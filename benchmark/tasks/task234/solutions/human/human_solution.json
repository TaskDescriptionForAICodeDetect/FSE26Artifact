[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<iomanip>\n\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ntypedef pair<P,double> C;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\n\n//for vector\nP unit(P p){return p / abs(p);}\ndouble dot(P x,P y){return real(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n//return seta A\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n//for circle\n\n//circle position relation\nint cpr(C a,C b){\n  double d = abs(a.fs-b.fs);\n  if(a.sc+b.sc + EPS < d)return -1;      //no cross point (outside)\n  if(b.sc+d + EPS < a.sc)return 1;       //no cross point (inside,B in A)\n  if(a.sc+d + EPS < b.sc)return 2;       //no cross point (inside,A in B)\n  return 0;                              //two cross point\n}\n\nvector<P> cp_cir_to_cir(C a, C b){\n  vector<P> v;\n  int pos = cpr(a,b);\n  if(pos==0){\n    double s = arg(b.sc,abs(b.fs-a.fs),a.sc);\n    P x = a.sc * unit(b.fs - a.fs);\n    v.pb(a.fs + rotate(x,s));\n    v.pb(a.fs + rotate(x,-s));\n  }else if(abs(pos) >= 3){\n    v.pb(a.fs + a.sc * unit(b.fs-a.fs));\n  }\n  return v;\n}\n\nint n;\ndouble x[10],y[10],l[10];\n\nbool check(double h){\n  C c[10];\n  for(int i=0;i<n;i++){\n    c[i] = make_pair( P(x[i],y[i]), sqrt(l[i]*l[i] - h*h) );\n  }\n\n  vector<P> v,tmp;\n  for(int i=0;i<n;i++){\n    v.pb(c[i].fs);\n    for(int j=i+1;j<n;j++){\n      tmp = cp_cir_to_cir(c[i],c[j]);\n      for(int k=0;k<tmp.size();k++)v.pb(tmp[k]);\n    }\n  }\n\n  for(int i=0;i<v.size();i++){\n    bool f = true;\n    for(int j=0;j<n;j++){\n      if(abs(v[i]-c[j].fs) > c[j].sc + EPS){\n\tf = false;\n\tbreak;\n      }\n    }\n    if(f)return true;\n  }\n  return false;\n}\n  \nint main(){\n  while(cin >> n,n){\n    double a=0, b=1e10;\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> l[i];\n      b = min(b,l[i]);\n    }\n\n    for(int i=0;i<100;i++){\n      double mid = (a+b)/2;\n      if(check(mid))a = mid;\n      else b = mid;\n    }\n    cout << fixed << setprecision(10) << a << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0 || a < 0 || a > l)continue;\n\t\t\t\tif (z < ans)ans = z;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\trep(k, j) {\n\t\t\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\tif (x[1][1] == 0) {\n\t\t\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t\t\t}\n\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\tint cc = ccw(P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]), P(a, b));\n\t\t\t\t\tif (cc == ccw(P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1]), P(a, b)) && cc == ccw(P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1]), P(a, b)))ans = c;\n\t\t\t\t\t//h.push_back({ a,b,c });\n\t\t\t\t\t/*bool f = 1;\n\t\t\t\t\trep(i, n) {\n\t\t\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  double d = abs(A.center() - B.center());\n  double rc = (d * d + A.radius() * A.radius() - B.radius() * B.radius()) / (2.0 * d);\n  double rs = sqrt(A.radius() * A.radius() - rc * rc);\n  Point diff = (B.center() - A.center()) / d;\n  ret.pb(A.center() + diff * Point(rc,  rs));\n  ret.pb(A.center() + diff * Point(rc, -rs));\n  return ret;\n}\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semieq(d, A.radius() + B.radius())) return  3;  // ?????\\\n  if(semige(d, A.radius() + B.radius())) return -3;  // ???????????????\n  return 4;  // ????????£?????????\n}\n\ninline bool operator < (Circle& A, Circle& B)\n{\n  return A.radius() != B.radius() ? A.radius() < B.radius() : A.center() < B.center();\n}\n\nconst int MAX_N = 12;\nint n;\ndouble x, y;\ndouble l[MAX_N];\nPoint p[MAX_N];\n\nbool C(double x)\n{\n  vector<Circle> c;\n  rep(i, n) c.pb(Circle(p[i], sqrt(l[i] * l[i] - x * x)));\n  rep(i, n) rep(j, i){\n    Circle A = c[i];\n    Circle B = c[j];\n    int det = intersectionDeterminationOfCC(A, B);\n    if(det < 3) continue;\n    vector<Point> vp = intersectionOfCC(A, B);\n    vrep(v, vp){\n      bool ok = true;\n      vrep(w, c) ok &= !semige(abs(*v - w->center()), w->radius());\n      if(ok) return true;\n    }\n  }\n\n  sort(ALL(c));\n  bool ok = true;\n  rep(i, n-1){\n      int det = intersectionDeterminationOfCC(c[i], c[i+1]);\n      ok &= (det == -1 || det == -2);\n  }\n  return ok;\n}\n\nint main()\n{\n  while(cin >> n, n){\n    double mn = (double)INF;\n    rep(i, n){\n      cin >> x >> y >> l[i];\n      p[i] = Point(x, y);\n      minup(mn, l[i]);\n    }\n\n    double left = 0.0;\n    double right = mn;\n    rep(_, 100){\n      double mid = (left + right) / 2.0;\n      if(C(mid)) left = mid;\n      else right = mid;\n    }\n\n    printf(\"%.15f\\n\", right);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(p.x, x), add(p.y, y));\n  }\n  P operator - (P p) {\n    return P(add(p.x, -x), add(p.y, -y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  //printf(\"%d:%d,%f,%f,%f\\n\",i,j,s,r[i],r[j]);\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p) {\n  //for (int i = 0; i < n; i++) if (ESP < (add((p - dir[i]).square(), -r[i] * r[i])) && 0.1 > (add((p - dir[i]).square(), -r[i] * r[i]))) printf(\"%d,%f]]]\\n\",i,(add((p - dir[i]).square(), -r[i] * r[i])));\n  for (int i = 0; i < n; i++) if (0.00001 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i],-h * h));\n    //printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      //printf(\"t:%d\\n\",t);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 + dir[j] * l1) * (1.0 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d)) return true;\n        if (canClear(ave - d)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t])) return true;\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n    //printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n    //printf(\"%d\\n\",(int)check(72.2251798));\n    //printf(\"%d\\n\",(int)check(71.954102));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%.7f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nint N;\nPoint p[10];\ndouble l[10],r[10];\nCircle c[10];\nbool f(int i,int j,int k)\n{\n\tif(intersect(c[i],c[j])==4)return false;\n\telse if(intersect(c[i],c[j])<=1)\n\t{\n\t\tif(intersect(c[i],c[k])==4||intersect(c[j],c[k])==4)return false;\n\t}\n\telse\n\t{\n\t\tpair<Point,Point>q=crosspoint(c[i],c[j]);\n\t\tif(!contain(c[k],q.first)&&!contain(c[k],q.second))return false;\n\t}\n\treturn true;\n}\nmain()\n{\n\twhile(cin>>N,N)\n\t{\n\t\tfor(int i=0;i<N;i++)cin>>p[i]>>l[i];\n\t\tdouble L=1,R=500;\n\t\tfor(int ccc=0;ccc<300;ccc++)\n\t\t{\n\t\t\tdouble h=(L+R)/2;\n\t\t\tbool flag=1;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(l[i]<h)\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr[i]=sqrt(l[i]*l[i]-h*h);\n\t\t\t\tc[i]=Circle(p[i],r[i]);\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tR=h;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(N>=3)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=i+1;j<N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=j+1;k<N;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!f(i,j,k)&&!f(j,k,i)&&!f(k,i,j))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(N==2)\n\t\t\t{\n\t\t\t\tif(intersect(c[0],c[1])==4)flag=0;\n\t\t\t}\n\t\t\tif(!flag)R=h;\n\t\t\telse L=h;\n\t\t}\n\t\tcout<<fixed<<setprecision(9)<<L<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst double INF = 1e9;\nconst double EPS = 1e-8;\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\nbool operator < (const Point & a, const Point & b) { return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag(); }\nbool operator > (const Point & a, const Point & b) { return !eq(a.real(), b.real()) ? a.real() > b.real() : a.imag() > b.imag(); }\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\ndouble dot(const Point & a, const Point & b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(const Point & a, const Point & b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(const Point & p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(const Point & p) { return sqrt(length2(p)); }\ndouble distance(const Point & a, const Point & b) { return length(a - b); }\nPoint unit(const Point & p) { return p / length(p); }\nPoint divide(Point a, Point b, double m, double n) {\n    return Point((n * a.X() + m * b.X()) / (m + n), (n * a.Y() + m * b.Y()) / (m + n));\n}\n// ??????????????????\nPoint normal_vector(Point a) { return Point(-a.Y(), a.X()); }\n\n// (a.X, a.Y, az) ??¨ (b.X, b.Y, bz) ????????¢?????????\ndouble distance3d(Point a, double az, Point b, double bz) {\n    return sqrt(length2(a - b) + pow(az - bz, 2));\n}\n\n// c : ?????? ??§??????????§???¢??§????§?ac or ?§?bc ???????§???§??????????????????\nbool is_obtuse(double a, double b, double c) {\n    bool ok = true;\n    swap(a, c);\n    ok &= (a * a + b * b - c * c) / (2 * a * b) >= 0;\n    swap(a, c);\n    swap(b, c);\n    ok &= (a * a + b * b - c * c) / (2 * a * b) >= 0;\n    return not ok;\n}\n\ndouble heron_formula(double a, double b, double c) {\n    if(a > b) swap(a, b);\n    if(b > c) swap(b, c);\n    assert(a + b >= c);\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// ac = la, bc = lb ???????§???¢abc???c?????????ab????????±?????????, ab???????????¨??????????????????????±???????\n// ????°??????????????????\\????????????????§???¢????????????\ntuple<Point, double> third_point_projection_of_triangle(Point a, Point b, double la, double lb) {\n    if(eq(a, b) and abs(la - lb) < EPS) return make_pair(a, la);\n    double lc = distance(a, b);    \n    assert(not is_obtuse(la, lb, lc));\n    double s = heron_formula(la, lb, lc);\n    double h = s / lc * 2;\n    double m = abs(la - h) > EPS ? sqrt(la * la - h * h) : 0;\n    double n = lc - m;\n    assert(m >= 0 and n >= 0);\n    return make_tuple(divide(a, b, m, n), h);\n}\n\n// a -> b ??????????°??????????\nPoint projection(Point a, Point b, const Point &p) {\n    double t = dot(p-a, a-b) / norm(a-b);\n    Point ret = (a - b) * t;\n    ret += a;\n    return ret;\n}\n\nclass Solver {\n  public:\n\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return 0;\n        vector<Point> P(N);\n        vector<double> H(N);\n        rep(i, N) cin >> P[i] >> H[i];\n\n        double ans = 0;\n        \n        rep(i, N) {\n            // 1\n            {                \n                bool ok = true;\n                rep(j, N) if(i != j) ok &= distance3d(P[i], H[i], P[j], 0) <= H[j] + EPS;\n                if(ok) set_max(ans, H[i]);\n            }\n            rep(j, N) if(j != i) {                \n                double c = distance(P[i], P[j]);\n                if(H[i] + H[j] <= c) continue;\n                if(is_obtuse(H[i], H[j], c)) continue;\n                Point p;\n                double h;\n                tie(p, h) = third_point_projection_of_triangle(P[i], P[j], H[i], H[j]);\n                //2 \n                {\n                    bool ok = true;\n                    rep(k, N) ok &= distance3d(p, h, P[k], 0) <= H[k] + EPS;\n                    if(ok) set_max(ans, h);\n                }\n\n                rep(k, N) if(i != k and j != k) {\n                    if(abs(dot(P[i] - P[j], P[k]) > EPS)) continue;                    \n                    Point a = normal_vector(P[j] - P[i]); // P[k] ??§?????£???????????????????????????\n                    Point pk = projection(p, a + p, P[k]); \n                    double hk = sqrt(H[k] * H[k] - length2(pk - P[k]));\n                    if(h + hk <= distance(p, pk)) continue;\n                    if(is_obtuse(h, hk, distance(p, pk))) continue;\n                    Point pp;\n                    double hh;\n                    tie(pp, hh) = third_point_projection_of_triangle(p, pk, h, hk);\n                    // 3\n                    {\n                        bool ok = true;\n                        rep(l, N) ok &= distance3d(pp, hh, P[l], 0) <= H[l] + EPS;\n                        if(ok) set_max(ans, hh);\n                    }\n                }\n            }\n            \n        }\n        printf(\"%lf\\n\", ans);\n        return 1;\n    }\n};\n\nint main() {\n    while(1) {\n        Solver s;\n        if(!s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\n \nint main() {\n    int n;\n    cin.sync_with_stdio(0);\n    while (cin >> n, n) {\n        va<int, 3> bl(n);\n        rep(i, n)rep(j, 3)cin >> bl[i][j];\n        //va<double, 3> h;\n        double ans = 1e9;\n        int mina = 0;\n        rep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n        ans *= ans;\n        rep(i,n){\n            rep(j,i){\n                double l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n                double a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n                double x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n                if (z < 0)continue;\n                if (z<ans&&a > 0 && a < l)ans = z;\n                rep(k, j) {\n                    double x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n                    double a, b, c;\n                    if (x[1][1] == 0) {\n                        if (x[0][1] == 0)continue;\n                        if (x[1][0]*x[0][1] - (x[1][1] )*x[0][0] == 0)continue;\n                        a = 1/ (2*(x[1][0]*x[0][1] - (x[1][1])*x[0][0]))*(x[1][2]*x[0][1] - x[1][1]  * x[0][2]);\n                        b = (x[0][2]*0.5 - a*x[0][0])*(1/ x[0][1]);\n                    }\n                    else {\n                        if (x[0][0]*x[1][1] - (x[0][1])*x[1][0] == 0)continue;\n                        a = 1/ (2*(x[0][0]*x[1][1] - (x[0][1] )*x[1][0]))*(x[0][2]*x[1][1] - x[0][1]* x[1][2]);\n                        b = (x[1][2] *0.5 - a*x[1][0]) *(1 / x[1][1]);\n                    }\n                    c = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n                    if (c < 0)continue;\n                    if (c >= ans)continue;\n                    int cc = ccw( P(a, b),P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                    if (cc == ccw(P(a, b),P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b),P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                }\n            }\n        }\n        cout << fixed << setprecision(7) << sqrt(ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 3> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2] )/l+l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#include<cmath>\nusing namespace std;\ntypedef double R;\ntypedef complex<R> P;\n\nstruct C{P c;R r;};\n\ndouble n, x, y, l;\nC c[108];\nC tc[108];\npair<P, P> cross_circles(C a, C b){\n  R d = abs(a.c - b.c);\n  R l = ((a.r*a.r - b.r*b.r) / d + d) / 2.0;\n  R h = sqrt(a.r*a.r - l*l);\n  P e = a.c + (b.c-a.c) * l / d;\n  P p = (b.c-a.c) * h / d * P(0, -1);\n  return make_pair(e + p, e - p);\n}\n\nbool able(R h){\n  for(int i = 0;i < n;i++){\n    tc[i] = c[i];\n    if(c[i].r < h)return false;\n    tc[i].r = sqrt(tc[i].r*tc[i].r - h*h);\n  }\n  \n  vector<P> points;\n\n  for(int i = 0;i < n;i++){\n    for(int j = i + 1;j < n;j++){\n      if(abs(tc[i].c - tc[j].c) >= tc[i].r + tc[j].r)continue;\n      if(abs(tc[i].c - tc[j].c) <= abs(tc[i].r - tc[j].r))continue;\n      pair<P, P> tmp = cross_circles(tc[i], tc[j]);\n      points.push_back(tmp.first);\n      points.push_back(tmp.second);\n    }\n    points.push_back(tc[i].c);\n  }\n\n  for(int i = 0;i < points.size();i++){\n    bool tmp = true;\n    P p = points[i];\n    for(int j = 0;j < n;j++){\n      if(abs(p - tc[j].c) > tc[j].r)tmp = false;\n    }\n    if(tmp == true){\n      return true;\n      \n    }\n  }\n  return false;  \n}\n\nbool solve(){\n  cin >> n;\n  if(n == 0)return false;\n  double bottom = 0.5, top = 300;\n  for(int i = 0;i < n;i++){\n    cin >> x >> y >> l;\n    c[i].c = P(x, y);\n    c[i].r = l;\n    top = min(top, l);\n  }\n  for(int i = 0;i < 1000;i++){\n    double mid = (bottom + top) / 2;\n    if(able(mid))bottom = mid;\n    else top = mid;\n  }\n  printf(\"%.10lf\\n\", bottom);\n  return true;\n}\n\nint main(){\n  while(solve());return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstatic const double eps = 1e-10;\ntypedef complex<double> point;\nstruct circle { point p; double r; };\ninline double sq(double x) { return x * x; }\n\npair<point, point> cross(const circle& c1, const circle& c2)\n{\n    double d = abs(c1.p - c2.p);\n    double rc = (sq(d) + sq(c1.r) - sq(c2.r)) / (2*d);\n    double rs = sqrt(sq(c1.r) - sq(rc));\n    point diff = (c2.p - c1.p) / d;\n    return make_pair(c1.p + diff * point(rc, rs),\n                     c1.p + diff * point(rc, -rs));\n}\n\nbool check_point(const vector<circle>& circles, point p)\n{\n    return all_of(begin(circles), end(circles),\n            [p](const circle& c){ return sq(c.r + eps) > norm(c.p - p); });\n}\n\nbool check(const vector<circle>& ropes, double h)\n{\n    vector<circle> circles;\n    for (const auto& c : ropes) {\n        double r = sqrt(sq(c.r) - sq(h));\n        circles.push_back({ c.p, r });\n    }\n\n    for (int i = 0; i < (int)circles.size(); ++i) {\n        const circle& c1 = circles[i];\n        if (check_point(circles, c1.p))\n            return true;\n\n        for (int j = i + 1; j < (int)circles.size(); ++j) {\n            const circle& c2 = circles[j];\n            double sqd = norm(c1.p - c2.p);\n            if (sq(c1.r + c2.r) <= sqd)\n                return false;\n            auto cp = cross(c1, c2);\n            if (check_point(circles, cp.first))\n                return true;\n            if (check_point(circles, cp.second))\n                return true;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n, n) {\n        double lo = 0, hi = 1e10;\n        vector<circle> ropes;\n\n        for (int i = 0; i < n; ++i) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            ropes.push_back({ point(x, y), r });\n            hi = min(hi, r);\n        }\n\n        for (int i = 0; i < 100; ++i) {\n            double mid = (lo + hi) / 2;\n            if (check(ropes, mid))\n                lo = mid;\n            else\n                hi = mid;\n        }\n\n        cout.precision(15);\n        cout << hi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  //cerr<<\"judge::\"<<m<<\" \";\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  //cerr<<\" val \";\n  bool hoge = true;\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m)+EPS)continue;\n      if(dist+in[j].R(m)<=in[i].R(m)+EPS)continue;\n      hoge = false;\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return hoge;\n}\n\ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return m;\n  if(judge(m)){\n    //cerr<<\"true\"<<endl;\n    return req(m,r);\n  }else{\n    //cerr<<\"false\"<<endl;\n    return req(l,m);\n  }\n}\n\ndouble solve(){\n  double ans = req(1.0,400.0);\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];       \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-10;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            bool hoge=true;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>dis+EPS) hoge=false;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    if(val>1) val=1;\n                    if(val<-1) val=-1;\n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+1e-8){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            able=able|hoge;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<setprecision(10)<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LIMIT 50\nint n; long double x[100], y[100], l[100];\nlong double dst(long double ax, long double ay, long double az, long double bx, long double by, long double bz) {\n\treturn sqrtl((ax - bx)*(ax - bx) + (ay - by)*(ay - by) + (az - bz)*(az - bz));\n}\nlong double max_amari(long double ax, long double ay, long double az) {\n\tlong double maxn = 1000000000.0l;\n\tfor (int i = 0; i < n; i++) {\n\t\tmaxn = min(maxn, l[i] - dst(ax, ay, az, 0, x[i], y[i]));\n\t}\n\treturn maxn;\n}\nlong double solve2(long double h, long double X) {\n\tlong double L1 = -1000000.0l, R1 = 1000000.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = max_amari(h, X, c1);\n\t\tlong double m2 = max_amari(h, X, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\treturn maxn;\n}\nbool solve(long double h) {\n\tlong double L1 = -1000000.0l, R1 = 1000000.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = solve2(h, c1);\n\t\tlong double m2 = solve2(h, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\tif (maxn > -1e-14)return true;\n\treturn false;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> x[i] >> y[i] >> l[i];\n\t\tlong double L = 0.0l, R = 1000000.0l, M;\n\t\tfor (int i = 0; i < LIMIT; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tbool a1 = solve(M);\n\t\t\tif (a1 == true)L = M;\n\t\t\tif (a1 == false)R = M;\n\t\t}\n\t\tprintf(\"%.15Lf\\n\", M);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst double eps=1e-9;\ntypedef complex<double> P;\n\nvector<P> intersection(P a,double ra,P b,double rb){\n  double c=abs(b-a);\n  double costheta=-(rb*rb-ra*ra-c*c)/2/ra/c;\n  if(-1<=costheta&&costheta<=1){\n    double theta=acos(costheta);\n    double ang=arg(b-a);\n    return {a+polar(ra,ang+theta),a+polar(ra,ang-theta)};\n  }else{\n    return {};\n  }\n}\n\nbool includes(P a,double r,P b){\n  return abs(a-b)<=r+eps;\n}\n\ndouble sst(double a,double b){\n  return sqrt(a*a-b*b);\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int x[10],y[10],l[10];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>l[i];\n    }\n    if(n==1){\n      cout<<l[0]<<endl;\n    }else{\n      double lo=0,hi=*min_element(begin(l),begin(l)+n);\n      for(int i=0;i<99;i++){\n\tdouble m=(lo+hi)/2;\n\tbool is=false;\n\tauto all_include=[&](P p){\n\t  bool f=false;\n\t  for(int o=0;o<n;o++){\n\t    f|=!includes(P(x[o],y[o]),sst(l[o],m),p);\n\t  }\n\t  return !f;\n\t};\n\tfor(int j=0;j<n;j++){\n\t  is|=all_include(P(x[j],y[j]));\n\t  for(int k=j+1;k<n;k++){\n\t    auto it=intersection(P(x[j],y[j]),sst(l[j],m),P(x[k],y[k]),sst(l[k],m));\n\t    for(auto e:it){\n\t      is|=all_include(e);\n\t    }\n\t  }\n\t}\n\tif(is){\n\t  lo=m;\n\t}else{\n\t  hi=m;\n\t}\n      }\n      cout<<fixed<<lo<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define foreach(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\nPoint operator/(Point p,double c){\n\treturn Point(p.x/c,p.y/c);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble radius;\n\tCircle(){}\n\tCircle(Point c,double r):center(c),radius(r){}\n\tCircle(double x,double y,double r):center(x,y),radius(r){}\n};\nbool operator==(Circle a,Circle b){\n\treturn a.center==b.center && abs(a.radius-b.radius)<EPS;\n}\n\nint IntersectCC(Circle c1,Circle c2){\n\tif(c1==c2)\n\t\treturn INFTY;\n\tdouble r1=c1.radius,r2=c2.radius,d=Abs(c1.center-c2.center);\n\tif(d>r1+r2+EPS || d<abs(r1-r2)-EPS)\n\t\treturn 0;\n\tif(abs(d-(r1+r2))<EPS || abs(d-abs(r1-r2))<EPS)\n\t\treturn 1;\n\treturn 2;\n}\n\npair<Point,Point> InterPointCC(Circle c1,Circle c2){\n\tPoint p1=c1.center,p2=c2.center;\n\tdouble r1=c1.radius,r2=c2.radius;\n\tdouble d=Abs(p1-p2);\n\tdouble a=(d*d+r1*r1-r2*r2)/(2*d);\n\tdouble s=sqrt(r1*r1-a*a);\n\treturn mp(p1+a/d*(p2-p1)+s*Rot((p2-p1)/d,PI/2),\n\t\t\t  p1+a/d*(p2-p1)-s*Rot((p2-p1)/d,PI/2));\n}\n\nbool ok(const vi& xs,const vi& ys,const vi& ls,double z)\n{\n\tint n=xs.size();\n\tvd rs(n);\n\trep(i,n) rs[i]=sqrt(ls[i]*ls[i]-z*z);\n\t\n\tvector<Point> ps;\n\trep(i,n) ps.push_back(Point(xs[i],ys[i]));\n\t\n\trep(i,n) repi(j,i+1,n){\n\t\tCircle c1(xs[i],ys[i],rs[i]),c2(xs[j],ys[j],rs[j]);\n\t\tint inter=IntersectCC(c1,c2);\n\t\tassert(inter!=INFTY);\n\t\tif(inter>=1){\n\t\t\tdouble r1=c1.radius,r2=c2.radius;\n\t\t\tdouble d=Abs(c2.center-c1.center);\n\t\t\tdouble cos_t=(r2*r2-r1*r1-d*d)/(2*r1*d);\n\t\t\tps.push_back(c1.center+r1*cos_t/d*(c2.center-c1.center));\n\t\t}\n\t\tif(inter==2){\n\t\t\tauto temp=InterPointCC(c1,c2);\n\t\t\tps.push_back(temp.first);\n\t\t\tps.push_back(temp.second);\n\t\t}\n\t}\n\t\n\tfor(Point p:ps){\n\t\tbool ok=true;\n\t\trep(i,n)\n\t\t\tok&=Abs(p-Point(xs[i],ys[i]))<rs[i]+EPS;\n\t\tif(ok) return true;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvi xs(n),ys(n),ls(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i]>>ls[i];\n\t\t\n\t\tdouble lo=0,hi=*min_element(all(ls));\n\t\trep(_,52){\n\t\t\tdouble z=(lo+hi)/2;\n\t\t\tif(ok(xs,ys,ls,z))\n\t\t\t\tlo=z;\n\t\t\telse\n\t\t\t\thi=z;\n\t\t}\n\t\tdouble res=(lo+hi)/2;\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nclass Task{\npublic:\n\tint y,x;\n\tint c,M;\n\tTask(int y,int x,int c,int M):y(y),x(x),c(c),M(M){}\n\tbool operator < (const Task& r) const{\n\t\tif(c!=r.c)return c<r.c;\n\t\treturn M<r.M;\n\t}\n};\n\n\n\tint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ndouble INF=1e16;\nclass Main{\npublic:\n\t\n\tint n;\n\tvector<double> xs,ys,ls;\n\tbool input(){\n\t\tcin >>n;if(n==0)return false;\n\t\txs=vector<double>(n);ys=vector<double>(n);ls=vector<double>(n);\n\t\tREP(i,n) cin >> xs[i] >> ys[i] >> ls[i];\n\t\treturn true;\n\t}\n\n\tdouble getM(double x){\n\t\tdouble yl=-200,yr=200;\n\t\tdouble Mv=-INF;\n\t\twhile(yr-yl>1e-9){\n\t\t\tdouble yml=(2*yl+yr)/3,ymr=(yl+2*yr)/3;\n\t\t\t//DUMP(yml);\n\t\t\tdouble lv=INF,rv=INF;\n\t\t\tREP(i,n){\n\t\t\t\tdouble d=pow(ls[i],2)-(pow(xs[i]-x,2)+pow(ys[i]-yml,2));\n\t\t\t\tlv=min(lv,d);\n\t\t\t}\n\t\t\tREP(i,n){\n\t\t\t\tdouble d=pow(ls[i],2)-(pow(xs[i]-x,2)+pow(ys[i]-ymr,2));\n\t\t\t\trv=min(rv,d);\n\t\t\t}\n\t\t\t// DUMP(x);DUMP(yml);DUMP(ymr);DUMP(BR);\n\t\t\t// DUMP(lv);DUMP(rv);DUMP(BR);\n\t\t\tMv=max(max(lv,rv),Mv);\n\t\t\tif(lv<rv)yl=yml;\n\t\t\telse yr=ymr;\n\t\t}\n\t\treturn Mv;\n\t}\n\n\n\tvoid run(){\n\t\twhile(input()){\n\t\t\tdouble xl=-200,xr=200;\n\t\t\tdouble Mv=0;\n\t\t\twhile(xr-xl>1e-9){\n\t\t\t\tdouble xml=(2*xl+xr)/3,xmr=(xl+2*xr)/3;\n\t\t\t\tdouble lv=getM(xml),rv=getM(xmr);\n\t\t\t\t// DUMP(xml);DUMP(xmr);DUMP(BR);\n\t\t\t\t// DUMP(lv);DUMP(rv);DUMP(BR);\n\t\t\t\tMv=max(max(lv,rv),Mv);\n\t\t\t\tif(lv<rv)xl=xml;\n\t\t\t\telse xr=xmr;\n\t\t\t}\n\t\t\tcout <<sqrt(Mv)<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n \tcout <<fixed<<setprecision(15);\t\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst double EPS = 1e-9;\n#define SQR(x) ((x) * (x))\n\nint main()\n{\n  int N, X[10], Y[10], L[10];\n  double D[10][10];\n\n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; ++i) {\n      scanf(\"%d %d %d\", &X[i], &Y[i], &L[i]);\n    }\n    for(int i = 0; i < N; i++) {\n      for(int j = i + 1; j < N; j++) {\n        D[i][j] = sqrt(SQR(X[i] - X[j]) + SQR(Y[i] - Y[j]));\n      }\n    }\n\n    auto check = [&](double val)\n    {\n      vector< double > R;\n      for(int i = 0; i < N; ++i) {\n        R.emplace_back(sqrt(SQR(L[i]) - SQR(val)));\n      }\n      vector< pair< double, double > > P;\n      for(int i = 0; i < N; ++i) {\n        P.emplace_back(X[i], Y[i]);\n      }\n      for(int i = 0; i < N; ++i) {\n        for(int j = i + 1; j < N; ++j) {\n          if(abs(R[i] - R[j]) < D[i][j] && D[i][j] < R[i] + R[j]) {\n            double a = atan2(Y[j] - Y[i], X[j] - X[i]);\n            double theta = acos((SQR(D[i][j]) + SQR(R[i]) - SQR(R[j])) / (2 * D[i][j] * R[i]));\n            P.emplace_back(X[i] + R[i] * cos(a + theta), Y[i] + R[i] * sin(a + theta));\n            P.emplace_back(X[i] + R[i] * cos(a - theta), Y[i] + R[i] * sin(a - theta));\n          }\n        }\n      }\n      for(auto &&e : P) {\n        double x, y;\n        tie(x, y) = e;\n        bool f = true;\n        for(int i = 0; i < N; i++) {\n          if(sqrt(SQR(X[i] - x) + SQR(Y[i] - y)) > R[i] + EPS) f = false;\n        }\n        if(f) return (true);\n      }\n      return (false);\n    };\n\n    double low = 1.0, high = *min_element(L, L + N);\n\n    for(int i = 0; i < 25; ++i) {\n      double mid = (low + high) / 2.0;\n      if(check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.10lf\\n\", low);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n\nconst double EPS = 1e-9;\ntypedef long double Real;\ntypedef complex<Real> Point;\n\ninline Real dot(const Point &a, const Point &b) {\n    return a.real() * a.real() + b.imag() * b.imag();\n}\n\nstruct Circle {\n    Point p;\n    Real r;\n    Circle(Point p = 0, Real r = 0) : p(p), r(r) {;}\n};\n\nstruct Line : public vector<Point> {\n    Line(Point a = 0, Point b = 0) {\n        push_back(a); push_back(b);\n    }\n};\n\nPoint projection(Line l, Point p) {\n    Real t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\n\nvector<Point> crosspointLC(Line l, const Circle &c){\n    vector<Point> res;\n    Point p = projection(l, c.p);\n    Real d = abs(p - c.p);\n    Real t = sqrt(c.r * c.r - d * d);\n    if(isnan(t)) return res;\n    Point v = (l[1] - l[0]) / abs(l[1] - l[0]);\n    res.push_back(p - v*t);\n    if(t > EPS) res.push_back(p + v*t);\n    return res;\n}\n\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2){\n    vector<Point> res;\n    Real d = abs(c1.p - c2.p);\n    if(max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) return res;\n    Real x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point p = c1.p + (c2.p - c1.p) / d * x;\n    Point v = (c1.p - c2.p) * Point(0.0, 1.0);\n    return crosspointLC(Line(p, p + v), c1);\n}\n\n\nint n;\nCircle cs[200];\n#define sq(x) ((x)*(x))\n\nbool isok(Point p, Real h){\n    rep(i,n) if(norm(p-cs[i].p) + sq(h) > sq(cs[i].r) + EPS) return false;\n    return true;\n}\n\nbool check(Circle c1, Circle c2, Real h) {\n    c1.r = sqrt(sq(c1.r) - sq(h));\n    c2.r = sqrt(sq(c2.r) - sq(h));\n    vector<Point> ps = crosspointCC(c1, c2);\n    for(auto p : ps) {\n        if(isok(p,h)) return true;\n    }\n    return false;\n}\n\nbool check(Real h){\n    rep(i,n){\n        if(isok(cs[i].p, h)) return true;\n        rep(j,n) if(check(cs[i], cs[j], h)) return true;\n    }\n    return false;\n}\n\nint main() {\n    while(cin >> n, n) {\n        rep(i, n) {\n            Real x,y,l;\n            cin >> x >> y >> l;\n            cs[i] = Circle(Point(x, y), l);\n        }\n        Real l = 1, r = 500;\n        rep(q,200) {\n            Real m = (l+r)/2;\n            if(check(m)) l = m; else r = m;\n        }\n        printf(\"%.06f\\n\", (double)l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconst double EPS = 1e-9;\nconst int INF = 1000000;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x = 0.0, double y = 0.0):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn point(INF, INF); // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nint main() {\n\tfor(int n; scanf(\"%d\", &n), n;) {\n\t\tvector<circle> cs;\n\t\tcs.reserve(n);\n\t\tvector<point> candidates;\n\t\tcandidates.reserve(4 * n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, l;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &l);\n\t\t\tcs.push_back(circle(point(x, y), l));\n\t\t\tcandidates.push_back(cs[i].c);\n\t\t}\n\n\t\tvector<segment> segs;\n\t\tsegs.reserve(100000);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(!intersect(cs[i], cs[j]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tvector<point> ps = crosspoint(cs[i], cs[j]);\n\t\t\t\tif(ps.size() == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcandidates.push_back((ps[0] + ps[1]) / 2.0);\n\t\t\t\tsegs.push_back(segment(ps[0], ps[1]));\n\t\t\t}\n\t\t}\n\n\t\tconst int m = segs.size();\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tfor(int j = i + 1; j < m; ++j) {\n\t\t\t\tpoint p = crosspoint(segs[i], segs[j]);\n\t\t\t\tif(p.x >= INF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcandidates.push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1.0;\n\t\tfor(int i = 0; i < (int)candidates.size(); ++i) {\n\t\t\tdouble mn = INF;\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tconst double d = abs(cs[j].c - candidates[i]);\n\t\t\t\tchmin(mn, cs[j].r * cs[j].r - d * d);\n\t\t\t}\n\t\t\tchmax(ans, mn);\n\t\t}\n\n\t\tprintf(\"%.7lf\\n\", sqrt(ans));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\ndouble const EPS = 1e-9;\n\ntypedef double Real;\ntypedef complex<Real> P;\ntypedef vector<P> line;\n\nstruct circle {\n  P p; Real r;\n};\n\ndouble sq(double x) {\n  return x * x;\n}\n\nbool out(circle& a, circle& b) {\n  return abs(a.p - b.p) > a.r + b.r;// + EPS;\n}\n\nbool is_intersect(circle& a, circle& b) {\n  return abs(a.p - b.p) <= a.r + b.r && abs(a.p - b.p) + min(a.r, b.r) >= max(a.r, b.r);\n}\n\nbool contains(circle& a, circle& b) {\n  return abs(a.p - b.p) + min(a.r, b.r) < max(a.r, b.r);\n}\n\nbool contains(circle& c, P& p) {\n  return abs(c.p - p) <= c.r + EPS;\n}\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nbool is_parallel(line const& l, line const& m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\nP crosspoint(line const& l, line const& m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false && \"PRECONDITION NOT SATISFIED\");\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(circle c1, circle c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  Real const d = abs(c2.p - c1.p);\n  Real const alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  Real const beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n\nint N;\ndouble x[11], y[11], l[11];\n\nbool compare(double h) {\n  vector<circle> cs;\n  rep(i, N) {\n    if(l[i] < h - EPS) return false;\n    cs.push_back({{x[i], y[i]}, sqrt(sq(l[i]) - sq(h))});\n  }\n  rep(i, N) REP(j, i+1, N) {\n    if(out(cs[i], cs[j])) return false;\n  }\n\n  rep(i, N) REP(j, i+1, N) REP(k, j+1, N) {\n    auto p = crosspoint(cs[i], cs[j]);\n    auto q = crosspoint(cs[j], cs[k]);\n    auto r = crosspoint(cs[k], cs[i]);\n    if(!contains(cs[k], p.first) && !contains(cs[k], p.second) &&\n       !contains(cs[i], q.first) && !contains(cs[i], q.second) &&\n       !contains(cs[j], r.first) && !contains(cs[j], r.second) &&\n       !contains(cs[i], cs[j]) && !contains(cs[j], cs[k]) && !contains(cs[k], cs[i])) return false;\n  }\n  \n  return true;\n}\n\ndouble solve() {\n  double l = 0.0, r = 1e10;\n  rep(_, 150) {\n    double m = (l + r) / 2.0;\n    (compare(m) ? l : r) = m;\n  }\n  return l;\n}\n\nint main() {\n\n  for(; cin >> N && N;) {\n    rep(i, N) {\n      cin >> x[i] >> y[i] >> l[i];\n    }\n    printf(\"%.10f\\n\", solve());\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i, a) for(int i=0;i<(int)(a);i++)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n\n\ntypedef double D;\nconst D EPS = 1e-12;\nconst D INF = 1e+10;\ntypedef complex<D> P;\n\nnamespace std{\n  bool operator<(const P &a, const P &b){\n    return real(a) == real(b) ? imag(a) < imag(b): real(a) < real(b);\n  }\n}\n\ndouble x[10];\ndouble y[10];\ndouble l[10];\nint N;\n\ndouble checked(const double X, const double Y){\n  double h = INF;\n  for(int i=0;i<N;i++){\n    D a = (x[i]-X)*(x[i]-X) + (y[i]-Y)*(y[i]-Y);\n    // cout << X << \" \" << Y << \" \" << a << \" \" << l[i]*l[i] << endl;\n    // if(a > l[i]*l[i] - EPS){\n    //   h = 0;\n    //   break;\n    // }q\n    // cout << l[i]*l[i] << \" \" << a << \" \" << sqrt((l[i]*l[i]) - a) << endl;\n    h = min(h, l[i]*l[i] - a);\n  }\n  return h;\n}\n\ndouble Ck(const double X){\n  double miny = -100;\n  double maxy =  100;\n  for(int i=0;i<200;i++){\n    double mid1 = (maxy - miny) / 3 + miny;\n    double mid2 = maxy - (maxy - miny) / 3;\n    //    cout << mid1 << \" \" << checked(X, mid1) << \" \" << mid2 << \" \" << checked(X, mid2) << endl;\n    if(checked(X, mid1) > checked(X, mid2)){\n      maxy = mid2;\n    }else{\n      miny = mid1;\n    }\n  }\n  // cout << X << \" \" << miny << \" \" << checked(X, miny) << endl;\n  return checked(X, miny);\n}\n  \nint main(){\n  while(cin >> N, N){\n    rep(i, N){\n      cin >> x[i] >> y[i] >> l[i];\n    }\n\n    double minx = -100;\n    double maxx =  100;\n    for(int i=0;i<200;i++){\n      double mid1 = (maxx - minx) / 3 + minx;\n      double mid2 = maxx - (maxx - minx) / 3;\n      // cout << mid1 << \" \" << Ck(mid1) << \" \" << mid2 << \" \" << Ck(mid2) << endl;\n      if(Ck(mid1) > Ck(mid2)){\n\tmaxx = mid2;\n      }else{\n\tminx = mid1;\n      }\n    }\n    printf(\"%.10lf\\n\", sqrt(Ck(maxx)));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 10;\n  double ans=1;\n  double tans=800;\n\n  vector<double> app;\n  \n  rep(i,n)rep(j,i){\n    /*\n      dd=sqrt(dx*dx+dy*dy);\n      sqrt(r1*r1-x*x)+sqrt(r2*r2-x*x)=dd\n      sqrt(r1*r1-x*x)=dd-sqrt(r2*r2-x*x)\n      r1*r1-x*x=dd^2-2*dd*sqrt(r2*r2-x*x)+r2*r2-x*x\n      r1*r1=dd^2-2*dd*sqrt(r2*r2-x*x)+r2*r2\n      r1*r1-r2*r2-dd^2=-2*dd*sqrt(r2*r2-x*x)\n      (r1*r1-r2*r2-dd^2)^2=4*dd*dd*(r2*r2-x*x);\n      (r1*r1-r2*r2-dd^2)^2/4/dd/dd=(r2*r2-x*x);\n      x*x=(r2*r2-(r1*r1-r2*r2-dd^2)^2/4/dd/dd);      \n     */\n    double dx=x[i]-x[j];\n    double dy=y[i]-y[j];\n    double dd=sqrt(dx*dx+dy*dy);\n    app.pb(sqrt(l[j]*l[j]-pow(l[i]*l[i]-l[j]*l[j]-dd*dd,2)/4/dd/dd));\n    //if(dd >= l[i]+l[j]) continue;\n  }\n  \n  //if(n>1) ans=tans;\n  \n  while(len > 5e-9){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-2e-4;\n  }\n\n  sort(ALL(app));\n  if(!app.empty() && app[app.size()-1]>=ans){\n    double p=*lower_bound(ALL(app),ans);\n    if(ans+2e-4 > p) ans=p;\n  }\n  \n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n\nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\ndouble heron(double a, double b, double c)\n{\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n\treturn sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n\ntuple<double, double, double> com(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn a;\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn b;\n\t}\n\telse {\n\t\tdouble l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n\t\tdouble d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n\t\tdouble d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n\t\treturn tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n\t}\n}\n\ndouble two(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn (double)get<2>(a);\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn (double)get<2>(b);\n\t}\n\telse {\n\t\tdouble d = sqrt(disdis(a, b));\n\t\treturn heron(get<2>(a), get<2>(b), d) * 2 / d;\n\t}\n}\n\ndouble three(const tuple<double, double, double>& a, const tuple<double, double, double>& b, const tuple<double, double, double>& c)\n{\n\ttuple<double, double, double> temp;\n\n\tif (ISLOOSE(a, b) && ISLOOSE(a, c))\n\t\treturn get<2>(a);\n\tif (ISLOOSE(b, a) && ISLOOSE(b, c))\n\t\treturn get<2>(b);\n\tif (ISLOOSE(c, a) && ISLOOSE(c, b))\n\t\treturn get<2>(c);\n\n\tif (ISLOOSE(temp = com(a, b), c))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(b, c), a))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(c, a), b))\n\t\treturn get<2>(temp);\n\n\treturn heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n\t\t* 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n\nint main()\n{\n\tint n;\n\tdouble res;\n\tcout << fixed << setprecision(7);\n\twhile (cin >> n, n) {\n\t\tvector< tuple<double, double, double> > str(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << (double)get<2>(str[0]) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcout << two(str[0], str[1]) << endl;\n\t\t}\n\t\telse {\n\t\t\tres = 100000000.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tres = min(res, three(str[i], str[j], str[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct Rope{\n\tdouble x;\n\tdouble y;\n\tdouble l;\n};\nint n;\nRope r[10];\n\ndouble balloon_H(double X, double Y){\n\tdouble ans = 1e9;\n\tfor (int i = 0; i < n; i++){\n\t\tdouble h = r[i].l*r[i].l - (r[i].x - X)*(r[i].x - X) -(r[i].y - Y)*(r[i].y - Y);\n\t\tif (ans>h)ans = h;\n\t}\n\t\n\treturn ans;\n}\ndouble searchy(double x){\n\tdouble min = -100.0;\n\tdouble max = 100.0;\n\tfor (int i = 0; i < 200; i++){\n\t\tdouble div1 = (min * 2 + max) / 3;\n\t\tdouble div2 = (min + 2 * max) / 3;\n\t\tif (balloon_H(x, div1) < balloon_H(x, div2))\n\t\t\tmin = div1;\n\t\telse\n\t\t\tmax = div2;\n\t}\n\treturn balloon_H(x,min);\n}\nint main() {\n\twhile (cin >> n, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> r[i].x >> r[i].y >> r[i].l;\n\t\t}\n\t\tdouble e = 0.00001f;\n\t\tdouble min = -100.0;\n\t\tdouble max = 100.0;\n\n\t\tfor (int i = 0; i < 200;i++){\n\t\t\tdouble div1 = (min * 2 + max) / 3;\n\t\t\tdouble div2 = (min + 2 * max) / 3;\n\t\t\tif (searchy(div1) < searchy(div2))\n\t\t\t\tmin = div1;\n\t\t\telse\n\t\t\t\tmax = div2;\n\t\t}\n\t\t\n\t\tprintf(\"%.7f\\n\", sqrt(searchy(min)));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02;\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\tx02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n  \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n  \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n  \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<float, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 100;\n  double ans=1;\n  while(len > 1e-6){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-1e-4;\n  }\n\n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=50;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h-EPS);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq*=conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b))res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 0;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\t//h.push_back({ a,b,c });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c*c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, c);\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2] )/l+l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\t//h.push_back({ x,y,z });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((x - bl[i][0])*(x - bl[i][0]) + (y - bl[i][1])*(y - bl[i][1]) + z*z > bl[i][2] * bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, z);\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\t//h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t\tbool f = 1;\n\t\t\trep(j, n) {\n\t\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, bl[i][2]);\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\trep(k, j) {\n\t\t\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\tif (x[1][1] == 0) {\n\t\t\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t\t\t}\n\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\tint cc = ccw(P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]), P(a, b));\n\t\t\t\t\tif (cc == ccw(P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1]), P(a, b)) && cc == ccw(P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1]), P(a, b)))ans = c;\n\t\t\t\t\t//h.push_back({ a,b,c });\n\t\t\t\t\t/*bool f = 1;\n\t\t\t\t\trep(i, n) {\n\t\t\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint n;\ndouble x[10], y[10], l[10];\n\ndouble search(double X, double Y){\n\tdouble res = 1e+9;\n\tfor(int i = 0; i < n; i++){\n\t\tdouble h = l[i] * l[i] - ((X - x[i]) * (X - x[i])) - ((Y - y[i]) * (Y - y[i]));\n\t\tres = min(res, h);\n\t}\n\treturn res;\n}\n\ndouble searchY(double X){\n\tdouble left = -100.0, right = 100.0;\n\tfor(int i = 0; i < 200; i++){\n\t\tdouble mid1 = (2 * left + right) / 3;\n\t\tdouble mid2 = (left + 2 * right) / 3;\n\t\tif( search(X, mid1) > search(X, mid2) ){\n\t\t\tright = mid2;\n\t\t}else{\n\t\t\tleft = mid1;\n\t\t}\n\t}\n\treturn search(X, left);\n}\n\ndouble searchXY(double left = -100.0, double right = 100.0){\n\tfor(int i = 0; i < 200; i++){\n\t\tdouble mid1 = (2 * left + right) / 3;\n\t\tdouble mid2 = (left + 2 * right) / 3;\n\t\tif( searchY(mid1) > searchY(mid2) ){\n\t\t\tright = mid2;\n\t\t}else{\n\t\t\tleft = mid1;\n\t\t}\n\t}\n\treturn searchY(left);\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> l[i];\n\t\tdouble ans = sqrt(searchXY());\n\t\tprintf(\"%.07f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-bl[i][2] + bl[j][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-bl[i][2] + bl[k][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1]) == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t\tif (c<13.03&&c>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t\tif (z<13.03&&z>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nstruct S{\n  P s,t;\n  S(P s=P(),P t=P()): s(s),t(t) {}\n};\nstruct C{\n  P p;\n  double r;\n  C(P p=P(),double r=0):p(p),r(r){}\n};\n \n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \ndouble Sqrt(double a){\n  if(a<0)return 0;\n  return sqrt(a);\n}\n\nbool isIntersect(C a,C b){\n  double k=abs(a.p-b.p);\n  return (a.r+b.r>=k-eps&& abs(a.r-b.r)<=k+eps);\n}\n\nP crossPoint(C a,C b){\n  P base=b.p-a.p;\n  double k=(-b.r*b.r+a.r*a.r+norm(base));\n  double w=k/(2.0*abs(base)),h=Sqrt(a.r*a.r-w*w);\n  base/=abs(base);\n  return a.p+base*P(w,h);\n}\n\n\nbool isIntersect(vector<C> &vec){\n  vector<P> t;\n  for(int i=0;i<(int)vec.size();i++){\n    t.push_back(vec[i].p);\n    for(int j=0;j<i;j++){\n      if(isIntersect(vec[i],vec[j])){\n        t.push_back(crossPoint(vec[i],vec[j]));\n        t.push_back(crossPoint(vec[j],vec[i]));\n      }\n    }\n  }\n  for(int i=0;i<(int)t.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)vec.size();j++)\n      if(vec[j].r*vec[j].r+eps<norm(vec[j].p-t[i]))flg=false;\n    if(flg)return true;\n  }\n  return false;\n}\n\nint n;\nvector<P> t;\nvector<double> u;\n\ndouble check(double M){\n  vector<C> nt(n);\n  for(int i=0;i<n;i++){\n    nt[i].p=t[i];\n    nt[i].r=Sqrt(u[i]*u[i]-M*M);\n  }\n  return isIntersect(nt);\n}\n\ndouble solve(){\n  double L=0,R=1e8,M;\n  for(int i=0;i<n;i++)R=min(R,u[i]);\n  \n  for(int i=0;i<1000;i++){\n    M=(L+R)/2;\n    if(check(M))L=M;\n    else R=M;\n  }\n  \n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    t.clear();t.resize(n);\n    u.clear();u.resize(n);\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y>>u[i];\n      t[i]=P(x,y);\n    }\n    printf(\"%.10f\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n \nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<int, int, int>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\nint disdis(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    return (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n \ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2;\n    return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n \ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n    return sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n \ntuple<double, double, double> com(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return a;\n    }\n    else if (ISLOOSE(b, a)) {\n        return b;\n    }\n    else {\n        double l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n        double d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n        double d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n        return tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n    }\n}\n \ndouble two(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return (double)get<2>(a);\n    }\n    else if (ISLOOSE(b, a)) {\n        return (double)get<2>(b);\n    }\n    else {\n        double d = sqrt(disdis(a, b));\n        return heron(get<2>(a), get<2>(b), d) * 2 / d;\n    }\n}\n \ndouble three(const tuple<int, int, int>& a, const tuple<int, int, int>& b, const tuple<int, int, int>& c)\n{\n    tuple<double, double, double> temp;\n \n    if (ISLOOSE(a, b) && ISLOOSE(a, c))\n        return get<2>(a);\n    if (ISLOOSE(b, a) && ISLOOSE(b, c))\n        return get<2>(b);\n    if (ISLOOSE(c, a) && ISLOOSE(c, b))\n        return get<2>(c);\n \n    if (ISLOOSE(temp = com(a, b), c))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(b, c), a))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(c, a), b))\n        return get<2>(temp);\n \n    return heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n        * 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n \nint main()\n{\n    int n;\n    double res;\n\tcout << fixed << setprecision(7);\n    while (cin >> n, n) {\n        vector< tuple<int, int, int> > str(n);\n        for (int i = 0; i < n; i++) {\n            cin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n        }\n        if (n == 1) {\n            cout << (double)get<2>(str[0]) << endl;\n        }\n        else if (n == 2) {\n            cout << two(str[0], str[1]) << endl;\n        }\n        else {\n            res = 100000000.0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    for (int k = j + 1; k < n; k++) {\n                        res = min(res, three(str[i], str[j], str[k]));\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\nconst double EPS = 1e-6;\n\ndouble x[11], y[11], l[11];\n\ndouble square(double X) {return X*X;}\n\ndouble calc(int n, double X, double Y) {\n    double ret = 1e9;\n    for (int i = 0; i < n; i++) {\n        ret = min(ret, /*sqrt*/(square(l[i]) - square(x[i]-X) - square(y[i]-Y)));\n    }\n    return ret;\n}\n\ndouble searchY(int n, double x) {\n    double left = -100, right = 100;\n    for (int t = 0; t < 200; t++) {\n        double m1 = (2*left+right) / 3;\n        double m2 = (left+2*right) / 3;\n        double M1 = calc(n, x, m1);\n        double M2 = calc(n, x, m2);\n        if (M1 > M2) {\n            right = m2;\n        } else {\n            left = m1;\n        }\n    }\n    return calc(n, x, (right+left)/2);\n}\n\ndouble search(int n) {\n    double left = -100, right = 100;\n    for (int t = 0; t < 200; t++) {\n        double m1 = (2*left+right) / 3;\n        double m2 = (left+2*right) / 3;\n        double M1 = searchY(n, m1);\n        double M2 = searchY(n, m2);\n        if (M1 > M2) {\n            right = m2;\n        } else {\n            left = m1;\n        }\n    }\n    return searchY(n, (left+right)/2);\n}\n\nvoid solve(int n) {\n    printf(\"%.15lf\\n\", sqrt(search(n)));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> l[i];\n        }\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\nstatic const double eps = 1e-10;\ntypedef complex<double> point;\nstruct circle { point p; double r; };\ninline double sq(double x) { return x * x; }\n\npair<point, point> cross(const circle& c1, const circle& c2)\n{\n    double d = abs(c1.p - c2.p);\n    double rc = (sq(d) + sq(c1.r) - sq(c2.r)) / (2*d);\n    double rs = sqrt(sq(c1.r) - sq(rc));\n    point diff = (c2.p - c1.p) / d;\n    return make_pair(c1.p + diff * point(rc, rs),\n                     c1.p + diff * point(rc, -rs));\n}\n\nbool check_point(const vector<circle>& circles, point p)\n{\n    return all_of(begin(circles), end(circles),\n            [p](const circle& c){ return sq(c.r + eps) > norm(c.p - p); });\n}\n\nbool check(const vector<circle>& ropes, double h)\n{\n    vector<circle> circles;\n    for (const auto& c : ropes) {\n        double r = sqrt(sq(c.r) - sq(h));\n        circles.push_back({ c.p, r });\n    }\n\n    for (int i = 0; i < (int)circles.size(); ++i) {\n        const circle& c1 = circles[i];\n        if (check_point(circles, c1.p))\n            return true;\n\n        for (int j = i + 1; j < (int)circles.size(); ++j) {\n            const circle& c2 = circles[j];\n            double sqd = norm(c1.p - c2.p);\n            if (sq(c1.r + c2.r) <= sqd)\n                return false;\n        }\n\n        for (int j = i + 1; j < (int)circles.size(); ++j) {\n            const circle& c2 = circles[j];\n            auto cp = cross(c1, c2);\n            if (check_point(circles, cp.first))\n                return true;\n            if (check_point(circles, cp.second))\n                return true;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n, n) {\n        double lo = 0, hi = 1e10;\n        vector<circle> ropes;\n\n        for (int i = 0; i < n; ++i) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            ropes.push_back({ point(x, y), r });\n            hi = min(hi, r);\n        }\n\n        for (int i = 0; i < 100; ++i) {\n            double mid = (lo + hi) / 2;\n            bool b = check(ropes, mid);\n            if (b)\n                lo = mid;\n            else\n                hi = mid;\n        }\n\n        cout.precision(15);\n        cout << hi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\nusing namespace std;\nconst double eps = 1e-7;\n\ndouble sq(double x) { return x * x; }\n\nstruct point {\n    double x, y;\n};\npoint operator + (point const & a, point const & b) { return { a.x + b.x, a.y + b.y }; }\npoint operator - (point const & a, point const & b) { return { a.x - b.x, a.y - b.y }; }\ndouble   dot(point const & a, point const & b) { return a.x * b.x + a.y * b.y; }\ndouble cross(point const & a, point const & b) { return a.x * b.y - a.y * b.x; }\ndouble length_squared(point const & a) { return dot(a,a); }\ndouble length(point const & a) { return sqrt(length_squared(a)); }\npoint operator * (double a, point const & b) { return { a * b.x, a * b.y }; }\npoint normalize(point const & a) { return (1 / length(a)) * a; }\npoint rot90( point const & a) { return { - a.y, a.x }; }\npoint rot270(point const & a) { return { a.y, - a.x }; }\nostream & operator << (ostream & output, point const & a) {\n    return output << \"( \" << a.x << \", \" << a.y << \" )\";\n}\n\nstruct circle {\n    point p;\n    double r;\n};\nvector<point> cross_point(circle const & a, circle const & b) {\n    point d = b.p - a.p;\n    double r = min(a.r, b.r);\n    double R = max(a.r, b.r);\n    if (length(d) + r <= R) {\n        // ???????????????\n        return vector<point>();\n    } else if (r + R < length(d)) {\n        // ????????????\n        return vector<point>();\n    } else {\n        // 1,2?????§\n        double x = ( sq(a.r) - sq(b.r) + length_squared(d) ) / ( 2 * length(d) );\n        double y = sqrt( sq(a.r) - sq(x) );\n        point e = normalize(d);\n        point h = x * e + a.p;\n        vector<point> result(2);\n        result[0] = h + y * rot90(e);\n        result[1] = h + y * rot270(e);\n        return result;\n    }\n}\n// ?????¨??? ????????????\nbool is_include(circle const & a, point const & b) {\n    return length_squared(b - a.p) <= sq(a.r) + eps;\n}\n// ?????¨??? ?????\\??????\nbool is_include(circle a, circle const & b) {\n    a.r += b.r;\n    return is_include(a, b.p);\n}\nbool has_intersection(circle const & a, circle const & b) {\n    return length(a.p - b.p) <= a.r + b.r + eps;\n}\n\n// ??±?????¨????????????\nbool has_intersection(vector<circle> const & cs) {\n    int n = cs.size();\n    vector<point> ps;\n    repeat (i,n) {\n        ps.push_back(cs[i].p);\n        repeat_from (j,i+1,n) {\n            if (not has_intersection(cs[i], cs[j])) return false;\n            for (auto p : cross_point(cs[i], cs[j])) {\n                ps.push_back(p);\n            }\n        }\n    }\n    for (auto p : ps) {\n        bool ok = true;\n        repeat (k,n) {\n            ok = ok and is_include(cs[k], p);\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\ndouble solve(vector<circle> const & cs) {\n    int n = cs.size();\n    double l = 1;\n    double r = 300+1;\n    repeat (trial,400) {\n        double m = (l + r) / 2;\n        vector<circle> ds(n);\n        repeat (i,n) {\n            ds[i].p = cs[i].p;\n            if (cs[i].r < m) {\n                r = m;\n                goto next;\n            }\n            ds[i].r = sqrt( sq(cs[i].r) - sq(m) );\n        }\n        (has_intersection(ds) ? l : r) = m;\nnext: ;\n    }\n    return l;\n}\n\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<circle> cs(n);\n        repeat (i,n) cin >> cs[i].p.x >> cs[i].p.y >> cs[i].r;\n        printf(\"%.9lf\\n\", solve(cs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n} \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n\nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n\npoint rot(point p, double a) {\n\tpoint ret;\n\tdouble C = cos(a), S = sin(a);\n\tret.x = p.x*C - p.y*S;\n\tret.y = p.x*S + p.y*C;\n\treturn ret;\n}\n\ndouble aaa[1111111];\nint cs=0;\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\twhile(1) {\n\t\tscanf(\"%d\",&n); \n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n\n\t\tdouble ans = -1e20;\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tdouble tmp = r[i];\n\t\t\tbool can = 1;\n\t\t\tfor(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n\t\t\tif(can) ans = max(ans, tmp);\n\t\t}\n\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tmemcpy(cP,P,sizeof(cP));\n\t\t\tfor(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n\t\t\tfor(int j=0;j<n;++j) if(j!=i) {\n\t\t\t\tdouble d = dis(cP[i],cP[j]);\n\t\t\t\tif(r[i]+r[j] < d-EPS) continue;\n\t\t\t\tif(abs(r[i]-r[j]) > d+EPS) continue;\n\n\t\t\t\tmemcpy(nP,cP,sizeof(nP));\n\t\t\t\tdouble a = atan2(cP[j].y,cP[j].x);\n\t\t\t\tfor(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n\t\t\t\tif(abs(nP[j].x) < 1e-9) continue;\n\n\t\t\t\tbool can = 1;\n\t\t\t\tpoint p1,p2;\n\t\t\t\tintersection_circle_circle(point(nP[j].x,nP[j].y),r[j],point(nP[i].x,nP[i].y),r[i],p1,p2);\n\t\t\t\tdouble zz = max(p1.y,p2.y), yy = 0;\n\t\t\t\tdouble xx = p1.x;\n\t\t\t\tfor(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n\t\t\t\tif(can)\n\t\t\t\t\tans = max(ans, zz);\n\n\t\t\t\tdouble rr = zz;\n\t\t\t\tfor(int k=0;k<n;++k) nP[k].x -= xx;\n\t\t\t\tfor(int k=0;k<n;++k) if(k!=i && k!=j && abs(nP[k].x) <= r[k]+EPS){\n\t\t\t\t\tdouble nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n\t\t\t\t\tdouble d = abs(nP[k].y);\n\t\t\t\t\tif(nr+rr < d-EPS) continue;\n\t\t\t\t\tif(abs(nr-rr) > d+EPS) continue;\n\t\t\t\t\tif(d < 1e-9) continue;\n\n\t\t\t\t\tbool can = 1;\n\t\t\t\t\tpoint p1,p2;\n\t\t\t\t\tintersection_circle_circle(point(0,0),rr,point(nP[k].y,0),nr,p1,p2);\n\t\t\t\t\tdouble zz = max(p1.y,p2.y), xx = 0;\n\t\t\t\t\tdouble yy = p1.x;\n\t\t\t\t\tif(nP[k].y < 0) yy *= -1;\n\t\t\t\t\tfor(int h=0;h<n;++h) if(sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)) > r[h] + EPS) {\n\t\t\t\t\t\tcan = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(can)\n\t\t\t\t\t\tans = max(ans, zz);\n\t\t\t\t}\n\t\t\t}\n\t\t} printf(\"%.10lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\nusing namespace std;\n\ntypedef struct {int x, y, l;} Anchor;\n\nint N;\nAnchor anchers[10];\n\nbool check(double H){\n    //高さHについて要件を満たすか\n    for(int i=0; i<N; i++){\n        for(int j=0; j<i; j++){\n            Anchor a1 = anchers[i];\n            Anchor a2 = anchers[j];\n            double r1 = sqrt(a1.l*a1.l - H*H);\n            double r2 = sqrt(a2.l*a2.l - H*H);\n            if(sqrt((a1.x-a2.x)*(a1.x-a2.x)+(a1.y-a2.y)*(a1.y-a2.y)) > r1+r2)\n                return false;\n        }\n    }\n    \n    return true;\n}\n\nvoid solve(){\n    double lb = 0, ub = 300;\n    \n    //上限を最も短いロープの長さにする\n    for(int i=0; i<N; i++)\n        ub = min(ub, double(anchers[i].l));\n    \n    //二分探索\n    for(int i=0; i<50; i++){\n        double mid = (lb + ub)/2;\n        if(check(mid))\n            lb = mid;\n        else\n            ub = mid;\n    }\n    printf(\"%.07f\\n\", lb);\n}\n\nint main(int argc, const char * argv[]){\n    while(cin>>N, N){\n        for(int i=0; i<N; i++)\n            cin >> anchers[i].x >> anchers[i].y >> anchers[i].l;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1000000;\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x = 0.0, double y = 0.0):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point &p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point &p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point &p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline double norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\ninline double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ninline double cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a, const point &b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(const point &c, double r):c(c), r(r){}\n};\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double t = cross(b, c);\n\tif(t > EPS) return 1; // ccw\n\tif(t < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b ???????????´??????\n\tif(norm(b) < norm(c)) return -2; // a, b, c ???????????´??????\n\treturn 0; //a, c, b ?????§?????´??????\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) return point(INF, INF); // ?????????????????????\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // ?????´??????\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) return res; // ???????????§?¨??????????\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nint main() {\n\tfor(int n; scanf(\"%d\", &n), n;) {\n\t\tvector<circle> cs;\n\t\tcs.reserve(n);\n\t\tvector<point> candidates;\n\t\tcandidates.reserve(n * n * n * n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, l;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &l);\n\t\t\tcs.emplace_back(point(x, y), l);\n\t\t\tcandidates.emplace_back(cs[i].c);\n\t\t}\n\n\t\tvector<segment> segs;\n\t\tsegs.reserve(n * n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(!intersect(cs[i], cs[j])) continue;\n\n\t\t\t\tconst vector<point> ps = crosspoint(cs[i], cs[j]);\n\t\t\t\tcandidates.emplace_back((ps[0] + ps[1]) / 2.0);\n\t\t\t\tsegs.emplace_back(ps[0], ps[1]);\n\t\t\t}\n\t\t}\n\n\t\tconst int m = segs.size();\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tfor(int j = i + 1; j < m; ++j) {\n\t\t\t\tconst point p = crosspoint(segs[i], segs[j]);\n\t\t\t\tif(p.x < INF) candidates.emplace_back(p);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1.0;\n\t\tfor(const auto &p : candidates) {\n\t\t\tdouble mn = INF;\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tchmin(mn, cs[j].r * cs[j].r - norm(cs[j].c - p));\n\t\t\t}\n\t\t\tchmax(ans, mn);\n\t\t}\n\n\t\tprintf(\"%.7lf\\n\", sqrt(ans));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n \nusing namespace std;\n \nint disdis(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    return (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n \ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2;\n    return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n \ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n    return sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n \ntuple<double, double, double> com(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return a;\n    }\n    else if (ISLOOSE(b, a)) {\n        return b;\n    }\n    else {\n        double l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n        double d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n        double d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n        return tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n    }\n}\n \ndouble two(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return (double)get<2>(a);\n    }\n    else if (ISLOOSE(b, a)) {\n        return (double)get<2>(b);\n    }\n    else {\n        double d = sqrt(disdis(a, b));\n        return heron(get<2>(a), get<2>(b), d) * 2 / d;\n    }\n}\n \ndouble three(const tuple<int, int, int>& a, const tuple<int, int, int>& b, const tuple<int, int, int>& c)\n{\n    tuple<double, double, double> temp;\n \n    if (ISLOOSE(a, b) && ISLOOSE(a, c))\n        return get<2>(a);\n    if (ISLOOSE(b, a) && ISLOOSE(b, c))\n        return get<2>(b);\n    if (ISLOOSE(c, a) && ISLOOSE(c, b))\n        return get<2>(c);\n \n    if (ISLOOSE(temp = com(a, b), c))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(b, c), a))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(c, a), b))\n        return get<2>(temp);\n \n    return heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n        * 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n \nint main()\n{\n    int n;\n    double res;\n\tcout << fixed << setprecision(7);\n    while (cin >> n, n) {\n        vector< tuple<int, int, int> > str(n);\n        for (int i = 0; i < n; i++) {\n            cin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n        }\n        if (n == 1) {\n            cout << (double)get<2>(str[0]) << endl;\n        }\n        else if (n == 2) {\n            cout << two(str[0], str[1]) << endl;\n        }\n        else {\n            res = 100000000.0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    for (int k = j + 1; k < n; k++) {\n                        res = min(res, three(str[i], str[j], str[k]));\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc != ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) || cc != ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint N;\nint x[11],y[11],l[11];\nbool connect[11][11];\n\nbool test(long double &h){\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tconnect[i][j] = false;\n\t\t}\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tlong double r1 = sqrt((long double)(l[i]*l[i] - h*h));\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==j) continue;\n\t\t\tlong double r2 = sqrt((long double)(l[j]*l[j] - h*h));\n\t\t\tlong double dist = sqrt((long double)((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));\n\t\t\tif(r1+r2>=dist) connect[i][j] = true;\n\t\t}\n\t}\n\n\tbool res = true;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==j) continue;\n\t\t\tres &= connect[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&N),N>0){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d%d%d\",&x[i],&y[i],&l[i]);\n\t\t}\n\t\tif(N == 1){\n\t\t\tprintf(\"%.7lf\\n\", double(l[0]));\n\t\t\tcontinue;\n\t\t}\n\t\tlong double hi = double(300.0);\n\t\tlong double low = double(0.0);\n\t\tlong double mid = (low+hi)/(long double)(2.0);\n\t\twhile((hi-low)>(long double)(1e-15)){\n\t\t\tif(test(mid)) low = mid;\n\t\t\telse hi = mid;\n\t\t\tmid = (low+hi)/(long double)(2.0);\n\t\t}\n\t\tprintf(\"%.7Lf\\n\", mid);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\ndouble arg(Vector p){ return atan2(p.y,p.x);}\nVector polar(double a,double r){ return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(double)(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return mp(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n// ???????????????????????????\nbool isContain(Circle c1,Circle c2){\n  if((abs(c1.c-c2.c)+c2.r-c1.r)<eps)return true;\n  return false;\n}\n\nint n;\nvector<pair<Point,double> > vp;\nvector<Circle> vc;\n\nbool check(Point p){\n  for(int i=0;i<n;i++){\n    if(vc[i].r-abs(p-vc[i].c)<-eps)return false;\n  }\n  return true;\n}\n\nbool ok(double mid){\n  vc.clear();\n\n  for(int i=0;i<n;i++){\n    if(vp[i].s-mid<eps)return false;\n    vc.push_back(Circle(vp[i].f,sqrt(vp[i].s*vp[i].s-mid*mid)));\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(check(vc[i].c))return true;\n      if(check(vc[j].c))return true;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      if((vc[i].r+vc[j].r)-abs(vc[i].c-vc[j].c)<-eps)return false;\n      if(isContain(vc[j],vc[i]))continue;\n      if(isContain(vc[i],vc[j]))continue;\n      pair<Point,Point> pp=getCrossPoints(vc[i],vc[j]);\n      if(check(pp.f))return true;\n      if(check(pp.s))return true;\n    }\n  }\n  return vc.size()==1;\n}\n\nint main()\n{\n  int a,b,c;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      vp.push_back(mp(Point(a,b),c));\n    }\n\n    double l=0,r=1000,mid;\n    for(int i=0;i<100;i++){\n      mid=(l+r)/2;\n      if(ok(mid))l=mid;\n      else r=mid;\n    }\n    printf(\"%.10f\\n\",mid);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nbool is_in(Circle c, Point p)\n{\n\tld dist = abs(c.p - p);\n\treturn c.r - dist > -EPS;\n}\n\ntypedef pair<Point, ld> Data;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<Data> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y, l;\n\t\t\tcin >> x >> y >> l;\n\t\t\tv.emplace_back(Point(x, y), l);\n\t\t}\n\t\tld lb = 0, ub = INF;\n\t\tREP(loop, 1000)\n\t\t{\n\t\t\tld height = (lb + ub) / 2.0;\n\t\t\tvector<Circle> vc;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tld r = sqrt((v[i].second * v[i].second) - height*height);\n\t\t\t\tvc.emplace_back(v[i].first, r);\n\t\t\t}\n\t\t\tvector<Point> ps;\n\t\t\tREP(i, n) ps.emplace_back(vc[i].p);\n\t\t\tREP(i, n)REP(j, i)\n\t\t\t{\n\t\t\t\tif (isis_cc(vc[i], vc[j]))\n\t\t\t\t{\n\t\t\t\t\tvector<Point> tmp = is_cc(vc[i], vc[j]);\n\t\t\t\t\tfor (auto k : tmp) ps.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = false;\n\t\t\tREP(i, ps.size())\n\t\t\t{\n\t\t\t\tbool ff = true;\n\t\t\t\tREP(j, vc.size())\n\t\t\t\t{\n\t\t\t\t\tif (!is_in(vc[j], ps[i])) ff = false;\n\t\t\t\t}\n\t\t\t\tif (ff) f = true;\n\t\t\t}\n\t\t\tif (f) lb = height;\n\t\t\telse ub = height;\n\t\t}\n\t\tcout << D10 << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=50;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h-EPS);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq=q*conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b)) res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\nconst double EPS = 1e-6;\n\ndouble x[11], y[11], l[11];\n\ndouble square(double X) {return X*X;}\n\ndouble calc(int n, double X, double Y) {\n    double ret = 300;\n    for (int i = 0; i < n; i++) {\n        ret = min(ret, /*sqrt*/(square(l[i]) - square(x[i]-X) - square(y[i]-Y)));\n    }\n    return ret;\n}\n\ndouble searchY(int n, double x) {\n    double left = -100, right = 100;\n    for (int t = 0; t < 100; t++) {\n        double m1 = (2*left+right) / 3;\n        double m2 = (left+2*right) / 3;\n        double M1 = calc(n, x, m1);\n        double M2 = calc(n, x, m2);\n        if (M1 > M2) {\n            right = m2;\n        } else {\n            left = m1;\n        }\n    }\n    return calc(n, x, (right+left)/2);\n}\n\ndouble search(int n) {\n    double left = -100, right = 100;\n    for (int t = 0; t < 100; t++) {\n        double m1 = (2*left+right) / 3;\n        double m2 = (left+2*right) / 3;\n        double M1 = searchY(n, m1);\n        double M2 = searchY(n, m2);\n        if (M1 > M2) {\n            right = m2;\n        } else {\n            left = m1;\n        }\n    }\n    return searchY(n, (left+right)/2);\n}\n\nvoid solve(int n) {\n    printf(\"%.15lf\\n\", sqrt(search(n)));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> l[i];\n        }\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef complex<double> P;\n\nint N;\nvector<double> X, Y, L;\n\nbool check(int n, int m, int p, double h) {\n    P p1 = P(X[n], Y[n]);\n    P p2 = P(X[m], Y[m]);\n    P p3 = P(X[p], Y[p]);\n    double r1 = sqrt(L[n] * L[n] - h * h);\n    double r2 = sqrt(L[m] * L[m] - h * h);\n    double r3 = sqrt(L[p] * L[p] - h * h);\n\n    if (abs(p1 - p2) > r1 + r2) return false;\n    if (abs(p1 - p2) <= abs(r2 - r1)) {\n        if (r1 <= r2 && abs(p1 - p3) <= r1 + r3) {\n            return true;\n        }\n        else if (r2 <= r1 && abs(p2 - p3) <= r2 + r3) {\n            return true;\n        }\n        else return false;\n    }\n\n    if (abs(p1 - p2) == r1 + r2) {\n        P p = p1 + (r1 / (r1 + r2)) * (p2 - p1);\n        if (abs(p - p3) <= r3) return true;\n        return false;\n    } else if (abs(r1 - r2) < abs(p1 - p2) && abs(p1 - p2) < r1 + r2) {\n        double A = 2. * (p2.real() - p1.real());\n        double B = 2. * (p2.imag() - p1.imag());\n        double C = r1 * r1 - r2 * r2 - (p1.real() * p1.real() - p2.real() * p2.real()) - (p1.imag() * p1.imag() - p2.imag() * p2.imag());\n        double X1, X2, Y1, Y2;\n        double Ad, Bd, Cd;\n        if (B == 0) {\n            X1 = X2 = C / A;\n            Y1 = p1.imag() - sqrt(r1 * r1 - (X1 - p1.real()) * (X1 - p1.real()));\n            Y2 = p1.imag() + sqrt(r1 * r1 - (X1 - p1.real()) * (X1 - p1.real()));\n        } else if (A == 0) {\n            Y1 = Y2 = C / B;\n            X1 = p1.real() - sqrt(r1 * r1 - (Y1 - p1.imag()) * (Y1 - p1.imag()));\n            X2 = p1.real() + sqrt(r1 * r1 - (Y1 - p1.imag()) * (Y1 - p1.imag()));\n        } else {\n            Ad = 1. + (A / B) * (A / B);\n            Bd = -2 * p1.real() - 2 * (A / B) * (C / B - p1.imag());\n            Cd = (C / B - p1.imag()) * (C / B - p1.imag()) - r1 * r1 + p1.real() * p1.real();\n            X1 = (- Bd + sqrt(Bd * Bd - 4. * Ad * Cd)) / (2. * Ad);\n            X2 = (- Bd - sqrt(Bd * Bd - 4. * Ad * Cd)) / (2. * Ad);\n            Y1 = (- A / B) * X1 + (C / B);\n            Y2 = (- A / B) * X2 + (C / B);\n        }\n        P p1d = P(X1, Y1);\n        P p2d = P(X2, Y2);\n\n        if (abs(p1d - p3) <= r3) return true;\n        if (abs(p2d - p3) <= r3) return true;\n    }\n\n    return false;\n}\n\nvoid solve() {\n    double res_r = 1LL << 28;\n    double res_l = 1LL << 28;\n    for (int i = 0; i < N; i++) {\n        for (int j = i; j < N; j++) {\n            for (int k = j; k < N; k++) {\n                int v[] = {i, j, k};\n                double l = 0., r = min(L[i], min(L[j], L[k]));\n                for (int loop = 0; loop < 100; loop++) {\n                    bool flag = false;\n                    for (int I = 0; I < 3; I++) {\n                        for (int J = I + 1; J < 3; J++) {\n                            int K = 3 - J - I;\n                            flag |= check(v[I], v[J], v[K], (l + r) / 2.);\n                        }\n                    }\n                    if (flag) {\n                        l = (l + r) / 2.;\n                    } else {\n                        r = (l + r) / 2.;\n                    }\n                    res_r = min(res_r, r);\n                    res_l = min(res_l, l);\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\", res_r);\n}\n\nint main() {\n    while (cin >> N, N) {\n        X.resize(N), Y.resize(N), L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> X[i] >> Y[i] >> L[i];\n        }\n\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nvector<P> cross_circles(P c1,double r1,P c2,double r2){\n\tdouble d=abs(c2-c1);\n\tif(LT(r1+r2,d)||LT(d,fabs(r1-r2)))\n\t\treturn vector<P>();\n\tdouble l=0.5*((r1*r1-r2*r2)/d+d);\n\tdouble h=sqrt(r1*r1-l*l);\n\tvector<P> ret(2);\n\tret[0]=P(l,+h)*(c2-c1)/d+c1;\n\tret[1]=P(l,-h)*(c2-c1)/d+c1;\n\treturn ret;\n}\n\ndouble distance(double y1,double x1,double y2,double x2){\n\tdouble dy=y1-y2;\n\tdouble dx=x1-x2;\n\treturn sqrt(dy*dy+dx*dx);\n}\n\nbool ok(vi &y,vi &x,vi &l, double h){\n\tint n=y.size();\n\tvector<P> all_cross;\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(l[i]+EPS<h||l[j]+EPS<h){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdouble di=sqrt(l[i]*l[i]-h*h);\n\t\t\tdouble dj=sqrt(l[j]*l[j]-h*h);\n\t\t\tdouble dist2=distance(y[i],x[i],y[j],x[j]);\n\t\t\tbool intersected=di+dj+EPS>dist2;\n\t\t\tvector<P> cross=cross_circles(P(y[i],x[i]),di,P(y[j],x[j]),dj);\n\t\t\tif(cross.size()==0){\n\t\t\t\tif(!intersected){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tall_cross.push_back(cross[0]);\n\t\t\t\tall_cross.push_back(cross[1]);\n\t\t\t}\n\t\t}\n\t\tall_cross.push_back(P(y[i],x[i]));\n\t}\n\n\tREP(ci,all_cross.size()){\n\t\tbool ok=true;\n\t\tREP(k,n){\n\t\t\tdouble dk=sqrt(l[k]*l[k]-h*h);\n\t\t\tif(distance(y[k],x[k],all_cross[ci].real(),all_cross[ci].imag())>dk+EPS){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcout.precision(30);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n),y(n),l(n);\n\t\tint maxl=0;\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>l[i];\n\t\t\tmaxl=max(maxl,l[i]);\n\t\t}\n\n\t\tdouble lb=1,ub=maxl;\n\t\tREP(time,1000){\n\t\t\tdouble mid=(lb+ub)/2;\n\t\t\tif(!ok(y,x,l,mid)){\n\t\t\t\tub=mid;\n\t\t\t}else{\n\t\t\t\tlb=mid;\n\t\t\t}\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\tvolatile int a=0;\n\t\trep(i, 50000000)a++;\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1]) == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t\tif (c<13.03&&c>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t\tif (z<13.03&&z>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-12) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(5) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\ntypedef complex<double> P;\nconst int L = 10;\n\nint N, x[L], y[L], r[L];\n\nstruct C {\n  P p; double r;\n  C(){}\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nvoid crosspointCC(const C &c1, const C &c2, vector<P> &ps){\n  double d = abs(c1.p - c2.p);\n  double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  double dfr = c1.r * c1.r - rc * rc;\n  if(EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ;\n  double rs = sqrt(dfr);\n\n  P diff = (c2.p - c1.p) / d;\n  ps.push_back(c1.p + diff * P(rc, rs));\n  ps.push_back(c1.p + diff * P(rc, -rs));\n}\n\nbool check(double h){\n  C cs[L];\n  REP(i, N){\n    cs[i].p = P(x[i], y[i]);\n    double rr = r[i] * r[i] - h * h;\n    if(rr < 0) return false;\n    cs[i].r = sqrt(rr);\n  }\n  vector<P> ps;\n  REP(i, N) ps.push_back(cs[i].p);\n  REP(i, N) FOR(j, i + 1, N) crosspointCC(cs[i], cs[j], ps);\n\n  REP(i, ps.size()){\n    bool f = true;\n    REP(j, N) if(abs(cs[j].p - ps[i]) > cs[j].r + EPS) f = false;\n    if(f) return true;\n  }\n  return false;\n}\n\ndouble solve(){\n  double lb = 0, ub = 300;\n  REP(i, 100){\n    double m = (lb + ub) / 2.0;\n    if(check(m)) lb = m;\n    else ub = m;\n  }\n  return lb;\n}\n\nint main() {\n  while(cin >>N && N){\n    REP(i, N) cin >>x[i] >>y[i] >>r[i];\n    printf(\"%.7lf\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n\tbool res = l > r;\n\tif (res) {\n\t\tl = r;\n\t}\n\treturn res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\ntypedef double D;\n\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef pair<P, D> C;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n\treturn a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n\treturn a.X*b.Y - a.Y*b.X;\n}\n\n\n\nstruct cww {\n\tcww() {\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\nIL D signed_distance_P_L(P p, LS l) {\n\tP a, b, c = p;\n\ttie(a, b) = l;\n\treturn cross(b - a, c - a) / abs(b - a);\n}\nIL D distance_P_LS(P p, LS ls) {\n\tP a, b, c = p;\n\ttie(a, b) = ls;\n\tif (dot(b - a, c - a) < EPS)return abs(c - a);\n\tif (dot(a - b, c - b) < EPS)return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nIL bool isintersected_LS_LS(LS p, LS q) {\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tif (abs(cross(b - a, d - c))<EPS) {\n\t\tif (abs(abs(b - c) + abs(a - c) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(b - d) + abs(a - d) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(a - c) + abs(a - d) - abs(c - d)) < EPS)return true;\n\t\tif (abs(abs(b - c) + abs(b - d) - abs(c - d)) < EPS)return true;\n\n\t\treturn false;\n\t}\n\treturn cross(b - a, c - a)*cross(b - a, d - a) < EPS && cross(d - c, a - c)*cross(d - c, b - c) < EPS;\n}\nIL D distance_LS_LS(LS p, LS q) {\n\tif (isintersected_LS_LS(p, q))return 0;\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tdouble e, f, g, h;\n\te = distance_P_LS(a, q);\n\tf = distance_P_LS(b, q);\n\tg = distance_P_LS(c, p);\n\th = distance_P_LS(d, p);\n\treturn min({ e,f,g,h });\n}\nP rot(P p, double r) {\n\treturn P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\nIL bool isintersected_C_C(C p, C q) {\n\tP cp, cq;\n\tD rp, rq;\n\ttie(cp, rp) = p;\n\ttie(cq, rq) = q;\n\tD d = abs(cp - cq);\n\treturn abs(rp - rq) < d + EPS&&d < rp + rq + EPS;\n}\nIL LS cross_C_C(C p, C q) {\n\tP cp, cq;\n\tD rp, rq;\n\ttie(cp, rp) = p;\n\ttie(cq, rq) = q;\n\tD d = abs(cp - cq);\n\tD rc = (d*d +rp*rp - rq*rq)/(2*d);\n\tD rs = sqrt(rp*rp - rc*rc);\n\tP diff = (cq - cp) / d;\n\treturn LS(cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff);\n}\n\nconst D PI = acos(-1);\ntypedef pair<double, int> pp;\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<P> xy(N);\n\t\tvector<D> len(N);\n\t\tREP(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y>>len[i];\n\t\t\txy[i] = P(x, y);\n\t\t}\n\t\tdouble lb = 0;\n\t\tdouble ub = 400;\n\t\tREP(loop, 100) {\n\t\t\tconst D mid = (lb + ub) / 2;\n\t\t\tvector<C> cir(N);\n\t\t\tbool flag = true;\n\t\t\tREP(i, N) {\n\t\t\t\tdouble l = len[i] * len[i] - mid*mid;\n\t\t\t\tif (l < 0) { flag = false; break; }\n\t\t\t\tcir[i] = C(xy[i], sqrt(l));\n\t\t\t}\n\t\t\tif (flag == false) {\n\t\t\t\tub = mid; continue;\n\t\t\t}\n\t\t\tvector<P> nobu;\n\t\t\tREP(i, N)nobu.push_back(xy[i]);\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tif (!isintersected_C_C(cir[i], cir[j]))continue;\n\t\t\t\t\t\tauto hiro = cross_C_C(cir[i], cir[j]);\n\t\t\t\t\t\tnobu.push_back(hiro.first);\n\t\t\t\t\t\tnobu.push_back(hiro.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor (auto &p : nobu) {\n\t\t\t\tbool btk=true;\n\t\t\t\tREP(i, N) {\n\t\t\t\t\tauto d = abs(p - xy[i]);\n\t\t\t\t\tif (d*d + mid*mid >EPS+ len[i] * len[i])\n\t\t\t\t\t\tbtk = false;\n\t\t\t\t}\n\t\t\t\tif (btk)flag = true;\n\t\t\t}\n\n\n\t\t\tif (flag)lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst double eps = 1e-8, inf = 1e8;\n\ntemplate<typename T> T sqr(T x){return x*x;}\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a) * b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct L:vector<P>{\n    L(const P &a, const P &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interSS(const L &s, const L &t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool interSP(const L &s, const P &p){\n    return abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < eps;\n}\n\nP xptSS(const L &s, const L &t){\n    double d = cross(s[1] - s[0], t[1] - t[0]);\n    if(abs(d) < eps){\n        if(interSP(t, s[0]))return s[0];\n        if(interSP(t, s[1]))return s[1];\n        if(interSP(s, t[0]))return t[0];\n        return t[1];\n    }\n    return t[0] + (t[1] - t[0]) * cross(s[1] - s[0], s[1] - t[0]) * (1. / d);\n}\n\nstruct C:P{\n    double r;\n    C(const P &a, double r):P(a), r(r){}\n};\n\nint overlap(const C &c1, const C &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nvector<P> xptCC(const C &c1, const C &c2){\n    vector<P> res;\n    double d = abs(c1 - c2);\n    if(d < eps || abs(overlap(c1, c2)) != 2)return res;\n    double rc = (sqr(d) + sqr(c1.r) - sqr(c2.r)) / (2. * d);\n    double rs = sqrt(sqr(c1.r) - sqr(rc));\n    P diff = (c2 - c1) / d;\n    res.push_back(c1 + diff * P(rc, rs));\n    res.push_back(c1 + diff * P(rc, -rs));\n    return res;\n}\n\ndouble solve(vector<C> stake){\n    vector<P> fixpt(all(stake));\n    vector<L> locus;\n    rep(i, (int)stake.size())rep(j, i){\n        vector<P> xpt = xptCC(stake[i], stake[j]);\n        if(xpt.empty())continue;\n        fixpt.push_back((xpt[0] + xpt[1]) / 2.);\n        locus.emplace_back(xpt[0], xpt[1]);\n    }\n    rep(i, (int)locus.size())rep(j, i){\n        if(!interSS(locus[i], locus[j]))continue;\n        fixpt.push_back(xptSS(locus[i], locus[j]));\n    }\n    double res = 0.;\n    for(auto p: fixpt){\n        double h = inf;\n        for(auto c: stake)h = min(h, sqr(c.r) - norm(c - p));\n        res = max(res, h);\n    }\n    return res;\n}\n\nint main(){\n    for(int n; cin >> n, n;){\n        vector<C> stake;\n        rep(i, n){\n            int x, y, l;\n            cin >> x >> y >> l;\n            stake.emplace_back(P(x, y), l);\n        }\n        cout << fixed << setprecision(7) << sqrt(solve(stake)) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n \nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<int, int, int>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\nint disdis(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    return (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n \ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2;\n    return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n \ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n    return sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n \ntuple<double, double, double> com(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return a;\n    }\n    else if (ISLOOSE(b, a)) {\n        return b;\n    }\n    else {\n        double l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n        double d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n        double d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n        return tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n    }\n}\n \ndouble two(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return (double)get<2>(a);\n    }\n    else if (ISLOOSE(b, a)) {\n        return (double)get<2>(b);\n    }\n    else {\n        double d = sqrt(disdis(a, b));\n        return heron(get<2>(a), get<2>(b), d) * 2 / d;\n    }\n}\n \ndouble three(const tuple<int, int, int>& a, const tuple<int, int, int>& b, const tuple<int, int, int>& c)\n{\n    tuple<double, double, double> temp;\n \n    if (ISLOOSE(a, b) && ISLOOSE(a, c))\n        return get<2>(a);\n    if (ISLOOSE(b, a) && ISLOOSE(b, c))\n        return get<2>(b);\n    if (ISLOOSE(c, a) && ISLOOSE(c, b))\n        return get<2>(c);\n \n    if (ISLOOSE(temp = com(a, b), c))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(b, c), a))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(c, a), b))\n        return get<2>(temp);\n \n    return heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n        * 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n \nint main()\n{\n    int n;\n    double res;\n\tcout << fixed << setprecision(7);\n    while (cin >> n, n) {\n        vector< tuple<int, int, int> > str(n);\n        for (int i = 0; i < n; i++) {\n            cin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n        }\n        if (n == 1) {\n            cout << (double)get<2>(str[0]) << endl;\n        }\n        else if (n == 2) {\n            cout << two(str[0], str[1]) << endl;\n        }\n        else {\n            res = 100000000.0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    for (int k = j + 1; k < n; k++) {\n                        res = min(res, three(str[i], str[j], str[k]));\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#include<cmath>\nusing namespace std;\ntypedef double R;\ntypedef complex<R> P;\n\nstruct C{P c;R r;};\n\ndouble n, x, y, l;\nC c[108];\nC tc[108];\npair<P, P> cross_circles(C a, C b){\n  R d = abs(a.c - b.c);\n  R l = ((a.r*a.r - b.r*b.r) / d + d) / 2.0;\n  R h = sqrt(a.r*a.r - l*l);\n  P e = a.c + (b.c-a.c) * l / d;\n  P p = (b.c-a.c) * h / d * P(0, -1);\n  return make_pair(e + p, e - p);\n}\n\nbool able(R h){\n  for(int i = 0;i < n;i++){\n    tc[i] = c[i];\n    if(c[i].r < h)return false;\n    tc[i].r = sqrt(tc[i].r*tc[i].r - h*h);\n  }\n  \n  vector<P> points;\n\n  for(int i = 0;i < n;i++){\n    for(int j = i + 1;j < n;j++){\n      if(abs(tc[i].c - tc[j].c) >= tc[i].r + tc[j].r)continue;\n      if(abs(tc[i].c - tc[j].c) <= abs(tc[i].r - tc[j].r))continue;\n      pair<P, P> tmp = cross_circles(tc[i], tc[j]);\n      points.push_back(tmp.first);\n      points.push_back(tmp.second);\n    }\n    points.push_back(tc[i].c);\n  }\n\n  for(int i = 0;i < points.size();i++){\n    bool tmp = true;\n    P p = points[i];\n    for(int j = 0;j < n;j++){\n      if(abs(p - tc[j].c) > tc[j].r)tmp = false;\n    }\n    if(tmp == true){\n      return true;\n      \n    }\n  }\n  return false;  \n}\n\nbool solve(){\n  cin >> n;\n  if(n == 0)return false;\n  double bottom = 0.5, top = 300;\n  for(int i = 0;i < n;i++){\n    cin >> x >> y >> l;\n    c[i].c = P(x, y);\n    c[i].r = l;\n    top = min(top, l);\n  }\n  for(int i = 0;i < 1000;i++){\n    double mid = (bottom + top) / 2;\n    if(able(mid))bottom = mid;\n    else top = mid;\n  }\n  printf(\"%.10lf\\n\", bottom);\n  return true;\n}\n\nint main(){\n  while(solve());return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double eps = 1e-8;\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\nstruct circle\n{\n\tpoint p;\n\tdouble r;\n\tcircle(const point &p, double r) : p(p), r(r) {}\n};\n\nint n;\npoint  p[10];\ndouble r[10];\n\npoint unit(const point &v) { return v/abs(v); }\n\nbool containCP(const circle& c, const point& p)\n{\n\treturn abs(p - c.p) <= c.r + eps;\n}\n\npolygon crosspointCC(const circle &c1, const circle &c2)\n{\n\tpoint  v = unit(c2.p - c1.p);\n\tdouble d = abs(c1.p - c2.p);\n\tdouble x = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble y = c1.r*c1.r - x*x;\n\n\tpolygon ret;\n\tif(y<0) return ret;\n\tif(y<eps)\n\t{\n\t\tret.push_back(c1.p + v*point(c1.r, 0));\n\t\treturn ret;\n\t}\n\ty = sqrt(y);\n\tret.push_back(c1.p + v*point(x, y));\n\tret.push_back(c1.p + v*point(x,-y));\n\treturn ret;\n}\n\nbool check(double z)\n{\n\tdouble tr[10];\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(z > r[i]) return false;\n\t\ttr[i] = sqrt(r[i]*r[i] - z*z);\n\t}\n\n\tvector<point> cp;\n\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tcp.push_back( p[i] );\n\t\tfor(int j=i+1; j<n; j++)\n\t\t{\n\t\t\tpolygon g = crosspointCC( circle(p[i],tr[i]), circle(p[j],tr[j]) );\n\t\t\tfor(int k=0; k<g.size(); k++)\n\t\t\t{\n\t\t\t\tcp.push_back( g[k] );\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> cnt(cp.size(), 0);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tfor(int k=0; k<cp.size(); k++)\n\t\t{\n\t\t\tif(containCP(circle(p[i],tr[i]), cp[k])) cnt[k]++;\n\t\t}\n\t}\n\n\tfor(int k=0; k<cp.size(); k++)\n\t{\n\t\tif(cnt[k]==n) return true;\n\t}\t\n\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y >> r[i];\n\t\t\tp[i] = point(x,y);\n\t\t}\n\n\t\tdouble l=0, h=300;\n\t\twhile(h-l > eps)\n\t\t{\n\t\t\tdouble z = (l+h) / 2.0;\n\t\t\tif(check(z)) l=z; else h=z;\n\t\t}\n\t\tprintf(\"%.7lf\\n\", (l+h)/2.0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p(n);\n    double ll[n];\n    for(int i=0;i<n;i++) cin>>p[i].x>>p[i].y>>ll[i];\n    double l=0,r=400;\n    for(int i=0;i<500;i++){\n      double m=(l+r)/2;\n      bool f=1;\n      Circle c[n];\n      for(int j=0;j<n;j++){\n\tif(m>ll[j]){\n\t  f=0;\n\t  break;\n\t}\n\tc[j]=Circle(p[j],sqrt(ll[j]*ll[j]-m*m));\n      }\n      \n      for(int j=0;j<n;j++)\n\tfor(int k=j+1;k<n;k++)\n\t  f&=abs(c[j].c-c[k].c)<=(c[j].r+c[k].r);\n\n      //*\n      for(int j=0;j<n;j++){\n\tfor(int k=j+1;k<n;k++){\n\t  for(int a=k+1;a<n;a++){\n\t    bool ff=0;\n\t    pair<Point,Point> pp;\n\t    pp=getCrossPoints(c[j],c[k]);\n\t    ff|=abs(c[a].c-pp.first)<=c[a].r;\n\t    ff|=abs(c[a].c-pp.second)<=c[a].r;\n\t    pp=getCrossPoints(c[k],c[a]);\n\t    ff|=abs(c[j].c-pp.first)<=c[j].r;\n\t    ff|=abs(c[j].c-pp.second)<=c[j].r;\n\t    pp=getCrossPoints(c[a],c[j]);\n\t    ff|=abs(c[k].c-pp.first)<=c[k].r;\n\t    ff|=abs(c[k].c-pp.second)<=c[k].r;\n\t    //if(!ff) cout<<j<<\" \"<<k<<\" \"<<a<<endl;\n\t    ff|=abs(c[j].c-c[k].c)+c[j].r<c[k].r;\n\t    ff|=abs(c[j].c-c[k].c)+c[k].r<c[j].r;\n\t    ff|=abs(c[k].c-c[a].c)+c[k].r<c[a].r;\n\t    ff|=abs(c[k].c-c[a].c)+c[a].r<c[k].r;\n\t    ff|=abs(c[a].c-c[j].c)+c[a].r<c[j].r;\n\t    ff|=abs(c[a].c-c[j].c)+c[j].r<c[a].r;\n\t    f&=ff;\n\t    if(!f) break;\n\t  }\n\t}\n      }\t \n      //*/\n      \n      if(f) l=m;\n      else r=m;\n    }\n    printf(\"%.12lf\\n\",l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=30;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h-EPS);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq*=conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b))res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst double eps = 1e-8, inf = 1e8;\n\ntemplate<typename T> T sqr(T x){return x*x;}\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a) * b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct L:vector<P>{\n    L(const P &a, const P &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interSS(const L &s, const L &t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool interSP(const L &s, const P &p){\n    return abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < eps;\n}\n\nP xptSS(const L &s, const L &t){\n    double d = cross(s[1] - s[0], t[1] - t[0]);\n    if(abs(d) < eps){\n        if(interSP(t, s[0]))return s[0];\n        if(interSP(t, s[1]))return s[1];\n        if(interSP(s, t[0]))return t[0];\n        return t[1];\n    }\n    return t[0] + (t[1] - t[0]) * cross(s[1] - s[0], s[1] - t[0]) * (1. / d);\n}\n\nstruct C:P{\n    double r;\n    C(const P &a, double r):P(a), r(r){}\n};\n\nint overlap(const C &c1, const C &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nvector<P> xptCC(const C &c1, const C &c2){\n    vector<P> res;\n    double d = abs(c1 - c2);\n    if(d < eps || abs(overlap(c1, c2)) != 2)return res;\n    double rc = (sqr(d) + sqr(c1.r) - sqr(c2.r)) / (2. * d);\n    double rs = sqrt(sqr(c1.r) - sqr(rc));\n    P diff = (c2 - c1) / d;\n    res.push_back(c1 + diff * P(rc, rs));\n    res.push_back(c1 + diff * P(rc, -rs));\n    return res;\n}\n\ndouble solve(vector<C> stake){\n    vector<P> fixpt(all(stake));\n    vector<L> locus;\n    rep(i, (int)stake.size())rep(j, i){\n        vector<P> xpt = xptCC(stake[i], stake[j]);\n        if(xpt.empty())continue;\n        fixpt.push_back((xpt[0] + xpt[1]) / 2.);\n        locus.emplace_back(xpt[0], xpt[1]);\n    }\n    rep(i, (int)locus.size())rep(j, i){\n        if(!interSS(locus[i], locus[j]))continue;\n        fixpt.push_back(xptSS(locus[i], locus[j]));\n    }\n    double res = 0.;\n    for(auto p: fixpt){\n        double h = inf;\n        for(auto c: stake)h = min(h, sqr(c.r) - norm(c - p));\n        res = max(res, h);\n    }\n    return res;\n}\n\nint main(){\n    for(int n; cin >> n, n;){\n        vector<C> stake;\n        rep(i, n){\n            int x, y, l;\n            cin >> x >> y >> l;\n            stake.emplace_back(P(x, y), l);\n        }\n        cout << fixed << setprecision(7) << sqrt(solve(stake)) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1]) == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t\tif (c<13.03&&c>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t\tif (z<13.03&&z>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-12) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint n;\nvll x, y, l;\ndouble dist(double x1, double y1, double x2, double y2) {\n  return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\ndouble area(double a, double b, double c) {\n  double s = (a + b + c) / 2;\n  return sqrt(s * (s-a) * (s-b) * (s-c));\n}\nbool triangle(double a, double b, double c) {\n  return a + b > c - eps && b + c > a - eps && c + a > b - eps;\n}\ndouble solve1() {\n  double res = 0.0;\n  for(int i=0;i<n;++i) {\n    bool ok = true;\n    for(int j=0;j<n;++j) {\n      if(i == j) continue;\n      ok &= l[j] * l[j] + eps > l[i] * l[i] + dist(x[i], y[i], x[j], y[j]) * dist(x[i], y[i], x[j], y[j]);\n    }\n    if(ok) res = max(res, (double)l[i]);\n  }\n  return res;\n}\ndouble solve2() {\n  double res = 0.0;\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      double d = dist(x[i], y[i], x[j], y[j]);\n      if(!triangle(d, l[i], l[j])) continue;\n      double s = area(d, l[i], l[j]);\n      double h = s * 2 / d;\n      double tmp = sqrt(l[i] * l[i] - h * h);\n      complex<double> p1(x[i], y[i]), p2(x[j], y[j]), hoko(tmp/d, 0.0);\n      complex<double> p3 = p1 + hoko * (p2 - p1);\n      bool ok = true;\n      for(int k=0;k<n;++k) {\n        if(i == k || j == k) continue;\n        double d2 = dist(x[k], y[k], p3.real(), p3.imag());\n        ok &= l[k] + eps > sqrt(h * h + d2 * d2);\n      }\n      if(ok) res = max(res, h);\n    }\n  }\n  return res;\n}\ndouble solve3() {\n  double res = 0.0;\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      for(int k=j+1;k<n;++k) {\n        double a1 = l[i] * l[i] - x[i] * x[i] - y[i] * y[i];\n        double a2 = l[j] * l[j] - x[j] * x[j] - y[j] * y[j];\n        double a3 = l[k] * l[k] - x[k] * x[k] - y[k] * y[k];\n        double a21 = -(a2 - a1) / 2;\n        double a31 = -(a3 - a1) / 2;\n        double d = (x[j] - x[i]) * (y[k] - y[i]) - (x[k] - x[i]) * (y[j] - y[i]);\n        if(abs(d) < eps) continue;\n        double b = (a21 * (y[k] - y[i]) - a31 * (y[j] - y[i])) / d;\n        double c = (a31 * (x[j] - x[i]) - a21 * (x[k] - x[i])) / d;\n        double tmp = l[i] * l[i] - (x[i] - b) * (x[i] - b) - (y[i] - c) * (y[i] - c);\n        if(tmp < eps) continue;\n        double z = sqrt(tmp);\n        bool ok = true;\n        for(int p=0;p<n;++p) {\n          if(p == i || p == j || p == k) continue;\n          double d2 = dist(x[p], y[p], b, c);\n          ok &= l[p] + eps > sqrt(z * z + d2 * d2);\n        }\n        if(ok) res = max(res, z);\n      }\n    }\n  }\n  return res;\n}\nvoid solve() {\n  x.clear();\n  x.resize(n);\n  y.clear();\n  y.resize(n);\n  l.clear();\n  l.resize(n);\n  for(int i=0;i<n;++i) {\n    cin >> x[i] >> y[i] >> l[i];\n  }\n  cout << max(solve1(), max(solve2() , solve3())) << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    solve();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n  \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n   \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n   \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n   \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n}\nint main() {\n    int n;\n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);\n    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);\n    cin.sync_with_stdio(0);\n    while (cin >> n, n) {\n        va<float, 3> bl(n);\n        rep(i, n)rep(j, 3)cin >> bl[i][j];\n        //va<double, 3> h;\n        double ans = 1e9;\n        int mina = 0;\n        rep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n        ans *= ans;\n        rep(i, n) {\n            rep(j, i) {\n                double l = sqrt(double(bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n                double a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n                double x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n                if (z < 0)continue;\n                if (z<ans&&a > 0 && a < l)ans = z;\n                double x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n                if (x01 != 0) {\n                    double rv = 1 / x01;\n                    rep(k, j) {\n                        double x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n                        double a, b, c;\n                        double rv2 = x10 * x01 - x11*x00;\n                        if (rv2 == 0)continue;\n                        rv2 = 1 / rv2;\n                        a = rv2*(x12 * x01 - x11 * x02)*0.5;\n                        b = (x02 * 0.5 - a*x00)*rv;\n                        c = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n                        if (c < 0)continue;\n                        if (c >= ans)continue;\n                        int cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                        if (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                    }\n                }\n                else {\n                    double a = x02*0.5 / x00;\n                    double c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n                    rep(k, j) {\n                        double x11 = bl[i][1] - bl[k][1];\n                        if (x11 == 0)continue;\n                        double x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n                        double b = (x12*0.5 - a*x10) / x11, c;\n                        c = c_ - (b - bl[i][1])*(b - bl[i][1]);\n                        if (c < 0)continue;\n                        if (c >= ans)continue;\n                        int cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                        if (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                    }\n                }\n            }\n        }\n        cout << fixed << setprecision(7) << sqrt(ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nstruct vec{\n    double x,y;\n    vec(){x=y=0.0;};\n    vec(double x, double y): x(x), y(y){};\n    inline double add(double a, double b){\n        return abs(a+b)<(1e-10)*(abs(a)+abs(b))?0.0:a+b;\n    }\n    vec operator-(vec b){\n        return vec(add(x,-b.x),add(y,-b.y));\n    }\n    vec operator+(vec b){\n        return vec(add(x,b.x),add(y,b.y));\n    }\n    vec operator*(double d){\n        return vec(x*d,y*d);\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    double norm(){\n        return hypot(x,y);\n    }\n};\n\npair<vec,vec> cross_point(vec&C1, vec&C2, double r1, double r2){\n    vec e1,e2,P1,P2;\n    double d=(C2-C1).norm();\n    e1=(C2-C1)*(1/d);\n    double theta = acos((r1*r1+(C2-C1).dot(C2-C1)-r2*r2)/(2*r1*d));\n    e2.x=cos(theta)*e1.x-sin(theta)*e1.y, e2.y=sin(theta)*e1.x+cos(theta)*e1.y;\n    P1=C1+e2*r1;\n    e2.x=cos(theta)*e1.x+sin(theta)*e1.y, e2.y=-sin(theta)*e1.x+cos(theta)*e1.y;\n    P2=C1+e2*r1;\n    if(P1.x==P2.x){\n        if(P1.y<P2.y) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.x<P2.x)return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\ndouble radius(double h, double l){\n    return sqrt(l*l-h*h);\n}\nint n;\nvector<vec> V;\nvector<double> L;\n\nbool iswrap(vec point, vector<double> &LL){\n    for(int i=0;i<n;i++){\n        double d = (V[i]-point).norm();\n        if(LL[i]+1e-9<d) return false;\n    }\n    return true;\n}\n\nbool test(double h){\n    vector<double> LL(n);\n    for(int i=0;i<n;i++) LL[i]=radius(h,L[i]);\n    for(int i=0;i<n;i++){\n        if(iswrap(V[i],LL)) return true;\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            //テゥツ崢「テ」ツつ古」ツ?ヲテ」ツつ?\n            double d = (V[i]-V[j]).norm();\n            if(d>LL[i]+LL[j]){\n                return false;\n            }\n            //テ・ツ??・ツ個?\n            if(d+min(LL[i],LL[j])<max(LL[i],LL[j])){\n                continue;\n            }\n            //テ、ツコツ、テ・ツキツョ\n            auto PP = cross_point(V[i],V[j],LL[i],LL[j]);\n            if(iswrap(PP.first,LL)||iswrap(PP.second,LL)) return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    cout<<fixed;\n    cout.precision(7);\n    while(cin>>n,n){\n        V.clear();\n        L.clear();\n        for(int i=0;i<n;i++){\n            int x,y,l;\n            cin>>x>>y>>l;\n            V.emplace_back(x,y);\n            L.push_back(l);\n        }\n        double lb=1,ub=1000;\n        for(auto l:L) ub=min(ub,l);\n        int cnt=50;\n        while(cnt--){\n            double mid=(ub+lb)/2;\n            if(test(mid)){\n                lb=mid;\n            }else{\n                ub=mid;\n            }\n        }\n        cout<<ub<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool is_intersect(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心に回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る半径rの円の中心座標\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//線分と点の距離\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(is_intersect(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分間の距離\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(is_intersect(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n//多角形内部に点pがあるか\nbool contains(vector<P> &poly,P p){\n\tint f=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\tdouble d=(p-poly[i]).det(poly[i]-poly[(i+1)%poly.size()]);\n\t\tif(d<0)f|=1;\n\t\telse if(d>0)f|=2;\n\t}\n\treturn f==(f&-f);\n}\n\n\nint main(){\n\tint n;\n\tdouble x[10],y[10],h[10],r[10];\n\twhile(cin>>n&&n){\n\t\tdouble lo=1,hi=300;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>h[i];\n\t\t\thi=min(hi,h[i]);\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"%.7f\\n\",h[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tdouble mi=(lo+hi)/2;\n\t\t\tbool ok=false;\n\t\t\tvector<P> v;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tr[j]=sqrt(h[j]*h[j]-mi*mi);\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tpair<P,P> pp=circle_intersection(x[j],y[j],r[j],x[k],y[k],r[k]);\n\t\t\t\t\tv.push_back(pp.first);\n\t\t\t\t\tv.push_back(pp.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<v.size()&&!ok;j++){\n\t\t\t\tint c=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif((x[k]-v[j].x)*(x[k]-v[j].x)+(y[k]-v[j].y)*(y[k]-v[j].y)\n\t\t\t\t\t\t< r[k]*r[k]+EPS)c++;\n\t\t\t\t}\n\t\t\t\tif(c==n)ok=true;\n\t\t\t}\n\t\t\tif(ok)lo=mi;\n\t\t\telse hi=mi;\n\t\t}\n\t\tprintf(\"%.7f\\n\",lo);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nstruct ballon {\n\tld x;\n\tld y;\n\tld l;\n};\nvector<ballon>bas;\n\nbool check(const ld h) {\n\tvector<Circle>cs;\n\tfor (auto b : bas) {\n\t\tif (b.l < h)return false;\n\t\telse {\n\t\t\tld rad = sqrt((b.l)*(b.l) - h*h);\n\t\t\tcs.emplace_back(Point(b.x, b.y), rad);\n\t\t}\n\t}\n\tfor (int i = 0; i < cs.size(); ++i) {\n\t\tfor (int j = i+1; j < cs.size(); ++j) {\n\t\t\tvector<Point>ps(is_cc(cs[i], cs[j]));\n\t\t\tfor (auto p : ps) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < cs.size(); ++k) {\n\t\t\t\t\tif (abs(cs[k].p - p)>cs[k].r + eps)ok = false;\n\t\t\t\t}\n\t\t\t\tif (ok)return true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tPoint p(cs[i].p);\n\t\tbool ok = true;\n\t\tfor (int k = 0; k < cs.size(); ++k) {\n\t\t\tif (abs(cs[k].p - p)>cs[k].r + eps)ok = false;\n\t\t}\n\t\tif (ok)return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tbas.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x, y, l; cin >> x >> y >> l;\n\t\t\tbas.push_back(ballon{ x,y,l });\n\t\t}\n\t\tld amin = 0;\n\t\tld amax = 1000;\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tld amid = (amin + amax) / 2;\n\t\t\tif (check(amid)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(22) << fixed << amin << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nint n,l[15];\nP p[15];\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tif(sgn(a.r+b.r-d)<0) return OUT;\n\tif(sgn(a.r+b.r-d)==0) return ON_OUT;\n\tif(sgn(abs(a.r-b.r)-d)<0) return ISC;\n\tif(sgn(abs(a.r-b.r)-d)==0) return ON_IN;\n\treturn IN;\n}\nVP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\nVP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n\nR calc(P point){\n\tR res=INF;\n\trep(i,n) chmin(res,sq(norm(l[i])-norm(p[i]-point)));\n\treturn res;\n}\n\nP getpoint(int i,int j){\n\tL line={O,P(abs(p[j]-p[i]),0.0)};\n\tC ci={line.s,R(l[i])},cj={line.t,R(l[j])};\n\tVP res=pcc(ci,cj);\n\tR len=real(proj(line,res[0]));\n\tP ret=p[i]+len/abs(p[j]-p[i])*(p[j]-p[i]);\n\treturn ret;\n}\n\nL getline(int i,int j){\n\tP h=getpoint(i,j);\n\tP e=(p[j]-p[i])*P(0,1);\n\treturn L{h-e,h+e};\n}\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n) cin >> p[i] >> l[i];\n\t\tR ans=calc(O);\n\t\trep(i,n) chmax(ans,calc(p[i]));\n\t\trep(j,n)rep(i,j) chmax(ans,calc(getpoint(i,j)));\n\t\trep(k,n)rep(j,k)rep(i,j){\n\t\t\tL l1=getline(i,j),l2=getline(i,k);\n\t\t\tP candiate=cross(l1,l2);\n\t\t\tchmax(ans,calc(candiate));\n\t\t}\n\t\trep(i,n) chmin<R>(ans,l[i]);\n\t\tcout.precision(20);\n\t\tcout << fixed << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nstruct ballon {\n\tld x;\n\tld y;\n\tld l;\n};\nvector<ballon>bas;\n\nbool check(const ld h) {\n\tvector<Circle>cs;\n\tfor (auto b : bas) {\n\t\tif (b.l < h)return false;\n\t\telse {\n\t\t\tld rad = sqrt((b.l)*(b.l) - h*h);\n\t\t\tcs.emplace_back(Point(b.x, b.y), rad);\n\t\t}\n\t}\n\tfor (int i = 0; i < cs.size(); ++i) {\n\t\tfor (int j = i+1; j < cs.size(); ++j) {\n\t\t\tvector<Point>ps(is_cc(cs[i], cs[j]));\n\t\t\tfor (auto p : ps) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < cs.size(); ++k) {\n\t\t\t\t\tif (abs(cs[k].p - p)>cs[k].r + eps)ok = false;\n\t\t\t\t}\n\t\t\t\tif (ok)return true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tbas.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x, y, l; cin >> x >> y >> l;\n\t\t\tbas.push_back(ballon{ x,y,l });\n\t\t}\n\t\tld amin = 0;\n\t\tld amax = 1000;\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tld amid = (amin + amax) / 2;\n\t\t\tif (check(amid)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\tif (bas.size() == 1)amin = bas[0].l;\n\t\tcout << setprecision(22) << fixed << amin << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 100;\n  double ans=1;\n  while(len > 1e-6){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-5e-4;\n  }\n\n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//?????????\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> point;\ntypedef point vec;\ntypedef array<point, 2> line;\ntypedef vector<point> poly;\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n};\n\nenum geometry {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n\tbool operator<(point a, point b) {\n\t\tif (!EQ(a.X, b.X)) return a.X < b.X;\n\t\tif (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n\t\treturn false;\n\t}\n\n\tbool operator>(point a, point b) {\n\t\treturn b<a;\n\t}\n\n\tbool operator<=(point a, point b) {\n\t\treturn !(a>b);\n\t}\n}\n\ndouble dot(point a, point b) {\n\treturn (conj(a)*b).X;\n}\n\ndouble cross(point a, point b) {\n\treturn (conj(a)*b).Y;\n}\n\ngeometry ccw(point a, point b, point c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > EPS) return CCW; // ccw\n\tif (cross(b, c) < -EPS) return CW; // cw\n\tif (dot(b, c) < 0) return CAB; // c - a - b\n\tif (norm(b) < norm(c)) return ABC; // a - b - c\n\treturn ERROR;\n}\n\npoint proj(line l, point p) {\n\tpoint v = l[1]-l[0];\n\tdouble ratio = dot(v, p-l[0]) / norm(v);\n\treturn l[0] + ratio*v;\n}\n\npoint refl(line l, point p) {\n\treturn p + (proj(l, p) - p) * 2.0;\n}\n\nvec rotate(vec v, double r) {\n\treturn v*vec(cos(r), sin(r));\n}\n\nvec Normalvec(line l){\n\tvec v=(vec)l[1]-l[0];\n\treturn vec (v.Y,-v.X);\n}\n\nbool IsOrthogonal(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(line l, line m) {\n\tif (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n\tif (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n\treturn false;\n}\n\nbool IntersectLS(line l, line s) {\n\tpoint b = l[0];\n\tvec v = l[1]-l[0];\n\treturn cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(line s, line t) {\n\tif (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n\tif (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n\treturn true;\n}\n\nbool IntersectLP(line l, point p) {\n\treturn EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(line s, point p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(line l) {\n\treturn abs(l[0]-l[1]);\n}\n\ndouble DistLP(line l, point p) {\n\treturn abs(p - proj(l, p));\n}\n\ndouble DistLL(line l, line m) {\n\tif (!IntersectLL(l, m)) return 0;\n\treturn DistLP(l, m[0]);\n}\n\ndouble DistLS(line l, line s) {\n\tif (IntersectLS(l, s)) return 0;\n\treturn min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(line s, point p) {\n\tpoint r = proj(s, p);\n\tif (IntersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(line s, line t) {\n\tif (IntersectSS(s, t)) return 0;\n\n\tdouble a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n\tdouble b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n\treturn min(a, b);\n}\n\nline PerpendBisect(line seg) {\n\tpoint mid = (seg[0]+seg[1])/2.0;\n\treturn line{mid, mid+(seg[1]-seg[0])*vec(0, 1)};\n}\n\npoint CrosspointLL(line l, line m) {\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\tif (abs(A) < EPS) assert(0);\n\treturn m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<point> CrosspointCL(circle c, line l) {\n\tvector<point> ret;\n\tdouble d = DistLP(l, c.c);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(proj(l, c.c));\n\t} else if (d < c.r) {\n\t\tdouble ratio = sqrt(c.r*c.r - d*d);\n\t\tvec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n\t\tret.emplace_back(proj(l, c.c) + ratio*sgn);\n\t\tret.emplace_back(proj(l, c.c) - ratio*sgn);\n\t}\n\n\treturn ret;\n}\n\nvector<point> CrosspointCS(circle c, line s) {\n\tvector<point> ret;\n\tvector<point> res = CrosspointCL(c, s);\n\tif (s[0] > s[1]) swap(s[0], s[1]);\n\tfor (point p : res) {\n\t\tif (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n\t}\n\treturn ret;\n}\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nline CapCS(circle c, line s) {\n\tpoint inf(INF, INF);\n\tvector<point> cros = CrosspointCS(c, s);\n\tif (cros.empty()) return line{inf, inf};\n\n\tif (cros.size() == 1) {\n\t\tdouble ad = abs(s[0]-c.c);\n\t\tdouble bd = abs(s[1]-c.c);\n\t\tif (ad < min(bd, c.r)) cros.emplace_back(s[0]);\n\t\telse if (bd < min(ad, c.r)) cros.emplace_back(s[1]);\n\t\telse {\n\t\t\tpoint p = cros[0];\n\t\t\tcros.emplace_back(p); // avoid an undefined behavior\n\t\t}\n\t}\n\n\tif (cros[1] < cros[0]) {\n\t\tswap(cros[0], cros[1]);\n\t}\n\n\treturn line{cros[0], cros[1]};\n}\n\ngeometry Positioningpoint(poly poly, point p) {\n\tbool in = false;\n\tint n = poly.size();\n\tfor (int i=0; i<n; i++) {\n\t\tpoint a = poly[i];\n\t\tpoint b = poly[(i+1)%n];\n\t\tvec u = a - p;\n\t\tvec v = b - p;\n\n\t\tif (u.Y > v.Y) swap(u, v);\n\n\t\tdouble cr = cross(u, v);\n\t\tif (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n\t\tif (IntersectSP({a, b}, p)) return ON_LINE;\n\t}\n\n\tif (in) return INSIDE;\n\treturn OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\npoly GrahamScan(vector<point> ps) {//Get convex hull.\n\tif (ps.size() <= 2) return ps;\n\n\tint k = 0;\n\tint n = ps.size();\n\tpoly ret(n*2);\n\n\tsort(ps.begin(), ps.end());\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tint k_ = k;\n\tfor (int i=n-1; i>=0; i--) {\n\t\twhile (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tret.resize(k-1);\n\treturn ret;\n}\n\nbool IsConvex(poly ps) {\n\treturn GrahamScan(ps).size() == ps.size();\n}\n\npoly CapConvexes(poly pp, poly qq) {\n#if DEBUG\n\tassert (IsConvex(pp));\n\tassert (IsConvex(qq));\n#endif\n\n\tpoly ret;\n\tint a = 0;\n\tint b = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint n = pp.size();\n\tint m = qq.size();\n\tenum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n\tauto forward_a = [&](bool put) {\n\t\tif (put && in == PIN) ret.emplace_back(pp[a]);\n\t\ta = (a+1)%n;\n\t\taa++;\n\t};\n\n\tauto forward_b = [&](bool put) {\n\t\tif (put && in == QIN) ret.emplace_back(qq[b]);\n\t\tb = (b+1)%m;\n\t\tbb++;\n\t};\n\n\tauto intersect_1pt = [](point &a, point &b, point &c, point &d, point &r) {\n\t\tdouble D =\tcross(b - a, d - c);\n\t\tif (EQ(D, 0)) return false;\n\t\tdouble t =\tcross(c - a, d - c) / D;\n\t\tdouble s = -cross(a - c, b - a) / D;\n\t\tr = a + t * (b - a);\n\t\treturn GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n\t};\n\n\tdo {\n\t\tint apre = (a+n-1)%n;\n\t\tint bpre = (b+m-1)%m;\n\t\tdouble C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n\t\tdouble A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n\t\tdouble B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n\t\tpoint r;\n\t\tif (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n\t\t\tif (in == UNKNOWN) aa = bb = 0;\n\t\t\tret.emplace_back(r);\n\t\t\tif (B > 0) in = PIN;\n\t\t\telse if (A > 0) in = QIN;\n\t\t}\n\n\t\tif (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n\t\t\tif (in == PIN) forward_b(false);\n\t\t\telse forward_a(false);\n\t\t} else if (C >= 0) {\n\t\t\tif (A > 0) forward_a(true);\n\t\t\telse forward_b(true);\n\t\t} else {\n\t\t\tif (B > 0) forward_b(true);\n\t\t\telse forward_a(true);\n\t\t}\n\t} while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n\tif (in == UNKNOWN) {\n\t\tif (Positioningpoint(qq, pp[0]) != OUTSIDE) return pp;\n\t\tif (Positioningpoint(pp, qq[0]) != OUTSIDE) return qq;\n\t}\n\treturn ret;\n}\n\ndouble CalcArea(poly ps) {\n\tdouble ret = 0.0;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tret += cross(ps[i], ps[(i+1)%ps.size()]);\n\t}\n\treturn ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(poly ps) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\tint n = ps.size();\n\tint is = 0;\n\tint js = 0;\n\tfor (int i=1; i<n; i++) {\n\t\tif (ps[i].Y > ps[is].Y) is = i;\n\t\tif (ps[i].Y < ps[js].Y) js = i;\n\t}\n\n\tint maxi, maxj;\n\tdouble maxd = norm(ps[is]-ps[js]);\n\tint i = is;\n\tint j = js;\n\tdo {\n\t\tvec a = ps[i+1] - ps[i];\n\t\tvec b = ps[j+1] - ps[j];\n\t\tif (cross(a, b) > -EPS) j = (j+1)%n;\n\t\telse i = (i+1)%n;\n\n\t\tdouble d = norm(ps[i]-ps[j]);\n\t\tif (d > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\n\treturn make_pair(maxi, maxj);\n}\n\nline ClosestPair(vector<point> ps) {\n\tauto CompareY = [](const point &a, const point &b) {\n\t\tif (a.Y != b.Y) return a.Y < b.Y;\n\t\treturn a.X < b.X;\n\t};\n\n\tfunction<line(point*,int)> Rec = [&Rec, &CompareY](point *ps, int n) {\n\t\tif (n <= 1) return line{point(0, 0), point(INF, INF)};\n\t\t\n\t\tint m = n/2;\n\t\tdouble x = ps[m].X;\n\t\tline a = Rec(ps, m);\n\t\tline b = Rec(ps+m, n-m);\n\t\tdouble mind = DistL(a);\n\t\tline ret = a;\n\t\tif (DistL(b) < mind) {\n\t\t\tmind = DistL(b);\n\t\t\tret = b;\n\t\t}\n\n\t\tsort(ps, ps+n, CompareY);\n\t\tvector<point> qs;\n\t\tqs.reserve(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (abs(ps[i].X - x) >= mind) continue;\n\n\t\t\tfor (int j=0; j<qs.size(); j++) {\n\t\t\t\tpoint p1 = ps[i];\n\t\t\t\tpoint p2 = qs[qs.size()-1-j];\n\t\t\t\tif (p1.Y - p2.Y >= mind) break;\n\n\t\t\t\tdouble d = abs(p1-p2);\n\t\t\t\tif (mind > d) {\n\t\t\t\t\tmind = d;\n\t\t\t\t\tret = line{p1, p2};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqs.emplace_back(ps[i]);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tint n = ps.size();\n\tassert (n >= 2);\n\tsort(ps.begin(), ps.end());\n\treturn Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<poly, poly> CutConvex(poly ps, line l) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\t//if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n\t//else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n\tpoly left;\n\tpoly right;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tpoint a = ps[i];\n\t\tpoint b = ps[(i+1)%ps.size()];\n\n\t\tif (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n\t\telse right.emplace_back(a);\n\n\t\tline m{a, b};\n\t\tif (IntersectLS(l, m)) {\n\t\t\tpoint p = CrosspointLL(l, m);\n\t\t\tleft.emplace_back(p);\n\t\t\tright.emplace_back(p);\n\t\t}\n\t}\n\n\treturn make_pair(left, right);\n}\n\ncircle Circum(point a, point b, point c) {\n\tcircle ret{{INF, INF}, 0.0};\n\tline l{a, b};\n\tline m{b, c};\n\tline lp = PerpendBisect(l);\n\tline mp = PerpendBisect(m);\n\tif (IsParallel(lp, mp)) return ret;\n\n\tret.c = CrosspointLL(lp, mp);\n\tret.r = abs(a-ret.c);\n\treturn ret;\n}\n\nvector<point> Tangentpoints(circle c, point p) {\n\tvector<point> ret;\n\tdouble d = abs(c.c-p);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(p);\n\t\treturn ret;\n\t}\n\n\tif (d < c.r) return ret;\n\n\tvec v = (p-c.c)/d*c.r;\n\tdouble t = acos(c.r/d);\n\tret.emplace_back(c.c + rotate(v, t));\n\tret.emplace_back(c.c + rotate(v, -t));\n\treturn ret;\n}\n\nvector<line> CommonTangents(circle p, circle q) {\n#if DEBUG\n\tassert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n\tdouble pr = p.r;\n\tdouble qr = q.r;\n\tpoint pc = p.c;\n\tpoint qc = q.c;\n\tdouble d = abs(pc - qc);\n\tdouble dr = abs(pr - qr);\n\tdouble sr = abs(pr + qr);\n\n\tvector<line> ret;\n\tif (EQ(d, sr)) {//If the 2 circles tangent exclusively,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > sr) {//If the 2 have no intersection,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\tfor (int i=0; i<2; i++) {\n\t\t\tline l{pts[0], qts[i]};\n\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\tret.emplace_back(l);\n\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t}\n\t\t}\n\t} \n\n\tif (EQ(d, dr)) {//If the 2 tangent inclusively,\n\t\tpoint cp = pc + (pc-qc) / (qr-pr) * pr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > dr) {//If the 2 intersect,\n\t\tif (EQ(pr, qr)) {\n\t\t\tpoint v = (qc - pc) / d * pr;\n\t\t\tv *= point(0, 1);\n\t\t\tret.emplace_back(line{pc+v, qc+v});\n\t\t\tret.emplace_back(line{pc-v, qc-v});\n\t\t} else {\n\t\t\tpoint cp = pc + (qc-pc) * pr / (pr-qr);\n\t\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\t\tfor (int i=0; i<2; i++) {\n\t\t\t\tline l{pts[0], qts[i]};\n\t\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\t\tret.emplace_back(l);\n\t\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\n\treturn ret;\n}\n\ntypedef pair<point,double> ppd;\n\npoint p[10];\ndouble l[10];\nppd h[10][10];\n\nppd ans2(int i,int j){\n\tif(h[i][j].sc!=0){\n\t\treturn h[i][j];\n\t}\n\tdouble r=abs(p[i]-p[j]);\n\tppd ret;\n\tif(abs(l[i]*l[i]-l[j]*l[j])>=r*r){\n\t\tif(l[i]>l[j]){\n\t\t\tret.fi=p[j];\n\t\t\tret.sc=l[j];\n\t\t}else{\n\t\t\tret.fi=p[i];\n\t\t\tret.sc=l[i];\n\t\t}\n\t}else{\n\t\tcircle c,d;\n\t\tc.c=p[i];\n\t\tc.r=l[i];\n\t\td.c=p[j];\n\t\td.r=l[j];\n\t\tvector<point> v=CrosspointCC(c,d);\n\t\tret.fi=(v[0]+v[1])/2.0;\n\t\tret.sc=abs(v[0]-v[1])/2.0;\n\t}\n\th[i][j]=ret;\n\th[j][i]=ret;\n\treturn ret;\n}\n\nvoid solve(int n){\n\tdouble ans=301;\n\tint i[5];\n\tfor(int j=0;j<n;++j){\n\t\tint x,y;\n\t\tcin>>x>>y>>l[j];\n\t\tp[j]=point (x,y);\n\t\tfill(h[j],h[j]+n,mp(0,0));\n\t}\n\tif(n==1){//for the sake of avoiding bugs\n\t\tcout<<fixed<<setprecision(5)<<l[0]<<endl;\n\t\treturn;\n\t}else if(n==2){//for the same purpose\n\t\tcout<<fixed<<setprecision(5)<<ans2(0,1).sc<<endl;\n\t\treturn;\n\t}\n\tfor(i[0]=0;i[0]<n-2;++i[0]){\n\t\ti[3]=i[0];\n\t\tfor(i[1]=i[0]+1;i[1]<n-1;++i[1]){\n\t\t\ti[4]=i[1];\n\t\t\tfor(i[2]=i[1]+1;i[2]<n;++i[2]){\n\t\t\t\tbool f=false;\n\t\t\t\tppd pa[4];\n\t\t\t\tvector<line> m;\n\t\t\t\tpa[0]=ans2(i[0],i[1]),pa[1]=ans2(i[1],i[2]),pa[2]=ans2(i[2],i[0]),pa[3]=pa[0];\n\t\t\t\tfor(int j=0;j<3;++j){//??????\n\t\t\t\t\tif(pa[j].fi==pa[j+1].fi){\n\t\t\t\t\t\tans=min(ans,pa[j].sc);\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tif(pa[j].fi!=p[i[j]]&&pa[j].fi!=p[i[j+1]]){\n\t\t\t\t\t\tdouble r=abs(pa[j].fi-p[i[j+2]]);\n\t\t\t\t\t\tif(r*r+pa[j].sc*pa[j].sc<=l[i[j+2]]*l[i[j+2]]){\n\t\t\t\t\t\t\tans=min(ans,pa[j].sc);\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tm.pb({pa[j].fi,pa[j].fi+Normalvec({p[i[j]],p[i[j+1]]})});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpoint z=CrosspointLL(m[0],m[1]);\n\t\t\t\tdouble r=abs(z-p[i[0]]);\n\t\t\t\tans=min(ans,sqrt(l[i[0]]*l[i[0]]-r*r));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(5)<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = long double;\nconst T INF = 1e10;\nconst T EPS = 1e-10;\nconst T PI = acos(-1.0);\nT torad(int deg) {return (T)(deg) * PI / 180;}\nT todeg(T ang) {return ang * 180 / PI;}\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (T(0) < x) - (x < T(0)); }\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(T(1), a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline P linearTransform(P p, P q, P fp, P fq, P r) { return fp + (r - p) * (fq - fp) / (q - p); }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    istream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L() = default;\n    explicit L(P a, P b) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    bool onLine(P p) { return abs(side(p)) < EPS; }\n    bool onSegment(P p) { return onLine(p) && dot(this->operator[](0) - p, this->operator[](1) - p) <= EPS; }\n    friend istream& operator>>(istream& is, L& l) { P p, q; is >> p >> q; l = L(p, q); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C() = default;\n    C(P p, T r) : P(p), r(r) {}\n    friend istream& operator>>(istream& is, C& c) { P p; T r; is >> p >> r; c = C(p, r); return is; }\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS) return 1;         // counter clockwise\n    if (cross(b, c) < -EPS) return -1;       // clockwise\n    if (dot(b, c) < -EPS) return 2;          // c--a--b on line\n    if (norm(b) < norm(c) - EPS) return -2;  // a--b--c on line or a==b\n    return 0;                                // a--c--b on line or a==c or b==c\n}\n\n// intersect\nbool isInterPL(P p, L l) { return (ccw(l[0], l[1], p) != 1); }\nbool isInterPS(P p, L s) { return (ccw(s[0], s[1], p) == 0); }\nbool isInterLL(L l, L m) { return (!isPara(l.v, m.v)); }\nbool isInterLS(L l, L s) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], l);\n    return (ccw(l[0], l[1], s[0]) * ccw(l[0], l[1], s[1]) <= 0);\n}\nbool isInterSS(L s, L t) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], t);\n    if (eq(t[0], t[1])) return isInterPL(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n\n// distance\nT distancePL(P p, L l) { return (abs(p - l.proj(p))); }\nT distancePS(P p, L s) {\n    P h = s.proj(p);\n    if (isInterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nT distanceLL(L l, L m) {\n    if (isInterLL(l, m)) return 0.0;\n    return distancePL(m[0], l);\n}\nT distanceLS(L l, L s) {\n    if (isInterLS(l, s)) return 0;\n    return min(distancePL(s[0], l), distancePL(s[1], l));\n}\nT distanceSS(L s, L t) {\n    if (isInterSS(s, t)) return 0;\n    return min({distancePS(s[0], t), distancePS(s[1], t), distancePS(t[0], s), distancePS(t[1], s)});\n}\n\n// crosspoint\nvector<P> crosspointLL(L l, L m) {\n    if (!isInterLL(l, m)) return vector<P>();\n    vector<P> res;\n    T d = cross(m[1] - m[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLS(L l, L s) {\n    if (!isInterLS(l, s)) return vector<P>();\n    vector<P> res;\n    T d = cross(s[1] - s[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(s[1] - s[0], s[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLC(L l, C c, bool dupl = false) {\n    if (abs(c - l.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, l), h2 = c.r * c.r - d * d;\n    assert(h2 >= -EPS);\n    P p = l.proj(c), h = l.v * sqrt(h2) / abs(l.v);\n    res.push_back(p - h);\n    if (dupl || abs(h) > EPS) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointSS(L s, L t) {\n    if (!isInterSS(s, t)) return vector<P>();\n    vector<P> res;\n    T d = cross(t[1] - t[0], s[1] - s[0]);\n    if (d) {\n        res.push_back(s[0] + (s[1] - s[0]) * cross(t[1] - t[0], t[1] - s[0]) / d);\n    } else {\n        if (ccw(s[0], s[1], t[0]) == 0) res.push_back(t[0]);\n        if (ccw(s[0], s[1], t[1]) == 0) res.push_back(t[1]);\n        if (ccw(t[0], t[1], s[0]) == 0) res.push_back(s[0]);\n        if (ccw(t[0], t[1], s[1]) == 0) res.push_back(s[1]);\n    }\n    return res;\n}\nvector<P> crosspointSC(L s, C c, bool dupl = false) {\n    if (abs(c - s.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, s), h2 = c.r * c.r - d * d;\n    assert(h2 >= -EPS);\n    P p = s.proj(c), h = s.v * sqrt(h2) / abs(s.v);\n    if (isInterPS(p - h, s)) res.push_back(p - h);\n    if (dupl || (abs(h) > EPS && isInterPS(p + h, s))) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointCC(C c1, C c2, bool dupl = false) {\n    P d = c2 - c1; T d2 = norm(d);\n    if (d2 == 0) { assert(c1.r != c2.r); return vector<P>(); }\n    vector<P> res;\n    T pd = (d2 + c1.r * c1.r - c2.r * c2.r) / 2;\n    T h2 = c1.r * c1.r - pd * pd / d2;\n    if (h2 >= 0) {\n        P p = c1 + d * pd / d2, h = rot90(d) * sqrt(h2 / d2);\n        res.push_back(p - h);\n        if (dupl || abs(h) > EPS) res.push_back(p + h);\n    }\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int n;\n    while (cin >> n, n) {\n        vector<P> ps(n);\n        vector<int> l(n);\n        REP (i, n) cin >> ps[i] >> l[i];\n\n        int j = -1;\n        REP (i, n) if (j == -1 || l[i] < l[j] - EPS) j = i;\n\n        bool f = true;\n        REP (i, n) if (i != j) {\n            T r = sqrt(l[i] * l[i] - l[j] * l[j]);\n            f &= (abs(ps[i] - ps[j]) <= r + EPS);\n        }\n\n        if (f) {\n            cout << (T)l[j] << endl;\n            continue;\n        }\n\n        auto check = [&](T m) -> bool {\n            vector<C> cs(n);\n            REP (i, n) cs[i] = C(ps[i], sqrt(l[i] * l[i] - m * m));\n            vector<P> cps;\n            REP (i, n) FOR (j, i + 1, n) {\n                for (P& p : crosspointCC(cs[i], cs[j])) {\n                    cps.emplace_back(p);\n                }\n            }\n            for (P& p : cps) {\n                bool ok = true;\n                REP (i, n) {\n                    ok &= (abs(cs[i] - p) <= cs[i].r + EPS);\n                }\n                if (ok) return true;\n            }\n            return false;\n        };\n\n        T ok = 0, ng = l[j];\n        REP (i, 100) {\n            T m = (ok + ng) / 2;\n            if (check(m)) ok = m;\n            else ng = m;\n        }\n        cout << ok << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define double long double\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef complex<double> Point;\n\n//円と円の交点. 接する場合も空のvectorを返す. この誤魔化しは, 解heightを少し小さくすれば解消できるのでOK.\nvector<Point> kouten_CC(Point c1, double r1, Point c2, double r2) {\n\tPoint r = c2 - c1;\n\tif (norm(r) >= (r1 + r2) * (r1 + r2)) { return vector<Point>(); }\n\tif (min(r1, r2) + abs(r) <= max(r1, r2)) { return vector<Point>(); }\n\tdouble theta = acos((norm(r) + r1 * r1 - r2 * r2) / (2 * r1 * abs(r)));\n\tPoint R = (r1 / abs(r)) * r;\n\tPoint res1 = R * exp(Point(0, 1) * theta);\n\tPoint res2 = R * exp(Point(0, 1) * (-theta));\n\tvector<Point> ret;\n\tret.push_back(c1 + res1);\n\tret.push_back(c1 + res2);\n\treturn ret;\n}\n\nint n;\ndouble x[10], y[10], l[10];\n\nbool check(double h) {\n\tdouble r[10];\n\tint i, j, k;\n\t\n\trep(i, n) r[i] = sqrt(l[i] * l[i] - h * h);\n\t\n\t//cout << endl;\n\t//cout << \"h = \" << h << endl;\n\t//rep(i, n) cout << \"r[\" << i << \"] = \" << r[i] << endl;\n\t\n\tvector<Point> ps;\n\trep(i, n) {\n\t\tps.push_back(Point(x[i], y[i]));\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tps.push_back((Point(x[i], y[i]) + Point(x[j], y[j])) * (double)0.5);\n\t\t\tvector<Point> p = kouten_CC(Point(x[i], y[i]), r[i], Point(x[j], y[j]), r[j]);\n\t\t\trep(k, p.size()) {\n\t\t\t\tps.push_back(p[k]);\n\t\t\t\t//cout << p[k] << endl;\n\t\t\t}\n\t\t\tif (p.size() == 2) {\n\t\t\t\tps.push_back((p[0] + p[1]) * (double)0.5);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//交点ps[i]が全ての円に含まれるか判定.\n\t//誤差が無い場合、円jが交点ps[i]をギリギリ含むことがある。\n\t//誤差が無い場合、解hを小さくすることで誤魔化すのは難しい。(交点しか見ないため）\n\t//そこで、円jを少しだけ大きくしておいて判定する。\n\tdouble EPS = 1e-11;\n\trep(i, n) r[i] += EPS;\n\trep(i, ps.size()) {\n\t\tint cnt = 0;\n\t\trep(j, n) {\n\t\t\tPoint diff = Point(x[j], y[j]) - ps[i];\n\t\t\tif (abs(diff) <= r[j]) cnt++;\n\t\t}\n\t\tif (cnt == n) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\tint i;\n\t\tdouble minL = 114514;\n\t\trep(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t\tminL = min(minL, l[i]);\n\t\t}\n\t\t\n\t\tdouble st = 0, ed = minL, mid;\n\t\trep(i, 100) {\n\t\t\tmid = (st + ed) / 2;\n\t\t\tif (check(mid)) st = mid;\n\t\t\telse ed = mid;\n\t\t}\n\t\tprintf(\"%.14Lf\\n\", st);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1000000;\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x = 0.0, double y = 0.0):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point &p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point &p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point &p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline double norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\ninline double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ninline double cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a, const point &b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(const point &c, double r):c(c), r(r){}\n};\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double t = cross(b, c);\n\tif(t > EPS) return 1; // ccw\n\tif(t < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) return point(INF, INF); // 交点を持たない\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) return res; // 中心の座標が同じ\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nint main() {\n\tfor(int n; scanf(\"%d\", &n), n;) {\n\t\tvector<circle> cs;\n\t\tcs.reserve(n);\n\t\tvector<point> candidates;\n\t\tcandidates.reserve(n * n * n * n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, l;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &l);\n\t\t\tcs.emplace_back(point(x, y), l);\n\t\t\tcandidates.emplace_back(cs[i].c);\n\t\t}\n\n\t\tvector<segment> segs;\n\t\tsegs.reserve(n * n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(!intersect(cs[i], cs[j])) continue;\n\n\t\t\t\tconst vector<point> ps = crosspoint(cs[i], cs[j]);\n\t\t\t\tcandidates.emplace_back((ps[0] + ps[1]) / 2.0);\n\t\t\t\tsegs.emplace_back(ps[0], ps[1]);\n\t\t\t}\n\t\t}\n\n\t\tconst int m = segs.size();\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tfor(int j = i + 1; j < m; ++j) {\n\t\t\t\tconst point p = crosspoint(segs[i], segs[j]);\n\t\t\t\tif(p.x < INF) candidates.emplace_back(p);\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = 1.0;\n\t\tfor(const auto &p : candidates) {\n\t\t\tdouble mn = INF;\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tchmin(mn, cs[j].r * cs[j].r - norm(cs[j].c - p));\n\t\t\t}\n\t\t\tchmax(ans, mn);\n\t\t}\n\n\t\tprintf(\"%.7lf\\n\", sqrt(ans));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\n//円\nstruct Circle{\n  P c; //中心点\n  double r; //半径\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\n//円と円の交点\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //円１と円２が同じ場合（無限個になるため除外）\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //交わらない\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nint n, x[10], y[10], l[10];\n\nbool check(double h){\n  \n  Circle c[10];\n  \n  vector<P> points;\n  \n  for(int i=0;i<n;i++){\n    \n    P p = P( 1.0 * x[i], 1.0 * y[i] );\n    double r = sqrt( l[i] * l[i] - h * h );\n    \n    c[i] = Circle( p, r );\n    \n    points.push_back(p);\n    \n  }  \n  \n  for(int i=0;i<n;i++){\n    \n    for(int j=i+1;j<n;j++){\n      \n      vector<P> r = getIntersectCC( c[i], c[j] );\n      \n      for(int k=0;k<(int)r.size();k++) points.push_back(r[k]);\n      \n    }\n    \n  }\n  \n  for(int i=0;i<(int)points.size();i++){\n    \n    int flag = true;\n    \n    for(int j=0;j<n;j++){\n      \n      double len1 = c[j].r;\n      double len2 = abs( points[i] - c[j].c );\n      \n      if( len1 + EPS < len2 ) flag = false;\n\t\n    }\n    \n    if( flag ) return true;\n    \n  }  \n  \n  return false;\n}\n\nvoid solve(){\n  \n  int minl = 300;\n  \n  for(int i=0;i<n;i++) minl = min( minl, l[i] );  \n\n  double L = 0, R = minl;\n  int cnt = 100;\n  \n  while( cnt-- ){\n    \n    double M = ( L + R ) / 2.0;\n    \n    if( check(M) == true ) L = M;\n    else R = M;\n    \n  }\n  \n  printf(\"%.8f\\n\", L );\n  \n}\n\nsigned main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n  \n    for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];\n  \n    solve();\n  \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.0000001;\nusing p2 = complex<double>;\n// x: real\n// y: imag\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\nbool same(double x, double y) { return fabs(x - y) < eps; }\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (fabs(l.real() - r.real()) > eps)\n    return l.real() < r.real();\n  return l.imag() < r.imag();\n};\nstruct Line {\n  p2 st, ed;\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n  Line(double x1, double y1, double x2, double y2)\n      : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n  double dist() { return sqrt(dist2(st, ed)); }\n  bool isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n  double x() { return ed.real() - st.real(); }\n  double y() { return ed.imag() - st.imag(); }\n};\n\n// l1.st + (l1.st - l1.ed) * r.first = l2.st + (l2.st - l2.ed) * r.second\n// 方程式を満たす(r.first, r.second)を返す\n// l1.isPalla(l2) => (nan, nan)\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return eps < r.first && r.first < 1. - eps && eps < r.second &&\n         r.second < 1. - eps;\n}\n\nstruct Poly {\n  vector<p2> ps;\n  Poly(vector<p2> ps) : ps(ps) {}\n  bool include(p2 p) {\n    vector<double> b;\n    for (int i = 0; i < ps.size(); i++) {\n      b.push_back(det(p, ps[i] - ps[(i + 1) % ps.size()]));\n    }\n    bool allPlus = true, allMinus = true;\n    for (auto &x : b) {\n      if (x > eps)\n        allMinus = false;\n      if (x < -eps)\n        allPlus = false;\n    }\n    return allMinus || allPlus;\n  }\n  bool intersecl(Line l) {\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        return true;\n    }\n    return false;\n  }\n};\n\nstruct Circle {\n  p2 p;\n  double r;\n  Circle(p2 p, double r) : p(p), r(r) {}\n  bool include(p2 l) { return dist2(p, l) < r * r + eps; }\n\n  // 円同士の交点\n  // 存在すれば2つ\n  vector<p2> intersec(Circle c) {\n    p2 diff = c.p - p;\n    double dist = dot(diff, diff);\n    double a = (dist + r * r - c.r * c.r) / 2.;\n    double D = dist * r * r - a * a;\n    if (D < eps)\n      return vector<p2>();\n    double Dsqrt = sqrt(D);\n    vector<p2> ps;\n    ps.emplace_back((a * diff.real() + diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() - diff.real() * Dsqrt) / dist + p.imag());\n    ps.emplace_back((a * diff.real() - diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() + diff.real() * Dsqrt) / dist + p.imag());\n    return ps;\n  }\n};\n\n// 逆時計回り\nstruct ConX {\n  vector<p2> ps;\n  // graham scan\n  // ref: プログラミングコンテストチャレンジブック p233\n  ConX(vector<p2> v) {\n    sort(v.begin(), v.end(), p2comp);\n\n    int k = 0, n = v.size();\n    ps.resize(n * 2);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    ps.resize(k - 1);\n  }\n  size_t size() { return ps.size(); }\n};\n\nint n;\nvector<double> rs;\nvector<p2> ps;\nvector<Circle> cs;\n\nbool f(double l) {\n  cs.clear();\n  for (int i = 0; i < n; i++) {\n    double rr = rs[i] * rs[i] - l * l;\n    if (rr < eps)\n      return false;\n    cs.emplace_back(ps[i], sqrt(rr));\n  }\n  vector<p2> may;\n  for (int i = 0; i < n; i++) {\n    may.push_back(cs[i].p);\n    for (int j = i + 1; j < n; j++) {\n      auto v = cs[i].intersec(cs[j]);\n      if (v.size() == 0)\n        continue;\n      may.push_back(v[0]);\n      may.push_back(v[1]);\n    }\n  }\n  for (auto &p : may) {\n    bool ok = true;\n    for (auto &c : cs) {\n      if (!c.include(p)) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok)\n      return true;\n  }\n  return false;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  while (true) {\n    cin >> n;\n    if (n == 0)\n      break;\n    rs.resize(n);\n    ps.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      double x, y;\n      cin >> x >> y >> rs[i];\n      ps[i] = p2(x, y);\n    }\n\n    double l = 0., r = 300.;\n    for (int i = 0; i < 200; i++) {\n      double m = (l + r) / 2.;\n      if (f(m)) {\n        l = m;\n      } else {\n        r = m;\n      }\n    }\n    printf(\"%.6lf\\n\", l);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\ntypedef complex<ld> Point;\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\n\nPoint input_point() {\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n    return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n    Point a, b;\n    Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle () : p(Point(0, 0)), r(0) {}\n    Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n    return isis_ll(l, s) &&\n        (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n        ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res;\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps){\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d,\tc.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0,\t1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = p.size();\n    REP(j,n) res += cross(p[j], p[(j+1)%n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = ps.size();\n    Polygon Q;\n    REP(i,n) {\n        Point A = ps[i], B = ps[(i+1)%n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n    for (Point q : ps) if (abs(q - p) < eps) return;\n    ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n    g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n    int n = p.size(), m = s.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (isis_sp(s[i], p[j]))\n            vec.emplace_back(abs(s[i].a - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            add_edge(g, from, to, abs(p[from] - p[to]));\n        }\n    }\n    return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n    int n = p.size(), m = c.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n            vec.emplace_back(arg(c[i].p - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            ld angle = vec[j+1].first - vec[j].first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n        if (vec.size() >= 2) {\n            int from = vec.back().second, to = vec.front().first;\n            ld angle = vec.front().first - vec.back().first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n    }\n    return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n    int N = p.size();\n    polygon.clear();\n    REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n    vector<vector<tuple<ld,int,bool>>> tup(N);\n    REP(i,s.size()) {\n        int a = -1, b = -1;\n        REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n        REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n        assert(a >= 0 && b >= 0);\n        tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n        tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n    }\n    REP(i,N) sort(ALL(tup[i]));\n    REP(i,N) {\n        REP(j,tup[i].size()) {\n            ld angle; int pos = j, from = i, to; bool flag;\n            tie(angle, to, flag) = tup[i][j];\n            if (flag) continue;\n            vector<int> ps;\n            while (!flag) {\n                ps.push_back(from);\n                get<2>(tup[from][pos]) = true;\n                seg2p[from][to].push_back(polygon.size());\n                seg2p[to][from].push_back(polygon.size());\n                angle += pi + eps;\n                if (angle > pi) angle -= 2 * pi;\n                auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n                if (it == tup[to].end()) it = tup[to].begin();\n                from = to; tie(angle, to, flag) = *it;\n                pos = it - tup[from].begin();\n            }\n            polygon.push_back(ps);\n        }\n    }\n    Graph g(polygon.size());\n    REP(i,N) REP(j,i) {\n        if (seg2p[i][j].size() == 2) {\n            int from = seg2p[i][j][0], to = seg2p[i][j][1];\n            g[from].push_back((Edge){from, to});\n            g[to].push_back((Edge){to, from});\n        }\n    }\n    return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n    fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n    Point v = l.b - l.a;\n    Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n    int n = p.size();\n    REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n;\n    while (cin >> n, n) {\n        vector<ll> X(n), Y(n), L(n);\n        REP(i, n) {\n            cin >> X[i] >> Y[i] >> L[i];\n        }\n        auto check = [&](double h) {\n            vector<double> r(n);\n            REP(i, n) {\n                double rr = L[i]*L[i]-h*h;\n                if (rr < 0) return false;\n                r[i] = sqrt(rr);\n            }\n            vector<Circle> c;\n            REP(i, n) {\n                c.pb({{X[i], Y[i]}, r[i]});\n            }\n            vector<Point> kh;\n            REP(i, n) kh.pb(c[i].p);\n            REP(i, n) FOR(j, i+1, n) {\n                vector<Point> v = is_cc(c[i], c[j]);\n                EACH(p, v) kh.pb(p);\n            }\n            EACH(p, kh) {\n                bool f = true;\n                REP(i, n) {\n                    if (abs(p-Point(X[i], Y[i])) > r[i]+eps) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return true;\n            }\n            return false;\n        };\n        double l = 0, r = 1000;\n        REP(t, 100) {\n            double m = (l + r) / 2;\n            if (check(m)) l = m;\n            else r = m;\n        }\n        cout << fixed << setprecision(10) << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.0000001;\nusing p2 = complex<double>;\n// x: real\n// y: imag\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\nbool same(double x, double y) { return fabs(x - y) < eps; }\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (fabs(l.real() - r.real()) > eps)\n    return l.real() < r.real();\n  return l.imag() < r.imag();\n};\nstruct Line {\n  p2 st, ed;\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n  Line(double x1, double y1, double x2, double y2)\n      : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n  double dist() { return sqrt(dist2(st, ed)); }\n  bool isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n  double x() { return ed.real() - st.real(); }\n  double y() { return ed.imag() - st.imag(); }\n};\n\n// l1.st + (l1.st - l1.ed) * r.first = l2.st + (l2.st - l2.ed) * r.second\n// 方程式を満たす(r.first, r.second)を返す\n// l1.isPalla(l2) => (nan, nan)\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return eps < r.first && r.first < 1. - eps && eps < r.second &&\n         r.second < 1. - eps;\n}\n\nstruct Poly {\n  vector<p2> ps;\n  Poly(vector<p2> ps) : ps(ps) {}\n  bool include(p2 p) {\n    vector<double> b;\n    for (int i = 0; i < ps.size(); i++) {\n      b.push_back(det(p, ps[i] - ps[(i + 1) % ps.size()]));\n    }\n    bool allPlus = true, allMinus = true;\n    for (auto &x : b) {\n      if (x > eps)\n        allMinus = false;\n      if (x < -eps)\n        allPlus = false;\n    }\n    return allMinus || allPlus;\n  }\n  bool intersecl(Line l) {\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        return true;\n    }\n    return false;\n  }\n};\n\nstruct Circle {\n  p2 p;\n  double r;\n  Circle(p2 p, double r) : p(p), r(r) {}\n  bool include(p2 l) { return dist2(p, l) < r * r + eps; }\n\n  // 円同士の交点\n  // 存在すれば2つ\n  vector<p2> intersec(Circle c) {\n    p2 diff = c.p - p;\n    double dist = dot(diff, diff);\n    double a = (dist + r * r - c.r * c.r) / 2.;\n    double D = dist * r * r - a * a;\n    if (D < eps)\n      return vector<p2>();\n    double Dsqrt = sqrt(D);\n    vector<p2> ps;\n    ps.emplace_back((a * diff.real() + diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() - diff.real() * Dsqrt) / dist + p.imag());\n    ps.emplace_back((a * diff.real() - diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() + diff.real() * Dsqrt) / dist + p.imag());\n    return ps;\n  }\n};\n\n// 逆時計回り\nstruct ConX {\n  vector<p2> ps;\n  // graham scan\n  // ref: プログラミングコンテストチャレンジブック p233\n  ConX(vector<p2> v) {\n    sort(v.begin(), v.end(), p2comp);\n\n    int k = 0, n = v.size();\n    ps.resize(n * 2);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    ps.resize(k - 1);\n  }\n  size_t size() { return ps.size(); }\n};\n\nint n;\nvector<double> rs;\nvector<p2> ps;\nvector<Circle> cs;\n\nbool f(double l) {\n  cs.clear();\n  for (int i = 0; i < n; i++) {\n    double rr = rs[i] * rs[i] - l * l;\n    if (rr < eps)\n      return false;\n    cs.emplace_back(ps[i], sqrt(rr));\n  }\n  vector<p2> may;\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      auto v = cs[i].intersec(cs[j]);\n      may.push_back(cs[i].p);\n      if (v.size() == 0)\n        continue;\n      may.push_back(v[0]);\n      may.push_back(v[1]);\n    }\n  for (auto &p : may) {\n    bool ok = true;\n    for (auto &c : cs) {\n      if (!c.include(p)) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok)\n      return true;\n  }\n  return false;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  while (true) {\n    cin >> n;\n    if (n == 0)\n      break;\n    rs.resize(n);\n    ps.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      double x, y;\n      cin >> x >> y >> rs[i];\n      ps[i] = p2(x, y);\n    }\n\n    if (n == 1) {\n      printf(\"%.6lf\\n\", rs[0]);\n      continue;\n    }\n\n    double l = 0., r = 300.;\n    for (int i = 0; i < 200; i++) {\n      double m = (l + r) / 2.;\n      if (f(m)) {\n        l = m;\n      } else {\n        r = m;\n      }\n    }\n    printf(\"%.6lf\\n\", l);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <tuple>\n#include <cmath>\n\n#define ISLOOSE(a,b)\t(disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n\nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\ndouble heron(double a, double b, double c)\n{\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n\treturn sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n\ntuple<double, double, double> com(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b)) {\n\t\treturn a;\n\t}\n\telse if (disdis(a, b) + get<2>(b) * get<2>(b) <= get<2>(a) * get<2>(a)) {\n\t\treturn b;\n\t}\n\telse {\n\t\tdouble l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n\t\tdouble d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n\t\tdouble d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n\t\treturn tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n\t}\n}\n\ndouble two(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b)) {\n\t\treturn (double)get<2>(a);\n\t}\n\telse if (disdis(a, b) + get<2>(b) * get<2>(b) <= get<2>(a) * get<2>(a)) {\n\t\treturn (double)get<2>(b);\n\t}\n\telse {\n\t\tdouble d = sqrt(disdis(a, b));\n\t\treturn heron(get<2>(a), get<2>(b), d) * 2 / d;\n\t}\n}\n\ndouble three(const tuple<double, double, double>& a, const tuple<double, double, double>& b, const tuple<double, double, double>& c)\n{\n\ttuple<double, double, double> temp;\n\n\tif (ISLOOSE(a, b) && ISLOOSE(a, c))\n\t\treturn get<2>(a);\n\tif (ISLOOSE(b, a) && ISLOOSE(b, c))\n\t\treturn get<2>(b);\n\tif (ISLOOSE(c, a) && ISLOOSE(c, b))\n\t\treturn get<2>(c);\n\n\tif (ISLOOSE(temp = com(a, b), c))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(b, c), a))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(c, a), b))\n\t\treturn get<2>(temp);\n\n\treturn heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n\t\t* 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n\nint main()\n{\n\tint n;\n\tdouble res;\n\twhile (cin >> n, n) {\n\t\tvector< tuple<double, double, double> > str(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << fixed << setprecision(7) << (double)get<2>(str[0]) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcout << fixed << setprecision(7) << two(str[0], str[1]) << endl;\n\t\t}\n\t\telse {\n\t\t\tres = 100000000.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tres = min(res, three(str[i], str[j], str[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(7) << res << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(x, p.x), add(y, p.y));\n  }\n  P operator - (P p) {\n    return P(add(x, -p.x), add(y, -p.y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  P operator / (double d) {\n    return P(x / d, y / d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p, int i1, int i2) {\n  //for (int i = 0; i < n; i++) if ((add((p - dir[i]).square(), -r[i] * r[i]))>0.000005&&1.0>add((p - dir[i]).square(), -r[i] * r[i]))printf(\"%f \",(add((p - dir[i]).square(), -r[i] * r[i])));\n  //for (int i = 0; i < n; i++) printf(\"%f \",(add((p - dir[i]).square(), -r[i] * r[i])));\n  //printf(\"\\n\");\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && 0.000005 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) return false;//r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i], -h * h));\n //   printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      //printf(\"\\nt:%d\\n\",t);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 / (l1 + l2) + dir[j] * l1 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d, i, j)) return true;\n        if (canClear(ave - d, i, j)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t], -1, -1)) return true;////////////!!!!!!!!!!\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n//    printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n   // printf(\"%d\\n\",(int)check(116.190917));\n    //printf(\"%d\\n\",(int)check(123.016154));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-9;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return eq(sum, 0) ? 2 : 1;\n}\n\npoint reflection(line const& l, point p) {\n    auto pro = proj(l, p);\n    return p + (pro - p) + (pro - p);\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i=0; i<N; ++i) {\n        res += cross(p[i], p[(i+1)%N]);\n    }\n    return res / 2;\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i=0; i<N; ++i) {\n        auto a = p[i], b = p[(i+1)%N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\npolygon convex_hull(vector<point> ps) {\n    sort(ps.begin(), ps.end(), [&](point const& p1, point const& p2) {\n        if(real(p1) == real(p2)) {\n            return imag(p1) < imag(p2);\n        }\n        return real(p1) < real(p2);\n    });\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2*n);\n    for(int i=0; i<n; ++i) {\n        while(k > 1 && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i=n-2, t = k; i>=0; --i) {\n        while(k > t && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nbool check(vector<point> const& ps, vector<ld> const& l, ld mid) {\n    const int n = ps.size();\n    vector<point> cand;\n    vector<circle> cs(n);\n    for(int i=0; i<n; ++i) {\n        cs[i].p = ps[i];\n        cand.push_back(ps[i]);\n        if(l[i] < mid) {\n            return false;\n        }\n        cs[i].r = sqrt(l[i]*l[i] - mid*mid);\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=i+1; j<n; ++j) {\n            auto is = is_cc(cs[i], cs[j]);\n            for(auto p : is) {\n                cand.push_back(p);\n            }\n        }\n    }\n    for(auto& p : cand) {\n        bool ok = true;\n        for(int i=0; i<n; ++i) {\n            ok &= abs(p - cs[i].p) <= cs[i].r + eps; \n        }\n        if(ok) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<point> ps(n);\n        vector<ld> l(n);\n        for(int i=0; i<n; ++i) {\n            ld x, y;\n            cin >> x >> y >> l[i];\n            ps[i] = point(x, y);\n        }\n        ld lb = 1, ub = 1e9;\n        while(ub - lb > eps) {\n            auto m = (ub + lb) / 2;\n            if(check(ps, l, m)) {\n                lb = m;\n            } else {\n                ub = m;\n            }\n        }\n        cout << fixed << setprecision(10) << lb << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\nconst double EPS = 1e-8;\n\nstruct Point {\n\tdouble x, y;\n\tPoint() : x(0), y(0) { }\n\tPoint(double x, double y) : x(x), y(y) { }\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator+=(const Point &p){ x += p.x; y += p.y; return *this; }\n\tPoint &operator-=(const Point &p){ x -= p.x; y -= p.y; return *this; }\n\tPoint &operator*=(double s){ x *= s; y *= s; return *this; }\n\tPoint &operator/=(double s){ x /= s; y /= s; return *this; }\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\ninline Point operator*(double s, const Point &p){ return p * s; }\n\ninline double norm(const Point &p){ return p.x * p.x + p.y * p.y; }\ninline double abs(const Point &p){ return sqrt(norm(p)); }\ninline double arg(const Point &p){ return atan2(p.y, p.x); }\ninline Point unit(const Point &p){ return p / abs(p); }\ninline Point ortho(const Point &p){ return Point(-p.y, p.x); }\ninline double cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline double dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle() : p(), r(0) { }\n\tCircle(Point p, double r) : p(p), r(r) { }\n\tbool operator==(const Circle &c) const { return p == c.p && r == c.r; }\n\tbool operator!=(const Circle &c) const { return p != c.p || r != c.r; }\n\tbool operator<(const Circle &c) const {\n\t\treturn (p == c.p) ? (r < c.r) : (p < c.p);\n\t}\n};\n\ninline double heron(double a, double b, double c){\n\tdouble s = (a + b + c) / 2.0;\n\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\ninline bool intersect(const Circle &a, const Circle &b){\n\tconst double d = abs(a.p - b.p);\n\treturn (d >= abs(a.r - b.r) - EPS) && (d <= a.r + b.r + EPS);\n}\ninline vector<Point> crossing_points(const Circle &a, const Circle &b){\n\tconst double l = abs(b.p - a.p);\n\tconst double d = 2.0 * heron(l, a.r, b.r) / l;\n\tconst double t = sqrt(a.r * a.r - d * d);\n\tconst Point v = t * unit(b.p - a.p);\n\tconst Point w = d * unit(ortho(v));\n\treturn vector<Point>({ a.p + v + w, a.p + v - w });\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setiosflags(ios::fixed) << setprecision(10);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Circle> anchors(n);\n\t\tdouble min_length = 1e10;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tCircle &c = anchors[i];\n\t\t\tcin >> c.p.x >> c.p.y >> c.r;\n\t\t\tmin_length = min(min_length, c.r);\n\t\t}\n\t\tdouble left = 0.0, right = min_length;\n\t\tfor(int iter = 0; iter < 100; ++iter){\n\t\t\tconst double center = (left + right) / 2.0;\n\t\t\tconst double h = center;\n\t\t\tvector<Circle> areas(n);\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tconst Circle &c = anchors[i];\n\t\t\t\tconst double r = sqrt(c.r * c.r - h * h);\n\t\t\t\tareas[i] = Circle(c.p, r);\n\t\t\t}\n\t\t\tvector<Point> candidates;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tcandidates.push_back(areas[i].p);\n\t\t\t\tfor(int j = i + 1; j < n; ++j){\n\t\t\t\t\tif(!intersect(areas[i], areas[j])){ continue; }\n\t\t\t\t\tconst vector<Point> cp =\n\t\t\t\t\t\tcrossing_points(areas[i], areas[j]);\n\t\t\t\t\tcandidates.push_back(cp[0]);\n\t\t\t\t\tcandidates.push_back(cp[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst int m = candidates.size();\n\t\t\tbool accept = false;\n\t\t\tfor(int i = 0; !accept && i < m; ++i){\n\t\t\t\tconst Point p = candidates[i];\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int j = 0; flag && j < n; ++j){\n\t\t\t\t\tconst Circle c(areas[j].p, areas[j].r + EPS);\n\t\t\t\t\tif(norm(c.p - p) > c.r * c.r){ flag = false; }\n\t\t\t\t}\n\t\t\t\tif(flag){ accept = true; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tleft = center;\n\t\t\t}else{\n\t\t\t\tright = center;\n\t\t\t}\n\t\t}\n\t\tcout << left << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\nusing namespace std;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\n\nbool zero(double a) { return abs(a) <= EPS; }\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nbool canClear(P p, int i1, int i2) {\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && EPS + r[i] < abs(p - dir[i])) return false;\n  return true;\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (-EPS > ((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt((double)l[i] * l[i] - h * h);\n  }\n  for (int i = 0; i < n; i++) if (canClear(dir[i], -1, -1)) return true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      double d = abs(dir[j] - dir[i]);\n      if (d - r[i] - r[j] > EPS) return false;\n      if (r[i] - r[j] - d > EPS) continue;\n      if (r[j] - r[i] - d > EPS) continue;\n      double A = atan2((dir[j] - dir[i]).imag(), (dir[j] - dir[i]).real());\n      double S = acos((d*d + r[i]*r[i] - r[j]*r[j]) / (2 * d * r[i]));\n      if (canClear(dir[i] + polar(r[i], A + S), i, j)) return true;\n      if (canClear(dir[i] + polar(r[i], A - S), i, j)) return true;\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i] = P(x[i], y[i]);\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n\nstruct sphere {\n\tdouble x, y, r;\n\tsphere(double x_, double y_, double r_) {\n\t\tx = x_; y = y_; r = r_;\n\t}\n};\n\nconst double EPS = 1e-10;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<sphere> v;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(sphere(x, y, r));\n\t\t}\n\n\t\tdouble top, bottom;\n\t\ttop = 300; bottom = 0;\n\t\tfor(int i = 0; i < 40; i++) {\n\t\t\tbool flag = true;\n\t\t\tdouble z = (top + bottom) / 2;\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(z > v[j].r)\n\t\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tvector<pair<double,double> > points;\n\t\t\tfor(int j = 0; j < v.size() && flag; j++) {\n\t\t\t\tpoints.push_back(pair<double,double>(v[j].x, v[j].y));\n\t\t\t\tfor(int k = j + 1; k < v.size(); k++) {\n\t\t\t\t\tdouble r0, r1;\n\t\t\t\t\tr0 = sqrt(sqr(v[j].r) - sqr(z));\n\t\t\t\t\tr1 = sqrt(sqr(v[k].r) - sqr(z));\n\t\t\t\t\tdouble d;\n\t\t\t\t\td = sqrt(sqr(v[j].x - v[k].x) + sqr(v[j].y - v[k].y));\n\n\t\t\t\t\tif(!(r0 + r1 < d || r1 + d < r0 || d + r0 < r1)) {\n\t\t\t\t\t\tdouble theta, phi;\n\t\t\t\t\t\ttheta = atan2(v[k].y - v[j].y, v[k].x - v[j].x);\n\t\t\t\t\t\tphi = acos((sqr(r0) + sqr(d) - sqr(r1)) / (2 * r0 * d));\n\n\t\t\t\t\t\tif(isnan(theta) || isnan(phi))\n\t\t\t\t\t\t\tcout << \"viss\" << endl;\n\n\t\t\t\t\t\tdouble x0, y0, x1, y1;\n\t\t\t\t\t\tx0 = v[j].x + r0 * cos(theta + phi);\n\t\t\t\t\t\ty0 = v[j].y + r0 * sin(theta + phi);\n\t\t\t\t\t\tx1 = v[j].x + r0 * cos(theta - phi);\n\t\t\t\t\t\ty1 = v[j].y + r0 * sin(theta - phi);\n\t\t\t\t\t\tpoints.push_back(pair<double,double>(x0, y0));\n\t\t\t\t\t\tpoints.push_back(pair<double,double>(x1, y1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tfor(int j = 0; j < points.size(); j++) {\n\t\t\t\t\tbool sub_flag = true;\n\t\t\t\t\tflag = false;\n\t\t\t\t\tfor(int k = 0; k < v.size(); k++) {\n\t\t\t\t\t\tif(sqrt(sqr(points[j].first - v[k].x) + sqr(points[j].second - v[k].y)) > sqrt(sqr(v[k].r) - sqr(z)) + EPS) {\n\t\t\t\t\t\t\tsub_flag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sub_flag) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t\ttop = z;\n\t\t\telse\n\t\t\t\tbottom = z;\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", (top + bottom) / 2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n    \n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n    \n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n    \n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n    \n  static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n  D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n  D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n  P project(P vec,P x){return vec*(x/vec).real();}\n    \n  P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n  P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n  P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n    \n  bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n    \n  D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n  D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n    \n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n    \n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n    \n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n    \n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n    \n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n    \n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n    \n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n    \n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n    \n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=[&](){\n               for(auto &I:pts){\n                 if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n                 while(ret.size()>1){\n                   P A=ret.back()-ret[ret.size()-2];\n                   P B=I-ret.back();\n                   if(cross(A,B)<-EPS){ret.pop_back();}\n                   else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){ret.pop_back();}\n                   else{break;}\n                 }\n                 ret.push_back(I);\n               }\n             };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n    \n  //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n    \n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n    \n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n    \n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n    \n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n    \n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n        }\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n      else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n    \n  //反時計回り\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n      else{(++r)%=n;}\n    }\n    return ret;\n  }\n    \n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n    \n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n    \n  void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n    \n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=\n      [&](int v,int pre){\n        if(pre!=-1 && v==0){return;}\n        ret.push_back(pt[v]);\n        vector<pair<D,int>> nx;\n        for(auto &u:edge[v]){\n          D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n          if(abs(a+PI)<EPS){a=PI;}\n          nx.emplace_back(a,u);\n        }\n        sort(nx.begin(),nx.end());\n        dfs(nx[0].S,v);\n      };\n    dfs(0,-1);\n    return ret;\n  }\n    \n  istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n  istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n  void Input(P &p){D x,y;cin>>x>>y;p={x,y};}\n};\n\nusing namespace Geometry;\n\n//4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\nbool judge(D x,vector<C> A,ll N){\n  for(auto &I:A){\n    if(I.S<x+EPS){return false;}\n    I.S=sqrt(I.S*I.S-x*x);\n  }\n  for(int i=0;i<N;i++){\n    vector<pair<D,int>> cp;\n    int cnt1=0,cnt2=0;\n    bool jd=true;\n    P cen=A[i].F;\n    for(int j=0;j<N;j++){\n      if(i==j){cnt1++; continue;}\n      int num=intersectCC(A[i],A[j]);\n      if(num>2 || (num<2 && A[i].S>A[j].S-EPS)){jd=false; break;}\n      else if(num<2){cnt1++;}\n      else{\n        auto pts=crosspointCC(A[i],A[j]);\n        assert(pts.size()==2);\n        for(auto &I:pts){I-=cen;}\n        D s=arg(pts[0]),g=arg(pts[1]);\n        while(g<s-EPS){g+=2*PI;}\n        cp.push_back({s,1});\n        cp.push_back({g,-1});\n        cp.push_back({s+2*PI,1});\n        cp.push_back({g+2*PI,-1});\n      }\n    }\n    if(!jd){continue;}\n    sort(cp.begin(),cp.end());\n    if(cnt1==N){return true;}\n    for(auto &I:cp){\n      cnt2+=I.S;\n      if(cnt1+cnt2==N){return true;}\n    }\n  }\n  return false;\n}\n\nbool solve(){\n  ll N;\n  cin>>N;\n  if(N==0){return false;}\n  vector<C> A(N);\n  cin>>A;\n  D lf=0,rg=1e4;\n  for(int i=0;i<100;i++){\n    D mid=(lf+rg)/2;\n    if(judge(mid,A,N)){lf=mid;}\n    else{rg=mid;}\n  }\n  cout<<rg<<endl;\n  return true;\n}\n\nint main(){\n  cout<<fixed<<setprecision(12);\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=100;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq=q*conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b)) res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.7f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc != ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) || cc != ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n\ntemplate<class F>\ndouble binarySearch(double l, double r, F f) {\n\tif (f(l))return l;\n\tfor (int i = 0; i < 200; i++) {\n\t\tdouble m = (l + r) / 2;\n\t\tif (f(m))\n\t\t\tr = m;\n\t\telse\n\t\t\tl = m;\n\t}\n\treturn r;\n}\n\nconst double EPS = 1e-8;\n\nstruct Point {\n\tdouble x, y;\n\tPoint() :x(0.0), y(0.0) {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tPoint& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tPoint& operator*=(double a) { x *= a; y *= a; return *this; }\n\tPoint& operator/=(double a) { x /= a; y /= a; return *this; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n};\nPoint operator+(const Point& p1, const Point& p2) { return Point(p1) += p2; }\nPoint operator-(const Point& p1, const Point& p2) { return Point(p1) -= p2; }\nPoint operator*(const Point& p, double a) { return Point(p) *= a; }\nPoint operator/(const Point& p, double a) { return Point(p) /= a; }\n\nstruct Vector :public Point {\n\tusing Point::Point;\n\tVector() {}\n\tVector(const Point& P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)); }\n\tVector unit() { return *this / abs(); }\n};\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n\nVector polar(double r, double a) { return Point(cos(a) * r, sin(a) * r); }\n\ndouble get_distance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r - c2.r * c2.r + d * d) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n\nsigned main() {\n\tcout << fixed << setprecision(10);\n\tfor (int n; cin >> n && n;) {\n\t\tvector<double> x(n), y(n), l(n);\n\t\trep(i, 0, n)cin >> x[i] >> y[i] >> l[i];\n\n\t\tauto f = [&](double h) {\n\t\t\t//cerr << \"h \" << h << endl;\n\t\t\tvector<Circle> c(n);\n\t\t\tvector<Point> P;\n\t\t\trep(i, 0, n) {\n\t\t\t\tif (l[i] < h)return true;\n\t\t\t\tdouble theta = asin(h / l[i]);\n\t\t\t\tc[i].r = l[i] * cos(theta);\n\t\t\t\tc[i].c = Point(x[i], y[i]);\n\t\t\t\t//cerr << i << \" \" << c[i].r << endl;\n\t\t\t\tP.push_back(c[i].c);\n\t\t\t}\n\n\t\t\trep(i, 0, n)rep(j, i + 1, n) {\n\t\t\t\tint m = intersect(c[i], c[j]);\n\t\t\t\tif (m == 4)return true;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tauto cp = get_cross_points(c[i], c[j]);\n\t\t\t\t\tP.push_back(cp.first);\n\t\t\t\t\tP.push_back(cp.second);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ok = true なら ゆるんでて大丈夫\n\t\t\tbool ok = false;\n\t\t\t// 全部に含まれている点が存在したら ok = true にする\n\t\t\tfor (auto p : P) {\n\t\t\t\t// 含まれているなら true\n\t\t\t\t//cerr << p.x << \" \" << p.y << endl;\n\t\t\t\tbool ok2 = true;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tdouble d = get_distance(c[i].c, p);\n\t\t\t\t\t//cerr << \"d \" << d - EPS << \" c[i].r \" << c[i].r << endl;\n\t\t\t\t\t// 含まれていない\n\t\t\t\t\tif (d - EPS > c[i].r)\n\t\t\t\t\t\tok2 = false;\n\t\t\t\t}\n\t\t\t\tif (ok2)\n\t\t\t\t\tok = true;\n\t\t\t\t//cerr << ok2 << endl;\n\t\t\t}\n\n\t\t\treturn !ok;\n\n\t\t};\n\n\t\tdouble h = binarySearch(0, 300, f);\n\n\t\tcout << h << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 0;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\t//h.push_back({ a,b,c });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c*c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, c);\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2] )/l+l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\t//h.push_back({ x,y,z });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((x - bl[i][0])*(x - bl[i][0]) + (y - bl[i][1])*(y - bl[i][1]) + z*z > bl[i][2] * bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, z);\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\t//h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t\tbool f = 1;\n\t\t\trep(j, n) {\n\t\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][1] * bl[i][2] >= bl[j][2] * bl[j][2]) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, bl[i][2]);\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Complex;\n\nconst double EPS = 1e-10, PI = M_PI;\nll N;\nComplex P[10];\ndouble L[10];\n\nbool ok(double h) {\n  vector<double> r(N);\n  REP(i, 0, N) {\n    if(h > L[i]) return false;\n    r[i] = sqrt(L[i] * L[i] - h * h);\n  }\n\n  bool ret = false;\n  REP(m, 0, N) {\n    vector<pair<double, double>> theta(N);\n    REP(i, 0, N) if(i != m) {\n      Complex p1 = P[m], p2 = P[i];\n      double r1 = r[m], r2 = r[i];\n\n      if(abs(p2 - p1) > r1 + r2) return false;\n      if(abs(p2 - p1) < abs(r2 - r1)) {\n        if(r1 < r2) {\n          theta[i] = pair<double, double>(-PI, PI);\n        } else {\n          theta[i] = pair<double, double>(1e20, 1e20);\n        }\n        continue;\n      }\n\n      double d = abs(p2 - p1);\n      double t = abs((d * d + r1 * r1 - r2 * r2) / (d * 2));\n      double h = sqrt(r1 * r1 - t * t);\n\n      Complex u = (p2 - p1) / d;\n      Complex v = u * Complex(0, 1);\n      Complex q1 = p1 + u * t - v * h;\n      Complex q2 = p1 + u * t + v * h;\n\n      double theta1 = arg(q1 - p1);\n      double theta2 = arg(q2 - p1);\n      theta[i] = pair<double, double>(theta1, theta2);\n    }\n\n    vector<double> uniq;\n    REP(i, 0, N) if(i != m) {\n      uniq.push_back(theta[i].first);\n      uniq.push_back(theta[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pair<ll, ll>> range(N);\n    REP(i, 0, N) if(i != m) {\n      range[i].first = lower_bound(uniq.begin(), uniq.end(), theta[i].first) - uniq.begin();\n      range[i].second = lower_bound(uniq.begin(), uniq.end(), theta[i].second) - uniq.begin();\n    }\n\n    ll k = uniq.size();\n    vector<ll> sum(k * 2 + 1, 0);\n    REP(i, 0, N) if(i != m) {\n      if(range[i].first <= range[i].second) {\n        sum[range[i].first]++;\n        sum[range[i].second + 1]--;\n      } else {\n        sum[range[i].first]++;\n        sum[k]--;\n        sum[0]++;\n        sum[range[i].second + 1]--;\n      }\n    }\n    REP(i, 0, k) sum[i + 1] += sum[i];\n\n    REP(i, 0, k + 1) ret = ret || sum[i] >= N - 1;\n  }\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) {\n      double x, y;\n      cin >> x >> y >> L[i];\n      P[i] = Complex(x, y);\n    }\n\n    double l = 1, h = 1e5;\n    REP(_, 0, 100) {\n      double m = (l + h) / 2;\n      if(ok(m)) l = m; else h = m;\n    }\n    printf(\"%.15lf\\n\", l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct Rope{\n\tfloat x;\n\tfloat y;\n\tfloat l;\n};\nint n;\nRope r[10];\n\nfloat balloon_H(float X, float Y){\n\tfloat ans = 1e9;\n\tfor (int i = 0; i < n; i++){\n\t\tfloat h = r[i].l*r[i].l - (r[i].x - X)*(r[i].x - X) -(r[i].y - Y)*(r[i].y - Y);\n\t\tif (ans>h)ans = h;\n\t}\n\t\n\treturn ans;\n}\nfloat searchy(float x){\n\tfloat min = -100.0;\n\tfloat max = 100.0;\n\tfor (int i = 0; i < 200; i++){\n\t\tfloat div1 = (min * 2 + max) / 3;\n\t\tfloat div2 = (min + 2 * max) / 3;\n\t\tif (balloon_H(x, div1) < balloon_H(x, div2))\n\t\t\tmin = div1;\n\t\telse\n\t\t\tmax = div2;\n\t}\n\treturn balloon_H(x,min);\n}\nint main() {\n\twhile (cin >> n, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> r[i].x >> r[i].y >> r[i].l;\n\t\t}\n\t\tfloat e = 0.00001f;\n\t\tfloat min = -100.0;\n\t\tfloat max = 100.0;\n\n\t\tfor (int i = 0; i < 200;i++){\n\t\t\tfloat div1 = (min * 2 + max) / 3;\n\t\t\tfloat div2 = (min + 2 * max) / 3;\n\t\t\tif (searchy(div1) < searchy(div2))\n\t\t\t\tmin = div1;\n\t\t\telse\n\t\t\t\tmax = div2;\n\t\t}\n\t\t\n\t\tprintf(\"%.7f\\n\", sqrt(searchy(min)));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double eps = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n \nstruct P{\n  double x;\n  double y;\n \n  P(){\n    x=INF,y=INF;\n  }\n \n  P(const double &s , const double &e)\n  { x=s; y=e;}\n \n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n \n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n \n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n \nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P t , P p , double r){\n  //double r=radians(angle);\n  double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n  double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n  return P(ta , tb);\n}\n \nvoid interpoint_cc(P a , double ra , P b , double rb , P ans[]){\n  double di=fabs(dis(a-b));\n  if(di > ra+rb || di < fabs(ra-rb)) return;\n  double t=(ra*ra-rb*rb+di*di)/(di+di);\n  double rd=acos(t/ra);\n \n  P dv=unit_vector(b-a);\n  P g1=rotate(dv , P(0,0) , rd);\n  P g2=rotate(dv , P(0,0) , -rd);\n  ans[0]=a+g1*ra;\n  ans[1]=a+g2*ra;\n}\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int N;\n  while(cin>>N,N){\n    vector<P> p(N);\n    vector<double> ls(N);\n    REP(i,N) cin >> p[i].x >> p[i].y >> ls[i];\n \n    double lb = 0, ub = 300;\n    REP(loop,100){\n      double h = (lb + ub) / 2.;\n      bool ok = true;\n      REP(i,N) if(ls[i] < h) ok = false;\n \n      if(ok){\n        ok = false;\n        vector<double> ri(N);\n        REP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n        vector<P> chk;\n        REP(i,N){\n          REP(j,N){\n            if(dis(p[i]-p[j]) > ri[i]+ri[j] || dis(p[i]-p[j]) < fabs(ri[i]-ri[j])) continue;\n            P icp[2];\n            interpoint_cc(p[i], ri[i], p[j], ri[j], icp);\n            chk.PB(icp[0]);\n            chk.PB(icp[1]);\n          }\n          chk.PB(p[i]);\n        }\n        for(auto& pp: chk){\n          int cnt = 0;\n          REP(k,N){\n            if(dis(p[k]-pp) <= ri[k]+EPS)\n              ++cnt;\n          }\n          if(cnt == N) ok = true;\n        }\n      }\n \n      if(ok) lb = h;\n      else ub = h;\n    }\n    cout << fixed << setprecision(9) << lb << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\trep(k, j) {\n\t\t\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\tif (x[1][1] == 0) {\n\t\t\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\t\t\tif (x[1][0] - (x[1][1] *(1/ x[0][1]))*x[0][0] == 0)continue;\n\t\t\t\t\t\ta = 0.5/ (x[1][0] - (x[1][1] *(1/ x[0][1]))*x[0][0])*(x[1][2] - x[1][1] * (1 / x[0][1]) * x[0][2]);\n\t\t\t\t\t\tb = (x[0][2]*0.5 - a*x[0][0])*(1/ x[0][1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x[0][0] - (x[0][1] *(1/ x[1][1]))*x[1][0] == 0)continue;\n\t\t\t\t\t\ta = 0.5/ (x[0][0] - (x[0][1] *(1/ x[1][1]))*x[1][0])*(x[0][2] - x[0][1] * (1 / x[1][1])* x[1][2]);\n\t\t\t\t\t\tb = (x[1][2] *0.5 - a*x[1][0]) *(1 / x[1][1]);\n\t\t\t\t\t}\n\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\tint cc = ccw(P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]), P(a, b));\n\t\t\t\t\tif (cc == ccw(P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1]), P(a, b)) && cc == ccw(P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1]), P(a, b)))ans = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.00001;\nusing p2 = complex<double>;\n// x: real\n// y: imag\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\nbool same(double x, double y) { return fabs(x - y) < eps; }\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (fabs(l.real() - r.real()) > eps)\n    return l.real() < r.real();\n  return l.imag() < r.imag();\n};\nstruct Line {\n  p2 st, ed;\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n  Line(double x1, double y1, double x2, double y2)\n      : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n  double dist() { return sqrt(dist2(st, ed)); }\n  bool isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n  double x() { return ed.real() - st.real(); }\n  double y() { return ed.imag() - st.imag(); }\n};\n\n// l1.st + (l1.st - l1.ed) * r.first = l2.st + (l2.st - l2.ed) * r.second\n// 方程式を満たす(r.first, r.second)を返す\n// l1.isPalla(l2) => (nan, nan)\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return eps < r.first && r.first < 1. - eps && eps < r.second &&\n         r.second < 1. - eps;\n}\n\nstruct Poly {\n  vector<p2> ps;\n  Poly(vector<p2> ps) : ps(ps) {}\n  bool include(p2 p) {\n    vector<double> b;\n    for (int i = 0; i < ps.size(); i++) {\n      b.push_back(det(p, ps[i] - ps[(i + 1) % ps.size()]));\n    }\n    bool allPlus = true, allMinus = true;\n    for (auto &x : b) {\n      if (x > eps)\n        allMinus = false;\n      if (x < -eps)\n        allPlus = false;\n    }\n    return allMinus || allPlus;\n  }\n  bool intersecl(Line l) {\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        return true;\n    }\n    return false;\n  }\n};\n\nstruct Circle {\n  p2 p;\n  double r;\n  Circle(p2 p, double r) : p(p), r(r) {}\n  bool include(p2 l) { return dist2(p, l) < r * r + eps; }\n\n  // 円同士の交点\n  // 存在すれば2つ\n  vector<p2> intersec(Circle c) {\n    p2 diff = c.p - p;\n    double dist = dot(diff, diff);\n    double a = (dist + r * r - c.r * c.r) / 2.;\n    double D = dist * r * r - a * a;\n    if (D < eps)\n      return vector<p2>();\n    double Dsqrt = sqrt(D);\n    vector<p2> ps;\n    ps.emplace_back((a * diff.real() + diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() - diff.real() * Dsqrt) / dist + p.imag());\n    ps.emplace_back((a * diff.real() - diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() + diff.real() * Dsqrt) / dist + p.imag());\n    return ps;\n  }\n};\n\n// 逆時計回り\nstruct ConX {\n  vector<p2> ps;\n  // graham scan\n  // ref: プログラミングコンテストチャレンジブック p233\n  ConX(vector<p2> v) {\n    sort(v.begin(), v.end(), p2comp);\n\n    int k = 0, n = v.size();\n    ps.resize(n * 2);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    ps.resize(k - 1);\n  }\n  size_t size() { return ps.size(); }\n};\n\nint n;\nvector<double> rs;\nvector<p2> ps;\nvector<Circle> cs;\n\nbool f(double l) {\n  cs.clear();\n  for (int i = 0; i < n; i++) {\n    double rr = rs[i] * rs[i] - l * l;\n    if (rr < eps)\n      return false;\n    cs.emplace_back(ps[i], sqrt(rr));\n  }\n  vector<p2> may;\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      auto v = cs[i].intersec(cs[j]);\n      may.push_back(cs[i].p);\n      if (v.size() == 0)\n        continue;\n      may.push_back(v[0]);\n      may.push_back(v[1]);\n    }\n  for (auto &p : may) {\n    bool ok = true;\n    for (auto &c : cs) {\n      if (!c.include(p)) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok)\n      return true;\n  }\n  return false;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  while (true) {\n    cin >> n;\n    if (n == 0)\n      break;\n    rs.resize(n);\n    ps.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      double x, y;\n      cin >> x >> y >> rs[i];\n      ps[i] = p2(x, y);\n    }\n\n    if (n == 1) {\n      printf(\"%.9lf\\n\", rs[0]);\n      continue;\n    }\n\n    double l = 0., r = 300.;\n    for (int i = 0; i < 100; i++) {\n      double m = (l + r) / 2.;\n      if (f(m)) {\n        l = m;\n      } else {\n        r = m;\n      }\n    }\n    printf(\"%.9lf\\n\", l);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\nstruct Balloon {\n\tdouble x, y, l;\n\n\tdouble score(double x2, double y2)const {\n\t\tdouble d_2 = pow(x - x2, 2) + pow(y - y2, 2);\n\t\treturn pow(l, 2) - d_2;\n\t}\n};\n\nstruct Stage {\n\tStage() \n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tREP(i, n)\n\t\t{\n\t\t\tBalloon ball;\n\t\t\tcin >> ball.x >> ball.y >> ball.l;\n\t\t\tballs.push_back(ball);\n\t\t}\n\t}\n\n\tbool is_end() \n\t{\n\t\treturn balls.empty();\n\t}\n\t\n\tvoid action()\n\t{\n\t\tconst int TRY = 100;\n\t\tdouble x = 0;\n\t\tdouble y = 0;\n\t\tdouble step = 1;\n\n\t\twhile (step > 1e-9) {\n\t\t\tREP(i, TRY) {\n\t\t\t\tauto dir = select_dir(x, y, step);\n\t\t\t\tx += step * dir.first;\n\t\t\t\ty += step * dir.second;\n\t\t\t}\n\t\t\tstep /= 10.0;\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(10)<<sqrt(eval(x, y)) << endl;\n\t\t//cerr << \"=================\" << endl;\n\t}\n\nprivate:\n\tvector<Balloon> balls;\n\n\tpair<int, int> select_dir(double x, double y, double step)\n\t{\n\t\tpair<int, int> bestDir = { -1,-1 };\n\t\tdouble bestScore = -INF;\n\t\tFOR(i, -1, 2)FOR(j, -1, 2) {\n\t\t\tdouble tmp = eval(x + step * i, y + step * j);\n\t\t\tif (bestScore < tmp) {\n\t\t\t\tbestScore = tmp;\n\t\t\t\tbestDir = { i,j };\n\t\t\t}\n\t\t}\n\t\treturn bestDir;\n\t}\n\n\tdouble eval(double x, double y)\n\t{\n\t\tdouble res = INF;\n\t\tfor (auto ball : balls)\n\t\t{\n\t\t\tres = min(res, ball.score(x, y));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tStage stage;\n\t\tif (stage.is_end())break;\n\t\tstage.action();\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG p(n);\n\t\tvector<double>r(n);\n\t\trep(i,n){p[i]=pin();cin>>r[i];}\n\t\tif(n==1){\n\t\t\tcout<<r[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble h=320;\n\t\tdouble l=-1;\n\t\twhile(1){\n\t\t\tif(h-l<1e-5)break;\n\t\t\tdouble t=(h+l)/2;\n\t\t\tvector<C>c;\n\t\t\tbool h1=true;\n\t\t\trep(i,n){\n\t\t\t\tdouble go=r[i]*r[i]-t*t;\n\t\t\t\tif(go<0){h1=false;break;}\n\t\t\t\tdouble sa=sqrt(go);\n\t\t\t\tc.pb(C(p[i],sa));\n\t\t\t}\n\t\t\tif(!h1){h=t;continue;}\n\t\t\th1=true;\n\t\t\tG ko;\n\t\t\trep(i,n){\n\t\t\t\tloop(j,i+1,n){\n\t\t\t\t\tif(abs(p[i]-p[j])>c[i].r+c[j].r){h1=false;break;}\n\t\t\t\t\tL cross=crosspointCC(c[i],c[j]);\n\t\t\t\t\tko.pb(cross[0]);\n\t\t\t\t\tko.pb(cross[1]);\n\t\t\t\t}\n\t\t\t\tif(!h1)break;\n\t\t\t\t//ko.pb(p[i]);\n\t\t\t}\n\t\t\tif(!h1){h=t;continue;}\n\t/*\t\t\t\trep(e,2){\n\t\t\t\t\t\tint co=0;\n\t\t\t\t\t\trep(k,n)if(EPS+r[k]>abs(p[k]-cross[e]))co++;\n\t\t\t\t\t\tif(co>=n){h1=true;break;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h1)break;\n\t\t\t\t*/\n\t\t\th1=false;\n\t\t\trep(i,ko.size()){\n\t\t\t\tint co=0;\n\t\t\t\trep(k,n)if(EPS+c[i].r>abs(p[k]-ko[i]))co++;\n\t\t\t\tif(co>=0){h1=true;break;}\n\t\t\t\t/*h1=true;\n\t\t\t\trep(j,n)if(r[j]<abs(ko[i]-p[j])){h1=false;break;}\n\t\t\t\tif(h1)break;*/\n\t\t\t}\n\t\t\t//cout<<l<<\" \"<<h<<endl;\n\t\t\tif(h1)l=t;\n\t\t\telse h=t;\n\t\t}\n\t\tprintf(\"%.6f\\n\",(h+l)/2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(x, p.x), add(y, p.y));\n  }\n  P operator - (P p) {\n    return P(add(x, -p.x), add(y, -p.y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  P operator / (double d) {\n    return P(x / d, y / d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  //printf(\"%d:%d,%f,%f,%f\\n\",i,j,s,r[i],r[j]);\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p) {\n  for (int i = 0; i < n; i++) if (0.000008 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) return false;//r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i], -h * h));\n  //  printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 / (l1 + l2) + dir[j] * l1 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d)) return true;\n        if (canClear(ave - d)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t])) return true;\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n    //printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n    //printf(\"%d\\n\",(int)check(13.02));\n    //printf(\"%d\\n\",(int)check(10.34));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%.7f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 10;\n  double ans=1;\n  while(len > 1e-9){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-2e-4;\n  }\n\n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc != ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) || cc != ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\ndouble x[11],y[11],l[11];\n\nCircle circles[11];\nvector<Point> cands;\n\nbool inCircle(Circle c,Point p){//境界上でもtrue\n\tdouble d=pointsDistance(c.center,p);\n\tint s=sgn(d-c.r);\n\tif(s<=0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N;i++) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble lb=0;\n\t\tdouble ub=1000;\n\t\tfor(int i=0;i<N;i++) ub=min(ub,l[i]);\n\t\tfor(int stage=0;stage<100;stage++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircles[i]=Circle(Point(x[i],y[i]),sqrt(l[i]*l[i]-mid*mid));\n\t\t\t}\n\t\t\tcands.clear();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tvector<Point> tmp;\n\t\t\t\t\ttmp=circlesIntersection(circles[i],circles[j]);\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\tcands.push_back(tmp[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(cands.size()==0){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tcands.push_back(circles[i].center);\n\t\t\t\t}\n\t\t\t//}\n\t\t\tbool ok=false;\n\t\t\tfor(int i=0;i<cands.size();i++){\n\t\t\t\tbool flg=true;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(inCircle(circles[j],cands[i])==false) flg=false;\n\t\t\t\t}\n\t\t\t\tif(flg) ok=true;\n\t\t\t}\n\t\t\tif(ok) lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%f\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst double INF = 1e9;\nconst double EPS = 1e-8;\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\nbool operator < (const Point & a, const Point & b) { return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag(); }\nbool operator > (const Point & a, const Point & b) { return !eq(a.real(), b.real()) ? a.real() > b.real() : a.imag() > b.imag(); }\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\ndouble dot(const Point & a, const Point & b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(const Point & a, const Point & b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(const Point & p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(const Point & p) { return sqrt(length2(p)); }\ndouble distance(const Point & a, const Point & b) { return length(a - b); }\nPoint unit(const Point & p) { return p / length(p); }\nPoint divide(Point a, Point b, double m, double n) {\n    return Point((n * a.X() + m * b.X()) / (m + n), (n * a.Y() + m * b.Y()) / (m + n));\n}\n// ??????????????????\nPoint normal_vector(Point a) { return Point(-a.Y(), a.X()); }\n\n// (a.X, a.Y, az) ??¨ (b.X, b.Y, bz) ????????¢?????????\ndouble distance3d(Point a, double az, Point b, double bz) {\n    return sqrt(length2(a - b) + pow(az - bz, 2));\n}\n\n// c : ?????? ??§??????????§???¢??§????§?ac or ?§?bc ???????§???§??????????????????\nbool is_obtuse(double a, double b, double c) {\n    bool ok = true;\n    swap(a, c);\n    ok &= (a * a + b * b - c * c) / (2 * a * b) >= 0;\n    swap(a, c);\n    swap(b, c);\n    ok &= (a * a + b * b - c * c) / (2 * a * b) >= 0;\n    return not ok;\n}\n\ndouble heron_formula(double a, double b, double c) {\n    if(a > b) swap(a, b);\n    if(b > c) swap(b, c);\n    assert(a + b >= c);\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// ac = la, bc = lb ???????§???¢abc???c?????????ab????????±?????????, ab???????????¨??????????????????????±???????\n// ????°??????????????????\\????????????????§???¢????????????\ntuple<Point, double> third_point_projection_of_triangle(Point a, Point b, double la, double lb) {\n    if(eq(a, b) and abs(la - lb) < EPS) return make_pair(a, la);\n    double lc = distance(a, b);    \n    assert(not is_obtuse(la, lb, lc));\n    double s = heron_formula(la, lb, lc);\n    double h = s / lc * 2;\n    double m = abs(la - h) > EPS ? sqrt(la * la - h * h) : 0;\n    double n = lc - m;\n    if (not(m >= 0 and n >= 0)) debug(a), debug(b), debug(la), debug(lb), debug(m), debug(n);\n    assert(m >= 0 and n >= 0);\n    // cerr << \"thrid point projection: a:\" << a << \" b:\" << b << \" la:\" << la << \" lb:\" << lb << endl;\n    // cerr << \"divide: \" << divide(a, b, m, n) << \" h:\" << h << endl;\n    // cerr << a << b << \" \" << la << \" \" << lb << \" \" << divide(a, b, m, n) << \" \" << h << endl;\n    return make_tuple(divide(a, b, m, n), h);\n}\n\n// a -> b ??????????°??????????\nPoint projection(Point a, Point b, const Point &p) {\n    double t = dot(p-a, a-b) / norm(a-b);\n    Point ret = (a - b) * t;\n    ret += a;\n    return ret;\n}\n\nclass Solver {\n  public:\n\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return 0;\n        vector<Point> P(N);\n        vector<double> H(N);\n        rep(i, N) cin >> P[i] >> H[i];\n\n        double ans = 0;\n        \n        rep(i, N) {\n            // 1\n            {                \n                bool ok = true;\n                rep(j, N) if(i != j) ok &= distance3d(P[i], H[i], P[j], 0) <= H[j] + EPS;\n                if(ok) set_max(ans, H[i]);\n            }\n            rep(j, N) if(j != i) {                \n                double c = distance(P[i], P[j]);\n                if(H[i] + H[j] <= c) continue;\n                if(is_obtuse(H[i], H[j], c)) continue;\n                Point p;\n                double h;\n                tie(p, h) = third_point_projection_of_triangle(P[i], P[j], H[i], H[j]);\n                assert(distance3d(p, h, P[i], 0) <= H[i] + EPS);\n                assert(distance3d(p, h, P[j], 0) <= H[j] + EPS);\n                //2 \n                {\n                    bool ok = true;\n                    rep(k, N) ok &= distance3d(p, h, P[k], 0) <= H[k] + EPS;\n                    if(ok) set_max(ans, h);\n                }\n\n                rep(k, N) if(i != k and j != k) {\n                    if(abs(dot(P[i] - P[j], P[k]) > EPS)) continue;                    \n                    Point a = normal_vector(P[j] - P[i]); // P[k] ??§?????£???????????????????????????\n                    Point pk = projection(p, a + p, P[k]); \n                    double hk = sqrt(H[k] * H[k] - length2(pk - P[k]));\n                    if(h + hk <= distance(p, pk)) continue;\n                    if(is_obtuse(h, hk, distance(p, pk))) continue;\n                    Point pp;\n                    double hh;\n                    tie(pp, hh) = third_point_projection_of_triangle(p, pk, h, hk);\n                    if (not(distance3d(pp, hh, P[i], 0) <= H[i] + EPS)) {\n                        debug(pp); debug(hh); debug(P[i]);\n                    }\n                    assert(distance3d(pp, hh, P[j], 0) <= H[j] + EPS);\n                    assert(distance3d(pp, hh, P[k], 0) <= H[k] + EPS);\n                    // 3\n                    {\n                        bool ok = true;\n                        rep(l, N) ok &= distance3d(pp, hh, P[l], 0) <= H[l] + EPS;\n                        if(ok) set_max(ans, hh);\n                    }\n                }\n            }\n            \n        }\n        printf(\"%lf\\n\", ans);\n        return 1;\n    }\n};\n\nint main() {\n    while(1) {\n        Solver s;\n        if(!s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint xs[10], ys[10], ls[10];\nint lk;\n\nint sq(int i) { return i * i; }\nlong double sq(long double d) { return d * d; }\n\nbool ok(long double h) {\n    for (int i = 0; i < n; i++) {\n        if (lk == i) { continue; }\n\n        if (sq(xs[lk] - xs[i]) + sq(ys[lk] - ys[i])\n                > (sq(ls[i]) - sq(h))\n                    + (sq(ls[lk]) - sq(h))\n                    + 2 * sqrtl((sq(ls[i]) - sq(h)) * (sq(ls[lk]) - sq(h)))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d\", &n);\n\n        if (!n) { break; }\n\n        for (int i = 0; i < n; i++) {\n            int x, y, l;\n            scanf(\"%d%d%d\", &x, &y, &l);\n            xs[i] = x; ys[i] = y; ls[i] = l;\n        }\n\n        long double s = 300;\n        long double r = 300;\n        for (int i = 0; i < n; i++) { s = min(r, (long double)ls[i]); }\n\n        for (lk = 0; lk < n; lk++) {\n            long double lb = 1;\n            long double ub = s;\n\n            for (int i = 0; i < 30; i++) {\n                long double m = lb + (ub - lb) / 2;\n                if (ok(m)) { lb = m; }\n                else { ub = m; }\n            }\n\n            r = min(r, lb);\n        }\n\n        printf(\"%Lf\\n\", r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\nusing ld = long double;\n\nstruct Balloon {\n\tld x, y, l;\n\n\tld score(ld x2, ld y2)const {\n\t\tld d_2 = pow(x - x2, 2) + pow(y - y2, 2);\n\t\treturn pow(l, 2) - d_2;\n\t}\n};\n\nstruct Stage {\n\tStage() \n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tREP(i, n)\n\t\t{\n\t\t\tBalloon ball;\n\t\t\tcin >> ball.x >> ball.y >> ball.l;\n\t\t\tballs.push_back(ball);\n\t\t}\n\t}\n\n\tbool is_end() \n\t{\n\t\treturn balls.empty();\n\t}\n\t\n\tvoid action()\n\t{\n\t\tld x = 0;\n\t\tld y = 0;\n\t\tld step = 0.1;\n\n\t\twhile (step > 1e-12) {\n\t\t\tauto dir = select_dir(x, y, step);\n\t\t\tx += step * dir.first;\n\t\t\ty += step * dir.second;\n\t\t\tstep /= 10.0;\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(10)<<sqrt(eval(x, y)) << endl;\n\t\t//cerr << \"=================\" << endl;\n\t}\n\nprivate:\n\tvector<Balloon> balls;\n\n\tpair<int, int> select_dir(ld x, ld y, ld step)\n\t{\n\t\tpair<int, int> bestDir = { -1,-1 };\n\t\tld bestScore = -INF;\n\t\tFOR(i, -1000, 1001)FOR(j, -1000, 1001) {\n\t\t\tld tmp = eval(x + step * i, y + step * j);\n\t\t\tif (bestScore < tmp) {\n\t\t\t\tbestScore = tmp;\n\t\t\t\tbestDir = { i,j };\n\t\t\t}\n\t\t}\n\t\treturn bestDir;\n\t}\n\n\tld eval(ld x, ld y)\n\t{\n\t\tld res = INF;\n\t\tfor (auto ball : balls)\n\t\t{\n\t\t\tres = min(res, ball.score(x, y));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tStage stage;\n\t\tif (stage.is_end())break;\n\t\tstage.action();\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <cfloat>\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\ntypedef const seg &rseg;\n\n#define EPS 1e-9\n#define INF DBL_MAX\n\ninline D cross(rP a, rP b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ninline D dot(rP a, rP b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\nP crosspoint(rseg sa, rseg sb){\n\trP pa1 = sa.first, pa2 = sa.second, pb1 = sb.first, pb2 = sb.second;\n\tP da12 = pa2 - pa1;\n\tP db21 = pb1 - pb2;\n\tP dab1 = pb1 - pa1;\n\tD d = cross(da12, db21);\n\tif(abs(d) > EPS){\n\t\tD t = cross(dab1, db21) / d;\n\t\treturn pa1 + t * (pa2 - pa1);\n\t}\n\treturn P(INF, INF);\n}\n\nvector<P> intrCC(rP p1, D r1, rP p2, D r2){\n\tD d = abs(p2 - p1);\n\tD phi = arg(p2 - p1);\n\tvector<P> ret;\n\tD ct = (d * d + r1 * r1 - r2 * r2) / (2.0 * d * r1);\n\tif(ct > 1.0 && ct < 1.0 + EPS){\n\t\tct = 1.0;\n\t}\n\telse if(ct < -1.0 && ct > -1.0 - EPS){\n\t\tct = -1.0;\n\t}\n\tif(abs(ct) > 1.0){ return ret; }\n\tD theta = acos(ct);\n\t\n\tret.resize(2);\n\tret[0] = p1 + polar(r1, phi + theta);\n\tret[1] = p1 + polar(r1, phi - theta);\n\treturn ret;\n}\n\n\nvector<P> ps;\nvector<D> ls;\nvector<seg> segs;\nD ans;\n\nvoid check(rP z){\n\tD r = INF;\n\tfor(int i = 0; i < ps.size(); ++i){\n\t\tr = min(r, ls[i] * ls[i] - norm(ps[i] - z));\n\t}\n\tans = max(ans, sqrt(r));\n}\n\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tps.resize(n);\n\t\tls.resize(n);\n\t\tD x, y;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf%lf\", &x, &y, &ls[i]);\n\t\t\tps[i] = P(x, y);\n\t\t}\n\n\t\tsegs.clear();\n\t\tans = 0.0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcheck(ps[i]);\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tvector<P> w = intrCC(ps[i], ls[i], ps[j], ls[j]);\n\t\t\t\tif(w.empty()){ continue; }\n\t\t\t\tsegs.push_back(seg(w[0], w[1]));\n\t\t\t\tcheck(0.5 * (w[0] + w[1]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < segs.size(); ++i)\n\t\tfor(int j = 0; j < i; ++j){\n\t\t\tP z = crosspoint(segs[i], segs[j]);\n\t\t\tif(real(z) != INF){\n\t\t\t\tcheck(z);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a,b,d;\n\t\t\tcin>>a>>b>>d;\n\t\t\tc.pb(C(P(a,b),d));\n\t\t}\n\t\tdouble r=0,l=310;\n\t\twhile(abs(r-l)>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tvector<C>tmp;\n\t\t\trep(i,n){\n\t\t\t\tdouble t=c[i].r*c[i].r-h*h;\n\t\t\t\ttmp.pb(C(c[i].c,sqrt(t)));\n\t\t\t}\n\t\t\tbool hh=false;\n\t\t\trep(i,n)rep(j,n)if(i!=j)if(tmp[i].r+tmp[j].r+EPS>abs(tmp[j].c-tmp[i].c)){\n\t\t\t\tL l=crosspointCC(tmp[i],tmp[j]);\n\t\t\t\tif(abs(tmp[i].r-tmp[j].r)>abs(tmp[i].c-tmp[j].c))l=L(tmp[i].c,tmp[j].c);\n\t\t\t\trep(k,2){\n\t\t\t\t\tint co=0;\n\t\t\t\t\trep(q,n)if(tmp[q].r+EPS>abs(tmp[q].c-l[k]))co++;\n\t\t\t\t\tif(co==n)hh=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(hh)r=h;\n\t\t\telse l=h;\n\t\t}\n\t\tprintf(\"%.9f\\n\",r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1]) == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t\tif (c<13.03&&c>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t\tif (z<13.03&&z>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(5) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\nconst double EPS = 1e-9;\n#define SQR(x) ((x) * (x))\n \nint main()\n{\n  int N, X[10], Y[10], L[10];\n  double D[10][10];\n \n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; ++i) {\n      scanf(\"%d %d %d\", &X[i], &Y[i], &L[i]);\n    }\n    for(int i = 0; i < N; i++) {\n      for(int j = i + 1; j < N; j++) {\n        D[i][j] = sqrt(SQR(X[i] - X[j]) + SQR(Y[i] - Y[j]));\n      }\n    }\n \n    auto check = [&](double val)\n    {\n      vector< double > R;\n      for(int i = 0; i < N; ++i) {\n        R.emplace_back(sqrt(SQR(L[i]) - SQR(val)));\n      }\n      vector< pair< double, double > > P;\n      for(int i = 0; i < N; ++i) {\n        P.emplace_back(X[i], Y[i]);\n        for(int j = i + 1; j < N; ++j) {\n          if(abs(R[i] - R[j]) < D[i][j] && D[i][j] < R[i] + R[j]) {\n            double a = atan2(Y[j] - Y[i], X[j] - X[i]);\n            double theta = acos((SQR(D[i][j]) + SQR(R[i]) - SQR(R[j])) / (2 * D[i][j] * R[i]));\n            P.emplace_back(X[i] + R[i] * cos(a + theta), Y[i] + R[i] * sin(a + theta));\n            P.emplace_back(X[i] + R[i] * cos(a - theta), Y[i] + R[i] * sin(a - theta));\n          }\n        }\n      }\n      for(auto &&e : P) {\n        double x, y;\n        tie(x, y) = e;\n        bool f = true;\n        for(int i = 0; i < N; i++) {\n          if(sqrt(SQR(X[i] - x) + SQR(Y[i] - y)) > R[i] + EPS) f = false;\n        }\n        if(f) return (true);\n      }\n      return (false);\n    };\n \n    double low = 1.0, high = *min_element(L, L + N);\n \n    for(int i = 0; i < 25; ++i) {\n      double mid = (low + high) / 2.0;\n      if(check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.10lf\\n\", low);\n  }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - s.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nbool is_inc(Circle c, Point p)\n{\n\treturn abs(c.p - p) - c.r < EPS;\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tdouble x[10], y[10], l[10];\n\t\tREP(i, n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t}\n\t\tdouble ub = 301, lb = 0;\n\t\tfor (int cnt = 0; cnt < 100; cnt++)\n\t\t{\n\t\t\tdouble mid = (ub + lb) / 2;\n\t\t\tvector<Circle> cs;\n\t\t\tbool f = true;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (mid-l[i]>EPS)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcs.push_back(Circle(Point(x[i], y[i]), sqrt(pow(l[i], 2) - pow(mid, 2))));\n\t\t\t}\n\t\t\tif (!f)\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<Point> cps;\n\t\t\tREP(i, n - 1)FOR(j, i + 1, n)\n\t\t\t{\n\t\t\t\tauto tmp = is_cc(cs[i], cs[j]);\n\t\t\t\tcps.insert(cps.end(),ALL(tmp));\n\t\t\t}\n\t\t\tbool ff = false;\n\t\t\tREP(i, cps.size())\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tREP(j, cs.size())\n\t\t\t\t{\n\t\t\t\t\tif (!is_inc(cs[j], cps[i])) f = false;\n\t\t\t\t}\n\t\t\t\tif (f) ff = true;\n\t\t\t}\n\t\t\tif (ff) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << D10 << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LIMIT 50\nint n; long double x[100], y[100], l[100];\nlong double dst(long double ax, long double ay, long double az, long double bx, long double by, long double bz) {\n\treturn sqrtl((ax - bx)*(ax - bx) + (ay - by)*(ay - by) + (az - bz)*(az - bz));\n}\nlong double max_amari(long double ax, long double ay, long double az) {\n\tlong double maxn = 1000000000.0l;\n\tfor (int i = 0; i < n; i++) {\n\t\tmaxn = min(maxn, l[i] - dst(ax, ay, az, 0, x[i], y[i]));\n\t}\n\treturn maxn;\n}\nlong double solve2(long double h, long double X) {\n\tlong double L1 = -1000000.0l, R1 = 1000000.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = max_amari(h, X, c1);\n\t\tlong double m2 = max_amari(h, X, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\treturn maxn;\n}\nbool solve(long double h) {\n\tlong double L1 = -1000000.0l, R1 = 1000000.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = solve2(h, c1);\n\t\tlong double m2 = solve2(h, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\tif (maxn > -1e-14)return true;\n\treturn false;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> x[i] >> y[i] >> l[i];\n\t\tlong double L = 0.0l, R = 1000000.0l, M;\n\t\tfor (int i = 0; i < LIMIT; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tbool a1 = solve(M);\n\t\t\tif (a1 == true)L = M;\n\t\t\tif (a1 == false)R = M;\n\t\t}\n\t\tprintf(\"%.15Lf\\n\", M);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-7;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\n\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nint icc(const circle &c, const circle &d) {\n    /*\n      1 : intersect\n      0 : distinct\n      -1: c < d\n      -2: c > d\n\n      intersect or contain : true\n      distinct             : false\n    */\n    long double od = abs((c.o-d.o));\n    return c.r+d.r<od+eps ? 0 : od+c.r<d.r+eps ? -1 : od+d.r<c.r+eps ? -2 : 1;\n}\n\npair<point,point> ccc(const circle &c1, const circle &c2) {\n    if(!icc(c1,c2)) return pair<point,point>(c1.o,c2.o);\n    long double w = abs(c2.o-c1.o), th = arg(c2.o-c1.o);\n    long double dth = acosl((c1.r*c1.r+w*w-c2.r*c2.r)/(2.*c1.r*w));\n    return std::pair<point,point>(c1.o+polar(c1.r,th-dth),c1.o+polar(c1.r,th+dth));\n}\n\n\nvoid solve(int n){\n    vector<long double> x(n),y(n),l(n);\n    rep(i,0,n) cin >> x[i] >> y[i] >> l[i];\n\n    auto ok=[&](long double h){\n        vector<circle> cs;\n        rep(i,0,n) cs.push_back(circle(point(x[i],y[i]),sqrtl(l[i]*l[i]-h*h)));\n\n        vector<bool> del(n);\n        rep(i,0,n) rep(j,i+1,n){\n            auto &c1=cs[i],&c2=cs[j];\n            int k=icc(c1,c2);\n            if(!k) return false;\n            if(k==-1) del[j]=true;\n            if(k==-2) del[i]=true;\n        }\n        vector<point> ps;\n        int cnt=0;\n        rep(i,0,n){\n            if(del[i]) continue;\n            ++cnt;\n            rep(j,i+1,n){\n                if(del[j]) continue;\n                auto &c1=cs[i],&c2=cs[j];\n                auto ppp=ccc(c1,c2);\n                ps.push_back(ppp.first);\n                ps.push_back(ppp.second);\n            }\n        }\n        if(cnt==1) return true;\n        for(auto &p:ps){\n            bool f=true;\n            for(auto &c:cs){\n                if(abs(p-c.o)<=c.r+eps) continue;\n                f=false;\n            }\n            if(f) return true;\n        }\n        return false;\n    };\n\n    long double lb=1,ub=inf;\n    rep(i,0,n) ub=min(ub,l[i]);\n    rep(i,0,128){\n        long double m=(lb+ub)/2;\n        if(ok(m)) lb=m;\n        else ub=m;\n    }\n    cout << lb << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define EPS (1e-10)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, double> Rope;\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nRope integrate2(Rope x, Rope y){\n  P s = x.first, t = y.first;\n  double a = x.second, b = y.second, c_square = norm(s-t);\n  if(c_square < EPS) return Rope(s,min(a,b));\n  double k = (a*a - b*b + c_square)/c_square/2.0;\n  P p = (1-k)*s + k*t;\n  double h_square = a*a - norm(p-s);\n  return Rope(p, sqrt(max(h_square,0.0)));\n}\n\nRope integrate3(Rope x, Rope y, Rope z){\n  //??????????????¬????????¨??????\n  P s = x.first, t = y.first, u = z.first;\n  double a = x.second, b = y.second, c = z.second;\n  if(norm(s-t) < EPS) return integrate2(z, Rope(s,min(a,b)));\n  if(norm(t-u) < EPS) return integrate2(x, Rope(t,min(b,c)));\n  if(norm(u-s) < EPS) return integrate2(y, Rope(u,min(c,a)));\n  double px = ((norm(t) - norm(s) + a*a - b*b)*(u.Y-s.Y) - (norm(u) - norm(s) + a*a - c*c)*(t.Y-s.Y)) / 2.0 / cross(t-s,u-s);\n  double py = ((norm(t) - norm(s) + a*a - b*b)*(u.X-s.X) - (norm(u) - norm(s) + a*a - c*c)*(t.X-s.X)) / 2.0 / cross(u-s,t-s);\n  P p = P(px, py);\n  double h_square = a*a - norm(p-s);\n  return Rope(p, sqrt(max(h_square, 0.0)));\n}\n\ndouble solve(vector<Rope> r){\n  int n = r.size();\n  double ret = -1;\n  for(int i = 0; i < n; ++i){\n    for(int j = i; j < n; ++j){\n      for(int k = j; k < n; ++k){\n\tRope x = integrate3(r[i], r[j], r[k]);//?????¬????????????????????¨??????\n\tdouble h = x.second;\n\tif(h < ret) continue;\n\tP p = x.first;\n\tbool f = true;\n\tfor(int l = 0; l < n; ++l){\n\t  if(h*h + norm(p-r[l].first) > r[l].second*r[l].second + EPS){\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f) ret = max(ret, h);\n      }\n    }\n  }\n  return ret;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<Rope> R(n);\n    double x, y, l;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y >> l;\n      R[i] = Rope(P(x,y),l);\n    }\n    printf(\"%.10lf\\n\", solve(R));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\ntypedef complex<ld> Point;\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\n\nPoint input_point() {\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n    return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n    Point a, b;\n    Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle () : p(Point(0, 0)), r(0) {}\n    Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n    return isis_ll(l, s) &&\n        (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n        ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res;\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps){\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d,\tc.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0,\t1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = p.size();\n    REP(j,n) res += cross(p[j], p[(j+1)%n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = ps.size();\n    Polygon Q;\n    REP(i,n) {\n        Point A = ps[i], B = ps[(i+1)%n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n    for (Point q : ps) if (abs(q - p) < eps) return;\n    ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n    g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n    int n = p.size(), m = s.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (isis_sp(s[i], p[j]))\n            vec.emplace_back(abs(s[i].a - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            add_edge(g, from, to, abs(p[from] - p[to]));\n        }\n    }\n    return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n    int n = p.size(), m = c.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n            vec.emplace_back(arg(c[i].p - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            ld angle = vec[j+1].first - vec[j].first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n        if (vec.size() >= 2) {\n            int from = vec.back().second, to = vec.front().first;\n            ld angle = vec.front().first - vec.back().first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n    }\n    return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n    int N = p.size();\n    polygon.clear();\n    REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n    vector<vector<tuple<ld,int,bool>>> tup(N);\n    REP(i,s.size()) {\n        int a = -1, b = -1;\n        REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n        REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n        assert(a >= 0 && b >= 0);\n        tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n        tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n    }\n    REP(i,N) sort(ALL(tup[i]));\n    REP(i,N) {\n        REP(j,tup[i].size()) {\n            ld angle; int pos = j, from = i, to; bool flag;\n            tie(angle, to, flag) = tup[i][j];\n            if (flag) continue;\n            vector<int> ps;\n            while (!flag) {\n                ps.push_back(from);\n                get<2>(tup[from][pos]) = true;\n                seg2p[from][to].push_back(polygon.size());\n                seg2p[to][from].push_back(polygon.size());\n                angle += pi + eps;\n                if (angle > pi) angle -= 2 * pi;\n                auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n                if (it == tup[to].end()) it = tup[to].begin();\n                from = to; tie(angle, to, flag) = *it;\n                pos = it - tup[from].begin();\n            }\n            polygon.push_back(ps);\n        }\n    }\n    Graph g(polygon.size());\n    REP(i,N) REP(j,i) {\n        if (seg2p[i][j].size() == 2) {\n            int from = seg2p[i][j][0], to = seg2p[i][j][1];\n            g[from].push_back((Edge){from, to});\n            g[to].push_back((Edge){to, from});\n        }\n    }\n    return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n    fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n    Point v = l.b - l.a;\n    Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n    int n = p.size();\n    REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n;\n    while (cin >> n, n) {\n        vector<ll> X(n), Y(n), L(n);\n        REP(i, n) {\n            cin >> X[i] >> Y[i] >> L[i];\n        }\n        auto check = [&](double h) {\n            vector<double> r(n);\n            REP(i, n) {\n                double rr = L[i]*L[i]-h*h;\n                if (rr < 0) return false;\n                r[i] = sqrt(rr);\n            }\n            vector<Circle> c;\n            REP(i, n) {\n                c.pb({{X[i], Y[i]}, r[i]});\n            }\n            vector<Point> kh;\n            REP(i, n) kh.pb(c[i].p);\n            REP(i, n) FOR(j, i+1, n) {\n                vector<Point> v = is_cc(c[i], c[j]);\n                EACH(p, v) kh.pb(p);\n            }\n            EACH(p, kh) {\n                bool f = true;\n                REP(i, n) {\n                    if (abs(p-Point(X[i], Y[i])) > r[i]+eps) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return true;\n            }\n            return false;\n        };\n        double l = 0, r = 1000;\n        REP(t, 100) {\n            double m = (l + r) / 2;\n            if (check(m)) l = m;\n            else r = m;\n        }\n        cout << fixed << setprecision(10) << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x10)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x00) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\n// Circle\nclass C {\n  public:\n  P p; ld r;\n  C(P p_,ld r_):p(p_),r(r_){}\n};\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nVP is_cc(C c1, C c2){\n  VP res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  P diff = (c2.p-c1.p)/d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\n\n// 直線sと直線lの交点\nVP is_ll(L s, L t){\n  VP v;\n  P sv = s.b - s.a, tv = t.b - t.a;\n  if (abs(cross(sv,tv)) > 0)\n    v.push_back(s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv));\n  return v;\n}\n\nbool isis_ccc(C c1,C c2,C c3){\n  VP crs;\n  for(P p:is_cc(c1,c2))crs.push_back(p);\n  for(P p:is_cc(c2,c3))crs.push_back(p);\n  for(P p:is_cc(c3,c1))crs.push_back(p);\n  crs.push_back(c1.p);\n  crs.push_back(c2.p);\n  crs.push_back(c3.p);\n  for(P p:crs){\n    if(abs(p-c1.p)<=c1.r+eps&&abs(p-c2.p)<=c2.r+eps&&abs(p-c3.p)<=c3.r+eps){\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<P> p(n);\n    vector<ld> l(n);\n    REP(i,n){\n      ld x,y;\n      cin>>x>>y>>l[i];\n      p[i] = P(x,y);\n    }\n    ld maxh=300.0;\n    REP(i,n){\n      maxh=min(maxh,l[i]);\n    }\n    REP(i,n){\n      REP(j,i){\n        ld d=abs(p[i]-p[j]);\n        vector<ld> t={l[i],l[j],d};\n        sort(begin(t),end(t));\n        if(t[0]+t[1]<t[2])continue;\n        ld al=(l[i]*l[i]+d*d-l[j]*l[j])/(2.0*d);\n        if(al<eps||al-d>eps)continue;\n        ld h=sqrt(l[i]*l[i]-al*al);\n        maxh=min(maxh,h);\n      }\n    }\n    REP(i,n){\n      REP(j,i){\n        REP(k,j){\n          ld m=maxh;\n          ld h=0.0;\n          while(m>eps){\n            ld sqh=(m+h)*(m+h);\n            if(isis_ccc(C(p[i],sqrt(l[i]*l[i]-sqh)),C(p[j],sqrt(l[j]*l[j]-sqh)),C(p[k],sqrt(l[k]*l[k]-sqh)))){\n              h+=m;\n            }\n            m/=2.0;\n          }\n          maxh=min(maxh,h);\n        }\n      }\n    }\n    cout<<fixed<<setprecision(7)<<maxh<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nint n;\ndouble l[10];\n\nstruct C {\n\tP p;\n\tdouble r;\n\n\tC() {\n\t\tp = P(0, 0);\n\t\tr = 0;\n\t}\n\n\tC(const P& p, double r) : p(p), r(r) {\n\t}\n\n\tbool in(P t) {\n\t\treturn norm(p - t) < r * r + EPS;\n\t}\n\n\tbool in(C t) {\n\t\treturn abs(p - t.p) + t.r < r + EPS;\n\t}\n} c[10];\n\nbool check(double h) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (l[i] * l[i] - h * h < EPS) return false;\n\t\tc[i].r = sqrt(l[i] * l[i] - h * h);\n\t}\n\n\tvector<P> cs;\n\tfor (int i = 0; i < n; i++) {\n\t\tcs.push_back(c[i].p);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tC c1 = c[i], c2 = c[j];\n\t\t\tif (abs(c1.p - c2.p) > c1.r + c2.r) return false; // ????????????\n\t\t\tif (c1.in(c2) || c2.in(c1)) continue;\n\n\t\t\tP v = c2.p - c1.p;\n\t\t\tdouble t = (c1.r * c1.r + norm(v) - c2.r * c2.r) / (2 * abs(v));\n\t\t\tdouble theta = acos(t / c1.r);\n\t\t\tP b[2];\n\t\t\tb[0] = c1.p + v / abs(v) * c1.r * polar(1.0, theta);\n\t\t\tb[1] = c1.p + v / abs(v) * c1.r * polar(1.0, -theta);\n\t\t\tcs.push_back(b[0]);\n\t\t\tcs.push_back(b[1]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cs.size(); i++) {\n\t\tbool flag = true;\n\t\tfor (int m = 0; m < n; m++) {\n\t\t\tif (!c[m].in(cs[i])) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n , n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y >> l[i];\n\t\t\tc[i].p = P(x, y);\n\t\t}\n\t\tcheck(0);\n\t\tdouble ok = 1, ng = 300;\n\t\tfor (int loop = 0; loop < 100; loop++) {\n\t\t\tdouble h = (ok + ng) / 2;\n\t\t\tif (check(h)) ok = h;\n\t\t\telse ng = h;\n\t\t}\n\t\tcout << setprecision(15) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define EPS 1e-10\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) return 0;\n\t\tdouble x[10], y[10], l[10];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x1, y1, l1;\n\t\t\tscanf(\"%d %d %d\", &x1, &y1, &l1);\n\t\t\tx[i]=(double)x1, y[i]=(double)y1, l[i]=(double)l1;\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"%.7lf\\n\", l[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tdouble h1=1.0, h2=300.0;\n\t\tfor(int t=0; t<100; t++){\n\t\t\tdouble h=(h1+h2)/2.0;\n\t\t\tbool e=0;\n\t\t\tdouble r[10];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(l[i]<h+EPS){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr[i]=sqrt(l[i]*l[i]-h*h);\n\t\t\t}\n\t\t\tif(e==1){\n\t\t\t\th2=h;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool nn[10]={};\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t\tdouble d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n\t\t\t\t\tif(abs(r[i]-r[j])>=d-EPS){\n\t\t\t\t\t\tif(r[i]>r[j]){\n\t\t\t\t\t\t\tnn[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnn[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(r[i]+r[j]<d+EPS){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e==1){\n\t\t\t\th2=h;\n\t\t\t\tcontinue;\n\t\t\t}\n          int count=0;\n          for(int i=0; i<n; i++){\n            if(nn[i]==0) count++;\n          }\n          if(count<=2){\n            h1=h;\n            continue;\n          }\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=i+1; j<n; j++){\n                  if(i==j) continue;\n\t\t\t\t\tif(nn[i]==1 || nn[j]==1) continue;\n\t\t\t\t\tdouble s=x[i]*x[i]-x[j]*x[j]+y[i]*y[i]-y[j]*y[j]-l[i]*l[i]+l[j]*l[j];\n\t\t\t\t\tdouble x1, y1, x2, y2;\n\t\t\t\t\tif(abs(y[i]-y[j])<EPS){\n\t\t\t\t\t\tx1=s/(2.0*(x[i]-x[j]));\n\t\t\t\t\t\tx2=x1;\n\t\t\t\t\t\tif(l[i]*l[i]-h*h<(x1-x[i])*(x1-x[i])+EPS){\n\t\t\t\t\t\t\ty1=y[i], y2=y[i];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ty1=sqrt(l[i]*l[i]-h*h-(x1-x[i])*(x1-x[i]))+y[i];\n\t\t\t\t\t\t\ty2=-sqrt(l[i]*l[i]-h*h-(x1-x[i])*(x1-x[i]))+y[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdouble t1=(x[i]-x[j])/(y[i]-y[j]);\n\t\t\t\t\t\ts/=(y[i]-y[j]);\n                      \ts/=2.0;\n\t\t\t\t\t\tdouble a=1.0+t1*t1;\n\t\t\t\t\t\tdouble b=x[i]+t1*(s-y[i]);\n\t\t\t\t\t\tdouble c=x[i]*x[i]+(s-y[i])*(s-y[i])-l[i]*l[i]+h*h;\n\t\t\t\t\t\tif(b*b<a*c+EPS){\n\t\t\t\t\t\t\tx1=b, x2=b;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tx1=(b+sqrt(b*b-a*c))/a;\n\t\t\t\t\t\t\tx2=(b-sqrt(b*b-a*c))/a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty1=-t1*x1+s;\n\t\t\t\t\t\ty2=-t1*x2+s;\n\t\t\t\t\t}\n\t\t\t\t\tbool e1=0;\n\t\t\t\t\tfor(int k=0; k<n; k++){\n                      if(k==i || k==j || nn[k]==1) continue;\n\t\t\t\t\t\tif((x1-x[k])*(x1-x[k])+(y1-y[k])*(y1-y[k])>l[k]*l[k]-h*h-EPS){\n\t\t\t\t\t\t\te1=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(e1==0){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\te1=0;\n\t\t\t\t\tfor(int k=0; k<n; k++){\n                      if(k==i || k==j || nn[k]==1) continue;\n\t\t\t\t\t\tif((x2-x[k])*(x2-x[k])+(y2-y[k])*(y2-y[k])>l[k]*l[k]-h*h-EPS){\n\t\t\t\t\t\t\te1=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(e1==0){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e==1) break;\n            }\n\t\t\tif(e==1){\n\t\t\t\th1=h;\n\t\t\t}else{\n\t\t\t\th2=h;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7lf\\n\", h1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=INF,y=INF;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n  P operator / (const double &d) const\n  { return P(x/d , y/d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n\nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P p,double angle){\n  return P(p.x*cos(angle) - p.y*sin(angle),\n\t\t\t   p.x*sin(angle) + p.y*cos(angle));\n}\nstruct Circle{\n  P c;\n  double r;\n};\n\npair<P, P> getCrossPoints(const Circle& c1, const Circle& c2){\n  double d = dis(c2.c - c1.c);\n  double a = (c1.r*c1.r + d*d - c2.r*c2.r) / (2*d);\n  P e = (c2.c - c1.c) / d;\n  P h = rotate(e, PI/2) * sqrt(max(c1.r*c1.r - a*a, 0.));\n  if(d + min(c1.r, c2.r) <= max(c1.r, c2.r))\n\treturn MP(c1.c + e*c1.r, c1.c + e*c1.r);\n\n  return MP(c1.c + e*a + h, c1.c + e*a - h);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<P> p(N);\n\tvector<double> ls(N);\n\tdouble ub = 1000;\n\tREP(i,N){\n\t  cin >> p[i].x >> p[i].y >> ls[i];\n\t  ub = min(ub, ls[i]);\n\t}\n\n\tdouble lb = 0;\n\tREP(loop,100){\n\t  double h = (lb + ub) / 2.;\n\t  bool ok = true;\n\n\t  if(ok){\n\t\tok = false;\n\t\tvector<double> ri(N);\n\t\tREP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n\t\tvector<P> chk;\n\t\tREP(i,N){\n\t\t  REP(j,N){\n\t\t\tCircle c1, c2;\n\t\t\tc1.c = p[i];\n\t\t\tc1.r = ri[i];\n\t\t\tc2.c = p[j];\n\t\t\tc2.r = ri[j];\n\t\t\tauto icp = getCrossPoints(c1, c2);\n\n\t\t\tP dirs[4] = {P(-EPS,0), P(EPS,0), P(0,-EPS), P(0,EPS)};\n\t\t\tREP(d,4){\n\t\t\t  chk.PB(icp.first + dirs[d]);\n\t\t\t  chk.PB(icp.second + dirs[d]);\n\t\t\t}\n\t\t  }\n\t\t  chk.PB(p[i]);\n\t\t}\n\t\tfor(auto& pp: chk){\n\t\t  int cnt = 0;\n\t\t  REP(k,N){\n\t\t\tif(dis(p[k]-pp) <= ri[k]+EPS)\n\t\t\t  ++cnt;\n\t\t  }\n\t\t  if(cnt == N) ok = true;\n\t\t}\n\t  }\n\n\t  if(ok) lb = h;\n\t  else ub = h;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\ntypedef double double2;\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-10; //??´??°???????????????\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\n//???????¨???????\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > P_eps) return 1; //COUNTER_CLOCKWISE\n  if(cross(b-a,c-a) < -P_eps) return -1; //CLOCKWISE\n  if(dot(b-a,c-a) < P_eps) return -2; //c -> a -> b\n  if(dot(a-b,c-b) < P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n/* ??????????????? */\nbool isIntersectedCC(P c1, double r1, P c2, double r2){\n  double dist = abs(c1 - c2);\n  \n  return abs(r1 - r2) < dist + P_eps && dist - P_eps < r1 + r2; //?????\\?????\\?????????\n  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //?????\\?????\\?????????\n}\n\n/* ????????? */\npair<P,P> getCrosspointCC(P c1, double r1, P c2, double r2){\n  //assert(isIntersectedCC(c1, r1, c2, r2));\n  \n  double dist = abs(c1 - c2);\n  double a = acos((r1*r1 + dist * dist - r2 * r2) / (2 * r1 * dist));\n  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};\n}\n\n\nint n;\nP c[10];\nint r[10];\n\nbool check(double h){\n  vector<P> cross_points;\n\n  double R[10];\n\n  for(int i=0;i<n;i++){\n    R[i] = sqrt(r[i]*r[i] - h*h);\n  }\n  \n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(!isIntersectedCC(c[i],r[i],c[j],r[j])) continue;\n      \n      auto res = getCrosspointCC(c[i],R[i],c[j],R[j]);\n\n      cross_points.push_back(res.first);\n      cross_points.push_back(res.second);\n    }\n  }\n\n  bool ok[10] = {};\n  int ok_count = 0;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i == j) continue;\n\n      if(abs(c[i] - c[j]) + R[j] <= R[i]){\n        ok_count += !ok[i];\n        ok[i] = true;\n      }\n    }\n  }\n\n  if(ok_count == n-1){\n    for(int i=0;i<n;i++){\n      if(!ok[i]){\n        return h <= r[i];\n      }\n    }\n  }\n  \n  for(int i=0;i<cross_points.size();i++){\n    bool flag = true;\n\n    for(int j=0;j<n;j++){\n      \n      flag &= ok[j] || norm(cross_points[i]-c[j]) <= r[j]*r[j] - h*h + P_eps;\n    }\n\n    if(flag) return true;\n  }\n\n  return false;\n}\n\nbool solve(){\n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++){\n    int x,y;\n\n    scanf(\"%d%d%d\",&x,&y,r+i);\n\n    c[i] = P(x,y);\n  }\n\n  if(n == 1){\n    printf(\"%.10lf\\n\",(double2)r[0]);\n    return true;\n  }\n  \n  double l = 0, r = 500;\n\n  while(r - l > 1e-10){\n    double mid = (l + r)/2;\n    \n    if(check(mid)){\n      l = mid;\n    }else{\n      r = mid;\n    }\n  }\n\n  printf(\"%.10lf\\n\",(double2)r);\n  \n  return true;\n}\n\nint main(){\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\t//if(a < 0 || a > l)continue;\n\t\t\t\tif (z < ans)ans = z;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\trep(k, j) {\n\t\t\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\tif (x[1][1] == 0) {\n\t\t\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t\t\t}\n\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\tint cc = ccw(P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]), P(a, b));\n\t\t\t\t\tif (cc == ccw(P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1]), P(a, b)) && cc == ccw(P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1]), P(a, b)))ans = c;\n\t\t\t\t\t//h.push_back({ a,b,c });\n\t\t\t\t\t/*bool f = 1;\n\t\t\t\t\trep(i, n) {\n\t\t\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n} \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n\nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n\npoint rot(point p, double a) {\n\tpoint ret;\n\tdouble C = cos(a), S = sin(a);\n\tret.x = p.x*C - p.y*S;\n\tret.y = p.x*S + p.y*C;\n\t//printf(\"%lf %lf %lf %lf %lf\\n\",p.x,S,p.y,C,ret.y);\n\treturn ret;\n}\n\ndouble aaa[1111111];\nint cs=0;\n\nint main() {\n#ifdef LOCAL\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\t//FILE *f = fopen(\"E1.ans\",\"r\");\n\twhile(1) {\n\t\t//fscanf(f,\"%lf\",&aaa[cs++]);\n\t\tscanf(\"%d\",&n); \n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n\n\t\tdouble ans = -1e20;\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tdouble tmp = r[i];\n\t\t\tbool can = 1;\n\t\t\tfor(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n\t\t\tif(can) ans = max(ans, tmp);\n\t\t}\n\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tmemcpy(cP,P,sizeof(cP));\n\t\t\tfor(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n\t\t\tfor(int j=0;j<n;++j) if(j!=i) {\n\t\t\t\tdouble d = dis(cP[i],cP[j]);\n\t\t\t\tif(r[i]+r[j] < d-EPS) continue;\n\t\t\t\tif(abs(r[i]-r[j]) > d+EPS) continue;\n\n\t\t\t\tmemcpy(nP,cP,sizeof(nP));\n\t\t\t\tdouble a = atan2(cP[j].y,cP[j].x);\n\t\t\t\t//printf(\"%lf\\n\",a/acos(-1.0)*180.0);\n\t\t\t\tfor(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n\t\t\t\tif(abs(nP[j].x) < 1e-9) continue;\n\t\t\t\t//if(abs(nP[j].y) > EPS) printf(\"fuck\\n\");\n\n\t\t\t\tbool can = 1;\n\t\t\t\tpoint p1,p2;\n\t\t\t\tintersection_circle_circle(point(nP[j].x,nP[j].y),r[j],point(nP[i].x,nP[i].y),r[i],p1,p2);\n\t\t\t\tdouble zz = max(p1.y,p2.y), yy = 0;\n\t\t\t\tdouble xx = p1.x;\n\t\t\t\tfor(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n\t\t\t\tif(can)\n\t\t\t\t\tans = max(ans, zz);\n\n\t\t\t\tdouble rr = zz;\n\t\t\t\tfor(int k=0;k<n;++k) nP[k].x -= xx;// nP[k].x = abs(nP[k].x);\n\t\t\t\t//for(int k=0;k<n;++k) printf(\"%lf %lf\\n\",nP[k].x,nP[k].y);\n\t\t\t\tfor(int k=0;k<n;++k) if(k!=i && k!=j && abs(nP[k].x) <= r[k]+EPS){\n\t\t\t\t\tdouble nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n\t\t\t\t\tdouble d = abs(nP[k].y);\n\t\t\t\t\tif(nr+rr < d-EPS) continue;\n\t\t\t\t\tif(abs(nr-rr) > d+EPS) continue;\n\t\t\t\t\tif(d < 1e-9) continue;\n\n\t\t\t\t\tbool can = 1;\n\t\t\t\t\tpoint p1,p2;\n\t\t\t\t\tintersection_circle_circle(point(0,0),rr,point(nP[k].y,0),nr,p1,p2);\n\t\t\t\t\tdouble zz = max(p1.y,p2.y), xx = 0;\n\t\t\t\t\tdouble yy = p1.x;\n\t\t\t\t\tif(nP[k].y < 0) yy *= -1;\n\t\t\t\t\tfor(int h=0;h<n;++h) if(sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)) > r[h] + EPS) {\n\t\t\t\t\t\t//printf(\"%lf %lf\\n\",sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)),r[h]);\n\t\t\t\t\t\tcan = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(can)\n\t\t\t\t\t\tans = max(ans, zz);\n\t\t\t\t}\n\t\t\t}\n\t\t} printf(\"%.10lf\\n\",ans);\n\n\n\t\t/*if(abs(ans-aaa[cs-1]) > 1e-5) {\n\t\t\tprintf(\"No %.5lf %.5lf\\n\",ans,aaa[cs-1]);\n\t\t\tprintf(\"%d\\n\",n);\n\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\tprintf(\"%lf %lf\\n\",x[i],y[i]);\n\t\t}*/\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-7;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2円の交点\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint n;\nD x[11],y[11],z[11],a[11];\n\nbool ch(double mid){\n  VP v;\n  rep(i,n){\n    a[i] = sqrt(z[i]*z[i] - mid*mid);\n    if(a[i]<0)return 0;\n    v.push_back(P(x[i],y[i]));\n  }\n  rep(i,n)rep(j,n)if(i<j){\n    VP p=crosspointCC(P(x[i],y[i]),a[i],P(x[j],y[j]),a[j]);\n    rep(k,p.size()){\n      v.push_back(p[k]);\n    }\n  }\n  rep(i,v.size()){\n    int flag=0;\n    rep(j,n){\n      D dist=sqrt((x[j]-v[i].X)*(x[j]-v[i].X)+(y[j]-v[i].Y)*(y[j]-v[i].Y));\n      if(dist<=a[j])flag++;\n    }\n    if(flag==n)return 1;\n  }\n  return 0;\n}\n\nsigned main(){\n  while(cin>>n,n){\n    rep(i,n)cin>>x[i]>>y[i]>>z[i];\n    D l=0,r=1e9;\n    rep(o,50){\n      D mid=(l+r)/2;\n      if(!ch(mid))r=mid;\n      else l=mid;\n    }\n    printf(\"%.9f\\n\",l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double Real;\ntypedef complex<Real> Point;\ntypedef vector<Point> Polygon;\nstruct Line {\n\tLine(){}\n\tLine(Point p, Point q): p(p), q(q){}\n\tPoint p, q;\n};\ntypedef Line Segment;\nstruct Circle {\n\tCircle(){}\n\tCircle(Point p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\n#define X real\n#define Y imag\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-12;\n\ninline int sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\treturn a < 0.0 ? -1 : 1;\n}\n\ninline bool eq(Real a, Real b){ return sgn(a - b) == 0; }\ninline bool neq(Real a, Real b){ return sgn(a - b) != 0; }\ninline bool lt(Real a, Real b){ return sgn(a - b) == -1; }\ninline bool leq(Real a, Real b){ return sgn(a - b) <= 0; }\ninline bool gt(Real a, Real b){ return sgn(a - b) == 1; }\ninline bool geq(Real a, Real b){ return sgn(a - b) >= 0; }\n\nReal sq(Real a){ return a * a; }\n\nReal dot(Point a, Point b){ return X(conj(a) * b); }\nReal cross(Point a, Point b){ return Y(conj(a) * b); }\n\nbool orthogonal(Line l, Line m){\n\treturn sgn(dot(l.q - l.p, m.q - m.p)) == 0;\n}\n\nbool parallel(Line l, Line m){\n\treturn sgn(cross(l.q - l.p, m.q - m.p)) == 0;\n}\n\nPoint project(Line l, Point p){\n\tPoint t = l.q - l.p;\n\tReal r = dot(p - l.p, t) / norm(t);\n\treturn l.p + t * r;\n}\n\nPoint reflect(Line l, Point p){\n\treturn p + (project(l, p) - p) * Real(2.0);\n}\n\nint ccw(Point a, Point b, Point c){\n\tPoint u = b - a, v = c - a;\n\tif (sgn(cross(u, v)) == 1) return 1;\t\t// ccw\n\tif (sgn(cross(u, v)) == -1) return -1;\t// cw\n\tif (sgn(dot(a, b)) == -1) return 2;\t\t\t// back\n\tif (lt(norm(a), norm(b))) return -2;\t\t// front\n\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// on\n}\n\nbool intersectLL(Line l, Line m){\n\tif (!parallel(l, m)) return true;\n\treturn parallel(l, Line(l.p, m.p));\n}\n\nbool intersectLS(Line l, Segment s){\n\treturn sgn(cross(l.q - l.p, s.p - l.p)) * sgn(cross(l.q - l.p, s.q - l.p)) <= 0;\n}\n\nbool intersectLP(Line l, Point p){\n\treturn parallel(l, Line(l.p, p));\n}\n\nbool intersectSS(Segment s, Segment t){\n\treturn ccw(s.p, s.q, t.p) * ccw(s.p, s.q, t.q) <= 0\n\t\t&& ccw(t.p, t.q, s.p) * ccw(t.p, t.q, s.q) <= 0;\n}\n\nReal distanceLP(Line l, Point p){\n\treturn abs(cross(l.q - l.p, p - l.p) / abs(l.q - l.p));\n}\n\nReal distanceLL(Line l, Line m){\n\tif (intersectLL(l, m)) return 0.0;\n\treturn distanceLP(l, m.p);\n}\n\nReal distanceLS(Line l, Segment s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.p), distanceLP(l, s.q));\n}\n\nReal distanceSP(Segment s, Point p){\n\tif (sgn(dot(s.q - s.p, p - s.p)) <= 0) return abs(p - s.p);\n\tif (sgn(dot(s.p - s.q, p - s.q)) <= 0) return abs(p - s.q);\n\treturn distanceLP(s, p);\n}\n\nReal distanceSS(Segment s, Segment t){\n\tif (intersectSS(s, t)) return 0.0;\n\treturn min(\n\t\tmin(distanceSP(s, t.p), distanceSP(s, t.q)),\n\t\tmin(distanceSP(t, s.p), distanceSP(t, s.q))\n\t);\n}\n\nbool intersectCL(Circle c, Line l){\n\treturn leq(distanceLP(l, c.p), c.r);\n}\n\nbool intersectCS(Circle c, Segment s){\n\treturn leq(distanceSP(s, c.p), c.r);\n}\n\nbool intersectCP(Circle c, Point p){\n\treturn leq(norm(c.p - p), sq(c.r));\n}\n\nbool intersectCC(Circle c, Circle d){\n\treturn leq(norm(c.p - d.p), sq(c.r + d.r));\n}\n\npair<Point, Point> crossPointsCL(Circle c, Line l){\n\tPoint pr = project(l, c.p);\n\tPoint e = (l.q - l.p) / abs(l.q - l.p);\n\tReal t = sqrt(sq(c.r) - norm(pr - c.r));\n\treturn make_pair(pr + e * t, pr - e * t);\n}\n\npair<Point, Point> crossPointsCC(Circle c, Circle d){\n\tReal ds = abs(d.p - c.p);\n\tReal a = acos((sq(c.r) + sq(ds) - sq(d.r)) / (2 * c.r * ds));\n\tReal t = arg(d.p - c.p);\n\treturn make_pair(c.p + polar(c.r, t + a), c.p + polar(c.r, t - a));\n}\n\nbool contains(Circle c, Circle d){ // d in c\n\treturn leq(c.r + abs(c.p - d.p), d.r);\n}\n\nint n;\nReal x[10], y[10], l[10];\n\nbool ok(Real h)\n{\n\tCircle c[10];\n\tfor (int i = 0; i < n; i++){\n\t\tReal r = sqrt(sq(l[i]) - sq(h));\n\t\tc[i] = Circle(Point(x[i], y[i]), r);\n\t}\n\n\tfor (int i = 0; i < n; i++){\n\t\tbool f = true;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (!intersectCP(c[j], c[i].p)) f = false;\n\t\t}\n\t\tif (f) return true;\n\t}\n\n\tvector<Point> cps;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (!intersectCC(c[i], c[j])) return false;\n\t\t\tif (contains(c[i], c[j])) continue;\n\t\t\tif (contains(c[j], c[i])) continue;\n\t\t\tauto cp = crossPointsCC(c[i], c[j]);\n\t\t\tcps.push_back(cp.first);\n\t\t\tcps.push_back(cp.second);\n\t\t}\n\t}\n\t\n\tfor (auto cp : cps){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (!intersectCP(c[i], cp)) f = false;\n\t\t}\n\t\tif (f) return true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t}\n\t\tReal lb = 0.0, ub = *min_element(l, l + n);\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tReal md = (lb + ub) / 2;\n\t\t\t(ok(md) ? lb : ub) = md;\n\t\t}\n\t\tcout << fixed << setprecision(20) << lb << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef struct {P s,t;} L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef vector <C> VC;\n\nconst D eps=1.0e-10;\nconst D pi=acos(-1.0);\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\n//template<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\ntemplate<class T> int sig(T a,T b = 0) {return a < b ? -1 : b > a ? 1 : 0;}\n#define X real()\n#define Y imag()\n\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sq(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.t-l.s;}\ninline P input(){D x,y;cin >> x >> y; return P(x,y);}\n//??\\??? ???????????¬????????¨???\n\n\n// ??? not verify\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ??????\nP rot (P base, P a, D theta){\n\tP tar=a-base;return base+polar(abs(tar), arg(tar)+theta );\n}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P b,P p){ return b*ip(b,p)/norm(b);}\nP proj(L l,P p){ return l.s+proj(vec(l),p-l.s);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ???????????? verify AOJ CGL_1_C\nenum CCW{\n\tLEFT = 1,\n\tRIGHT = 2,\n\tBACK = 4,\n\tFRONT = 8,\n\tMID = 16,\n\tON=FRONT|BACK|MID\n};\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n\ta -= base; b -= base;\n\tif (ep(a, b) > 0)\n\t\treturn LEFT;    // counter clockwise\n\tif (ep(a, b) < 0)\n\t\treturn RIGHT;   // clockwise\n\tif (ip(a, b) < 0)\n\t\treturn BACK;    // b--base--a on line\n\tif (norm(a) < norm(b))\n\t\treturn FRONT;   // base--a--b on line\n\t// otherwise\n\treturn MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n// verify AOJ CGL_2_A\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ?????¨??´?????¨????????¢??£??????????????? (s??????????????????????????§?????????????¨±?????????)\nB iLL(L a,L b){return !ipar(a,b);}\n\nB eqL(L a,L b){return !iLL(a, b) && ep(vec(a), b.s - a.s)==0;}\nB iLS(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) <= 0;}\nB iLSs(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) < 0;}\n\n// ????????¨?????????????????????\n// verify AOJ CGL_2_B\nB iSS(L a,L b){\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a,L b) {\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ??????\n// verify AOJ CGL_2_C\nP pLL(L a,L b){ return a.s+vec(a)*ep(vec(b),b.s-a.s)/ep(vec(b),vec(a));}\n\n// ?????¨??´???????????¢\nD dLP(L l,P p){return abs( ep(vec(l),p-l.s) )/abs(vec(l));}\n// ?????¨??????????????¢\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.s)) <= 0) return abs(p - s.s);\n\tif (sig( ip(-vec(s), p - s.t)) <= 0) return abs(p - s.t);\n\treturn dLP(s,p);\n}\n\n// ??´?????¨??´???????????¢\nD dLL(L a,L b){ return iLL(a,b)?0:dLP(a,b.s);}\n\n// ?????¨??´?????¨????????¢??£????????¢\nD dLS(L a,L b){ return iLS(a,b)?0:min(dLP(a, b.s),dLP(a, b.t));}\n\n// ????????¨??????????????¢\n// verify AOJ CGL_2_D\nD dSS(L a,L b){ return iSS(a,b)?0:\n\tmin({ dSP(a,b.s),dSP(a,b.t),dSP(b,a.s),dSP(b,a.t)});\n}\n\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){\n\treturn (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;\n}  // base x\ninline B cmp_y(const P &a,const P &b){\n\treturn (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;\n}  // base y\ninline B cmp_a(const P &a,const P &b){\n\treturn (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);\n} // base arg\n\n// ????§???¢\n\n// ??¢???\n// Verify AOJ 1100\n// verify CGL_3_A\nD area(VP pol){\n\tint n=pol.size();\n\tD sum=0.0;\n\trep(i,n){\n\t\tD x=pol[i%n].X-pol[(i+1)%n].X;\n\t\tD y=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=x*y;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢?????????\n// verify CGL_3_B\nB is_convex(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==RIGHT) return false;\n\t}\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????)\n//verify AOJ CGL_3-C\nint in_polygon(VP pol,P p){\n\tint n=pol.size();\n\tint res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==MID)\n\t\t\treturn 1;\n\t\tD vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n\t\tD dx=pol[(i+1)%n].X-pol[i].X;\n\t\tif((pol[i].Y<=p.Y)&&(p.Y< pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res++;\n\t\tif((pol[i].Y> p.Y)&&(p.Y>=pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res--;\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????)\n// Verify AOJ 2514\n\nbool in_polygon(VP pol,L l){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar={pol[i],pol[(i+1)%n]};\n\t\tif(iSS(l,tar))\n\t\t\tcheck.push_back(pLL(l,tar));\n\t}\n\n\tcheck.push_back(l.s);\n\tcheck.push_back(l.t);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m)) return false;\n\t}\n\treturn true;\n}\n\n\n// convex_hull\n// Verify AOJ 0063\n// Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tVP res(2*n);\n\n\t//??\\??????while?????????????????????\n\t//????????????????????????????????????????????´??????<=0\n\t//???????????????????????????????????????????????´??????<0\n\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// ????????????\n// verify AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i], b = pol[(i+1)%n];\n\t\tif(ccw(l.s, l.t, a) != RIGHT) res.push_back(a);\n\t\tif((ccw(l.s, l.t, a)|ccw(l.s, l.t, b))==(LEFT|RIGHT))\n\t\t\tres.push_back(pLL({a,b}, l));\n\t}\n\treturn res;\n}\n\n// ???\n// Verify AOJ 1183\n\nenum RCC{\n\tA_IN_B=1,\n\tB_IN_A=2,\n\tA_ON_B=4,\n\tB_ON_A=8,\n\tISC=16,\n\tON_OUT=32,\n\tOUT=64,\n\tSAME=12,\n\tONS=48\n};\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// ?????¢??£???????????????\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L l) {return sig(c.r, dSP(l, c.c)) >= 0;}\nbool iCSc(C c, L l) {return iCS(c, l) && sig(c.r, max(abs(l.s - c.c), abs(l.t - c.c))) <= 0;}\n\n//2??????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.push_back(a.c+P(a.r,0));\n\t\tres.push_back(a.c+P(-a.r,0));\n\t\tres.push_back(a.c+P(0,a.r));\n\t\tres.push_back(a.c+P(0,-a.r));\n\t}else{\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (norm(d) + norm(a.r) - norm(b.r)) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c);\n\t\tif(rel==ISC){ // 2points\n\t\t\tP w = e * P(0, 1) * sq(norm(a.r)-norm(x));\n\t\t\tres.push_back(a.c + e * x - w);\n\t\t\tres.push_back(a.c + e * x + w);\n\t\t}else if(rel&ONS){ // 1points\n\t\t\tres.push_back(a.c + e * x);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l,c.c);\n\tP e = vec(l) / abs(vec(l)) * sq(norm(c.r) - norm(h - c.c));\n\tres.push_back(h - e);\n\tres.push_back(h + e);\n\treturn res;\n}\n\n\n// ????????\\???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n\n// ????????±?????\\???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tP ba=b.c-a.c;\n\tD d=ang(ba);\n\tD i=acos((a.r+b.r)/abs(ba));\n\tD o=acos((a.r-b.r)/abs(ba));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.push_back(tanC(a,d+i));\n\t\tres.push_back(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.push_back(tanC(a,d+o));\n\t\tres.push_back(tanC(a,d-o));\n\t}\n\n\tif(r&ONS) res.push_back(tanC(a,d)); //??\\????????±???????????\\???\n\n\tif(r==SAME) rep(i,5) res.push_back(tanC(a,i));\n\treturn res;\n}\n\n\nconst int vmax=1010;\nstruct node{int to;D cost;};\n// segments arrangement\nvector<node> graph[vmax];\nvoid sArr(const vector<L> &seg, vector<P> &point){\n\trep(i,seg.size()){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trange(j,i+1,seg.size()){\n\t\t\tif (iSS(seg[i],seg[j]))\n\t\t\t\tpoint.push_back( pLL(seg[i],seg[j]));\n\t\t}\n\t}\n\tsort(point.begin(),point.end(),cmp_x);\n\tpoint.erase(unique(point.begin(),point.end(),cmp_x), point.end());\n\n\trep(i,seg.size()){\n\t\tvector< pair<D, int> > list;\n\t\trep(j,point.size())\n\t\t\tif (ccw(seg[i].s,seg[i].t, point[j])==MID)\n\t\t\t\tlist.push_back(make_pair(norm(seg[i].s-point[j]), j));\n\t\tsort(list.begin(),list.end());\n\t\trange(j,1,list.size()){\n\t\t\tint a = list[j-1].second, b = list[j].second;\n\t\t\tgraph[a].push_back( {b, abs(point[a]-point[b])} );\n\t\t\tgraph[b].push_back( {a, abs(point[a]-point[b])} );\n\t\t}\n\t}\n}\n\n\n\n// under not verify\n\n// ????????????????????????\n/*\nvector<L> merge(vector<L> lines) {\n\trep(i,lines.size())\n\t\tif(lines[i].t < lines[i].s)\n\t\t\tswap(lines[i].s, lines[i].t);\n\tsort(lines.begin(),lines.end());\n\trep(i,lines.size())rep(j,i){\n\t\tif (iSS(lines[i],lines[j])&&!iSSs(lines[i],lines[j])){\n\t\t\tif(abs(lines[i].t-lines[j].s) > abs(vec(lines[j])))\n\t\t\t\tlines[j].t = lines[i].t;\n\t\t\tlines.erase(lines.begin() + i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lines;\n}\n*/\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==MID)\n\t\t\tpol.erase(pol.begin() + i--);\n\t}\n\treturn pol;\n}\n\n\nL bisector(P a, P b) {\n  P mid=(a+b)*P(0.5,0);\n  return L{mid, mid+(b-a)*P(0, pi/2)};\n}\n\nVP voronoi_cell(VP pol,VP v, int s) {\n  rep(i, v.size()) if(i!=s) pol = convex_cut(pol,bisector(v[s], v[i]));\n  return pol;\n}\n\nconst D inf = 1e9;\n\nint main(void){\n    for(int n; cin >> n, n;){\n        VP points(n);\n        vector<D> l(n);\n        rep(i, n) points[i] = input(), cin >> l[i];\n\n        D lb = 0.0, ub = *min_element(begin(l), end(l)) + eps;\n        rep(loop, 100){\n            D mid = (lb + ub) / 2.0;\n\n            VC circles(n);\n            rep(i, n){\n                circles[i] = { points[i], sq(pow(l[i], 2) - pow(mid, 2)) };\n            }\n\n            bool ok = true;\n            [&]\n            {\n                rep(i, n){\n                    range(j, i + 1, n){\n                        if(pCC(circles[i], circles[j]).size() == 0){\n                            ok = false;\n                            return;\n                        }\n                    }\n                }\n            }();\n\n            if(ok){\n                lb = mid;\n            }\n            else {\n                ub = mid;\n            }\n        }\n\n        cout.precision(12);\n        cout << lb << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x10)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12 / x10;\n\t\t\t\t\t\t\tb = (x02 - a*x10)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12 - a*x00) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\nconst D EPS = 1e-7;\n#define X real()\n#define Y imag()\n\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint n;\nD x[11],y[11],z[11],a[11];\n\nbool ch(double mid){\n  VP v;\n  rep(i,n){\n    a[i] = sqrt(z[i]*z[i] - mid*mid);\n    if(a[i]<0)return 0;\n    v.push_back(P(x[i],y[i]));\n  }\n  rep(i,n)rep(j,n)if(i<j){\n    VP p=crosspointCC(P(x[i],y[i]),a[i],P(x[j],y[j]),a[j]);\n    rep(k,p.size()){\n      v.push_back(p[k]);\n    }\n  }\n  rep(i,v.size()){\n    int flag=0;\n    rep(j,n){\n      D dist=sqrt((x[j]-v[i].X)*(x[j]-v[i].X)+(y[j]-v[i].Y)*(y[j]-v[i].Y));\n      if(dist<=a[j]+EPS)flag++;\n    }\n    if(flag==n)return 1;\n  }\n  return 0;\n}\n\nsigned main(){\n  while(cin>>n,n){\n    rep(i,n)cin>>x[i]>>y[i]>>z[i];\n    D l=0,r=1e9;\n    rep(o,100){\n      D mid=(l+r)/2;\n      if(!ch(mid))r=mid;\n      else l=mid;\n    }\n    printf(\"%.9f\\n\",l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\nusing namespace std;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\n\nbool zero(double a) { return abs(a) <= EPS; }\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nbool canClear(P p, int i1, int i2) {\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && EPS + r[i] < abs(p - dir[i])) return false;\n  return true;\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (-EPS > ((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt((double)l[i] * l[i] - h * h);\n  }\n  for (int i = 0; i < n; i++) if (canClear(dir[i], -1, -1)) return true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      double d = abs(dir[j] - dir[i]);\n      if (d - r[i] - r[j] > EPS) return false;\n      if (r[i] - r[j] - d > EPS) continue;\n      if (r[j] - r[i] - d > EPS) continue;\n      double A = atan2((dir[j] - dir[i]).imag(), (dir[j] - dir[i]).real());\n      double S = acos((d*d + r[i]*r[i] - r[j]*r[j]) / (2 * d * r[i]));\n      if (canClear(dir[i] + polar(r[i], A + S), i, j)) return true;\n      if (canClear(dir[i] + polar(r[i], A - S), i, j)) return true;\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i] = P(x[i], y[i]);\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  double d = abs(A.center() - B.center());\n  double rc = (d * d + A.radius() * A.radius() - B.radius() * B.radius()) / (2.0 * d);\n  double rs = sqrt(A.radius() * A.radius() - rc * rc);\n  Point diff = (B.center() - A.center()) / d;\n  ret.pb(A.center() + diff * Point(rc,  rs));\n  ret.pb(A.center() + diff * Point(rc, -rs));\n  return ret;\n}\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semieq(d, A.radius() + B.radius())) return  3;  // ?????\\\n  if(semige(d, A.radius() + B.radius())) return -3;  // ???????????????\n  return 4;  // ????????£?????????\n}\n\ninline bool operator < (Circle& A, Circle& B)\n{\n  return A.radius() != B.radius() ? A.radius() < B.radius() : A.center() < B.center();\n}\n\nconst int MAX_N = 12;\nint n;\ndouble x, y;\ndouble l[MAX_N];\nPoint p[MAX_N];\n\nbool C(double x)\n{\n  vector<Circle> c;\n  rep(i, n) c.pb(Circle(p[i], sqrt(l[i] * l[i] - x * x)));\n  rep(i, c.size()) rep(j, i){\n    Circle A = c[i];\n    Circle B = c[j];\n    int det = intersectionDeterminationOfCC(A, B);\n    if(det < 3) continue;\n    vector<Point> vp = intersectionOfCC(A, B);\n    vrep(v, vp){\n      bool ok = true;\n      vrep(w, c) ok &= !semige(abs(*v - w->center()), w->radius());\n      if(ok) return true;\n    }\n  }\n\n  sort(ALL(c));\n  bool ok = true;\n  rep(i, n-1){\n      int det = intersectionDeterminationOfCC(c[i], c[i+1]);\n      ok &= (det == -1 || det == -2);\n  }\n  if(ok) return true;\n\n  vrep(v, c){\n    bool ok = true;\n    vrep(w, c) ok &= !semige(abs(v->center() - w->center()), w->radius());\n    if(ok) return true;\n  }\n\n  return false;\n}\n\nint main()\n{\n  int cnt = 0;\n  while(cin >> n, n){\n    double mn = (double)INF;\n    rep(i, n){\n      cin >> x >> y >> l[i];\n      p[i] = Point(x, y);\n      minup(mn, l[i]);\n    }\n\n    double left = 1.0;\n    double right = mn;\n    rep(_, 50){\n      double mid = (left + right) / 2.0;\n      if(C(mid)) left = mid;\n      else right = mid;\n    }\n\n    printf(\"%.15f\\n\", right);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble PI=acos(-1.0);\n#define eps (1e-7)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\ndouble x[11],y[11],r[11];\nvector<Point> po;\nCircle c[11];\ndouble mx;\nint n;\nbool test(double d){\n    po.clear();\n    rep(i,n){\n        double dist=r[i]*r[i]-d*d;\n        if(dist<0) return false;\n        c[i]=Circle(Point(x[i],y[i]),sqrt(dist));\n        po.pb(c[i].p);\n    }\n    rep(i,n)FOR(j,i+1,n){\n        if(!isIntersectCC(c[i],c[j])){\n            continue;\n            if((c[i].p-c[j].p).abs()>c[i].r+c[j].r) return false;\n            else{\n                continue;\n            }\n        }\n        if(abs(c[i].r-c[j].r)+eps>(c[i].p-c[j].p).abs()) continue;\n        pair<Point,Point> pp=CrossPointsCC(c[i],c[j]);\n        po.pb(pp.first);po.pb(pp.second);\n    }\n    int sz=po.size();\n    rep(i,sz){\n        bool flag=true;\n        rep(j,n){\n            if((po[i]-c[j].p).abs()>c[j].r+eps) flag=false;\n        }\n        if(flag) return true;\n    }\n    return false;\n}\nint main(){\n    while(cin>>n,n){\n        mx=0;\n        rep(i,n){\n            cin>>x[i]>>y[i]>>r[i];\n            mx=max(mx,r[i]);\n        }\n        double lb=0,ub=300;\n        while(ub-lb>eps){\n            double mid=(ub+lb)/2;\n            if(test(mid)) lb=mid;\n            else ub=mid;\n        }\n        cout<<fixed<<setprecision(12)<<lb<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\n\nconst int PREC=100;\nconst ld EPS=1e-6;\n\nusing VP = vector<P>;\nstruct C { P p; ld r; };\nconst ld eps = 1e-8, pi = acos(-1.0);\nVP is_cc(C c1, C c2){\n  VP res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  P diff = (c2.p-c1.p)/d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\nvector<P> ccp(P x0,ld r0,P x1,ld r1){\n    VP res=is_cc(C{x0,r0},C{x1,r1});\n    res.push_back(x0);\n    res.push_back(x1);\n    return res;\n}\n\nbool check(ld h,vector<P>& p,vector<ld> &l){\n    int n=p.size();\n    if(n==1) return l[0];\n    vector<ld> tr(n);\n    for(int i=0;i<n;i++){\n        if(l[i]<h) return false;\n        tr[i]=sqrt(l[i]*l[i]-h*h);\n    }\n    bool res=false;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            vector<P> testP=ccp(p[i],tr[i],p[j],tr[j]);\n            for(int k=0;k<testP.size();k++){\n                bool isok=true;\n                for(int l=0;l<n;l++){\n                    isok&=(abs(testP[k]-p[l])<tr[l]+EPS);\n                }\n                res|=isok;\n            }\n        }\n    }\n    return res;\n}\nld solve(vector<P> &p,vector<ld> &l){\n    ld lb=0;\n    ld ub=1e18;\n    for(int i=0;i<PREC;i++){\n        ld mid=(lb+ub)/2;\n        if(check(mid,p,l)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return lb;\n}\nint main(){\n    int n;\n    cout<<setprecision(10)<<fixed;\n    while(cin>>n,n){\n        vector<P> p(n);\n        vector<ld> l(n);\n        for(int i=0;i<n;i++){\n            ld x,y;\n            cin>>x>>y>>l[i];\n            p[i]=P(x,y);\n        }\n        cout<<solve(p,l)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n\nconst double EPS = 1e-9;\ntypedef long double Real;\ntypedef complex<Real> Point;\n\ninline Real dot(const Point &a, const Point &b) {\n    return a.real() * a.real() + b.imag() * b.imag();\n}\n\nstruct Circle {\n    Point p;\n    Real r;\n    Circle(Point p = 0, Real r = 0) : p(p), r(r) {;}\n};\n\nstruct Line : public vector<Point> {\n    Line(Point a = 0, Point b = 0) {\n        push_back(a); push_back(b);\n    }\n};\n\nPoint projection(Line l, Point p) {\n    Real t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\n\nvector<Point> crosspointLC(Line l, const Circle &c){\n    vector<Point> res;\n    Point p = projection(l, c.p);\n    Real d = abs(p - c.p);\n    Real t = sqrt(c.r * c.r - d * d);\n    if(isnan(t)) return res;\n    Point v = (l[1] - l[0]) / abs(l[1] - l[0]);\n    res.push_back(p - v*t);\n    if(t > EPS) res.push_back(p + v*t);\n    return res;\n}\n\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2){\n    vector<Point> res;\n    Real d = abs(c1.p - c2.p);\n    if(max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) return res;\n    Real x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point p = c1.p + (c2.p - c1.p) / d * x;\n    Point v = (c1.p - c2.p) * Point(0.0, 1.0);\n    return crosspointLC(Line(p, p + v), c1);\n}\n\n\nint n;\nCircle cs[200];\n#define sq(x) ((x)*(x))\n\nbool isok(Point p, Real h){\n    rep(i,n) if(norm(p-cs[i].p) + sq(h) > sq(cs[i].r) + EPS) return false;\n    return true;\n}\n\nbool check(Circle c1, Circle c2, Real h) {\n    c1.r = sqrt(sq(c1.r) - sq(h));\n    c2.r = sqrt(sq(c2.r) - sq(h));\n    vector<Point> ps = crosspointCC(c1, c2);\n    for(auto p : ps) {\n        if(isok(p,h)) return true;\n    }\n    return false;\n}\n\nbool check(Real h){\n    rep(i,n){\n        if(isok(cs[i].p, h)) return true;\n        rep(j,n) if(check(cs[i], cs[j], h)) return true;\n    }\n    return false;\n}\n\nint main() {\n    while(cin >> n, n) {\n        rep(i, n) {\n            Real x,y,l;\n            cin >> x >> y >> l;\n            cs[i] = Circle(Point(x, y), l);\n        }\n        Real l = 1, r = 500;\n        rep(q,200) {\n            Real m = (l+r)/2;\n            if(check(m)) l = m; else r = m;\n        }\n        printf(\"%.20f\\n\", (double)l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\n\nconst int PREC=100;\nconst ld EPS=1e-8;\n\nusing VP = vector<P>;\nstruct C { P p; ld r; };\nconst ld eps = 1e-9, pi = acos(-1.0);\nVP is_cc(C c1, C c2){\n  VP res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  P diff = (c2.p-c1.p)/d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\nvector<P> ccp(P x0,ld r0,P x1,ld r1){\n    VP res=is_cc(C{x0,r0},C{x1,r1});\n    res.push_back(x0);\n    res.push_back(x1);\n    return res;\n}\n\nbool check(ld h,vector<P>& p,vector<ld> &l){\n    int n=p.size();\n    vector<ld> tr(n);\n    for(int i=0;i<n;i++){\n        if(l[i]<h) return false;\n        tr[i]=sqrt(l[i]*l[i]-h*h);\n    }\n    bool res=false;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            vector<P> testP=ccp(p[i],tr[i],p[j],tr[j]);\n            for(int k=0;k<testP.size();k++){\n                bool isok=true;\n                for(int l=0;l<n;l++){\n                    isok&=(abs(testP[k]-p[l])<tr[l]+EPS);\n                }\n                res|=isok;\n            }\n        }\n    }\n    return res;\n}\nld solve(vector<P> &p,vector<ld> &l){\n    if(p.size()==1) return l[0];\n    ld lb=0;\n    ld ub=1e18;\n    for(int i=0;i<PREC;i++){\n        ld mid=(lb+ub)/2;\n        if(check(mid,p,l)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return lb;\n}\nint main(){\n    int n;\n    cout<<setprecision(10)<<fixed;\n    while(cin>>n,n){\n        vector<P> p(n);\n        vector<ld> l(n);\n        for(int i=0;i<n;i++){\n            ld x,y;\n            cin>>x>>y>>l[i];\n            p[i]=P(x,y);\n        }\n        cout<<solve(p,l)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct Circle{\n  double r;\n  P c;\n  Circle(double r=0.0, P c = P(0,0)):r(r),c(c){}\n  bool operator < (const Circle &c) const {\n    return r < c.r;\n  }\n};\n\nconst double EPS = 1e-8;\n\nint n;\ndouble hi;\nCircle v[11];\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersectCP(P p, Circle c){\n  return abs(c.c-p) < c.r || equal(abs(c.c-p),c.r);\n}\n\nvector<P> intersectCC(Circle C1, Circle C2){\n  vector<P> res;\n  double r1 = C1.r, r2 = C2.r, d;\n  P p1 = C1.c, p2 = C2.c;\n  d = abs(p1-p2);\n  if(d < EPS && abs(r1-r2) < EPS) return res;\n  if(r1 + r2 < d - EPS || d + EPS < abs(r1-r2)) return res;\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nbool func(vector<Circle> w){\n  bool f = false;\n  int ws = w.size();\n  if(ws == 1) return true;\n\n  //内側に円があれば、交わっていなくてもtrue\n  f = false;\n  for(int i=1;i<ws;i++) {\n    if(abs(w[i].c-w[0].c) > w[i].r-w[0].r && !equal(abs(w[i].c-w[0].c),w[i].r-w[0].r)){\n      f = true;\n      break;\n    }\n  }\n  if(!f)  return true;\n\n\n  //円の交点を求め、１つでも全ての円の内側・境界に存在するならtrue\n  vector<P> p;\n  for(int i=0;i<ws;i++){\n    for(int j=i+1;j<ws;j++){\n      vector<P> aa = intersectCC(w[i],w[j]);\n      for(int k=0;k<aa.size();k++) p.push_back(aa[k]);\n    }\n  }\n  for(int i=0;i<p.size();i++){\n    int j;\n    for(j=0;j<ws;j++){\n      if(!isIntersectCP(p[i],w[j])) break;\n    }\n    if(j == ws) return true;\n  }\n  return false;\n}\n\nbool check(double h){\n  if(n == 1) return h < v[0].r;\n  vector<Circle> w;\n\n  for(int i=0;i<n;i++) w.push_back(Circle(sqrt(v[i].r*v[i].r - h*h), v[i].c));\n  sort(w.begin(),w.end());\n  return func(w);\n}\n\nvoid solve(){\n  double c,lo=0.0;\n  for(int i=0;i<100;i++){\n    c = (lo + hi) / 2.0;\n    if(check(c)) lo = c;\n    else hi = c;\n  }\n  printf(\"%.7f\\n\",hi);\n}\n\nint main(){\n  while(cin >> n && n){\n    hi = 400.0;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> x >> y >> v[i].r;\n      v[i].c = P(x,y);\n      hi = min(hi, v[i].r);\n    }\n    solve();\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<double, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02;\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\tx02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000009;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nusing Float = double;\nusing Point = complex<Float>;\nstruct Line{\n\tPoint a,b;\n\tLine(Point a,Point b) : a(a),b(b){}\n};\nstruct Segment : Line{ Segment(Point a,Point b) : Line(a,b){} };\nstruct Circle{\n\tPoint p; Float r;\n\tCircle(Point p,Float r) : p(p),r(r){}\n};\n\ninline bool eq(Float a,Float b) { return abs(a - b) < EPS; }\ninline Float dot(const Point &a,const Point &b){ return real(conj(a) * b); }\ninline Float cross(const Point &a,const Point &b){ return imag(conj(a) * b); }\n\nFloat distance(Point &p1,Point &p2){\n    return abs(p1 - p2);\n}\n\nbool contain(Circle &c,Point &p){\n    return (distance(c.p,p) <= c.r + EPS);\n}\n\nvector<Point> crosspoint(const Circle &c1,const Circle &c2){\n\tvector<Point> ret;\n\tPoint d = c2.p - c1.p;\n\tFloat rcosa = (c1.r * c1.r + norm(d) - c2.r * c2.r) / (abs(d) * 2);\n\tif(eq(0,abs(d)) || abs(rcosa) > c1.r) return ret;\n\tFloat rsina = sqrt(c1.r * c1.r - rcosa * rcosa);\n\tret.push_back(c1.p + d / abs(d) * Point(rcosa,rsina));\n\tif(!eq(rcosa,c1.r)) ret.push_back(c1.p + d / abs(d) * Point(rcosa,-rsina));\n\treturn ret;\n}\n\nint n;\ndouble x[15],y[15],l[15];\n\nbool isOK(double h){\n\tvector<Circle> cs;\n\tfor(int i = 0;i < n;i++){\n\t\tif(l[i] < h) return false;\n\t\tcs.emplace_back(Point(x[i],y[i]),sqrt(l[i] * l[i] - h * h));\n\t}\n\tvector<Point> ps;\n\tfor(int i = 0;i < n;i++){\n\t\tps.push_back(cs[i].p);\n\t\tfor(int j = i + 1;j < n;j++){\n\t\t\tauto cp = crosspoint(cs[i],cs[j]);\n\t\t\tps.insert(ps.end(),all(cp));\n\t\t}\n\t}\n\tfor(auto p : ps){\n\t\tbool flag = true;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(!contain(cs[i],p)) flag = false;\n\t\t}\n\t\tif(flag) return true;\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i] >> l[i];\n\t}\n\tdouble ok = 0,ng = INF;\n\tfor(int i = 0;i < 100;i++){\n\t\tdouble mid = (ok + ng) / 2;\n\t\tif(isOK(mid)) ok = mid;\n\t\telse ng = mid;\n\t}\n\tprintf(\"%.15lf\\n\",ok);\n}\n\nsigned main(){\n\twhile(cin >> n,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 3> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ x,y,z, });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n  \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n  \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n  \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n}\n  \nint main() {\n    int n;\n    cin.sync_with_stdio(0);\n    while (cin >> n, n) {\n        va<float, 3> bl(n);\n        rep(i, n)rep(j, 3)cin >> bl[i][j];\n        //va<double, 3> h;\n        double ans = 1e9;\n        int mina = 0;\n        rep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n        ans *= ans;\n        rep(i,n){\n            rep(j,i){\n                double l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n                double a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n                double x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n                if (z < 0)continue;\n                if (z<ans&&a > 0 && a < l)ans = z;\n                rep(k, j) {\n                    double x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n                    double a, b, c;\n                    if (x[1][1] == 0) {\n                        if (x[0][1] == 0)continue;\n                        if (x[1][0]*x[0][1] - (x[1][1] )*x[0][0] == 0)continue;\n                        a = 1/ (2*(x[1][0]*x[0][1] - (x[1][1])*x[0][0]))*(x[1][2]*x[0][1] - x[1][1]  * x[0][2]);\n                        b = (x[0][2]*0.5 - a*x[0][0])*(1/ x[0][1]);\n                    }\n                    else {\n                        if (x[0][0]*x[1][1] - (x[0][1])*x[1][0] == 0)continue;\n                        a = 1/ (2*(x[0][0]*x[1][1] - (x[0][1] )*x[1][0]))*(x[0][2]*x[1][1] - x[0][1]* x[1][2]);\n                        b = (x[1][2] *0.5 - a*x[1][0]) *(1 / x[1][1]);\n                    }\n                    c = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n                    if (c < 0)continue;\n                    if (c >= ans)continue;\n                    int cc = ccw( P(a, b),P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                    if (cc == ccw(P(a, b),P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b),P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                }\n            }\n        }\n        cout << fixed << setprecision(7) << sqrt(ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "3\n10 10 20\n10 -10 20\n-10 10 120\n1\n10 10 16\n2\n10 10 20\n10 -10 20\n2\n100 0 101\n-90 0 91\n2\n0 0 53\n30 40 102\n3\n10 10 20\n10 -10 20\n-10 -10 20\n3\n1 5 13\n5 -3 13\n-3 -3 13\n3\n98 97 168\n-82 -80 193\n-99 -96 211\n4\n90 -100 160\n-80 -80 150\n90 80 150\n80 80 245\n4\n85 -90 290\n-80 -80 220\n-85 90 145\n85 90 170\n5\n0 0 4\n3 0 5\n-3 0 5\n0 3 5\n0 -3 5\n10\n95 -93 260\n-86 96 211\n91 90 177\n-81 -80 124\n-91 91 144\n97 94 165\n-90 -86 194\n89 85 167\n-93 -80 222\n92 -84 218\n0"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret(2);\n  double x1 = A.center().real(), y1 = A.center().imag(), r1 = A.radius();\n  double x2 = B.center().real(), y2 = B.center().imag(), r2 = B.radius();\n  double dx = x2 - x1;\n  double dy = y2 - y1;\n  double a = dx * dx + dy * dy;\n  double b = ((r1 * r1 - r2 * r2) / a + 1) / 2;\n  double d = r1 * r1 / a - b * b;\n  double x3 = x1 + dx * b;\n  double y3 = y1 + dy * b;\n  double x4 = -dy * sqrt(d);\n  double y4 =  dx * sqrt(d);\n  ret[0] = Point(x3 - x4, y3 - y4);\n  ret[1] = Point(x3 + x4, y3 + y4);\n  return ret;\n}\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semieq(d, A.radius() + B.radius())) return  3;  // ?????\\\n  if(semige(d, A.radius() + B.radius())) return -3;  // ???????????????\n  return 4;  // ????????£?????????\n}\n\ninline bool operator < (Circle& A, Circle& B)\n{\n  return A.radius() != B.radius() ? A.radius() < B.radius() : A.center() < B.center();\n}\n\nconst int MAX_N = 12;\nint n;\ndouble x, y;\ndouble l[MAX_N];\nPoint p[MAX_N];\n\nbool C(double x)\n{\n  vector<Circle> c;\n  rep(i, n) c.pb(Circle(p[i], sqrt(l[i] * l[i] - x * x)));\n  rep(i, c.size()) rep(j, i){\n    Circle A = c[i];\n    Circle B = c[j];\n    int det = intersectionDeterminationOfCC(A, B);\n    if(det < 3) continue;\n    vector<Point> vp = intersectionOfCC(A, B);\n    vrep(v, vp){\n      bool ok = true;\n      vrep(w, c) ok &= !semige(abs(*v - w->center()), w->radius());\n      if(ok) return true;\n    }\n  }\n\n  vrep(v, c){\n    bool ok = true;\n    vrep(w, c) ok &= !semige(abs(v->center() - w->center()), w->radius());\n    if(ok) return true;\n  }\n\n  return false;\n}\n\nint main()\n{\n  int cnt = 0;\n  while(cin >> n, n){\n    double mn = (double)INF;\n    rep(i, n){\n      cin >> x >> y >> l[i];\n      p[i] = Point(x, y);\n      minup(mn, l[i]);\n    }\n\n    double left = 1.0;\n    double right = mn;\n    rep(_, 50){\n      double mid = (left + right) / 2.0;\n      if(C(mid)) left = mid;\n      else right = mid;\n    }\n\n    printf(\"%.15f\\n\", right);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n){\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0 || a < 0 || a > l)continue;\n\t\t\t\tif (z < ans)ans = z;\n\t\t\t\trep(k, j) {\n\t\t\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\tif (x[1][1] == 0) {\n\t\t\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t\t\t}\n\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\tint cc = ccw(P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]), P(a, b));\n\t\t\t\t\tif (cc == ccw(P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1]), P(a, b)) && cc == ccw(P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1]), P(a, b)))ans = c;\n\t\t\t\t\t//h.push_back({ a,b,c });\n\t\t\t\t\t/*bool f = 1;\n\t\t\t\t\trep(i, n) {\n\t\t\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef struct {P s,t;} L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef vector <C> VC;\n\nconst D eps=1.0e-10;\nconst D pi=acos(-1.0);\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\n//template<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\ntemplate<class T> int sig(T a,T b = 0) {return a < b ? -1 : b > a ? 1 : 0;}\n#define X real()\n#define Y imag()\n\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sq(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.t-l.s;}\ninline P input(){D x,y;cin >> x >> y; return P(x,y);}\n//??\\??? ???????????¬????????¨???\n\n\n// ??? not verify\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ??????\nP rot (P base, P a, D theta){\n\tP tar=a-base;return base+polar(abs(tar), arg(tar)+theta );\n}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P b,P p){ return b*ip(b,p)/norm(b);}\nP proj(L l,P p){ return l.s+proj(vec(l),p-l.s);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ???????????? verify AOJ CGL_1_C\nenum CCW{\n\tLEFT = 1,\n\tRIGHT = 2,\n\tBACK = 4,\n\tFRONT = 8,\n\tMID = 16,\n\tON=FRONT|BACK|MID\n};\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n\ta -= base; b -= base;\n\tif (ep(a, b) > 0)\n\t\treturn LEFT;    // counter clockwise\n\tif (ep(a, b) < 0)\n\t\treturn RIGHT;   // clockwise\n\tif (ip(a, b) < 0)\n\t\treturn BACK;    // b--base--a on line\n\tif (norm(a) < norm(b))\n\t\treturn FRONT;   // base--a--b on line\n\t// otherwise\n\treturn MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n// verify AOJ CGL_2_A\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ?????¨??´?????¨????????¢??£??????????????? (s??????????????????????????§?????????????¨±?????????)\nB iLL(L a,L b){return !ipar(a,b);}\n\nB eqL(L a,L b){return !iLL(a, b) && ep(vec(a), b.s - a.s)==0;}\nB iLS(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) <= 0;}\nB iLSs(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) < 0;}\n\n// ????????¨?????????????????????\n// verify AOJ CGL_2_B\nB iSS(L a,L b){\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a,L b) {\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ??????\n// verify AOJ CGL_2_C\nP pLL(L a,L b){ return a.s+vec(a)*ep(vec(b),b.s-a.s)/ep(vec(b),vec(a));}\n\n// ?????¨??´???????????¢\nD dLP(L l,P p){return abs( ep(vec(l),p-l.s) )/abs(vec(l));}\n// ?????¨??????????????¢\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.s)) <= 0) return abs(p - s.s);\n\tif (sig( ip(-vec(s), p - s.t)) <= 0) return abs(p - s.t);\n\treturn dLP(s,p);\n}\n\n// ??´?????¨??´???????????¢\nD dLL(L a,L b){ return iLL(a,b)?0:dLP(a,b.s);}\n\n// ?????¨??´?????¨????????¢??£????????¢\nD dLS(L a,L b){ return iLS(a,b)?0:min(dLP(a, b.s),dLP(a, b.t));}\n\n// ????????¨??????????????¢\n// verify AOJ CGL_2_D\nD dSS(L a,L b){ return iSS(a,b)?0:\n\tmin({ dSP(a,b.s),dSP(a,b.t),dSP(b,a.s),dSP(b,a.t)});\n}\n\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){\n\treturn (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;\n}  // base x\ninline B cmp_y(const P &a,const P &b){\n\treturn (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;\n}  // base y\ninline B cmp_a(const P &a,const P &b){\n\treturn (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);\n} // base arg\n\n// ????§???¢\n\n// ??¢???\n// Verify AOJ 1100\n// verify CGL_3_A\nD area(VP pol){\n\tint n=pol.size();\n\tD sum=0.0;\n\trep(i,n){\n\t\tD x=pol[i%n].X-pol[(i+1)%n].X;\n\t\tD y=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=x*y;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢?????????\n// verify CGL_3_B\nB is_convex(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==RIGHT) return false;\n\t}\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????)\n//verify AOJ CGL_3-C\nint in_polygon(VP pol,P p){\n\tint n=pol.size();\n\tint res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==MID)\n\t\t\treturn 1;\n\t\tD vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n\t\tD dx=pol[(i+1)%n].X-pol[i].X;\n\t\tif((pol[i].Y<=p.Y)&&(p.Y< pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res++;\n\t\tif((pol[i].Y> p.Y)&&(p.Y>=pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res--;\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????)\n// Verify AOJ 2514\n\nbool in_polygon(VP pol,L l){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar={pol[i],pol[(i+1)%n]};\n\t\tif(iSS(l,tar))\n\t\t\tcheck.push_back(pLL(l,tar));\n\t}\n\n\tcheck.push_back(l.s);\n\tcheck.push_back(l.t);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m)) return false;\n\t}\n\treturn true;\n}\n\n\n// convex_hull\n// Verify AOJ 0063\n// Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tVP res(2*n);\n\n\t//??\\??????while?????????????????????\n\t//????????????????????????????????????????????´??????<=0\n\t//???????????????????????????????????????????????´??????<0\n\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// ????????????\n// verify AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i], b = pol[(i+1)%n];\n\t\tif(ccw(l.s, l.t, a) != RIGHT) res.push_back(a);\n\t\tif((ccw(l.s, l.t, a)|ccw(l.s, l.t, b))==(LEFT|RIGHT))\n\t\t\tres.push_back(pLL({a,b}, l));\n\t}\n\treturn res;\n}\n\n// ???\n// Verify AOJ 1183\n\nenum RCC{\n\tA_IN_B=1,\n\tB_IN_A=2,\n\tA_ON_B=4,\n\tB_ON_A=8,\n\tISC=16,\n\tON_OUT=32,\n\tOUT=64,\n\tSAME=12,\n\tONS=48\n};\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// ?????¢??£???????????????\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L l) {return sig(c.r, dSP(l, c.c)) >= 0;}\nbool iCSc(C c, L l) {return iCS(c, l) && sig(c.r, max(abs(l.s - c.c), abs(l.t - c.c))) <= 0;}\n\n//2??????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.push_back(a.c+P(a.r,0));\n\t\tres.push_back(a.c+P(-a.r,0));\n\t\tres.push_back(a.c+P(0,a.r));\n\t\tres.push_back(a.c+P(0,-a.r));\n\t}else{\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (norm(d) + norm(a.r) - norm(b.r)) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c);\n\t\tif(rel==ISC){ // 2points\n\t\t\tP w = e * P(0, 1) * sq(norm(a.r)-norm(x));\n\t\t\tres.push_back(a.c + e * x - w);\n\t\t\tres.push_back(a.c + e * x + w);\n\t\t}else if(rel&ONS){ // 1points\n\t\t\tres.push_back(a.c + e * x);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l,c.c);\n\tP e = vec(l) / abs(vec(l)) * sq(norm(c.r) - norm(h - c.c));\n\tres.push_back(h - e);\n\tres.push_back(h + e);\n\treturn res;\n}\n\n\n// ????????\\???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n\n// ????????±?????\\???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tP ba=b.c-a.c;\n\tD d=ang(ba);\n\tD i=acos((a.r+b.r)/abs(ba));\n\tD o=acos((a.r-b.r)/abs(ba));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.push_back(tanC(a,d+i));\n\t\tres.push_back(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.push_back(tanC(a,d+o));\n\t\tres.push_back(tanC(a,d-o));\n\t}\n\n\tif(r&ONS) res.push_back(tanC(a,d)); //??\\????????±???????????\\???\n\n\tif(r==SAME) rep(i,5) res.push_back(tanC(a,i));\n\treturn res;\n}\n\n\nconst int vmax=1010;\nstruct node{int to;D cost;};\n// segments arrangement\nvector<node> graph[vmax];\nvoid sArr(const vector<L> &seg, vector<P> &point){\n\trep(i,seg.size()){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trange(j,i+1,seg.size()){\n\t\t\tif (iSS(seg[i],seg[j]))\n\t\t\t\tpoint.push_back( pLL(seg[i],seg[j]));\n\t\t}\n\t}\n\tsort(point.begin(),point.end(),cmp_x);\n\tpoint.erase(unique(point.begin(),point.end(),cmp_x), point.end());\n\n\trep(i,seg.size()){\n\t\tvector< pair<D, int> > list;\n\t\trep(j,point.size())\n\t\t\tif (ccw(seg[i].s,seg[i].t, point[j])==MID)\n\t\t\t\tlist.push_back(make_pair(norm(seg[i].s-point[j]), j));\n\t\tsort(list.begin(),list.end());\n\t\trange(j,1,list.size()){\n\t\t\tint a = list[j-1].second, b = list[j].second;\n\t\t\tgraph[a].push_back( {b, abs(point[a]-point[b])} );\n\t\t\tgraph[b].push_back( {a, abs(point[a]-point[b])} );\n\t\t}\n\t}\n}\n\n\n\n// under not verify\n\n// ????????????????????????\n/*\nvector<L> merge(vector<L> lines) {\n\trep(i,lines.size())\n\t\tif(lines[i].t < lines[i].s)\n\t\t\tswap(lines[i].s, lines[i].t);\n\tsort(lines.begin(),lines.end());\n\trep(i,lines.size())rep(j,i){\n\t\tif (iSS(lines[i],lines[j])&&!iSSs(lines[i],lines[j])){\n\t\t\tif(abs(lines[i].t-lines[j].s) > abs(vec(lines[j])))\n\t\t\t\tlines[j].t = lines[i].t;\n\t\t\tlines.erase(lines.begin() + i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lines;\n}\n*/\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==MID)\n\t\t\tpol.erase(pol.begin() + i--);\n\t}\n\treturn pol;\n}\n\n\nL bisector(P a, P b) {\n  P mid=(a+b)*P(0.5,0);\n  return L{mid, mid+(b-a)*P(0, pi/2)};\n}\n\nVP voronoi_cell(VP pol,VP v, int s) {\n  rep(i, v.size()) if(i!=s) pol = convex_cut(pol,bisector(v[s], v[i]));\n  return pol;\n}\n\nint main(void){\n    for(int n; cin >> n, n;){\n        VP points(n);\n        vector<D> l(n);\n        rep(i, n) points[i] = input(), cin >> l[i];\n\n        D lb = 0.0, ub = 310;\n        rep(loop, 100){\n            D mid = (lb + ub) / 2.0;\n\n            bool ok = false;\n            [&]\n            {\n                VC circles(n);\n                rep(i, n){\n                    D r2 = pow(l[i], 2) - pow(mid, 2);\n                    if(r2 < -eps) return;\n                    circles[i] = { points[i], sq(r2) };\n                }\n\n                VP ps;\n                rep(i, n){\n                    ps.push_back(circles[i].c);\n\n                    range(j, i + 1, n){\n                        VP ret = pCC(circles[i], circles[j]);\n                        ps.insert(end(ps), begin(ret), end(ret));\n                    }\n                }\n\n                for(auto & p : ps){\n                    bool all_in = true;\n                    [&]{\n                        rep(i, n){\n                            if(not (abs(p - circles[i].c) <= circles[i].r + eps)){\n                                all_in = false;\n                                return;\n                            }\n                        }\n                    }();\n\n                    if(all_in){\n                        ok = true;\n                        return;\n                    }\n                }\n            }();\n\n            if(ok){\n                lb = mid;\n            }\n            else {\n                ub = mid;\n            }\n        }\n\n        cout.precision(12);\n        cout << lb << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\ndouble x[11],y[11],l[11];\n\nCircle circles[11];\nvector<Point> cands;\n\nbool inCircle(Circle c,Point p){//境界上でもtrue\n\tdouble d=pointsDistance(c.center,p);\n\tint s=sgn(d-c.r);\n\tif(s<=0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N;i++) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble lb=0;\n\t\tdouble ub=1000;\n\t\tfor(int i=0;i<N;i++) ub=min(ub,l[i]);\n\t\tfor(int stage=0;stage<100;stage++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircles[i]=Circle(Point(x[i],y[i]),sqrt(l[i]*l[i]-mid*mid));\n\t\t\t}\n\t\t\tcands.clear();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tvector<Point> tmp;\n\t\t\t\t\ttmp=circlesIntersection(circles[i],circles[j]);\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\tcands.push_back(tmp[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cands.size()==0){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tcands.push_back(circles[i].center);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int i=0;i<cands.size();i++){\n\t\t\t\tbool flg=true;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(inCircle(circles[j],cands[i])==false) flg=false;\n\t\t\t\t}\n\t\t\t\tif(flg) ok=true;\n\t\t\t}\n\t\t\tif(ok) lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.9f\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - s.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.p - c2.p);\n\n\tif (c1.r-d-c2.r>EPS)\n\t{\n\t\tres.push_back(c2.p);\n\t\treturn res;\n\t}\n\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\n\nbool is_inc(Circle c, Point p)\n{\n\treturn abs(c.p - p) - c.r < EPS;\n}\n\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tdouble x[10], y[10], l[10];\n\t\tREP(i, n)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t}\n\t\tif (n == 1)\n\t\t{\n\t\t\tcout << l[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble ub = 301, lb = 0;\n\t\tfor (int cnt = 0; cnt < 100; cnt++)\n\t\t{\n\t\t\tdouble mid = (ub + lb) / 2;\n\t\t\tvector<Circle> cs;\n\t\t\tbool f = true;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (mid-l[i]>EPS)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcs.push_back(Circle(Point(x[i], y[i]), sqrt(pow(l[i], 2) - pow(mid, 2))));\n\t\t\t}\n\t\t\tif (!f)\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<Point> cps;\n\t\t\tREP(i, n - 1)FOR(j, i + 1, n)\n\t\t\t{\n\t\t\t\tauto tmp = is_cc(cs[i], cs[j]);\n\t\t\t\tcps.insert(cps.end(),ALL(tmp));\n\t\t\t}\n\t\t\tbool ff = false;\n\t\t\tREP(i, cps.size())\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tREP(j, cs.size())\n\t\t\t\t{\n\t\t\t\t\tif (!is_inc(cs[j], cps[i])) f = false;\n\t\t\t\t}\n\t\t\t\tif (f) ff = true;\n\t\t\t}\n\t\t\tif (ff) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << D10 << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\n int main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12 / x10;\n\t\t\t\t\t\t\tb = (x02 - a*x10)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (isnan(c)) {\n\t\t\t\t\t\t\tint a = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12 - a*x00) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (isnan(c)) {\n\t\t\t\t\t\t\tint a = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  //cerr<<\"judge::\"<<m<<\" \";\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)+EPS){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  //cerr<<\" val \";\n  bool hoge = true;\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m)+EPS)continue;\n      if(dist+in[j].R(m)<=in[i].R(m)+EPS)continue;\n      hoge = false;\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return hoge;\n}\n\ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return m;\n  if(judge(m)){\n    //cerr<<\"true\"<<endl;\n    return req(m,r);\n  }else{\n    //cerr<<\"false\"<<endl;\n    return req(l,m);\n  }\n}\n\ndouble solve(){\n  double ans = req(1.0,300.0);\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //std==c++14\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a,b) ( fabs(a-b) < EPS )\n#define PI acos(-1)\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intersect Circle and Circle\nstatic const int ICC_SEPARATE = 4;//離れている\nstatic const int ICC_CIRCUMSCRIBE = 3;//外接\nstatic const int ICC_INTERSECT = 2;// 交わる\nstatic const int ICC_INSCRIBE = 1;// 内接\nstatic const int ICC_CONTAIN = 0;//内包\n\nstruct point{\n\tdouble x,y;\n\t//construct\n\tpoint() {} \n\tpoint(double x,double y):x(x),y(y){}\n\t//演算子\n\tpoint operator + (point p) { return point(x+p.x,y+p.y); }\n\tpoint operator - (point p) { return point(x-p.x,y-p.y); }\n\tpoint operator * (double k) { return point(x*k,y*k); }\n\tpoint operator / (double k) { return point(x/k,y/k); }\n\tpoint operator / (point p) { return point( (x*p.x + y*p.y)/p.norm()  , (-x*p.y + y*p.x)/p.norm() ) ; }\n\tbool operator < (point p) { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (point p) { return equals(x,p.x) && equals(y,p.y) ; }\n\t//function\n\tdouble arg() { return atan2(y,x) ; }\n\tdouble norm(){return x*x+y*y; }\n\tdouble abs() { return sqrt(norm() ) ;}\n\tdouble dot(point p) { return p.x*x + p.y*y; }\n\tdouble cross(point p) { return x*p.y - y*p.x; }\n\tpoint roll(double theta){ return point( cos(theta)*x - sin(theta)*y , sin(theta)*x + cos(theta)*y ) ; }\t\n\t//input output\n\tvoid input(){cin>>x>>y;}\n\tvoid polar(double r,double theta){ x = r*cos(theta), y= r*sin(theta) ; }\n\tvoid print(){cout<<x<<' '<<y<<endl;};\n\n};\n\nbool sort_x(point a,point b){\n\treturn a.x!=b.x?a.x<b.x:a.y<b.y ;\n}\nbool sort_y(point a,point b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x ;\n}\n\ntypedef vector<point> polygon;\n\nstruct segment{\n\tpoint s,t;\n\tsegment() {}\n\tsegment(point s,point t) : s(s),t(t){}\n\tvoid input(){s.input(),t.input(); }\n};\ntypedef segment line;\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle() {}\n\tcircle(point c,double r) : c(c),r(r){}\n\tvoid input(){c.input(); cin>>r; }\n};\n\ndouble norm(point a){\treturn a.norm(); }\ndouble abs(point a){ return a.abs(); }\ndouble arg(point a){ return a.arg(); }\ndouble dot(point a,point b) { return a.x*b.x + a.y*b.y ; }\ndouble cross(point a,point b) { return a.x * b.y - a.y * b.x ; }\npoint polar(double r,double theta){ point a; a.polar(r,theta); return a; }\npoint orth(point p){ return point(-p.y,p.x); }\n\n//isOrthgonal 垂直\nbool isOrthogonal(point a,point b) { return equals(dot(a,b), 0.0 ) ; }\nbool isOrthogonal(point a,point b,point c,point d) { return isOrthogonal(a-b,c-d) ; }\nbool isOrthogonal(line l1,line l2 ){ return isOrthogonal(l1.t-l1.s,l2.t-l2.s); }\n//isParallel 平行\nbool isParallel(point a,point b) { return equals(cross(a,b), 0.0) ; }\nbool isParallel(point a,point b,point c,point d) { return isParallel(a-b,c-d); }\nbool isParallel(line l1,line l2) { return isParallel(l1.t-l1.s,l2.t-l2.s) ; }\n\npoint project(line l,point p){\n\tpoint base = l.t-l.s;\n\tdouble r = dot(p-l.s,base) / norm(base) ;\n\treturn l.s + base*r;\n}\npoint reflect(line l,point p){\n\treturn p + (project(l,p) - p) *2.0;\n}\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\n\tif(cross(a,b) > EPS ) return CCW_COUNTER_CLOCKWISE ;\n\tif(cross(a,b) < -EPS ) return CCW_CLOCKWISE;\n\tif(dot(a,b) < -EPS ) return CCW_ONLINE_BACK;\n\tif(a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\n\n//intersect\nbool intersect(point p1,point p2,point p3,point p4){return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 ) ; }\nbool intersect(line l1,line l2) { return intersect(l1.s,l1.t,l2.s,l2.t) ; }\nbool intersect(polygon p,line l){\n\tint n = p.size();\n\tfor(int i=0;i<n;i++)  if(intersect(line(p[i],p[(i+1)%n] ) , l ) ) return true;\n\treturn false;\n}\nint intersect(circle c1,circle c2){\n\tif(c1.r < c2.r) swap(c1,c2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble r = c1.r + c2.r;\n\tif(equals(d,r) ) return ICC_CIRCUMSCRIBE;\n\tif(d > r ) return ICC_SEPARATE;\n\tif(equals(d+c2.r,c1.r) ) return ICC_INSCRIBE;\n\tif( d + c2.r < c1.r ) return ICC_CONTAIN;\n\treturn ICC_INTERSECT;\n}\n\n//bool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; } distanceののち\nint intersectcs(circle c,line l ){// 0\t\t1\t\t2\n\tif(norm(project(l,c.c) - c.c )  - c.r*c.r  > EPS ) return 0;\n\tdouble d1 = abs(c.c-l.s),d2  = abs(c.c-l.t);\n\tif(d1 < c.r + EPS && d2 < c.r + EPS ) return 0;\n\tif( (d1<c.r - EPS && d2 > c.r +EPS) || (d1 > c.r +EPS &&d2 < c.r -EPS ) ) return 1;\n\tpoint h = project(l,c.c) ;\n\tif(dot(l.s-h,l.t-h) < 0 ) return 2;\n\treturn 0;\n}\n\n//distance\n//line point\ndouble distancelp(line l,point p){ return abs(cross(l.t-l.s,p-l.s)/ abs(l.t-l.s)  ); }\n//segment point\ndouble distancesp(line l,point p){ \n\tif(dot(l.t-l.s,p-l.s) < 0.0 ) return abs(p-l.s);\n\tif(dot(l.s-l.t,p-l.t) < 0.0 ) return abs(p-l.t);\n\treturn distancelp(l,p);\n}\n//segment segment \ndouble distancess(line l1,line l2){\n\tif(intersect(l1,l2) ) return 0.0;\n\treturn min( min(distancesp(l1,l2.s) ,distancesp(l1,l2.t) ) , min(distancesp(l2,l1.s),distancesp(l2,l1.t)  ) );\n}\n\nbool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; }\n\n//crosspoint \n//segment segment\npoint crosspointss(line l1,line l2){\n\tfor(int k=0;k<2;k++){\n\t\tif(distancesp(l1,l2.s) < EPS ) return l2.s;\n\t\tif(distancesp(l1,l2.t) < EPS ) return l2.t;\n\t\tswap(l1,l2);\n\t}\n\tpoint base = l2.t-l2.s;\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.t-l2.s) );\n\tdouble t = d1/(d1+d2);\n\treturn l1.s + (l1.t-l1.s) * t;\n}\n//line line\npoint crosspointll(line l1,line l2){\n\tdouble a = cross(l1.t-l1.s,l2.t-l2.s);\n\tdouble b = cross(l1.t-l1.s,l1.t-l2.s);\n\tif(abs(a) < EPS && abs(b) < EPS ) return l2.s;\n\treturn l2.s + (l2.t-l2.s) * (b/a) ;\n}\n//circle line\npolygon crosspointCL(circle c,line l){\n\tpolygon ps;\n\tpoint pr = project(l,c.c);\n\tpoint e = (l.t - l.s) / abs(l.t-l.s) ;\n\tif(equals(distancelp(l,c.c),c.r) ){\n\t\tps.emplace_back(pr);\n\t\treturn ps;\n\t}\n\tdouble base = sqrt(c.r*c.r - norm(pr-c.c) );\n\tps.emplace_back(pr + e*base ) ;\n\tps.emplace_back(pr - e*base ) ;\n\treturn ps;\n}\n//circle segment\npolygon crosspointCS(circle c,line l ){\n\tpolygon res = crosspointCL(c,l);\n\tif(intersectcs(c,l) == 2 ) return res;\n\tif(res.size() > 1u ){//一つのみ削る\n\t\tif(dot(l.s-res[0] ,l.t-res[0] ) > 0) swap(res[0],res[1] );\n\t\tres.pop_back();\n\t}\n\treturn res;\n}\npolygon crosspointcc(circle c1,circle c2){\n\tpolygon p(2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble a = acos( (c1.r *c1.r + d*d -c2.r*c2.r) /(2*c1.r*d ) );\n\tdouble t = arg(c2.c-c1.c);\n\tp[0] = c1.c + polar(c1.r,t+a);\n\tp[1] = c1.c + polar(c1.r,t-a);\n\t//if(cross(c2.c-c1.c,p[0]-c1.c) > EPS) swap(p[0],p[1]); //c1に関する偏角の順\n\treturn p;\n}\n\nint contains(polygon g,point p) { //IN:2 ON:1 OUT:0\n    int n = g.size();\n    bool f = false;\n    for(int i=0;i<n;i++){\n\tpoint a = g[i] - p,b = g[(i+1)%n] - p;\n\tif( fabs(cross(a,b) ) < EPS && dot(a,b) < EPS) return 1;\n\tif( a.y > b.y ) swap(a,b);\n\tif( a.y < EPS && EPS < b.y && cross(a,b) > EPS ) f = !f;\n    }\n    return (f?2:0) ;\n}\n\npolygon andrewscan(polygon &s){ //convex hull\n\tpolygon u,l;\n\tif(s.size() < 3) return s;\n\t//sort(s.begin(),s.end() );\n\t//最も左で最も右の点にする\n\tsort(s.begin(),s.end(),sort_y);\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\tfor(int i=2;i<s.size();i++){\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\n\t\t//for(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\t\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n\ndouble diameter(polygon &s){\n\tpolygon p = s;\n\tint n = p.size();\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++){\n\t\tif(p[i] < p[k]) i = k;\n\t\tif(!(p[j]<p[k]) ) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i,sj = j;\n\twhile( i != sj || j != si ){\n\t\tres = max(res,abs(p[i]-p[j]) );\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j] ) < 0.0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\nbool isconvex(polygon p){\n\tbool f = 1;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tint t = ccw(p[(i+n-1)%n],p[i],p[(i+1)%n] );\n\t\tf&= t!=CCW_CLOCKWISE;\n\t}\n\treturn f;\n}\ndouble area(polygon p){\n\tdouble res =  0.0;\n\tfor(int i=0;i<p.size();i++) res += cross(p[i],p[ (i+1)%p.size() ]);\n\treturn res/2.0;\n}\ndouble area(circle c1,circle c2){\n\tdouble d = abs(c1.c-c2.c);\n\tif(c1.r + c2.r <= d + EPS ) return 0.0;\n\tif(d<=abs(c1.r-c2.r) ){\n\t\tdouble r = min(c1.r,c2.r);\n\t\treturn PI*r*r;\n\t}\n\tdouble rc = (d*d + c1.r*c1.r -c2.r*c2.r)/(2*d);\n\tdouble th = acos(rc/c1.r);\n\tdouble ph = acos( (d-rc)/c2.r);\n\treturn c1.r*c1.r*th + c2.r*c2.r*ph - d * c1.r * sin(th) ;\n}\n\npolygon convex_cut(polygon p,line l){\n\tpolygon q;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tpoint a = p[i] , b = p[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a) != -1 ) q.push_back(a);\n\t\tif(ccw(l.s,l.t,a) * ccw(l.s,l.t,b) < 0) q.push_back(crosspointss(line(a,b),l) );\n\t}\n\treturn q;\n}\n//[s,t) 再帰 devide and conquer\ndouble inf  = 1e10;\ndouble closest_pair_dac(polygon &p,int s,int t,double &res){\n\tif(t-s<=1)return inf;\n\tif(t-s==2){\n\t\tsort(p.begin()+s,p.begin()+t,sort_y);\n\t\treturn (p[s]-p[s+1]).abs();\n\t}\n\tint mid = (s+t)/2;\n\tdouble x = p[mid].x;\n\tres = min(closest_pair_dac(p,s,mid,res),closest_pair_dac(p,mid,t,res) );\n\tauto it = p.begin();\n\tauto its = it+s,itm = it+mid,itt = it + t;\n\tinplace_merge(its,itm,itt,sort_y);\n\tvector<point> tmp;\n\tfor(int i=s;i<t;i++){\n\t\tif(abs(p[i].x-x) >= res) continue;\n\t\tfor(int j=tmp.size()-1;j>=0;j--){\n\t\t\tpoint d = p[i]-tmp[j];\n\t\t\tif(d.y >= res) break;\n\t\t\tres = min( res , d.abs() );\n\t\t}\n\t\ttmp.push_back(p[i]);\n\t}\n\treturn res;\n}\ndouble closest_pair(polygon &p){\n\tdouble res = inf;\n\tsort(p.begin(),p.end());\n\treturn  closest_pair_dac(p,0,p.size(),res);\n}\n\npolygon tangent(circle c,point p){//点から円への接戦\n\tcircle c2 = circle(p,sqrt(norm(c.c-p)-c.r*c.r ) );\n\tpolygon res = crosspointcc(c,c2);\n\tsort(res.begin(),res.end() );\n\treturn res;\n}\nvector<line> tangent(circle c1,circle c2){//円の共通接戦\n    vector<line> res;\n    if(c1.r < c2.r ) swap(c1,c2);\n    point g  = c2.c-c1.c;\n    if( equals( g.norm() ,0.0 ) ) return res;\n    point u = g/g.abs();\n    point v = orth(u);\n    for(int s=1;s>=-1;s-=2){\n\tdouble h = (c1.r + s*c2.r)/g.abs();\n\tif( equals(1-h*h,0.0) ){\n\t\tres.emplace_back( line(c1.c+u*c1.r,c1.c+(u+v)*c1.r) );\n\t}else if(1-h*h>0) {\n\t\tpoint uu = u*h,vv = v*sqrt(1-h*h) ;\n\t\tres.emplace_back( line(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s) );\n\t\tres.emplace_back( line(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s) );\n\t}\n    }\n\treturn res;\n}\npolygon tangent_point(circle c1,circle c2){//円の共通接戦における接点集合\n    vector<line> ls = tangent(c1,c2);\n    polygon res ;\n    for(auto l:ls){\n\tpolygon tmp = crosspointCL(c1,l);\n\tif(tmp.size()!=0)res.emplace_back(tmp[0]);\n    }\n    sort(res.begin(),res.end());\n    return res;\n}\n\ndouble calcu(circle c,point a,point b){\n\tpoint va = c.c-a,vb = c.c - b;\n\tdouble f = cross(va,vb);\n\tdouble res = 0.0;\n\tif(equals(f,0.0) )return res;\n\tif(max(abs(va),abs(vb) ) < c.r + EPS) return f;\n\tpoint d( dot(va,vb),cross(va,vb) );\n\tif( distancesp(line(a,b),c.c) > c.r -EPS ) return c.r*c.r*atan2(d.y,d.x);\n\tauto u = crosspointCS(c,line(a,b) );\n\tif(u.empty() ) return res;\n\tif(u.size() > 1u && dot(u[1]-u[0],a-u[0] ) > 0 ) swap(u[0],u[1]);\n\tu.emplace(u.begin(),a);\n\tu.emplace_back(b);\n\tfor(int i=1;i<u.size();i++)res+=calcu(c,u[i-1],u[i]);\n\treturn res;\n}\ndouble area(polygon ps,circle c){\n\tif(ps.size() < 3u) return 0.0;\n\tdouble res = 0.0;\n\tfor(int i=0;i<ps.size();i++) res += calcu(c,ps[i],ps[(i+1)%ps.size()] );\n\treturn res/2;\n}\n\n\n//double inf = 1000;\ntypedef pair<point,double> mp;\nint main(){\n    \twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tdouble lm = inf,mm = 0;\n\t\tvector<mp> a(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t    a[i].first.input();\n\t\t    cin>>a[i].second;\n\t\t    lm = min(a[i].second,lm);\n\t\t}\n\t\tif(n != 1)\n\t\twhile( lm - mm > EPS){\n\t\t    vector<circle> c(n);\n\t\t    double l = (lm+mm)/2;\n\t\t    for(int i=0;i<n;i++){\n\t\t\tc[i] = circle(a[i].first, sqrt(a[i].second*a[i].second - l*l )  );\n\t\t    }\n\t\t    bool f = false;\n\t\t    for(int i=0;i<n;i++)if(!f)\n\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t    if( intersect(c[i],c[j]) == ICC_SEPARATE ){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    if( f ){\n\t\t\tlm = l;\n\t\t\tcontinue;\n\t\t    }\n\t\t    polygon ps;\n\t\t    for(int i=0;i<n;i++){\n\t\t\tps.push_back( c[i].c  );\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t    if( intersect(c[i],c[j] ) == ICC_CONTAIN )continue;\n\t\t\t\tpolygon tmp = crosspointcc(c[i],c[j]);\n\t\t\t\tfor(int k=0;k<tmp.size();k++) ps.push_back(tmp[k]);\n\t\t\t}\n\t\t    }\n\t\t    /*if(ps.size() == 0){\n\t\t\tmm = l;\n\t\t\tcontinue;\n\t\t    }*/\n\t\t    bool ff = false;\n\t\t    for(int i=0;i<ps.size();i++){\n\t\t\tbool flag = true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t    if( (c[j].c - ps[i] ).abs()   <=   c[j].r  + EPS){\n\t\t\t    }else flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t    ff = true;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if(ff){\n\t\t\tmm = l;\n\t\t    }else{\n\t\t\tlm = l;\n\t\t    }\n\t\t}\n\t\tprintf(\"%0.10lf\\n\", lm);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1190&lang=jp\n#define INF 1<<30\nint n;\nvector<double> x;\nvector<double> y;\nvector<double> l;\ndouble ans_X, ans_Y;\ndouble check_y(double X, double Y) {\n\tdouble Sum = INF;\n\tfor (int i = 0; i < n;i++) {\n\t\tdouble L = pow(X - x[i], 2) + pow(Y - y[i], 2);\n\t\tSum = min(Sum, l[i] - L);\n\t}\n\treturn Sum;\n}\n\ndouble check_x(double X) {\n\tdouble yl = -100, yr = 100;\n\tfor (int i = 0; i < 150; i++) {\n\t\tdouble mid1 = yl + (yr - yl) / 3;\n\t\tdouble mid2 = yl + (yr - yl) * 2 / 3;\n\t\tif (check_y(X, mid1) > check_y(X, mid2)) {\n\t\t\tyr = mid2;\n\t\t}\n\t\telse {\n\t\t\tyl = mid1;\n\t\t}\n\t}\n\tans_Y = yl;\n\treturn check_y(X, ans_Y);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> n, n) {\n\t\tx.clear(), y.clear(), l.clear();\n\t\tx.resize(n), y.resize(n), l.resize(n);\n\t\tfor (int i = 0; i < n;i++) { cin >> x[i] >> y[i] >> l[i]; l[i] *= l[i]; }\n\t\tdouble xl = -100, xr = 100;\n\t\tfor (int i = 0; i < 159; i++) {\n\t\t\tdouble mid1 = xl + (xr - xl) / 3;\n\t\t\tdouble mid2 = xl + (xr - xl) * 2 / 3;\n\t\t\tif (check_x(mid1) > check_x(mid2)) {\n\t\t\t\txr = mid2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\txl = mid1;\n\t\t\t}\n\t\t}\n\t\tans_X = xl;\n\t\tcout << fixed << setprecision(15) << sqrt(check_y(ans_X, ans_Y)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n#define EPS (1e-10)\n\nstruct Vector2 {\n  //using T = double;\n  double x, y;\n\n  Vector2() : x(double(0)), y(double(0)) {}\n  Vector2(double x_, double y_) : x(x_), y(y_) {}\n\n  Vector2 operator + (const Vector2& v) const { return Vector2(x + v.x, y + v.y); }\n  Vector2 operator - (const Vector2& v) const { return Vector2(x - v.x, y - v.y); }\n  Vector2 operator * (const double& k) const { return Vector2(x * k, y * k); }\n  Vector2 operator / (const double& k) const { return Vector2(x / k, y / k); }\n\n  Vector2 operator *= (const double& k) { return Vector2(x * k, y * k); }\n\n  double norm2() { return x * x + y * y; }\n  double norm() { return sqrt(norm2()); }\n\n  bool operator < (const Vector2& v) const {\n    return x != v.x ? x < v.x : y < v.y;\n  }\n  bool operator == (const Vector2& v) const {\n    return fabs(x - v.x) < EPS && fabs(y - v.y) < EPS;\n  }\n\n  double dot(const Vector2& v) { return x * v.x + y * v.y; }\n  double cross(const Vector2& v) { return x * v.y - y * v.x; }\n};\n\ntypedef Vector2 Point2;\n\nstruct Vector3 {\n  //using T = double;\n  double x, y, z;\n\n  Vector3() : x(double(0)), y(double(0)), z(double(0)) {}\n  Vector3(double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}\n  Vector3(Vector2 v, double z_) : x(v.x), y(v.y), z(z_) {}\n\n  Vector3 operator + (const Vector3& v) const { return Vector3(x + v.x, y + v.y, z + v.z); }\n  Vector3 operator - (const Vector3& v) const { return Vector3(x - v.x, y - v.y, z - v.z); }\n  Vector3 operator * (const double& k) const { return Vector3(x * k, y * k, z * k); }\n  Vector3 operator / (const double& k) const { return Vector3(x / k, y / k, z / k); }\n\n  double norm2() { return x * x + y * y + z * z; }\n  double norm() { return sqrt(norm2()); }\n\n  bool operator < (const Vector3& v) const {\n    if (x == v.x) {\n      if (y == v.y) {\n        return z <= v.z;\n      }\n      return y <= v.y;\n    }\n    return x <= v.x;\n  }\n  bool operator == (const Vector3& v) const {\n    return fabs(x - v.x) < EPS && fabs(y - v.y) < EPS;\n  }\n\n  double dot(const Vector3& v) { return x * v.x + y * v.y + z * v.z; }\n  Vector3 cross(const Vector3& v) {\n    return Vector3(y * v.z - v.y * z,\n                   z * v.x - v.z * x,\n                   x * v.y - v.x * y);\n  }\n\n};\n\ntypedef Vector3 Point3;\n\nstruct Rope {\n  double x, y, l;\n  Rope() {}\n  Rope(double x_, double y_, double l_) : x(x_), y(y_), l(l_) {}\n\n  bool can_place(Rope rope) {\n    auto dist = (Vector3(rope.x, rope.y, rope.l) - Vector3(x, y, 0)).norm();\n    return (dist < l);\n  }\n\n  bool can_place(Vector3 p) {\n    auto dist = (p - Vector3(x, y, 0)).norm();\n    return (dist - EPS <= l);\n  }\n};\n\nVector3 highest_point(Rope A, Rope B) {\n  auto AB = Vector3(B.x - A.x, B.y - A.y, 0);\n  double a = B.l;\n  double b = A.l;\n  double c = AB.norm();\n  double cosA = (b*b + c*c - a*a) / (2*b*c);\n  double sinA = sqrt(1 - cosA*cosA);\n  auto AC = Vector3(AB.x * cosA * b / c, AB.y * cosA * b / c, b * sinA);\n  return Vector3(A.x, A.y, 0) + AC;\n}\n\nstruct Circle2 {\n  double x, y, r;\n  Circle2() {}\n  Circle2(double x_, double y_, double r_) : x(x_), y(y_), r(r_) {}\n  Circle2(Rope rope) : x(rope.x), y(rope.y), r(rope.l) {}\n};\n\nstruct Line2 {\n  double a, b, c;\n  Line2() {}\n  Line2(double a_, double b_, double c_) : a(a_), b(b_), c(c_) {}\n};\n\nVector3 rotate(Vector2 middle, Vector2 v, double alpha) {\n  v *= cos(alpha);\n  return Vector3(middle.x + v.x, middle.y + v.y, sin(alpha));\n}\n\nVector3 highest_point(Rope A, Rope B, Rope C) {\n  auto c1 = Circle2(A);\n  auto c2 = Circle2(B);\n  auto line = Line2(-2*c1.x + 2*c2.x, -2*c1.y + 2*c2.y, c1.x*c1.x + c1.y*c1.y - c1.r*c1.r - c2.x*c2.x - c2.y*c2.y + c2.r*c2.r);\n  double d = line.a * c1.x + line.b * c1.y + line.c;\n  double a2b2 = line.a*line.a + line.b*line.b;\n  Vector2 middle;\n  middle.x = (-line.a * d) / a2b2 + c1.x;\n  middle.y = (-line.b * d) / a2b2 + c1.y;\n  double root = sqrt(a2b2 * c1.r*c1.r - d*d);\n  Vector2 v;\n  v.x = line.b * root / a2b2;\n  v.y = -line.a * root / a2b2;\n\n  double a1 = 2 * (- (C.x - middle.x) * v.x - (C.y - middle.y) * v.y);\n  double a0 = (C.x - middle.x) * (C.x - middle.x) + (C.y - middle.y) * (C.y - middle.y) + v.norm2() - C.l * C.l;\n  double cosA = -a0 / a1;\n  double sinA = sqrt(1 - cosA*cosA);\n  return Vector3(middle.x + v.x * cosA, middle.y + v.y * cosA, v.norm() * sinA);\n}\n\nint main() {\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    vector<Rope> ropes(n);\n    rep (i, n) {\n      int x, y, l;\n      scanf(\"%d %d %d\", &x, &y, &l);\n      ropes[i] = Rope(x, y, l);\n    }\n    if (n == 1) {\n      printf(\"%.9f\\n\", ropes[0].l);\n      continue;\n    }\n    if (n == 2) {\n      double ans = 0;\n      if (ropes[1].can_place(ropes[0])) {\n        ans = max(ans, ropes[0].l);\n      }\n      if (ropes[0].can_place(ropes[1])) {\n        ans = max(ans, ropes[1].l);\n      }\n      if (ans == 0) {\n        ans = highest_point(ropes[0], ropes[1]).z;\n      }\n      printf(\"%.9f\\n\", ans);\n      continue;\n    }\n\n    vector<Rope> theropes(3);\n    double ans = DBL_MAX;\n    rep (i, n) {\n      theropes[0] = ropes[i];\n      FOR (j, i+1, n) {\n        theropes[1] = ropes[j];\n        FOR (k, j+1, n) {\n          double theans = 0;\n          theropes[2] = ropes[k];\n          //\n          rep (ii, 3) {\n            auto target = theropes[ii];\n            auto checkA = theropes[(ii+1)%3];\n            auto checkB = theropes[(ii+2)%3];\n            if (checkA.can_place(target) && checkB.can_place(target)) {\n              theans = max(theans, target.l);\n            }\n          }\n          //debug(theans);\n          if (theans == 0) {\n            rep (ii, 3) {\n              auto targetA = theropes[ii];\n              auto targetB = theropes[(ii+1)%3];\n              auto check = theropes[(ii+2)%3];\n              auto target_point = highest_point(targetA, targetB);\n              if (check.can_place(target_point)) {\n                theans = max(theans, target_point.z);\n              }\n            }\n          }\n          //debug(theans);\n          if (theans == 0) {\n            theans = max(theans, highest_point(theropes[0], theropes[1], theropes[2]).z);\n          }\n          assert(theans > 0);\n          ans = min(ans, theans);\n        }\n      }\n    }\n    printf(\"%.9f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<vector>\n#include<complex>\nusing namespace std;\n#define int long long\n// 2円の交点\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nVP crosspointCC(P a, D ar, P b, D br) {\n\tVP ps;\n\tP ab = b - a;\n\tD d = abs(ab);\n\tD crL = (norm(ab) + ar*ar - br*br) / (2 * d);\n\tif (EQ(d, 0) || ar < abs(crL)) return ps;\n\n\tP abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n\tP cp = a + crL / d * ab;\n\tps.push_back(cp + abN);\n\tif (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n\treturn ps;\n}\nsigned main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> l(N);\n\t\tdouble ng = 300;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t\tng = min(ng, (double)l[i]);\n\t\t}\n\n\t\tdouble ok = 0;\n\t\tdouble m;\n\t\tbool f;\n\n\t\twhile (ng - ok > 1e-9) {\n\t\t\tm = (ng + ok)*0.5;\n\t\t\tvector<pair<P, D> >vp;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tvp.push_back(make_pair(P(x[i], y[i]), sqrt(l[i] * l[i] - m * m)));\n\t\t\t}\n\t\t\tvector<P> kouho;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tkouho.push_back(P(x[i], y[i]));\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tVP t = crosspointCC(vp[i].first, vp[i].second, vp[j].first, vp[j].second);\n\t\t\t\t\tfor (auto p : t) {\n\t\t\t\t\t\tkouho.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = false;\n\t\t\t\n\t\t\tfor (auto p : kouho) {\n\t\t\t\tbool tf = true;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (abs(p - vp[i].first) > vp[i].second + EPS) {\n\t\t\t\t\t\ttf = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tf)f = true;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tok = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = m;\n\t\t\t}\n\t\t}\n\n\t\tcout << fixed << setprecision(15) << ok << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-7;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Point> is_cc(Circle c1,Circle c2){\n    if(c1.r>c2.r)swap(c1,c2);\n    Point ok(inf,inf);\n    Point ng(-inf,-inf);\n    ld d = abs(c1.p-c2.p);\n    if(d>c1.r+c2.r){\n        return {};\n    }\n    if(c2.r>d+c1.r)return {};\n    ld theta = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    Point mid = c1.p +(c2.p-c1.p)* cos(theta) * c1.r /d;\n    Point h = (c2.p-c1.p) * Point(0,1) * sin(theta) * c1.r /d;\n    vector<Point> ret;\n    ret.push_back(mid+h);ret.push_back(mid-h);\n    return ret;\n}\n\nvoid solve(int n){\n    Point p[n];\n    ld l[n];\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        p[i]=Point(x,y);\n        cin>>l[i];\n    }\n    ld ok=0,ng=1000;\n    rep(i,n)ng=min(ng,l[i]);\n    rep(_,60){\n        ld mid=(ok+ng)/2;\n        double r[n];\n        rep(i,n){\n            r[i]=sqrt(l[i]*l[i]-mid*mid);\n        }\n        Circle c[n];\n        rep(i,n)c[i]=Circle{p[i],r[i]};\n        bool can=false;\n        rep(i,n)REP(j,i+1,n){\n            auto ret = is_cc(c[i],c[j]);\n            for(auto q : ret){\n                bool in = true;\n                rep(i,n){\n                    if(abs(q-p[i])>r[i]+eps)in=false;\n                }\n                if(in)can=true;\n            }\n        }\n        rep(i,n){\n            bool in = true;\n            rep(j,n){\n                if(abs(p[i]-p[j])>r[j]+eps)in=false;\n            }\n            if(in)can=true;\n        }\n        if(can)ok=mid;\n        else ng=mid;\n    }\n    cout<<ok<<endl;\n}\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nconst double EPS = 1e-7;\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(p.y, -p.x); } // 時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle(const Point& p=Point(0,0), double r=0) : p(p), r(r) {}\n};\nbool contains(const Circle& c, const Point& p) {\n    return norm(c.p - p) < c.r + EPS;\n}\nbool contains(const Circle& a, const Circle& b) {\n    return b.r + norm(a.p - b.p) < a.r + EPS;\n}\nbool intersects(const Circle& a, const Circle& b) {\n    if (contains(a, b) || contains(b, a)) return false;\n    return norm(a.p - b.p) < a.r + b.r + EPS;\n}\nostream& operator<<(ostream& os, const Circle& c) {\n    return os << \"Circle[\" << c.p << \",\" << c.r << \"]\";\n}\nvector<Point> crosspoint(const Circle& a, const Circle& b) {\n    if (!intersects(a, b)) return vector<Point>();\n    double d = norm(b.p - a.p);\n    double x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n    double y = sqrt(a.r * a.r - x * x);\n    Point v = b.p - a.p;\n    vector<Point> ret(2);\n    Point e = v / d;\n    ret[0] = a.p + e * x + rot90(e) * y;\n    ret[1] = a.p + e * x - rot90(e) * y;\n    return ret;\n}\n\nint N;\nvector<Point> ps;\nvector<double> ls;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    ps.clear(); ps.resize(N);\n    ls.clear(); ls.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ps[i].x >> ps[i].y >> ls[i];\n    }\n    return true;\n}\n\nbool C(double h) {\n    vector<Circle> cs(N);\n    for (int i = 0; i < N; i++) {\n        cs[i].p = ps[i];\n        cs[i].r = sqrt(ls[i] * ls[i] - h * h);\n    }\n    vector<Point> cands;\n    for (int i = 0; i < N; i++) {\n        cands.push_back(cs[i].p);\n        for (int j = i + 1; j < N; j++) {\n            const Circle& a = cs[i];\n            const Circle& b = cs[j];\n            if (contains(a, b) || contains(b, a)) continue;\n            if (!intersects(a, b)) return false; // 共通部分を持たない2円が存在 \n            vector<Point> xs = crosspoint(a, b);\n            cands.insert(cands.end(), xs.begin(), xs.end());\n        }\n    }\n    for (int i = 0; i < cands.size(); i++) {\n        const Point& p = cands[i];\n        for (int j = 0; j < N; j++) {\n            if (!contains(cs[j], p)) {\n                goto next;\n            }\n        }\n        return true;\nnext:;\n    }\n    return false;\n}\n\nvoid solve() {\n    double L = 0;\n    for (int i = 0; i < N; i++) L = max(L, ls[i]);\n    double lb = 1, ub = L;\n    for (int i = 0; i < 300; i++) {\n        double mid = (lb + ub) / 2;\n        (C(mid) ? lb : ub) = mid;\n    }\n    printf(\"%.10lf\\n\", lb);\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n  \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n  \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n  \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\n  \nint main() {\n    int n;\n    cin.sync_with_stdio(0);\n    while (cin >> n, n) {\n        va<int, 3> bl(n);\n        rep(i, n)rep(j, 3)cin >> bl[i][j];\n        //va<double, 3> h;\n        double ans = 1e9;\n        int mina = 0;\n        rep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n        ans *= ans;\n        rep(i,n){\n            rep(j,i){\n                double l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n                double a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n                double x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n                if (z < 0)continue;\n                if (z<ans&&a > 0 && a < l)ans = z;\n                rep(k, j) {\n                    double x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n                    double a, b, c;\n                    if (x[1][1] == 0) {\n                        if (x[0][1] == 0)continue;\n                        if (x[1][0]*x[0][1] - (x[1][1] )*x[0][0] == 0)continue;\n                        a = 1/ (2*(x[1][0]*x[0][1] - (x[1][1])*x[0][0]))*(x[1][2]*x[0][1] - x[1][1]  * x[0][2]);\n                        b = (x[0][2]*0.5 - a*x[0][0])*(1/ x[0][1]);\n                    }\n                    else {\n                        if (x[0][0]*x[1][1] - (x[0][1])*x[1][0] == 0)continue;\n                        a = 1/ (2*(x[0][0]*x[1][1] - (x[0][1] )*x[1][0]))*(x[0][2]*x[1][1] - x[0][1]* x[1][2]);\n                        b = (x[1][2] *0.5 - a*x[1][0]) *(1 / x[1][1]);\n                    }\n                    c = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n                    if (c < 0)continue;\n                    if (c >= ans)continue;\n                    int cc = ccw( P(a, b),P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                    if (cc == ccw(P(a, b),P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b),P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                }\n            }\n        }\n        cout << fixed << setprecision(7) << sqrt(ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 3> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ x,y,z, });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\nstruct Balloon {\n\tdouble x, y, l;\n\n\tdouble score(double x2, double y2)const {\n\t\tdouble d_2 = pow(x - x2, 2) + pow(y - y2, 2);\n\t\treturn pow(l, 2) - d_2;\n\t}\n};\n\nstruct Stage {\n\tStage() \n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tREP(i, n)\n\t\t{\n\t\t\tBalloon ball;\n\t\t\tcin >> ball.x >> ball.y >> ball.l;\n\t\t\tballs.push_back(ball);\n\t\t}\n\t}\n\n\tbool is_end() \n\t{\n\t\treturn balls.empty();\n\t}\n\t\n\tvoid action()\n\t{\n\t\tconst int TRY = 100;\n\t\tdouble x = 0;\n\t\tdouble y = 0;\n\t\tdouble step = 1;\n\n\t\twhile (step > 1e-9) {\n\t\t\tREP(i, TRY) {\n\t\t\t\tauto dir = select_dir(x, y, step);\n\t\t\t\tx += step * dir.first;\n\t\t\t\ty += step * dir.second;\n\t\t\t}\n\t\t\tstep /= 10.0;\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(10)<<sqrt(eval(x, y)) << endl;\n\t\tcerr << \"=================\" << endl;\n\t}\n\nprivate:\n\tvector<Balloon> balls;\n\n\tpair<int, int> select_dir(double x, double y, double step)\n\t{\n\t\tpair<int, int> bestDir = { -1,-1 };\n\t\tdouble bestScore = -INF;\n\t\tFOR(i, -1, 2)FOR(j, -1, 2) {\n\t\t\tdouble tmp = eval(x + step * i, y + step * j);\n\t\t\tif (bestScore < tmp) {\n\t\t\t\tbestScore = tmp;\n\t\t\t\tbestDir = { i,j };\n\t\t\t}\n\t\t}\n\t\treturn bestDir;\n\t}\n\n\tdouble eval(double x, double y)\n\t{\n\t\tdouble res = INF;\n\t\tfor (auto ball : balls)\n\t\t{\n\t\t\tres = min(res, ball.score(x, y));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tStage stage;\n\t\tif (stage.is_end())break;\n\t\tstage.action();\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nint n,l[15];\nP p[15];\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tif(sgn(a.r+b.r-d)<0) return OUT;\n\tif(sgn(a.r+b.r-d)==0) return ON_OUT;\n\tif(sgn(abs(a.r-b.r)-d)<0) return ISC;\n\tif(sgn(abs(a.r-b.r)-d)==0) return ON_IN;\n\treturn IN;\n}\nVP pcl(C c, L l){P h=proj(l,c.c),e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));return VP{h-e,h+e};}\nVP pcc(C a,C b){P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d,h=a.c+w,e=w*P(0,1);return pcl(a,{h-e,h+e});}\n\n\nR calc(P point){\n\tR res=INF;\n\trep(i,n) chmin(res,sq(norm(l[i])-norm(p[i]-point)));\n\treturn res;\n}\n\nP getpoint(int i,int j){\n\tL line={O,P(abs(p[j]-p[i]),0.0)};\n\tC ci={line.s,l[i]},cj={line.t,l[j]};\n\tVP res=pcc(ci,cj);\n\tR len=real(proj(line,res[0]));\n\tP ret=p[i]+len/abs(p[j]-p[i])*(p[j]-p[i]);\n\treturn ret;\n}\n\nL getline(int i,int j){\n\tP h=getpoint(i,j);\n\tP e=(p[j]-p[i])*P(0,1);\n\treturn L{h-e,h+e};\n}\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n) cin >> p[i] >> l[i];\n\t\tR ans=calc(O);\n\t\trep(i,n) chmax(ans,calc(p[i]));\n\t\trep(j,n)rep(i,j) chmax(ans,calc(getpoint(i,j)));\n\t\trep(k,n)rep(j,k)rep(i,j){\n\t\t\tL l1=getline(i,j),l2=getline(i,k);\n\t\t\tP candiate=cross(l1,l2);\n\t\t\tchmax(ans,calc(candiate));\n\t\t}\n\t\trep(i,n) chmin<R>(ans,l[i]);\n\t\tcout.precision(20);\n\t\tcout << fixed << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][0],-bl[i][2] + bl[j][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][0],-bl[i][2] + bl[k][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1] == 0))continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[0][2] - 2 * a*x[0][1]) / 2 / x[0][1];\n\t\t\tc = bl[i][2] - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n};\n\npoint operator*(double c,const point &a){ return point(c*a.x,c*a.y); }\n\ndouble abs(const point &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle():c(point(0,0)),r(0){}\n\tcircle(const point &c,double r):c(c),r(r){}\n};\n\nbool cover(const circle &C,const point &p){\n\treturn abs(C.c-p)<C.r+EPS;\n}\n\nint get_intersect(const circle &C1,const circle &C2,vector<point> &res){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif(d<EPS && abs(r1-r2)<EPS){ // C1==C2\n\t\treturn -1;\n\t}\n\telse if(r1+r2<d-EPS || d+EPS<abs(r1-r2)){\n\t\treturn 0;\n\t}\n\telse{\n\t\tdouble a=(r1*r1-r2*r2+d*d)/(2*d);\n\t\tdouble h=sqrt(max(r1*r1-a*a,0.0));\n\t\tpoint tmp1=p1+a/d*(p2-p1);\n\t\tpoint tmp2=h/d*(p2-p1);\n\t\tif(abs(tmp2)<EPS){\n\t\t\tres.push_back(tmp1);\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\tres.push_back(point(tmp1.x-tmp2.y,tmp1.y+tmp2.x));\n\t\t\tres.push_back(point(tmp1.x+tmp2.y,tmp1.y-tmp2.x));\n\t\t\treturn 2;\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tdouble x[10],y[10],l[10];\n\t\trep(i,n) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\n\t\tdouble lo=0,hi=*min_element(l,l+n);\n\t\trep(_,100){\n\t\t\tdouble mi=(lo+hi)/2;\n\n\t\t\tcircle C[10];\n\t\t\trep(i,n) C[i]=circle(point(x[i],y[i]),sqrt(l[i]*l[i]-mi*mi));\n\n\t\t\tvector<point> P;\n\t\t\trep(i,n) P.push_back(C[i].c);\n\t\t\trep(i,n) rep(j,i) get_intersect(C[i],C[j],P);\n\t\t\tbool ok=false;\n\t\t\trep(i,P.size()){\n\t\t\t\tok=true;\n\t\t\t\trep(j,n) if(!cover(C[j],P[i])) ok=false;\n\t\t\t\tif(ok) break;\n\t\t\t}\n\n\t\t\tif(ok) lo=mi;\n\t\t\telse   hi=mi;\n\t\t}\n\n\t\tprintf(\"%f\\n\",lo);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\nusing ld = long double;\n\nstruct Balloon {\n\tld x, y, l;\n\n\tld score(ld x2, ld y2)const {\n\t\tld d_2 = pow(x - x2, 2) + pow(y - y2, 2);\n\t\treturn pow(l, 2) - d_2;\n\t}\n};\n\nstruct Stage {\n\tStage() \n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tREP(i, n)\n\t\t{\n\t\t\tBalloon ball;\n\t\t\tcin >> ball.x >> ball.y >> ball.l;\n\t\t\tballs.push_back(ball);\n\t\t}\n\t}\n\n\tbool is_end() \n\t{\n\t\treturn balls.empty();\n\t}\n\t\n\tvoid action()\n\t{\n\t\tconst int TRY = 1000;\n\t\tld x = 0;\n\t\tld y = 0;\n\t\tld step = 1;\n\n\t\twhile (step > 1e-12) {\n\t\t\tREP(i, TRY) {\n\t\t\t\tauto dir = select_dir(x, y, step);\n\t\t\t\tx += step * dir.first;\n\t\t\t\ty += step * dir.second;\n\t\t\t}\n\t\t\tstep /= 10.0;\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(10)<<sqrt(eval(x, y)) << endl;\n\t\t//cerr << \"=================\" << endl;\n\t}\n\nprivate:\n\tvector<Balloon> balls;\n\n\tpair<int, int> select_dir(ld x, ld y, ld step)\n\t{\n\t\tpair<int, int> bestDir = { -1,-1 };\n\t\tld bestScore = -INF;\n\t\tFOR(i, -1, 2)FOR(j, -1, 2) {\n\t\t\tld tmp = eval(x + step * i, y + step * j);\n\t\t\tif (bestScore < tmp) {\n\t\t\t\tbestScore = tmp;\n\t\t\t\tbestDir = { i,j };\n\t\t\t}\n\t\t}\n\t\treturn bestDir;\n\t}\n\n\tld eval(ld x, ld y)\n\t{\n\t\tld res = INF;\n\t\tfor (auto ball : balls)\n\t\t{\n\t\t\tres = min(res, ball.score(x, y));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tStage stage;\n\t\tif (stage.is_end())break;\n\t\tstage.action();\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 10;\n  double ans=1;\n  double tans=800;\n\n  vector<double> app;\n  \n  rep(i,n)rep(j,i){\n    /*\n      dd=sqrt(dx*dx+dy*dy);\n      sqrt(r1*r1-x*x)+sqrt(r2*r2-x*x)=dd\n      sqrt(r1*r1-x*x)=dd-sqrt(r2*r2-x*x)\n      r1*r1-x*x=dd^2-2*dd*sqrt(r2*r2-x*x)+r2*r2-x*x\n      r1*r1=dd^2-2*dd*sqrt(r2*r2-x*x)+r2*r2\n      r1*r1-r2*r2-dd^2=-2*dd*sqrt(r2*r2-x*x)\n      (r1*r1-r2*r2-dd^2)^2=4*dd*dd*(r2*r2-x*x);\n      (r1*r1-r2*r2-dd^2)^2/4/dd/dd=(r2*r2-x*x);\n      x*x=(r2*r2-(r1*r1-r2*r2-dd^2)^2/4/dd/dd);      \n     */\n    \n    double dx=x[j]-x[i];\n    double dy=y[j]-y[i];\n    double dd=sqrt(dx*dx+dy*dy);\n    double xx=sqrt(l[j]*l[j]-pow(l[i]*l[i]-l[j]*l[j]-dd*dd,2)/4/dd/dd);\n    //app.pb();\n    double r1r = sqrt(l[i]*l[i]-xx*xx);\n    /*\n      r1c r1r xx    r2c\n     */\n    \n    double cx = x[i]+dx/dd*r1r;\n    double cy = y[i]+dy/dd*r1r;\n    ans=max(ans,get(cx,cy).F);\n    //if(dd >= l[i]+l[j]) continue;\n  }\n  \n  //if(n>1) ans=tans;\n  \n  while(len > 5e-9){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-2e-4;\n  }\n\n  // sort(ALL(app));\n  // if(!app.empty() && app[app.size()-1]>=ans){\n  //   double p=*lower_bound(ALL(app),ans);\n  //   if(ans+2e-4 > p) ans=p;\n  // }\n  \n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double eps = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=INF,y=INF;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n\nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P t , P p , double r){\n  //double r=radians(angle);\n  double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n  double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n  return P(ta , tb);\n}\n\nvoid interpoint_cc(P a , double ra , P b , double rb , P ans[]){\n  double di=fabs(dis(a-b));\n  if(di > ra+rb || di < fabs(ra-rb)) return;\n  double t=(ra*ra-rb*rb+di*di)/(di+di);\n  double rd=acos(t/ra);\n\n  P dv=unit_vector(b-a);\n  P g1=rotate(dv , P(0,0) , rd);\n  P g2=rotate(dv , P(0,0) , -rd);\n  ans[0]=a+g1*ra;\n  ans[1]=a+g2*ra;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<P> p(N);\n\tvector<double> ls(N);\n\tREP(i,N) cin >> p[i].x >> p[i].y >> ls[i];\n\n\tdouble lb = 0, ub = 300;\n\tREP(loop,100){\n\t  double h = (lb + ub) / 2.;\n\t  bool ok = true;\n\t  REP(i,N) if(ls[i] < h) ok = false;\n\n\t  if(ok){\n\t\tok = false;\n\t\tvector<double> ri(N);\n\t\tREP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n\t\tvector<P> chk;\n\t\tREP(i,N){\n\t\t  REP(j,N){\n\t\t\tif(dis(p[i]-p[j]) > ri[i]+ri[j] || dis(p[i]-p[j]) < fabs(ri[i]-ri[j])) continue;\n\t\t\tP icp[2];\n\t\t\tinterpoint_cc(p[i], ri[i], p[j], ri[j], icp);\n\t\t\tchk.PB(icp[0]);\n\t\t\tchk.PB(icp[1]);\n\t\t  }\n\t\t  chk.PB(p[i]);\n\t\t}\n\t\tfor(auto& pp: chk){\n\t\t  int cnt = 0;\n\t\t  REP(k,N){\n\t\t\tif(dis(p[k]-pp) <= ri[k])\n\t\t\t  ++cnt;\n\t\t  }\n\t\t  if(cnt == N) ok = true;\n\t\t}\n\t  }\n\n\t  if(ok) lb = h;\n\t  else ub = h;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double eps = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n \nstruct P{\n  double x;\n  double y;\n \n  P(){\n    x=INF,y=INF;\n  }\n \n  P(const double &s , const double &e)\n  { x=s; y=e;}\n \n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n \n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n \n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n \nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P t , P p , double r){\n  //double r=radians(angle);\n  double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n  double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n  return P(ta , tb);\n}\n \nvoid interpoint_cc(P a , double ra , P b , double rb , P ans[]){\n  double di=fabs(dis(a-b));\n  if(di > ra+rb || di < fabs(ra-rb)) return;\n  double t=(ra*ra-rb*rb+di*di)/(di+di);\n  double rd=acos(t/ra);\n \n  P dv=unit_vector(b-a);\n  P g1=rotate(dv , P(0,0) , rd);\n  P g2=rotate(dv , P(0,0) , -rd);\n  ans[0]=a+g1*ra;\n  ans[1]=a+g2*ra;\n}\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int N;\n  while(cin>>N,N){\n    vector<P> p(N);\n    vector<double> ls(N);\n    REP(i,N) cin >> p[i].x >> p[i].y >> ls[i];\n \n    double lb = 0, ub = 300;\n    REP(loop,100){\n      double h = (lb + ub) / 2.;\n      bool ok = true;\n      REP(i,N) if(ls[i] < h) ok = false;\n \n      if(ok){\n        ok = false;\n        vector<double> ri(N);\n        REP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n        vector<P> chk;\n        REP(i,N){\n          REP(j,N){\n            if(dis(p[i]-p[j]) > ri[i]+ri[j] || dis(p[i]-p[j]) < fabs(ri[i]-ri[j])) continue;\n            P icp[2];\n            interpoint_cc(p[i], ri[i], p[j], ri[j], icp);\n            chk.PB(icp[0]);\n            chk.PB(icp[1]);\n          }\n          chk.PB(p[i]);\n        }\n        for(auto& pp: chk){\n          int cnt = 0;\n          REP(k,N){\n            if(dis(p[k]-pp) <= ri[k]+eps)\n              ++cnt;\n          }\n          if(cnt == N) ok = true;\n        }\n      }\n \n      if(ok) lb = h;\n      else ub = h;\n    }\n    cout << fixed << setprecision(9) << lb << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=20;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h-EPS);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq*=conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b))res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {bl[i][0] - bl[j][0],bl[i][1] - bl[j][0],-bl[i][2] + bl[j][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ bl[i][0] - bl[k][0],bl[i][1] - bl[k][0],-bl[i][2] + bl[k][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1] == 0))continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[0][2] - 2 * a*x[0][1]) / 2 / x[0][1];\n\t\t\tc = bl[i][2] - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n\nconst double EPS = 1e-9;\ntypedef long double Real;\ntypedef complex<Real> Point;\n\ninline Real dot(const Point &a, const Point &b) {\n    return a.real() * a.real() + b.imag() * b.imag();\n}\n\nstruct Circle {\n    Point p;\n    Real r;\n    Circle(Point p = 0, Real r = 0) : p(p), r(r) {;}\n};\n\nstruct Line : public vector<Point> {\n    Line(Point a = 0, Point b = 0) {\n        push_back(a); push_back(b);\n    }\n};\n\nPoint projection(Line l, Point p) {\n    Real t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\n\nvector<Point> crosspointLC(Line l, const Circle &c){\n    vector<Point> res;\n    Point p = projection(l, c.p);\n    Real d = abs(p - c.p);\n    Real t = sqrt(c.r * c.r - d * d);\n    if(isnan(t)) return res;\n    Point v = (l[1] - l[0]) / abs(l[1] - l[0]);\n    res.push_back(p - v*t);\n    if(t > EPS) res.push_back(p + v*t);\n    return res;\n}\n\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2){\n    vector<Point> res;\n    Real d = abs(c1.p - c2.p);\n    if(max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) return res;\n    Real x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point p = c1.p + (c2.p - c1.p) / d * x;\n    Point v = (c1.p - c2.p) * Point(0.0, 1.0);\n    return crosspointLC(Line(p, p + v), c1);\n}\n\n\nint n;\nCircle cs[200];\n#define sq(x) ((x)*(x))\n\nbool isok(Point p, Real h){\n    rep(i,n) if(norm(p-cs[i].p) + sq(h) > sq(cs[i].r) + EPS) return false;\n    return true;\n}\n\nbool check(Circle c1, Circle c2, Real h) {\n    c1.r = sqrt(sq(c1.r) - sq(h));\n    c2.r = sqrt(sq(c2.r) - sq(h));\n    vector<Point> ps = crosspointCC(c1, c2);\n    for(auto p : ps) {\n        if(isok(p,h)) return true;\n    }\n    return false;\n}\n\nbool check(Real h){\n    rep(i,n){\n        if(isok(cs[i].p, h)) return true;\n        rep(j,n) if(check(cs[i], cs[j], h)) return true;\n    }\n    return false;\n}\n\nint main() {\n    while(cin >> n, n) {\n        rep(i, n) {\n            Real x,y,l;\n            cin >> x >> y >> l;\n            cs[i] = Circle(Point(x, y), l);\n        }\n        Real l = 1, r = 500;\n        rep(q,200) {\n            Real m = (l+r)/2;\n            if(check(m)) l = m; else r = m;\n        }\n        printf(\"%.06f\\n\", (double)l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n\tbool res = l > r;\n\tif (res) {\n\t\tl = r;\n\t}\n\treturn res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\ntypedef double D;\n\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef pair<P, D> C;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n\treturn a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n\treturn a.X*b.Y - a.Y*b.X;\n}\n\n\n\nstruct cww {\n\tcww() {\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\nIL D signed_distance_P_L(P p, LS l) {\n\tP a, b, c = p;\n\ttie(a, b) = l;\n\treturn cross(b - a, c - a) / abs(b - a);\n}\nIL D distance_P_LS(P p, LS ls) {\n\tP a, b, c = p;\n\ttie(a, b) = ls;\n\tif (dot(b - a, c - a) < EPS)return abs(c - a);\n\tif (dot(a - b, c - b) < EPS)return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nIL bool isintersected_LS_LS(LS p, LS q) {\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tif (abs(cross(b - a, d - c))<EPS) {\n\t\tif (abs(abs(b - c) + abs(a - c) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(b - d) + abs(a - d) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(a - c) + abs(a - d) - abs(c - d)) < EPS)return true;\n\t\tif (abs(abs(b - c) + abs(b - d) - abs(c - d)) < EPS)return true;\n\n\t\treturn false;\n\t}\n\treturn cross(b - a, c - a)*cross(b - a, d - a) < EPS && cross(d - c, a - c)*cross(d - c, b - c) < EPS;\n}\nIL D distance_LS_LS(LS p, LS q) {\n\tif (isintersected_LS_LS(p, q))return 0;\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tdouble e, f, g, h;\n\te = distance_P_LS(a, q);\n\tf = distance_P_LS(b, q);\n\tg = distance_P_LS(c, p);\n\th = distance_P_LS(d, p);\n\treturn min({ e,f,g,h });\n}\nP rot(P p, double r) {\n\treturn P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\n\nIL LS cross_C_C(C p, C q) {\n\tP cp, cq;\n\tD rp, rq;\n\ttie(cp, rp) = p;\n\ttie(cq, rq) = q;\n\tD d = abs(cp - cq);\n\tD rc = (d*d - rp*rp - rq*rq)/(2*d);\n\tD rs = sqrt(rp*rp - rc*rc);\n\tP diff = (cq - cp) / d;\n\treturn LS(cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff);\n}\n\nconst D PI = acos(-1);\ntypedef pair<double, int> pp;\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<P> xy(N);\n\t\tvector<D> len(N);\n\t\tREP(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y>>len[i];\n\t\t\txy[i] = P(x, y);\n\t\t}\n\t\tdouble lb = 0;\n\t\tdouble ub = 1e18;\n\t\tREP(loop, 100) {\n\t\t\tconst D mid = (lb + ub) / 2;\n\t\t\tvector<C> cir(N);\n\t\t\tbool flag = true;\n\t\t\tREP(i, N) {\n\t\t\t\tdouble l = len[i] * len[i] - mid*mid;\n\t\t\t\tif (l < 0) { flag = false; break; }\n\t\t\t\tcir[i] = C(xy[i], sqrt(l));\n\t\t\t}\n\t\t\tif (flag == false) {\n\t\t\t\tub = mid; continue;\n\t\t\t}\n\t\t\tvector<P> nobu;\n\t\t\tREP(i, N)REP(j, N)if(i!=j) {\n\t\t\t\tauto hiro = cross_C_C(cir[i], cir[j]);\n\t\t\t\tnobu.push_back(hiro.first);\n\t\t\t\tnobu.push_back(hiro.second);\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor (auto &p : nobu) {\n\t\t\t\tbool btk=true;\n\t\t\t\tREP(i, N) {\n\t\t\t\t\tauto d = abs(p - xy[i]);\n\t\t\t\t\tif (d*d + mid*mid>len[i] * len[i])\n\t\t\t\t\t\tbtk = false;\n\n\t\t\t\t}\n\n\t\t\t\tif (btk)flag = true;\n\t\t\t}\n\n\n\t\t\tif (flag)lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\n\nconst double EPS = 1e-8, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\ndouble dist(double x, double y, double z){\n\treturn sqrt(x*x + y*y+ z*z);\n}\nint n, l[10];\nP p[10];\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> p[i].real() >> p[i].imag() >> l[i];\n\t\t\n\t\tdouble ans = 0;\n\t\trep(i, n){\n\t\t\tbool ok = 1;\n\t\t\trep(j, n){\n\t\t\t\tif(dist(p[i].real() - p[j].real(), p[i].imag() - p[j].imag(), l[i]) > l[j] + EPS) ok = 0;\n\t\t\t}\n\t\t\tif(ok) ans = max(ans, (double)l[i]);\n\t\t}\n\t\t\n\t\trep(a, n) rep(b, n) rep(c, n) if(a != b){\n\t\t\tdouble t = arg(p[b] - p[a]);\n\t\t\tdouble x = (l[a] * l[a] - l[b] * l[b] + norm(p[b] - p[a])) / (2 * abs(p[b] - p[a]));\n\t\t\tdouble r = sqrt(l[a] * l[a] - x * x);\n\t\t\tP o = p[a] + (p[b] - p[a]) / abs(p[b] - p[a]) * x;\n\t\t\to *= P(cos(-t), sin(-t));\n\t\t\tP q = p[c] * P(cos(-t), sin(-t));\n\t\t\t\n\t\t\tdouble lo = 0, hi = PI / 2, mid;\n\t\t\trep(it, 100){\n\t\t\t\tmid = (lo + hi) / 2;\n\t\t\t\tdouble ty = o.imag() + r * cos(mid), tz = r * sin(mid);\n\t\t\t\tif(dist(q.real() - o.real(), q.imag() - ty, tz) > l[c]) hi = mid;\n\t\t\t\telse lo = mid;\n\t\t\t}\n\t\t\tdouble th = r * sin(mid);\n\t\t\tP tmp(o.real(), o.imag() + r * cos(mid));\n\t\t\ttmp *= P(cos(t), sin(t));\n\t\t\tbool ok = 1;\n\t\t\trep(i, n){\n\t\t\t\tif(dist(tmp.real() - p[i].real(), tmp.imag() - p[i].imag(), th) > l[i] + EPS) ok = 0;\n\t\t\t}\n\t\t\tif(ok) ans = max(ans, th);\n\t\t\t\n\t\t\tok = 1;\n\t\t\ttmp = p[a] + (p[b] - p[a]) / abs(p[b] - p[a]) * x;\n\t\t\trep(i, n){\n\t\t\t\tif(dist(tmp.real() - p[i].real(), tmp.imag() - p[i].imag(), r) > l[i] + EPS) ok = 0;\n\t\t\t}\n\t\t\tif(ok) ans = max(ans, r);\n\t\t\t\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n;\ndouble x[11], y[11], l[11];\n\ndouble sq(double a) {\n  return a*a;\n}\n\ndouble f(double _x, double _y) {\n  double res = 1e9;\n  rep(i, n) {\n    double h = sq(l[i]) - sq(_x-x[i]) - sq(_y-y[i]);\n    chmin(res, h);\n  }\n  return res;\n}\n\ndouble tsY(double _x) {\n  double l = -100.0, r = 100.0;\n  rep(i, 200) {\n    double c = (r - l) / 3;\n    double a = l + c, b = r - c;\n    if(f(_x, a) <= f(_x, b)) l = a;\n    else r = b;\n  }\n  return f(_x, l);\n}\n\ndouble tsX() {\n  double l = -100.0, r = 100.0;\n  rep(i, 200) {\n    double c = (r - l) / 3;\n    double a = l + c, b = r - c;\n    if(tsY(a) <= tsY(b)) l = a;\n    else r = b;\n  }\n  return tsY(l);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n, n) {\n    rep(i, n) cin >> x[i] >> y[i] >> l[i];\n    cout << sqrt(tsX()) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n#include<iostream>\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nint N;\nint X[10];\nint Y[10];\nint L[10];\n\nvoid crosspoint(vector<C> &ret, C p1, double r1, C p2, double r2) {\n\tdouble d = abs(p1 - p2);\n\n\tif(d > r1 + r2) return;\n\tif(r2 > d + r1 || r1 > d + r2) return;\n/*\n\tdouble x = p2.real() - p1.real();\n\tdouble y = p2.imag() - p1.imag();\n\tdouble a = (x*x + y*y * r1*r1 - r2*r2)/2;\n\n\tdouble rc = (d*d + r1*r1 - r2*r2) / (2*d);\n\tdouble rs = sqrt(r2*r2 - rc*rc);\n\tC diff = (p2 -p1) / d;\n\n\tret.push_back(p1 + diff * C(rc, rs));\n\tret.push_back(p1 + diff * C(rc, -rs));\n\n*/\n\n\tC a = conj(p2-p1);\n\tC b = (r2*r2-r1*r1-(p2-p1)*conj(p2-p1));\n\tC c = r1*r1*(p2-p1);\n\tC dd = b*b-4.0*a*c;\n\tC z1 = (-b+sqrt(dd))/(2.0*a)+p1;\n\tC z2 = (-b-sqrt(dd))/(2.0*b)+p1;\n\tret.push_back(z1);\n\tret.push_back(z2);\n}\n\nbool check(double h){\n\t//cout << \"---\" << h << \"---\" <<endl;\n\tdouble r[10];\n\tfor(int i = 0; i < N; i++){\n\t\tif(L[i] < h) return false;\n\t\tr[i] = sqrt(L[i] * L[i] - h * h);\n\t}\n\n\tvector<C> points;\n\tfor(int i = 0; i < N; i++){\n\t\tpoints.push_back(C(X[i], Y[i]));\n\t\tfor(int j = i + 1; j < N; j++){\n\t\t\tcrosspoint(points, C(X[i], Y[i]), r[i], C(X[j], Y[j]), r[j]);\n\t\t}\n\t}\n\n\tfor(auto p : points){\n\t\tbool flg = true;\n\t\t//cout << p << endl;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint xx = p.real() - X[i];\n\t\t\tint yy = p.imag() - Y[i];\n\t\t\tif(xx * xx + yy * yy > r[i] * r[i]){\n\t\t\t\t//cout << X[i] << \",\" << Y[i] << \",\" << r[i] << endl;\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flg) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(!N) break;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d %d\", &X[i], &Y[i], &L[i]);\n\t\t}\n\t\tdouble l = 0, r = 301;\n\t\tfor(int i = 0; i < 200; i++){\n\t\t\tdouble m = (l + r) / 2;\n\t\t\tif(check(m)) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%lf\\n\", l);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=INF,y=INF;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n\nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P t , P p , double r){\n  //double r=radians(angle);\n  double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n  double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n  return P(ta , tb);\n}\n\nvoid interpoint_cc(P a , double ra , P b , double rb , P ans[]){\n  double di=fabs(dis(a-b));\n  if(di > ra+rb || di < fabs(ra-rb)) return;\n  double t=(ra*ra-rb*rb+di*di)/(di+di);\n  double rd=acos(t/ra);\n\n  P dv=unit_vector(b-a);\n  P g1=rotate(dv , P(0,0) , rd);\n  P g2=rotate(dv , P(0,0) , -rd);\n  ans[0]=a+g1*ra;\n  ans[1]=a+g2*ra;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<P> p(N);\n\tvector<double> ls(N);\n\tREP(i,N) cin >> p[i].x >> p[i].y >> ls[i];\n\n\tdouble lb = 0, ub = 300;\n\tREP(loop,100){\n\t  double h = (lb + ub) / 2.;\n\t  bool ok = true;\n\t  REP(i,N) if(ls[i] < h) ok = false;\n\n\t  if(ok){\n\t\tok = false;\n\t\tvector<double> ri(N);\n\t\tREP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n\t\tvector<P> chk;\n\t\tREP(i,N){\n\t\t  REP(j,N){\n\t\t\tif(dis(p[i]-p[j]) > ri[i]+ri[j] || dis(p[i]-p[j]) < fabs(ri[i]-ri[j])) continue;\n\t\t\tP icp[2];\n\t\t\tinterpoint_cc(p[i], ri[i], p[j], ri[j], icp);\n\n\t\t\tP dirs[4] = {P(-EPS,0), P(EPS,0), P(0,-EPS), P(0,EPS)};\n\t\t\tREP(d,4){\n\t\t\t  chk.PB(icp[0] + dirs[d]);\n\t\t\t  chk.PB(icp[1] + dirs[d]);\n\t\t\t}\n\t\t  }\n\t\t  chk.PB(p[i]);\n\t\t}\n\t\tfor(auto& pp: chk){\n\t\t  int cnt = 0;\n\t\t  REP(k,N){\n\t\t\tif(dis(p[k]-pp) <= ri[k])\n\t\t\t  ++cnt;\n\t\t  }\n\t\t  if(cnt == N) ok = true;\n\t\t}\n\t  }\n\n\t  if(ok) lb = h;\n\t  else ub = h;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define EPS (1e-10)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P, double> Rope;\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nRope integrate2(Rope x, Rope y){\n  P s = x.first, t = y.first;\n  double a = x.second, b = y.second, c_square = norm(s-t);\n  if(c_square < EPS) return Rope(s,min(a,b));\n  double k = (a*a - b*b + c_square)/c_square/2.0;\n  P p = (1-k)*s + k*t;\n  double h_square = a*a - norm(p-s);\n  return Rope(p, sqrt(max(h_square,0.0)));\n}\n\nRope integrate3(Rope x, Rope y, Rope z){\n  //??????????????¬????????¨??????\n  P s = x.first, t = y.first, u = z.first;\n  double a = x.second, b = y.second, c = z.second;\n  if(norm(s-t) < EPS) return integrate2(z, Rope(s,min(a,b)));\n  if(norm(t-u) < EPS) return integrate2(x, Rope(t,min(b,c)));\n  if(norm(u-s) < EPS) return integrate2(y, Rope(u,min(c,a)));\n  double px = ((norm(t) - norm(s) + a*a - b*b)*(u.Y-s.Y) - (norm(u) - norm(s) + a*a - c*c)*(t.Y-s.Y)) / 2.0 / cross(t-s,u-s);\n  double py = ((norm(t) - norm(s) + a*a - b*b)*(u.X-s.X) - (norm(u) - norm(s) + a*a - c*c)*(t.X-s.X)) / 2.0 / cross(u-s,t-s);\n  P p = P(px, py);\n  double h_square = a*a - norm(p-s);\n  return Rope(p, sqrt(max(h_square, 0.0)));\n}\n\ndouble solve(vector<Rope> r){\n  int n = r.size();\n  double ret = -1;\n  for(int i = 0; i < n; ++i){\n    for(int j = i; j < n; ++j){\n      for(int k = j; k < n; ++k){\n\tRope x = integrate3(r[i], r[j], r[k]);//?????¬????????????????????¨??????\n\tdouble h = x.second;\n\tP p = x.first;\n\tbool f = true;\n\tfor(int l = 0; l < n; ++l){\n\t  if(h*h + norm(p-r[l].first) > r[l].second*r[l].second + EPS){\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f) ret = max(ret, h);\n      }\n    }\n  }\n  return ret;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<Rope> R(n);\n    double x, y, l;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y >> l;\n      R[i] = Rope(P(x,y),l);\n    }\n    printf(\"%.10lf\\n\", solve(R));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nint N;\nPoint p[10];\ndouble l[10],r[10];\nCircle c[10];\nbool f(int i,int j,int k)\n{\n\tif(intersect(c[i],c[j])==4)return false;\n\telse if(intersect(c[i],c[j])<=1)\n\t{\n\t\tif(intersect(c[i],c[k])==4||intersect(c[j],c[k])==4)return false;\n\t}\n\telse\n\t{\n\t\tpair<Point,Point>q=crosspoint(c[i],c[j]);\n\t\tif(!contain(c[k],q.first)&&!contain(c[k],q.second))return false;\n\t}\n\treturn true;\n}\nmain()\n{\n\twhile(cin>>N,N)\n\t{\n\t\tfor(int i=0;i<N;i++)cin>>p[i]>>l[i];\n\t\tdouble L=1,R=500;\n\t\tfor(int ccc=0;ccc<300;ccc++)\n\t\t{\n\t\t\tdouble h=(L+R)/2;\n\t\t\tbool flag=1;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(l[i]<h)\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr[i]=sqrt(l[i]*l[i]-h*h);\n\t\t\t\tc[i]=Circle(p[i],r[i]);\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tR=h;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(N>=3)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=i+1;j<N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=j+1;k<N;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!f(i,j,k)&&!f(j,k,i)&&!f(k,i,j))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(N==2)\n\t\t\t{\n\t\t\t\tif(intersect(c[0],c[1])==4)flag=0;\n\t\t\t}\n\t\t\tif(!flag)R=h;\n\t\t\telse L=h;\n\t\t}\n\t\tcout<<fixed<<setprecision(9)<<L<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\ndouble const EPS = 1e-9;\n\ntypedef double Real;\ntypedef complex<Real> P;\ntypedef vector<P> line;\n\nstruct circle {\n  P p; Real r;\n};\n\ndouble sq(double x) {\n  return x * x;\n}\n\nbool out(circle& a, circle& b) {\n  return abs(a.p - b.p) > a.r + b.r;// + EPS;\n}\n\nbool is_intersect(circle& a, circle& b) {\n  return abs(a.p - b.p) <= a.r + b.r && abs(a.p - b.p) + min(a.r, b.r) >= max(a.r, b.r);\n}\n\nbool contains(circle& a, circle& b) {\n  return abs(a.p - b.p) + min(a.r, b.r) < max(a.r, b.r);\n}\n\nbool contains(circle& c, P& p) {\n  return abs(c.p - p) <= c.r + EPS;\n}\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nbool is_parallel(line const& l, line const& m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\nP crosspoint(line const& l, line const& m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false && \"PRECONDITION NOT SATISFIED\");\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(circle c1, circle c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  Real const d = abs(c2.p - c1.p);\n  Real const alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  Real const beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n\nint N;\ndouble x[11], y[11], l[11];\n\nbool compare(double h) {\n  vector<circle> cs;\n  rep(i, N) {\n    if(l[i] < h - EPS) return false;\n    cs.push_back({{x[i], y[i]}, sqrt(sq(l[i]) - sq(h))});\n  }\n  rep(i, N) REP(j, i+1, N) {\n    if(out(cs[i], cs[j])) return false;\n  }\n\n  rep(i, N) REP(j, i+1, N) REP(k, j+1, N) {\n    if(contains(cs[i], cs[j]) || contains(cs[j], cs[k]) || contains(cs[k], cs[i])) continue;\n    auto p = crosspoint(cs[i], cs[j]);\n    auto q = crosspoint(cs[j], cs[k]);\n    auto r = crosspoint(cs[k], cs[i]);\n    if(!contains(cs[k], p.first) && !contains(cs[k], p.second) &&\n       !contains(cs[i], q.first) && !contains(cs[i], q.second) &&\n       !contains(cs[j], r.first) && !contains(cs[j], r.second)) return false;\n  }\n  \n  return true;\n}\n\ndouble solve() {\n  double l = 0.0, r = 1e10;\n  rep(_, 150) {\n    double m = (l + r) / 2.0;\n    (compare(m) ? l : r) = m;\n  }\n  return l;\n}\n\nint main() {\n\n  for(; cin >> N && N;) {\n    rep(i, N) {\n      cin >> x[i] >> y[i] >> l[i];\n    }\n    printf(\"%.10f\\n\", solve());\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LIMIT 45\nint n; long double x[100], y[100], l[100];\nlong double dst(long double ax, long double ay, long double az, long double bx, long double by, long double bz) {\n\treturn sqrtl((ax - bx)*(ax - bx) + (ay - by)*(ay - by) + (az - bz)*(az - bz));\n}\nlong double max_amari(long double ax, long double ay, long double az) {\n\tlong double maxn = 1000000000.0l;\n\tfor (int i = 0; i < n; i++) {\n\t\tmaxn = min(maxn, l[i] - dst(ax, ay, az, 0, x[i], y[i]));\n\t}\n\treturn maxn;\n}\nlong double solve2(long double h, long double X) {\n\tlong double L1 = -200.0l, R1 = 200.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = max_amari(h, X, c1);\n\t\tlong double m2 = max_amari(h, X, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\treturn maxn;\n}\nbool solve(long double h) {\n\tlong double L1 = -200.0l, R1 = 200.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = solve2(h, c1);\n\t\tlong double m2 = solve2(h, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\tif (maxn > -1e-14)return true;\n\treturn false;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> x[i] >> y[i] >> l[i];\n\t\tlong double L = 0.0l, R = 400.0l, M;\n\t\tfor (int i = 0; i < LIMIT; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tbool a1 = solve(M);\n\t\t\tif (a1 == true)L = M;\n\t\t\tif (a1 == false)R = M;\n\t\t}\n\t\tprintf(\"%.15Lf\\n\", M);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];\n        \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-8;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            int cnt=0;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>=dis) cnt++;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    \n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+EPS){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            if(cnt==(n*(n-1)/2)) able=true;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];\n        \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-10;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            int cnt=0;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>=dis) cnt++;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    \n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+EPS){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            if(cnt==(n*(n-1)/2)) able=true;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<setprecision(10)<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];       \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-10;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            int cnt=0;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>=dis) cnt++;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    \n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+1e-8){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            if(cnt==(n*(n-1)/2)) able=true;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<setprecision(10)<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\ndouble x[11],y[11],l[11];\n\nCircle circles[11];\nvector<Point> cands;\n\nbool inCircle(Circle c,Point p){//境界上でもtrue\n\tdouble d=pointsDistance(c.center,p);\n\tint s=sgn(d-c.r);\n\tif(s<=0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N;i++) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble lb=0;\n\t\tdouble ub=1000;\n\t\tfor(int i=0;i<N;i++) ub=min(ub,l[i]);\n\t\tfor(int stage=0;stage<100;stage++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircles[i]=Circle(Point(x[i],y[i]),sqrt(l[i]*l[i]-mid*mid));\n\t\t\t}\n\t\t\tcands.clear();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tvector<Point> tmp;\n\t\t\t\t\ttmp=circlesIntersection(circles[i],circles[j]);\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\tcands.push_back(tmp[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(cands.size()==0){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tcands.push_back(circles[i].center);\n\t\t\t\t}\n\t\t\t//}\n\t\t\tbool ok=false;\n\t\t\tfor(int i=0;i<cands.size();i++){\n\t\t\t\tbool flg=true;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(inCircle(circles[j],cands[i])==false) flg=false;\n\t\t\t\t}\n\t\t\t\tif(flg) ok=true;\n\t\t\t}\n\t\t\tif(ok) lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%f\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=50;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h-EPS);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq*=conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b))res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nvector<P> cross_circles(P c1,double r1,P c2,double r2){\n\tdouble d=abs(c2-c1);\n\tif(LT(r1+r2,d)||LT(d,fabs(r1-r2)))\n\t\treturn vector<P>();\n\tdouble l=0.5*((r1*r1-r2*r2)/d+d);\n\tdouble h=sqrt(r1*r1-l*l);\n\tvector<P> ret(2);\n\tret[0]=P(l,+h)*(c2-c1)/d+c1;\n\tret[1]=P(l,-h)*(c2-c1)/d+c1;\n\treturn ret;\n}\n\ndouble distance(double y1,double x1,double y2,double x2){\n\tdouble dy=y1-y2;\n\tdouble dx=x1-x2;\n\treturn sqrt(dy*dy+dx*dx);\n}\n\nbool ok(vi &y,vi &x,vi &l, double h){\n\tint n=y.size();\n\tvector<P> all_cross;\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(l[i]+EPS<h||l[j]+EPS<h){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdouble di=sqrt(l[i]*l[i]-h*h);\n\t\t\tdouble dj=sqrt(l[j]*l[j]-h*h);\n\t\t\tdouble dist2=distance(y[i],x[i],y[j],x[j]);\n\t\t\tbool intersected=di+dj+EPS>dist2;\n\t\t\tvector<P> cross=cross_circles(P(y[i],x[i]),di,P(y[j],x[j]),dj);\n\t\t\tif(cross.size()==0){\n\t\t\t\tif(!intersected){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tall_cross.push_back(cross[0]);\n\t\t\t\tall_cross.push_back(cross[1]);\n\t\t\t}\n\t\t}\n\t\tall_cross.push_back(P(y[i],x[i]));\n\t}\n\n\tREP(ci,all_cross.size()){\n\t\tbool ok=true;\n\t\tREP(k,n){\n\t\t\tdouble dk=sqrt(l[k]*l[k]-h*h);\n\t\t\tif(distance(y[k],x[k],all_cross[ci].real(),all_cross[ci].imag())>dk+EPS){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcout.precision(30);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n),y(n),l(n);\n\t\tint maxl=0;\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>l[i];\n\t\t\tmaxl=max(maxl,l[i]);\n\t\t}\n\n\t\tdouble lb=1,ub=maxl;\n\t\tREP(time,10000){\n\t\t\tdouble mid=(lb+ub)/2;\n\t\t\tif(!ok(y,x,l,mid)){\n\t\t\t\tub=mid;\n\t\t\t}else{\n\t\t\t\tlb=mid;\n\t\t\t}\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tint x[2][3] = { {bl[i][0] - bl[j][0],bl[i][1] - bl[j][0],-bl[i][2] + bl[j][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ bl[i][0] - bl[k][0],bl[i][1] - bl[k][0],-bl[i][2] + bl[k][2] + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1] == 0))continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[0][2] - 2 * a*x[0][1]) / 2 / x[0][1];\n\t\t\tc = bl[i][2] - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nvector<P> cross_circles(P c1,double r1,P c2,double r2){\n\tdouble d=abs(c2-c1);\n\tif(LT(r1+r2,d)||LT(d,fabs(r1-r2)))\n\t\treturn vector<P>();\n\tdouble l=0.5*((r1*r1-r2*r2)/d+d);\n\tdouble h=sqrt(r1*r1-l*l);\n\tvector<P> ret(2);\n\tret[0]=P(l,+h)*(c2-c1)/d+c1;\n\tret[1]=P(l,-h)*(c2-c1)/d+c1;\n\treturn ret;\n}\n\ndouble distance(double y1,double x1,double y2,double x2){\n\tdouble dy=y1-y2;\n\tdouble dx=x1-x2;\n\treturn sqrt(dy*dy+dx*dx);\n}\n\nbool ok(vi &y,vi &x,vi &l, double h){\n\tint n=y.size();\n\tvector<P> all_cross;\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(l[i]+EPS<h||l[j]+EPS<h){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdouble di=sqrt(l[i]*l[i]-h*h);\n\t\t\tdouble dj=sqrt(l[j]*l[j]-h*h);\n\t\t\tdouble dist2=distance(y[i],x[i],y[j],x[j]);\n\t\t\tbool intersected=di+dj+EPS>dist2;\n\t\t\tvector<P> cross=cross_circles(P(y[i],x[i]),di,P(y[j],x[j]),dj);\n\t\t\tif(cross.size()==0){\n\t\t\t\tif(!intersected){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tall_cross.push_back(cross[0]);\n\t\t\t\tall_cross.push_back(cross[1]);\n\t\t\t}\n\t\t}\n\t\tall_cross.push_back(P(y[i],x[i]));\n\t}\n\n\tREP(ci,all_cross.size()){\n\t\tbool ok=true;\n\t\tREP(k,n){\n\t\t\tdouble dk=sqrt(l[k]*l[k]-h*h);\n\t\t\tif(distance(y[k],x[k],all_cross[ci].real(),all_cross[ci].imag())>dk+EPS){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcout.precision(30);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n),y(n),l(n);\n\t\tint maxl=0;\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>l[i];\n\t\t\tmaxl=max(maxl,l[i]);\n\t\t}\n\n\t\tdouble lb=1,ub=maxl;\n\t\tREP(time,100000){\n\t\t\tdouble mid=(lb+ub)/2;\n\t\t\tif(!ok(y,x,l,mid)){\n\t\t\t\tub=mid;\n\t\t\t}else{\n\t\t\t\tlb=mid;\n\t\t\t}\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(x, p.x), add(y, p.y));\n  }\n  P operator - (P p) {\n    return P(add(x, -p.x), add(y, -p.y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  P operator / (double d) {\n    return P(x / d, y / d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p) {\n  //for (int i = 0; i < n; i++) printf(\"%f \",(add((p - dir[i]).square(), -r[i] * r[i])));\n  //printf(\"\\n\");\n  for (int i = 0; i < n; i++) if (0.000005 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) return false;//r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i], -h * h));\n  //  printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 / (l1 + l2) + dir[j] * l1 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d)) return true;\n        if (canClear(ave - d)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t])) return true;\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n    //printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n    //printf(\"%d\\n\",(int)check(13.02));\n//    printf(\"%d\\n\",(int)check(225.25));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%.7f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n// Library\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=IINF):p(p),r(r){}\n};\n\npair<Point, Point> intersectCC( Point C1, double r1, Point C2, double r2) {\n  complex<double> c1(C1.x,C1.y);\n  complex<double> c2(C2.x,C2.y);\n  complex<double> A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  complex<double> D = B*B-4.0*A*C;\n  complex<double> z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<Point, Point>(Point(z1.real(),z1.imag()),Point(z2.real(),z2.imag()));\n}\n\n\n\n// Library\n\nbool insideCC(Circle a,Circle b){\n  double d = sqrt(norm(a.p-b.p));\n  double r1 = max(a.r,b.r);\n  double r2 = min(a.r,b.r);\n \n  if(!equals(d,r1-r2) && d < r1-r2) return a.r < b.r; \n  return false;\n}\n\nbool insideCP(Circle c,Point p){\n  double dist = abs(c.p-p);\n  return equals(dist,c.r) || dist < c.r;\n}\n\nint n;\nPoint ps[11];\ndouble ls[11];\n\nbool check(double h){\n  vector<Circle> cs;\n  bool out[n];\n  rep(i,n) out[i] = false;\n\n  rep(i,n) {\n    if( equals(h,ls[i]) || h >= ls[i] ) return false;\n    rep(j,n){\n      if( i == j ) continue;\n      double r1 = sqrt( pow(ls[i],2) - pow(h,2) ), r2 = sqrt( pow(ls[j],2) - pow(h,2) );\n      if(insideCC((Circle){ps[i],r1},(Circle){ps[j],r2})) out[j] = true;\n    }\n  }\n\n  rep(i,n) if( !out[i] ) {\n    double r = sqrt( pow(ls[i],2) - pow(h,2) );\n    cs.push_back(Circle(ps[i],r));\n  }\n\n  assert(cs.size());\n  if( cs.size() == 1 ) return true;\n\n  vector<Point> cps;\n\n  rep(i,cs.size()) REP(j,i+1,cs.size()){\n    pair<Point,Point> pp = intersectCC(cs[i].p,cs[i].r,cs[j].p,cs[j].r);\n    cps.push_back(pp.first);    \n    cps.push_back(pp.second);\n  }\n\n  rep(i,cps.size()){\n    rep(j,cs.size()) if( !insideCP(cs[j],cps[i]) ) goto Skip;\n    return true;\n  Skip:;\n  }\n  return false;\n}\n\nint main(){\n  while( cin >> n, n ){\n    rep(i,n) cin >> ps[i].x >> ps[i].y >> ls[i];\n\n    double L = 0, R = 1e10;\n    rep(_,120){\n      double M = ( L + R ) * 0.5;\n      if( check(M) ) L = M;\n      else           R = M;\n    }\n    printf(\"%.7f\\n\",R);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x, y) ((x) - (y) <= -EPS)\n#define EQ(x, y) (abs((x)-(y)) < EPS)\n#define LE(x, y) ((x) - (y) < +EPS)\n\nvector<P> cross_circles(P c1, double r1, P c2, double r2){\n    double d=abs(c2-c1);\n    if ( LT(r1+r2, d) || LT(d, fabs(r1-r2)) )\n    return vector<P>();\n    double l = 0.5* ( (r1*r1-r2*r2)/d+d);\n    double h = sqrt(r1*r1-l*l);\n    vector<P> ret(2);\n    ret[0]=P(l,+h)*(c2-c1)/d+c1;\n    ret[1]=P(l,-h)*(c2-c1)/d+c1;\n    return ret;\n}\n\nstruct rope{\n\tint x,y,l;\n\trope(int x,int y,int l):x(x),y(y),l(l){}\n\tbool operator<(const rope& other)const{\n\t\treturn l<other.l;\n\t}\n};\n\ndouble dist(P p1, P p2){\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble get_height(vector<rope> ropes){\n\tsort(ALL(ropes));\n\tdouble lb=0,ub=1000;\n\tREP(c,100){\n\t\tdouble mid=(lb+ub)/2;\n\t\tvector<double> r;\n\t\tbool ok=true;\n\t\tREP(i,ropes.size()){\n\t\t\tdouble r_square=ropes[i].l*ropes[i].l-mid*mid;\n\t\t\tif(LE(r_square,0)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr.push_back(sqrt(ropes[i].l*ropes[i].l-mid*mid));\n\t\t}\n\t\tif(!ok){\n\t\t\tub=mid;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<P> itsc=cross_circles(P(ropes[0].x,ropes[0].y),r[0],P(ropes[1].x,ropes[1].y),r[1]);\n\t\tbool flag=false;\n\t\tif(ropes.size()==2){\n\t\t\tif(itsc.size()||LT(dist(P(ropes[0].x,ropes[0].y),P(ropes[1].x,ropes[1].y)),max(r[0],r[1]))){\n\t\t\t\tlb=mid;\n\t\t\t}else{\n\t\t\t\tub=mid;\n\t\t\t}\n\t\t}else{\n\t\t\tif(itsc.size()){\n\t\t\t\tREP(i,2){\n\t\t\t\t\tif(LT(dist(itsc[i],P(ropes[2].x,ropes[2].y)),r[2])){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tlb=mid;\n\t\t\t\t}else{\n\t\t\t\t\tub=mid;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tub=mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn LT(1,ub)?ub:INT_MAX;\n}\n\nint main(){\n\tcout.precision(16);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<rope> ropes;\n\t\tREP(i,n){\n\t\t\tint x,y,l;\n\t\t\tcin>>x>>y>>l;\n\t\t\tropes.push_back(rope(x,y,l));\n\t\t}\n\t\tdouble ans=INT_MAX;\n\t\tREP(i,n){\n\t\t\tans=min(ans,(double)ropes[i].l);\n\t\t}\n\t\tREP(bit,1<<n){\n\t\t\tvector<rope> av_ropes;\n\t\t\tREP(i,n){\n\t\t\t\tif(bit&(1<<i)){\n\t\t\t\t\tav_ropes.push_back(ropes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif(av_ropes.size()==2){\n\t\t\t\tans=min(ans,get_height(av_ropes));\n\t\t\t}else if(av_ropes.size()==3){\n\t\t\t\tans=min(ans,get_height(av_ropes));\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble EPS = 1e-9;\ntypedef complex<double> P,point;\n\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\n\nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nbool f(vector<C> b,double h){\n\tvector<P> cP;\n\tfor(int i = 0 ; i < b.size() ; i++){\n\t\tcP.push_back(b[i].p);\n\t}\n\tfor(int i = 0 ; i < b.size() ; i++){\n\t\tb[i].r = sqrt(b[i].r*b[i].r-h*h);\n\t}\n\tfor(int i = 0 ; i < b.size() ; i++){\n\t\tfor(int j = i+1 ; j < b.size() ; j++){\n\t\t\tauto tmp = C_cp(b[i],b[j]);\n\t\t\tcP.insert(cP.end(),tmp.begin(),tmp.end());\n\t\t}\n\t}\n\tfor(int i = 0 ; i < cP.size() ; i++){\n\t\tbool intersectAll = true;\n\t\tfor(int j = 0 ; j < b.size() ; j++){\n\t\t\tif( abs(b[j].p-cP[i]) > b[j].r + EPS){\n\t\t\t\tintersectAll = false;\n\t\t\t}\n\t\t}\n\t\tif(intersectAll) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> b(n);\n\t\tdouble l = 0, r = 1e9;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y,len;\n\t\t\tcin >> x >> y >> len;\n\t\t\tb[i].p = P(x,y);\n\t\t\tb[i].r = len;\n\t\t\tr = min(r,len);\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 128 ; i++){\n\t\t\tdouble m = (l+r) / 2;\n\t\t\tif( f(b,m) ) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",l);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  double d = abs(A.center() - B.center());\n  double rc = (d * d + A.radius() * A.radius() - B.radius() * B.radius()) / (2.0 * d);\n  double rs = sqrt(A.radius() * A.radius() - rc * rc);\n  Point diff = (B.center() - A.center()) / d;\n  ret.pb(A.center() + diff * Point(rc,  rs));\n  ret.pb(A.center() + diff * Point(rc, -rs));\n  return ret;\n}\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semieq(d, A.radius() + B.radius())) return  3;  // ?????\\\n  if(semige(d, A.radius() + B.radius())) return -3;  // ???????????????\n  return 4;  // ????????£?????????\n}\n\ninline bool operator < (Circle& A, Circle& B)\n{\n  return A.radius() != B.radius() ? A.radius() < B.radius() : A.center() < B.center();\n}\n\nconst int MAX_N = 12;\nint n;\ndouble x, y;\ndouble l[MAX_N];\nPoint p[MAX_N];\n\nbool C(double x)\n{\n  vector<Circle> c;\n  rep(i, n) c.pb(Circle(p[i], sqrt(l[i] * l[i] - x * x)));\n  rep(i, c.size()) rep(j, i){\n    Circle A = c[i];\n    Circle B = c[j];\n    int det = intersectionDeterminationOfCC(A, B);\n    if(det < 3) continue;\n    vector<Point> vp = intersectionOfCC(A, B);\n    vrep(v, vp){\n      bool ok = true;\n      vrep(w, c) ok &= !semige(abs(*v - w->center()), w->radius());\n      if(ok) return true;\n    }\n  }\n\n  vrep(v, c){\n    bool ok = true;\n    vrep(w, c) ok &= !semige(abs(v->center() - w->center()), w->radius());\n    if(ok) return true;\n  }\n\n  return false;\n}\n\nint main()\n{\n  int cnt = 0;\n  while(cin >> n, n){\n    double mn = (double)INF;\n    rep(i, n){\n      cin >> x >> y >> l[i];\n      p[i] = Point(x, y);\n      minup(mn, l[i]);\n    }\n\n    double left = 1.0;\n    double right = mn;\n    rep(_, 50){\n      double mid = (left + right) / 2.0;\n      if(C(mid)) left = mid;\n      else right = mid;\n    }\n\n    printf(\"%.15f\\n\", right);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n \nstruct Point{\n    double x, y;\n     \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n \n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n \n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n \n    bool operator < (const Point &p) const{\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n \n    bool operator == (const Point &p) const{\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n \ntypedef Point Vector;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n \ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n \nstruct Circle{\n    Point c;\n    double r;\n \n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n \ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n \ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n \ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n \nVector polar(double a, double r){\n    return Point(cos(r) * a, sin(r) * a);\n}\n \npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)  );\n}\n\nint n;\ndouble tmpp[15][3];\ndouble max_h;\nvector<double> p[15];\n\ndouble findans(double x,double y){\n    double st = 0.99,en = max_h+0.1;\n    while(en-st > 0.00000001){\n        double half = (st + en) / 2.0;\n        bool flag = true;\n        for(int i = 0;i < n;i++){\n            if( (half*half + (p[i][0]-x)*(p[i][0]-x) + (p[i][1]-y)*(p[i][1]-y)) > p[i][2]*p[i][2] ){\n                flag = false;\n                break;\n            }\n        }\n        if(flag) st = half;\n        else en = half;\n    }\n    return  st;\n}\n\n\nint main(){\n    while(true){\n        cin >> n;\n        if(n == 0)break;\n        max_h = 301;\n        bool ch[15];\n        for(int i = 0;i < n;i++){\n            p[i].clear();\n            ch[i] = true;\n            for(int j = 0;j < 3;j++){\n                cin >> tmpp[i][j];\n                if(j == 2)max_h=min(max_h,tmpp[i][j]);\n            }\n        }\n        int sum = 0;\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < n;j++){\n                if(ch[i] == false || ch[j] == false)continue;\n                if(i == j)continue;\n                if(tmpp[i][2] >= dist(tmpp[i][0],tmpp[i][1],tmpp[j][0],tmpp[j][1]) + tmpp[j][2]){\n                    sum++;\n                    ch[i] = false;\n                }\n            }\n        }\n        int count = 0;\n        for(int i = 0;i < n;i++){\n            if(ch[i] == false)continue;\n            for(int j = 0;j < 3;j++){\n                p[count].push_back(tmpp[i][j]);\n            }\n            count++;\n        }\n        n -= sum;\n    //    cout << \"n:\" << n << endl;\n        if(n == 1){\n            printf(\"%.7lf\\n\",p[0][2]);\n            continue;\n        }\n        if(n == 2){\n            Circle c1 = {Point(p[0][0], p[0][1]), p[0][2]};\n            Circle c2 = {Point(p[1][0], p[1][1]), p[1][2]};\n            pair<Point, Point> ansp = getCrossPoints(c1, c2);\n\n            Segment s1 = {Point(p[0][0], p[0][1]), Point(p[1][0], p[1][1])};\n            Segment s2 = {Point(ansp.first.x, ansp.first.y), Point(ansp.second.x, ansp.second.y)};\n            Point ansp2 = getCrossPoint(s1, s2);\n            double ans = findans(ansp2.x,ansp2.y);\n            for(int i = 0;i < 2;i++) ans = max(ans,findans(p[i][0],p[i][1]));\n            printf(\"%.7lf\\n\",ans);\n            continue;\n        }\n        vector<int> v;\n        for(int i = 0;i < n-3;i++)v.push_back(0);\n        for(int i = 0;i < 3;i++)v.push_back(1);\n        double tmp[4][4];\n        double ans = 0;\n        do{\n            int cnt = 0;\n            for(int i = 0;i < n;i++){\n                if(v[i] == 0)continue;\n                for(int j = 0;j < 3;j++)tmp[cnt][j] = p[i][j];\n                cnt++;\n            }\n            Circle c[3];\n            for(int i = 0;i < 3;i++) c[i] = {Point(tmp[i][0], tmp[i][1]), tmp[i][2]};\n            pair<Point, Point> ansp1 = getCrossPoints(c[0], c[1]);\n            pair<Point, Point> ansp2 = getCrossPoints(c[0], c[2]);\n            Segment s1 = {Point(ansp1.first.x, ansp1.first.y), Point(ansp1.second.x, ansp1.second.y)};\n            Segment s2 = {Point(ansp2.first.x, ansp2.first.y), Point(ansp2.second.x, ansp2.second.y)};\n            Point ansp3 = getCrossPoint(s1, s2);\n            ans = max(ans,findans(ansp3.x,ansp3.y));\n\n        }while(next_permutation(v.begin(),v.end()));\n        for(int i = 0;i < n;i++)ans = max(ans,findans(p[i][0],p[i][1]));\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < n;j++){\n                Circle c1 = {Point(p[i][0], p[i][1]), p[i][2]};\n                Circle c2 = {Point(p[j][0], p[j][1]), p[j][2]};\n                pair<Point, Point> ansp = getCrossPoints(c1, c2);\n\n                Segment s1 = {Point(p[i][0], p[i][1]), Point(p[j][0], p[j][1])};\n                Segment s2 = {Point(ansp.first.x, ansp.first.y), Point(ansp.second.x, ansp.second.y)};\n                Point ansp2 = getCrossPoint(s1, s2);\n                ans = max(ans,findans(ansp2.x,ansp2.y));                \n            }\n        }\n        printf(\"%.7lf\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ndouble data[10][3];\nint n;\n\nconst double EPS = 1e-9;\n#define EQ(a,b) (abs(a - b) < EPS)\n\nvoid rotate(double arr[], double rad)\n{\n\tdouble x, y;\n\tx = arr[0] * cos(rad) - arr[1] * sin(rad);\n\ty = arr[0] * sin(rad) + arr[1] * cos(rad);\n\tarr[0] = x, arr[1] = y;\n}\n\nbool checked[10];\n\nint main(void)\n{\n\twhile(scanf(\"%d\", &n), n)\n\t{\n\t\tdouble s = 1, e = 9999;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf %lf\", data[i], data[i] + 1, data[i] + 2);\n\t\t\te = min(e, data[i][2]);\n\t\t}\n\n\t\tfor(int q=0;q<100;q++)\n\t\t{\n\t\t\tdouble mid = (s + e) / 2;\n\t\t\tdouble r[10];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tdouble rad = acos(mid / data[i][2]);\n\t\t\t\tr[i] = data[i][2] * sin(rad);\n\t\t\t}\n\t\t\t\n\t\t\tbool isAble = false;\n\n\t\t\tvector <pair<double, double> > cand;\n\t\t\tfor(int i=0;i<n;i++) cand.push_back(make_pair(data[i][0], data[i][1]));\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=i+1;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble dist = hypot(data[i][0] - data[j][0], data[i][1] - data[j][1]);\n\t\t\t\t\tif(dist > r[i] + r[j]) continue;\n\t\t\t\t\tif(dist + min(r[i], r[j]) < max(r[i], r[j])) continue;\n\t\t\t\t\tdouble rad = acos((r[i] * r[i] + dist * dist - r[j] * r[j]) / 2 / r[i] / dist);\n\t\t\t\t\tdouble dir[2];\n\t\t\t\t\tdir[0] = data[j][0] - data[i][0], dir[1] = data[j][1] - data[i][1];\n\t\t\t\t\tdouble temp = hypot(dir[0], dir[1]);\n\t\t\t\t\tdir[0] /= temp, dir[1] /= temp;\n\t\t\t\t\tdouble cx = data[i][0] + dir[0] * r[i] * cos(rad);\n\t\t\t\t\tdouble cy = data[i][1] + dir[1] * r[i] * cos(rad);\n\t\t\t\t\trotate(dir, acos(-1.0) / 2);\n\t\t\t\t\tcand.push_back(make_pair(cx + dir[0] * r[i] * sin(rad), cy + dir[1] * r[i] * sin(rad)));\n\t\t\t\t\tcand.push_back(make_pair(cx - dir[0] * r[i] * sin(rad), cy - dir[1] * r[i] * sin(rad)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<cand.size();i++)\n\t\t\t{\n\t\t\t\tmemset(checked, 0, sizeof(checked));\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tdouble dist = hypot(cand[i].first - data[j][0], cand[i].second - data[j][1]);\n\t\t\t\t\tif(dist > r[j] && !EQ(dist, r[j])) { flag = false; break; }\n\t\t\t\t}\n\t\t\t\tif(flag) { isAble = true; break; }\n\t\t\t}\n\n\t\t\tif(isAble) s = mid;\n\t\t\telse e = mid;\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", s);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw({ bl[i][0],bl[i][1] }, { bl[j][0],bl[j][1] }, { a,b });\n\t\t\tif (cc != ccw({ bl[j][0],bl[j][1] }, { bl[k][0],bl[k][1] }, { a,b }) || cc != ccw({ bl[k][0],bl[k][1] }, { bl[i][0],bl[i][1] }, { a,b }))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double Real;\ntypedef complex<Real> Point;\ntypedef vector<Point> Polygon;\nstruct Line {\n\tLine(){}\n\tLine(Point p, Point q): p(p), q(q){}\n\tPoint p, q;\n};\ntypedef Line Segment;\nstruct Circle {\n\tCircle(){}\n\tCircle(Point p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\n#define X real\n#define Y imag\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-12;\n\ninline int sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\treturn a < 0.0 ? -1 : 1;\n}\n\ninline bool eq(Real a, Real b){ return sgn(a - b) == 0; }\ninline bool neq(Real a, Real b){ return sgn(a - b) != 0; }\ninline bool lt(Real a, Real b){ return sgn(a - b) == -1; }\ninline bool leq(Real a, Real b){ return sgn(a - b) <= 0; }\ninline bool gt(Real a, Real b){ return sgn(a - b) == 1; }\ninline bool geq(Real a, Real b){ return sgn(a - b) >= 0; }\n\nReal sq(Real a){ return a * a; }\n\nReal dot(Point a, Point b){ return X(conj(a) * b); }\nReal cross(Point a, Point b){ return Y(conj(a) * b); }\n\nbool orthogonal(Line l, Line m){\n\treturn sgn(dot(l.q - l.p, m.q - m.p)) == 0;\n}\n\nbool parallel(Line l, Line m){\n\treturn sgn(cross(l.q - l.p, m.q - m.p)) == 0;\n}\n\nPoint project(Line l, Point p){\n\tPoint t = l.q - l.p;\n\tReal r = dot(p - l.p, t) / norm(t);\n\treturn l.p + t * r;\n}\n\nPoint reflect(Line l, Point p){\n\treturn p + (project(l, p) - p) * Real(2.0);\n}\n\nint ccw(Point a, Point b, Point c){\n\tPoint u = b - a, v = c - a;\n\tif (sgn(cross(u, v)) == 1) return 1;\t\t// ccw\n\tif (sgn(cross(u, v)) == -1) return -1;\t// cw\n\tif (sgn(dot(a, b)) == -1) return 2;\t\t\t// back\n\tif (lt(norm(a), norm(b))) return -2;\t\t// front\n\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// on\n}\n\nbool intersectLL(Line l, Line m){\n\tif (!parallel(l, m)) return true;\n\treturn parallel(l, Line(l.p, m.p));\n}\n\nbool intersectLS(Line l, Segment s){\n\treturn sgn(cross(l.q - l.p, s.p - l.p)) * sgn(cross(l.q - l.p, s.q - l.p)) <= 0;\n}\n\nbool intersectLP(Line l, Point p){\n\treturn parallel(l, Line(l.p, p));\n}\n\nbool intersectSS(Segment s, Segment t){\n\treturn ccw(s.p, s.q, t.p) * ccw(s.p, s.q, t.q) <= 0\n\t\t&& ccw(t.p, t.q, s.p) * ccw(t.p, t.q, s.q) <= 0;\n}\n\nReal distanceLP(Line l, Point p){\n\treturn abs(cross(l.q - l.p, p - l.p) / abs(l.q - l.p));\n}\n\nReal distanceLL(Line l, Line m){\n\tif (intersectLL(l, m)) return 0.0;\n\treturn distanceLP(l, m.p);\n}\n\nReal distanceLS(Line l, Segment s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.p), distanceLP(l, s.q));\n}\n\nReal distanceSP(Segment s, Point p){\n\tif (sgn(dot(s.q - s.p, p - s.p)) <= 0) return abs(p - s.p);\n\tif (sgn(dot(s.p - s.q, p - s.q)) <= 0) return abs(p - s.q);\n\treturn distanceLP(s, p);\n}\n\nReal distanceSS(Segment s, Segment t){\n\tif (intersectSS(s, t)) return 0.0;\n\treturn min(\n\t\tmin(distanceSP(s, t.p), distanceSP(s, t.q)),\n\t\tmin(distanceSP(t, s.p), distanceSP(t, s.q))\n\t);\n}\n\nbool intersectCL(Circle c, Line l){\n\treturn leq(distanceLP(l, c.p), c.r);\n}\n\nbool intersectCS(Circle c, Segment s){\n\treturn leq(distanceSP(s, c.p), c.r);\n}\n\nbool intersectCP(Circle c, Point p){\n\treturn leq(norm(c.p - p), sq(c.r));\n}\n\nbool intersectCC(Circle c, Circle d){\n\treturn leq(norm(c.p - d.p), sq(c.r + d.r));\n}\n\npair<Point, Point> crossPointsCL(Circle c, Line l){\n\tPoint pr = project(l, c.p);\n\tPoint e = (l.q - l.p) / abs(l.q - l.p);\n\tReal t = sqrt(sq(c.r) - norm(pr - c.r));\n\treturn make_pair(pr + e * t, pr - e * t);\n}\n\npair<Point, Point> crossPointsCC(Circle c, Circle d){\n\tReal ds = abs(d.p - c.p);\n\tReal a = acos((sq(c.r) + sq(ds) - sq(d.r)) / (2 * c.r * ds));\n\tReal t = arg(d.p - c.p);\n\treturn make_pair(c.p + polar(c.r, t + a), c.p + polar(c.r, t - a));\n}\n\nbool contains(Circle c, Circle d){ // d in c\n\treturn leq(c.r + abs(c.p - d.p), d.r);\n}\n\nint n;\nReal x[10], y[10], l[10];\n\nbool ok(Real h)\n{\n\tCircle c[10];\n\tfor (int i = 0; i < n; i++){\n\t\tReal r = sqrt(sq(l[i]) - sq(h));\n\t\tc[i] = Circle(Point(x[i], y[i]), r);\n\t}\n\n\tvector<Point> cps;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (!intersectCC(c[i], c[j])) return false;\n\t\t\tif (contains(c[i], c[j])) continue;\n\t\t\tauto cp = crossPointsCC(c[i], c[j]);\n\t\t\tcps.push_back(cp.first);\n\t\t\tcps.push_back(cp.second);\n\t\t}\n\t}\n\t\n\tif (cps.empty()) return true;\n\n\tfor (auto cp : cps){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (!intersectCP(c[i], cp)) f = false;\n\t\t}\n\t\tif (f) return true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t}\n\t\tReal lb = 0.0, ub = *min_element(l, l + n);\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tReal md = (lb + ub) / 2;\n\t\t\t(ok(md) ? lb : ub) = md;\n\t\t}\n\t\tcout << fixed << setprecision(20) << lb << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tarray<double, 3>minp;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\trep(i, 3)minp[i] = bl[mina][i];\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\t//h.push_back({ a,b,c });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c*c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, c);\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2] )/l+l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tz = sqrt(z);\n\t\t\t//h.push_back({ x,y,z });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((x - bl[i][0])*(x - bl[i][0]) + (y - bl[i][1])*(y - bl[i][1]) + z*z > bl[i][2] * bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, z);\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\n#define double float\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nint sign(double x) {\n    if(x > EPS) return 1;\n    if(x < -EPS) return -1;\n    return 0;\n}\nstruct C{\n    P p;\n    double r;\n};\nvector<P> pCC(C a, C b) {\n    vector<P> res;\n\n    double d = abs(b.p - a.p);\n    double l1 = abs(a.r - b.r);\n    double l2 = a.r + b.r; \n\n    if(sign(d) == 0 && sign(l1) == 0) assert(false); // 円が等しい\n    if(sign(d - l1) < 0 || sign(d - l2) > 0) return res; // 交わらない\n\n    double th1 = arg(b.p - a.p);\n\n    if(sign(d - l1) == 0 || sign(d - l2) == 0) { // 一点で交わる\n        res.push_back(a.p + polar(a.r, th1));\n    } else { // 二点で交わる\n        double th2 = acos( (a.r * a.r - b.r * b.r + d * d) / (2 * a.r * d) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n\n    return res;\n}\n\nint main() {\n    int n;\n    while(cin >> n && n > 0) {\n        vector<P> ps(n);\n        vector<double> l(n);\n        REP(i, n) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n            cin >> l[i];\n        }\n        double lb = 0, ub = *min_element(l.begin(), l.end());\n        REP(_, 60) {\n            double h = (lb + ub) / 2;\n            vector<C> cs(n);\n            REP(i, n) {\n                double r = sqrt(l[i] * l[i] - h * h);\n                cs[i] = {ps[i], r};\n            }\n            vector<P> cand = ps;\n            REP(i, n) REP(j, n) if(i != j) {\n                for(auto p : pCC(cs[i], cs[j])){\n                    cand.push_back(p);\n                }\n            }\n            bool ok = false;\n            for(auto p : cand) {\n                int cnt = 0;\n                REP(i, n) {\n                    double d = abs(cs[i].p - p);\n                    if(sign(d - cs[i].r) <= 0) {\n                        cnt++;\n                    }\n                }\n                if(cnt == n) ok = true;\n            }\n            if(ok) {\n                lb = h;\n            } else {\n                ub = h;\n            }\n        }\n        printf(\"%.12f\\n\", lb);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1]) == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t\tif (c<13.03&&c>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t\tif (z<13.03&&z>13.01) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nint N;\nP p[10];\nD len[10];\nD eps=1e-9;\nint large(D x,D y){\n\tif(abs(x-y)<eps) return 0;\n\tif(x>y) return 1;\n\treturn -1;\n}\nPol intCC(C a,C b){\n\tint x=large(abs(a.p-b.p),a.r+b.r);\n\tPol ret;\n\tif(x==1) return ret;\n\tif(x==0){\n\t\tret.pb((a.r*b.p+a.p*b.r)/(a.r+b.r));\n\t\treturn ret;\n\t}\n\tD d=abs(a.p-b.p);\n\tD theta=acos((a.r*a.r+d*d-b.r*b.r)/(2.0*a.r*d));\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,theta));\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,-theta));\n\treturn ret;\n}\nbool AinB(C a,C b){\t\t//true if touch\n\treturn abs(a.p-b.p)+a.r<b.r+eps;\n}\nbool can(D h){\n\trep(i,N){\n\t\tif(h>len[i]) return 0;\n\t}\n\tC c[10];\n\trep(i,N) c[i].r=sqrt(len[i]*len[i]-h*h),c[i].p=p[i];\n\tbool iran[10]={};\n\trep(i,N) rep(j,N) if(i!=j){\n\t\tif(AinB(c[i],c[j])) iran[j]=true;\n\t}\n\tvector<C> cs;\n\trep(i,N) if(!iran[i]) cs.pb(c[i]);\n\tif(cs.size()==1) return 1;\n\trep(i,cs.size()) rep(j,i){\n\t\tPol ps=intCC(cs[i],cs[j]);\n\t\tfor(P q:ps){\n\t\t\tbool can=true;\n\t\t\trep(k,cs.size()){\n\t\t\t\tif(cs[k].r+eps<abs(cs[k].p-q)) can=0;\n\t\t\t}\n\t\t\tif(can) return true;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y>>len[i];\n\t\t\tp[i]=P(x,y);\n\t\t}\n\t\tD ub=300,lb=1;\n\t\twhile(ub-lb>1e-7){\n\t\t\tD m=(ub+lb)/2;\n\t\t\tif(can(m)) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tprintf(\"%.7f\\n\",ub);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<complex>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int INF = 1000000000;\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\n\nclass Line{\n\tpublic:\n\tdouble A,B,C;\n\tLine(double A,double B,double C):A(A),B(B),C(C){}\n\tLine(){}\n};\nclass Circle : public Point{\n\tpublic:\n\tdouble R;\n\tCircle(Point pt, double R):Point(pt),R(R){}\n\tCircle(){}\n};\n\n\ndouble Dot(Point p1, Point p2){return p1.X*p2.X + p1.Y*p2.Y;}\ndouble Cross(Point p1, Point p2){return p1.X*p2.Y - p1.Y*p2.X;}\n\nbool ccw(Point p1, Point p2, Point p3){return  Cross(p2-p1, p3-p1)>=0;}\n\npair<Point,Point> Suisen(Line line, Point pt){\n\tPoint v(line.A, line.B);  v/=Point(abs(v),0);\n\tPoint toPoint;\n\t\n\tif(line.B!=0){\n\t\tPoint slide = pt-Point(0, -line.C/line.B);\n\t\ttoPoint = v*Point(Dot(v,slide),0);\n\t}else{\n\t\ttoPoint = Point(pt.X + line.C/line.A, 0);\n\t}\n\treturn pair<Point,Point>(pt-toPoint, toPoint); //場所と方向\n}\nbool CircleHit(Circle a, Circle b){return abs(a-b) <= a.R + b.R;}\nLine CircleCommonLine(Circle a,Circle b){\n\tdouble C = pow(b.R, 2)-pow(a.R, 2)+norm(a)-norm(b);\n\treturn Line(2*(b.X-a.X), 2*(b.Y-a.Y), C);\n}\npair<Point,Point> CircleCross(Circle a, Circle b){\n\tLine commonLine = CircleCommonLine(a,b);\n\tpair<Point,Point> s = Suisen(commonLine, a);\n\t\n\tdouble d = abs(s.second);\n\tif(d!=0){\n\t\tPoint e = s.second*Point(0,1)/d;\n\t\tif(a.R<d)d=a.R;\n\t\tdouble dist = sqrt(a.R*a.R - d*d);\n\t\treturn pair<Point,Point>(s.first+e*Point(dist,0), s.first+e*Point(-dist,0));\n\t}\n\treturn pair<Point,Point>(s.first-Point(0,a.R), s.first+Point(0,a.R));\n}\n\n\nconst int N = 11;\n\nint n;\nCircle cir[N];\nCircle cirnext[N];\n\nbool checknext(){\n\tvector<Point> pt;\n\trep(i,n)pt.push_back(cirnext[i]);\n\t/*\n\trep(i,n){\n\t\tcout<<cirnext[i]<<cirnext[i].R<<\" \";\n\t}puts(\"\");\n\t*/\n\trep(i,n){\n\t\treps(j,i+1,n){\n\t\t\tif(!CircleHit(cirnext[i],cirnext[j]))continue;\n\t\t\tpair<Point,Point> cross = CircleCross(cirnext[i],cirnext[j]);\n\t\t\tpt.push_back(cross.first);\n\t\t\tpt.push_back(cross.second);\n\t\t}\n\t}\n\t\n\tconst double EPS_IN = 0.00000001;\n\tbool has = false;\n\trep(i,pt.size()){\n\t\tbool ok = true;\n\t\trep(j,n){\n\t\t\tif(abs(pt[i]-cirnext[j]) > cirnext[j].R+EPS_IN)ok=false;\n\t\t}\n\t\tif(ok)has=true;\n\t}\n\t\n\treturn has;\n}\n\nbool check(double val){\n\tbool ret = true;\n\trep(i,n){\n\t\tif(val>cir[i].R)return false;\n\t\tdouble theta = asin(val/cir[i].R);\n\t\tdouble len = cir[i].R * cos(theta);\n\t\tcirnext[i]=Circle(cir[i], len);\n\t}\n\tret &= checknext();\n\treturn ret;\n}\n\n\ndouble solve(){\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcir[i] = Circle(Point(a,b),c);\n\t}\n\t\n\tdouble left = 0;\n\tdouble right = INF;\n\tconst double EPS_BS = 0.0000001;\n\t\n\twhile(1){\n\t\tdouble half = (left+right)/2;\n\t\t\n\t\tif(check(half)){\n\t\t\tleft = half;\n\t\t}else{\n\t\t\tright = half;\n\t\t}\n\t\tif(left+EPS_BS>right)break;\n\t}\n\t\n\treturn left;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n#define EPS 1e-9\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat& A,const vec& b){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tB[i][j]=A[i][j];\n\t\t}\n\t\tB[i][n]=b[i];\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tint piv=0;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[piv][i]))piv=j;\n\t\t}\n\t\tswap(B[i],B[piv]);\n\t\tif(abs(B[i][i])<EPS)return vec();\n\t\tfor(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tvec x(n);\n\tfor(int i=0;i<n;i++)x[i]=B[i][n];\n\treturn x;\n}\n\nint n;\ndouble x[11],y[11],l[11];\n\nbool judge(double xx,double yy,double zz){\n\tbool ok=true;\n\trep(i,n){\n\t\tif(pow(xx-x[i],2)+pow(yy-y[i],2)+pow(zz,2)-pow(l[i],2)>EPS)ok=false;\n\t}\n\treturn ok;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n)cin>>x[i]>>y[i]>>l[i];\n\t\tdouble res=0;\n\t\t{ /// 1\n\t\t\trep(i,n){\n\t\t\t\tif(judge(x[i],y[i],l[i])){\n\t\t\t\t\tmaxch(res,l[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//dbg(res);\n\t\t{ /// 2\n\t\t\trep(i,n)rep(j,i){\n\t\t\t\tif(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)-pow(l[i]+l[j],2)>EPS)continue;\n\t\t\t\t//dbg(i);dbg(j);\n\t\t\t\tdouble d=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2));\n\t\t\t\t//dbg(d);\n\t\t\t\tdouble xx=(l[i]*l[i]-l[j]*l[j]+d*d)/(2*d);\n\t\t\t\t//dbg(xx);\n\t\t\t\tdouble vx=(xx/d)*x[j]+((d-xx)/d)*x[i];\n\t\t\t\tdouble vy=(xx/d)*y[j]+((d-xx)/d)*y[i];\n\t\t\t\tdouble vz=sqrt(l[i]*l[i]-xx*xx);\n\t\t\t\tif(judge(vx,vy,vz)){\n\t\t\t\t\tmaxch(res,vz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//dbg(res);\n\t\t{ /// 3\n\t\t\trep(i,n)rep(j,i)rep(k,j){\n\t\t\t\tmat A(2,vec(2));\n\t\t\t\tvec b(2);\n\t\t\t\tA[0][0]=2*(x[j]-x[i]); A[0][1]=2*(y[j]-y[i]);\n\t\t\t\tA[1][0]=2*(x[k]-x[i]); A[1][1]=2*(y[k]-y[i]);\n\t\t\t\tb[0]=l[i]*l[i]-l[j]*l[j]-(x[i]+x[j])*(x[i]-x[j])-(y[i]+y[j])*(y[i]-y[j]);\n\t\t\t\tb[1]=l[i]*l[i]-l[k]*l[k]-(x[i]+x[k])*(x[i]-x[k])-(y[i]+y[k])*(y[i]-y[k]);\n\t\t\t\tvec X=gauss_jordan(A,b);\n\t\t\t\t//dbg(X.size());\n\t\t\t\tif(X.size()!=2)continue;\n\t\t\t\telse{\n\t\t\t\t\tdouble vx=X[0], vy=X[1];\n\t\t\t\t\tdouble vz=sqrt(l[i]*l[i]-pow(vx-x[i],2)-pow(vy-y[i],2));\n\t\t\t\t\t//dbg(vz);\n\t\t\t\t\tif(judge(vx,vy,vz)){\n\t\t\t\t\t\tmaxch(res,vz);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(p.x, x), add(p.y, y));\n  }\n  P operator - (P p) {\n    return P(add(p.x, -x), add(p.y, -y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  //printf(\"%d:%d,%f,%f,%f\\n\",i,j,s,r[i],r[j]);\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p) {\n  //for (int i = 0; i < n; i++) if (ESP < (add((p - dir[i]).square(), -r[i] * r[i])) && 0.1 > (add((p - dir[i]).square(), -r[i] * r[i]))) printf(\"%d,%f]]]\\n\",i,(add((p - dir[i]).square(), -r[i] * r[i])));\n  for (int i = 0; i < n; i++) if (0.00001 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i],-h * h));\n    //printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      //printf(\"t:%d\\n\",t);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 + dir[j] * l1) * (1.0 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d)) return true;\n        if (canClear(ave - d)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t])) return true;\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n    //printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n    //printf(\"%d\\n\",(int)check(72.2251798));\n    //printf(\"%d\\n\",(int)check(71.954102));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p(n);\n    double ll[n];\n    for(int i=0;i<n;i++) cin>>p[i].x>>p[i].y>>ll[i];\n    double l=0,r=400;\n    for(int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      bool f=1;\n      Circle c[n];\n      for(int j=0;j<n;j++){\n\tif(m>ll[j]){\n\t  f=0;\n\t  break;\n\t}\n\tc[j]=Circle(p[j],sqrt(ll[j]*ll[j]-m*m));\n      }\n      \n      for(int j=0;j<n;j++)\n\tfor(int k=j+1;k<n;k++)\n\t  f&=abs(c[j].c-c[k].c)<=(c[j].r+c[k].r);\n\n      //*\n      for(int j=0;j<n;j++){\n\tfor(int k=j+1;k<n;k++){\n\t  for(int a=k+1;a<n;a++){\n\t    bool ff=0;\n\t    pair<Point,Point> pp;\n\t    pp=getCrossPoints(c[j],c[k]);\n\t    ff|=abs(c[a].c-pp.first)<=c[a].r;\n\t    ff|=abs(c[a].c-pp.second)<=c[a].r;\n\t    pp=getCrossPoints(c[k],c[a]);\n\t    ff|=abs(c[j].c-pp.first)<=c[j].r;\n\t    ff|=abs(c[j].c-pp.second)<=c[j].r;\n\t    pp=getCrossPoints(c[a],c[j]);\n\t    ff|=abs(c[k].c-pp.first)<=c[k].r;\n\t    ff|=abs(c[k].c-pp.second)<=c[k].r;\n\t    //if(!ff) cout<<j<<\" \"<<k<<\" \"<<a<<endl;\n\t    ff|=abs(c[j].c-c[k].c)+c[j].r<c[k].r;\n\t    ff|=abs(c[j].c-c[k].c)+c[k].r<c[j].r;\n\t    ff|=abs(c[k].c-c[a].c)+c[k].r<c[a].r;\n\t    ff|=abs(c[k].c-c[a].c)+c[a].r<c[k].r;\n\t    ff|=abs(c[a].c-c[j].c)+c[a].r<c[j].r;\n\t    ff|=abs(c[a].c-c[j].c)+c[j].r<c[a].r;\n\t    f&=ff;\n\t  }\n\t}\n      }\t \n      //*/\n      \n      if(f) l=m;\n      else r=m;\n    }\n    printf(\"%.12lf\\n\",l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<float, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt(double(bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// dot of a and b\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// cross of a and b\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nstruct Sphere{\n    ld x,y,l;\n    Sphere(ld x, ld y, ld l):x(x),y(y),l(l){}\n};\n\nbool check(const vector<Circle> &c){\n    bool f=false;\n    int sz=c.size();\n    vector<Point> res;\n    for(int i=0;i<sz;i++){\n        for(int j=i+1;j<sz;j++){\n            res=is_cc(c[i],c[j]);\n            for(int k=0;k<(int)res.size();k++){\n                bool ftmp=true;\n                for(int t=0;t<sz;t++){\n                    if(abs(c[t].p-res[k])<c[t].r+eps){\n                        continue;\n                    }\n                    ftmp=false;\n                }\n                if(ftmp) f=true; \n            }\n        }\n    }\n    for(int i=0;i<sz;i++){\n        bool ftmp=true;\n        for(int j=0;j<sz;j++){\n            if(abs(c[i].p-c[j].p)<c[j].r+eps) continue;\n            ftmp=false;\n        }\n        if(ftmp) f=true; \n    }\n    return f;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Sphere> s;\n        ld low=0,high=114514;\n        for(int i=0;i<n;i++){\n            ld x,y,l;cin>>x>>y>>l;\n            s.push_back(Sphere(x,y,l));\n            high=min(high,l);\n        }\n        for(int i=0;i<100;i++){\n            vector<Circle> c;\n            ld mid=(low+high)/2;\n            for(int j=0;j<n;j++){\n                ld x=s[j].x,y=s[j].y,l=s[j].l;\n                c.push_back(Circle(Point(x,y),sqrt(l*l-mid*mid)));\n            }\n            if(check(c)) low=mid;\n            else high=mid;\n        }\n        cout<<fixed<<setprecision(10)<<low<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  double d = abs(A.center() - B.center());\n  double rc = (d * d + A.radius() * A.radius() - B.radius() * B.radius()) / (2.0 * d);\n  double rs = sqrt(A.radius() * A.radius() - rc * rc);\n  Point diff = (B.center() - A.center()) / d;\n  ret.pb(A.center() + diff * Point(rc,  rs));\n  ret.pb(A.center() + diff * Point(rc, -rs));\n  return ret;\n}\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semieq(d, A.radius() + B.radius())) return  3;  // ?????\\\n  if(semige(d, A.radius() + B.radius())) return -3;  // ???????????????\n  return 4;  // ????????£?????????\n}\n\ninline bool operator < (Circle& A, Circle& B)\n{\n  return A.radius() != B.radius() ? A.radius() < B.radius() : A.center() < B.center();\n}\n\nconst int MAX_N = 12;\nint n;\ndouble x, y;\ndouble l[MAX_N];\nPoint p[MAX_N];\n\nbool C(double x)\n{\n  vector<Circle> c;\n  rep(i, n) c.pb(Circle(p[i], sqrt(l[i] * l[i] - x * x)));\n  rep(i, c.size()) rep(j, i){\n    Circle A = c[i];\n    Circle B = c[j];\n    int det = intersectionDeterminationOfCC(A, B);\n    if(det < 3) continue;\n    vector<Point> vp = intersectionOfCC(A, B);\n    vrep(v, vp){\n      bool ok = true;\n      vrep(w, c) ok &= !semige(abs(*v - w->center()), w->radius());\n      if(ok) return true;\n    }\n  }\n\n  sort(ALL(c));\n  bool ok = true;\n  rep(i, n-1){\n      int det = intersectionDeterminationOfCC(c[i], c[i+1]);\n      ok &= (det == -1 || det == -2);\n  }\n  if(ok) return true;\n\n  vrep(v, c){\n    bool ok = true;\n    vrep(w, c) ok &= !semige(abs(v->center() - w->center()), w->radius());\n    if(ok) return true;\n  }\n\n  return false;\n}\n\nint main()\n{\n  int cnt = 0;\n  while(cin >> n, n){\n    double mn = (double)INF;\n    rep(i, n){\n      cin >> x >> y >> l[i];\n      p[i] = Point(x, y);\n      minup(mn, l[i]);\n    }\n\n    double left = 1.0;\n    double right = mn;\n    rep(_, 100){\n      double mid = (left + right) / 2.0;\n      if(C(mid)) left = mid;\n      else right = mid;\n    }\n\n    printf(\"%.15f\\n\", right);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Complex;\n\nconst double EPS = 1e-10, PI = M_PI;\nll N;\nComplex P[10];\ndouble L[10];\n\nbool check(Complex p, vector<double> r) {\n  bool ret = true;\n  REP(i, 0, N) ret = ret && abs(p - P[i]) < r[i] + EPS;\n  return ret;\n}\n\nbool ok(double h) {\n  vector<double> r(N);\n  REP(i, 0, N) {\n    if(h > L[i]) return false;\n    r[i] = sqrt(L[i] * L[i] - h * h);\n  }\n\n  REP(i, 0, N) if(check(P[i], r)) return true;\n\n  REP(i, 0, N) REP(j, i + 1, N) {\n    Complex p1 = P[i], p2 = P[j];\n    double r1 = r[i], r2 = r[j];\n\n    if(abs(p2 - p1) > r1 + r2) continue;\n    if(abs(p2 - p1) < abs(r2 - r1)) continue;\n\n    double d = abs(p2 - p1);\n    double t = abs((d * d + r1 * r1 - r2 * r2) / (d * 2));\n    double h = sqrt(r1 * r1 - t * t);\n\n    Complex u = (p2 - p1) / d;\n    Complex v = u * Complex(0, 1);\n    Complex q1 = p1 + u * t - v * h;\n    Complex q2 = p1 + u * t + v * h;\n\n    if(check(q1, r)) return true;\n    if(check(q2, r)) return true;\n  }\n\n  return false;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) {\n      double x, y;\n      cin >> x >> y >> L[i];\n      P[i] = Complex(x, y);\n    }\n\n    double l = 1, h = 1e5;\n    REP(_, 0, 100) {\n      double m = (l + h) / 2;\n      if(ok(m)) l = m; else h = m;\n    }\n    printf(\"%.15lf\\n\", l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m))continue;\n      if(dist+in[j].R(m)<=in[i].R(m))continue;\n\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return false;\n}\n\ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return m;\n  if(judge(m)){\n    return req(m,r);\n  }else{\n    return req(l,m);\n  }\n}\n\ndouble solve(){\n  double ans = req(1.0,400.0);\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\nusing ld = long double;\n\nstruct Balloon {\n\tld x, y, l;\n\n\tld score(ld x2, ld y2)const {\n\t\tld d_2 = pow(x - x2, 2) + pow(y - y2, 2);\n\t\treturn pow(l, 2) - d_2;\n\t}\n};\n\nstruct Stage {\n\tStage() \n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tREP(i, n)\n\t\t{\n\t\t\tBalloon ball;\n\t\t\tcin >> ball.x >> ball.y >> ball.l;\n\t\t\tballs.push_back(ball);\n\t\t}\n\t}\n\n\tbool is_end() \n\t{\n\t\treturn balls.empty();\n\t}\n\t\n\tvoid action()\n\t{\n\t\tld x = 0;\n\t\tld y = 0;\n\t\tld step = 1;\n\n\t\twhile (step > 1e-12) {\n\t\t\tauto dir = select_dir(x, y, step);\n\t\t\tx += step * dir.first;\n\t\t\ty += step * dir.second;\n\t\t\tstep /= 10.0;\n\t\t}\n\t\tcout << fixed;\n\t\tcout << setprecision(10)<<sqrt(eval(x, y)) << endl;\n\t\t//cerr << \"=================\" << endl;\n\t}\n\nprivate:\n\tvector<Balloon> balls;\n\n\tpair<int, int> select_dir(ld x, ld y, ld step)\n\t{\n\t\tpair<int, int> bestDir = { -1,-1 };\n\t\tld bestScore = -INF;\n\t\tFOR(i, -100, 101)FOR(j, -100, 101) {\n\t\t\tld tmp = eval(x + step * i, y + step * j);\n\t\t\tif (bestScore < tmp) {\n\t\t\t\tbestScore = tmp;\n\t\t\t\tbestDir = { i,j };\n\t\t\t}\n\t\t}\n\t\treturn bestDir;\n\t}\n\n\tld eval(ld x, ld y)\n\t{\n\t\tld res = INF;\n\t\tfor (auto ball : balls)\n\t\t{\n\t\t\tres = min(res, ball.score(x, y));\n\t\t}\n\t\treturn res;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tStage stage;\n\t\tif (stage.is_end())break;\n\t\tstage.action();\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define EPS 1e-6\n\nstruct node{\n  int x, y, len;\n  double r;\n  inline void cal_radius(double height){ r = sqrt(len * len - height * height); }\n  inline void read(){ scanf(\"%d%d%d\", &x, &y, &len); }\n} nodes[20];\n\nint n;\n\ninline bool intersect(const node &a, const node &b){ return hypot(a.x - b.x, a.y - b.y) < a.r + b.r + EPS; }\ninline double dist(const node &a, const node &b){ return hypot(a.x - b.x, a.y - b.y); }\n\ninline bool check(double height){\n  for(int i = 0; i < n; i++) nodes[i].cal_radius(height);\n  \n  for(int i = 0; i < n; i++)\n  for(int j = i + 1; j < n; j++) \n    if(!intersect(nodes[i], nodes[j])) return false;\n    \n  double left[20], right[20];\n  double maxx = 1000.0, mini = -1000.0, mid;\n  \n  for(int i = 0; i < n; i++) maxx = fmin(maxx, nodes[i].y + nodes[i].r);\n  for(int i = 0; i < n; i++) mini = fmax(mini, nodes[i].y - nodes[i].r);\n  \n  while(maxx - mini > EPS){\n    mid = (maxx + mini) * 0.5;\n    \n    for(int i = 0; i < n; i++){\n      double half_chord = sqrt(nodes[i].r * nodes[i].r - (nodes[i].y - mid) * (nodes[i].y - mid));\n      left[i] = nodes[i].x - half_chord;\n      right[i] = nodes[i].x + half_chord;\n    }\n    \n    bool up = false, down = false;\n    for(int i = 0; i < n; i++)\n    for(int j = i + 1; j < n; j++)\n    if(fmax(left[i], left[j]) > fmin(right[i], right[j]) + EPS){\n      double nxty = nodes[i].y + (nodes[j].y - nodes[i].y) * nodes[i].r / dist(nodes[i], nodes[j]);\n      if(nxty > mid) up = true;\n      else down = true;\n    }\n    \n    if(up && down) return false;\n    if(!up && !down) return true;\n    if(up) mini = mid;\n    if(down) maxx = mid;\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d\", &n) == 1 && n){\n    for(int i = 0; i < n; i++) nodes[i].read();\n    \n    double maxx = 1000.0, mini = 0.0, mid;\n    for(int i = 0; i < n; i++) maxx = fmin(maxx, nodes[i].len);\n    \n    while(maxx - mini > EPS){\n      double mid = (maxx + mini) * 0.5;\n      \n      if(check(mid)) mini = mid;\n      else maxx = mid;\n    }\n    \n    printf(\"%.7lf\\n\", maxx);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\nusing vi  = vector<int>;\nusing vvi = vector<vi>;\nconstexpr double inf = 1e10;\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nvvi data;\n\n#define maxLoop 100\ndouble f(double x, double y){\n  double minv = inf;\n  rep(i,data.size()){\n    double nrm1 = pow(x-data[i][0],2) + pow(y-data[i][1],2);\n    double nrm2 = pow(data[i][2],2) - nrm1;\n    chmin(minv, nrm2);\n  }\n  // dump(x,y,minv);\n  return minv;\n}\n\ndouble searchy(double x, double left = -100, double right = 100){\n  for(int loop = 0; loop < maxLoop; ++loop){\n    if(f(x, (left*2+right)/3) > f(x, (left+right*2)/3)){\n      right = (left + right * 2) / 3;\n    }else{\n      left = (left * 2 + right) / 3;\n    }\n  }\n  return f(x,(right + left) * 0.5);\n}\ndouble searchx(double left = -100, double right = 100){\n  for(int loop = 0; loop < maxLoop; ++loop){\n    //dump(left, right, searchy((left*2+right)/3), searchy((left+right*2)/3));\n    if( searchy((left*2+right)/3) > searchy((left+right*2)/3) ){\n      right = (left + right * 2) / 3;\n    }else{\n      left = (left * 2 + right) / 3;\n    }\n  }\n  //dump((right+left)/2);\n  return searchy((right+left)*0.5, -100, 100);\n}\n\nsigned main(){\n  int n;\n  while(cin >> n, n){\n    data.clear();\n    data.resize(n,vi(3));\n    rep(i,n) rep(j,3) cin >> data[i][j];\n    printf(\"%.10lf\\n\", sqrt(searchx()));\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\nstruct Circle{\n  double r;\n  P c;\n};\n\nnamespace std {\n  bool operator < (const P&a, const P&b) {\n    return fabs( real(a) - real(b) ) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\nvector<P> getIntersectCC(Circle C1,Circle C2){\n  vector<P> res;\n  double r1 = C1.r, r2 = C2.r, d;\n  P p1 = C1.c, p2 = C2.c;\n  d = abs( p1 - p2 );\n  \n  if( d < EPS && abs( r1 - r2 ) < EPS ) return res;\n  if( r1 + r2 < d - EPS || d + EPS < abs( r1 - r2 ) ) return res;\n  double a = ( r1 * r1 - r2 * r2 + d * d ) / (2 * d);\n  double h = sqrt(max(r1 * r1 - a * a, 0.0) );\n  P tmp1 = p1 + a / d * (p2 - p1);\n  P tmp2 = h / d * (p2 - p1);\n\n  if( abs( tmp2 ) < EPS ) res.push_back( tmp1 );\n  else {\n    res.push_back( P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)) );\n    res.push_back( P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)) );    \n  }\n  return res;\n}\n\nbool inCircle(Circle C,P p){//in point\n  if( abs(C.c - p) < C.r + EPS ) return true;\n  return false;\n}\n\nint N;\nCircle X[11];\n\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++)\n      cin >> X[i].c.real() >> X[i].c.imag() >> X[i].r;\n    \n    double st = 0.0, ed = 10000.0;\n    while(  ed - st  > EPS ){\n      double h = (ed + st)/2.0;\n      vector<Circle> nc;\n      bool f = true;\n      for(int i=0;i<N;i++){\n        nc.push_back( X[i] );\n        nc[i].r = X[i].r * X[i].r - h * h;\n        if( nc[i].r < EPS ) {\n          f = false;\n          break;\n        }\n        nc[i].r = sqrt(nc[i].r);\n      }\n      if( !f ) {\n        ed = h;\n        continue;\n      }\n      vector<P> pos;\n      for(int i=0;i<N;i++){\n        pos.push_back( nc[i].c );\n        for(int j=i+1;j<N;j++){\n          vector<P> ret = getIntersectCC(nc[i],nc[j]);\n          for(int k=0;k<(int)ret.size();k++) pos.push_back( ret[k] );\n        }\n      }\n      f = false;\n      // cout << \"h : \" <<h << endl;\n      for(int i=0;i<(int)pos.size();i++){\n        // cout <<pos[i] << endl;\n        bool kf = true;\n        for(int j=0;j<N;j++){\n          if( !inCircle( nc[j], pos[i] ) ) kf = false;\n        }\n        if( kf ){\n          f = true;\n          //cout << \"ok\"<< endl;\n          break;\n        }\n      }\n      if( f ) st = h;\n      else ed = h;\n    }\n    printf(\"%.10lf\\n\",st);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n  \nusing namespace std;\n  \n#define EPS 1e-9\n  \nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n   \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n} \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n   \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n   \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n  \nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n  \npoint rot(point p, double a) {\n    point ret;\n    double C = cos(a), S = sin(a);\n    ret.x = p.x*C - p.y*S;\n    ret.y = p.x*S + p.y*C;\n    return ret;\n}\n  \ndouble aaa[1111111];\nint cs=0;\n  \nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n#endif\n    while(1) {\n        scanf(\"%d\",&n); \n        if(n==0) break;\n        for(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n  \n        double ans = -1e20;\n        for(int i=0;i<n;++i) {\n            double tmp = r[i];\n            bool can = 1;\n            for(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n            if(can) ans = max(ans, tmp);\n        }\n  \n        for(int i=0;i<n;++i) {\n            memcpy(cP,P,sizeof(cP));\n            for(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n            for(int j=i+1;j<n;++j) if(j!=i) {\n                double d = dis(cP[i],cP[j]);\n                if(r[i]+r[j] < d-EPS) continue;\n                if(abs(r[i]-r[j]) > d+EPS) continue;\n  \n                memcpy(nP,cP,sizeof(nP));\n                double a = atan2(cP[j].y,cP[j].x);\n                for(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n  \n                bool can = 1;\n                point p1,p2;\n                intersection_circle_circle(point(nP[j].x,nP[j].y),r[j],point(nP[i].x,nP[i].y),r[i],p1,p2);\n                double zz = max(p1.y,p2.y), yy = 0;\n                double xx = p1.x;\n                for(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n                if(can)\n                    ans = max(ans, zz);\n  \n                double rr = zz;\n                for(int k=0;k<n;++k) nP[k].x -= xx;\n                for(int k=j+1;k<n;++k) if(k!=i && k!=j && abs(nP[k].x) <= r[k]+EPS){\n                    double nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n                    double d = abs(nP[k].y);\n                    if(nr+rr < d-EPS) continue;\n                    if(abs(nr-rr) > d+EPS) continue;\n  \n                    bool can = 1;\n                    point p1,p2;\n                    intersection_circle_circle(point(0,0),rr,point(nP[k].y,0),nr,p1,p2);\n                    double zz = max(p1.y,p2.y), xx = 0;\n                    double yy = p1.x;\n                    for(int h=0;h<n;++h) if(sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)) > r[h] + EPS) can = 0;\n                    if(can)\n                        ans = max(ans, zz);\n                }\n            }\n        } printf(\"%.10lf\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\ndouble x[11],y[11],l[11];\n\nCircle circles[11];\nvector<Point> cands;\n\nbool inCircle(Circle c,Point p){//境界上でもtrue\n\tdouble d=pointsDistance(c.center,p);\n\tint s=sgn(d-c.r);\n\tif(s<=0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N;i++) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble lb=0;\n\t\tdouble ub=1000;\n\t\tfor(int i=0;i<N;i++) ub=min(ub,l[i]);\n\t\tfor(int stage=0;stage<100;stage++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircles[i]=Circle(Point(x[i],y[i]),sqrt(l[i]*l[i]-mid*mid));\n\t\t\t}\n\t\t\tcands.clear();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tvector<Point> tmp;\n\t\t\t\t\ttmp=circlesIntersection(circles[i],circles[j]);\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\tcands.push_back(tmp[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cands.size()==0){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tcands.push_back(circles[i].center);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int i=0;i<cands.size();i++){\n\t\t\t\tbool flg=true;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(inCircle(circles[j],cands[i])==false) flg=false;\n\t\t\t\t}\n\t\t\t\tif(flg) ok=true;\n\t\t\t}\n\t\t\tif(ok) lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%f\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nstruct S{\n  P s,t;\n  S(P s=P(),P t=P()): s(s),t(t) {}\n};\nstruct C{\n  P p;\n  double r;\n  C(P p=P(),double r=0):p(p),r(r){}\n};\n \n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \ndouble Sqrt(double a){\n  if(a<0)return 0;\n  return sqrt(a);\n}\n\nbool isIntersect(C a,C b){\n  double k=abs(a.p-b.p);\n  return (a.r+b.r>=k-eps&& abs(a.r-b.r)<=k+eps);\n}\n\nP crossPoint(C a,C b){\n  P base=b.p-a.p;\n  double k=(-b.r*b.r+a.r*a.r+norm(base));\n  double w=k/(2.0*abs(base)),h=Sqrt(a.r*a.r-w*w);\n  base/=abs(base);\n  return a.p+base*P(w,h);\n}\n\n\nbool isIntersect(vector<C> &vec){\n  vector<P> t;\n  for(int i=0;i<(int)vec.size();i++){\n    t.push_back(vec[i].p);\n    for(int j=0;j<i;j++){\n      if(isIntersect(vec[i],vec[j])){\n        t.push_back(crossPoint(vec[i],vec[j]));\n        t.push_back(crossPoint(vec[j],vec[i]));\n      }\n    }\n  }\n  for(int i=0;i<(int)t.size();i++){\n    bool flg=true;\n    for(int j=0;j<(int)vec.size();j++)\n      if(vec[j].r*vec[j].r+eps<norm(vec[j].p-t[i]))flg=false;\n    if(flg)return true;\n  }\n  return false;\n}\n\nint n;\nvector<P> t;\nvector<double> u;\n\ndouble check(double M){\n  vector<C> nt(n);\n  for(int i=0;i<n;i++){\n    nt[i].p=t[i];\n    nt[i].r=Sqrt(u[i]*u[i]-M*M);\n  }\n  return isIntersect(nt);\n}\n\ndouble solve(){\n  double L=0,R=1e8,M;\n  for(int i=0;i<n;i++)R=min(R,u[i]);\n  \n  for(int i=0;i<100;i++){\n    M=(L+R)/2;\n    if(check(M))L=M;\n    else R=M;\n  }\n  \n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    t.clear();t.resize(n);\n    u.clear();u.resize(n);\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y>>u[i];\n      t[i]=P(x,y);\n    }\n    printf(\"%.10f\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(long long i=0;i<n;i++)\n#define REP1(i,n) for(long long i=1;i<=n;i++)\n#define REP2D(i,j,h,w) for(long long i=0;i<h;i++) for(long long j=0;j<w;j++)\n#define REP2D1(i,j,h,w) for(long long i=1;i<=h;i++) for(long long j=1;j<=w;j++)\n#define PER(i,n) for(long long i=((n)-1);i>=0;i--)\n#define PER1(i,n) for(long long i=(n);i>0;i--)\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define FORE(i,a,b) for(long long i=(a);i<=(b);i++)\n#define ITE(arr) for(auto ite=(arr).begin();ite!=(arr).end();++ite)\n#define ALL(a) (a.begin()),(a.end())\n#define RANGE(a) (a),(a+sizeof(a))\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define YNPRT(b) cout<<((b)?\"Yes\":\"No\")<<endl\n#define REV(arr) reverse(ALL(arr))\n#define PRT(a) cout<<a<<endl;\n#define PRTLST(arr,num) REP(_i,num) cout<<_i<<\" - \"<<arr[_i]<<endl;\n#define PRTLST2(arr2,d1,d2) REP(_i,d1) REP(_j,d2) cout<<_i<<\",\"<<_j<<\" : \"<<arr2[_i][_j]<<endl;\n#define PRTLST2D(arr2,d1,d2) do{cout<<\"L\\t\";REP(_i,d2) cout<<_i<<\"\\t\"; cout<<endl; REP(_i,d1){cout<<_i<<\"\\t\";REP(_j,d2){cout<<arr2[_i][_j]<<\"\\t\";}cout<<endl;}}while(0);\n#define MIN(target,v1) (target)=min(target,v1)\n#define MAX(target,v1) (target)=max(target,v1) \n#define P1 first\n#define P2 second\n#define PB push_back\n#define UB upper_bound\n#define LB lower_bound\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF_INT = 2147483647;\nconst ll INF_LL = 9223372036854775807LL;\nconst ull INF_ULL = 18446744073709551615Ull;\nconst ll P = 92540646808111039LL;\nconst int Move[4][2] = {-1,0,0,1,1,0,0,-1};\nconst int Move_[8][2] = {-1,0,-1,-1,0,1,1,1,1,0,1,-1,0,-1,-1,-1};\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p) {os<<\"( \"<<p.P1<<\" , \"<<p.P2<<\" )\";return os;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {ITE(v) os << (ite-v.begin()) << \" : \" << *ite <<endl;return os;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v) {os<<\" { \";ITE(v) {os<<*ite;if(ite!=--v.end()){os<<\" , \";}} os<<\" } \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& m) {ITE(m) {os<<ite->P1<<\"\\t\\t|->\\t\\t\"<<ite->P2<<endl;} return os;}\n\n//---------------------\n#define MAXN 11\n//---------------------\n\nint n;\ndouble x[MAXN],y[MAXN],l[MAXN];\ndouble retl=0;\n\nstruct Matrix{\n\tdouble m[3][3];\n\tMatrix(){ZERO(m);}\n\tvoid init(){ZERO(m);}\n\tvoid unit(){ZERO(m);m[0][0]=m[1][1]=m[2][2]=1;}\n};\n\nMatrix rot;\nMatrix rotinv;\n\n#define PRTVEC(vec) cout<<\"Vector : \"<<(vec.v[0])<< \" , \" <<(vec.v[1])<<\" , \"<<(vec.v[2])<<endl;\n\nstruct Vector{\n\tdouble v[3];\n\tVector(){ZERO(v);}\n\tVector(double x,double y,double z){v[0]=x;v[1]=y;v[2]=z;}\n\tvoid set(double x, double y, double z){v[0]=x,v[1]=y,v[2]=z;}\n\tvoid scale(double k){\n\t\tREP(i,3) v[i] *= k;\n\t}\n\tvoid mult(double k){scale(k);}\n\tdouble mag(){\n\t\treturn sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);\n\t}\n\tvoid normalize(){\n\t\tdouble len=mag();\n\t\tif(len!=0) scale(1/len);\n\t}\n\tvoid sub(const Vector& tar){\n\t\tREP(i,3) v[i]-=tar.v[i];\n\t}\n\tvoid plus(const Vector& tar){\n\t\tREP(i,3) v[i]+=tar.v[i];\n\t}\n};\n\n\nVector multMatrix(const Matrix& mat,const Vector& vec){\n\tVector v;\n\tv.set(mat.m[0][0]*vec.v[0]+mat.m[0][1]*vec.v[1] +mat.m[0][2]*vec.v[2]\n\t , mat.m[1][0]*vec.v[0]+mat.m[1][1]*vec.v[1] +mat.m[1][2]*vec.v[2] \n\t , mat.m[2][0]*vec.v[0]+mat.m[2][1]*vec.v[1] +mat.m[2][2]*vec.v[2] );\n\treturn v;\n}\n\n\nVector offset;\n\nvoid moveToOrigin(Vector& target){\n\ttarget.sub(offset);\n\ttarget=multMatrix(rot,target);\n}\n\nvoid moveFromOrigin(Vector& target){\n\ttarget=multMatrix(rotinv,target);\n\ttarget.plus(offset);\n}\n\nvoid setRotate(double theta){\n\trot.unit();\n\trotinv.unit();\n\ttheta=-theta;\n\trot.m[0][0]=cos(theta);\n\trot.m[1][1]=cos(theta);\n\trot.m[1][0]=sin(theta);\n\trot.m[0][1]=-sin(theta);\n\ttheta=-theta;\n\trotinv.m[0][0]=cos(theta);\n\trotinv.m[1][1]=cos(theta);\n\trotinv.m[1][0]=sin(theta);\n\trotinv.m[0][1]=-sin(theta);\n}\n\nVector ropes[MAXN];\n\n\nVector LM1(const Vector& A){\n\treturn A;\n}\n\nbool isGoodRopes(const Vector& A, const Vector& B){\n  \tdouble dx=A.v[0]-B.v[0];\n  \tdouble dy=A.v[1]-B.v[1];\n\tdouble dist=sqrt(dx*dx+dy*dy);\n\tdouble la=A.v[2],lb=B.v[2];\n\tif(lb>=sqrt(la*la+dist*dist)) return false;\n\treturn true;\n}\n\nstruct GoodRopes{\n  \tVector r1,r2;\n  \tint id1,id2;\n  \tVector sol;\n\tGoodRopes(int a,int b,const Vector& c){\n\t\tr1=ropes[a];r2=ropes[b];sol=c;\n\t\tid1=a;id2=b;\n\t}\n};\n\nvector<GoodRopes> goodropes;\n\nVector LM2(int ida, int idb){\n  \tVector A=ropes[ida];\n  \tVector B=ropes[idb];\n\tVector retvec;\n\tdouble la=A.v[2],lb=B.v[2];\n\tif(!isGoodRopes(A,B) || !isGoodRopes(B,A)){\n\t\tif(la<lb) return A;\n\t\treturn B;\n\t}\n\tdouble dx=A.v[0]-B.v[0];\n  \tdouble dy=A.v[1]-B.v[1];\n\tdouble dist=sqrt(dx*dx+dy*dy);\n\tdouble cosTheta=(la*la+dist*dist-lb*lb)/(2*la*dist);\n\tdouble distt=cosTheta*la;\n\tdouble t=distt/dist;\n\tdouble h=sqrt(la*la-distt*distt);\n\tretvec.set((1-t)*A.v[0]+t*B.v[0],(1-t)*A.v[1]+t*B.v[1],h);\n\tgoodropes.push_back(GoodRopes(ida,idb,retvec));\n\treturn retvec;\n}\n\n\n\nVector LM3(const GoodRopes& gr,const Vector& C){\n\tif(!isGoodRopes(gr.sol,C)) return gr.sol;\n\tVector curSol=gr.sol;\n\tVector curC=C;\n\tVector direction(gr.r1.v[1]-gr.r2.v[1],-(gr.r1.v[0]-gr.r2.v[0]),double(0));\n\tsetRotate(atan2(direction.v[1],direction.v[0]));\n\toffset.set(curSol.v[0],curSol.v[1],0);\n\tmoveToOrigin(curSol);moveToOrigin(curC);\n\tdouble l3=C.v[2];\n\tdouble x3=curC.v[0],y3=curC.v[1];\n\tdouble l=gr.sol.v[2];\n\tdouble cosTheta=(l3*l3-x3*x3-l*l-y3*y3)/(-2*x3*l);\n\tdouble newX=l*cosTheta;\n\tVector newSol(newX,0,sqrt(l*l-newX*newX));\n\tmoveFromOrigin(newSol);\n\treturn newSol;\n}\n\nbool isSafeSol(const Vector& sol,const Vector& test){\n\tVector testrp=test;\n\ttestrp.v[2]=0;\n\ttestrp.sub(sol);\n\treturn testrp.mag()<=test.v[2];\n}\n\nbool init(){\n  \t\n  \tZERO(x);ZERO(y);ZERO(l);\n  \toffset.set(0,0,0);\n  \tgoodropes.clear();\n  \tretl=0;\n\tcin>>n;\n\tif(n<=0) return false;\n\tREP(i,n) cin>>x[i]>>y[i]>>l[i];\n\tREP(i,n) ropes[i].set(x[i],y[i],l[i]);\n\treturn true;\n}\n\n\nint main(){\n  \twhile(init()){\n  \t\tREP(i,n){\n  \t\t  \tVector target=LM1(ropes[i]);\n  \t\t  \tbool isOK = true;\n  \t\t\tFOR(j,0,n){\n  \t\t\t\tif(i==j) continue;\n  \t\t\t\tif(!isSafeSol(target,ropes[j])){\n  \t\t\t\t\tisOK=false;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif(isOK) MAX(retl,target.v[2]);\n  \t\t}\n  \t\t\n  \t\tif(n==1) {  \t\tprintf(\"%.6lf\\n\",retl);continue;}\n  \t\t\n  \t\tREP(i,n-1){\n  \t\t\tFOR(j,i+1,n){\n  \t\t\t\tVector target=LM2(i,j);\n  \t\t\t\tbool isOK=true;\n  \t\t\t\tFOR(k,0,n){\n  \t\t\t\t\tif(i==k || j==k) continue;\n  \t\t\t\t\tif(!isSafeSol(target,ropes[k])){\n  \t\t\t\t\t\tisOK=false;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tif(isOK) MAX(retl,target.v[2]);\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\tif(n==2) {  \t\tprintf(\"%.6lf\\n\",retl);continue;}\n  \t\t\n  \t\tITE(goodropes){\n  \t\t\tREP(i,n){\n  \t\t\t\tif(i==ite->id1 || i== ite->id2) continue;\n  \t\t\t\tVector target=LM3(*ite,ropes[i]);\n  \t\t\t\tbool isOK=true;\n  \t\t\t\tREP(j,n){\n  \t\t\t\t\tif(j==ite->id1 || j==ite->id2 || j==i) continue;\n  \t\t\t\t\tif(!isSafeSol(target,ropes[j])){\n  \t\t\t\t\t\tisOK=false;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tif(isOK) {MAX(retl,target.v[2]);}\n  \t\t\t}  \n  \t\t}\n  \t\tprintf(\"%.6lf\\n\",retl);\n  \t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\ntypedef complex<ld> Point;\nld dot(Point a, Point b) { return real(conj(a)*b); }\nld cross(Point a, Point b) { return imag(conj(a)*b); }\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n\t}\n}\nstruct Line {\n\tPoint a, b;\n};\nstruct Circle {\n\tPoint p; ld r;\n};\nnamespace std {\n\tbool operator<(const Circle &lhs, const Circle &rhs) {\n\t\tif (lhs.r != rhs.r)return lhs.r < rhs.r;\n\t\treturn lhs.p < rhs.p;\n\t}\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// most in_circle point\nint calc(vector<Circle> c) {\n\tif (c.size() <= 1)return c.size();\n\tint res = 0;\n\trep(i, c.size()) {\n\t\tint num = 1;\n\t\tvector<pair<ld, int>> u;\n\t\tint cur = 0;\n\t\trep(j, c.size()) {\n\t\t\tif (i == j)continue;\n\t\t\tld dist = abs(c[j].p - c[i].p);\n\t\t\tif (dist + c[i].r <= c[j].r) {\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\telse if (dist > c[i].r + c[j].r)continue;\n\t\t\telse {\n\t\t\t\tvector<Point> v = is_cc(c[i], c[j]);\n\t\t\t\tif (v.size() <= 1)continue;\n\t\t\t\tld t1 = atan2(imag(v[0]) - imag(c[i].p), real(v[0]) - real(c[i].p));\n\t\t\t\tld t2 = atan2(imag(v[1]) - imag(c[i].p), real(v[1]) - real(c[i].p));\n\t\t\t\tu.push_back({ t1,0 });\n\t\t\t\tu.push_back({ t2,1 });\n\t\t\t\tif (t2 > t1) {\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tint len = u.size();\n\t\trep(i, len)u.push_back({ u[i].first + 2 * pi,u[i].second });\n\t\tlen = u.size();\n\t\tint ma = 0;\n\t\trep(i, len) {\n\t\t\tif (u[i].second)cur++;\n\t\t\telse cur--;\n\t\t\tma = max(ma, cur);\n\t\t}\n\t\tres = max(res, ma + num);\n\t}\n\treturn res;\n}\nint n;\nvoid solve() {\n\tvector<Point> p(n);\n\tvector<ld> l(n);\n\tld ri = mod;\n\trep(i, n) {\n\t\tld x, y; cin >> x >> y;\n\t\tp[i] = { x,y }; cin >> l[i];\n\t\tri = min(ri, l[i]);\n\t}\n\tld le = 1;\n\trep(aa, 100) {\n\t\tld mid = (le + ri) / 2.0;\n\t\tvector<Circle> c;\n\t\trep(i, n) {\n\t\t\tld r = sqrt(l[i] * l[i] - mid * mid);\n\t\t\tc.push_back({ p[i],r });\n\t\t}\n\t\tint num = calc(c);\n\t\t//cout << mid << \" !! \" << num << endl;\n\t\tif (num == n) {\n\t\t\tle = mid;\n\t\t}\n\t\telse {\n\t\t\tri = mid;\n\t\t}\n\t}\n\tcout << le << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\t//init();\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\nconst D EPS = 1e-7;\n#define X real()\n#define Y imag()\n \n#define EQ(n,m) (abs((n)-(m)) < EPS)\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n  \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \nint n;\nD x[11],y[11],z[11],a[11];\n \ninline bool ch(double mid){\n  VP v;\n  rep(i,n){\n    a[i] = sqrt(z[i]*z[i] - mid*mid);\n    if(a[i]<0)return 0;\n    v.push_back(P(x[i],y[i]));\n  }\n  rep(i,n)rep(j,n)if(i<j){\n    VP p=crosspointCC(P(x[i],y[i]),a[i],P(x[j],y[j]),a[j]);\n    rep(k,p.size()){\n      v.push_back(p[k]);\n    }\n  }\n  rep(i,v.size()){\n    int flag=0;\n    rep(j,n){\n      D dist=sqrt((x[j]-v[i].X)*(x[j]-v[i].X)+(y[j]-v[i].Y)*(y[j]-v[i].Y));\n      if(dist<=a[j]+EPS)flag++;\n    }\n    if(flag==n)return 1;\n  }\n  return 0;\n}\n \nsigned main(){\n  while(cin>>n,n){\n    rep(i,n)cin>>x[i]>>y[i]>>z[i];\n    D l=0,r=1e9;\n    rep(o,100){\n      D mid=(l+r)/2;\n      if(!ch(mid))r=mid;\n      else l=mid;\n    }\n    printf(\"%.9f\\n\",l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <tuple>\n#include <cmath>\n\n#define ISLOOSE(a,b)\t(disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n\nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\ndouble heron(double a, double b, double c)\n{\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n\treturn sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n\ntuple<double, double, double> com(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b)) {\n\t\treturn a;\n\t}\n\telse if (disdis(a, b) + get<2>(b) * get<2>(b) <= get<2>(a) * get<2>(a)) {\n\t\treturn b;\n\t}\n\telse {\n\t\tdouble l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n\t\tdouble d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n\t\tdouble d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n\t\treturn tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n\t}\n}\n\ndouble two(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b)) {\n\t\treturn (double)get<2>(a);\n\t}\n\telse if (disdis(a, b) + get<2>(b) * get<2>(b) <= get<2>(a) * get<2>(a)) {\n\t\treturn (double)get<2>(b);\n\t}\n\telse {\n\t\tdouble d = sqrt(disdis(a, b));\n\t\treturn heron(get<2>(a), get<2>(b), d) * 2 / d;\n\t}\n}\n\ndouble three(const tuple<double, double, double>& a, const tuple<double, double, double>& b, const tuple<double, double, double>& c)\n{\n\ttuple<double, double, double> temp;\n\n\tif (ISLOOSE(a, b) && ISLOOSE(a, c))\n\t\treturn get<2>(a);\n\tif (ISLOOSE(b, a) && ISLOOSE(b, c))\n\t\treturn get<2>(b);\n\tif (ISLOOSE(c, a) && ISLOOSE(c, b))\n\t\treturn get<2>(c);\n\n\tif (ISLOOSE(temp = com(a, b), c))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(b, c), a))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(c, a), b))\n\t\treturn get<2>(temp);\n\n\treturn heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n\t\t* 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n\nint main()\n{\n\tint n;\n\tdouble res;\n\twhile (cin >> n, n) {\n\t\tvector< tuple<double, double, double> > str(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << fixed << setprecision(7) << (double)get<2>(str[0]) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcout << fixed << setprecision(7) << two(str[0], str[1]) << endl;\n\t\t}\n\t\telse {\n\t\t\tres = 100000000.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tres = min(res, three(str[i], str[j], str[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(7) << res << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<tuple>\n#include<complex>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmin(T &l, T r) {\n\tbool res = l > r;\n\tif (res) {\n\t\tl = r;\n\t}\n\treturn res;\n}\n#define IL inline\n#define X real()\n#define Y imag()\ntypedef double D;\n\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\ntypedef pair<P, D> C;\nconst D EPS = 1e-8;\nIL D dot(P a, P b) {\n\treturn a.X*b.X + a.Y*b.Y;\n}\nIL D cross(P a, P b) {\n\treturn a.X*b.Y - a.Y*b.X;\n}\n\n\n\nstruct cww {\n\tcww() {\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\nIL D signed_distance_P_L(P p, LS l) {\n\tP a, b, c = p;\n\ttie(a, b) = l;\n\treturn cross(b - a, c - a) / abs(b - a);\n}\nIL D distance_P_LS(P p, LS ls) {\n\tP a, b, c = p;\n\ttie(a, b) = ls;\n\tif (dot(b - a, c - a) < EPS)return abs(c - a);\n\tif (dot(a - b, c - b) < EPS)return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nIL bool isintersected_LS_LS(LS p, LS q) {\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tif (abs(cross(b - a, d - c))<EPS) {\n\t\tif (abs(abs(b - c) + abs(a - c) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(b - d) + abs(a - d) - abs(a - b)) < EPS)return true;\n\t\tif (abs(abs(a - c) + abs(a - d) - abs(c - d)) < EPS)return true;\n\t\tif (abs(abs(b - c) + abs(b - d) - abs(c - d)) < EPS)return true;\n\n\t\treturn false;\n\t}\n\treturn cross(b - a, c - a)*cross(b - a, d - a) < EPS && cross(d - c, a - c)*cross(d - c, b - c) < EPS;\n}\nIL D distance_LS_LS(LS p, LS q) {\n\tif (isintersected_LS_LS(p, q))return 0;\n\tP a, b, c, d;\n\ttie(a, b) = p;\n\ttie(c, d) = q;\n\tdouble e, f, g, h;\n\te = distance_P_LS(a, q);\n\tf = distance_P_LS(b, q);\n\tg = distance_P_LS(c, p);\n\th = distance_P_LS(d, p);\n\treturn min({ e,f,g,h });\n}\nP rot(P p, double r) {\n\treturn P(p.X*cos(r) - p.Y*sin(r), p.X*sin(r) + p.Y*cos(r));\n}\nIL bool isintersected_C_C(C p, C q) {\n\tP cp, cq;\n\tD rp, rq;\n\ttie(cp, rp) = p;\n\ttie(cq, rq) = q;\n\tD d = abs(cp - cq);\n\treturn abs(rp - rq) < d + EPS&&d < rp + rq + EPS;\n}\nIL LS cross_C_C(C p, C q) {\n\tP cp, cq;\n\tD rp, rq;\n\ttie(cp, rp) = p;\n\ttie(cq, rq) = q;\n\tD d = abs(cp - cq);\n\tD rc = (d*d +rp*rp - rq*rq)/(2*d);\n\tD rs = sqrt(rp*rp - rc*rc);\n\tP diff = (cq - cp) / d;\n\treturn LS(cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff);\n}\n\nconst D PI = acos(-1);\ntypedef pair<double, int> pp;\ntypedef priority_queue<pp, vector<pp>, greater<pp>> QUE;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<P> xy(N);\n\t\tvector<D> len(N);\n\t\tREP(i, N) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y>>len[i];\n\t\t\txy[i] = P(x, y);\n\t\t}\n\t\tdouble lb = 0;\n\t\tdouble ub = 400;\n\t\tREP(loop, 100) {\n\t\t\tconst D mid = (lb + ub) / 2;\n\t\t\tvector<C> cir(N);\n\t\t\tbool flag = true;\n\t\t\tREP(i, N) {\n\t\t\t\tdouble l = len[i] * len[i] - mid*mid;\n\t\t\t\tif (l < 0) { flag = false; break; }\n\t\t\t\tcir[i] = C(xy[i], sqrt(l));\n\t\t\t}\n\t\t\tif (flag == false) {\n\t\t\t\tub = mid; continue;\n\t\t\t}\n\t\t\tvector<P> nobu;\n\t\t\tREP(i, N)nobu.push_back(xy[i]);\n\t\t\tREP(i, N) {\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tif (!isintersected_C_C(cir[i], cir[j]))continue;\n\t\t\t\t\t\tauto hiro = cross_C_C(cir[i], cir[j]);\n\t\t\t\t\t\tnobu.push_back(hiro.first);\n\t\t\t\t\t\tnobu.push_back(hiro.second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor (auto &p : nobu) {\n\t\t\t\tbool btk=true;\n\t\t\t\tREP(i, N) {\n\t\t\t\t\tauto d = abs(p - xy[i]);\n\t\t\t\t\tif (d*d + mid*mid > len[i] * len[i])\n\t\t\t\t\t\tbtk = false;\n\t\t\t\t}\n\t\t\t\tif (btk)flag = true;\n\t\t\t}\n\n\n\t\t\tif (flag)lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n\npoint rot(point p, double a) {\n\tpoint ret;\n\tdouble C = cos(a), S = sin(a);\n\tret.x = p.x*C - p.y*S;\n\tret.y = p.x*S + p.y*C;\n\t//printf(\"%lf %lf %lf %lf %lf\\n\",p.x,S,p.y,C,ret.y);\n\treturn ret;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\twhile(1) {\n\t\tscanf(\"%d\",&n); \n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n\n\t\tdouble ans = 1e20;\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tdouble tmp = r[i];\n\t\t\tbool can = 1;\n\t\t\tfor(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n\t\t\tif(can) ans = min(ans, tmp);\n\t\t}\n\n\t\tfor(int i=0;i<n;++i) {\n\t\t\tmemcpy(cP,P,sizeof(cP));\n\t\t\tfor(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n\t\t\tfor(int j=i+1;j<n;++j) {\n\t\t\t\tdouble d = dis(cP[i],cP[j]);\n\t\t\t\tif(r[i]+r[j] < d-EPS) continue;\n\t\t\t\tif(abs(r[i]-r[j]) > d+EPS) continue;\n\n\t\t\t\tmemcpy(nP,cP,sizeof(nP));\n\t\t\t\tdouble a = atan2(cP[j].y,cP[j].x);\n\t\t\t\t//printf(\"%lf\\n\",a/acos(-1.0)*180.0);\n\t\t\t\tfor(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n\t\t\t\t//for(int k=0;k<n;++k) printf(\"%lf %lf\\n\",nP[k].x,nP[k].y);\n\n\t\t\t\tbool can = 1;\n\t\t\t\tdouble s = (abs(nP[j].x) + r[i] + r[j]) / 2;\n\t\t\t\tdouble S = sqrt(s*(s-abs(nP[j].x))*(s-r[i])*(s-r[j]));\n\t\t\t\tdouble zz = S * 2 / abs(nP[j].x), yy = 0;\n\t\t\t\tdouble xx = sqrt(sqr(r[i]) - sqr(zz));\n\t\t\t\tif(nP[j].x < 0) xx *= -1;\n\t\t\t\tfor(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n\t\t\t\tif(can)\n\t\t\t\t\tans = min(ans, zz);\n\n\t\t\t\tdouble rr = zz;\n\t\t\t\tfor(int k=0;k<n;++k) nP[k].x -= xx, nP[k].x = abs(nP[k].x);\n\t\t\t\tfor(int k=j+1;k<n;++k) if(abs(nP[k].x) <= r[k]+EPS){\n\t\t\t\t\tdouble nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n\t\t\t\t\tdouble d = abs(nP[k].y);\n\t\t\t\t\tif(nr+rr < d-EPS) continue;\n\t\t\t\t\tif(abs(nr-rr) > d+EPS) continue;\n\t\t\t\t\tif(d < EPS) continue;\n\n\t\t\t\t\tbool can = 1;\n\t\t\t\t\tdouble s = (d + nr + rr) / 2;\n\t\t\t\t\tdouble S = sqrt(s*(s-d)*(s-nr)*(s-rr));\n\t\t\t\t\tdouble zz = S * 2 / d, xx = 0;\n\t\t\t\t\tdouble yy = sqrt(sqr(rr) - sqr(zz));\n\t\t\t\t\tif(nP[k].y < 0) yy *= -1;\n\t\t\t\t\tfor(int h=0;h<n;++h) if(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz) > r[h]*r[h] + EPS) can = 0;\n\t\t\t\t\tif(can)\n\t\t\t\t\t\tans = min(ans, zz);\n\t\t\t\t}\n\t\t\t}\n\t\t} printf(\"%.10lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\nusing namespace std;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\n\nbool zero(double a) { return abs(a) <= EPS; }\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nbool canClear(P p, int i1, int i2) {\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && 0.000005 + r[i] < abs(p - dir[i])) return false;\n  return true;\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (-EPS > ((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt((double)l[i] * l[i] - h * h);\n  }\n  for (int i = 0; i < n; i++) if (canClear(dir[i], -1, -1)) return true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      double d = abs(dir[j] - dir[i]);\n      if (d - r[i] - r[j] > EPS) return false;\n      if (r[i] - r[j] - d > EPS) continue;\n      if (r[j] - r[i] - d > EPS) continue;\n      double A = atan2((dir[j] - dir[i]).imag(), (dir[j] - dir[i]).real());\n      double S = acos((d*d + r[i]*r[i] - r[j]*r[j]) / (2 * d * r[i]));\n      if (canClear(dir[i] + polar(r[i], S + A), i, j)) return true;\n      if (canClear(dir[i] + polar(r[i], S - A), i, j)) return true;\n    }\n  }\n  return false;\n  //return true;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i] = P(x[i], y[i]);\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%.7f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> Point;\nbool intersect(Point p1, double r1, Point p2, double r2) {\n\tdouble d = abs(p1 - p2);\n\tif (d < abs(r1 - r2)) return false;\n\tif (d > r1 + r2) return false;\n\treturn true;\n}\nPoint crosspoint(Point p1, double r1, Point p2, double r2) {\n\tdouble c = (r1 * r1 + norm(p1 - p2) - r2 * r2) / (2.0 * r1 * abs(p1 - p2));\n\treturn p1 + (p2 - p1) / abs(p1 - p2) * r1 * Point(c, sqrt(1.0 - c * c));\n}\nint n; double x[15], y[15], p[15], e[15];\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> p[i];\n\t\tdouble l = 0.0, r = *min_element(p, p + n);\n\t\tfor (int i = 0; i < 70; i++) {\n\t\t\tdouble m = (l + r) * 0.5;\n\t\t\tfor (int i = 0; i < n; i++) e[i] = sqrt(p[i] * p[i] - m * m);\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (abs(Point(x[j] - x[k], y[j] - y[k])) > e[k] + 1.0e-7) ok = false;\n\t\t\t\t}\n\t\t\t\tif (ok) flag = true;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (intersect(Point(x[j], y[j]), e[j], Point(x[k], y[k]), e[k])) {\n\t\t\t\t\t\tPoint p1 = crosspoint(Point(x[j], y[j]), e[j], Point(x[k], y[k]), e[k]);\n\t\t\t\t\t\tPoint p2 = crosspoint(Point(x[k], y[k]), e[k], Point(x[j], y[j]), e[j]);\n\t\t\t\t\t\tbool ok1 = true, ok2 = true;\n\t\t\t\t\t\tfor (int t = 0; t < n; t++) {\n\t\t\t\t\t\t\tif (abs(Point(x[t], y[t]) - p1) > e[t] + 1.0e-7) ok1 = false;\n\t\t\t\t\t\t\tif (abs(Point(x[t], y[t]) - p2) > e[t] + 1.0e-7) ok2 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok1 || ok2) flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tcout << fixed << setprecision(10) << l << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 1e9;\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n\nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\ndouble heron(double a, double b, double c)\n{\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n\treturn sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n\ntuple<double, double, double> com(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn a;\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn b;\n\t}\n\telse {\n\t\tdouble l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n\t\tdouble d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n\t\tdouble d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n\t\treturn tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n\t}\n}\n\ndouble two(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn (double)get<2>(a);\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn (double)get<2>(b);\n\t}\n\telse {\n\t\tdouble d = sqrt(disdis(a, b));\n\t\treturn heron(get<2>(a), get<2>(b), d) * 2 / d;\n\t}\n}\n\ndouble three(const tuple<double, double, double>& a, const tuple<double, double, double>& b, const tuple<double, double, double>& c)\n{\n\ttuple<double, double, double> temp;\n\n\tif (ISLOOSE(a, b) && ISLOOSE(a, c))\n\t\treturn get<2>(a);\n\tif (ISLOOSE(b, a) && ISLOOSE(b, c))\n\t\treturn get<2>(b);\n\tif (ISLOOSE(c, a) && ISLOOSE(c, b))\n\t\treturn get<2>(c);\n\n\tif (ISLOOSE(temp = com(a, b), c))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(b, c), a))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(c, a), b))\n\t\treturn get<2>(temp);\n\n\treturn heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n\t\t* 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n\nint main()\n{\n\tint n;\n\tdouble res;\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\twhile (cin >> n, n) {\n\t\tvector< tuple<double, double, double> > str(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << (double)get<2>(str[0]) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcout << two(str[0], str[1]) << endl;\n\t\t}\n\t\telse {\n\t\t\tres = 100000000.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tres = min(res, three(str[i], str[j], str[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    for(;;){\n      int(n); if(!n)break;\n      double x[n], y[n], l[n], dx, dy;\n      rep(i, n)cin >> x[i] >> y[i] >> l[i];\n      if(n == 1){ pri(l[0]); continue; }\n      double wl = 100, wr = -100, ht = -100, hb = 100;\n      rep(i, n){\n        if(wl > x[i])wl = x[i];\n        if(wr < x[i])wr = x[i];\n        if(ht < y[i])ht = y[i];\n        if(hb > y[i])hb = y[i];\n      }\n      rep(i, n){\n        if(wl < x[i] - l[i])wl = x[i] - l[i];\n        if(wr > x[i] + l[i])wr = x[i] + l[i];\n        if(hb < y[i] - l[i])hb = y[i] - l[i];\n        if(ht > y[i] + l[i])ht = y[i] + l[i];\n      }\n\n      double w[4] = {wl, 0, 0, wr}, wres[4];\n      for(int xt = 200;xt--;){\n        w[1] = w[0] + (w[3] - w[0]) / 3.0;\n        w[2] = w[0] + (w[3] - w[0]) * 2.0 / 3.0;\n        rep(i, 4){\n\n          double h[4] = {hb, 0, 0, ht}, hres[4];\n          for(int yt = 200;yt--;){\n            h[1] = h[0] + (h[3] - h[0]) / 3.0;\n            h[2] = h[0] + (h[3] - h[0]) * 2.0 / 3.0;\n\n            rep(j, 4){\n              double res = 400;\n              rep(k, n){\n                double d = sqrt((x[k] - w[i]) * (x[k] - w[i]) + (y[k] - h[j]) * (y[k] - h[j]));\n                if(l[k] < d)res = 0;\n                else{\n                  double tmp = sqrt(l[k] * l[k] - d * d);\n                  res = min(res, tmp);\n                }\n              }\n              hres[j] = res;\n            }\n\n            if(hres[1] < hres[2])h[0] = h[1];\n            else h[3] = h[2];\n            dy = h[1];\n          }\n\n          wres[i] = hres[1];\n        }\n        if(wres[1] < wres[2])w[0] = w[1];\n        else w[3] = w[2];\n        dx = w[1];\n      }\n\n      double res = 400;\n      rep(k, n){\n        double d = sqrt((x[k] - dx) * (x[k] - dx) + (y[k] - dy) * (y[k] - dy));\n        double tmp = sqrt(l[k] * l[k] - d * d);\n        res = min(res, tmp);\n      }\n      prid(res);\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1.0e-8\n#define PI 3.1415926535897932384 \n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n// 実数の符号関数\ninline int signum(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n//XY座標\n#define X real()\n#define Y imag()\n// 点\ntypedef complex<double> P;\n \n\n// 線分・半直線・直線\nstruct L { P pos, dir; };\n\n\n// 円\nstruct C { P p; double r; };\n\n// 二つのベクトルの内積を計算する\ninline double inp(const P& a, const P& b) {\n    return (conj(a)*b).real();\n}\n \n// 二つのベクトルの外積を計算する\ninline double outp(const P& a, const P& b) {\n    return (conj(a)*b).imag();\n}\ninline int ccw(const P& p, const P& r, const P& s) {\n    P a(r-p), b(s-p);\n    int sgn = signum(outp(a, b));\n    if (sgn != 0)\n        return sgn;\n    if (a.real()*b.real() < -EPS || a.imag()*b.imag() < -EPS)\n        return -1;\n    if (norm(a) < norm(b) - EPS)\n        return 1;\n    return 0;\n}\n// ベクトルpをベクトルbに射影したベクトルを計算する\ninline P proj(const P& p, const P& b) {\n    return b*inp(p,b)/norm(b);\n}\n \n// 点pから直線lに引いた垂線の足となる点を計算する\ninline P perf(const L& l, const P& p) {\n    L m = {l.pos - p, l.dir};\n    return (p + (m.pos - proj(m.pos, m.dir)));\n}\n \n// 線分sを直線bに射影した線分を計算する\ninline L proj(const L& s, const L& b) {\n     return (L){perf(b, s.pos), proj(s.dir, b.dir)};\n}\n\npair<P, P> cc_cross(const C& c1, const C& c2) {\n\tif(c1.r+c2.r < abs(c1.p-c2.p) || abs(c1.p-c2.p) < abs(c1.r-c2.r)+EPS){\n\t\tprintf(\"cc_cross error\\n\");\n\t\texit(0);\n\t}\n\n    double d = abs(c1.p - c2.p);\n    double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n    double rs = sqrt(c1.r*c1.r - rc*rc);\n    P diff = (c2.p - c1.p) / d;\n    return make_pair(c1.p + diff * P(rc, rs), c1.p + diff * P(rc, -rs));\n}\n\nint n;\n\nbool check(vector<C> Cs, double z){\n\tint i,j,k;\n\n\tvector<P> intersects;\n\tfor(i=0;i<Cs.size();i++){\n\t\tCs[i].r = sqrt(Cs[i].r*Cs[i].r - z*z);\n//\t\tprintf(\"circle(%f, %f, %f)\\n\", Cs[i].p.X+100, Cs[i].p.Y+100, Cs[i].r);\n\t\tintersects.push_back(Cs[i].p);\n\t}\n\tfor(i=0;i<Cs.size();i++){\n\t\tfor(j=0;j<i;j++){\n\t\t\tC a=Cs[i], b=Cs[j];\n\t\t\tif(abs(a.p-b.p) < EPS) continue;\n\t\t\tif(abs(a.p-b.p) > a.r+b.r) continue;\n\t\t\tif(abs(a.p-b.p) < abs(a.r-b.r)) continue;\n\t\t\tpair<P, P> c = cc_cross(a, b);\n\t\t\tintersects.push_back(c.first);\n\t\t\tintersects.push_back(c.second);\n\t\t}\n\t}\n//\tprintf(\"%d %d\\n\", intersects.size(), Cs.size());\n\tfor(i=0;i<intersects.size();i++){\n//\t\tprintf(\"circle(%f, %f, 2)\\n\", intersects[i].X+100, intersects[i].Y+100);\n\t\tfor(j=0;j<Cs.size();j++){\n\t\t\tif(abs(Cs[j].p - intersects[i]) > Cs[j].r + EPS) break;\n\t\t}\n\t\tif(j==Cs.size()) return true;\n\t}\n\treturn false;\n}\nmain(){\n\tint h,w,i,j;\n\t\n\twhile(cin >> n, n){\n\t\tvector<C> Cs;\n\t\tdouble minl=300;\n\t\tfor(i=0;i<n;i++){\n\t\t\tdouble x,y,l;\n\t\t\tcin >> x >> y >> l;\n\t\t\tCs.push_back((C){P(x,y),l});\n\t\t\tminl = min(minl, l);\n\t\t}\n//\t\tcheck(Cs, 20);\n//\t\treturn 0;\n\t\tdouble high = minl, low=0;\n//\t\tprintf(\"high = %f\\n\", high);\n\t\twhile(high-low > EPS){\n\t\t\tdouble mid = (high+low)/2;\n//\t\t\tprintf(\"mid = %f\\n\", mid);\n\t\t\tif(check(Cs, mid)) low = mid;\n\t\t\telse high = mid;\n\t\t}\n\t\tprintf(\"%.7f\\n\", high);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//reference to\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2243124#1\n\n#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ndouble d2r(int d){\n  return (1.0 * d/180)*PI;\n}\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nP inputP(){\n  double x,y;\n  cin >> x >> y;\n  return P(x,y);\n}\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void input() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\nclass G {\n  public:\n    vector<P> g;\n    vector<L> l;\n    ll n;\n    G(){};\n    G(int _n):n(_n){\n      double x,y;\n      l.resize(n),g.resize(n);\n      rep(i,n){\n        cin >> x >> y;\n        g[i] = (P(x,y));\n      }\n      rep(i,n){\n        l[i] = L(g[i],g[(i+1)%n]);\n      }\n    }\n    G (vector<P> ps){\n      n = ps.size();\n      g.resize(n),l.resize(n);\n      rep(i,n){\n        g[i] = ps[i];\n      }\n      rep(i,n){\n        l[i] = L(g[i],g[(i+1)%n]);\n      }\n    }\n    P& operator[](int i){\n      return g[i];\n    }\n    void push_back(P p){\n      g.push_back(p);\n    }\n    size_t size(){\n      return g.size();\n    }\n    void resize(int n){\n      g.resize(n),l.resize(n);\n    }\n    friend ostream& operator<<(ostream& os,const G& g){\n      rep(i,g.n){\n        if(i) os << ' ';\n        os << g.g[i] ;\n      }\n      return os;\n    }\n};\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n  void input(){\n    double x,y;\n    cin >> x >> y >> r;\n    p = P(x,y);\n  }\n};\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L l,  L m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L l,  L s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L l,  P p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L s,  L t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L s,  P p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nbool intersectSG(L l, G g) {\n  int n = g.size();\n  rep(i, n) {\n    if (intersectSS(l, L(curr(g, i), next(g, i)))) {\n      return true;\n    }\n  }\n  return false;\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L l,  P p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L l,  L m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L l,  L s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L s,  P p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L s,  L t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P p, P q){\n  return abs(p - q) ;\n}\ndouble distanceSG(L l, G g) {\n  double d = INF;\n  rep(i, g.size()) {\n    d = min(d, distanceSS(l, L(curr(g, i), next(g, i))));\n  }\n  return d;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP crosspointSS(L &l1,L &l2) {\n  double d1 = abs(cross(l2.v, l1[0] - l2[0])); // l1.a - l2.b???\n  double d2 = abs(cross(l2.v, l1[1] - l2[0]));\n  double t = d1 / (d1 + d2);\n  return l1[0] + t * l1.v;\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\nvector<P> crosspoint(const C &a,const C &b){\n  vector<P> res;\n  double d = abs(a.p - b.p);\n  double rc = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n  double dfr = a.r * a.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  double rs = sqrt(dfr);\n  P diff = (b.p - a.p) / d;\n  res.push_back(a.p + diff * P(rc, rs));\n  if (dfr != 0.0) res.push_back(a.p + diff * P(rc, -rs));\n  return res;\n}\n// a < b : -1, a > b : 1, a == b : 0\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\nint circle_judge(C &a,C &b){ // return tangent count\n  double d = distancePP(a.p,b.p);\n  double e = a.r,f = b.r;\n  if(sgn(d,e+f) == 1) return 4;\n  if(sgn(d,e+f) == 0) return 3;\n  if(sgn(d,abs(e-f)) == -1) return 0;\n  if(sgn(d,abs(e-f)) == 0 ) return 1;\n  return 2;\n}\ndouble calc_triangle(P a,P b,P c){\n  P ba = (b - a);\n  P ca = (c - a);\n  return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n}\ndouble calc_area(G &g){\n  double res = 0;\n  rep(i,g.size()-2){\n    res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n  }\n  return res;\n}\nbool is_convex(G &g){\n  if(g.size() == 3) return true;\n  rep(i,g.size()){\n    if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n      return false;\n    }\n  }\n  return true;\n}\nint convex_point(G &g,const P &p){\n  P q = p-P(-INF,imag(p));\n  double x = real(p),y = imag(p);\n  L l1(p,q);\n  ll cn = 0;\n  rep(i,g.size()){\n    P a = g[i],b = g[(i+1) % g.size()];\n    L l2 = L(a,b);\n    int k = ccw(a,b,p);\n    if(k == 0){\n      return 1; // p on g\n    }\n  }\n  rep(i,g.size()){\n    P a = g[i],b = g[(i+1) % g.size()];\n    double y1 = imag(a),y2 = imag(b);\n    if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n      L l2 = L(a,b);\n      P c = crosspoint(l1,l2);\n      if(x < real(c))\n        ++cn;\n    }\n  }\n  if(cn % 2) return 2; // p in g\n  return 0; // p out g\n}\ndouble distance(G &g, P &p){\n  if(convex_point(g,p)) return 0;\n  double res = INF;\n  ll N = g.size();\n  rep(i,N){\n    L l = L(g[i],g[(i+1)%N]);\n    res = min(res,distanceSP(l,p));\n  }\n  return res;\n}\n\ndouble distance(G &g, G &h){\n  double res = INF;\n  ll N = g.size();\n  ll M = h.size();\n  rep(i,N){\n    L l = L(g[i],g[(i+1)%N]);\n    rep(j,M){\n      L k = L(h[j],h[(j+1)%M]);\n      res = min(res,distanceSS(l,k));\n    }\n  }\n  return res;\n}\nvector<P> convex_hull(vector<P> &ps){\n  sort(all(ps));\n  int k = 0;\n  int n = ps.size();\n  vector<P> qs(ps.size() * 2);\n  rep(i,ps.size()){\n    while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2,t = k; i >= 0; i--){\n    while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i] ;\n  }\n  qs.resize(k-1);\n  return qs;\n}\ndouble convex_diameter(vector<P> &ps){\n  const int n = ps.size();\n  int is = 0,js = 0;\n  REP(i,1,n){\n    if(imag(ps[i]) > imag(ps[is])) is = i;\n    if(imag(ps[i]) < imag(ps[js])) js = i;\n  }\n  double d = norm(ps[is]-ps[js]);\n  int im,jm,i,j;\n  i = im = is;\n  j = jm = js;\n  do {\n    if(cross(diff(ps,i),diff(ps,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if(norm(ps[i]-ps[j]) > d){\n      d = norm(ps[i]-ps[j]);\n      im = i,jm = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(d);\n}\nG convex_cut(G &g, L &l) {\n  G h;\n  rep(i, (int)g.size()) {\n    P p = curr(g, i), q = next(g, i);\n    if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n      if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n      else return G{};                        // p -- l.b -- l.a -- q\n    }\n    if (ccw(l[0], l[1], p) != -1) h.push_back(p);\n    if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0){\n      L t = L(p,q);\n      h.push_back(crosspoint(t, l));\n    }\n  }\n  return h;\n}\ndouble closestPair_calc(P *p,int n){\n  if(n < 2) return INF;\n  int m = n/2;\n  double x=real(p[m]);\n  double d = min(closestPair_calc(p,m),closestPair_calc(p+m,n-m));\n  inplace_merge(p,p+m,p+n,sorty);\n  vector<P> q;\n  double dx,dy;\n  rep(i,n) {\n    if(abs(real(p[i])-x)>=d)continue;\n\n    for(int j=q.size()-1;j>=0;j--)\n    {\n      dx=real(p[i])-real(q[j]);\n      dy=imag(p[i])-imag(q[j]);\n      if(dy>=d)break;\n      d=min(d,sqrt(dx*dx+dy*dy));\n    }\n    q.push_back(p[i]);\n  }\n  return d;\n}\n\ndouble closestPair(vector<P> &p,int n) {\n  if(n < 2) return 0.0;\n  sort(all(p));\n  double ans = closestPair_calc(&p[0],n);\n  return ans == INF ? 0.0 : ans;\n}\n//3D\ndouble add(double a, double b) {\n  if (abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n  return a + b;\n}\nstruct Point {\n  double x, y, z;\n  Point() {}\n  Point(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n  void input(){\n    cin >> x >> y >> z;\n  }\n  const Point operator+ (const Point &p) {\n    return Point(add(this->x, p.x), add(this->y, p.y), add(this->z, p.z));\n  }\n  const Point operator- (const Point &p) {\n    return Point(add(this->x, -p.x), add(this->y, -p.y), add(this->z, -p.z));\n  }\n  const Point operator* (double d) {\n    return Point(this->x * d, this->y * d, this->z * d);\n  }\n  double norm() {\n    return this->x * this->x + this->y * this->y + this->z * this->z;\n  }\n  double distance() {\n    return sqrt(this->norm());\n  }\n};\n\ndouble dot(const Point &p1, const Point &p2) {\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\nPoint cross(const Point &p1, const Point &p2) {\n  return Point(p1.y * p2.z - p2.y * p1.z, -(p1.x * p2.z - p2.x * p1.z), p1.x * p2.y - p2.x * p1.y);\n}\n\nstruct Line {\n  Point a, b, dis;\n  Line() {}\n  Line(const Point &_a, const Point &_b) : a(_a), b(_b), dis(b - a) {}\n  void input(){\n    a.input();\n    b.input();\n    *this = Line(a,b);\n  }\n  double dist2() {\n    const double X = this->a.x - this->b.x;\n    const double Y = this->a.y - this->b.y;\n    const double Z = this->a.z - this->b.z;\n    return X * X + Y * Y + Z * Z;\n  }\n  double dist() {\n    return sqrt(this->dist2());\n  }\n};\nusing Segment = Line;\n\ndouble distanceLineToPoint(Line &l, Point &p) {\n  return cross(l.dis, p - l.a).distance() / l.dis.distance();\n}\n\ndouble distanceSegmentToPoint(Segment &l, Point &p) {\n  if (dot(l.b - l.a, p - l.a) < 0) {\n    auto buf = p - l.a;\n    return buf.distance();\n  }\n  if (dot(l.a - l.b, p - l.b) < 0) {\n    auto buf = p - l.b;\n    return buf.distance();\n  }\n  return distanceLineToPoint(l, p);\n}\n\nstruct Ball {\n  Point center;\n  double r;\n  Ball() {}\n  Ball(double _x, double _y, double _z, double _r) : center(_x, _y, _z), r(_r) {}\n  Ball(const Point &_c, double _r) : center(_c), r(_r) {}\n  void input(){\n    center.input();\n    cin >> r;\n  }\n  bool inside(const Point &p) {\n    const double X = p.x - this->center.x;\n    const double Y = p.y - this->center.y;\n    const double Z = p.z - this->center.z;\n    return sgn(X * X + Y * Y + Z * Z, -(this->r * this->r)) == -1;\n  }\n  bool inside(Segment &s) {\n    return sgn(distanceSegmentToPoint(s, this->center) - this->r) == -1;\n  }\n  bool on_surface(const Point &p) {\n    const double X = p.x - this->center.x;\n    const double Y = p.y - this->center.y;\n    const double Z = p.z - this->center.z;\n    return sgn(X * X + Y * Y + Z * Z, -(this->r * this->r)) == 0;\n  }\n  bool on_surface(Segment &s) {\n    return sgn(distanceSegmentToPoint(s, this->center) - this->r) == 0;\n  }\n};\nll n;\nusing pd = pair<P,double>;\nvector<pd> v;\n\nP interDiv(P p,P q,double a,double b){\n  return ((p * b + q * a)/(a+b));\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> n,n){\n    v.resize(n);\n    rep(i,n){\n      ll k;\n      P p = inputP();\n      cin >> k;\n      v[i] = mp(p,k);\n    }\n    auto check = [&](double h){\n      vector<double> rs(n);\n      rep(i,n){\n        double r = v[i].se * v[i].se - h * h;\n        if(r < 0) return false;\n        rs[i] = sqrt(r);\n      }\n      vector<C> cs;\n      rep(i,n){\n        cs.pb(C(v[i].fi,rs[i]));\n      }\n      vector<P> kh;\n      rep(i,n){\n        kh.pb(cs[i].p);\n      }\n      rep(i,n){\n        REP(j,i+1,n){\n          auto vs = crosspoint(cs[i],cs[j]);\n          for(auto &u : vs){\n            kh.pb(u);\n          }\n        }\n      }\n      for(auto &p : kh){\n        bool f = true;\n        rep(i,n){\n          if(abs(p - v[i].fi) > rs[i] + EPS){\n            f = false;\n            break;\n          }\n        }\n        if(f) return true;\n      }\n      return false;\n    };\n    double lb = 0,ub = 1000.0;\n    rep(i,100){\n      double h = (lb+ub)/2;\n      if(check(h)){\n        lb = h;\n      }\n      else\n        ub = h;\n    }\n    std::fcout(10) << ub << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define pb push_back\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\ninline ld dist(const po &p, const li &l){\n\treturn abs(l(p))/sqrt(l.a*l.a+l.b*l.b);\n}\n\nstruct ci{\n\tpo c;\n\tld r;\n\tinline bool internal(const po &p){\n\t\treturn dist(p,c) <= r+1e-9;\n\t}\n};\n\nci circum(const po &p,const po &q,const po &r){\n\tci ret;\n\tli l = perpen((p+q)/2.0,li(p,q));\n\tli m = perpen((q+r)/2.0,li(q,r));\n\tpo* _c;\n\tintersect(l,m,_c);\n\tif(_c == nullptr){\n\t\tret.c = po(0.0,0.0);\n\t\tret.r = -1.0;\n\t\treturn ret;\n\t}\n\telse {\n\t\tret.c = *_c;\n\t\tret.r = dist(ret.c,p);\n\t\tdelete _c;\n\t\treturn ret;\n\t}\n}\n\n\nvoid intersect(const li &l, const ci &c, po* &ret1, po* &ret2){\n\tld d = dist(c.c,l);\n\tif(d > c.r+1e-9){\n\t\tret1 = nullptr;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tpo h = perpen_leg(c.c,l);\n\tif(abs(d-c.r) <= 1e-9){\n\t\tret1 = new po;\n\t\t*ret1 = h;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tret1 = new po;\n\t*ret1 = h+(c.c-h)*po(0.0,sqrt((c.r*c.r-d*d)/((c.c-h)(c.c-h))));\n\tret2 = new po;\n\t*ret2 = 2*h-*ret1;\n\treturn;\n}\nvoid intersect(const ci &c, const ci &d, po* &ret1, po* &ret2){\n\tli l;\n\tl.a = 2*(c.c.x-d.c.x);\n\tl.b = 2*(c.c.y-d.c.y);\n\tl.c = d.c(d.c)-d.r*d.r-(c.c(c.c)-c.r*c.r);\n\tintersect(l,c,ret1,ret2);\n}\nvoid tangent(const po &p, const ci &c,li* &ret1,li* &ret2){\n\tci d;\n\td.c = (p+c.c)/2.0;\n\td.r = dist(p,c.c)/2.0;\n\tpo *q,*r;\n\tintersect(c,d,q,r);\n\tret1 = ret2 = nullptr;\n\tif(q == nullptr)return;\n\tret1 = new li;\n\t*ret1 = li(p,*q);\n\tdelete q;\n\tif(r == nullptr)return;\n\tret2 = new li;\n\t*ret2 = li(p,*r);\n\tdelete r;\n}\nvoid cotan_in(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tpo p = similar(-c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\nvoid cotan_out(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tif(abs(c.r-d.r) < 1e-9){\n\t\tret1 = new li;\n\t\tret2 = new li;\n\t\t*ret1 = *ret2 = li(c.c,d.c);\n\t\tret1->c += c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\tret2->c -= c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\treturn;\n\t}\n\tpo p = similar(c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\t\tci p[12];\n\t\trep1(i,n){\n\t\t\tp[i].c.in();\n\t\t\tscanf(\"%Lf\",&p[i].r);\n\t\t}\n\t\tld l = 0.0, r = 300.0;\n\t\trep1(i,n){\n\t\t\tld _l = p[i].r;\n\t\t\trep1(j,n){\n\t\t\t\tld d2 = p[j].r*p[j].r-(p[i].c-p[j].c)(p[i].c-p[j].c);\n\t\t\t\tif(d2 <= 1e-9)_l = 0.0;\n\t\t\t\telse _l = min( _l , sqrt(d2) );\n\t\t\t}\n\t\t\tl = max( l , _l );\n\t\t}\n\t\twhile(r-l>0.0000001){\n\t\t\tld m = (l+r)/2.0;\n\t\t\tbool ret = true;\n\t\t\tci _p[12];\n\t\t\trep1(i,n){\n\t\t\t\t_p[i] = p[i];\n\t\t\t\tif(_p[i].r <= m+1e-9)ret = false;\n\t\t\t\telse _p[i].r = sqrt(_p[i].r*_p[i].r-m*m);\n\t\t\t}\n\t\t\tif(!ret){\n\t\t\t\tr = m;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = false;\n\t\t\tvector<po*> vec;\n\t\t\tpo *q[2];\n\t\t\trep1(i,n)for(int j = i+1 ; j <= n ; j ++){\n\t\t\t\tintersect(_p[i],_p[j],q[0],q[1]);\n\t\t\t\trep(k,2)if(q[k] != nullptr)vec.pb(q[k]);\n\t\t\t}\n\t\t\tfor(po* _q: vec){\n\t\t\t\tbool _ret = true;\n\t\t\t\trep1(i,n)_ret &= dist(*_q,_p[i].c) <= _p[i].r+1e-9;\n\t\t\t\tdelete _q;\n\t\t\t\tif(_ret)ret = true;\n\t\t\t}\n\t\t\tif(ret)l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.12f\\n\",(double)l);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n \nusing namespace std;\n \n#define EPS 1e-9\n \nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n  \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n} \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n  \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n  \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n \nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n \npoint rot(point p, double a) {\n    point ret;\n    double C = cos(a), S = sin(a);\n    ret.x = p.x*C - p.y*S;\n    ret.y = p.x*S + p.y*C;\n    return ret;\n}\n \ndouble aaa[1111111];\nint cs=0;\n \nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n#endif\n    while(1) {\n        scanf(\"%d\",&n); \n        if(n==0) break;\n        for(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n \n        double ans = -1e20;\n        for(int i=0;i<n;++i) {\n            double tmp = r[i];\n            bool can = 1;\n            for(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n            if(can) ans = max(ans, tmp);\n        }\n \n        for(int i=0;i<n;++i) {\n            memcpy(cP,P,sizeof(cP));\n            for(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n            for(int j=0;j<n;++j) if(j!=i) {\n                double d = dis(cP[i],cP[j]);\n                if(r[i]+r[j] < d-EPS) continue;\n                if(abs(r[i]-r[j]) > d+EPS) continue;\n \n                memcpy(nP,cP,sizeof(nP));\n                double a = atan2(cP[j].y,cP[j].x);\n                for(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n                if(abs(nP[j].x) < 1e-9) continue;\n \n                bool can = 1;\n                point p1,p2;\n                intersection_circle_circle(point(nP[j].x,nP[j].y),r[j],point(nP[i].x,nP[i].y),r[i],p1,p2);\n                double zz = max(p1.y,p2.y), yy = 0;\n                double xx = p1.x;\n                for(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n                if(can)\n                    ans = max(ans, zz);\n \n                double rr = zz;\n                for(int k=0;k<n;++k) nP[k].x -= xx;\n                for(int k=0;k<n;++k) if(k!=i && k!=j && abs(nP[k].x) <= r[k]+EPS){\n                    double nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n                    double d = abs(nP[k].y);\n                    if(nr+rr < d-EPS) continue;\n                    if(abs(nr-rr) > d+EPS) continue;\n                    if(d < 1e-9) continue;\n \n                    bool can = 1;\n                    point p1,p2;\n                    intersection_circle_circle(point(0,0),rr,point(nP[k].y,0),nr,p1,p2);\n                    double zz = max(p1.y,p2.y), xx = 0;\n                    double yy = p1.x;\n                    for(int h=0;h<n;++h) if(sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)) > r[h] + EPS) {\n                        can = 0;\n                    }\n                    if(can)\n                        ans = max(ans, zz);\n                }\n            }\n        } printf(\"%.10lf\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc != ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) || cc != ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint N;\ndouble xs[11];\ndouble ys[11];\ndouble ls[11];\n\ntypedef complex<double> P;\n\n// 三角形の面積をヘロンの公式で３辺から計算\ndouble calcTriangleArea(double a,double b,double c){\n  double s=(a+b+c)/2;\n  if(EQ(abs(sqrt(s*(s-a)*(s-b)*(s-c))),0))return 0;\n  return sqrt(abs(s*(s-a)*(s-b)*(s-c)));\n}\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 内積\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(const P &a1, const P &a2, const P &b1, const P &b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nbool EQV(P &p1,P &p2){\n  return (EQ(p1.real(),p2.real())&&EQ(p1.imag(),p2.imag()));\n}\n\ndouble calcHeight(P s1,P s2,P pb,double r,int idx3){\n  P p3=P(xs[idx3],ys[idx3]);\n  // cout<<endl;\n  // cout<<abs(p3-s1)<<\" \";\n  // cout<<abs(p3-s2)<<\" \";\n  // cout<<p3<<\" \"<<s1<<\" \"<<s2<<endl;\n  //cout<<abs(p3-s2)<<endl;\n  //cout<<s1<<\" \"<<s2<<\" \"<<pb<<\" \"<<p3<<\" \"<<r<<endl;\n  double ub=0.5;\n  double lb=0;\n  for(int ite=0;ite<200;ite++){\n    double mid=(ub+lb)/2;\n    // s1-s2のベクトル\n    P e=(s2-s1)/*/abs(s2-s1)*/;\n    // 候補となる円弧の場所を(x,y)平面に射影した時の座標\n    P p=e*mid+s1;\n    // 風船の座標からの距離\n    double a=abs(pb-p);\n    double z=sqrt(r*r-a*a);\n    //cout<<r<<\" \"<<a<<endl;\n    // 距離を計算\n    double dist=sqrt(z*z+pow(p.real()-p3.real(),2)+pow(p.imag()-p3.imag(),2));\n    // 長すぎたら,長さを抑える\n    if(dist>ls[idx3]||EQ(dist,ls[idx3]))ub=mid;\n    else lb=mid;\n  }\n  // ubの長さで計算したときに、結果がどうなるか\n  double mid=ub;\n  //cout<<mid<<endl;\n  // s1-s2のベクトル\n  P e=(s2-s1);\n  // 候補となる円弧の場所を(x,y)平面に射影した時の座標\n  P p=e*mid+s1;\n  // 風船の座標からの距離\n  double a=abs(pb-p);\n  double z=sqrt(r*r-a*a);\n  //cout<<p<<\" \"<<r<<\" \"<<a<<\" \"<<abs(s1-p3)<<endl;\n  // 距離を計算\n  double dist=sqrt(z*z+pow(p.real()-p3.real(),2)+pow(p.imag()-p3.imag(),2));\n  // cout<<s1<<\" \"<<s2<<\" \"<<pb<<\" \"<<r<<\" \"<<idx3<<endl;\n  // cout<<dist<<\" \"<<z<<\" \"<<p<<endl;\n  //cout<<dist<<endl;\n  // 距離がマッチするか\n  if(!EQ(dist,ls[idx3]))return -1;\n  return z;\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++)cin>>xs[i]>>ys[i]>>ls[i];\n    double res=1e+10;\n    for(int mask=1;mask<(1<<N);mask++){\n      const int cnt=popcount(mask);\n      int ary[10];\n      int idx=0;\n      for(int i=0;i<N;i++)if((mask>>i)&1)ary[idx++]=i;\n      vector<pii> v;\n      for(int i=0;i<idx;i++)\n        v.push_back(pii(ls[ary[i]],ary[i]));\n      sort(v.begin(),v.end());\n      for(int i=0;i<idx;i++)\n        ary[i]=v[i].second;\n      if(cnt==1)res=min(res,ls[ary[0]]);\n      else if(cnt==2){\n        // 2つの要素の長さで条件分岐\n        int idx1=ary[0];\n        int idx2=ary[1];\n        // idx1のほうが高さが小さくなるように\n        if(ls[idx1]>ls[idx2])swap(idx1,idx2);\n        P p1=P(xs[idx1],ys[idx1]);\n        P p2=P(xs[idx2],ys[idx2]);\n        const double x=abs(p1-p2)/*dist(idx1,idx2)*/;\n        const double y=sqrt(ls[idx1]*ls[idx1]+x*x);\n        // 2線が届かない場合、だめ\n        if(EQ(ls[idx1]+ls[idx2],x)||ls[idx1]+ls[idx2]>x){\n          if(EQ(y,ls[idx2])||y<ls[idx2])res=min(res,ls[idx1]);\n          // 両方に引っ張られる形で高さが決まる\n          else{\n            const double S=calcTriangleArea(x,ls[idx1],ls[idx2]);\n            const double h=2*S/x;\n            res=min(res,h);\n          }\n        }\n      }\n      // 3つの点があるとき\n      else if(cnt==3){\n        do{\n          int idx1=ary[0];\n          int idx2=ary[1];\n          int idx3=ary[2];\n          // idx1のほうが高さが小さくなるように\n          // if(ls[idx1]>ls[idx2])continue;\n          if(ls[idx1]>ls[idx2])swap(idx1,idx2);\n          \n          \n          P p1=P(xs[idx1],ys[idx1]);\n          P p2=P(xs[idx2],ys[idx2]);\n          P p3=P(xs[idx3],ys[idx3]);\n          const double x=abs(p1-p2)/*dist(idx1,idx2)*/;\n          const double y=sqrt(ls[idx1]*ls[idx1]+x*x);\n          // 2線が届かない場合、だめ\n          if(EQ(ls[idx1]+ls[idx2],x)||ls[idx1]+ls[idx2]>x){\n            // 高さを計算\n            double h=0;\n            if(!EQ(y,ls[idx2])&&y<ls[idx2]){\n              continue;\n            }\n            // 両方に引っ張られる形で高さが決まる\n            else{\n              const double S=calcTriangleArea(x,ls[idx1],ls[idx2]);\n              h=2*S/x;\n            }\n            //cout<<\"height:\"<<h<<endl;\n            // 風船の位置する(x,y)座標を計算\n            double x1=sqrt(ls[idx1]*ls[idx1]-h*h);\n            double x2=sqrt(ls[idx2]*ls[idx2]-h*h);\n            // p1->p2の単位ベクトルを求めておく\n            // そのベクトルをx1/(x1+x2)倍し、p1を足して、風船の座標を計算する\n            P e=(p2-p1)/abs(p2-p1);\n            // 風船の座標\n            P pb=(p2-p1)*(x1/(x1+x2))+p1;\n\n            // p1-p2の向きから90度回転させた方向に、高さhだけいったところに線分を引く\n            // 回転は２方向試す\n            // その線分が、弧の射影となる\n            // 線分\n            P s1=roundPoint(e,PI/2)*h+pb;\n            P s2=roundPoint(e,-PI/2)*h+pb;\n            // 近いほうをlbの方向としておく\n            //if(idx1==7&&idx2==1&&idx3==3){\n            double z;\n            if(abs(s1-p3)>abs(s2-p3))z=calcHeight(s2,s1,pb,h,idx3);\n            else z=calcHeight(s1,s2,pb,h,idx3);\n            \n            // P tmp=p1+p2;tmp*=0.5;\n            // cout<<tmp<<endl;\n            //cout<<pb<<endl;\n            //cout<<x1<<\" \"<<x2<<endl;\n            \n            // cout<<s1<<\" \"<<s2<<\" \"<<h<<endl;\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<\" \"<<z<<endl;\n            // cout<<abs(s1-p3)<<endl;\n            if(!EQ(0,z)&&z>0)res=min(res,z);\n            // cout<<idx1<<\" \"<<idx2<<endl;\n            // cout<<z<<endl;\n            //}\n          }\n          break;\n        }while(next_permutation(ary,ary+idx));\n      }\n    }\n    printf(\"%.10f\\n\",res);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(x, p.x), add(y, p.y));\n  }\n  P operator - (P p) {\n    return P(add(x, -p.x), add(y, -p.y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  P operator / (double d) {\n    return P(x / d, y / d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p) {\n  //for (int i = 0; i < n; i++) printf(\"%f \",(add((p - dir[i]).square(), -r[i] * r[i])));\n  //printf(\"\\n\");\n  for (int i = 0; i < n; i++) if (0.000009 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) return false;//r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i], -h * h));\n  //  printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 / (l1 + l2) + dir[j] * l1 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d)) return true;\n        if (canClear(ave - d)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t])) return true;\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n    //printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n    //printf(\"%d\\n\",(int)check(13.02));\n//    printf(\"%d\\n\",(int)check(225.25));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%.7f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tC(){}\n\t\tC(const P& p, const R r):P(p), r(r){}\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tstruct F : public C{\n\t\tR s, t;\n\t\tF(const C &c, R ss, R tt):C(c), s(ss), t(tt){\n\t\t\tif(PI < s) s -= 2*PI;\n\t\t\tif(PI < t) t -= 2*PI;\n\t\t}\n\t\tBOOL inside(const P& p)const {\n\t\t\tP v = p - SELF;\n\t\t\tif(!sig(norm(v))) return BORDER;\n\t\t\tR a = arg(v);\n\t\t\tif(t < s){\n\t\t\t\tif((!less(s, a) && !less(a, t)) || !less(norm(v), r*r)) return FALSE;\n\t\t\t\treturn less(s, a) | less(a, t) | less(norm(v), r*r);\n\t\t\t}else{\n\t\t\t\tif(!less(s, a) || !less(a, t) || !less(norm(v), r*r)) return FALSE;\n\t\t\t\treturn less(s, a) | less(a, t) | less(norm(v), r*r);\n\t\t\t}\n\t\t}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tinline P reflect(const P &s, const L &t){return 2.*proj(s, t) - s;}\n\tinline S reflect(const S &s, const L &t){return S(reflect(s[0], t), reflect(s[1], t));}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\t\n\t/*\n\t * CCWでs[0]->s[1]にかけてが共通部分\n\t */\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,-1)*h, c1 + u*x + u*P(0,1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline S crosspoint(const C &c, const L &l){\n\t\tR d2 = dist2(l, c);\n\t\tif(c.r*c.r+EPS < d2) return S();\n\t\tP m = proj(c, l);\n\t\tP u = unit(l[1]-l[0]);\n\t\tR d = sqrt(c.r*c.r - d2);\n\t\treturn S(m+u*d, m-u*d);\n\t}\n\tinline vector<P> crosspoint(const C &c, const S &s){\n\t\tvector<P> res = crosspoint(c, (const L&)s);\n\t\tRREP(i, res.size()){\n\t\t\tif(inp(res[i]-s[0], s.dir())*inp(res[i]-s[1], -s.dir())<EPS)\n\t\t\t\tres.erase(res.begin() + i);\n\t\t}\n\t\treturn res;\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tvector<L> CommonTangent(C c1, C c2){\n\t\tif(c1.r > c2.r) swap(c1, c2);\n\t\tdouble d = abs(c1-c2);\n\t\tvector<L> res;\n\t\tif(d < EPS) return res;\n\t\tif(d + EPS > c1.r + c2.r){\n\t\t\t// 内接線\n\t\t\tP crs = (c1*c2.r + c2*c1.r) / (c1.r + c2.r);\n\t\t\tdouble rad = asin(c1.r/abs(crs-c1));\n\t\t\tres.push_back(L(crs, crs + (c1-crs)*polar(1., rad)));\n\t\t\tres.push_back(L(crs, crs + (c1-crs)*polar(1., -rad)));\n\t\t}\n\t\tif(c1.r + d + EPS > c2.r){\n\t\t\t// 外接線\n\t\t\tdouble rad = 0.5*PI+asin((c2.r-c1.r) / d);\n\t\t\tP v = unit(c2-c1)*polar(1., rad);\n\t\t\tif(c1.r + d - EPS < c2.r){\n\t\t\t\tres.push_back(L(c1+v*c1.r, c1+v*c1.r+(c1-c2)*P(0, 1)));\n\t\t\t}else{\n\t\t\t\tres.push_back(L(c1+v*c1.r, c2+v*c2.r));\n\t\t\t\tv = 2.*proj(v, c2-c1) - v;\n\t\t\t\tres.push_back(L(c1+v*c1.r, c2+v*c2.r));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n\n\tstruct min_ball {\n\t\tP center;\n\t\tR radius2;\n\t\tmin_ball(const vector<P>& p) {\n\t\t\tFOR(it, p) ps.push_back(*it);\n\t\t}\n\t\tmin_ball& compile() {\n\t\t\tm = 0;\n\t\t\tcenter = P(0, 0);\n\t\t\tradius2 = -1;\n\t\t\tmake_ball(ps.end());\n\t\t\treturn *this;\n\t\t}\n\tprivate:\n\t\tlist<P> ps;\n\t\tlist<P>::iterator supp_end;\n\t\tint m;\n\t\tP v[3], c[3];\n\t\tR z[3], r[3];\n\t\tvoid pop() { --m; }\n\t\tvoid push(const P& p) {\n\t\t\tif (m == 0) {\n\t\t\t\tc[0] = p; r[0] = 0;\n\t\t\t} else {\n\t\t\t\tR e = norm(p-c[m-1]) - r[m-1];\n\t\t\t\tP delta = p - c[0];\n\t\t\t\tv[m] = p - c[0];\n\t\t\t\tfor (int i = 1; i < m; ++i)\n\t\t\t\t\tv[m] -= v[i] * inp(v[i], delta) / z[i];\n\t\t\t\tz[m] = inp(v[m], v[m]);\n\t\t\t\tc[m] = c[m-1] + e*v[m]/z[m]*.5;\n\t\t\t\tr[m] = r[m-1] + e*e/z[m]*.25;\n\t\t\t}\n\t\t\tcenter\t= c[m];\n\t\t\tradius2 = r[m]; ++m;\n\t\t}\n\t\tvoid make_ball(list<P>::iterator i) {\n\t\t\tsupp_end = ps.begin();\n\t\t\tif (m == 3) return;\n\t\t\tfor (list<P>::iterator k = ps.begin(); k != i; ) {\n\t\t\t\tlist<P>::iterator j = k++;\n\t\t\t\tif (norm(*j-center) > radius2) {\n\t\t\t\t\tpush(*j); make_ball(j); pop();\n\t\t\t\t\tmove_to_front(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid move_to_front(list<P>::iterator j) {\n\t\t\tif (supp_end == j) ++supp_end;\n\t\t\tps.splice (ps.begin(), ps, j);\n\t\t}\n\t};\n\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tbool operator==(const P &a, const P &b){return !sig(norm(a-b));}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n//\tconst double Z = 3;\n//\tostream& operator<<(ostream &os, const P &p){return os << \"circle(\"<<Z*(100+p.X)<<\", \"<<Z*(100-p.Y)<<\", 2)\";}\n//\tostream& operator<<(ostream &os, const C &c){return os << \"circle(\"<<Z*(100+c.X)<<\", \"<<Z*(100-c.Y)<<\", \"<<Z*(c.r)<<\")\";}\n//\tostream& operator<<(ostream &os, const S &s){return os << \"line(\"<<Z*(100+s[0].X)<<\", \"<<Z*(100-s[0].Y)<<\", \"<<Z*(100+s[1].X)<<\", \"<<Z*(100-s[1].Y)<<\")\";}\n}\n\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<C> c(n);\n\t\tREP(i, n) cin >> c[i];\n\t\tvector<P> cand;\n\t\tvector<L> l;\n\t\tREP(i, n){\n\t\t\tcand.push_back(c[i]);\n\t\t\tREP(j, i){\n\t\t\t\tR d = norm(c[i] - c[j]);\n\t\t\t\tP m = (c[i]*(c[j].r*c[j].r - c[i].r*c[i].r + d) + c[j]*(c[i].r*c[i].r - c[j].r*c[j].r + d))/(2*d);\n\t\t\t\tcand.push_back(m);\n\t\t\t\tl.push_back(L(m, m + (c[i]-c[j])*P(0, 1)));\n\t\t\t}\n\t\t}\n\t\tREP(i, l.size())REP(j, i)if(sig(outp(l[i].dir(), l[j].dir())))\n\t\t\tcand.push_back(crosspoint(l[i], l[j]));\n\t\tR ans = 0;\n\t\tFOR(p, cand){\n\t\t\tR m = INF;\n\t\t\tREP(i, n) m = min(m, c[i].r*c[i].r - norm(c[i]-*p));\n\t\t\tif(m > 0) ans = max(ans, m);\n\t\t}\n\t\tprintf(\"%.14f\\n\", sqrt(ans));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <map>\n\n#define FOR(i,a,b) for(int i=(int)a; i<(int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\ntemplate<class T> void CHMAX(T & a, T b) { a = (a >= b ? a : b); }\nconstexpr int INFINT = (1 << 30) - 1;\nconstexpr double EPS = 1e-8;\nconstexpr double PI = 3.141592653589793238462643383279;\nusing ld = long double;\n\nstruct Point {\n\tld x, y;\n};\n\nint main() {\n\n\tint n;\n\twhile (std::cin >> n, n) {\n\t\tstd::vector<int> x(n), y(n), l(n);\n\t\tREP(i, n) std::cin >> x[i] >> y[i] >> l[i];\n\t\t\t\n\t\tauto check = [n,x,y,l](ld h) -> bool {\n\t\t\tstd::vector<ld> r(n);\n\t\t\tREP(i, n) {\n\t\t\t\tif (l[i] + EPS < h) return false;\n\t\t\t\tr[i] = std::sqrt(l[i] * l[i] - h * h);\n\t\t\t}\n\n\t\t\t// 円iに点pが入るか判定\n\t\t\tauto isInCircle = [&](int i, Point p) {\n\t\t\t\tld d = std::hypot(p.x - x[i], p.y - y[i]);\n\t\t\t\treturn d <= r[i] + EPS;\n\t\t\t};\n\n\t\t\t// 円の包含関係・接触チェック\n\t\t\tstd::vector<bool> valid(n, true);\n\t\t\tREP(i, n) REP(j, n) if (i != j) {\n\t\t\t\tld d = std::hypot(x[i] - x[j], y[i] - y[j]);\n\t\t\t\t// 包含関係\n\t\t\t\tif (d + r[i] <= r[j] + EPS) valid[j] = false;\n\t\t\t\t// 接触\n\t\t\t\tif (d + EPS > r[i] + r[j]) return false;\n\t\t\t}\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(i, n) cnt += valid[i];\n\t\t\t\tif (cnt <= 1) return true;\n\t\t\t}\n\n\t\t\t// 交点列挙\n\t\t\tstd::vector<Point> points;\n\t\t\tREP(i, n) FOR(j, i + 1, n) if (valid[i] && valid[j]) {\n\t\t\t\tld theta = std::atan2(y[j] - y[i], x[j] - x[i]);\n\t\t\t\tfor (ld ok : {theta, theta + PI * 2}) {\n\t\t\t\t\tld ng = theta + PI;\n\t\t\t\t\tREP(_, 50) {\n\t\t\t\t\t\tld me = (ok + ng) / 2;\n\t\t\t\t\t\tPoint p{ x[i] + r[i] * std::cos(me), y[i] + r[i] * std::sin(me) };\n\t\t\t\t\t\tif (isInCircle(j, p)) ok = me;\n\t\t\t\t\t\telse ng = me;\n\t\t\t\t\t}\n\t\t\t\t\tpoints.emplace_back(Point{ x[i] + r[i] * std::cos(ok), y[i] + r[i] * std::sin(ok) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 各交点がn-重複部分に含まれるか判定\n\t\t\tfor (const auto& p : points) {\n\t\t\t\tbool f = true;\n\t\t\t\tREP(i, n) {\n\t\t\t\t\tif (isInCircle(i, p)) continue;\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (f) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tld ok = 1., ng = 301;\n\t\tREP(_, 50) {\n\t\t\tld me = (ok + ng) / 2;\n\t\t\tif (check(me)) ok = me;\n\t\t\telse ng = me;\n\t\t}\n\t\tstd::cout << std::fixed << std::setprecision(10) << ok << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p(n);\n    double ll[n];\n    for(int i=0;i<n;i++) cin>>p[i].x>>p[i].y>>ll[i];\n    double l=0,r=400;\n    for(int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      bool f=1;\n      Circle c[n];\n      for(int j=0;j<n;j++){\n\tif(m>ll[j]){\n\t  f=0;\n\t  break;\n\t}\n\tc[j]=Circle(p[j],sqrt(ll[j]*ll[j]-m*m));\n      }\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  if(j==k) continue;\n\t  f&=abs(c[j].c-c[k].c)<(c[j].r+c[k].r);\n\t}\n      }\n      if(f) l=m;\n      else r=m;\n    }\n    printf(\"%.12lf\\n\",l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point {\n    double x, y;\n\n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n    \n    Point operator / (const double &k) const {\n        return Point(x / k, y / k);\n    }\n};\n\nPoint operator * (const Point &a, const Point &b)\n{\n    return Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\nbool c(double z, vector<Circle> c)\n{\n    int N = c.size();\n    for (int i = 0; i < N; i++) {\n        if (c[i].r * c[i].r < z*z) return 0;        \n        c[i].r = sqrt(c[i].r * c[i].r - z * z);\n    }\n    \n    for (int i = 0; i < N; i++) {        \n        for (int j = i+1; j < N; j++) {\n            double d = dist(c[i].p, c[j].p);\n            if (c[i].r + c[j].r < d) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\ndouble solve(vector<Circle> &cirs)\n{\n    double l = 0, r = 25252;\n    for (int i = 0; i < 150; i++) {\n        double z = (l + r) / 2;\n        if (c(z, cirs)) {\n            l = z;\n        } else {\n            r = z;\n        }\n    }\n    return l;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cirs(N);\n        for (int i = 0; i < N; i++) {\n            cin >> cirs[i].p.x >> cirs[i].p.y >> cirs[i].r;\n        }\n        printf(\"%.10f\\n\", solve(cirs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\ndouble x[15],y[15],L[15];\ntypedef complex<double> pt;\nvector<pt>List;\nvector<pt> CCintersect (pair<pt,double> c, pair<pt,double> d) {\n    vector<pt> ret;\n    double dist = abs(c.first - d.first);\n    double cr = c.second;\n    double dr = d.second;\n    \n    if (dist > cr + dr) return ret;\n    if (dist < abs(cr - dr)) return ret;\n    \n    double s = (cr + dr + dist) / 2.;\n    double area = sqrt(s * (s - cr) * (s - dr) * (s - dist));\n    double h = 2 * area / dist;\n    \n    pt v = d.first - c.first; v /= abs(v);\n    pt m = c.first + sqrt(cr * cr - h * h) * v;\n    pt n = v * pt(0, 1);\n    \n    List.push_back(m + n * h);\n    List.push_back(m - n * h);\n    return ret;\n}\n#define eps 1e-11\nint main(){\n    while(1){\n        cin >> n; if(!n) return 0;\n        for(int i=1;i<=n;i++){\n            scanf(\"%lf%lf%lf\",&x[i],&y[i],&L[i]);\n        }if(n==1) { printf(\"%.10f\",L[1]); puts(\"\"); continue;}\n        double lb = 1.0,ub = 305.0;\n        for(int r = 0;r < 100; r++){\n            double mid = (lb+ub)/2; bool ok = 0; List.clear();\n            for(int i=1;i<=n;i++){\n                if(mid > L[i]) goto fail;\n                List.push_back(pt(x[i],y[i]));\n            }\n            for(int i=1;i<=n;i++){\n                for(int j=i+1;j<=n;j++){\n                    pt x1 = pt(x[i],y[i]); double r1 = sqrt(L[i]*L[i]-mid*mid);\n                    pt x2 = pt(x[j],y[j]); double r2 = sqrt(L[j]*L[j]-mid*mid);\n                    CCintersect(make_pair(x1,r1),make_pair(x2,r2));\n                }\n            }\n            for(int i=0;i<List.size();i++){\n                for(int j=1;j<=n;j++){\n                    if(abs(List[i]-pt(x[j],y[j])) > sqrt(L[j]*L[j]-mid*mid)+eps) goto bad;\n                }\n                ok = 1; break; bad:;\n            }\n        fail:; if(ok) lb = mid; else ub = mid;\n        }\n        printf(\"%.10f\",(lb+ub)/2); puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint N;\ndouble xs[11];\ndouble ys[11];\ndouble ls[11];\n\ntypedef complex<double> P;\n\n// 三角形の面積をヘロンの公式で３辺から計算\ndouble calcTriangleArea(double a,double b,double c){\n  double s=(a+b+c)/2;\n  if(EQ(abs(sqrt(s*(s-a)*(s-b)*(s-c))),0))return 0;\n  return sqrt(abs(s*(s-a)*(s-b)*(s-c)));\n}\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 内積\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(const P &a1, const P &a2, const P &b1, const P &b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nbool EQV(P &p1,P &p2){\n  return (EQ(p1.real(),p2.real())&&EQ(p1.imag(),p2.imag()));\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 2点が作る三角形の高さ\ndouble getTriH(int idx1,int idx2){\n  P p1=P(xs[idx1],ys[idx1]);\n  P p2=P(xs[idx2],ys[idx2]);\n  const double x=abs(p1-p2);\n  // 高さを計算\n  const double S=calcTriangleArea(x,ls[idx1],ls[idx2]);\n  double h=2*S/x;\n  return h;\n}\n\nint main(){\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++)cin>>xs[i]>>ys[i]>>ls[i];\n    double ans=-1;\n    // 風船が真ん中にある場合の計算\n    double minHeight=1e+10;\n    int idx1=-1;\n    for(int i=0;i<N;i++){\n      double h=sqrt(abs(ls[i]*ls[i]-pow(abs(P(xs[i],ys[i])),2)));\n      if(minHeight>h){\n        minHeight=h;\n        idx1=i;\n      }\n    }\n    {\n      // idxの方向へ風船が移動する\n      // 初期の角度を求めておき、角度で二分探索を行う\n      double lb=asin(minHeight/ls[idx1]);\n      double ub=PI/2;\n      for(int ite=0;ite<200;ite++){\n        double mid=(ub+lb)/2;\n        // この角度の時の風船のx,y座標pおよび高さzを計算\n        double z=ls[idx1]*sin(mid);\n        double len=abs(P(xs[idx1],ys[idx1]))-ls[idx1]*cos(mid);\n        // 風船の座標\n        P v=P(xs[idx1],ys[idx1]);v/=abs(v);v*=len;\n        // idx1以外の風船について,必要ロープ長を計算\n        int cnt=0;\n        for(int i=0;i<N;i++){\n          if(i==idx1)continue;\n          double lope=sqrt(z*z+pow(v.real()-xs[i],2)+pow(v.imag()-ys[i],2));\n          if(EQ(lope,ls[i])||lope>ls[i])\n            cnt++;\n        }\n        if(cnt>0)ub=mid;\n        else lb=mid;\n      }\n      // ubの地点における,風船の数によって場合分け\n      double mid=ub;\n      // この角度の時の風船のx,y座標pおよび高さzを計算\n      double z=ls[idx1]*sin(mid);\n      double len=abs(P(xs[idx1],ys[idx1]))-ls[idx1]*cos(mid);\n      // 風船の座標\n      P v=P(xs[idx1],ys[idx1]);v/=abs(v);v*=len;\n      // idx1以外の風船について,必要ロープ長を計算\n      int cnt=0;\n      int idx2=-1;\n      for(int i=0;i<N;i++){\n        if(i==idx1)continue;\n        double lope=sqrt(z*z+pow(v.real()-xs[i],2)+pow(v.imag()-ys[i],2));\n        if(EQ(lope,ls[i])||lope>ls[i]){\n          cnt++;\n          idx2=i;\n        }\n      }\n      // もしcntが0なら、答えはidx1の点のロープ長\n      if(cnt==0)ans=ls[idx1];\n      // そうでない場合、もう1点の候補を探す\n      else{\n        // 座標vが風船の初期位置で、ここからidx1,idx2の場所の作る線分の方向へ風船は移動する\n        P p1=P(xs[idx1],ys[idx1]);\n        P p2=P(xs[idx2],ys[idx2]);\n        // 単位ベクトルを計算しておく\n        P e;\n        if(!(cross(p2-p1,v-p1)>EPS)){\n          e=p2-p1;\n          e/=abs(e);\n          e=roundPoint(e,PI/2);\n        }\n        else{\n          e=p2-p1;\n          e/=abs(e);\n          e=roundPoint(e,-PI/2);\n        }\n        // vからp1-p2への長さ\n        double len=distance_ls_p(p1,p2,v);\n        double r=getTriH(idx1,idx2);\n        // 角度を計算\n        double lb=asin(z/r);\n        double ub=PI/2;\n        for(int ite=0;ite<200;ite++){\n          double mid=(ub+lb)/2;\n          // この角度でのx,y座標および高さzを計算\n          double zz=r*sin(mid);\n          // 風船の座標\n          P vv=e*(len-r*cos(mid))+v;\n          int cnt=0;\n          for(int i=0;i<N;i++){\n            if(idx1==i||idx2==i)continue;\n            double lope=sqrt(zz*zz+pow(vv.real()-xs[i],2)+pow(vv.imag()-ys[i],2));\n            if(EQ(lope,ls[i])||lope>ls[i]){\n              cnt++;\n            }\n          }\n          if(cnt>0)ub=mid;\n          else lb=mid;\n        }\n        // 最終的に、ubの位置でのzが答えになる\n        ans=r*sin(ub);\n      }\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst double INF = 1e9;\nconst double EPS = 1e-8;\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\nbool operator < (const Point & a, const Point & b) { return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag(); }\nbool operator > (const Point & a, const Point & b) { return !eq(a.real(), b.real()) ? a.real() > b.real() : a.imag() > b.imag(); }\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\ndouble dot(const Point & a, const Point & b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(const Point & a, const Point & b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(const Point & p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(const Point & p) { return sqrt(length2(p)); }\ndouble distance(const Point & a, const Point & b) { return length(a - b); }\nPoint unit(const Point & p) { return p / length(p); }\nPoint divide(Point a, Point b, double m, double n) {\n    return Point((n * a.X() + m * b.X()) / (m + n), (n * a.Y() + m * b.Y()) / (m + n));\n}\n// ??????????????????\nPoint normal_vector(Point a) { return Point(-a.Y(), a.X()); }\n\n// (a.X, a.Y, az) ??¨ (b.X, b.Y, bz) ????????¢?????????\ndouble distance3d(Point a, double az, Point b, double bz) {\n    return sqrt(length2(a - b) + pow(az - bz, 2));\n}\n\n// c : ?????? ??§??????????§???¢??§????§?ac or ?§?bc ???????§???§??????????????????\nbool is_obtuse(double a, double b, double c) {\n    bool ok = true;\n    swap(a, c);\n    ok &= (a * a + b * b - c * c) / (2 * a * b) >= 0;\n    swap(a, c);\n    swap(b, c);\n    ok &= (a * a + b * b - c * c) / (2 * a * b) >= 0;\n    return not ok;\n}\n\ndouble heron_formula(double a, double b, double c) {\n    if(a > b) swap(a, b);\n    if(b > c) swap(b, c);\n    assert(a + b >= c);\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// ac = la, bc = lb ???????§???¢abc???c?????????ab????????±?????????, ab???????????¨??????????????????????±???????\n// ????°??????????????????\\????????????????§???¢????????????\ntuple<Point, double> third_point_projection_of_triangle(Point a, Point b, double la, double lb) {\n    if(eq(a, b) and abs(la - lb) < EPS) return make_pair(a, la);\n    double lc = distance(a, b);    \n    assert(not is_obtuse(la, lb, lc));\n    double s = heron_formula(la, lb, lc);\n    double h = s / lc * 2;\n    double m = abs(la - h) > EPS ? sqrt(la * la - h * h) : 0;\n    double n = lc - m;\n    if (not(m >= 0 and n >= 0)) debug(a), debug(b), debug(la), debug(lb), debug(m), debug(n);\n    assert(m >= 0 and n >= 0);\n    // cerr << \"thrid point projection: a:\" << a << \" b:\" << b << \" la:\" << la << \" lb:\" << lb << endl;\n    // cerr << \"divide: \" << divide(a, b, m, n) << \" h:\" << h << endl;\n    // cerr << a << b << \" \" << la << \" \" << lb << \" \" << divide(a, b, m, n) << \" \" << h << endl;\n    return make_tuple(divide(a, b, m, n), h);\n}\n\n// a -> b ??????????°??????????\nPoint projection(Point a, Point b, const Point &p) {\n    double t = dot(p-a, a-b) / norm(a-b);\n    Point ret = (a - b) * t;\n    ret += a;\n    return ret;\n}\n\nclass Solver {\n  public:\n\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return 0;\n        vector<Point> P(N);\n        vector<double> H(N);\n        rep(i, N) cin >> P[i] >> H[i];\n\n        double ans = 0;\n        \n        rep(i, N) {\n            // 1\n            {                \n                bool ok = true;\n                rep(j, N) if(i != j) ok &= distance3d(P[i], H[i], P[j], 0) <= H[j] + EPS;\n                if(ok) set_max(ans, H[i]);\n            }\n            rep(j, N) if(j != i) {                \n                double c = distance(P[i], P[j]);\n                if(H[i] + H[j] <= c) continue;\n                if(is_obtuse(H[i], H[j], c)) continue;\n                Point p;\n                double h;\n                tie(p, h) = third_point_projection_of_triangle(P[i], P[j], H[i], H[j]);\n                assert(distance3d(p, h, P[i], 0) <= H[i] + EPS);\n                assert(distance3d(p, h, P[j], 0) <= H[j] + EPS);\n                //2 \n                {\n                    bool ok = true;\n                    rep(k, N) ok &= distance3d(p, h, P[k], 0) <= H[k] + EPS;\n                    if(ok) set_max(ans, h);\n                }\n\n                rep(k, N) if(i != k and j != k) {\n                    if(abs(dot(P[i] - P[j], P[k]) > EPS)) continue;                    \n                    Point a = normal_vector(P[j] - P[i]); // P[k] ??§?????£???????????????????????????\n                    Point pk = projection(p, a + p, P[k]); \n                    double hk = sqrt(H[k] * H[k] - length2(pk - P[k]));\n                    if(h + hk <= distance(p, pk)) continue;\n                    if(is_obtuse(h, hk, distance(p, pk))) continue;\n                    Point pp;\n                    double hh;\n                    tie(pp, hh) = third_point_projection_of_triangle(p, pk, h, hk);\n                    /*\n                    if (not(distance3d(pp, hh, P[i], 0) <= H[i] + EPS)) {\n                        debug(pp); debug(hh); debug(P[i]);\n                    }\n                    */\n                    //assert(distance3d(pp, hh, P[j], 0) <= H[j] + EPS);\n                    //assert(distance3d(pp, hh, P[k], 0) <= H[k] + EPS);\n                    // 3\n                    {\n                        bool ok = true;\n                        rep(l, N) ok &= distance3d(pp, hh, P[l], 0) <= H[l] + EPS;\n                        if(ok) set_max(ans, hh);\n                    }\n                }\n            }\n            \n        }\n        printf(\"%lf\\n\", ans);\n        return 1;\n    }\n};\n\nint main() {\n    while(1) {\n        Solver s;\n        if(!s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a,b,d;\n\t\t\tcin>>a>>b>>d;\n\t\t\tc.pb(C(P(a,b),d));\n\t\t}\n\t\tdouble r=0,l=310;\n\t\twhile(abs(r-l)>EPS){\n\t\t\tdouble h=(r+l)/2;\n\t\t\tvector<C>tmp;\n\t\t\trep(i,n){\n\t\t\t\tdouble t=c[i].r*c[i].r-h*h;\n\t\t\t\ttmp.pb(C(c[i].c,sqrt(t)));\n\t\t\t}\n\t\t\tbool hh=false;\n\t\t\trep(i,n)rep(j,n)if(i!=j)if(tmp[i].r+tmp[j].r+EPS>abs(tmp[j].c-tmp[i].c)){\n\t\t\t\tL l=crosspointCC(tmp[i],tmp[j]);\n\t\t\t\tif(abs(tmp[i].r-tmp[j].r)>abs(tmp[i].c-tmp[j].c))l=L(tmp[i].c,tmp[j].c);\n\t\t\t\trep(k,2){\n\t\t\t\t\tint co=0;\n\t\t\t\t\trep(q,n)if(tmp[q].r+EPS>abs(tmp[q].c-l[k]))co++;\n\t\t\t\t\tif(co==n)hh=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(hh)r=h;\n\t\t\telse l=h;\n\t\t}\n\t\tif(n==1)r=c[0].r;\n\t\tprintf(\"%.9f\\n\",r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 3> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ x,y,z, });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<float, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG p(n);\n\t\tvector<double>r(n);\n\t\trep(i,n){p[i]=pin();cin>>r[i];}\n\t\tif(n==1){\n\t\t\tcout<<r[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble h=320;\n\t\tdouble l=-1;\n\t\twhile(1){\n\t\t\tif(h-l<1e-8)break;\n\t\t\tdouble t=(h+l)/2;\n\t\t\tvector<C>c;\n\t\t\tbool h1=true;\n\t\t\trep(i,n){\n\t\t\t\tdouble go=r[i]*r[i]-t*t;\n\t\t\t\tif(go<0){h1=false;break;}\n\t\t\t\tdouble sa=sqrt(go);\n\t\t\t\tc.pb(C(p[i],sa));\n\t\t\t}\n\t\t\tif(!h1){h=t;continue;}\n\t\t\th1=true;\n\t\t\tG ko;\n\t\t\trep(i,n){\n\t\t\t\tloop(j,i+1,n){\n\t\t\t\t\tif(abs(p[i]-p[j])>c[i].r+c[j].r){h1=false;break;}\n\t\t\t\t\tL cross=crosspointCC(c[i],c[j]);\n\t\t\t\t\tko.pb(cross[0]);\n\t\t\t\t\tko.pb(cross[1]);\n\t\t\t\t}\n\t\t\t\tif(!h1)break;\n\t\t\t\tko.pb(p[i]);\n\t\t\t}\n\t\t\tif(!h1){h=t;continue;}\n\t/*\t\t\t\trep(e,2){\n\t\t\t\t\t\tint co=0;\n\t\t\t\t\t\trep(k,n)if(EPS+r[k]>abs(p[k]-cross[e]))co++;\n\t\t\t\t\t\tif(co>=n){h1=true;break;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h1)break;\n\t\t\t\t*/\n\t\t\th1=false;\n\t\t\trep(i,ko.size()){\n\t\t\t\tint co=0;\n\t\t\t\trep(k,n)if(EPS+c[k].r>abs(p[k]-ko[i]))co++;\n\t\t\t\tif(co>=n){h1=true;break;}\n\t\t\t\t/*h1=true;\n\t\t\t\trep(j,n)if(r[j]<abs(ko[i]-p[j])){h1=false;break;}\n\t\t\t\tif(h1)break;*/\n\t\t\t}\n\t\t\t//cout<<l<<\" \"<<h<<endl;\n\t\t\tif(h1)l=t;\n\t\t\telse h=t;\n\t\t}\n\t\tprintf(\"%.8f\\n\",(h+l)/2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n#include <complex>\ntypedef complex<double> Point;\nint sign(double a){\n  if(a > EPS) return +1;\n  if(a < -EPS) return -1;\n  return 0;\n}\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle() {}\n  Circle(Point p, double r) : p(p), r(r) {}\n};\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n  vector<Point> ret;\n  Point center = projection(l, c.p);\n  double d = abs(center - c.p);\n  double t = sqrt(c.r * c.r - d * d);\n  if (isnan(t)) { return ret; }\n  Point vect = l.vector();\n  vect /= abs(vect);\n  ret.push_back(center - vect * t);\n  if (t > EPS) {\n    ret.push_back(center + vect * t);\n  }\n  return ret;\n}\n\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n  vector<Point> ret;\n  double d = abs(c1.p - c2.p);\n  if(sign(abs(c1.r - c2.r) - d) >= 0) return ret;\n  double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  Point start = c1.p + (c2.p - c1.p) / d * x;\n  Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n  return crosspointLC(Line(start, start + vect), c1);\n}\nenum{ OUT, ON, IN };\nint contains(const Circle& C, const Point& p){\n  double d = abs(C.p - p);\n  if(sign(d - C.r) > 0) return OUT;\n  if(sign(d - C.r) == 0) return ON;\n  return IN;\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    vector<Point> ps(N);\n    vector<double> l(N);\n    REP(i, N) cin >> ps[i].real() >> ps[i].imag() >> l[i];\n    double min_length = l[0];\n    REP(i, N) min_length = min(min_length, l[i]);\n    double lb = 1, ub = min_length;\n    REP(_, 100){\n      double h = (ub + lb) * 0.5;\n      vector<Circle> cs(N);\n      REP(i, N) cs[i].p = ps[i];\n      REP(i, N) cs[i].r = sqrt(l[i] * l[i] - h * h);\n      vector<Point> cand = ps;\n      REP(i, N) FOR(j, i + 1, N){\n        vector<Point> cross = crosspointCC(cs[i], cs[j]);\n        FORIT(it, cross) cand.push_back(*it);\n      }\n      bool ok = false;\n      REP(i, cand.size()){\n        Point p = cand[i];\n        int cnt = 0;\n        REP(j, N){\n          if(contains(cs[j], p) != OUT) cnt++;\n        }\n        if(cnt == N) ok = true;\n      }\n      if(ok) lb = h;\n      else ub = h;\n    }\n    printf(\"%.12f\\n\", (ub + lb) * 0.5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n \ntypedef complex<double> P;\nconst double EPS = 1e-10;\n \nstruct Circle{\n  double r;\n  P c;\n};\n \nnamespace std {\n  bool operator < (const P&a, const P&b) {\n    return fabs( real(a) - real(b) ) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n \nvector<P> getIntersectCC(Circle C1,Circle C2){\n  vector<P> res;\n  double r1 = C1.r, r2 = C2.r, d;\n  P p1 = C1.c, p2 = C2.c;\n  d = abs( p1 - p2 );\n   \n  if( d < EPS && abs( r1 - r2 ) < EPS ) return res;\n  if( r1 + r2 < d - EPS || d + EPS < abs( r1 - r2 ) ) return res;\n  double a = ( r1 * r1 - r2 * r2 + d * d ) / (2 * d);\n  double h = sqrt(max(r1 * r1 - a * a, 0.0) );\n  P tmp1 = p1 + a / d * (p2 - p1);\n  P tmp2 = h / d * (p2 - p1);\n \n  if( abs( tmp2 ) < EPS ) res.push_back( tmp1 );\n  else {\n    res.push_back( P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)) );\n    res.push_back( P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)) );    \n  }\n  return res;\n}\n \nbool inCircle(Circle C,P p){//in point\n  if( abs(C.c - p) < C.r + EPS ) return true;\n  return false;\n}\n \nint N;\nCircle X[11];\n \nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++)\n      cin >> X[i].c.real() >> X[i].c.imag() >> X[i].r;\n     \n    double st = 0.0, ed = 10000.0;\n    while(  ed - st  > EPS ){\n      double h = (ed + st)/2.0;\n      vector<Circle> nc;\n      bool f = true;\n      for(int i=0;i<N;i++){\n        nc.push_back( X[i] );\n        nc[i].r = X[i].r * X[i].r - h * h;\n        if( nc[i].r < EPS ) {\n          f = false;\n          break;\n        }\n        nc[i].r = sqrt(nc[i].r);\n      }\n      if( !f ) {\n        ed = h;\n        continue;\n      }\n      vector<P> pos;\n      for(int i=0;i<N;i++){\n        pos.push_back( nc[i].c );\n        for(int j=i+1;j<N;j++){\n          vector<P> ret = getIntersectCC(nc[i],nc[j]);\n          for(int k=0;k<(int)ret.size();k++) pos.push_back( ret[k] );\n        }\n      }\n      f = false;\n      // cout << \"h : \" <<h << endl;\n      for(int i=0;i<(int)pos.size();i++){\n        // cout <<pos[i] << endl;\n        bool kf = true;\n        for(int j=0;j<N;j++){\n          if( !inCircle( nc[j], pos[i] ) ) kf = false;\n        }\n        if( kf ){\n          f = true;\n          //cout << \"ok\"<< endl;\n          break;\n        }\n      }\n      if( f ) st = h;\n      else ed = h;\n    }\n    printf(\"%.10lf\\n\",st);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n \nstruct Point {\n    double x, y;\n \n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n \n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n     \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n     \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n     \n    Point operator / (const double &k) const {\n        return Point(x / k, y / k);\n    }\n};\n \nPoint operator * (const Point &a, const Point &b)\n{\n    return Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n \ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n \ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n \ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n \ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n \nstruct Circle {\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n \nbool isIntersectCC(const Circle &a, const Circle &b)\n{\n    double d = abs(a.p - b.p);\n    return (d <= a.r + b.r && d >= abs(a.r - b.r));\n}\n \nvector<Point> crosspointCC(const Circle &a, const Circle &b)\n{\n    vector<Point> res;\n    double d = abs(a.p - b.p);\n    if (!isIntersectCC(a, b) || d < EPS) {\n        return res;\n    }\n    double rc = (a.r * a.r - b.r * b.r + d * d) / (2.0 * d);\n    if (abs(a.r) - abs(rc) < EPS) {\n        return res;\n    }\n     \n    double rs = sqrt(a.r * a.r - rc * rc);\n    Point p = (b.p - a.p);\n    res.push_back(Point(a.p + p * Point(rc, +rs) / d));\n    res.push_back(Point(a.p + p * Point(rc, -rs) / d));\n    return res;\n}\n \nbool c(double z, vector<Circle> c)\n{\n    int N = c.size();\n    for (int i = 0; i < N; i++) {\n        c[i].r = sqrt(c[i].r * c[i].r - z * z);        \n    }\n     \n    vector<Point> cross_point;\n    for (int i = 0; i < N; i++) {\n        cross_point.push_back(c[i].p);\n        for (int j = i+1; j < N; j++) {            \n            vector<Point> cp = crosspointCC(c[i], c[j]);\n            for (int k = 0; k < (int)cp.size(); k++) {\n                cross_point.push_back(cp[k]);\n            }\n        }\n    }\n     \n    for (int i = 0; i < (int)cross_point.size(); i++) {\n        bool poss = 1;\n        for (int j = 0; j < N; j++) {\n            if (dist(cross_point[i], c[j].p) - c[j].r > EPS) {\n                poss = 0;\n                break;\n            }\n        }\n        if (poss) {\n            return 1;\n        }\n    }\n    return 0;\n}\n \ndouble solve(vector<Circle> &cirs)\n{\n    if (cirs.size() == 1) return cirs[0].r;\n    double min = 25252;\n    for (int i = 0; i < (int)cirs.size(); i++) {\n        min = std::min(min, cirs[i].r);\n    }\n \n    double l = 0, r = 2 * min;\n    for (int i = 0; i < 150; i++) {\n        double z = (l + r) / 2;\n        if (c(z, cirs)) {\n            l = z;\n        } else {\n            r = z;\n        }\n    }\n    return l;\n}\n \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cirs(N);\n        for (int i = 0; i < N; i++) {\n            cin >> cirs[i].p.x >> cirs[i].p.y >> cirs[i].r;\n        }\n        printf(\"%.10f\\n\", solve(cirs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define ALL(x) x.begin(), x.end()\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nusing ll = long long;\ntypedef pair<int, int> pii;\n\n//幾何 Geometry\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nconst bool DEBUG = false;\n\ntypedef complex<double> point;\nistream &operator>>(istream &is, point &p) {\n    double a, b;\n    is >> a >> b;\n    p = point(a, b);\n    return is;\n}\npoint operator*(const point &p, const double &d) { return point(real(p) * d, imag(p) * d); }\nnamespace std {\nbool operator<(const point &a, const point &b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); }\n}  // namespace std\n\n//直線or線分\nstruct Line : public vector<point> {\n    Line(const point &a, const point &b) {\n        push_back(a);\n        push_back(b);\n    }\n};\ntypedef vector<Line> Lines;\n\npoint direction(const point &p) {  //同じ向きの単位ベクトル\n    return p / abs(p);\n}\npoint orthogonal(const point &p) {  //法線ベクトル\n    return point(-imag(p), real(p));\n}\ndouble cross(const point &a, const point &b) { return real(a) * imag(b) - imag(a) * real(b); }\ndouble dot(const point &a, const point &b) { return real(a) * real(b) + imag(a) * imag(b); }\nint ccw(point a, point b, point c) {\n    b = b - a;\n    c = c - a;\n    if (cross(b, c) > EPS) return +1;   // counter clockwise\n    if (cross(b, c) < -EPS) return -1;  // clockwise\n    if (dot(b, c) < -EPS) return +2;    // c--a--b on line\n    if (norm(b) < norm(c)) return -2;   // a--b--c on line\n    return 0;\n}\n//交差判定\nbool intersectLL(const Line &l1, const Line &l2) {\n    return abs(cross(l1[1] - l1[0], l2[1] - l2[0])) > EPS ||  // non-parallel\n           abs(cross(l1[1] - l1[0], l2[0] - l1[0])) < EPS;    // same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n    return cross(l[1] - l[0], s[0] - l[0]) *  // s[0] is left of l\n               cross(l[1] - l[0], s[1] - l[0]) <\n           EPS;  // s[1] is right of l\n}\nbool intersectLP(const Line &l, const point &p) { return abs(cross(l[1] - p, l[0] - p)) < EPS; }\n//端点に乗ってたらfalse\nbool intersectSP_without_endpoint(const Line &s, const point &p) {\n    if (abs(s[0] - p) < EPS || abs(s[1] - p) < EPS) return false;\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;  // triangle inequality\n}\n\nbool intersectSP(const Line &s, const point &p) {\n    // verified on 2020/04/03\n    // https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;  // triangle inequality\n}\nbool isOnSegment(const Line &s, const Line &t) {\n    if (intersectSP(s, t[0]) || intersectSP(s, t[1]) || intersectSP(t, s[0]) || intersectSP(t, s[1]))\n        return true;\n    else\n        return false;\n}\nbool isSamePoint(const point &p1, const point &p2) { return abs(p1 - p2) < EPS; }\nbool connectSS(const Line &s, const Line &t) {\n    REP(i, 2) REP(j, 2) {\n        if (s[i] == t[j]) return true;\n    }\n    return false;\n}\nbool intersectSS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点が線分上に乗っている場合はfalseにする\nbool intersectSS_strict(const Line &s, const Line &t) {\n    if (isOnSegment(s, t)) return false;\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n//距離,交点\n//射影 直線lにpから下した垂線との交点\npoint projection(\n    const Line &l,\n    const point &p) {  // verified on 2020/04/03\n                       // https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + (l[0] - l[1]) * t;\n}\n//射影 直線lを対象軸としてpと線対称にある点\npoint reflection(const Line &l, const point &p) { return p + (projection(l, p) - p) * 2; }\ndouble distancePP(const point &a, const point &b) { return sqrt(norm(a - b)); }\ndouble distanceLP(const Line &l, const point &p) { return abs(p - projection(l, p)); }\ndouble distanceLL(const Line &l, const Line &m) { return intersectLL(l, m) ? 0 : distanceLP(l, m[0]); }\ndouble distanceLS(const Line &l, const Line &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const point &p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n    // verified on 2020/04/03\n    // https://onlinejudge.u-aizu.ac.jp/status/users/Mojumbo/submissions/1/1157/judge/4316978/C++14\n    if (intersectSS(s, t)) return 0;\n    return min({distanceSP(s, t[0]), distanceSP(s, t[1]), distanceSP(t, s[0]), distanceSP(t, s[1])});\n}\npoint crosspoint(const Line &l, const Line &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0];  // same line\n    if (abs(A) < EPS) assert(false);                // Precondition not satisfied\n    return m[0] + B / A * (m[1] - m[0]);\n}\ndouble dist(point &p1, point &p2) { return abs(p1 - p2); }\n\nstruct rope {\n    point p;\n    double l;\n    rope(point p_, double l_) : p(p_), l(l_) {}\n};\nstruct point3d {\n    point p;\n    double z;\n    point3d(point p_, double z_) : p(p_), z(z_) {}\n};\n\npoint3d two_ropes(int i, int j, vector<rope> &ropes, int N) {\n    if (ropes[i].l > ropes[j].l) swap(i, j);\n    point p = ropes[i].p, q = ropes[j].p;\n    point v = q - p;\n    double t = (pow(ropes[i].l, 2) - pow(ropes[j].l, 2) + pow(abs(v), 2)) / (2 * abs(v));\n    point m = p + direction(v) * t;\n    double h = sqrt(pow(ropes[i].l, 2) - pow(abs(m - p), 2));\n    bool ok = true;\n    // cout << ropes[i].p << ropes[j].p << m << h << endl;\n\n    if (ropes[j].l > ropes[i].l + dist(p, q) + EPS) ok = false;\n    if (ok) {\n        point3d ret(m, h);\n        return ret;\n    } else {\n        point3d ret(0, -1);\n        return ret;\n    }\n}\n\nvoid solve() {\n    int N;\n    cin >> N;\n    if (N == 0) exit(0);\n    vector<rope> ropes;\n    REP(i, N) {\n        double x, y, l;\n        cin >> x >> y >> l;\n        point p(x, y);\n        rope r(p, l);\n        ropes.push_back(r);\n    }\n    double ans = 0;\n\n    // 1本が張る\n    REP(i, N) {\n        point p = ropes[i].p;\n        double h = ropes[i].l;\n        bool ok = true;\n        REP(j, N) {\n            if (i == j) continue;\n            if (pow(dist(ropes[j].p, p), 2) + pow(h, 2) > pow(ropes[j].l, 2) + EPS) ok = false;\n        }\n        if (ok) ans = max(ans, h);\n    }\n\n    // 2本が張る\n    REP(i, N) {\n        FOR(j, i + 1, N) {\n            point3d po = two_ropes(i, j, ropes, N);\n\n            point m = po.p;\n            // cout << ropes[i].p << ropes[j].p << m << po.z << endl;\n            double h = po.z;\n            bool ok = true;\n            REP(k, N) {\n                // if (k == i || k == j) continue;\n                double d = sqrt(pow(dist(ropes[k].p, m), 2) + pow(h, 2));\n                if (ropes[k].l + EPS < d) ok = false;\n            }\n            if (ok) ans = max(ans, h);\n        }\n    }\n\n    // 3本が張る\n    REP(i, N) {\n        FOR(j, i + 1, N) {\n            point3d po = two_ropes(i, j, ropes, N);\n            point p = ropes[i].p, q = ropes[j].p, m = po.p;\n            if (po.z < 0) continue;\n            //\n            REP(k, N) {\n                if (k == i || k == j) continue;\n\n                {\n                    double ok = 0, ng = PI / 2;\n                    double L = po.z;\n                    REP(_, 50) {\n                        double mid = (ok + ng) / 2;\n                        double z = L * sin(mid);\n                        point v = direction(m - p);\n                        //時計回りに90度回転\n                        point v2 = v * point(0, -1);\n                        point M = m + v2 * L * cos(mid);\n                        double d = sqrt(pow(abs(M - ropes[k].p), 2) + pow(z, 2));\n                        if (d <= ropes[k].l + EPS)\n                            ok = mid;\n                        else\n                            ng = mid;\n                        //\n                    }\n                    double mid = ok;\n                    double z = L * sin(mid);\n                    point v = direction(m - p);\n                    //時計回りに90度回転\n                    point v2 = v * point(0, -1);\n                    point M = m + v2 * L * cos(mid);\n                    bool possible = true;\n                    REP(idx, N) {\n                        // if (idx == i || idx == j || idx == k) continue;\n                        double d = sqrt(pow(abs(M - ropes[idx].p), 2) + z * z);\n                        if (d > ropes[idx].l + EPS) possible = false;\n                    }\n                    if (possible) ans = max(ans, z);\n                }\n                {\n                    double ok = 0, ng = PI / 2;\n                    double L = po.z;\n                    REP(_, 50) {\n                        double mid = (ok + ng) / 2;\n                        double z = L * sin(mid);\n                        point v = direction(m - p);\n                        //反時計回りに90度回転\n                        point v2 = v * point(0, 1);\n                        point M = m + v2 * L * cos(mid);\n                        double d = sqrt(pow(abs(M - ropes[k].p), 2) + pow(z, 2));\n                        if (d <= ropes[k].l + EPS)\n                            ok = mid;\n                        else\n                            ng = mid;\n                        //\n                    }\n                    double mid = ok;\n                    double z = L * sin(mid);\n                    point v = direction(m - p);\n                    //反時計回りに90度回転\n                    point v2 = v * point(0, 1);\n                    point M = m + v2 * L * cos(mid);\n                    bool possible = true;\n                    REP(idx, N) {\n                        // if (idx == i || idx == j || idx == k) continue;\n                        double d = sqrt(pow(abs(M - ropes[idx].p), 2) + z * z);\n                        if (d > ropes[idx].l + EPS) possible = false;\n                    }\n                    if (possible) ans = max(ans, z);\n                }\n            }\n        }\n    }\n    cout << fixed << setprecision(6) << ans << endl;\n}\n\nsigned main() {\n    while (true) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n \nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<int, int, int>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\nint disdis(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    return (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n \ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2;\n    return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n \ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n    return sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n \ntuple<double, double, double> com(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return a;\n    }\n    else if (ISLOOSE(b, a)) {\n        return b;\n    }\n    else {\n        double l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n        double d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n        double d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n        return tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n    }\n}\n \ndouble two(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return (double)get<2>(a);\n    }\n    else if (ISLOOSE(b, a)) {\n        return (double)get<2>(b);\n    }\n    else {\n        double d = sqrt(disdis(a, b));\n        return heron(get<2>(a), get<2>(b), d) * 2 / d;\n    }\n}\n \ndouble three(const tuple<int, int, int>& a, const tuple<int, int, int>& b, const tuple<int, int, int>& c)\n{\n    tuple<double, double, double> temp;\n \n    if (ISLOOSE(a, b) && ISLOOSE(a, c))\n        return get<2>(a);\n    if (ISLOOSE(b, a) && ISLOOSE(b, c))\n        return get<2>(b);\n    if (ISLOOSE(c, a) && ISLOOSE(c, b))\n        return get<2>(c);\n \n    if (ISLOOSE(temp = com(a, b), c))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(b, c), a))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(c, a), b))\n        return get<2>(temp);\n \n    return heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n        * 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n \nint main()\n{\n    int n;\n    double res;\n\tcout << fixed << setprecision(7);\n    while (cin >> n, n) {\n        vector< tuple<int, int, int> > str(n);\n        for (int i = 0; i < n; i++) {\n            cin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n        }\n        if (n == 1) {\n            cout << (double)get<2>(str[0]) << endl;\n        }\n        else if (n == 2) {\n            cout << two(str[0], str[1]) << endl;\n        }\n        else {\n            res = 100000000.0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    for (int k = j + 1; k < n; k++) {\n                        res = min(res, three(str[i], str[j], str[k]));\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point {\n    double x, y;\n\n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n    \n    Point operator / (const double &k) const {\n        return Point(x / k, y / k);\n    }\n};\n\nPoint operator * (const Point &a, const Point &b)\n{\n    return Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\nbool isIntersectCC(const Circle &a, const Circle &b)\n{\n    double d = abs(a.p - b.p);\n    return (d <= a.r + b.r && d >= abs(a.r - b.r));\n}\n\nvector<Point> crosspointCC(const Circle &a, const Circle &b)\n{\n    vector<Point> res;\n    double d = abs(a.p - b.p);\n    if (!isIntersectCC(a, b) || d < EPS) {\n        return res;\n    }\n    double rc = (a.r * a.r - b.r * b.r + d * d) / (2.0 * d);\n    if (abs(a.r) - abs(rc) < EPS) {\n        return res;\n    }\n    \n    double rs = sqrt(a.r * a.r - rc * rc);\n    Point p = (b.p - a.p);\n    res.push_back(Point(a.p + p * Point(rc, +rs) / d));\n    res.push_back(Point(a.p + p * Point(rc, -rs) / d));\n    return res;\n}\n\nbool c(double z, vector<Circle> c)\n{\n    int N = c.size();\n    for (int i = 0; i < N; i++) {\n        c[i].r = sqrt(c[i].r * c[i].r - z * z);        \n    }\n    \n    vector<Point> cross_point;\n    for (int i = 0; i < N; i++) {\n        if (c[i].r == 0) {\n            cross_point.push_back(c[i].p);\n            continue;\n        }\n        for (int j = i+1; j < N; j++) {            \n            vector<Point> cp = crosspointCC(c[i], c[j]);\n            for (int k = 0; k < (int)cp.size(); k++) {\n                cross_point.push_back(cp[k]);\n            }\n        }\n    }\n    \n    for (int i = 0; i < (int)cross_point.size(); i++) {\n        bool poss = 1;\n        for (int j = 0; j < N; j++) {\n            if (dist(cross_point[i], c[j].p) - c[j].r > EPS) {\n                poss = 0;\n                break;\n            }\n        }\n        if (poss) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\ndouble solve(vector<Circle> &cirs)\n{\n    if (cirs.size() == 1) return cirs[0].r;\n    double min = 25252;\n    for (int i = 0; i < (int)cirs.size(); i++) {\n        min = std::min(min, cirs[i].r);\n    }\n\n    double l = 0, r = 2 * min;\n    for (int i = 0; i < 150; i++) {\n        double z = (l + r) / 2;\n        if (c(z, cirs)) {\n            l = z;\n        } else {\n            r = z;\n        }\n    }\n    return l;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cirs(N);\n        for (int i = 0; i < N; i++) {\n            cin >> cirs[i].p.x >> cirs[i].p.y >> cirs[i].r;\n        }\n        printf(\"%.10f\\n\", solve(cirs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nint n;\ndouble l[10];\n\nstruct C {\n\tP p;\n\tdouble r;\n\n\tC() {\n\t\tp = P(0, 0);\n\t\tr = 0;\n\t}\n\n\tC(const P& p, double r) : p(p), r(r) {\n\t}\n\n\tbool in(P t) {\n\t\treturn norm(p - t) < r * r + EPS;\n\t}\n\n\tbool in(C t) {\n\t\treturn abs(p - t.p) + t.r < r + EPS;\n\t}\n} c[10];\n\nbool check(double h) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (l[i] * l[i] - h * h < EPS) return false;\n\t\tc[i].r = sqrt(l[i] * l[i] - h * h);\n\t}\n\n\tvector<P> cs;\n\tfor (int i = 0; i < n; i++) {\n\t\tcs.push_back(c[i].p);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tC c1 = c[i], c2 = c[j];\n\t\t\tif (abs(c1.p - c2.p) > c1.r + c2.r) return false; // ????????????\n\t\t\tif (c1.in(c2) || c2.in(c1)) continue;\n\n\t\t\tP v = c2.p - c1.p;\n\t\t\tdouble t = (c1.r * c1.r + norm(v) - c2.r * c2.r) / (2 * abs(v));\n\t\t\tdouble theta = acos(t / c1.r);\n\t\t\t//assert(-1.0 <= t / c1.r && t / c1.r <= 1.0);\n\t\t\tP b[2];\n\t\t\tb[0] = c1.p + v / abs(v) * c1.r * polar(1.0, theta);\n\t\t\tb[1] = c1.p + v / abs(v) * c1.r * polar(1.0, -theta);\n\t\t\tcs.push_back(b[0]);\n\t\t\tcs.push_back(b[1]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cs.size(); i++) {\n\t\tbool flag = true;\n\t\tfor (int m = 0; m < n; m++) {\n\t\t\tif (!c[m].in(cs[i])) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n , n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y >> l[i];\n\t\t\tc[i].p = P(x, y);\n\t\t}\n\t\tcheck(0);\n\t\tdouble ok = 0, ng = 100000;\n\t\tfor (int loop = 0; loop < 1000; loop++) {\n\t\t\tdouble h = (ok + ng) / 2;\n\t\t\tif (check(h)) ok = h;\n\t\t\telse ng = h;\n\t\t}\n\t\tcout << setprecision(15) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 0;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\t//h.push_back({ a,b,c });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c*c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, c);\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2] )/l+l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\t//h.push_back({ x,y,z });\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((x - bl[i][0])*(x - bl[i][0]) + (y - bl[i][1])*(y - bl[i][1]) + z*z > bl[i][2] * bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, z);\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\t//h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2] });\n\t\t\tbool f = 1;\n\t\t\trep(j, n) {\n\t\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][1] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, bl[i][2]);\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];       \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-10;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            bool hoge=true;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>dis+EPS) hoge=false;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    if(val>1) val=1;\n                    if(val<-1) val=-1;\n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+1e-8){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            able=able||hoge;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<setprecision(10)<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12 / x10;\n\t\t\t\t\t\t\tb = (x02 - a*x10)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12 - a*x00) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct Point {\n    ld x;\n    ld y;\n    ld l;\n};\n\nostream& operator<<(ostream& os, const Point& v)\n{\n    cout << \"(\" << v.x << \" \" << v.y << \" \" << v.l << \")\";\n    return os;\n}\n\nPoint two(const Point& p1, const Point& p2)\n{\n    const ld L = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y);\n    const ld l = sqrt(L);\n    const ld e = (L + (p1.l * p1.l) - (p2.l * p2.l)) / (2 * l);\n    const ld hh = p1.l * p1.l - e * e;\n    const ld h = (hh > 0) ? sqrt(hh) : 0;\n    const ld x = ((l - e) * p1.x + e * p2.x) / l;\n    const ld y = ((l - e) * p1.y + e * p2.y) / l;\n    return Point{x, y, h};\n}\n\nPoint three(const Point& p1, const Point& p2, const Point& p3)\n{\n    const ld a11 = p2.x - p3.x;\n    const ld a12 = p2.y - p3.y;\n    const ld a21 = p1.x - p2.x;\n    const ld a22 = p1.y - p2.y;\n    const ld b1 = (ld)(p3.l * p3.l - p2.l * p2.l - p3.x * p3.x + p2.x * p2.x - p3.y * p3.y + p2.y * p2.y) / 2;\n    const ld b2 = (ld)(p2.l * p2.l - p1.l * p1.l - p2.x * p2.x + p1.x * p1.x - p2.y * p2.y + p1.y * p1.y) / 2;\n\n    const ld det = a11 * a22 - a12 * a21;\n    const ld x = (a22 * b1 - a12 * b2) / det;\n    const ld y = (-a21 * b1 + a11 * b2) / det;\n    const ld hh = p1.l * p1.l - (x - p1.x) * (x - p1.x) - (y - p1.y) * (y - p1.y);\n    const ld h = (hh > 0) ? sqrt(hh) : 0;\n    return Point{x, y, h};\n}\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Point> p(n);\n        for (int i = 0; i < n; i++) {\n            auto& P = p[i];\n            cin >> P.x >> P.y >> P.l;\n        }\n\n        ld maxh = 0;\n        for (int i = 0; i < n; i++) {\n            const ld h = p[i].l;\n            const ld xi = p[i].x;\n            const ld yi = p[i].y;\n            bool ok = true;\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if ((xi - p[j].x) * (xi - p[j].x) + (yi - p[j].y) * (yi - p[j].y) + h * h > p[j].l * p[j].l) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                maxh = max(maxh, h);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                const Point P = two(p[i], p[j]);\n                const ld x = P.x;\n                const ld y = P.y;\n                const ld h = P.l;\n                bool ok = true;\n                for (int l = 0; l < n; l++) {\n                    if (i == l or j == l) {\n                        continue;\n                    }\n                    if ((x - p[l].x) * (x - p[l].x) + (y - p[l].y) * (y - p[l].y) + h * h > p[l].l * p[l].l) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) {\n                    maxh = max(maxh, h);\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    const Point P = three(p[i], p[j], p[k]);\n                    const ld x = P.x;\n                    const ld y = P.y;\n                    const ld h = P.l;\n                    bool ok = true;\n                    for (int l = 0; l < n; l++) {\n                        if (i == l or j == l or k == l) {\n                            continue;\n                        }\n                        if ((x - p[l].x) * (x - p[l].x) + (y - p[l].y) * (y - p[l].y) + h * h > p[l].l * p[l].l) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        maxh = max(maxh, h);\n                    }\n                }\n            }\n        }\n        cout << fixed << setprecision(10) << maxh << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst double eps = 1e-8, inf = 1e8;\n\ntemplate<typename T> T sqr(T x){return x*x;}\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a) * b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c){\n    b -= a; c -= a;\n    if(cross(a, b) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct L:vector<P>{\n    L(const P &a, const P &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interSS(const L &s, const L &t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP xptLL(const L &l, const L &m){\n    double d = cross(l[1] - l[0], m[1] - m[0]);\n    if(abs(d) < eps)return l[0];\n    return m[0] + (m[1] - m[0]) * cross(l[1] - l[0], l[1] - m[0]) / d;\n}\n\nstruct C:P{\n    double r;\n    C(const P &a, double r):P(a), r(r){}\n};\n\nint overlap(const C &c1, const C &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nvector<P> xptCC(const C &c1, const C &c2){\n    vector<P> res;\n    double d = abs(c1 - c2);\n    if(d < eps || abs(overlap(c1, c2)) != 2)return res;\n    double rc = (sqr(d) + sqr(c1.r) - sqr(c2.r)) / (2 * d);\n    double rs = sqrt(sqr(c1.r) - sqr(rc));\n    P diff = (c2 - c1) / d;\n    res.push_back(c1 + diff * P(rc, rs));\n    res.push_back(c1 + diff * P(rc, -rs));\n    return res;\n}\n\ndouble solve(vector<C> stake){\n    vector<P> fixpt(all(stake));\n    vector<L> locus;\n    rep(i, (int)stake.size())rep(j, i){\n        vector<P> xpt = xptCC(stake[i], stake[j]);\n        if(xpt.empty())continue;\n        fixpt.insert(fixpt.end(), all(xpt));\n        fixpt.push_back((xpt[0] + xpt[1]) / 2.);\n        locus.push_back(L(xpt[0], xpt[1]));\n    }\n    rep(i, (int)locus.size())rep(j, i){\n        if(!interSS(locus[i], locus[j]))continue;\n        fixpt.push_back(xptLL(locus[i], locus[j]));\n    }\n    double res = 0.;\n    for(auto p: fixpt){\n        double h = inf;\n        for(auto c: stake)h = min(h, sqr(c.r) - norm(c - p));\n        res = max(res, h);\n    }\n    return sqrt(res);\n}\n\nint main(){\n    for(int n; cin >> n, n;){\n        vector<C> stake;\n        rep(i, n){\n            int x, y, l;\n            cin >> x >> y >> l;\n            stake.push_back(C(P(1. * x, 1. * y), 1. * l));\n        }\n        cout << fixed << setprecision(8) << solve(stake) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tdouble l=0,r=inf;\n\t\tvector<C>in;\n\t\trep(i,n){\n\t\t\tdouble a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tin.pb(C(P(a,b),c));\n\t\t\tr=min(r,c);\n\t\t}\n\t\twhile(abs(l-r)>EPS){\n\t\t\tdouble h=(r+l)/2.;\n\t\t\tvector<C>c;\n\t\t\trep(i,n)c.pb(C(in[i].c,sqrt(in[i].r*in[i].r-h*h)));\n\t\t\tbool H=false;\n\t\t\trep(i,n)loop(j,i+1,n)if(abs(c[i].c-c[j].c)<EPS+c[i].r+c[j].r){\n\t\t\t\tL ll=crosspointCC(c[i],c[j]);\n\t\t\t\trep(k,2){\n\t\t\t\t\tint co=0;\n\t\t\t\t\trep(q,n)if(abs(ll[k]-c[q].c)<c[q].r+EPS)co++;\n\t\t\t\t\tif(co==n)H=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n){\n\t\t\t\tint co=0;\n\t\t\t\trep(j,n)if(abs(c[j].c-c[i].c)<c[j].r+EPS)co++;\n\t\t\t\tif(co==n)H=true;\n\t\t\t}\n\t\t\tif(H)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tif(n==1)l=in[0].r;\n\t\tcout<<shosu(9)<<l<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (abs(x + y) < ESP * (abs(x) + abs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(p.x, x), add(p.y, y));\n  }\n  P operator - (P p) {\n    return P(add(p.x, -x), add(p.y, -y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return abs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  //printf(\"%d:%d,%f,%f,%f\\n\",i,j,s,r[i],r[j]);\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p) {\n  //for (int i = 0; i < n; i++) if (ESP < (add((p - dir[i]).square(), -r[i] * r[i])) && 0.1 > (add((p - dir[i]).square(), -r[i] * r[i]))) printf(\"%d,%f]]]\\n\",i,(add((p - dir[i]).square(), -r[i] * r[i])));\n  for (int i = 0; i < n; i++) if (0.00001 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i],-h * h));\n    //printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      //printf(\"t:%d\\n\",t);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 + dir[j] * l1) * (1.0 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d)) return true;\n        if (canClear(ave - d)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t])) return true;\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n    //printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n    //printf(\"%d\\n\",(int)check(72.2251798));\n    //printf(\"%d\\n\",(int)check(71.954102));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\nusing namespace std;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\n\nbool zero(double a) { return abs(a) <= EPS; }\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nbool canClear(P p, int i1, int i2) {\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && EPS + r[i] < abs(p - dir[i])) return false;\n  return true;\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (-EPS > ((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt((double)l[i] * l[i] - h * h);\n  }\n  for (int i = 0; i < n; i++) if (canClear(dir[i], -1, -1)) return true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      double d = abs(dir[j] - dir[i]);\n      if (d - r[i] - r[j] > EPS) return false;\n      if (r[i] - r[j] - d > EPS) continue;\n      if (r[j] - r[i] - d > EPS) continue;\n      double A = atan2((dir[j] - dir[i]).imag(), (dir[j] - dir[i]).real());\n      double S = acos((d*d + r[i]*r[i] - r[j]*r[j]) / (2 * d * r[i]));\n      if (canClear(dir[i] + polar(r[i], S + A), i, j)) return true;\n      if (canClear(dir[i] + polar(r[i], S - A), i, j)) return true;\n    }\n  }\n  return false;\n  //return true;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i] = P(x[i], y[i]);\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n){\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\t\tif (z < ans)ans = z;\n\t\t\t\trep(k, j) {\n\t\t\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\tif (x[1][1] == 0) {\n\t\t\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t\t\t}\n\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\tint cc = ccw(P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]), P(a, b));\n\t\t\t\t\tif (cc == ccw(P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1]), P(a, b)) && cc == ccw(P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1]), P(a, b)))ans = c;\n\t\t\t\t\t//h.push_back({ a,b,c });\n\t\t\t\t\t/*bool f = 1;\n\t\t\t\t\trep(i, n) {\n\t\t\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\ntypedef complex<ld> Point;\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\n\nPoint input_point() {\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n    return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n    Point a, b;\n    Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle () : p(Point(0, 0)), r(0) {}\n    Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n    return isis_ll(l, s) &&\n        (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n        ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res;\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps){\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d,\tc.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0,\t1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = p.size();\n    REP(j,n) res += cross(p[j], p[(j+1)%n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = ps.size();\n    Polygon Q;\n    REP(i,n) {\n        Point A = ps[i], B = ps[(i+1)%n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n    for (Point q : ps) if (abs(q - p) < eps) return;\n    ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n    g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n    int n = p.size(), m = s.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (isis_sp(s[i], p[j]))\n            vec.emplace_back(abs(s[i].a - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            add_edge(g, from, to, abs(p[from] - p[to]));\n        }\n    }\n    return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n    int n = p.size(), m = c.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n            vec.emplace_back(arg(c[i].p - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            ld angle = vec[j+1].first - vec[j].first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n        if (vec.size() >= 2) {\n            int from = vec.back().second, to = vec.front().first;\n            ld angle = vec.front().first - vec.back().first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n    }\n    return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n    int N = p.size();\n    polygon.clear();\n    REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n    vector<vector<tuple<ld,int,bool>>> tup(N);\n    REP(i,s.size()) {\n        int a = -1, b = -1;\n        REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n        REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n        assert(a >= 0 && b >= 0);\n        tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n        tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n    }\n    REP(i,N) sort(ALL(tup[i]));\n    REP(i,N) {\n        REP(j,tup[i].size()) {\n            ld angle; int pos = j, from = i, to; bool flag;\n            tie(angle, to, flag) = tup[i][j];\n            if (flag) continue;\n            vector<int> ps;\n            while (!flag) {\n                ps.push_back(from);\n                get<2>(tup[from][pos]) = true;\n                seg2p[from][to].push_back(polygon.size());\n                seg2p[to][from].push_back(polygon.size());\n                angle += pi + eps;\n                if (angle > pi) angle -= 2 * pi;\n                auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n                if (it == tup[to].end()) it = tup[to].begin();\n                from = to; tie(angle, to, flag) = *it;\n                pos = it - tup[from].begin();\n            }\n            polygon.push_back(ps);\n        }\n    }\n    Graph g(polygon.size());\n    REP(i,N) REP(j,i) {\n        if (seg2p[i][j].size() == 2) {\n            int from = seg2p[i][j][0], to = seg2p[i][j][1];\n            g[from].push_back((Edge){from, to});\n            g[to].push_back((Edge){to, from});\n        }\n    }\n    return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n    fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n    Point v = l.b - l.a;\n    Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n    int n = p.size();\n    REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n;\n    while (cin >> n, n) {\n        vector<ll> X(n), Y(n), L(n);\n        REP(i, n) {\n            cin >> X[i] >> Y[i] >> L[i];\n        }\n        auto check = [&](double h) {\n            vector<double> r(n);\n            REP(i, n) {\n                double rr = L[i]*L[i]-h*h;\n                if (rr < 0) return false;\n                r[i] = sqrt(rr);\n            }\n            vector<Circle> c;\n            REP(i, n) {\n                c.pb(Circle(Point(X[i], Y[i]), r[i]));\n            }\n            vector<Point> kh;\n            REP(i, n) kh.pb(c[i].p);\n            REP(i, n) FOR(j, i+1, n) {\n                vector<Point> v = is_cc(c[i], c[j]);\n                EACH(p, v) kh.pb(p);\n            }\n            EACH(p, kh) {\n                bool f = true;\n                REP(i, n) {\n                    if (abs(p-Point(X[i], Y[i])) > r[i]+eps) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return true;\n            }\n            return false;\n        };\n        double l = 0, r = 1000;\n        REP(t, 100) {\n            double m = (l + r) / 2;\n            if (check(m)) l = m;\n            else r = m;\n        }\n        cout << fixed << setprecision(10) << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    for(;;){\n      int(n); if(!n)break;\n      double x[n], y[n], l[n], dx, dy;\n      rep(i, n)cin >> x[i] >> y[i] >> l[i];\n      if(n == 1){ pri(l[0]); continue; }\n      double wl = 100, wr = -100, ht = -100, hb = 100;\n      rep(i, n){\n        if(wl > x[i])wl = x[i];\n        if(wr < x[i])wr = x[i];\n        if(ht < y[i])ht = y[i];\n        if(hb > y[i])hb = y[i];\n      }\n      rep(i, n){\n        if(wl < x[i] - l[i])wl = x[i] - l[i];\n        if(wr > x[i] + l[i])wr = x[i] + l[i];\n        if(hb < y[i] - l[i])hb = y[i] - l[i];\n        if(ht > y[i] + l[i])ht = y[i] + l[i];\n      }\n\n      double w[4] = {wl, 0, 0, wr}, wres[4];\n      for(int xt = 70;xt--;){\n        w[1] = w[0] + (w[3] - w[0]) / 3.0;\n        w[2] = w[0] + (w[3] - w[0]) * 2.0 / 3.0;\n        rep(i, 4){\n\n          double h[4] = {hb, 0, 0, ht}, hres[4];\n          for(int yt = 70;yt--;){\n            h[1] = h[0] + (h[3] - h[0]) / 3.0;\n            h[2] = h[0] + (h[3] - h[0]) * 2.0 / 3.0;\n\n            rep(j, 4){\n              double res = 400;\n              rep(k, n){\n                double d = sqrt((x[k] - w[i]) * (x[k] - w[i]) + (y[k] - h[j]) * (y[k] - h[j]));\n                if(l[k] < d)res = 0;\n                else{\n                  double tmp = sqrt(l[k] * l[k] - d * d);\n                  res = min(res, tmp);\n                }\n              }\n              hres[j] = res;\n            }\n\n            if(hres[1] < hres[2])h[0] = h[1];\n            else h[3] = h[2];\n            dy = h[1];\n          }\n\n          wres[i] = hres[1];\n        }\n        if(wres[1] < wres[2])w[0] = w[1];\n        else w[3] = w[2];\n        dx = w[1];\n      }\n\n      double res = 400;\n      rep(k, n){\n        double d = sqrt((x[k] - dx) * (x[k] - dx) + (y[k] - dy) * (y[k] - dy));\n        double tmp = sqrt(l[k] * l[k] - d * d);\n        res = min(res, tmp);\n      }\n      prid(res);\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<double,double>pdd;\n\nconst int MAX_N = 12;\n\nint x[MAX_N],y[MAX_N],l[MAX_N];\nint n;\n\ndouble dir(double x1,double y1,double z1,double x2,double y2,double z2)\n{\n    return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1);\n}\n\npdd inter(double a1,double b1,double a2,double b2)\n{\n    pdd p;\n    p.first = (b2-b1)/(a1-a2);\n    p.second = p.first*a1 + b1;\n    return p;\n}\n\nbool possible(double r1,double r2,double r3)\n{\n    if(r1 + r2 > r3 && r2 + r3 > r1 && r1 + r3 > r2){\n        return true;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        double mx = 0.0;\n        rep(i,n){\n            scanf(\"%d%d%d\",&x[i],&y[i],&l[i]);\n        }\n        bool flag;\n        rep(i,n){\n            flag = false;\n            rep(j,n){\n                if(j != i){\n                    if(dir(x[i],y[i],l[i],x[j],y[j],0) > l[j]*l[j]){\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n            if(!flag){\n                mx = max(mx,(double)l[i]);\n            }\n        }\n\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                double r = sqrt(dir(x[i],y[i],0,x[j],y[j],0));\n                if(possible(r,l[i],l[j])){\n                    double t = (r*r + l[i]*l[i] - l[j]*l[j]) / (2*r);\n                    double h = sqrt(l[i]*l[i]-t*t);\n                    double s1 = ((r-t)*x[i] + t*x[j]) / r;\n                    double t1 = ((r-t)*y[i] + t*y[j]) / r;\n                    flag = false;\n                    rep(k,n){\n                        if(k != i && k != j){\n                            if(dir(s1,t1,h,x[k],y[k],0) > l[k]*l[k]){\n                                flag = true;\n                                break;\n                            }\n                        }\n                    }\n                    if(!flag){\n                        mx = max(mx,h);\n                    }\n                }\n            }\n        }\n\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                for(int k=j+1;k<n;k++){\n                    double r1 = sqrt(dir(x[i],y[i],0,x[j],y[j],0));\n                    double r2 = sqrt(dir(x[j],y[j],0,x[k],y[k],0));\n                    double r3 = sqrt(dir(x[i],y[i],0,x[k],y[k],0));\n                    if(possible(r1,l[i],l[j]) && possible(r2,l[j],l[k]) && possible(r3,l[k],l[i]) && possible(r1,r2,r3)){\n                        double xx,yy,zz;\n                        double dd1 = (x[i]*x[i] - x[j]*x[j]) + (y[i]*y[i] - y[j]*y[j]) - (l[i]*l[i] - l[j]*l[j]);\n                        double dd2 = (x[j]*x[j] - x[k]*x[k]) + (y[j]*y[j] - y[k]*y[k]) - (l[j]*l[j] - l[k]*l[k]);\n                        if(y[i] == y[j]){\n                            xx = dd1 / (2.0*(x[i]-x[j]));\n                            double a2 = -(double)(x[j] - x[k])/(y[j] - y[k]);\n                            double b2 = dd2 / (2.0*(y[j]-y[k]));\n                            yy = a2*xx + b2;\n                            zz = sqrt(l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]));\n                        }else{\n                            double a1 = -(double)(x[i] - x[j])/(y[i] - y[j]);\n                            double b1 = dd1 / (2.0*(y[i]-y[j]));\n                            if(y[j] == y[k]){\n                                xx = dd2 / (2.0*(x[j]-x[k]));\n                                yy = a1*xx + b1;\n                                zz = sqrt(l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]));\n                            }else{\n                                double a2 = -(double)(x[j] - x[k])/(y[j] - y[k]);\n                                double b2 = dd2 / (2.0*(y[j]-y[k]));\n                                pdd p = inter(a1,b1,a2,b2);\n                                xx = p.first,yy = p.second;\n                                zz = sqrt(l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]));\n                            }\n                        }\n                        flag = false;\n                        rep(m,n){\n                            if(m != i && m != j && m != k){\n                                if(dir(xx,yy,zz,x[m],y[m],0)>l[m]*l[m]){\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(!flag){\n                            mx = max(mx,zz);\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%.10f\\n\",mx);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<double> xs(N), ys(N), ls(N);\n\tREP(i,N) cin >> xs[i] >> ys[i] >> ls[i];\n\n\tdouble lb = 0, ub = 300;\n\tREP(loop,100){\n\t  double h = (lb + ub) / 2;\n\t  bool ok = true;\n\t  REP(i,N){\n\t\tdouble r1_ = ls[i]*ls[i] - h*h;\n\t\tif(r1_ < 0){\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t\tREP(j,N){\n\t\t  double r2_ = ls[j]*ls[j] - h*h;\n\t\t  if(r2_ < 0){\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t  }\n\t\t  if((xs[i]-xs[j])*(xs[i]-xs[j])\n\t\t\t +(ys[i]-ys[j])*(ys[i]-ys[j]) >= pow(sqrt(r1_)+sqrt(r2_),2))\n\t\t\tok = false;\n\t\t}\n\t  }\n\n\t  if(ok) lb = h;\n\t  else ub = h;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 10;\n  double ans=1;\n  while(len > 5e-9){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-2e-4;\n  }\n\n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<float, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt(double(bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\n\tdouble x,y;\n};\n\nstruct Info{\n\n\tPoint point;\n\tdouble length;\n};\n\nint N;\nInfo info[12];\n\n\ndouble calc(double X,double Y){\n\n\tdouble ret = BIG_NUM;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tret = min(ret,info[i].length*info[i].length-\n\t\t\t\t((X-info[i].point.x)*(X-info[i].point.x)+\n\t\t\t\t\t\t(Y-info[i].point.y)*(Y-info[i].point.y)));\n\t}\n\n\treturn ret;\n\n}\n\ndouble thirds_searchY(double X){\n\n\tdouble L = -101,R = 101;\n\n\tfor(int loop = 0; loop < 100; loop++){\n\n\t\tdouble mid1 = (2.0*L+R)/3.0;\n\t\tdouble mid2 = (1.0*L+2.0*R)/3.0;\n\n\t\tif(calc(X,mid1) > calc(X,mid2)){\n\n\t\t\tR = mid2;\n\t\t}else{\n\n\t\t\tL = mid1;\n\t\t}\n\t}\n\n\treturn calc(X,(L+R)/2);\n}\n\ndouble thirds_searchX(){\n\n\tdouble L = -101,R = 101;\n\n\tfor(int loop = 0; loop < 100; loop++){\n\n\t\tdouble mid1 = (2.0*L+R)/3.0;\n\t\tdouble mid2 = (1.0*L+2.0*R)/3.0;\n\n\t\tif(thirds_searchY(mid1) > thirds_searchY(mid2)){\n\n\t\t\tR = mid2;\n\t\t}else{\n\n\t\t\tL = mid1;\n\t\t}\n\t}\n\n\treturn thirds_searchY((L+R)/2);\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lf %lf %lf\",&info[i].point.x,&info[i].point.y,&info[i].length);\n\t}\n\n\tprintf(\"%.10lf\\n\",sqrt(thirds_searchX()));\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Complex;\n\nconst double EPS = 1e-10, PI = M_PI;\nll N;\nComplex P[10];\ndouble L[10];\n\nbool ok(double h) {\n  vector<double> r(N);\n  REP(i, 0, N) {\n    if(h > L[i]) return false;\n    r[i] = sqrt(L[i] * L[i] - h * h);\n  }\n\n  bool ret = false;\n  REP(m, 0, N) {\n    vector<pair<double, double>> theta(N);\n    REP(i, 0, N) if(i != m) {\n      Complex p1 = P[m], p2 = P[i];\n      double r1 = r[m], r2 = r[i];\n\n      if(abs(p2 - p1) > r1 + r2) return false;\n      if(abs(p2 - p1) < abs(r2 - r1)) {\n        if(r1 < r2) {\n          theta[i] = pair<double, double>(-PI, PI);\n        } else {\n          theta[i] = pair<double, double>(1e20, 1e20);\n        }\n        continue;\n      }\n\n      double d = abs(p2 - p1);\n      double t = abs((d * d + r1 * r1 - r2 * r2) / (d * 2));\n      double h = sqrt(r1 * r1 - t * t);\n\n      Complex u = (p2 - p1) / d;\n      Complex v = u * Complex(0, 1);\n      Complex q1 = p1 + u * t - v * h;\n      Complex q2 = p1 + u * t + v * h;\n\n      double theta1 = arg(q1 - p1);\n      double theta2 = arg(q2 - p1);\n      theta[i] = pair<double, double>(theta1, theta2);\n    }\n\n    vector<double> uniq;\n    REP(i, 0, N) if(i != m) {\n      uniq.push_back(theta[i].first);\n      uniq.push_back(theta[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pair<ll, ll>> range(N);\n    REP(i, 0, N) if(i != m) {\n      range[i].first = upper_bound(uniq.begin(), uniq.end(), theta[i].first) - uniq.begin() - 1;\n      range[i].second = upper_bound(uniq.begin(), uniq.end(), theta[i].second) - uniq.begin() - 1;\n    }\n\n    ll k = uniq.size();\n    vector<ll> sum(k * 2 + 1, 0);\n    REP(i, 0, N) if(i != m) {\n      if(range[i].first <= range[i].second) {\n        sum[range[i].first]++;\n        sum[range[i].second + 1]--;\n      } else {\n        sum[range[i].first]++;\n        sum[k]--;\n        sum[0]++;\n        sum[range[i].second + 1]--;\n      }\n    }\n    REP(i, 0, k) sum[i + 1] += sum[i];\n\n    REP(i, 0, k + 1) ret = ret || sum[i] >= N - 1;\n  }\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) {\n      double x, y;\n      cin >> x >> y >> L[i];\n      P[i] = Complex(x, y);\n    }\n\n    double l = 1, h = 1e5;\n    REP(_, 0, 100) {\n      double m = (l + h) / 2;\n      if(ok(m)) l = m; else h = m;\n    }\n    printf(\"%.15lf\\n\", l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nstruct vec{\n    double x,y;\n    vec(){x=y=0.0;};\n    vec(double x, double y): x(x), y(y){};\n    inline double add(double a, double b){\n        return abs(a+b)<(1e-10)*(abs(a)+abs(b))?0.0:a+b;\n    }\n    vec operator-(vec b){\n        return vec(add(x,-b.x),add(y,-b.y));\n    }\n    vec operator+(vec b){\n        return vec(add(x,b.x),add(y,b.y));\n    }\n    vec operator*(double d){\n        return vec(x*d,y*d);\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    double norm(){\n        return hypot(x,y);\n    }\n};\n\npair<vec,vec> cross_point(vec&C1, vec&C2, double r1, double r2){\n    vec e1,e2,P1,P2;\n    double d=(C2-C1).norm();\n    e1=(C2-C1)*(1/d);\n    double theta = acos((r1*r1+(C2-C1).dot(C2-C1)-r2*r2)/(2*r1*d));\n    e2.x=cos(theta)*e1.x-sin(theta)*e1.y, e2.y=sin(theta)*e1.x+cos(theta)*e1.y;\n    P1=C1+e2*r1;\n    e2.x=cos(theta)*e1.x+sin(theta)*e1.y, e2.y=-sin(theta)*e1.x+cos(theta)*e1.y;\n    P2=C1+e2*r1;\n    if(P1.x==P2.x){\n        if(P1.y<P2.y) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.x<P2.x)return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\ndouble radius(double h, double l){\n    return sqrt(l*l-h*h);\n}\nint n;\nvector<vec> V;\nvector<double> L;\n\nbool iswrap(vec point, vector<double> &LL){\n    for(int i=0;i<n;i++){\n        double d = (V[i]-point).norm();\n        if(LL[i]+1e-9<d) return false;\n    }\n    return true;\n}\n\nbool test(double h){\n    vector<double> LL(n);\n    for(int i=0;i<n;i++) LL[i]=radius(h,L[i]);\n    for(int i=0;i<n;i++){\n        if(iswrap(V[i],LL)) return true;\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            //??¢?????????\n            double d = (V[i]-V[j]).norm();\n            if(d>LL[i]+LL[j]){\n                return false;\n            }\n            //??????\n            if(d+min(LL[i],LL[j])<max(LL[i],LL[j])){\n                continue;\n            }\n            //??????\n            auto PP = cross_point(V[i],V[j],LL[i],LL[j]);\n            if(iswrap(PP.first,LL)||iswrap(PP.second,LL)) return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    cout<<fixed;\n    cout.precision(7);\n    while(cin>>n,n){\n        V.clear();\n        L.clear();\n        for(int i=0;i<n;i++){\n            int x,y,l;\n            cin>>x>>y>>l;\n            V.emplace_back(x,y);\n            L.push_back(l);\n        }\n        double lb=1,ub=1000;\n        for(auto l:L) ub=min(ub,l);\n        int cnt=50;\n        while(cnt--){\n            double mid=(ub+lb)/2;\n            if(test(mid)){\n                lb=mid;\n            }else{\n                ub=mid;\n            }\n        }\n        cout<<ub<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint N;\ndouble xs[11];\ndouble ys[11];\ndouble ls[11];\n\ntypedef complex<double> P;\n\n// 三角形の面積をヘロンの公式で３辺から計算\ndouble calcTriangleArea(double a,double b,double c){\n  double s=(a+b+c)/2;\n  if(EQ(abs(sqrt(s*(s-a)*(s-b)*(s-c))),0))return 0;\n  return sqrt(abs(s*(s-a)*(s-b)*(s-c)));\n}\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 内積\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(const P &a1, const P &a2, const P &b1, const P &b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nbool EQV(P &p1,P &p2){\n  return (EQ(p1.real(),p2.real())&&EQ(p1.imag(),p2.imag()));\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(const P &a, const P &b, const P &c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 2点が作る三角形の高さ\ndouble getTriH(int idx1,int idx2){\n  P p1=P(xs[idx1],ys[idx1]);\n  P p2=P(xs[idx2],ys[idx2]);\n  \n  const double x=abs(p1-p2);\n  // 高さを計算\n  const double S=calcTriangleArea(x,ls[idx1],ls[idx2]);\n  double h=2*S/x;\n  return h;\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++)cin>>xs[i]>>ys[i]>>ls[i];\n    double ans=-1;\n    // 風船が真ん中にある場合の計算\n    double minHeight=1e+10;\n    int idx1=-1;\n    for(int i=0;i<N;i++){\n      double h=sqrt(ls[i]*ls[i]-pow(abs(P(xs[i],ys[i])),2));\n      if(minHeight>h){\n        minHeight=h;\n        idx1=i;\n      }\n    }\n    {\n      // idxの方向へ風船が移動する\n      // 初期の角度を求めておき、角度で二分探索を行う\n      double lb=asin(minHeight/ls[idx1]);\n      double ub=PI/2;\n      //cout<<lb<<endl;\n      for(int ite=0;ite<200;ite++){\n        double mid=(ub+lb)/2;\n        // この角度の時の風船のx,y座標pおよび高さzを計算\n        double z=ls[idx1]*sin(mid);\n        double len=abs(P(xs[idx1],ys[idx1]))-ls[idx1]*cos(mid);\n        // 風船の座標\n        P v=P(xs[idx1],ys[idx1]);v/=abs(v);v*=len;\n        //cout<<v<<endl;\n        // idx1以外の風船について,必要ロープ長を計算\n        int cnt=0;\n        for(int i=0;i<N;i++){\n          if(i==idx1)continue;\n          double lope=sqrt(z*z+pow(v.real()-xs[i],2)+pow(v.imag()-ys[i],2));\n          if(EQ(lope,ls[i])||lope>ls[i])\n            cnt++;\n        }\n        if(cnt>0)ub=mid;\n        else lb=mid;\n      }\n      // ubの地点における,風船の数によって場合分け\n      double mid=ub;\n      // この角度の時の風船のx,y座標pおよび高さzを計算\n      double z=ls[idx1]*sin(mid);\n      double len=abs(P(xs[idx1],ys[idx1]))-ls[idx1]*cos(mid);\n      // 風船の座標\n      P v=P(xs[idx1],ys[idx1]);v/=abs(v);v*=len;\n      // idx1以外の風船について,必要ロープ長を計算\n      int cnt=0;\n      int idx2=-1;\n      for(int i=0;i<N;i++){\n        if(i==idx1)continue;\n        double lope=sqrt(z*z+pow(v.real()-xs[i],2)+pow(v.imag()-ys[i],2));\n        if(EQ(lope,ls[i])||lope>ls[i]){\n          cnt++;\n          idx2=i;\n        }\n      }\n      //cout<<idx1<<\" \"<<idx2<<\" \"<<mid<<\" \"<<PI/2<<endl;\n      // もしcntが0なら、答えはidx1の点のロープ長\n      if(cnt==0)ans=ls[idx1];\n      // そうでない場合、もう1点の候補を探す\n      else{\n        // 座標vが風船の初期位置で、ここからidx1,idx2の場所の作る線分の方向へ風船は移動する\n        P p1=P(xs[idx1],ys[idx1]);\n        P p2=P(xs[idx2],ys[idx2]);\n        //cout<<v<<\" \"<<p1<<\" \"<<p2<<endl;\n        // 単位ベクトルを計算しておく\n        P e;\n        if(!(cross(p2-p1,v-p1)>EPS)){\n          e=p2-p1;\n          e/=abs(e);\n          e=roundPoint(e,PI/2);\n        }\n        else{\n          e=p2-p1;\n          e/=abs(e);\n          e=roundPoint(e,-PI/2);\n        }\n        //cout<<e<<endl;\n        // vからp1-p2への長さ\n        double len=distance_ls_p(p1,p2,v);\n        double r=getTriH(idx1,idx2);\n        // 角度を計算\n        double lb=asin(z/r);\n        double ub=PI/2;\n        for(int ite=0;ite<200;ite++){\n          double mid=(ub+lb)/2;\n          // この角度でのx,y座標および高さzを計算\n          double zz=r*sin(mid);\n          // 風船の座標\n          P vv=e*(len-r*cos(mid))+v;\n          int cnt=0;\n          for(int i=0;i<N;i++){\n            if(idx1==i||idx2==i)continue;\n            double lope=sqrt(zz*zz+pow(vv.real()-xs[i],2)+pow(vv.imag()-ys[i],2));\n            if(EQ(lope,ls[i])||lope>ls[i]){\n              cnt++;\n            }\n          }\n          if(cnt>0)ub=mid;\n          else lb=mid;\n        }\n        // 最終的に、ubの位置でのzが答えになる\n        ans=r*sin(ub);\n      }\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  //cerr<<\"judge::\"<<m<<\" \";\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  //cerr<<\" val \";\n  bool hoge = true;\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m)+EPS)continue;\n      if(dist+in[j].R(m)<=in[i].R(m)+EPS)continue;\n      hoge = false;\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return hoge;\n}\n\ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return m;\n  if(judge(m)){\n    //cerr<<\"true\"<<endl;\n    return req(m,r);\n  }else{\n    //cerr<<\"false\"<<endl;\n    return req(l,m);\n  }\n}\n\ndouble solve(){\n  double ans = req(1.0,300.0);\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\n\ndouble x[10],y[10],l[10];\n\ndouble ch(int i,double xx,double yy){\n\treturn l[i]*l[i]-(xx-x[i])*(xx-x[i])-(yy-y[i])*(yy-y[i]);\n}\n\ndouble C(double xx,double yy,int n){\n\tdouble ans=1e30;\n\tfor(int i=0;i<n;i++)ans=min(ans,ch(i,xx,yy));\n\treturn ans;\n}\n\ndouble CC(double xx,int n){\n\tdouble y0=-100000,y3=100000;\n\tfor(int i=0;i<500;i++){\n\t\tdouble y1=(2*y0+y3)/3.0;\n\t\tdouble y2=(y0+2*y3)/3.0;\n\t\tdouble c1=C(xx,y1,n),c2=C(xx,y2,n);\n\t\tif(c1>c2)y3=y2;\n\t\telse y0=y1;\n\t}\n\treturn C(xx,y0,n);\n}\nvoid solve(){\n\tint n;\n\tcin>>n;\n\tif(n==0) exit(0);\n\t\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>l[i];\n\t\n\tdouble x0=-100000,x3=100000;\n\t\n\tfor(int i=0;i<500;i++){\n\t\tdouble x1=(2*x0+x3)/3.0;\n\t\tdouble x2=(x0+2*x3)/3.0;\n\t\tdouble c1=CC(x1,n),c2=CC(x2,n);\n\t\tif(c1>c2)x3=x2;\n\t\telse x0=x1;\n\t}\n\t\n\t\n\tdouble ans=CC((x0+x3)/2,n);\n\t\tprintf(\"%.10lf\\n\",sqrt(ans));\n}\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n#define EPS (1e-10)    //誤差\nconst double INF = 10000;\n\nstruct cercle{\n    P point;\n    double r;\n};\n\npair<P, P> cc_cross(cercle c1, cercle c2){\n    double d = abs(c1.point - c2.point);\n    double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    double rs = sqrt(c1.r * c1.r - rc * rc);\n    P diff = (c2.point - c1.point) / d;\n    return make_pair(c1.point + diff * P(rc, rs), c1.point + diff * P(rc, -rs));\n}\n\nbool C(vector<cercle> vec){\n\n    int n = (int)vec.size();\n\n    //調べる点の集合\n    vector<P> point_set;\n    \n    //中点をpoint_setに追加\n    for(int i = 0; i < n; i++){\n        //cout << \"add\" << endl;\n        point_set.push_back(vec[i].point);\n    }\n\n    //任意の二頂点間の交点をpoint_setに追加\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++){\n\n            double d = abs(vec[i].point - vec[j].point);\n            \n            if(abs(vec[i].r - vec[j].r) <= d && d <= vec[i].r + vec[j].r){\n                //cout << \"ADD\" << endl;\n                pair<P, P> sec = cc_cross(vec[i], vec[j]);\n                //cout << \"f\" << endl;\n                //point_set.push_back(sec.first);\n                //cout << \"f\" << endl;\n                point_set.push_back(sec.first);\n                //cout << \"s\" << endl;\n                point_set.push_back(sec.second);\n                //cout << sec.first << \" \" << sec.second << endl;\n            }\n        }\n    }\n\n    //point_setを全てためす\n    bool flag = false;\n    //cout << point_set.size() << endl;\n    for(auto po : point_set){\n\n        //cout << \"po\" << endl;\n        //cout << po << endl;\n\n        bool ok = true;\n        for(int i = 0; i < n; i++){\n            double d = abs(po - vec[i].point);\n            if(d > vec[i].r + 1e-9){\n                ok = false;\n                i += n;\n            }\n        }\n\n        //cout << \"ok \" << ok << endl;\n        if(ok){\n            flag = true;\n            break;\n        }\n\n    }\n\n    //cout << \"flag\" << flag << endl;\n    return flag;\n}\n\nint main(){\n\n    while(1){\n\n        int n; cin >> n;\n        if(!n) break;\n\n        vector<double> x(n);\n        vector<double> y(n);\n        vector<double> l(n);\n        double ub = INF;\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> l[i];\n            ub = min(ub, l[i]);\n        }\n\n        double lb = 0;\n        \n        //cout << lb << \" \" << ub << endl;\n\n        for(int i = 0; i < 100; i++){\n            double d = (lb + ub) / 2;\n\n            vector<cercle> vec(n);            \n            for(int i = 0; i < n; i++){\n\n                vec[i].point = P(x[i], y[i]);\n                vec[i].r = sqrt(l[i] * l[i] - d * d);\n\n            }\n\n            //cout << d << endl;\n            for(int i = 0; i < n; i++){\n\n                //cout << vec[i].point.real() << \" \" << vec[i].point.imag() << \" \" << vec[i].r << endl;\n            }\n\n            //cout << d << \" \" << C(vec) << endl;\n\n            if(C(vec)) lb = d;\n            else ub = d;\n        }\n        \n        /*double d = 17.0;\n        cout << d << endl;\n        vector<cercle> vec(n);            \n        for(int i = 0; i < n; i++){\n\n            vec[i].point = P(x[i], y[i]);\n            vec[i].r = sqrt(l[i] * l[i] - d * d);\n        \n        }\n\n        for(int i = 0; i < n; i++){\n            cout << vec[i].point.real() << \" \" << vec[i].point.imag() << \" \" << vec[i].r << endl;\n        }\n\n        cout << C(vec) << endl;\n        */\n        printf(\"%f\\n\", lb);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ndouble eps=1e-8;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\ndouble x[11],y[11],l[11];\n\nCircle circles[11];\nvector<Point> cands;\n\nbool inCircle(Circle c,Point p){//境界上でもtrue\n\tdouble d=pointsDistance(c.center,p);\n\tint s=sgn(d-c.r);\n\tif(s<=0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N;i++) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble lb=0;\n\t\tdouble ub=1000;\n\t\tfor(int i=0;i<N;i++) ub=min(ub,l[i]);\n\t\tfor(int stage=0;stage<100;stage++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircles[i]=Circle(Point(x[i],y[i]),sqrt(l[i]*l[i]-mid*mid));\n\t\t\t}\n\t\t\tcands.clear();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tvector<Point> tmp;\n\t\t\t\t\ttmp=circlesIntersection(circles[i],circles[j]);\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\tcands.push_back(tmp[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(cands.size()==0){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tcands.push_back(circles[i].center);\n\t\t\t\t}\n\t\t\t//}\n\t\t\tbool ok=false;\n\t\t\tfor(int i=0;i<cands.size();i++){\n\t\t\t\tbool flg=true;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(inCircle(circles[j],cands[i])==false) flg=false;\n\t\t\t\t}\n\t\t\t\tif(flg) ok=true;\n\t\t\t}\n\t\t\tif(ok) lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%f\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n \n    template<typename S, typename T> struct hash<pair<S, T>> {\n        inline size_t operator()(const pair<S, T> & v) const {\n            size_t seed = 0;\n            hash_combine(seed, v.first);\n            hash_combine(seed, v.second);\n            return seed;\n        }\n    };\n    // Recursive template code derived from Matthieu M.\n    template <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n    struct HashValueImpl\n    {\n        static void apply(size_t& seed, Tuple const& tuple)\n        {\n            HashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n            hash_combine(seed, std::get<Index>(tuple));\n        }\n    };\n \n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0>\n    {\n        static void apply(size_t& seed, Tuple const& tuple)\n        {\n            hash_combine(seed, std::get<0>(tuple));\n        }\n    };\n \n    template <typename ... TT>\n    struct hash<std::tuple<TT...>>\n    {\n        size_t\n            operator()(std::tuple<TT...> const& tt) const\n        {\n            size_t seed = 0;\n            HashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n            return seed;\n        }\n \n    };\n}\nll pow(ll base, ll i, ll mod) {\n    ll a = 1;\n    while (i) {\n        if (i & 1) {\n            a *= base;\n            a %= mod;\n        }\n        base *= base;\n        base %= mod;\n        i /= 2;\n    }\n    return a;\n}\nclass unionfind {\n    vector<int> par, rank, size_;//?????????§???????????????¢???????????????????????????rank???????????????size?????????\npublic:\n    unionfind(int n) :par(n), rank(n), size_(n, 1) {\n        iota(ALL(par), 0);\n    }\n    int find(int x) {\n        if (par[x] == x)return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        par[y] = x;\n        size_[x] += size_[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        return size_[find(x)];\n    }\n};\nll gcd(ll a, ll b) {\n    while (b) {\n        ll c = a%b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    return a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n    a = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n    a = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n    a = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n    a = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n    a = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n    return (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n    vector<T> obj;\n    int offset;\n    Func updater;\n    T e;\n    int bufsize(int num) {\n        int i = 1;\n        for (; num >i; i <<= 1);\n        offset = i - 1;\n        return (i << 1) - 1;\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l)return e;\n        if (a <= l && r <= b)return obj[k];\n        else return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n    }\npublic:\n    T query(int a, int b) {//[a,b)\n        return query(a, b, 0, 0, offset + 1);\n    }\n    void updateall(int l = 0, int r = -1) {\n        if (r < 0)r = offset + 1;\n        l += offset, r += offset;\n        do {\n            l = l - 1 >> 1, r = r - 1 >> 1;\n            for (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n        } while (l);\n    }\n    void update(int k, T &a) {\n        k += offset;\n        obj[k] = a;\n        while (k) {\n            k = k - 1 >> 1;\n            obj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n        }\n    }\n    segtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n    segtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n        copy(vec.begin(), vec.end(), obj.begin() + offset);\n        updateall();\n    }\n    typename vector<T>::reference operator[](int n) {\n        return obj[n + offset];\n    }\n};\ntemplate<class T>\nclass matrix {\n    vector<vector<T>> obj;\n    pair<int, int> s;\npublic:\n    matrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n    matrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n    static matrix e(int n) {\n        matrix a = (n);\n        for (int i = 0; i < n; i++)a[i][i] = 1;\n        return a;\n    }\n    matrix& operator+=(const matrix &p) {\n        if (s != p.s)throw runtime_error(\"matrix error\");\n        for (int i = 0; i < s.first; i++)\n            for (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n        return *this;\n    }\n    matrix operator+(const matrix &p) {\n        matrix res(*this);\n        return res += p;\n    }\n    matrix& operator-=(const matrix &p) {\n        if (s != p.s)throw runtime_error(\"matrix error\");\n        for (int i = 0; i < s.first; i++)\n            for (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n        return *this;\n    }\n    matrix operator-(const matrix &p) {\n        matrix res(*this);\n        return res -= p;\n    }\n    matrix& operator*=(T p) {\n        for (auto &a : obj)\n            for (auto &b : a)b *= p;\n        return *this;\n    }\n    matrix operator*(T p) {\n        matrix res(*this);\n        return res *= p;\n    }\n    matrix operator*(const matrix &p) {\n        if (s.second != p.s.first)throw runtime_error(\"matrix error\");\n        matrix ret(s.first, p.s.second);\n        for (int i = 0; i < s.first; i++)\n            for (int j = 0; j < s.second; j++)\n                for (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n        return ret;\n    }\n    matrix &operator*=(const matrix &p) {\n        return *this = *this*p;\n    }\n    pair<int, int> size() const {\n        return s;\n    }\n    matrix &mod(T m) {\n        for (auto &a : obj)\n            for (auto &b : a)b %= m;\n        return *this;\n    }\n    typename vector<vector<T>>::reference operator[](int t) {\n        return obj[t];\n    }\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n    auto base_(base);\n    if (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n    matrix<T> res = matrix<T>::e(base_.size().first);\n    for (;;) {\n        if (exp & 1)res *= base_;\n        if (!(exp /= 2))break;\n        base_ *= base_;\n    }\n    return res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n    auto base_(base);\n    if (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n    matrix<T> res = matrix<T>::e(base_.size().first);\n    for (;;) {\n        if (exp & 1)(res *= base_).mod(m);\n        if (!(exp /= 2))break;\n        (base_ *= base_).mod(m);\n    }\n    return res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n    return lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n    int V;\n    struct edge { int to, cap, rev, cost; };\n    vector<vector<edge>> G;\n    vector<int> level, iter, h, dist, prevv, preve;\npublic:\n    Flow(int size) :G(size + 1), V(size + 1) {\n    }\n    void add_edge(int from, int to, int cap, int cost = 0) {\n        G[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n        G[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t)return f;\n        for (int &i = iter[v]; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        level.resize(V);\n        iter.resize(V);\n        int flow = 0;\n        for (;;) {\n            bfs(s);\n            if (level[t] < 0)return flow;\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n                flow += f;\n            }\n        }\n    }\n    typedef pair<int, int> P;\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        h.resize(V);\n        dist.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n        fill(h.begin(), h.end(), 0);\n        while (f > 0) {\n            priority_queue<P, vector<P>, greater<P>> que;\n            fill(dist.begin(), dist.end(), numeric_limits<int>::max());\n            dist[s] = 0;\n            que.push({ 0,s });\n            while (!que.empty()) {\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if (dist[v] < p.first)continue;\n                for (int i = 0; i < G[v].size(); i++) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push({ dist[e.to],e.to });\n                    }\n                }\n            }\n            if (dist[t] == numeric_limits<int>::max()) {\n                return -1;\n            }\n            for (int v = 0; v < V; v++)h[v] += dist[v];\n \n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n     "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//?????????\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> point;\ntypedef point vec;\ntypedef array<point, 2> line;\ntypedef vector<point> poly;\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n};\n\nenum geometry {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n\tbool operator<(point a, point b) {\n\t\tif (!EQ(a.X, b.X)) return a.X < b.X;\n\t\tif (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n\t\treturn false;\n\t}\n\n\tbool operator>(point a, point b) {\n\t\treturn b<a;\n\t}\n\n\tbool operator<=(point a, point b) {\n\t\treturn !(a>b);\n\t}\n}\n\ndouble dot(point a, point b) {\n\treturn (conj(a)*b).X;\n}\n\ndouble cross(point a, point b) {\n\treturn (conj(a)*b).Y;\n}\n\ngeometry ccw(point a, point b, point c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > EPS) return CCW; // ccw\n\tif (cross(b, c) < -EPS) return CW; // cw\n\tif (dot(b, c) < 0) return CAB; // c - a - b\n\tif (norm(b) < norm(c)) return ABC; // a - b - c\n\treturn ERROR;\n}\n\npoint proj(line l, point p) {\n\tpoint v = l[1]-l[0];\n\tdouble ratio = dot(v, p-l[0]) / norm(v);\n\treturn l[0] + ratio*v;\n}\n\npoint refl(line l, point p) {\n\treturn p + (proj(l, p) - p) * 2.0;\n}\n\nvec rotate(vec v, double r) {\n\treturn v*vec(cos(r), sin(r));\n}\n\nvec Normalvec(line l){\n\tvec v=(vec)l[1]-l[0];\n\treturn vec (v.Y,-v.X);\n}\n\nbool IsOrthogonal(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(line l, line m) {\n\tif (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n\tif (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n\treturn false;\n}\n\nbool IntersectLS(line l, line s) {\n\tpoint b = l[0];\n\tvec v = l[1]-l[0];\n\treturn cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(line s, line t) {\n\tif (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n\tif (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n\treturn true;\n}\n\nbool IntersectLP(line l, point p) {\n\treturn EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(line s, point p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(line l) {\n\treturn abs(l[0]-l[1]);\n}\n\ndouble DistLP(line l, point p) {\n\treturn abs(p - proj(l, p));\n}\n\ndouble DistLL(line l, line m) {\n\tif (!IntersectLL(l, m)) return 0;\n\treturn DistLP(l, m[0]);\n}\n\ndouble DistLS(line l, line s) {\n\tif (IntersectLS(l, s)) return 0;\n\treturn min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(line s, point p) {\n\tpoint r = proj(s, p);\n\tif (IntersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(line s, line t) {\n\tif (IntersectSS(s, t)) return 0;\n\n\tdouble a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n\tdouble b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n\treturn min(a, b);\n}\n\nline PerpendBisect(line seg) {\n\tpoint mid = (seg[0]+seg[1])/2.0;\n\treturn line{mid, mid+(seg[1]-seg[0])*vec(0, 1)};\n}\n\npoint CrosspointLL(line l, line m) {\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\tif (abs(A) < EPS) assert(0);\n\treturn m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<point> CrosspointCL(circle c, line l) {\n\tvector<point> ret;\n\tdouble d = DistLP(l, c.c);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(proj(l, c.c));\n\t} else if (d < c.r) {\n\t\tdouble ratio = sqrt(c.r*c.r - d*d);\n\t\tvec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n\t\tret.emplace_back(proj(l, c.c) + ratio*sgn);\n\t\tret.emplace_back(proj(l, c.c) - ratio*sgn);\n\t}\n\n\treturn ret;\n}\n\nvector<point> CrosspointCS(circle c, line s) {\n\tvector<point> ret;\n\tvector<point> res = CrosspointCL(c, s);\n\tif (s[0] > s[1]) swap(s[0], s[1]);\n\tfor (point p : res) {\n\t\tif (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n\t}\n\treturn ret;\n}\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nline CapCS(circle c, line s) {\n\tpoint inf(INF, INF);\n\tvector<point> cros = CrosspointCS(c, s);\n\tif (cros.empty()) return line{inf, inf};\n\n\tif (cros.size() == 1) {\n\t\tdouble ad = abs(s[0]-c.c);\n\t\tdouble bd = abs(s[1]-c.c);\n\t\tif (ad < min(bd, c.r)) cros.emplace_back(s[0]);\n\t\telse if (bd < min(ad, c.r)) cros.emplace_back(s[1]);\n\t\telse {\n\t\t\tpoint p = cros[0];\n\t\t\tcros.emplace_back(p); // avoid an undefined behavior\n\t\t}\n\t}\n\n\tif (cros[1] < cros[0]) {\n\t\tswap(cros[0], cros[1]);\n\t}\n\n\treturn line{cros[0], cros[1]};\n}\n\ngeometry Positioningpoint(poly poly, point p) {\n\tbool in = false;\n\tint n = poly.size();\n\tfor (int i=0; i<n; i++) {\n\t\tpoint a = poly[i];\n\t\tpoint b = poly[(i+1)%n];\n\t\tvec u = a - p;\n\t\tvec v = b - p;\n\n\t\tif (u.Y > v.Y) swap(u, v);\n\n\t\tdouble cr = cross(u, v);\n\t\tif (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n\t\tif (IntersectSP({a, b}, p)) return ON_LINE;\n\t}\n\n\tif (in) return INSIDE;\n\treturn OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\npoly GrahamScan(vector<point> ps) {//Get convex hull.\n\tif (ps.size() <= 2) return ps;\n\n\tint k = 0;\n\tint n = ps.size();\n\tpoly ret(n*2);\n\n\tsort(ps.begin(), ps.end());\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tint k_ = k;\n\tfor (int i=n-1; i>=0; i--) {\n\t\twhile (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tret.resize(k-1);\n\treturn ret;\n}\n\nbool IsConvex(poly ps) {\n\treturn GrahamScan(ps).size() == ps.size();\n}\n\npoly CapConvexes(poly pp, poly qq) {\n#if DEBUG\n\tassert (IsConvex(pp));\n\tassert (IsConvex(qq));\n#endif\n\n\tpoly ret;\n\tint a = 0;\n\tint b = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint n = pp.size();\n\tint m = qq.size();\n\tenum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n\tauto forward_a = [&](bool put) {\n\t\tif (put && in == PIN) ret.emplace_back(pp[a]);\n\t\ta = (a+1)%n;\n\t\taa++;\n\t};\n\n\tauto forward_b = [&](bool put) {\n\t\tif (put && in == QIN) ret.emplace_back(qq[b]);\n\t\tb = (b+1)%m;\n\t\tbb++;\n\t};\n\n\tauto intersect_1pt = [](point &a, point &b, point &c, point &d, point &r) {\n\t\tdouble D =\tcross(b - a, d - c);\n\t\tif (EQ(D, 0)) return false;\n\t\tdouble t =\tcross(c - a, d - c) / D;\n\t\tdouble s = -cross(a - c, b - a) / D;\n\t\tr = a + t * (b - a);\n\t\treturn GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n\t};\n\n\tdo {\n\t\tint apre = (a+n-1)%n;\n\t\tint bpre = (b+m-1)%m;\n\t\tdouble C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n\t\tdouble A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n\t\tdouble B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n\t\tpoint r;\n\t\tif (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n\t\t\tif (in == UNKNOWN) aa = bb = 0;\n\t\t\tret.emplace_back(r);\n\t\t\tif (B > 0) in = PIN;\n\t\t\telse if (A > 0) in = QIN;\n\t\t}\n\n\t\tif (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n\t\t\tif (in == PIN) forward_b(false);\n\t\t\telse forward_a(false);\n\t\t} else if (C >= 0) {\n\t\t\tif (A > 0) forward_a(true);\n\t\t\telse forward_b(true);\n\t\t} else {\n\t\t\tif (B > 0) forward_b(true);\n\t\t\telse forward_a(true);\n\t\t}\n\t} while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n\tif (in == UNKNOWN) {\n\t\tif (Positioningpoint(qq, pp[0]) != OUTSIDE) return pp;\n\t\tif (Positioningpoint(pp, qq[0]) != OUTSIDE) return qq;\n\t}\n\treturn ret;\n}\n\ndouble CalcArea(poly ps) {\n\tdouble ret = 0.0;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tret += cross(ps[i], ps[(i+1)%ps.size()]);\n\t}\n\treturn ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(poly ps) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\tint n = ps.size();\n\tint is = 0;\n\tint js = 0;\n\tfor (int i=1; i<n; i++) {\n\t\tif (ps[i].Y > ps[is].Y) is = i;\n\t\tif (ps[i].Y < ps[js].Y) js = i;\n\t}\n\n\tint maxi, maxj;\n\tdouble maxd = norm(ps[is]-ps[js]);\n\tint i = is;\n\tint j = js;\n\tdo {\n\t\tvec a = ps[i+1] - ps[i];\n\t\tvec b = ps[j+1] - ps[j];\n\t\tif (cross(a, b) > -EPS) j = (j+1)%n;\n\t\telse i = (i+1)%n;\n\n\t\tdouble d = norm(ps[i]-ps[j]);\n\t\tif (d > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\n\treturn make_pair(maxi, maxj);\n}\n\nline ClosestPair(vector<point> ps) {\n\tauto CompareY = [](const point &a, const point &b) {\n\t\tif (a.Y != b.Y) return a.Y < b.Y;\n\t\treturn a.X < b.X;\n\t};\n\n\tfunction<line(point*,int)> Rec = [&Rec, &CompareY](point *ps, int n) {\n\t\tif (n <= 1) return line{point(0, 0), point(INF, INF)};\n\t\t\n\t\tint m = n/2;\n\t\tdouble x = ps[m].X;\n\t\tline a = Rec(ps, m);\n\t\tline b = Rec(ps+m, n-m);\n\t\tdouble mind = DistL(a);\n\t\tline ret = a;\n\t\tif (DistL(b) < mind) {\n\t\t\tmind = DistL(b);\n\t\t\tret = b;\n\t\t}\n\n\t\tsort(ps, ps+n, CompareY);\n\t\tvector<point> qs;\n\t\tqs.reserve(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (abs(ps[i].X - x) >= mind) continue;\n\n\t\t\tfor (int j=0; j<qs.size(); j++) {\n\t\t\t\tpoint p1 = ps[i];\n\t\t\t\tpoint p2 = qs[qs.size()-1-j];\n\t\t\t\tif (p1.Y - p2.Y >= mind) break;\n\n\t\t\t\tdouble d = abs(p1-p2);\n\t\t\t\tif (mind > d) {\n\t\t\t\t\tmind = d;\n\t\t\t\t\tret = line{p1, p2};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqs.emplace_back(ps[i]);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tint n = ps.size();\n\tassert (n >= 2);\n\tsort(ps.begin(), ps.end());\n\treturn Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<poly, poly> CutConvex(poly ps, line l) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\t//if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n\t//else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n\tpoly left;\n\tpoly right;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tpoint a = ps[i];\n\t\tpoint b = ps[(i+1)%ps.size()];\n\n\t\tif (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n\t\telse right.emplace_back(a);\n\n\t\tline m{a, b};\n\t\tif (IntersectLS(l, m)) {\n\t\t\tpoint p = CrosspointLL(l, m);\n\t\t\tleft.emplace_back(p);\n\t\t\tright.emplace_back(p);\n\t\t}\n\t}\n\n\treturn make_pair(left, right);\n}\n\ncircle Circum(point a, point b, point c) {\n\tcircle ret{{INF, INF}, 0.0};\n\tline l{a, b};\n\tline m{b, c};\n\tline lp = PerpendBisect(l);\n\tline mp = PerpendBisect(m);\n\tif (IsParallel(lp, mp)) return ret;\n\n\tret.c = CrosspointLL(lp, mp);\n\tret.r = abs(a-ret.c);\n\treturn ret;\n}\n\nvector<point> Tangentpoints(circle c, point p) {\n\tvector<point> ret;\n\tdouble d = abs(c.c-p);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(p);\n\t\treturn ret;\n\t}\n\n\tif (d < c.r) return ret;\n\n\tvec v = (p-c.c)/d*c.r;\n\tdouble t = acos(c.r/d);\n\tret.emplace_back(c.c + rotate(v, t));\n\tret.emplace_back(c.c + rotate(v, -t));\n\treturn ret;\n}\n\nvector<line> CommonTangents(circle p, circle q) {\n#if DEBUG\n\tassert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n\tdouble pr = p.r;\n\tdouble qr = q.r;\n\tpoint pc = p.c;\n\tpoint qc = q.c;\n\tdouble d = abs(pc - qc);\n\tdouble dr = abs(pr - qr);\n\tdouble sr = abs(pr + qr);\n\n\tvector<line> ret;\n\tif (EQ(d, sr)) {//If the 2 circles tangent exclusively,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > sr) {//If the 2 have no intersection,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\tfor (int i=0; i<2; i++) {\n\t\t\tline l{pts[0], qts[i]};\n\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\tret.emplace_back(l);\n\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t}\n\t\t}\n\t} \n\n\tif (EQ(d, dr)) {//If the 2 tangent inclusively,\n\t\tpoint cp = pc + (pc-qc) / (qr-pr) * pr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > dr) {//If the 2 intersect,\n\t\tif (EQ(pr, qr)) {\n\t\t\tpoint v = (qc - pc) / d * pr;\n\t\t\tv *= point(0, 1);\n\t\t\tret.emplace_back(line{pc+v, qc+v});\n\t\t\tret.emplace_back(line{pc-v, qc-v});\n\t\t} else {\n\t\t\tpoint cp = pc + (qc-pc) * pr / (pr-qr);\n\t\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\t\tfor (int i=0; i<2; i++) {\n\t\t\t\tline l{pts[0], qts[i]};\n\t\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\t\tret.emplace_back(l);\n\t\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\n\treturn ret;\n}\n\ntypedef pair<point,double> ppd;\n\npoint p[10];\ndouble l[10];\nppd h[10][10];\n\nppd ans2(int i,int j){\n\tif(h[i][j].sc!=0){\n\t\treturn h[i][j];\n\t}\n\tdouble r=abs(p[i]-p[j]);\n\tppd ret;\n\tif(abs(l[i]*l[i]-l[j]*l[j])>=r*r){\n\t\tif(l[i]>l[j]){\n\t\t\tret.fi=p[j];\n\t\t\tret.sc=l[j];\n\t\t}else{\n\t\t\tret.fi=p[i];\n\t\t\tret.sc=l[i];\n\t\t}\n\t}else{\n\t\tcircle c,d;\n\t\tc.c=p[i];\n\t\tc.r=l[i];\n\t\td.c=p[j];\n\t\td.r=l[j];\n\t\tvector<point> v=CrosspointCC(c,d);\n\t\tret.fi=(v[0]+v[1])/2.0;\n\t\tret.sc=abs(v[0]-v[1])/2.0;\n\t}\n\th[i][j]=ret;\n\th[j][i]=ret;\n\treturn ret;\n}\n\nvoid solve(int n){\n\tdouble ans=301;\n\tint i[5];\n\tfor(int j=0;j<n;++j){\n\t\tint x,y;\n\t\tcin>>x>>y>>l[j];\n\t\tp[j]=point (x,y);\n\t\tfill(h[j],h[j]+n,mp(0,0));\n\t}\n\tif(n==1){//for the sake of avoiding bugs\n\t\tcout<<fixed<<setprecision(5)<<l[0]<<endl;\n\t\treturn;\n\t}else if(n==2){//for the same purpose\n\t\tcout<<fixed<<setprecision(5)<<ans2(0,1).sc<<endl;\n\t\treturn;\n\t}\n\tfor(i[0]=0;i[0]<n-2;++i[0]){\n\t\ti[3]=i[0];\n\t\tfor(i[1]=i[0]+1;i[1]<n-1;++i[1]){\n\t\t\ti[4]=i[1];\n\t\t\tfor(i[2]=i[1]+1;i[2]<n;++i[2]){\n\t\t\t\tbool f=false;\n\t\t\t\tppd pa[4];\n\t\t\t\tvector<line> m;\n\t\t\t\tpa[0]=ans2(i[0],i[1]),pa[1]=ans2(i[1],i[2]),pa[2]=ans2(i[2],i[0]),pa[3]=pa[0];\n\t\t\t\tfor(int j=0;j<3;++j){//??????\n\t\t\t\t\tif(pa[j].fi==pa[j+1].fi){\n\t\t\t\t\t\tans=min(ans,pa[j].sc);\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tif(pa[j].fi!=p[i[j]]&&pa[j].fi!=p[i[j+1]]){\n\t\t\t\t\t\tdouble r=abs(pa[j].fi-p[i[j+2]]);\n\t\t\t\t\t\tif(r*r+pa[j].sc*pa[j].sc<=l[i[j+2]]*l[i[j+2]]){\n\t\t\t\t\t\t\tans=min(ans,pa[j].sc);\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tm.pb({pa[j].fi,pa[j].fi+Normalvec({p[i[j]],p[i[j+1]]})});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpoint z=CrosspointLL(m[0],m[1]);\n\t\t\t\tdouble r=abs(z-p[i[0]]);\n\t\t\t\tans=min(ans,sqrt(l[i[0]]*l[i[0]]-r*r));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(5)<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ndouble eps=1e-8;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\ndouble x[11],y[11],l[11];\n\nCircle circles[11];\nvector<Point> cands;\n\nbool inCircle(Circle c,Point p){//境界上でもtrue\n\tdouble d=pointsDistance(c.center,p);\n\tint s=sgn(d-c.r);\n\tif(s<=0) return true;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N;i++) scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble lb=0;\n\t\tdouble ub=1000;\n\t\tfor(int i=0;i<N;i++) ub=min(ub,l[i]);\n\t\tfor(int stage=0;stage<100;stage++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tcircles[i]=Circle(Point(x[i],y[i]),sqrt(l[i]*l[i]-mid*mid));\n\t\t\t}\n\t\t\tcands.clear();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\t\tvector<Point> tmp;\n\t\t\t\t\ttmp=circlesIntersection(circles[i],circles[j]);\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\tcands.push_back(tmp[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cands.size()==0){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tcands.push_back(circles[i].center);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int i=0;i<cands.size();i++){\n\t\t\t\tbool flg=true;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tif(inCircle(circles[j],cands[i])==false) flg=false;\n\t\t\t\t}\n\t\t\t\tif(flg) ok=true;\n\t\t\t}\n\t\t\tif(ok) lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%f\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\n\nconst D EPS = 1e-8;\n\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nP vec(L a) {return a.b - a.a;} \n\n// 直線の交点\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\nint n;\nP pp[11];\nD l[11], res;\n\n// ２点を決めてロープがピンと張る点\nP b(int i, int j) {return pp[i] + (pp[j] - pp[i]) * (norm(pp[i] - pp[j]) + l[i] * l[i] - l[j] * l[j]) / (2 * norm(pp[i] - pp[j]));}\n\n// 点を決めた時にどれだけ高くできるか求めてresを更新\nvoid h(P p) {\n  D r = 1e9;\n  rep (i, n) r = min(r, sqrt(max(l[i] * l[i] - norm(pp[i] - p), (D)0)));\n  res = max(res, r);\n}\n\nint main() {\n  while (cin >> n, n) {\n    rep (i, n) cin >> pp[i].X >> pp[i].Y >> l[i];\n    res = 0;\n    // １点\n    rep (i, n) h(pp[i]);\n    // ２点\n    rep (i, n) rep (j, i) h(b(i, j));\n    // ３点\n    rep (i, n) rep (j, i) rep (k, j) if (abs(det(pp[j] - pp[i], pp[k] - pp[i])) > EPS) {\n      P b1 = b(i, j), b2 = b(i, k);\n      h(pLL((L){b1, b1 + (pp[i] - pp[j]) * P(0, 1)}, (L){b2, b2 + (pp[i] - pp[k]) * P(0, 1)}));\n    }\n    printf(\"%.12Lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint n;\n\nint x[100],y[100],l[100];\n\npair<double,int> get(double cx,double cy){\n  double maxh = 500;\n  int idx=0;\n  \n  rep(i,n){\n    double dx=x[i]-cx;\n    double dy = y[i]-cy;\n    double dd=sqrt(dx*dx+dy*dy);\n    if(maxh > sqrt(max(0.,l[i]*l[i]-dd*dd))){\n      maxh=sqrt(max(0.,l[i]*l[i]-dd*dd));\n      idx=i;\n    }\n    \n  }\n  return mp(maxh,idx);\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n  double cx=x[0];\n  double cy=y[0];\n\n  double len = 100;\n  double ans=1;\n  while(len > 1e-7){\n    pair<double,int> a=get(cx,cy);\n    ans=max(ans,a.F);\n    double dx=cx-x[a.S];\n    double dy=cy-y[a.S];\n    double dd=sqrt(dx*dx+dy*dy);\n    cx -= dx*len/dd;\n    cy -= dy*len/dd;\n    len *= 1-1e-4;\n  }\n\n  printf(\"%.8f\\n\",ans);\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n//const ll mod = 1000000007;\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\ndouble x[15], y[15], l[15];\nint N;\n\ntemplate<typename T> \nbool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ndouble check(double X, double Y) {\n    double ret = 1e9;\n    for(int i = 1; i <= N; i++) {\n        double h2 = pow(l[i], 2.0) - pow(x[i] - X, 2.0) - pow(y[i] - Y, 2.0);\n        if(h2 >= 0) chmin(ret, pow(h2, 0.5));\n        else ret = 0.0;\n    }\n    return ret;\n}\n\ndouble dist(int i, int j) {\n    double dx = x[i] - x[j];\n    double dy = y[i] - y[j];\n    return pow(dx * dx + dy * dy, 0.5);\n}\n\nint main() {\n    cout.precision(10);\n    while(true) {\n        cin >> N;\n        if(N == 0) break;\n        for(int i = 1; i <= N; i++) cin >> x[i] >> y[i] >> l[i];\n        double ans = 0.0;\n        for(int i = 1; i <= N; i++) {\n            chmax(ans, check(x[i], y[i]));\n        }\n        for(int i = 1; i <= N; i++) {\n            for(int j = i + 1; j <= N; j++) {\n                double ok = 0;\n                double ng = min(l[i], l[j]);\n                for(int _ = 1; _ <= 100; _++) {\n                    double mid = (ok + ng) / 2.0;\n                    double d1 = pow(pow(l[i], 2.0) - pow(mid, 2.0), 0.5);\n                    double d2 = pow(pow(l[j], 2.0) - pow(mid, 2.0), 0.5);\n                    if(d1 + d2 + EPS >= dist(i, j)) ok = mid;\n                    else ng = mid;\n                }\n                double d1 = pow(pow(l[i], 2.0) - pow(ok, 2.0), 0.5);\n                double dx = (x[j] - x[i]) / dist(i, j);\n                double dy = (y[j] - y[i]) / dist(i, j);\n                chmax(ans, check(x[i] + dx * d1, y[i] + dy * d1));\n            }\n        }\n        for(int i = 1; i <= N; i++) {\n            Point Pi(x[i], y[i]);\n            for(int j = i + 1; j <= N; j++) {\n                Point Pj(x[j], y[j]);\n                for(int k = 1; k <= N; k++) {\n                    if(k == i) continue;\n                    if(k == j) continue;\n                    Point Pk(x[k], y[k]);\n                    double ok = 0;\n                    double ng = min(l[i], min(l[j], l[k]));\n                    for(int _ = 1; _ <= 100; _++) {\n                        double mid = (ok + ng) / 2;\n                        double ri = pow(pow(l[i], 2.0) - pow(mid, 2.0), 0.5);\n                        double rj = pow(pow(l[j], 2.0) - pow(mid, 2.0), 0.5);\n                        if(ri + rj <= dist(i, j) + EPS) {\n                            ng = mid;\n                            continue;\n                        }\n                        Circle Ci(Pi, ri);\n                        Circle Cj(Pj, rj);\n                        auto PP = crosspoint(Ci, Cj);\n                        double rk = pow(pow(l[k], 2.0) - pow(mid, 2.0), 0.5);\n                        if(distance(PP.first, Pk) <= rk + EPS) ok = mid;\n                        else if(distance(PP.second, Pk) <= rk + EPS) ok = mid;\n                        else ng = mid;\n                    }\n                    double ri = pow(pow(l[i], 2.0) - pow(ok, 2.0), 0.5);\n                    double rj = pow(pow(l[j], 2.0) - pow(ok, 2.0), 0.5);\n                    Circle Ci(Pi, ri);\n                    Circle Cj(Pj, rj);\n                    auto PP = crosspoint(Ci, Cj);\n                    chmax(ans, check(PP.first.real(), PP.first.imag()));\n                    chmax(ans, check(PP.second.real(), PP.second.imag()));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw({ bl[i][0],bl[i][1] }, { bl[j][0],bl[j][1] }, { a,b });\n\t\t\tif (cc != ccw({ bl[j][0],bl[j][1] }, { bl[k][0],bl[k][1] }, { a,b }) || cc != ccw({ bl[k][0],bl[k][1] }, { bl[i][0],bl[i][1] }, { a,b }))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n#define PI 3.14159265358979323846\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P,i) - curr(P,i))\n#define EQ(x,y) (fabs((x)-(y))<EPS)\n#define GE(x,y) ((x)+EPS>(y))\n#define LE(x,y) ((x)<(y)+EPS)\nenum { OUT, ON, IN };\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(){}\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < -EPS)   return -1;       // clockwise\n  if (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)+EPS) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<P> crosspointLC(const L &l, const C &c){\n\tvector<P> res;\n\tP p = projection(l, c.p);\n\tdouble d1 = abs(p - c.p);\n\tif(EQ(d1, c.r)){\n\t\tres.pb(p);\n\t\treturn res;\n\t}\n\tif(d1 > c.r){\n\t\treturn res;\n\t}\n\tdouble d2 = sqrt(c.r*c.r - d1*d1);\n\tP v = d2/abs(l[1] - l[0]) * (l[1] - l[0]);\n\tres.pb(p + v);\n\tres.pb(p - v);\n\treturn res;\n}\n\n#define sq(x) ((x)*(x))\n\nvector<P> crosspointCC(const C &c1, const C &c2){\n\tvector<P> res;\n\tP v = c2.p - c1.p;\n\tdouble d = abs(v);\n\tif(d < EPS){\n\t\tif(EQ(c1.r, c2.r)){ // coincide\n\t\t\tres.pb(c1.p + P(c1.r, 0));\n\t\t}\n\t\treturn res;\n\t}\n\tvector<double> thetas;\n\tif(EQ(d, c1.r + c2.r)){\n\t\tthetas.pb(0);\n\t}else if(EQ(d, c1.r - c2.r)){\n\t\tthetas.pb(0);\n\t}else if(EQ(d, c2.r - c1.r)){\n\t\tthetas.pb(PI);\n\t}else if(d > c1.r + c2.r || d < abs(c1.r - c2.r)){\n\t\treturn res;\n\t}else{\n\t\tdouble t = acos((sq(c1.r) + sq(d) - sq(c2.r))\n\t\t\t/ (2.0 * c1.r * d));\n\t\tthetas.pb(t);\n\t\tthetas.pb(-t);\n\t}\n\trep(i, sz(thetas)){\n\t\tres.pb(c1.p + c1.r/d * v\n\t\t\t* P(cos(thetas[i]), sin(thetas[i])));\n\t}\n\treturn res;\n}\n\nint n;\nP p[11];\ndouble l[11];\n\nvoid main2(){\n\tdouble lo=0,hi=300;\n\trep(ii,100){\n\t\tdouble mi=(lo+hi)/2;\n\t\tint ok=1;\n\t\tC c[11];\n\t\trep(i,n){\n\t\t\tif(mi>l[i]){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tc[i]=C(p[i],sqrt(l[i]*l[i]-mi*mi));\n\t\t}\n\t\tif(!ok){\n\t\t\thi=mi;continue;\n\t\t}\n\t\tvector<P> v;\n\t\trep(i,n)v.pb(p[i]);\n\t\trep(i,n)rep2(j,i+1,n){\n\t\t\tvector<P> w=crosspointCC(c[i],c[j]);\n\t\t\trep(k,sz(w))v.pb(w[k]);\n\t\t}\n\t\tok=0;\n\t\trep(i,sz(v)){\n\t\t\tint ok2=1;\n\t\t\trep(j,n)if(abs(v[i]-p[j]) > c[j].r+EPS){\n\t\t\t\tok2=0;break;\n\t\t\t}\n\t\t\tif(ok2){\n\t\t\t\tok=1;break;\n\t\t\t}\n\t\t}\n\t\tif(ok)lo=mi;\n\t\telse hi=mi;\n\t}\n\tcout<<setprecision(16)<<lo<<endl;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i]=P(x,y);\n\t\t\tcin>>l[i];\n\t\t}\n\t\tmain2();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\ntypedef double R;\ntypedef complex<R> P;\n#define EPS (1e-10)\nstruct C{P c;R r;};\n\ndouble n, x, y, l;\nC c[108];\nC tc[108];\npair<P, P> cross_circles(C a, C b){\n  R d = abs(a.c - b.c);\n  R l = ((a.r*a.r - b.r*b.r) / d + d) / 2.0;\n  R h = sqrt(a.r*a.r - l*l);\n  P e = a.c + (b.c-a.c) * l / d;\n  P p = (b.c-a.c) * h / d * P(0, -1);\n  return make_pair(e + p, e - p);\n}\n\nbool able(R h){\n  for(int i = 0;i < n;i++){\n    tc[i] = c[i];\n    if(c[i].r < h)return false;\n    tc[i].r = sqrt(tc[i].r*tc[i].r - h*h);\n  }\n  \n  vector<P> points;\n\n  for(int i = 0;i < n;i++){\n    for(int j = i + 1;j < n;j++){\n      if(abs(tc[i].c - tc[j].c) > tc[i].r + tc[j].r  - EPS)continue;\n      if(abs(tc[i].c - tc[j].c) < abs(tc[i].r - tc[j].r) + EPS)continue;\n      pair<P, P> tmp = cross_circles(tc[i], tc[j]);\n      points.push_back(tmp.first);\n      points.push_back(tmp.second);\n    }\n    points.push_back(tc[i].c);\n  }\n\n  for(int i = 0;i < points.size();i++){\n    bool tmp = true;\n    P p = points[i];\n    for(int j = 0;j < n;j++){\n      if(abs(p - tc[j].c) > tc[j].r + EPS)tmp = false;\n    }\n    if(tmp == true){\n      return true;\n      \n    }\n  }\n  return false;  \n}\n\nbool solve(){\n  cin >> n;\n  if(n == 0)return false;\n  double bottom = 0.5, top = 300;\n  for(int i = 0;i < n;i++){\n    cin >> x >> y >> l;\n    c[i].c = P(x, y);\n    c[i].r = l;\n    top = min(top, l);\n  }\n  for(int i = 0;i < 1000;i++){\n    double mid = (bottom + top) / 2;\n    if(able(mid))bottom = mid;\n    else top = mid;\n  }\n  printf(\"%.10lf\\n\", bottom);\n  return true;\n}\n\nint main(){\n  while(solve());return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define EPS 1e-10\n  \nstruct Point {\n    double x, y;\n  \n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n  \n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n      \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n      \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n      \n    Point operator / (const double &k) const {\n        return Point(x / k, y / k);\n    }\n};\n  \nPoint operator * (const Point &a, const Point &b)\n{\n    return Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n  \ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n  \ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n  \ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n  \ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n  \nstruct Circle {\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n  \nbool isIntersectCC(const Circle &a, const Circle &b)\n{\n    double d = abs(a.p - b.p);\n    return (d <= a.r + b.r && d >= abs(a.r - b.r));\n}\n  \nvector<Point> crosspointCC(const Circle &a, const Circle &b)\n{\n    vector<Point> res;\n    double d = abs(a.p - b.p);\n    if (!isIntersectCC(a, b) || d < EPS) {\n        return res;\n    }\n    double rc = (a.r * a.r - b.r * b.r + d * d) / (2.0 * d);\n    if (abs(a.r) - abs(rc) < EPS) {\n        return res;\n    }\n      \n    double rs = sqrt(a.r * a.r - rc * rc);\n    Point p = (b.p - a.p);\n    res.push_back(Point(a.p + p * Point(rc, +rs) / d));\n    res.push_back(Point(a.p + p * Point(rc, -rs) / d));\n    return res;\n}\n  \nbool c(double z, vector<Circle> c)\n{\n    int N = c.size();\n    for (int i = 0; i < N; i++) {\n        if (c[i].r * c[i].r - z * z < 0) return 0; \n        c[i].r = sqrt(c[i].r * c[i].r - z * z);        \n    }\n      \n    vector<Point> cross_point;\n    for (int i = 0; i < N; i++) {\n        cross_point.push_back(c[i].p);\n        for (int j = i+1; j < N; j++) {            \n            vector<Point> cp = crosspointCC(c[i], c[j]);\n            for (int k = 0; k < (int)cp.size(); k++) {\n                cross_point.push_back(cp[k]);\n            }\n        }\n    }\n      \n    for (int i = 0; i < (int)cross_point.size(); i++) {\n        bool poss = 1;\n        for (int j = 0; j < N; j++) {\n            if (dist(cross_point[i], c[j].p) - c[j].r > EPS) {\n                poss = 0;\n                break;\n            }\n        }\n        if (poss) {\n            return 1;\n        }\n    }\n    return 0;\n}\n  \ndouble solve(vector<Circle> &cirs)\n{\n    if (cirs.size() == 1) return cirs[0].r;\n  \n    double l = 0, r = 25252;\n    for (int i = 0; i < 150; i++) {\n        double z = (l + r) / 2;\n        if (c(z, cirs)) {\n            l = z;\n        } else {\n            r = z;\n        }\n    }\n    return l;\n}\n  \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cirs(N);\n        for (int i = 0; i < N; i++) {\n            cin >> cirs[i].p.x >> cirs[i].p.y >> cirs[i].r;\n        }\n        printf(\"%.10f\\n\", solve(cirs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n\nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\ndouble heron(double a, double b, double c)\n{\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n\treturn sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n\ntuple<double, double, double> com(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn a;\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn b;\n\t}\n\telse {\n\t\tdouble l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n\t\tdouble d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n\t\tdouble d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n\t\treturn tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n\t}\n}\n\ndouble two(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn (double)get<2>(a);\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn (double)get<2>(b);\n\t}\n\telse {\n\t\tdouble d = sqrt(disdis(a, b));\n\t\treturn heron(get<2>(a), get<2>(b), d) * 2 / d;\n\t}\n}\n\ndouble three(const tuple<double, double, double>& a, const tuple<double, double, double>& b, const tuple<double, double, double>& c)\n{\n\ttuple<double, double, double> temp;\n\n\tif (ISLOOSE(a, b) && ISLOOSE(a, c))\n\t\treturn get<2>(a);\n\tif (ISLOOSE(b, a) && ISLOOSE(b, c))\n\t\treturn get<2>(b);\n\tif (ISLOOSE(c, a) && ISLOOSE(c, b))\n\t\treturn get<2>(c);\n\n\tif (ISLOOSE(temp = com(a, b), c))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(b, c), a))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(c, a), b))\n\t\treturn get<2>(temp);\n\n\treturn heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n\t\t* 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n\nint main()\n{\n\tint n;\n\tdouble res;\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\twhile (cin >> n, n) {\n\t\tvector< tuple<double, double, double> > str(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << (double)get<2>(str[0]) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcout << two(str[0], str[1]) << endl;\n\t\t}\n\t\telse {\n\t\t\tres = 100000000.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tres = min(res, three(str[i], str[j], str[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  //cerr<<\"judge::\"<<m<<\" \";\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  //cerr<<\" val \";\n  bool hoge = true;\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m))continue;\n      if(dist+in[j].R(m)<=in[i].R(m))continue;\n      hoge = false;\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return hoge;\n}\n\ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return m;\n  if(judge(m)){\n    //cerr<<\"true\"<<endl;\n    return req(m,r);\n  }else{\n    //cerr<<\"false\"<<endl;\n    return req(l,m);\n  }\n}\n\ndouble solve(){\n  double ans = req(1.0,400.0);\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n  \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n  \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n  \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<float, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt(double(bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nstruct Anchor{\n  int x,y,l;\n  Anchor(int _x,int _y,int _l)\n    : x(_x), y(_y), l(_l) {}\n};\n\ndouble check(const vector<Anchor>& anchors,\n\t     double x,double y){\n\n  double res = 100000000.0;\n  for(int anchor_idx=0;anchor_idx<anchors.size();anchor_idx++){\n    double bottom_line\n      = (double)(anchors[anchor_idx].x - x) * (double)(anchors[anchor_idx].x - x)\n      + (double)(anchors[anchor_idx].y - y) * (double)(anchors[anchor_idx].y - y);\n    double capacity = anchors[anchor_idx].l * anchors[anchor_idx].l;\n    res = min(res,capacity - bottom_line);\n  }\n  return res;\n}\n\ndouble search(const vector<Anchor>& anchors,\n\t      const double x,double left, double right)\n{\n  for (int round = 0; round < 100; round++){\n    if (check(anchors,x,(left * 2 + right) / 3)\n\t> check(anchors,x,(left + right * 2) / 3)){\n      right = (left + right * 2) / 3;\n    } else {\n      left = (left * 2 + right) / 3;\n    }\n  }\n  return check(anchors,x,(right + left) * 0.5);\n}\n\nint main(){\n  int total_anchors;\n  while(~scanf(\"%d\",&total_anchors)){\n    if(total_anchors == 0) break;\n\n    vector<Anchor> anchors;\n    for(int anchor_idx=0;anchor_idx<total_anchors;anchor_idx++){\n      int x,y,l;\n      scanf(\"%d %d %d\",&x,&y,&l);\n      anchors.push_back(Anchor(x,y,l));\n    }\n\n    double left = -100.0;\n    double right = 100.0;\n    for(int round = 0;round < 100; round++){\n      if (search(anchors,(left * 2 + right) / 3,-100.0,100.0)\n\t  > search(anchors,(left + right * 2) / 3,-100.0,100.0)){\n\tright = (left + right * 2) / 3;\n      } else {\n\tleft = (left * 2 + right) / 3;\n      }\n    }\n    double res = search(anchors,right,-100,100.0);\n    printf(\"%.7lf\\n\",sqrt(res));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-12;\nconst double INF = 1e12;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\ntypedef complex<double> P;\nconst int L = 10;\n\nint N, x[L], y[L], r[L];\n\nstruct C {\n  P p; double r;\n  C(){}\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nvoid crosspointCC(const C &c1, const C &c2, vector<P> &ps){\n  double d = abs(c1.p - c2.p);\n  double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  double dfr = c1.r * c1.r - rc * rc;\n  if(EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ;\n  double rs = sqrt(dfr);\n\n  P diff = (c2.p - c1.p) / d;\n  ps.push_back(c1.p + diff * P(rc, rs));\n  ps.push_back(c1.p + diff * P(rc, -rs));\n}\n\nbool check(double h){\n  C cs[L];\n  REP(i, N){\n    cs[i].p = P(x[i], y[i]);\n    double rr = r[i] * r[i] - h * h;\n    if(rr < 0) return false;\n    cs[i].r = sqrt(rr);\n  }\n  vector<P> ps;\n  REP(i, N) ps.push_back(cs[i].p);\n  REP(i, N) FOR(j, i + 1, N) crosspointCC(cs[i], cs[j], ps);\n\n  REP(i, ps.size()){\n    bool f = true;\n    REP(j, N) if(abs(cs[j].p - ps[i]) > cs[j].r + EPS) f = false;\n    if(f) return true;\n  }\n  return false;\n}\n\ndouble solve(){\n  double lb = 0, ub = 300;\n  REP(i, 100){\n    double m = (lb + ub) / 2.0;\n    if(check(m)) lb = m;\n    else ub = m;\n  }\n  return lb;\n}\n\nint main() {\n  while(cin >>N && N){\n    REP(i, N) cin >>x[i] >>y[i] >>r[i];\n    printf(\"%.7lf\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (ad < min(bd, c.r)) cros.push_back(s[0]);\n    else if (bd < min(ad, c.r)) cros.push_back(s[1]);\n    else {\n      Point p = cros[0];\n      cros.push_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n\n  return Line{cros[0], cros[1]};\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\n\nint n;\ndouble ls[114514];\nPoint ps[114514];\nCircle cs[114514];\n\nbool check(double K) {\n  vector<Point> qs;\n\n  for (int i=0; i<n; i++) {\n    if (ls[i] < K) return false;\n    double r = sqrt(ls[i]*ls[i]-K*K);\n    cs[i] = {ps[i], r};\n    qs.push_back(ps[i]);\n  }\n\n  for (int i=0; i<n; i++) {\n    for (int j=i+1; j<n; j++) {\n      vector<Point> cros = CrossPointCC(cs[i], cs[j]);\n      qs.insert(qs.end(), cros.begin(), cros.end());\n    }\n  }\n\n  for (Point &c : qs) {\n    bool fail = false;\n    for (int i=0; i<n; i++) {\n      if (abs(cs[i].c-c) >= cs[i].r+EPS) {\n        fail = true;\n        break;\n      }\n    }\n\n    if (!fail) return true;\n  }\n\n  return false;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      int x, y;\n      scanf(\"%d%d%lf\", &x, &y, &ls[i]);\n      ps[i] = Point(x, y);\n    }\n  \n    double low = 0.0;\n    double high = 400;\n    for (int i=0; i<40; i++) {\n      double mid = (low+high)/2;\n      if (check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.10f\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble PI=acos(-1.0);\n#define eps (1e-7)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\ndouble x[11],y[11],r[11];\nvector<Point> po;\nCircle c[11];\ndouble mx;\nint n;\nbool test(double d){\n    rep(i,n){\n        double dist=r[i]*r[i]-d*d;\n        if(dist<0) return false;\n        c[i]=Circle(Point(x[i],y[i]),sqrt(dist));\n    }\n    po.clear();\n    rep(i,n)FOR(j,i+1,n){\n        if(!isIntersectCC(c[i],c[j])){\n            if((c[i].p-c[j].p).abs()>c[i].r+c[j].r) return false;\n            else{\n                continue;\n            }\n        }\n        if(abs(c[i].r-c[j].r)>(c[i].p-c[j].p).abs()) continue;\n        pair<Point,Point> pp=CrossPointsCC(c[i],c[j]);\n        po.pb(pp.first);po.pb(pp.second);\n    }\n    int sz=po.size();\n    if(sz==0) return mx>=d;\n    rep(i,sz){\n        bool flag=true;\n        rep(j,n){\n            if((po[i]-c[j].p).abs()>c[j].r+eps) flag=false;\n        }\n        if(flag) return true;\n    }\n    return false;\n}\nint main(){\n    while(cin>>n,n){\n        mx=0;\n        rep(i,n){\n            cin>>x[i]>>y[i]>>r[i];\n            mx=max(mx,r[i]);\n        }\n        double lb=0,ub=300;\n        while(ub-lb>eps){\n            double mid=(ub+lb)/2;\n            if(test(mid)) lb=mid;\n            else ub=mid;\n        }\n        cout<<fixed<<setprecision(12)<<lb<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint n;\nint l[10],x[10],y[10];\n\ndouble H(double Y,double X){\n    double m=500000;\n    for(int i=0;i<n;i++)\n        m=min(m,l[i]*l[i]-(Y-y[i])*(Y-y[i])-(X-x[i])*(X-x[i]));\n    return m;\n}\n\ndouble Y(double X){\n    double l=-100,r=100;\n    for(int i=0;i<100;i++){\n        double m1=(l*2+r)/3,m2=(l+r*2)/3;\n        if(H(m1,X)<H(m2,X))\n            l=m1;\n        else\n            r=m2;\n    }\n    return H(l,X);\n}\n\ndouble X(){\n    double l=-100,r=100;\n    for(int i=0;i<100;i++){\n        double m1=(l*2+r)/3,m2=(l+r*2)/3;\n        if(Y(m1)<Y(m2))\n            l=m1;\n        else\n            r=m2;\n    }\n    return Y(l);\n}\nint main(){\n    while(cin>>n,n){\n        for(int i=0;i<n;i++)\n            cin>>x[i]>>y[i]>>l[i];\n        double ans=sqrt(X());\n        printf(\"%.7f\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble PI=acos(-1.0);\n#define eps (1e-7)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\ndouble x[11],y[11],r[11];\nvector<Point> po;\nCircle c[11];\ndouble mx;\nint n;\nbool test(double d){\n    po.clear();\n    rep(i,n){\n        double dist=r[i]*r[i]-d*d;\n        if(dist<0) return false;\n        c[i]=Circle(Point(x[i],y[i]),sqrt(dist));\n        po.pb(c[i].p);\n    }\n    rep(i,n)FOR(j,i+1,n){\n        if(!isIntersectCC(c[i],c[j])) continue;\n        if(abs(c[i].r-c[j].r)+eps>(c[i].p-c[j].p).abs()) continue;\n        pair<Point,Point> pp=CrossPointsCC(c[i],c[j]);\n        po.pb(pp.first);po.pb(pp.second);\n    }\n    int sz=po.size();\n    rep(i,sz){\n        bool flag=true;\n        rep(j,n){\n            if((po[i]-c[j].p).abs()>c[j].r+eps) flag=false;\n        }\n        if(flag) return true;\n    }\n    return false;\n}\nint main(){\n    while(cin>>n,n){\n        mx=0;\n        rep(i,n){\n            cin>>x[i]>>y[i]>>r[i];\n            mx=max(mx,r[i]);\n        }\n        double lb=0,ub=300;\n        while(ub-lb>eps){\n            double mid=(ub+lb)/2;\n            if(test(mid)) lb=mid;\n            else ub=mid;\n        }\n        cout<<fixed<<setprecision(12)<<lb<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <complex>\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\n\nstruct C {\n  P p; double r;\n  C(P p, double r) : p(p), r(r){}\n};\npair<P, P> cc_cross(const C& c1, const C& c2) {\n  double d = abs(c1.p - c2.p);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double rs = sqrt(c1.r*c1.r - rc*rc);\n  P diff = (c2.p - c1.p) / d;\n  return make_pair(c1.p + diff * P(rc, rs), c1.p + diff * P(rc, -rs));\n}\n\nint main(){\n  while(const int n = getInt()){\n    vector<double> x(n);\n    vector<double> y(n);\n    vector<double> l(n);\n\n    REP(i,n){\n      x[i] = getInt();\n      y[i] = getInt();\n      l[i] = getInt();\n    }\n\n    double low  = 0.0;\n    double high = 1000;\n\n    REP(cc,100){\n      const double med = (low + high) / 2;\n      vector<double> w(n);\n      vector<P> cand;\n\n      bool ok = true;\n      REP(i,n) if(l[i] < med){ ok = false; goto next; }\n\n      REP(i,n) w[i] = sqrt(l[i] * l[i] - med * med);\n      REP(i,n) cand.push_back(P(x[i], y[i]));\n      REP(i,n) REP(j,i){\n        if(std::abs(P(x[i], y[i]) - P(x[j], y[j])) + EPS > w[i] + w[j]){\n          // printf(\"%.4f %d %d (%.4f %.4f)\\n\", med, i, j, std::abs(P(x[i], y[i]) - P(x[j], y[j])), w[i] + w[j]);\n          ok = false; goto next;\n        }\n        if(std::abs(P(x[i], y[i]) - P(x[j], y[j])) > std::abs(w[i] - w[j])){\n          pair<P, P> tmp = cc_cross(C(P(x[i], y[i]), w[i]), C(P(x[j], y[j]), w[j]));\n          cand.push_back(tmp.first);\n          cand.push_back(tmp.second);\n        }\n      }\n\n      // REP(i,n) cand.push_back(P(x[i], y[i]));\n\n      REP(j,cand.size()){\n        bool tok = true;\n        const P p = cand[j];\n        REP(i,n){\n          if(std::abs(P(x[i], y[i]) - p) > w[i] + EPS){\n            tok = false;\n          }\n        }\n        if(tok) goto next;\n      }\n      if(n != 1) ok = false;\n      // puts(\"TEST\");\n\n    next:;\n      if(ok){\n        low = med;\n      }else{\n        high = med;\n      }\n    }\n\n    printf(\"%.8f\\n\", low);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <vector>\nnamespace lc {\nstatic const double EPS = 1e-9;\ninline double abs(double x){ return std::abs(x); }\ninline bool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n}\nnamespace lc {\nstruct Point {\n\tdouble x;\n\tdouble y;\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const Point &p) const {\n\t\treturn Point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble norm() const { return x * x + y * y; }\n};\ninline bool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n}\nnamespace lc {\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\texplicit Circle(const Point &c = Point(), double r = 0.0) :\n\t\tc(c), r(r)\n\t{ }\n\tint contains(const Point &p) const {\n\t\tconst double d2 = (p - c).norm(), r2 = r * r;\n\t\tif(d2 > r2){ return 0; }\n\t\tif(d2 < r2){ return 1; }\n\t\treturn -1;\n\t}\n};\ninline bool tolerant_eq(const Circle &a, const Circle &b){\n\treturn tolerant_eq(a.c, b.c) && tolerant_eq(a.r, b.r);\n}\n}\nnamespace lc {\ninline bool intersect(const Circle &a, const Circle &b){\n\tconst double d = (a.c - b.c).abs();\n\treturn d <= a.r + b.r && a.r + d >= b.r && b.r + d >= a.r;\n}\n}\nnamespace lc {\ninline std::vector<Point> crossing_points(const Circle &a, const Circle &b){\n\tstd::vector<Point> ret;\n\tif(!intersect(a, b)){ return ret; }\n\tif(tolerant_eq(a, b)){\n\t\tret.push_back(a.c + Point(a.r, 0.0));\n\t\tret.push_back(a.c + Point(-a.r, 0.0));\n\t\tret.push_back(a.c + Point(0.0, a.r));\n\t}else{\n\t\tconst double d = (a.c - b.c).abs();\n\t\tconst double rc = (d * d + a.r * a.r - b.r * b.r) / (2.0 * d);\n\t\tconst double rs = sqrt(a.r * a.r - rc * rc);\n\t\tconst Point diff = (b.c - a.c) / d;\n\t\tconst Point x = a.c + diff * Point(rc, rs);\n\t\tconst Point y = a.c + diff * Point(rc, -rs);\n\t\tret.push_back(x);\n\t\tif(!tolerant_eq(x, y)){ ret.push_back(y); }\n\t}\n\treturn ret;\n}\n}\nusing namespace std;\ninline double pow2(double x){ return x * x; }\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setiosflags(ios::fixed) << setprecision(10);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<lc::Point> pegs(n);\n\t\tvector<double> ropes(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> pegs[i].x >> pegs[i].y >> ropes[i];\n\t\t}\n\t\tdouble left = 0.0, right = *min_element(ropes.begin(), ropes.end());\n\t\tfor(int iter = 0; iter < 100; ++iter){\n\t\t\tconst double center = (left + right) * 0.5;\n\t\t\tvector<lc::Circle> areas(n);\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tareas[i] = lc::Circle(\n\t\t\t\t\tpegs[i], sqrt(max(0.0, pow2(ropes[i]) - pow2(center))));\n\t\t\t}\n\t\t\tvector<lc::Point> candidates(pegs);\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = i + 1; j < n; ++j){\n\t\t\t\t\tconst auto cps = lc::crossing_points(areas[i], areas[j]);\n\t\t\t\t\tcopy(cps.begin(), cps.end(), back_inserter(candidates));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool accept = false;\n\t\t\tfor(const auto &p : candidates){\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int i = 0; flag && i < n; ++i){\n\t\t\t\t\tlc::Circle c(areas[i].c, areas[i].r + lc::EPS);\n\t\t\t\t\tif(!c.contains(p)){ flag = false; }\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\taccept = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tleft = center;\n\t\t\t}else{\n\t\t\t\tright = center;\n\t\t\t}\n\t\t}\n\t\tcout << left << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\n// typedef pair<int, int> P;\ntypedef complex<double> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\n// ???p?????????c, ??????r??????????????¨(??????????????¨???)??????????????????\nbool inside(P p, P c, double r) {\n    return abs(p - c) <= r;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n && n) {\n        vector<P> p(n);\n        vector<double> r(n);\n        rep(i, n) {\n            double x, y, l;\n            cin >> x >> y >> l;\n            p[i] = P(x, y);\n            r[i] = l;\n        }\n\n        if (n == 1) {\n            cout << r[0] << endl;\n            continue;\n        }\n\n        double ans = 99999;\n        rep(j, n) {\n            rep(i, j) {\n                double d = abs(p[i] - p[j]);\n                double r1 = r[i], r2 = r[j];\n                double cand = 0;\n                // ???1???????????????2????????¨???????????????????????°\n                if (inside(P(0, r1), P(d, 0), r2)) {\n                    cand = max(cand, r1);\n                }\n                // ???2???????????????1????????¨???????????????????????°\n                if (inside(P(d, r2), P(0, 0), r1)) {\n                    cand = max(cand, r2);\n                }\n                // ????????????????????????????????°\n                if (abs(r1 - r2) <= d && d <= r1 + r2) {\n                    double x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n                    double y = sqrt(r1 * r1 - x * x);\n                    cand = max(cand, y);\n                }\n                ans = min(ans, cand);\n\n\n                // double d = abs(p[i] - p[j]);\n                // double r1 = r[i], r2 = r[j];\n                // if (d + r2 < r1) {\n                //     ans = min(ans, r2);\n                // } else if (d + r1 < r2) {\n                //     ans = min(ans, r1);\n                // } else {\n                //     double x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n                //     double y = sqrt(r1 * r1 - x * x);\n                //     ans = min(ans, y);\n                // }\n            }\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double eps = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=INF,y=INF;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n\nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P t , P p , double r){\n  //double r=radians(angle);\n  double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n  double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n  return P(ta , tb);\n}\n\nvoid interpoint_cc(P a , double ra , P b , double rb , P ans[]){\n  double di=fabs(dis(a-b));\n  if(di > ra+rb || di < fabs(ra-rb)) return;\n  double t=(ra*ra-rb*rb+di*di)/(di+di);\n  double rd=acos(t/ra);\n\n  P dv=unit_vector(b-a);\n  P g1=rotate(dv , P(0,0) , rd);\n  P g2=rotate(dv , P(0,0) , -rd);\n  ans[0]=a+g1*ra;\n  ans[1]=a+g2*ra;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<P> p(N);\n\tvector<double> ls(N);\n\tREP(i,N) cin >> p[i].x >> p[i].y >> ls[i];\n\n\tdouble lb = 0, ub = 300;\n\tREP(loop,100){\n\t  double h = (lb + ub) / 2.;\n\t  bool ok = true;\n\t  REP(i,N) if(ls[i] < h) ok = false;\n\n\t  if(ok){\n\t\tok = false;\n\t\tvector<double> ri(N);\n\t\tREP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n\t\tvector<P> chk;\n\t\tREP(i,N){\n\t\t  REP(j,N){\n\t\t\tif(dis(p[i]-p[j]) > ri[i]+ri[j] || dis(p[i]-p[j]) < fabs(ri[i]-ri[j])) continue;\n\t\t\tP icp[2];\n\t\t\tinterpoint_cc(p[i], ri[i], p[j], ri[j], icp);\n\t\t\tchk.PB(icp[0]);\n\t\t\tchk.PB(icp[1]);\n\t\t  }\n\t\t  chk.PB(p[i]);\n\t\t}\n\t\tfor(auto& pp: chk){\n\t\t  int cnt = 0;\n\t\t  REP(k,N){\n\t\t\tif(dis(p[k]-pp) <= ri[k])\n\t\t\t  ++cnt;\n\t\t  }\n\t\t  if(cnt == N) ok = true;\n\t\t}\n\t  }\n\n\t  if(ok) lb = h;\n\t  else ub = h;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\n\ntypedef complex<double> Point;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n  vector<Point> ret;\n  Point center = projection(l, c.p);\n  double d = abs(center - c.p);\n  double t = sqrt(c.r * c.r - d * d);\n  if (isnan(t)) { return ret; }\n  Point vect = (l[1] - l[0]);\n  vect /= abs(vect);\n  ret.push_back(center - vect * t);\n  if (t > EPS) {\n    ret.push_back(center + vect * t);\n  }\n  return ret;\n}\n\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n  vector<Point> ret;\n  double d = abs(c1.p - c2.p);\n  if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n  double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  Point start = c1.p + (c2.p - c1.p) / d * x;\n  Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n  return crosspointLC(Line(start, start + vect), c1);\n}\n\n\nint n;\nCircle cs[100];\ninline double square(double x) { return x * x; }\n\nbool isok(const Point &p, double h) {\n  REP(i, n) {\n    if (norm(p - cs[i].p) + square(h) - square(cs[i].r) > EPS) { return false; }\n  }\n  return true;\n}\n\nbool calc(Circle c1, Circle c2, double h) {\n  c1.r = sqrt(square(c1.r) - square(h));\n  c2.r = sqrt(square(c2.r) - square(h));\n  vector<Point> ps = crosspointCC(c1, c2);\n  bool ret = false;\n  FORIT(it, ps) {\n    ret |= isok(*it, h);\n  }\n  return ret;\n}\n\nint main() {\n  while (cin >> n, n) {\n    REP(i, n) {\n      double x, y, l;\n      cin >> x >> y >> l;\n      cs[i] = Circle(Point(x, y), l);\n    }\n    double low = 1;\n    double upper = 300;\n    REP(iter, 200) {\n      double mid = (low + upper) / 2.0;\n      bool ok = false;\n      REP(i, n) {\n        ok |= isok(cs[i].p, mid);\n        REP(j, n) {\n          if (ok) { break; }\n          ok |= calc(cs[i], cs[j], mid);\n        }\n      }\n      if (ok) {\n        low = mid;\n      } else {\n        upper = mid;\n      }\n    }\n    printf(\"%.10f\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \n/* double extention Library. */\n \nconst double EPS = 1e-8;\n \nbool eq(double a, double b)\n{\n    return (fabs(a - b) <= EPS);\n}\n \nbool lt(double a, double b)\n{\n    return (a - b < -EPS);\n}\n \nbool leq(double a, double b)\n{\n    return (lt(a, b) || eq(a, b));\n}\n \nbool gt(double a, double b)\n{\n    return (a - b > +EPS);\n}\n \nbool geq(double a, double b)\n{\n    return (gt(a, b) || eq(a, b));\n}\n \n/* 2-D Geometry Library. */\n \nclass Point{\npublic:\n    double x, y;\n    Point (double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){\n        return (Point(x + p.x, y + p.y));\n    }\n    Point operator - (Point p){\n        return (Point(x - p.x, y - p.y));\n    }\n    Point operator * (double a){\n        return (Point(x * a, y * a));\n    }\n    double abs(){\n        return (sqrt(norm()));\n    }\n    double norm(){\n        return (x * x + y * y);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n    bool operator != (const Point &p) const {\n        return (!(*this == p));\n    }\n};\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \ndouble norm(Vector a)\n{\n    return (a.x * a.x + a.y * a.y);\n}\n \ndouble abs(Vector a)\n{\n    return (sqrt(norm(a)));\n}\n \ndouble dot(Vector a, Vector b)\n{\n    return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(Vector a, Vector b)\n{\n    return (a.x * b.y - a.y * b.x);\n}\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return (COUNTER_CLOCKWISE);\n    if (cross(a, b) < -EPS) return (CLOCKWISE);\n    if (dot(a, b) < -EPS)   return (ONLINE_BACK);\n    if (norm(a) < norm(b))  return (ONLINE_FRONT);\n    return (ON_SEGMENT);\n}\n \nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n \n \n \nbool isInside(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == CLOCKWISE) return (false);\n    }\n    return (true);\n}\n \nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n \ndouble getSin(Point a , Point b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \ndouble getDistPL(Point p, Point a, Point b)\n{\n    return (fabs(cross(b - a, p - a)) / abs(b - a));\n}\n \ndouble getDistPS(Point p, Point a, Point b)\n{\n    if(dot(b - a, p - a) < EPS) return (abs(p - a));\n    if(dot(a - b, p - b) < EPS) return (abs(p - b));\n    return (getDistPL(p, a, b));\n}\n \nPoint interPointS(Point a1 , Point a2 , Point b1 , Point b2)\n{\n    Point b = b2 - b1;\n    double d1 = fabs(cross(b, a1 - b1));\n    double d2 = fabs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    Point a = a2 - a1;\n    Point v = a * t;\n    return (a1 + v);\n}\n \nPoint interPointL(Point a1 , Point a2 , Point b1 , Point b2)\n{\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    Point v = a * t;\n    return (a1 + v);\n}\n \nvoid interPointLC(Point a, Point b, Point c, double r, Point ans[])\n{\n    if (getDistPL(c, a, b) > r + EPS) return;\n    Point v = unitVector(b - a);\n    double delta = dot(v, a - c) * dot(v, a - c) - abs(a - c) * abs(a - c) + r * r;\n    double t = -dot(v, a - c);\n    double s = sqrt(delta);\n    ans[0] = a + v * (t + s);\n    ans[1] = a + v * (t - s);\n}\n \nPoint xTranslate(Point t, double k)\n{\n    return (Point(t.x, 2 * k - t.y));\n}\n \nPoint yTranslate(Point t, double k)\n{\n    return (Point(2 * k - t.x, t.y));\n}\n \nPoint oTranslate(Point t, Point k)\n{\n    return (k + (k - t));\n}\n \nPoint rotate(Point t , Point p , double r)\n{\n    double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n    double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n    return Point(ta , tb);\n}\n \nvoid interPointCC(Point a , double ra , Point b , double rb , Point ans[])\n{\n    double di=fabs(abs(a-b));\n    if(di > ra+rb || di < fabs(ra-rb)) return;\n    double t=(ra*ra-rb*rb+di*di)/(di+di);\n    double rd=acos(t/ra);\n \n    Point dv=unitVector(b-a);\n    Point g1=rotate(dv , Point(0,0) , rd);\n    Point g2=rotate(dv , Point(0,0) , -rd);\n    ans[0]=a+g1*ra;\n    ans[1]=a+g2*ra;\n}\n \nPoint normalVector(Point p,Point a,Point b)\n{\n    Point v=unitVector(b-a);\n    v = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n    return v*getDistPL(p,a,b);\n}\n \nPoint fTranslate(Point t , Point a , Point b)\n{\n    return t+normalVector(t,a,b)*2;\n}\n \ndouble area(Point a, Point b, Point c){\n    return fabs(cross(c-a , b-a)*0.5);\n}\n \ndouble polygonArea(Polygon t){\n    double ans = 0.0;\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (ans / 2);\n}\n \nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n     \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n \n    qs.resize(k - 1);\n    return (qs);\n}\n\nint n;\nPoint p[10];\ndouble l[10];\n\nbool check(double z)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tif (lt(l[i] * l[i] - z * z, 0)) return (false);\n\t\n\tvector<Point> check;\n\tfor (int i = 0; i < n; i++)\n\t\tcheck.push_back(p[i]);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tPoint ans[2];\n\t\t\tans[0] = ans[1] = Point(-999, -999);\n\t\t\tinterPointCC(p[i], sqrt(max(0.0, l[i] * l[i] - z * z)), p[j], sqrt(max(0.0, l[j] * l[j] - z * z)), ans);\n\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\tif (!eq(ans[k].x, -999)) check.push_back(ans[k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < check.size(); i++){\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (gt(norm(check[i] - p[j]), l[j] * l[j] - z * z))\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok){\n\t\t\treturn (true);\n\t\t}\n\t}\n\t\n\treturn (false);\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &n) && n){\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf %lf %lf\", &p[i].x, &p[i].y, &l[i]);\n\t\t}\n\t\t\n\t\tdouble lo = 0.0, hi = 300.0;\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tdouble mid = (lo + hi) / 2.0;\n\t\t\tif (check(mid)) lo = mid;\n\t\t\telse hi = mid;\n\t\t}\n\t\tprintf(\"%lf\\n\", (lo + hi) / 2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n   \nusing namespace std;\n   \n#define EPS 1e-10\n   \nstruct Point {\n    double x, y;\n   \n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n   \n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n       \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n       \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n       \n    Point operator / (const double &k) const {\n        return Point(x / k, y / k);\n    }\n};\n   \nPoint operator * (const Point &a, const Point &b)\n{\n    return Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n   \ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n   \ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n   \ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n   \ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n   \nstruct Circle {\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n   \nbool isIntersectCC(const Circle &a, const Circle &b)\n{\n    double d = abs(a.p - b.p);\n    return (d <= a.r + b.r && d >= abs(a.r - b.r));\n}\n   \nvector<Point> crosspointCC(const Circle &a, const Circle &b)\n{\n    vector<Point> res;\n    double d = abs(a.p - b.p);\n    if (!isIntersectCC(a, b) || d < EPS) {\n        return res;\n    }\n    double rc = (a.r * a.r - b.r * b.r + d * d) / (2.0 * d);\n    if (abs(a.r) - abs(rc) < EPS) {\n        return res;\n    }\n       \n    double rs = sqrt(a.r * a.r - rc * rc);\n    Point p = (b.p - a.p);\n    res.push_back(Point(a.p + p * Point(rc, +rs) / d));\n    res.push_back(Point(a.p + p * Point(rc, -rs) / d));\n    return res;\n}\n   \nbool c(double z, vector<Circle> c)\n{\n    int N = c.size();\n    for (int i = 0; i < N; i++) {\n        if (c[i].r * c[i].r - z * z < 0) return 0; \n        c[i].r = sqrt(c[i].r * c[i].r - z * z);        \n    }\n       \n    vector<Point> cross_point;\n    for (int i = 0; i < N; i++) {\n        cross_point.push_back(c[i].p);\n        for (int j = i+1; j < N; j++) {            \n            vector<Point> cp = crosspointCC(c[i], c[j]);\n            for (int k = 0; k < (int)cp.size(); k++) {\n                cross_point.push_back(cp[k]);\n            }\n        }\n    }\n       \n    for (int i = 0; i < (int)cross_point.size(); i++) {\n        bool poss = 1;\n        for (int j = 0; j < N; j++) {\n            if (dist(cross_point[i], c[j].p) - c[j].r > EPS) {\n                poss = 0;\n                break;\n            }\n        }\n        if (poss) {\n            return 1;\n        }\n    }\n    return 0;\n}\n   \ndouble solve(vector<Circle> &cirs)\n{\n    if (cirs.size() == 1) return cirs[0].r;\n   \n    double l = 0, r = 25252;\n    for (int i = 0; i < 150; i++) {\n        double z = (l + r) / 2;\n        if (c(z, cirs)) {\n            l = z;\n        } else {\n            r = z;\n        }\n    }\n    return l;\n}\n   \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cirs(N);\n        for (int i = 0; i < N; i++) {\n            cin >> cirs[i].p.x >> cirs[i].p.y >> cirs[i].r;\n        }\n        printf(\"%.10f\\n\", solve(cirs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//const int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\nint N;\ndouble xs[11];\ndouble ys[11];\ndouble ls[11];\n\ndouble check2(double X,double Y){\n  double res=1e+10;\n  for(int i=0;i<N;i++)\n    res=min(res,(ls[i]*ls[i]-pow(X-xs[i],2)-pow(Y-ys[i],2)));\n  //if(res>EPS)return sqrt(res);\n  //rturn 0;\n  return res;\n}\n\ndouble check(double X){\n  double initUb=-1;\n  double initLb=200;\n  for(int i=0;i<N;i++){\n    initUb=max(initUb,ys[i]);\n    initLb=min(initLb,ys[i]);\n  }\n  double ub=initUb;\n  double lb=initLb;\n  for(int ite=0;ite<200;ite++){\n    double mid1=(ub-lb)/3+lb;\n    double mid2=2*(ub-lb)/3+lb;\n    if(check2(X,mid1)<check2(X,mid2))lb=mid1;\n    else ub=mid2;\n  }\n  return check2(X,ub);\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    double initUb=-1;\n    double initLb=200;\n    for(int i=0;i<N;i++){\n      cin>>xs[i]>>ys[i]>>ls[i];\n      initUb=max(initUb,xs[i]);\n      initLb=min(initLb,xs[i]);\n    }\n    double ub=initUb;\n    double lb=initLb;\n    for(int ite=0;ite<200;ite++){\n      double mid1=(ub-lb)/3+lb;\n      double mid2=2*(ub-lb)/3+lb;\n      if(check(mid1)<check(mid2))lb=mid1;\n      else ub=mid2;\n    }\n    double res=check(ub);\n    printf(\"%.10f\\n\",sqrt(res));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];\n        \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-8;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            int cnt=0;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>=dis) cnt++;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    \n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+0.001){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            if(cnt==(n*(n-1)/2)) able=true;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble dbl(double x){return x*x;}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<double> x(n),y(n),l(n);\n        for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>l[i];       \n        double lb=0;\n        double ub=1000;\n        const double EPS=1e-10;\n        while(ub-lb>EPS){\n            double mid=(ub+lb)/2;\n            bool pos=true;\n            vector<double> r(n);\n            for(int i=0;i<n && pos;i++){\n                if(l[i]<=mid) pos=false;\n                else r[i]=sqrt(dbl(l[i])-dbl(mid));\n                \n            }\n            if(!pos){\n                ub=mid;\n                continue;\n            }\n            bool able=false;\n            bool hoge=true;\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    double dis=sqrt(dbl(x[i]-x[j])+dbl(y[i]-y[j]));\n                    if(abs(r[i]-r[j])>dis+EPS) hoge=false;\n                    if(2*max({r[i],r[j],dis})>=r[i]+r[j]+dis) continue;\n                    double val=(dbl(r[i])+dbl(dis)-dbl(r[j]))/(2.0*r[i]*dis);\n                    \n                    double sita=acos(val);\n                    \n                    double co=cos(sita);\n                    double si=sin(sita);\n                    double offx=x[j]-x[i];\n                    double offy=y[j]-y[i];\n                    double offx1=r[i]/dis*(offx*co-offy*si);\n                    double offy1=r[i]/dis*(offx*si+offy*co);\n                    double offx2=r[i]/dis*(offx*co+offy*si);\n                    double offy2=r[i]/dis*(-offx*si+offy*co);\n                    double px1=offx1+x[i];\n                    double px2=offx2+x[i];\n                    double py1=offy1+y[i];\n                    double py2=offy2+y[i];\n                \n                    vector<pair<double,double>> p(2);\n                    p[0]={px1,py1};\n                    p[1]={px2,py2};\n                    for(int i=0;i<2;i++){\n                        bool isok=true;\n                        for(int j=0;j<n;j++){\n                            if(sqrt(dbl(p[i].first-x[j])+dbl(p[i].second-y[j]))>=r[j]+1e-8){\n                                isok=false;\n                            }        \n                        }\n                        able=able||isok;\n                    }\n                        \n                    \n                }\n            }\n            able=able|hoge;\n            if(able){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n            \n        }\n        cout<<setprecision(10)<<fixed<<ub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n\nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\ndouble heron(double a, double b, double c)\n{\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n\treturn sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n\ntuple<double, double, double> com(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn a;\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn b;\n\t}\n\telse {\n\t\tdouble l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n\t\tdouble d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n\t\tdouble d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n\t\treturn tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n\t}\n}\n\ndouble two(const tuple<double, double, double>& a, const tuple<double, double, double>& b)\n{\n\tif (ISLOOSE(a, b)) {\n\t\treturn (double)get<2>(a);\n\t}\n\telse if (ISLOOSE(b, a)) {\n\t\treturn (double)get<2>(b);\n\t}\n\telse {\n\t\tdouble d = sqrt(disdis(a, b));\n\t\treturn heron(get<2>(a), get<2>(b), d) * 2 / d;\n\t}\n}\n\ndouble three(const tuple<double, double, double>& a, const tuple<double, double, double>& b, const tuple<double, double, double>& c)\n{\n\ttuple<double, double, double> temp;\n\n\tif (ISLOOSE(a, b) && ISLOOSE(a, c))\n\t\treturn get<2>(a);\n\tif (ISLOOSE(b, a) && ISLOOSE(b, c))\n\t\treturn get<2>(b);\n\tif (ISLOOSE(c, a) && ISLOOSE(c, b))\n\t\treturn get<2>(c);\n\n\tif (ISLOOSE(temp = com(a, b), c))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(b, c), a))\n\t\treturn get<2>(temp);\n\tif (ISLOOSE(temp = com(c, a), b))\n\t\treturn get<2>(temp);\n\n\treturn heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n\t\t* 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n\nint main()\n{\n\tint n;\n\tdouble res;\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\twhile (cin >> n, n) {\n\t\tvector< tuple<double, double, double> > str(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n\t\t}\n\t\tif (n == 1) {\n\t\t\tcout << (double)get<2>(str[0]) << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tcout << two(str[0], str[1]) << endl;\n\t\t}\n\t\telse {\n\t\t\tres = 100000000.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tres = min(res, three(str[i], str[j], str[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nint n;\ndouble calc(vector<double>&x,vector<double>&y,vector<double>&l,double xs){\n    double uy = 100.0;\n    double ly = -100.0;\n    while(uy-ly>=0.000001){\n            double a = (uy*2.0+ly)/3.0; \n            double b = (uy+ly*2.0)/3.0;\n            double ma = 100000.0;\n            double mb = 100000.0;\n            for(int i=0;i<n;i++){\n                ma = min(ma,l[i]*l[i]-(x[i]-xs)*(x[i]-xs)-(y[i]-a)*(y[i]-a));\n            }\n            for(int i=0;i<n;i++){\n                mb = min(mb,l[i]*l[i]-(x[i]-xs)*(x[i]-xs)-(y[i]-b)*(y[i]-b));\n            }\n            if(ma > mb){\n                ly = b;\n            }else{\n                uy = a;\n            }\n        }\n    return (uy+ly)/2.0;\n}\n\nint main(){\n    while(cin >> n&&n!=0){\n        vector<double>x(n),y(n),l(n);\n        for(int i=0;i<n;i++)cin >> x[i] >> y[i] >>l[i];\n        double ux = 100.0;\n        double lx = -100.0;\n        double uy = 100.0;\n        double ly = -100.0;\n        double tmpy = 0.0;\n        while(ux-lx>=0.000001){\n            double a = (ux*2.0+lx)/3.0; \n            double b = (ux+lx*2.0)/3.0;\n            double ma = 100000.0;\n            double mb = 100000.0;\n            tmpy = calc(x,y,l,a);\n            for(int i=0;i<n;i++){\n                ma = min(ma,l[i]*l[i]-(x[i]-a)*(x[i]-a)-(y[i]-tmpy)*(y[i]-tmpy));\n            }\n            tmpy = calc(x,y,l,b);\n            for(int i=0;i<n;i++){\n                mb = min(mb,l[i]*l[i]-(x[i]-b)*(x[i]-b)-(y[i]-tmpy)*(y[i]-tmpy));\n            }\n            if(ma > mb){\n                lx = b;\n            }else{\n                ux = a;\n            }\n        }\n        double tmpx = (ux+lx)/2.0;\n        tmpy = calc(x,y,l,tmpx);\n        double mi = 100000.0;\n        for(int i=0;i<n;i++){\n            \n            mi = min(mi,l[i]*l[i]-(x[i]-tmpx)*(x[i]-tmpx)-(y[i]-tmpy)*(y[i]-tmpy));\n            \n        }\n        cout <<fixed << setprecision(10) << sqrt(mi) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n// Library\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n};\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=IINF):p(p),r(r){}\n};\n\npair<Point, Point> intersectCC( Point C1, double r1, Point C2, double r2) {\n  complex<double> c1(C1.x,C1.y);\n  complex<double> c2(C2.x,C2.y);\n  complex<double> A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  complex<double> D = B*B-4.0*A*C;\n  complex<double> z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<Point, Point>(Point(z1.real(),z1.imag()),Point(z2.real(),z2.imag()));\n}\n\n// Library\n\nbool insideCC(Circle a,Circle b){\n  double d = sqrt(norm(a.p-b.p));\n  double r1 = max(a.r,b.r);\n  double r2 = min(a.r,b.r);\n \n  if(!equals(d,r1-r2) && d < r1-r2) return a.r < b.r; \n  return false;\n}\n\nbool insideCP(Circle c,Point p){\n  double dist = abs(c.p-p);\n  return equals(dist,c.r) || dist < c.r;\n}\n\nint n;\nPoint ps[11];\ndouble ls[11];\n\nbool check(double h){\n  vector<Circle> cs;\n  bool out[n];\n  rep(i,n) out[i] = false;\n\n  rep(i,n) {\n    if( equals(h,ls[i]) || h >= ls[i] ) return false;\n    rep(j,n){\n      if( i == j ) continue;\n      double r1 = sqrt( pow(ls[i],2) - pow(h,2) ), r2 = sqrt( pow(ls[j],2) - pow(h,2) );\n      if(insideCC((Circle){ps[i],r1},(Circle){ps[j],r2})) out[j] = true;\n    }\n  }\n\n  rep(i,n) if( !out[i] ) {\n    double r = sqrt( pow(ls[i],2) - pow(h,2) );\n    cs.push_back(Circle(ps[i],r));\n  }\n\n  if( cs.size() == 1 ) return true;\n  vector<Point> cps;\n\n  rep(i,cs.size()) REP(j,i+1,cs.size()){\n    pair<Point,Point> pp = intersectCC(cs[i].p,cs[i].r,cs[j].p,cs[j].r);\n    cps.push_back(pp.first);    \n    cps.push_back(pp.second);\n  }\n\n  rep(i,cps.size()){\n    rep(j,cs.size()) if( !insideCP(cs[j],cps[i]) ) goto Skip;\n    return true;\n  Skip:;\n  }\n  return false;\n}\n\nint main(){\n  while( cin >> n, n ){\n    rep(i,n) cin >> ps[i].x >> ps[i].y >> ls[i];\n\n    double L = 0, R = 1e10;\n    rep(_,60){\n      double M = ( L + R ) * 0.5;\n      if( check(M) ) L = M;\n      else           R = M;\n    }\n    printf(\"%.7f\\n\",R);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<complex>\nusing namespace std;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\n\nbool zero(double a) { return abs(a) <= EPS; }\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nbool canClear(P p, int i1, int i2) {\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && EPS + r[i] < abs(p - dir[i])) return false;\n  return true;\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (-EPS > ((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) r[i] = 0.0;\n    r[i] = sqrt((double)l[i] * l[i] - h * h);\n  }\n  for (int i = 0; i < n; i++) if (canClear(dir[i], -1, -1)) return true;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      double d = abs(dir[j] - dir[i]);\n      if (d - r[i] - r[j] > EPS) return false;\n      if (r[i] - r[j] - d > EPS) continue;\n      if (r[j] - r[i] - d > EPS) continue;\n      double A = atan2((dir[j] - dir[i]).imag(), (dir[j] - dir[i]).real());\n      double S = acos((d*d + r[i]*r[i] - r[j]*r[j]) / (2 * d * r[i]));\n      if (canClear(dir[i] + polar(r[i], S + A), i, j)) return true;\n      if (canClear(dir[i] + polar(r[i], S - A), i, j)) return true;\n    }\n  }\n  return false;\n  //return true;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i] = P(x[i], y[i]);\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%.7f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P{ bl[i][0],bl[i][1] }, P{ bl[j][0],bl[j][1] }, P{ a,b });\n\t\t\tif (cc != ccw(P{ bl[j][0],bl[j][1] }, P{ bl[k][0],bl[k][1] }, P{ a,b }) || cc != ccw(P{ bl[k][0],bl[k][1] }, P{ bl[i][0],bl[i][1] }, P{ a,b }))continue;\n\t\t\tans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\nDef inf = sizeof(Def) == sizeof(long long) ?  2e18:1e9+10;\nconst double EPS=1e-7;\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\n\nstruct L : public vector<P>{\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n\t\n};\n\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{\n\tbool operator < (const P &a,const P &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n\n}\n\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\n\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>in;\n\t\trep(i,n){\n\t\t\tdouble a,b,c;cin>>a>>b>>c;\n\t\t\tin.pb(C(P(a,b),c));\t\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"%.9f\\n\",in[0].r);\n\t\t\tcontinue;\n\t\t}\n\t\tdouble l=0,r=311;\n\t\twhile(r-l>EPS*1e-3){\n\t\t\tdouble h=(l+r)/2;\n\t\t\tbool H=false;\n\t\t\tvector<C>t;\n\t\t\trep(i,n){\n\t\t\t\tdouble w=in[i].r*in[i].r-h*h;\n\t\t\t\tif(w<0)goto end;\n\t\t\t\tt.pb(C(in[i].c,sqrt(w)));\n\t\t\t}\n\t\t\trep(i,n){\n\t\t\t\tbool e=true;\n\t\t\t\trep(j,n)if(abs(t[i].c-t[j].c)>t[j].r+EPS)e=false;\n\t\t\t\tif(e)H=true;\n\t\t\t}\n\t\t\trep(i,n)loop(j,i+1,n)if(abs(t[i].c-t[j].c)<t[i].r+t[j].r){\n\t\t\t\tif(t[i].r>EPS+abs(t[i].c-t[j].c)+t[j].r)continue;\n\t\t\t\tif(t[j].r>EPS+abs(t[i].c-t[j].c)+t[i].r)continue;\n\t\t\t\tL l=crosspointCC(t[i],t[j]);\n\t\t\t\trep(k,2){\n\t\t\t\t\tbool e=true;\n\t\t\t\t\trep(x,n)\n\t\t\t\t\t\tif(abs(t[x].c-l[k])-EPS>t[x].r)e=false;\n\t\t\t\t\tif(e)H=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend:;\n//\t\t\tprintf(\"         %.9f %.9f %.9f\\n\",l,h,r);\n\t\t\tif(H)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tprintf(\"%.9f\\n\",r);\n\t}\n\t\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define ISLOOSE(a,b)    (disdis(a, b) + get<2>(a) * get<2>(a) <= get<2>(b) * get<2>(b))\n \nusing namespace std;\n\ndouble disdis(const tuple<double, double, double>& a, const tuple<int, int, int>& b)\n{\n\treturn (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n\nint disdis(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    return (get<0>(a) - get<0>(b)) * (get<0>(a) - get<0>(b)) + (get<1>(a) - get<1>(b)) * (get<1>(a) - get<1>(b));\n}\n \ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2;\n    return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n \ndouble heron2(double a, double b, double c, double d, double e, double f)\n{\n    return sqrt((a*d*(b + c + e + f - a - d) + b*e*(c + a + f + d - b - e) + c*f*(a + b + d + e - c - f) - a*b*f - a*e*c - d*b*c - d*e*f) / 144.0);\n}\n \ntuple<double, double, double> com(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return a;\n    }\n    else if (ISLOOSE(b, a)) {\n        return b;\n    }\n    else {\n        double l = heron(get<2>(a), get<2>(b), sqrt(disdis(a, b))) * 2 / sqrt(disdis(a, b));\n        double d1 = sqrt(get<2>(a) * get<2>(a) - l * l);\n        double d2 = sqrt(get<2>(b) * get<2>(b) - l * l);\n        return tuple<double, double, double>(get<0>(a) + (get<0>(b) - get<0>(a)) * d1 / (d1 + d2), get<1>(a) + (get<1>(b) - get<1>(a)) * d1 / (d1 + d2), l);\n    }\n}\n \ndouble two(const tuple<int, int, int>& a, const tuple<int, int, int>& b)\n{\n    if (ISLOOSE(a, b)) {\n        return (double)get<2>(a);\n    }\n    else if (ISLOOSE(b, a)) {\n        return (double)get<2>(b);\n    }\n    else {\n        double d = sqrt(disdis(a, b));\n        return heron(get<2>(a), get<2>(b), d) * 2 / d;\n    }\n}\n \ndouble three(const tuple<int, int, int>& a, const tuple<int, int, int>& b, const tuple<int, int, int>& c)\n{\n    tuple<double, double, double> temp;\n \n    if (ISLOOSE(a, b) && ISLOOSE(a, c))\n        return get<2>(a);\n    if (ISLOOSE(b, a) && ISLOOSE(b, c))\n        return get<2>(b);\n    if (ISLOOSE(c, a) && ISLOOSE(c, b))\n        return get<2>(c);\n \n    if (ISLOOSE(temp = com(a, b), c))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(b, c), a))\n        return get<2>(temp);\n    if (ISLOOSE(temp = com(c, a), b))\n        return get<2>(temp);\n \n    return heron2(get<2>(a) * get<2>(a), get<2>(b) * get<2>(b), get<2>(c) * get<2>(c), disdis(b, c), disdis(c, a), disdis(a, b))\n        * 3.0 / heron(sqrt(disdis(a, b)), sqrt(disdis(b, c)), sqrt(disdis(c, a)));\n}\n \nint main()\n{\n    int n;\n    double res;\n\tcout << fixed << setprecision(7);\n    while (cin >> n, n) {\n        vector< tuple<int, int, int> > str(n);\n        for (int i = 0; i < n; i++) {\n            cin >> get<0>(str[i]) >> get<1>(str[i]) >> get<2>(str[i]);\n        }\n        if (n == 1) {\n            cout << (double)get<2>(str[0]) << endl;\n        }\n        else if (n == 2) {\n            cout << two(str[0], str[1]) << endl;\n        }\n        else {\n            res = 100000000.0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    for (int k = j + 1; k < n; k++) {\n                        res = min(res, three(str[i], str[j], str[k]));\n                    }\n                }\n            }\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<complex>\n#define EQ(x,y) (fabs((x)-(y))<EPS)\n#define pb push_back\n#define sq(x) ((x)*(x))\nusing namespace std;\nconst double EPS=1e-8;\nconst double INF=1e12;\ndouble PI=3.14159265359;\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a,const P& b){\n\t\treturn real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n\t}\n}\nstruct C{\n\tP p;double r;\n\tC(const P &p,double r):p(p),r(r){}\n};\nvector<P>crosspointCC(const C &c1,const C &c2){\n\tvector<P>res;\n\tP v=c2.p-c1.p;\n\tdouble d=abs(v);\n\tif(d<EPS){\n\t\tif(EQ(c1.r,c2.r)){\n\t\t\tres.pb(c1.p+P(c1.r,0));\n\t\t}\n\t\treturn res;\n\t}\n\tvector<double>thetas;\n\tif(EQ(d,c1.r+c2.r)){//return res;\n\t\tthetas.pb(0);\n\t}else if(EQ(c1.r-c2.r,d)){//return res;\n\t\tthetas.pb(0);\n\t}else if(EQ(c2.r-c1.r,d)){//return res;\n\t\tthetas.pb(PI);\n\t}else if(d>c1.r+c2.r||d<abs(c1.r-c2.r)){\n\t\treturn res;\n\t}else{\n\t\t//printf(\"%f\\n\",((sq(c1.r)+sq(d)-sq(c2.r))/(2.0*c1.r*d)));\n\t\tdouble t=acos((sq(c1.r)+sq(d)-sq(c2.r))/(2.0*c1.r*d));\n\t\tthetas.pb(t);\n\t\tthetas.pb(-t);\n\t//}\n\t//printf(\"%f %f \\n\",real(c1.p),imag(c1.p));\n\tfor(int i=0;i<thetas.size();i++){\n\t\tres.pb(c1.p+c1.r/d*v*P(cos(thetas[i]),sin(thetas[i])));\n\n\t\t//printf(\"%f %f %f\\n\",thetas[i],real(res[i]),imag(res[i]));\n\t}}\n\treturn res;\n}\ndouble x[10];\ndouble y[10];\ndouble l[10];\n\nint main(){\n\tint a;\n\t//printf(\"%f %f\\n\",real(crosspointCC(C(P(0,0),2),C(P(1,0),2))[0]),imag(crosspointCC(C(P(0,0),2),C(P(0,1),2))[0]));\n\t//return 0;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tbool dame=false;\n\t\t\tvector<P> una;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tfor(int k=j+1;k<a;k++){\n\t\t\t\t\tif(M*M>l[j]*l[j]||M*M>l[k]*l[k]||sqrt(sq(x[j]-x[k])+sq(y[j]-y[k]))>sqrt(sq(l[k])-sq(M))+sqrt(sq(l[j])-sq(M))){\n\t\t\t\t\t\tdame=true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//if()\n\t\t\t\t\tvector <P> fox=crosspointCC(C(P(x[j],y[j]),sqrt(l[j]*l[j]-M*M)),C(P(x[k],y[k]),sqrt(l[k]*l[k]-M*M)));\n\t\t\t\t\t//if(fox.size()==0)dame=true;\n\t\t\t\t\tfor(int m=0;m<fox.size();m++)una.push_back(fox[m]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tuna.push_back(P(0.0,0.0));\n\t\t\tfor(int j=0;j<a;j++)una.push_back(P(x[j],y[j]));\n\t\t\t//printf(\"%f :\",M);\n\t\t\t//if(dame)printf(\"dame\\n\");\n\t\t\t//else printf(\"\\n\");\n\t\t\tif(dame){\n\t\t\t\tright=M;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<una.size();k++){\n\t\t\t\tbool OK=true;\n\t\t\t\t\n\t\t\t\t\n\t\t\t//\tif(M>72.2&&M<72.4)printf(\"%d %f %f\\n\",k,real(una[k]),imag(una[k]));\n\t\t\t\tif(isnan((long double)real(una[k]))||isnan((long double)imag(una[k])))continue;\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\n\t\t\t\t\tif(abs(P(x[j],y[j])-una[k])*abs(P(x[j],y[j])-una[k])>EPS+(l[j])*(l[j])-M*M){\n\t\t\t\t\tif(M>72.2&&M<72.4){\n\t\t\t\t//\t\tprintf(\"%f %f %d %f %f\\n\",real(una[k]),imag(una[k]),j,abs(P(x[j],y[j])-una[k])*abs(P(x[j],y[j])-una[k]),(l[j])*(l[j])-M*M);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tOK=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(OK)ok=true;\n\t\t\t}\n\t\t\tif(ok)left=M;\n\t\t\telse right=M;\n\t\t}\n\t\tprintf(\"%.9f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double eps = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=INF,y=INF;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n};\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\n\nP unit_vector(P t){\n  double u=fabs(dis(t));\n  return P(t.x/u , t.y/u);\n}\nP rotate(P t , P p , double r){\n  //double r=radians(angle);\n  double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n  double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n  return P(ta , tb);\n}\n\nvoid interpoint_cc(P a , double ra , P b , double rb , P ans[]){\n  double di=fabs(dis(a-b));\n  if(di > ra+rb || di < fabs(ra-rb)) return;\n  double t=(ra*ra-rb*rb+di*di)/(di+di);\n  double rd=acos(t/ra);\n\n  P dv=unit_vector(b-a);\n  P g1=rotate(dv , P(0,0) , rd);\n  P g2=rotate(dv , P(0,0) , -rd);\n  ans[0]=a+g1*ra;\n  ans[1]=a+g2*ra;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<P> p(N);\n\tvector<double> ls(N);\n\tREP(i,N) cin >> p[i].x >> p[i].y >> ls[i];\n\n\tdouble lb = 0, ub = 300;\n\tREP(loop,200){\n\t  double h = (lb + ub) / 2.;\n\t  bool ok = true;\n\t  REP(i,N) if(ls[i] < h) ok = false;\n\n\t  if(ok){\n\t\tok = false;\n\t\tvector<double> ri(N);\n\t\tREP(i,N) ri[i] = sqrt(ls[i]*ls[i] - h*h);\n\t\tREP(i,N){\n\t\t  REP(j,N){\n\t\t\tif(dis(p[i]-p[j])> ri[i]+ri[j]) continue;\n\t\t\tP icp[2];\n\t\t\tinterpoint_cc(p[i], ri[i], p[j], ri[j], icp);\n\t\t\tint c1 = 0, c2 = 0;\n\t\t\tREP(k,N){\n\t\t\t  if(k == i || k == j){\n\t\t\t\t++c1, ++c2; continue;\n\t\t\t  }\n\t\t\t  if(dis(p[k]-icp[0]) <= ri[k])\n\t\t\t\t++c1;\n\t\t\t  if(dis(p[k]-icp[1]) <= ri[k])\n\t\t\t\t++c2;\n\t\t\t}\n\t\t\tif(c1 == N || c2 == N) ok = true;\n\t\t  }\n\t\t}\n\t  }\n\n\t  if(ok) lb = h;\n\t  else ub = h;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\ntypedef struct {int x, y, l;} Anchor;\n\nint N;\nAnchor anchers[10];\n\nbool check(double H){\n    //高さHについて要件を満たすか\n    for(int i=0; i<N; i++){\n        for(int j=0; j<i; j++){\n            Anchor a1 = anchers[i];\n            Anchor a2 = anchers[j];\n            double r1 = sqrt(a1.l*a1.l - H*H);\n            double r2 = sqrt(a2.l*a2.l - H*H);\n            if(sqrt((a1.x-a2.x)*(a1.x-a2.x)+(a1.y-a2.y)*(a1.y-a2.y)) > r1+r2)\n                return false;\n        }\n    }\n    \n    return true;\n}\n\nvoid solve(){\n    double lb = 0, ub = 300;\n    \n    //上限を最も短いロープの長さにする\n    for(int i=0; i<N; i++)\n        ub = min(ub, double(anchers[i].l));\n    \n    //二分探索\n    for(int i=0; i<50; i++){\n        double mid = (lb + ub)/2;\n        if(check(mid))\n            lb = mid;\n        else\n            ub = mid;\n    }\n    printf(\"%.07f\\n\", lb);\n}\n\nint main(int argc, const char * argv[]){\n    while(cin>>N, N){\n        for(int i=0; i<N; i++)\n            cin >> anchers[i].x >> anchers[i].y >> anchers[i].l;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct Circle{\n  double r;\n  P c;\n  Circle(double r=0.0, P c = P(0,0)):r(r),c(c){}\n  bool operator < (const Circle &c) const {\n    return r < c.r;\n  }\n};\n\nconst double EPS = 1e-8;\nconst double EPS2 = 0.0000001;\n\nint n;\ndouble ri;\nCircle v[11];\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersectCP(P p, Circle c){\n  return abs(c.c-p) < c.r || equal(abs(c.c-p),c.r);\n}\n\nvector<P> intersectCC(Circle C1, Circle C2){\n  vector<P> res;\n  double r1 = C1.r, r2 = C2.r, d;\n  P p1 = C1.c, p2 = C2.c;\n  d = abs(p1-p2);\n  if(d < EPS && abs(r1-r2) < EPS) return res;\n  if(r1 + r2 < d - EPS || d + EPS < abs(r1-r2)) return res;\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else{\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nbool func(vector<Circle> w){\n  bool f = false;\n  int ws = w.size();\n  if(ws == 1) return true;\n\n  //外側の円を消す\n  /*\n  for(int i=0;i<ws-1;i++) {\n    if(abs(w[ws-1].c-w[i].c) > w[ws-1].r-w[i].r && !equal(abs(w[ws-1].c-w[i].c),w[ws-1].r-w[i].r)){\n      f = true;\n      break;\n    }\n  }\n  if(!f) {\n    w.pop_back();\n    return func(w);\n  }\n  */\n\n  //内側の円を消す\n  f = false;\n  for(int i=1;i<ws;i++) {\n    if(abs(w[i].c-w[0].c) > w[i].r-w[0].r && !equal(abs(w[i].c-w[0].c),w[i].r-w[0].r)){\n      f = true;\n      break;\n    }\n  }\n  if(!f) {\n    //w.erase(w.begin());\n    //return func(w);\n    return true;\n  }\n\n\n  //円の交点を求め、１つでも全ての円の内側・境界に存在するならtrue\n  vector<P> p;\n  for(int i=0;i<ws;i++){\n    for(int j=i+1;j<ws;j++){\n      vector<P> aa = intersectCC(w[i],w[j]);\n      //if(aa.size() == 0) return false;\n      for(int k=0;k<aa.size();k++) p.push_back(aa[k]);\n    }\n  }\n\n  for(int i=0;i<p.size();i++){\n    int j;\n    for(j=0;j<ws;j++){\n      if(!isIntersectCP(p[i],w[j])) break;\n    }\n    if(j == ws) return true;\n  }\n  return false;\n}\n\nbool check(double h){\n  if(n == 1) return h < v[0].r;\n  vector<Circle> w;\n\n  for(int i=0;i<n;i++) w.push_back(Circle(sqrt(v[i].r*v[i].r - h*h), v[i].c));\n  sort(w.begin(),w.end());\n  return func(w);\n}\n\nvoid solve(){\n  double c,le=0.0;\n  for(int i=0;i<100;i++){\n    c = (ri + le) / 2.0;\n    if(check(c)) le = c;\n    else ri = c;\n  }\n  printf(\"%.7f\\n\",ri);\n}\n\nint main(){\n  while(cin >> n && n){\n    ri = 400.0;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> x >> y >> v[i].r;\n      v[i].c = P(x,y);\n      ri = min(ri, v[i].r);\n    }\n    solve();\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n#include <immintrin.h>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n  \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n   \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n   \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n   \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n}\nint main() {\n    int n;\n    cin.sync_with_stdio(0);\n    while (cin >> n, n) {\n        va<float, 3> bl(n);\n        rep(i, n)rep(j, 3)cin >> bl[i][j];\n        //va<double, 3> h;\n        double ans = 1e9;\n        int mina = 0;\n        rep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n        ans *= ans;\n        rep(i, n) {\n            rep(j, i) {\n                double l = sqrt(double(bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n                double a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n                double x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n                if (z < 0)continue;\n                if (z<ans&&a > 0 && a < l)ans = z;\n                double x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n                if (x01 != 0) {\n                    double rv = 1 / x01;\n                    rep(k, j) {\n                        double x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n                        double a, b, c;\n                        double rv2 = x10 * x01 - x11*x00;\n                        if (rv2 == 0)continue;\n                        rv2 = 1 / rv2;\n                        a = rv2*(x12 * x01 - x11 * x02)*0.5;\n                        b = (x02 * 0.5 - a*x00)*rv;\n                        c = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n                        if (c < 0)continue;\n                        if (c >= ans)continue;\n                        int cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                        if (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                    }\n                }\n                else {\n                    double a = x02*0.5 / x00;\n                    double c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n                    rep(k, j) {\n                        double x11 = bl[i][1] - bl[k][1];\n                        if (x11 == 0)continue;\n                        double x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n                        double b = (x12*0.5 - a*x10) / x11, c;\n                        c = c_ - (b - bl[i][1])*(b - bl[i][1]);\n                        if (c < 0)continue;\n                        if (c >= ans)continue;\n                        int cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                        if (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                    }\n                }\n            }\n        }\n        cout << fixed << setprecision(7) << sqrt(ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n  \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n  \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n  \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\n  \nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<float, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt(double((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1])));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02;\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\tx02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / rv2;\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02)*0.5;\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x10) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 2円の交点\nVP crosspointCC(Point a, double ar, Point b, double br) {\n  VP ps;\n  Point ab = b-a;\n  double d = abs(ab);\n  double crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  Point abN = ab * Point(0, sqrt(ar*ar - crL*crL) / d);\n  Point cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\n\nint main(){\n    int n;\n    while(scanf(\" %d\", &n),n){\n        vector<Point> p(n);\n        vector<int> l(n);\n        rep(i,n){\n            int x,y;\n            scanf(\" %d %d %d\", &x, &y, &l[i]);\n            p[i] = Point(x,y);\n        }\n\n        if(n==1){\n            printf(\"%d\\n\", l[0]);\n            continue;\n        }\n\n        int min_l = 300;\n        rep(i,n) min_l = min(min_l, l[i]);\n\n        auto check = [&](double h){\n            vector<double> r(n);\n            rep(i,n) r[i] = sqrt(l[i]*l[i] - h*h);\n\n            VP candidate;\n            rep(i,n) candidate.pb(p[i]);\n            rep(i,n)rep(j,i){\n                for(Point c:crosspointCC(p[i],r[i],p[j],r[j])) candidate.pb(c);\n            }\n\n            for(Point c:candidate){\n                bool ok = true;\n                rep(i,n){\n                    double d = abs(p[i]-c);\n                    ok &= (LE(d,r[i]));\n                }\n                if(ok) return true;\n            }\n            return false;\n        };\n\n        double L=0, R=min_l;\n        rep(loop,50){\n            double m = (L+R)/2;\n            if(check(m)) L=m;\n            else R=m;\n        }\n\n        printf(\"%.10f\\n\", L);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\ndouble arg(Vector p){ return atan2(p.y,p.x);}\nVector polar(double a,double r){ return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(double)(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return mp(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nbool isContain(Circle c1,Circle c2){\n  if((abs(c1.c-c2.c)+c1.r-c2.r)<-eps)return true;\n  if((abs(c1.c-c2.c)+c2.r-c1.r)<-eps)return true;\n  return false;\n}\n\nint n;\nvector<pair<Point,double> > vp;\nvector<Circle> vc;\n\nbool check(Point p){\n  for(int i=0;i<n;i++){\n    if(vc[i].r-abs(p-vc[i].c)<-eps)return false;\n  }\n  return true;\n}\n\nbool ok(double mid){\n  vc.clear();\n\n  for(int i=0;i<n;i++){\n    if(vp[i].s-mid<eps)return false;\n    vc.push_back(Circle(vp[i].f,sqrt(vp[i].s*vp[i].s-mid*mid)));\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if((vc[i].r+vc[j].r)-abs(vc[i].c-vc[j].c)<-eps)return false;\n      if(isContain(vc[i],vc[j]))continue;\n      pair<Point,Point> pp=getCrossPoints(vc[i],vc[j]);\n      if(check(pp.f))return true;\n      if(check(pp.s))return true;\n    }\n  }\n  return vc.size()==1;\n}\n\nint main()\n{\n  int a,b,c;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vp.clear();\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c;\n      vp.push_back(mp(Point(a,b),c));\n    }\n\n    double l=0,r=1000,mid;\n    for(int i=0;i<100;i++){\n      mid=(l+r)/2;\n      if(ok(mid))l=mid;\n      else r=mid;\n      //cout<<endl;\n    }\n    printf(\"%.10f\\n\",mid);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Complex;\n\nconst double EPS = 1e-10, PI = M_PI;\nll N;\nComplex P[10];\ndouble L[10];\n\nbool ok(double h) {\n  vector<double> r(N);\n  REP(i, 0, N) {\n    if(h > L[i]) return false;\n    r[i] = sqrt(L[i] * L[i] - h * h);\n  }\n\n  bool ret = false;\n  REP(m, 0, N) {\n    vector<pair<double, double>> theta(N);\n    REP(i, 0, N) if(i != m) {\n      Complex p1 = P[m], p2 = P[i];\n      double r1 = r[m], r2 = r[i];\n\n      if(abs(p2 - p1) > r1 + r2) return false;\n      if(abs(p2 - p1) < abs(r2 - r1)) {\n        if(r1 < r2) {\n          theta[i] = pair<double, double>(-PI, PI);\n        } else {\n          theta[i] = pair<double, double>(1e20, 1e20);\n        }\n        continue;\n      }\n\n      double d = abs(p2 - p1);\n      double t = abs((d * d + r1 * r1 - r2 * r2) / (d * 2));\n      double h = sqrt(r1 * r1 - t * t);\n\n      Complex u = (p2 - p1) / d;\n      Complex v = u * Complex(0, 1);\n      Complex q1 = p1 + u * t - v * h;\n      Complex q2 = p1 + u * t + v * h;\n\n      double theta1 = arg(q1 - p1);\n      double theta2 = arg(q2 - p1);\n      theta[i] = pair<double, double>(theta1, theta2);\n    }\n\n    vector<double> uniq;\n    REP(i, 0, N) if(i != m) {\n      uniq.push_back(theta[i].first);\n      uniq.push_back(theta[i].second);\n    }\n    sort(uniq.begin(), uniq.end());\n    uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());\n\n    vector<pair<ll, ll>> range(N);\n    REP(i, 0, N) if(i != m) {\n      range[i].first = lower_bound(uniq.begin(), uniq.end(), theta[i].first) - uniq.begin();\n      range[i].second = lower_bound(uniq.begin(), uniq.end(), theta[i].second) - uniq.begin();\n    }\n\n    ll k = uniq.size();\n    vector<ll> sum(k + 1, 0);\n    REP(i, 0, N) if(i != m) {\n      if(range[i].first <= range[i].second) {\n        sum[range[i].first]++;\n        sum[range[i].second + 1]--;\n      } else {\n        sum[range[i].first]++;\n        sum[k]--;\n        sum[0]++;\n        sum[range[i].second + 1]--;\n      }\n    }\n    REP(i, 0, k) sum[i + 1] += sum[i];\n\n    REP(i, 0, k + 1) ret = ret || sum[i] >= N - 1;\n  }\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) {\n      double x, y;\n      cin >> x >> y >> L[i];\n      P[i] = Complex(x, y);\n    }\n\n    double l = 1, h = 1e5;\n    REP(_, 0, 100) {\n      double m = (l + h) / 2;\n      if(ok(m)) l = m; else h = m;\n    }\n    printf(\"%.15lf\\n\", l);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n  \nusing namespace std;\n  \n#define EPS 1e-9\n  \nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n   \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n} \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n   \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n   \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n  \nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n  \npoint rot(point p, double a) {\n    point ret;\n    double C = cos(a), S = sin(a);\n    ret.x = p.x*C - p.y*S;\n    ret.y = p.x*S + p.y*C;\n    return ret;\n}\n   \nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n#endif\n    while(1) {\n        scanf(\"%d\",&n); \n        if(n==0) break;\n        for(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n  \n        double ans = -1e20;\n        for(int i=0;i<n;++i) {\n            double tmp = r[i];\n            bool can = 1;\n            for(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n            if(can) ans = max(ans, tmp);\n        }\n  \n        for(int i=0;i<n;++i) {\n            memcpy(cP,P,sizeof(cP));\n            for(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n            for(int j=i+1;j<n;++j) if(j!=i) {\n                double d = dis(cP[i],cP[j]);\n                if(r[i]+r[j] < d-EPS) continue;\n                if(abs(r[i]-r[j]) > d+EPS) continue;\n  \n                memcpy(nP,cP,sizeof(nP));\n                double a = atan2(cP[j].y,cP[j].x);\n                for(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n  \n                bool can = 1;\n                point p1,p2;\n                intersection_circle_circle(point(nP[j].x,nP[j].y),r[j],point(nP[i].x,nP[i].y),r[i],p1,p2);\n                double zz = max(p1.y,p2.y), yy = 0;\n                double xx = p1.x;\n                for(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n                if(can)\n                    ans = max(ans, zz);\n  \n                double rr = zz;\n                for(int k=0;k<n;++k) nP[k].x -= xx;\n                for(int k=j+1;k<n;++k) if(k!=i && k!=j && abs(nP[k].x) <= r[k]+EPS){\n                    double nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n                    double d = abs(nP[k].y);\n                    if(nr+rr < d-EPS) continue;\n                    if(abs(nr-rr) > d+EPS) continue;\n  \n                    bool can = 1;\n                    point p1,p2;\n                    intersection_circle_circle(point(0,0),rr,point(nP[k].y,0),nr,p1,p2);\n                    double zz = max(p1.y,p2.y), xx = 0;\n                    double yy = p1.x;\n                    for(int h=0;h<n;++h) if(sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)) > r[h] + EPS) can = 0;\n                    if(can)\n                        ans = max(ans, zz);\n                }\n            }\n        } printf(\"%.10lf\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\nVP crosspointCC(C a, C b){\n    VP ps;\n    if(a.r < b.r) swap(a,b);\n    P ab = b.p-a.p;\n    double dist = abs(ab);\n    if(EQ(dist, a.r+b.r) || EQ(dist, a.r-b.r)){\n        ps.push_back( a.p +ab*(a.r/dist) );\n        return ps;\n    }\n    if(dist > a.r +b.r || dist < abs(a.r-b.r)){\n        return ps;\n    }\n    double l = ((a.r*a.r -b.r*b.r)/dist +dist) /2;\n    double n = sqrt(a.r*a.r -l*l);\n    P mid = a.p + ab*l/dist;\n    P ort = ab *(n/dist) *P(0,1);\n    ps.push_back(mid+ort);\n    ps.push_back(mid-ort);\n    return ps;\n}\n\nconst int nrep = 50;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<double> x(n), y(n), l(n);\n\t\tdouble lmin=INF;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t\tlmin = min(lmin, l[i]);\n\t\t}\n\t\t\n\t\tdouble lb=0, ub=lmin;\n\t\tfor(int i=0; i<nrep; i++){\n\t\t\tdouble mid = (lb+ub)/2;\n\t\t\tvector<C> c(n);\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tc[j] = C(P(x[j],y[j]), sqrt(l[j]*l[j] -mid*mid));\n\t\t\t}\n\t\t\tbool success = false;\n\t\t\tfor(int s=0; s<n && !success; s++){\n\t\t\t\tfor(int t=s+1; t<n && !success; t++){\n\t\t\t\t\tVP cp = crosspointCC(c[s], c[t]);\n\t\t\t\t\tfor(int j=0; j<(int)cp.size(); j++){\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\t\t\tif(abs(cp[j]-c[k].p) > c[k].r +EPS){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(abs(c[j].p-c[k].p) > c[k].r +EPS){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(success){\n\t\t\t\tlb = mid;\n\t\t\t}else{\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t\tcout << (lb+ub)/2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-5)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=100;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq=q*conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b)) res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,D> C;\n\nconst D EPS = 1e-8;\nint n;\nD x[11],y[11],l[11];\n\ninline P unit(P p){return p/abs(p);}\ninline P rotate(P v, D s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s));\n}\ninline D arg(D a, D b, D c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\ninline int cpr(C a, C b){\n  D d = abs(a.fs - b.fs);\n  if(a.sc+b.sc + EPS < d)return -1;\n  if(b.sc+d + EPS < a.sc)return 1;\n  if(a.sc+d + EPS < b.sc)return 2;\n  if(abs(a.sc+b.sc - d) < EPS)return -3;\n  if(abs(b.sc+d - a.sc) < EPS)return 3;\n  if(abs(a.sc+d - b.sc) < EPS)return 4;\n  return 0;\n}\n\ninline vector<P> cross_point(C a, C b){\n  vector<P> v;\n  int pos = cpr(a,b);\n  if(pos==0){\n    D s = arg(b.sc, abs(b.fs-a.fs), a.sc);\n    P x = a.sc * unit(b.fs - a.fs);\n    v.push_back(a.fs + rotate(x,s));\n    v.push_back(a.fs + rotate(x,-s));\n  }else if(abs(pos) >= 3){\n    v.push_back(a.fs + a.sc * unit(b.fs-a.fs));\n  }\n  return v;\n}\n\nbool check(D hight){\n  //cerr << hight << endl;\n  for(int i=0;i<n;i++){\n    if(l[i]+EPS<hight)return false;\n  }\n\n  C c[11];\n  for(int i=0;i<n;i++){\n    c[i] = C(P(x[i],y[i]),sqrt(l[i]*l[i]-hight*hight));\n  }\n\n  vector<P> vp;\n  for(int i=0;i<n;i++){\n    vp.push_back(c[i].fs);\n    for(int j=i+1;j<n;j++){\n      vector<P> cp = cross_point(c[i],c[j]);\n      for(int k=0;k<(int)cp.size();k++)vp.push_back(cp[k]);\n    }\n  }\n\n  for(int j=0;j<(int)vp.size();j++){\n    bool f = true;\n    for(int i=0;i<n;i++){\n      D dis = abs(vp[j]-c[i].fs);\n      if(dis*dis + hight*hight > l[i]*l[i] + EPS){\n\tf = false;\n\tbreak;\n      }\n    }\n    if(f)return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> l[i];\n\n    D lb = 0, ub = 1000;\n    for(int z=0;z<100;z++){\n      D mid = (lb+ub)/2;\n      if(check(mid))lb = mid;\n      else ub = mid;\n    }\n\n    cout << fixed << setprecision(7) << lb << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n \n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\n \n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n \n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  //cerr<<\"judge::\"<<m<<\" \";\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  //cerr<<\" val \";\n  for(int i=0;i<in.size();i++){\n    if(judge2(in[i].p,m))return true;\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m)+EPS)continue;\n      if(dist+in[j].R(m)<=in[i].R(m)+EPS)continue;\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return false;\n}\n \ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return r;\n  if(judge(m)){\n    //cerr<<\"true\"<<endl;\n    return req(m,r);\n  }else{\n    //cerr<<\"false\"<<endl;\n    return req(l,m);\n  }\n}\n \ndouble solve(){\n  double ans = req(0.5,301.0);\n  return ans;\n}\n \n \nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef complex<double> P;  // Point\ntypedef double D;\nconst double EPS = 1e-8;\ntypedef vector<P> VP;\nint N;\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\ndouble points[11][3];\nint main() {\n\t\n\t/*ifstream in(\"Ain.txt\");\n\tcin.rdbuf(in.rdbuf());\n\tofstream ofs(\"Aout.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\twhile(cin >> N, N) {\n\t\trep(n, N) {\n\t\t\trep(i, 3) cin >> points[n][i];\n\t\t}\n\t\tdouble M = 400;\n\t\trep(i, N) M = min(M, points[i][2]);\n\t\tdouble m = 0;\n\t\twhile (M - m > EPS) {\n\t\t\tVP kouho;\n\t\t\tdouble mid = (m + M)/ 2;\n\t\t\tvector<pair<P, double>> circles;\n\t\t\tbool nn = true;\n\t\t\trep(n, N) {\n\t\t\t\tdouble t = points[n][2];\n\t\t\t\tP p1 = P(points[n][0], points[n][1]);\n\t\t\t\tdouble r = sqrt(t * t - mid * mid);\n\t\t\t\tcircles.push_back(make_pair(p1, r));\n\t\t\t}\n\t\t\trep(i, N) {\n\t\t\t\tP p1 = get<0>(circles[i]);\n\t\t\t\tdouble r1 = get<1>(circles[i]);\n\t\t\t\tkouho.push_back(p1);\n\t\t\t\trep(j, i) {\n\t\t\t\t\tP p2 = get<0>(circles[j]);\n\t\t\t\t\tdouble r2 = get<1>(circles[j]);\n\t\t\t\t\tVP ps1 = crosspointCC(p1, r1, p2, r2);\n\t\t\t\t\tfor (P p : ps1) {\n\t\t\t\t\t\tkouho.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = false;\n\t\t\tfor(P p : kouho){\n\t\t\t\tbool f2 = true;\n\t\t\t\trep(i, N) {\n\t\t\t\t\tP p1 = get<0>(circles[i]);\n\t\t\t\t\tdouble r1 = get<1>(circles[i]);\n\t\t\t\t\tif (abs(p1 - p)  > r1 + EPS) {\n\t\t\t\t\t\tf2 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f2) f = true;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tm = mid;\n\t\t\t} else {\n\t\t\t\tM = mid;\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(20)<< m << endl;\n\t}\n\t\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nfloat x[10],y[10],l[10];\n\nbool rec(float h){\n\tfloat r[n];\n\tREP(i,n){\n\t\tif(l[i]<h)return false;\n\t\tr[i]=l[i]*l[i]-h*h;\n\t}\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(i==j)continue;\n\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])>(r[i]+r[j]+2.0*sqrt(r[i]*r[j])))return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>l[i];\n\t\tfloat ma=300.0,mi=1.0;\n\t\tREP(i,10000){\n\t\t\tfloat mid=(ma+mi)/2;\n\t\t\tif(rec(mid))mi=mid;\n\t\t\telse ma=mid;\n\t\t}\n\t\tprintf(\"%.10f\\n\",mi);\n\t}\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool is_intersect(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心に回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る半径rの円の中心座標\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//線分と点の距離\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(is_intersect(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分間の距離\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(is_intersect(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n//多角形内部に点pがあるか\nbool contains(vector<P> &poly,P p){\n\tint f=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\tdouble d=(p-poly[i]).det(poly[i]-poly[(i+1)%poly.size()]);\n\t\tif(d<0)f|=1;\n\t\telse if(d>0)f|=2;\n\t}\n\treturn f==(f&-f);\n}\n\n\nint main(){\n\tint n;\n\tdouble x[10],y[10],h[10],r[10];\n\twhile(cin>>n&&n){\n\t\tdouble lo=1,hi=300;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>h[i];\n\t\t\thi=min(hi,h[i]);\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tdouble mi=(lo+hi)/2;\n\t\t\tbool ok=false;\n\t\t\tvector<P> v;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tr[j]=sqrt(h[j]*h[j]-mi*mi);\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv.push_back(P(x[j],y[j]));\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tpair<P,P> pp=circle_intersection(x[j],y[j],r[j],x[k],y[k],r[k]);\n\t\t\t\t\tv.push_back(pp.first);\n\t\t\t\t\tv.push_back(pp.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<v.size()&&!ok;j++){\n\t\t\t\tint c=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif((x[k]-v[j].x)*(x[k]-v[j].x)+(y[k]-v[j].y)*(y[k]-v[j].y)\n\t\t\t\t\t\t< EPS+r[k]*r[k])c++;\n\t\t\t\t}\n\t\t\t\tif(c==n)ok=true;\n\t\t\t}\n\t\t\tif(ok)lo=mi;\n\t\t\telse hi=mi;\n\t\t}\n\t\tprintf(\"%.7f\\n\",lo);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\ntypedef complex<ld> Point;\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\n\nPoint input_point() {\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n    return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n    Point a, b;\n    Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle () : p(Point(0, 0)), r(0) {}\n    Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n    return isis_ll(l, s) &&\n        (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n        ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res;\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps){\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d,\tc.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0,\t1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = p.size();\n    REP(j,n) res += cross(p[j], p[(j+1)%n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i,n) {\n        Point a = poly[i], b = poly[(i+1)%n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = ps.size();\n    Polygon Q;\n    REP(i,n) {\n        Point A = ps[i], B = ps[(i+1)%n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n    for (Point q : ps) if (abs(q - p) < eps) return;\n    ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n    g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n    int n = p.size(), m = s.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (isis_sp(s[i], p[j]))\n            vec.emplace_back(abs(s[i].a - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            add_edge(g, from, to, abs(p[from] - p[to]));\n        }\n    }\n    return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n    int n = p.size(), m = c.size();\n    Graph g(n);\n    REP(i,m) {\n        vector<pair<ld,int>> vec;\n        REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n            vec.emplace_back(arg(c[i].p - p[j]), j);\n        sort(ALL(vec));\n        REP(j,vec.size()-1) {\n            int from = vec[j].second, to = vec[j+1].second;\n            ld angle = vec[j+1].first - vec[j].first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n        if (vec.size() >= 2) {\n            int from = vec.back().second, to = vec.front().first;\n            ld angle = vec.front().first - vec.back().first;\n            add_edge(g, from, to, angle * c[i].r);\n        }\n    }\n    return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n    int N = p.size();\n    polygon.clear();\n    REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n    vector<vector<tuple<ld,int,bool>>> tup(N);\n    REP(i,s.size()) {\n        int a = -1, b = -1;\n        REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n        REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n        assert(a >= 0 && b >= 0);\n        tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n        tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n    }\n    REP(i,N) sort(ALL(tup[i]));\n    REP(i,N) {\n        REP(j,tup[i].size()) {\n            ld angle; int pos = j, from = i, to; bool flag;\n            tie(angle, to, flag) = tup[i][j];\n            if (flag) continue;\n            vector<int> ps;\n            while (!flag) {\n                ps.push_back(from);\n                get<2>(tup[from][pos]) = true;\n                seg2p[from][to].push_back(polygon.size());\n                seg2p[to][from].push_back(polygon.size());\n                angle += pi + eps;\n                if (angle > pi) angle -= 2 * pi;\n                auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n                if (it == tup[to].end()) it = tup[to].begin();\n                from = to; tie(angle, to, flag) = *it;\n                pos = it - tup[from].begin();\n            }\n            polygon.push_back(ps);\n        }\n    }\n    Graph g(polygon.size());\n    REP(i,N) REP(j,i) {\n        if (seg2p[i][j].size() == 2) {\n            int from = seg2p[i][j][0], to = seg2p[i][j][1];\n            g[from].push_back((Edge){from, to});\n            g[to].push_back((Edge){to, from});\n        }\n    }\n    return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n    fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n    Point v = l.b - l.a;\n    Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n    fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n    int n = p.size();\n    REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n    fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n;\n    while (cin >> n, n) {\n        vector<ll> X(n), Y(n), L(n);\n        REP(i, n) {\n            cin >> X[i] >> Y[i] >> L[i];\n        }\n        auto check = [&](double h) {\n            vector<double> r(n);\n            REP(i, n) {\n                double rr = L[i]*L[i]-h*h;\n                if (rr < 0) return false;\n                r[i] = sqrt(rr);\n            }\n            vector<Circle> c;\n            REP(i, n) {\n                c.pb(Circle(Point(X[i], Y[i]), r[i]));\n            }\n            vector<Point> kh;\n            REP(i, n) kh.pb(c[i].p);\n            REP(i, n) FOR(j, i+1, n) {\n                vector<Point> v = is_cc(c[i], c[j]);\n                EACH(p, v) kh.pb(p);\n            }\n            EACH(p, kh) {\n                bool f = true;\n                REP(i, n) {\n                    if (abs(p-Point(X[i], Y[i])) > r[i]+eps) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return true;\n            }\n            return false;\n        };\n        double l = 0, r = 1000;\n        REP(t, 100) {\n            double m = (l + r) / 2;\n            if (check(m)) l = m;\n            else r = m;\n        }\n        cout << fixed << setprecision(10) << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(const P &a, const P &b) {\n    return !sgn(abs(a-b));\n}\n\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\nint crossCC(const C &c, const C &d, R &l, R &r) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l = 0; r = 2*PI;\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l = bth-th;\n    r = bth+th;\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nconst int MN = 12;\nint n;\nC base[MN];\n\nC c[MN];\nbool calc(R md) {\n    for (int i = 0; i < n; i++) {\n        c[i] = base[i];\n        c[i].r = sqrt(base[i].r*base[i].r - md*md);\n    }\n\n    vector<P> v;\n\n    for (int i = 0; i < n; i++) {\n        v.push_back(c[i].p);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            R l, r;\n            if (crossCC(c[i], c[j], l, r) == 0) continue;\n            v.push_back(c[i].p + polar(c[i].r, l));\n            v.push_back(c[i].p + polar(c[i].r, r));\n        }\n    }\n\n    int res = 0;\n    for (P p: v) {\n        int sm = 0;\n        for (int i = 0; i < n; i++) {\n            if (sgn(abs(c[i].p-p), c[i].r) != -1) sm++;\n        }\n        res = max(res, sm);\n    }\n    return res == n;\n}\n\nbool solve() {\n    cin >> n;\n    if (!n) return false;\n    R r = 400;\n    for (int i = 0; i < n; i++) {\n        R x, y, l;\n        cin >> x >> y >> l;\n        base[i] = C(P(x, y), l);\n        r = min(r, l);\n    }\n\n    r -= 100*EPS;\n    R l = 0;\n    for (int i = 0; i < 100; i++) {\n        R md = (l+r)/2;\n//        printf(\"%.20Lf %d\\n\", md, calc(md));\n        if (calc(md)) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", l);\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n   \nusing namespace std;\n   \n#define EPS 1e-10\n   \nstruct Point {\n    double x, y;\n   \n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n   \n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n       \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n       \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n       \n    Point operator / (const double &k) const {\n        return Point(x / k, y / k);\n    }\n};\n   \nPoint operator * (const Point &a, const Point &b)\n{\n    return Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n   \ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n   \ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n   \ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n   \ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n   \nstruct Circle {\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n   \nbool isIntersectCC(const Circle &a, const Circle &b)\n{\n    double d = abs(a.p - b.p);\n    return (d <= a.r + b.r && d >= abs(a.r - b.r));\n}\n   \nvector<Point> crosspointCC(const Circle &a, const Circle &b)\n{\n    vector<Point> res;\n    double d = abs(a.p - b.p);\n    if (!isIntersectCC(a, b) || d < EPS) {\n        return res;\n    }\n    double rc = (a.r * a.r - b.r * b.r + d * d) / (2.0 * d);\n    if (abs(a.r) - abs(rc) < EPS) {\n        return res;\n    }\n       \n    double rs = sqrt(a.r * a.r - rc * rc);\n    Point p = (b.p - a.p);\n    res.push_back(Point(a.p + p * Point(rc, +rs) / d));\n    res.push_back(Point(a.p + p * Point(rc, -rs) / d));\n    return res;\n}\n   \nbool c(double z, vector<Circle> c)\n{\n    int N = c.size();\n    for (int i = 0; i < N; i++) {\n        if (c[i].r * c[i].r - z * z < 0) return 0; \n        c[i].r = sqrt(c[i].r * c[i].r - z * z);        \n    }\n       \n    vector<Point> cross_point;\n    for (int i = 0; i < N; i++) {\n        cross_point.push_back(c[i].p);\n        for (int j = i+1; j < N; j++) {            \n            vector<Point> cp = crosspointCC(c[i], c[j]);\n            for (int k = 0; k < (int)cp.size(); k++) {\n                cross_point.push_back(cp[k]);\n            }\n        }\n    }\n       \n    for (int i = 0; i < (int)cross_point.size(); i++) {\n        bool poss = 1;\n        for (int j = 0; j < N; j++) {\n            if (dist(cross_point[i], c[j].p) - c[j].r > EPS) {\n                poss = 0;\n                break;\n            }\n        }\n        if (poss) {\n            return 1;\n        }\n    }\n    return 0;\n}\n   \ndouble solve(vector<Circle> &cirs)\n{\n    if (cirs.size() == 1) return cirs[0].r;\n   \n    double l = 0, r = 25252;\n    for (int i = 0; i < 150; i++) {\n        double z = (l + r) / 2;\n        if (c(z, cirs)) {\n            l = z;\n        } else {\n            r = z;\n        }\n    }\n    return l;\n}\n   \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cirs(N);\n        for (int i = 0; i < N; i++) {\n            cin >> cirs[i].p.x >> cirs[i].p.y >> cirs[i].r;\n        }\n        printf(\"%.10f\\n\", solve(cirs));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing xy = pair<double, double>;\nconstexpr xy PARA = xy(-1010101, -2020202);\n\nstruct point {\n  double x, y, z;\n};\n\nstruct line {\n  long x, y, z, l;\n};\n\ndouble dist(point a, point b) {\n  double ret = 0;\n  ret += pow((a.x - b.x), 2);\n  ret += pow((a.y - b.y), 2);\n  ret += pow((a.z - b.z), 2);\n  return sqrt(ret);\n}\n\nbool isReachable(point p, const vector<line>& v) {\n  for (line l: v) {\n    point lp = {double(l.x), double(l.y), double(l.z)};\n    if (dist(lp, p) > l.l + 1e-8) {\n      // cout << \"Unreachable! dist: \" << dist(lp, p) << \", l: \" << l.l << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\ndouble getz(double x, double y, line l) {\n  if (pow(l.l, 2) - pow(x - l.x, 2) - pow(y - l.y, 2) < 0) return 0;\n  return sqrt(pow(l.l, 2) - pow(x - l.x, 2) - pow(y - l.y, 2));\n}\n\n\nxy getcross(double a1, double a2, double b1, double b2, double c1, double c2) {\n  if (abs(a1 * b2 - a2 * b1) < 1e-10) return PARA;\n\n  double x = (b2 * c1 - b1 * c2) / (a1 * b2 - a2 * b1);\n  double y =  -(a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n  return xy(x, y);\n}\n\nvoid solve(long n) {\n  vector<line> v;\n  long x, y, l;\n  for (int i = 0; i < n; i++) {\n    cin >> x >> y >> l;\n    v.push_back({x, y, 0, l});\n  }\n  double ans = -1e18;\n\n  for (int i = 0; i < n; i++) {\n    double z = v[i].l;\n    if (isReachable({double(v[i].x), double(v[i].y), double(z)}, v)) {\n      ans = max(ans, z);\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (v[i].l + v[j].l < dist({double(v[i].x), double(v[i].y), 0}, {double(v[j].x), double(v[j].y), 0})) {\n        continue;\n      }\n      double z;\n      double a = dist({double(v[i].x), double(v[i].y), 0}, {double(v[j].x), double(v[j].y), 0});\n      double k = 0.5 * ((pow(v[i].l, 2) - pow(v[j].l, 2)) / pow(a, 2) + 1);\n      double xx = v[i].x + k * (v[j].x - v[i].x);\n      double yy = v[i].y + k * (v[j].y - v[i].y);\n      z = getz(xx, yy, v[i]);\n      if (isReachable({xx, yy, z}, v)) {\n        ans = max(ans, z);\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      for (int k = j + 1; k < n; k++) {\n        double x1 = v[i].x;\n        double y1 = v[i].y;\n        double x2 = v[j].x;\n        double y2 = v[j].y;\n        double x3 = v[k].x;\n        double y3 = v[k].y;\n        xy xxyy = getcross(2 * (x1 - x2), 2 * (x2 - x3), 2 * (y1 - y2), 2 * (y2 - y3),\n          pow(x1, 2) - pow(x2, 2) + pow(y1, 2) - pow(y2, 2) - pow(v[i].l, 2) + pow(v[j].l, 2),\n          pow(x2, 2) - pow(x3, 2) + pow(y2, 2) - pow(y3, 2) - pow(v[j].l, 2) + pow(v[k].l, 2)\n        );\n        if (xxyy == PARA) continue;\n        double xx = xxyy.first;\n        double yy = xxyy.second;\n        double z = getz(xx, yy, v[i]);\n        // cout << \"hoge\" << endl;\n        // cout << xx << \" \" << yy << \" \" << z << endl;\n        if (isReachable({xx, yy, z}, v)) {\n          ans = max(ans, z);\n        }\n      }\n    }\n  }\n\n  printf(\"%.8f\\n\", ans);\n}\n\nint main() {\n  long n;\n  while (1) {\n    cin >> n;\n    if (n == 0) return 0;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\tif (isnan(c)) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\tif (isnan(z)) {\n\t\t\t\tint h = 0;\n\t\t\t}\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\tsort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcout << fixed << setprecision(10) << x[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS (1e-8)\n#define x p.real()\n#define y p.imag()\nusing namespace std;\ntypedef complex <double> point;\nstruct po{\n  point p;\n  double l;\n  po(){x=y=l=0;};\n  po(double a,double b,double c){x=a,y=b,l=c;}\n  po(point a,double b){p=a,l=b;}\n};\nint n;\npo bal[10];\ndouble Abs(po a){return (a.x*a.x+a.y*a.y+a.l*a.l);}\n\npo get_po(po a,po b){\n  if(a.l>b.l) swap(a,b);\n  double D=Abs(po(a.p-b.p,0));\n  if(a.l*a.l+D<=b.l*b.l)return a;\n  \n  double t=(a.l*a.l+D-b.l*b.l)/(2*sqrt(D));\n  point vec=b.p-a.p;\n  vec=(vec/abs(vec))*t+a.p;\n  return po(vec,sqrt(a.l*a.l-t*t));\n}\n\npo BinarySearch(double l,po b){\n  double L=0,Y,R=l,h;\n  int cnt=100;\n  while(cnt--){\n    Y=(L+R)/2;\n    h=sqrt(l*l-Y*Y);\n    if(Abs(po(b.x,Y-b.y,h))-b.l*b.l<=EPS) R=Y;\n    else L=Y;\n  }\n  return po(0,Y,h-EPS);\n}\n\nbool check(po a){\n  for(int i=0;i<n;i++)\n    if(Abs(po(a.p-bal[i].p,a.l))-bal[i].l*bal[i].l>EPS)return 0;\n  return 1;\n}\n\ndouble solve(){\n  if(n==1)return bal[0].l;\n  double res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      po a=get_po(bal[i],bal[j]);\n      for(int k=0;k<n;k++){\n\tpoint p=bal[i].p-a.p,q=bal[k].p-a.p;\n\tq=q*conj(p)/abs(p);\n\tpo b=BinarySearch(a.l,po(q,bal[k].l));\n\tb.p=b.p*p/abs(p)+a.p;\n\tif(check(b)) res=max(res,b.l);\n      }\n    }\n  return res;\n}\n\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>bal[i].x>>bal[i].y>>bal[i].l;\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\n\n// ???????????????????¨±??????????????????????????????????????¨????????????????¨???????????????????\nvector<Point> intersectionOfCC(Circle A, Circle B)\n{\n  vector<Point> ret;\n  double d = abs(A.center() - B.center());\n  double rc = (d * d + A.radius() * A.radius() - B.radius() * B.radius()) / (2.0 * d);\n  double rs = sqrt(A.radius() * A.radius() - rc * rc);\n  Point diff = (B.center() - A.center()) / d;\n  ret.pb(A.center() + diff * Point(rc,  rs));\n  ret.pb(A.center() + diff * Point(rc, -rs));\n  return ret;\n}\n\nint intersectionDeterminationOfCC(Circle A, Circle B)\n{\n  double d = abs(A.center() - B.center());\n  if(semile(d, A.radius() - B.radius())) return  1;  // B in A\n  if(semile(d, B.radius() - A.radius())) return -1;  // A in B\n  if(semieq(d, A.radius() - B.radius())) return  2;  // B in A????????\\???\n  if(semieq(d, B.radius() - A.radius())) return -2;  // A in B????????\\???\n  if(semieq(d, A.radius() + B.radius())) return  3;  // ?????\\\n  if(semige(d, A.radius() + B.radius())) return -3;  // ???????????????\n  return 4;  // ????????£?????????\n}\n\ninline bool operator < (Circle& A, Circle& B)\n{\n  return A.radius() != B.radius() ? A.radius() < B.radius() : A.center() < B.center();\n}\n\nconst int MAX_N = 12;\nint n;\ndouble x, y;\ndouble l[MAX_N];\nPoint p[MAX_N];\n\nbool C(double x)\n{\n  vector<Circle> c;\n  rep(i, n) c.pb(Circle(p[i], sqrt(l[i] * l[i] - x * x)));  rep(i, c.size()) rep(j, i){\n    Circle A = c[i];\n    Circle B = c[j];\n    int det = intersectionDeterminationOfCC(A, B);\n    if(det < 3) continue;\n    vector<Point> vp = intersectionOfCC(A, B);\n    vrep(v, vp){\n      bool ok = true;\n      vrep(w, c) ok &= !semige(abs(*v - w->center()), w->radius());\n      if(ok) return true;\n    }\n  }\n\n  sort(ALL(c));\n  bool ok = true;\n  rep(i, n-1){\n      int det = intersectionDeterminationOfCC(c[i], c[i+1]);\n      ok &= (det == -1 || det == -2);\n  }\n  if(ok) return true;\n\n\n  vrep(v, c){\n    bool ok = true;\n    vrep(w, c) if(v != w) ok &= !semige(abs(v->center() - w->center()), w->radius());\n    if(ok) return true;\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin >> n, n){\n    double mn = (double)INF;\n    rep(i, n){\n      cin >> x >> y >> l[i];\n      p[i] = Point(x, y);\n      minup(mn, l[i]);\n    }\n\n    double left = 1.0;\n    double right = mn;\n    rep(_, 100){\n      double mid = (left + right) / 2.0;\n      if(C(mid)) left = mid;\n      else right = mid;\n    }\n\n    printf(\"%.15f\\n\", right);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool is_intersect(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心に回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る半径rの円の中心座標\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//線分と点の距離\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(is_intersect(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分間の距離\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(is_intersect(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n//多角形内部に点pがあるか\nbool contains(vector<P> &poly,P p){\n\tint f=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\tdouble d=(p-poly[i]).det(poly[i]-poly[(i+1)%poly.size()]);\n\t\tif(d<0)f|=1;\n\t\telse if(d>0)f|=2;\n\t}\n\treturn f==(f&-f);\n}\n\n\nint main(){\n\tint n;\n\tdouble x[10],y[10],h[10],r[10];\n\twhile(cin>>n&&n){\n\t\tdouble lo=1,hi=300;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>h[i];\n\t\t\thi=min(hi,h[i]);\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"%f\\n\",h[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tdouble mi=(lo+hi)/2;\n\t\t\tbool ok=false;\n\t\t\tvector<P> v;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tr[j]=sqrt(h[j]*h[j]-mi*mi);\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tpair<P,P> pp=circle_intersection(x[j],y[j],r[j],x[k],y[k],r[k]);\n\t\t\t\t\tv.push_back(pp.first);\n\t\t\t\t\tv.push_back(pp.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<v.size()&&!ok;j++){\n\t\t\t\tint c=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif((x[k]-v[j].x)*(x[k]-v[j].x)+(y[k]-v[j].y)*(y[k]-v[j].y)\n\t\t\t\t\t\t< (r[k]+EPS)*(r[k]+EPS))c++;\n\t\t\t\t}\n\t\t\t\tif(c==n)ok=true;\n\t\t\t}\n\t\t\tif(ok)lo=mi;\n\t\t\telse hi=mi;\n\t\t}\n\t\tprintf(\"%.5f\\n\",hi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(j, n) {\n\t\t\tint i = mina;\n\t\t\tif ((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]) + bl[i][2] * bl[i][2] > bl[j][2] * bl[j][2]) {\n\t\t\t\tans = 1e9;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\tif (z < 0 || a <= 0 || a >= l)continue;\n\t\t\tif (z >= ans)continue;\n\t\t\tans = z;\n\t\t\t//h.push_back({ x,y,z });\n\t\t}\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {double(bl[i][0] - bl[j][0]),double(bl[i][1] - bl[j][1]),double(-bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1])},{ double(bl[i][0] - bl[k][0]),double(bl[i][1] - bl[k][1]),double(-bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1]) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0) {\n\t\t\t\tif (x[0][1] == 0)continue;\n\t\t\t\tif (x[1][0] - (x[1][1] / x[0][1])*x[0][0] == 0)continue;\n\t\t\t\ta = (x[1][2] - x[1][1] / x[0][1] * x[0][2]) / (x[1][0] - (x[1][1] / x[0][1])*x[0][0])*0.5;\n\t\t\t\tb = (x[0][2] - 2 * a*x[0][0]) *0.5 / x[0][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0])*0.5;\n\t\t\t\tb = (x[1][2] - 2 * a*x[1][0]) *0.5 / x[1][1];\n\t\t\t}\n\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\tif (c < 0)continue;\n\t\t\tif (c >= ans)continue;\n\t\t\tint cc = ccw(P(bl[i][0],bl[i][1]), P(bl[j][0],bl[j][1]), P(a,b));\n\t\t\tif (cc == ccw(P(bl[j][0],bl[j][1]), P(bl[k][0],bl[k][1]), P(a,b)) && cc == ccw(P(bl[k][0],bl[k][1]), P(bl[i][0],bl[i][1]), P(a,b)))ans = c;\n\t\t\t//h.push_back({ a,b,c });\n\t\t\t/*bool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif ((a - bl[i][0])*(a - bl[i][0]) + (b - bl[i][1])*(b - bl[i][1]) + c > bl[i][2]* bl[i][2] + 1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, sqrt(c));\n\t\t\t}*/\n\t\t}\n\t\tvolatile int a=0;\n\t\trep(i, 500000)a++;\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\t/*double ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t}\n\t\t}*/\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double Real;\ntypedef complex<Real> Point;\ntypedef vector<Point> Polygon;\nstruct Line {\n\tLine(){}\n\tLine(Point p, Point q): p(p), q(q){}\n\tPoint p, q;\n};\ntypedef Line Segment;\nstruct Circle {\n\tCircle(){}\n\tCircle(Point p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\n#define X real\n#define Y imag\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-12;\n\ninline int sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\treturn a < 0.0 ? -1 : 1;\n}\n\ninline bool eq(Real a, Real b){ return sgn(a - b) == 0; }\ninline bool neq(Real a, Real b){ return sgn(a - b) != 0; }\ninline bool lt(Real a, Real b){ return sgn(a - b) == -1; }\ninline bool leq(Real a, Real b){ return sgn(a - b) <= 0; }\ninline bool gt(Real a, Real b){ return sgn(a - b) == 1; }\ninline bool geq(Real a, Real b){ return sgn(a - b) >= 0; }\n\nReal sq(Real a){ return a * a; }\n\nReal dot(Point a, Point b){ return X(conj(a) * b); }\nReal cross(Point a, Point b){ return Y(conj(a) * b); }\n\nbool orthogonal(Line l, Line m){\n\treturn sgn(dot(l.q - l.p, m.q - m.p)) == 0;\n}\n\nbool parallel(Line l, Line m){\n\treturn sgn(cross(l.q - l.p, m.q - m.p)) == 0;\n}\n\nPoint project(Line l, Point p){\n\tPoint t = l.q - l.p;\n\tReal r = dot(p - l.p, t) / norm(t);\n\treturn l.p + t * r;\n}\n\nPoint reflect(Line l, Point p){\n\treturn p + (project(l, p) - p) * Real(2.0);\n}\n\nint ccw(Point a, Point b, Point c){\n\tPoint u = b - a, v = c - a;\n\tif (sgn(cross(u, v)) == 1) return 1;\t\t// ccw\n\tif (sgn(cross(u, v)) == -1) return -1;\t// cw\n\tif (sgn(dot(a, b)) == -1) return 2;\t\t\t// back\n\tif (lt(norm(a), norm(b))) return -2;\t\t// front\n\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// on\n}\n\nbool intersectLL(Line l, Line m){\n\tif (!parallel(l, m)) return true;\n\treturn parallel(l, Line(l.p, m.p));\n}\n\nbool intersectLS(Line l, Segment s){\n\treturn sgn(cross(l.q - l.p, s.p - l.p)) * sgn(cross(l.q - l.p, s.q - l.p)) <= 0;\n}\n\nbool intersectLP(Line l, Point p){\n\treturn parallel(l, Line(l.p, p));\n}\n\nbool intersectSS(Segment s, Segment t){\n\treturn ccw(s.p, s.q, t.p) * ccw(s.p, s.q, t.q) <= 0\n\t\t&& ccw(t.p, t.q, s.p) * ccw(t.p, t.q, s.q) <= 0;\n}\n\nReal distanceLP(Line l, Point p){\n\treturn abs(cross(l.q - l.p, p - l.p) / abs(l.q - l.p));\n}\n\nReal distanceLL(Line l, Line m){\n\tif (intersectLL(l, m)) return 0.0;\n\treturn distanceLP(l, m.p);\n}\n\nReal distanceLS(Line l, Segment s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.p), distanceLP(l, s.q));\n}\n\nReal distanceSP(Segment s, Point p){\n\tif (sgn(dot(s.q - s.p, p - s.p)) <= 0) return abs(p - s.p);\n\tif (sgn(dot(s.p - s.q, p - s.q)) <= 0) return abs(p - s.q);\n\treturn distanceLP(s, p);\n}\n\nReal distanceSS(Segment s, Segment t){\n\tif (intersectSS(s, t)) return 0.0;\n\treturn min(\n\t\tmin(distanceSP(s, t.p), distanceSP(s, t.q)),\n\t\tmin(distanceSP(t, s.p), distanceSP(t, s.q))\n\t);\n}\n\nbool intersectCL(Circle c, Line l){\n\treturn leq(distanceLP(l, c.p), c.r);\n}\n\nbool intersectCS(Circle c, Segment s){\n\treturn leq(distanceSP(s, c.p), c.r);\n}\n\nbool intersectCP(Circle c, Point p){\n\treturn leq(norm(c.p - p), sq(c.r));\n}\n\nbool intersectCC(Circle c, Circle d){\n\treturn leq(norm(c.p - d.p), sq(c.r + d.r));\n}\n\npair<Point, Point> crossPointsCL(Circle c, Line l){\n\tPoint pr = project(l, c.p);\n\tPoint e = (l.q - l.p) / abs(l.q - l.p);\n\tReal t = sqrt(sq(c.r) - norm(pr - c.r));\n\treturn make_pair(pr + e * t, pr - e * t);\n}\n\npair<Point, Point> crossPointsCC(Circle c, Circle d){\n\tReal ds = abs(d.p - c.p);\n\tReal a = acos((sq(c.r) + sq(ds) - sq(d.r)) / (2 * c.r * ds));\n\tReal t = arg(d.p - c.p);\n\treturn make_pair(c.p + polar(c.r, t + a), c.p + polar(c.r, t - a));\n}\n\nbool contains(Circle c, Circle d){ // d in c\n\treturn leq(c.r + abs(c.p - d.p), d.r);\n}\n\nint n;\nReal x[10], y[10], l[10];\n\nbool ok(Real h)\n{\n\tCircle c[10];\n\tfor (int i = 0; i < n; i++){\n\t\tReal r = sqrt(sq(l[i]) - sq(h));\n\t\tc[i] = Circle(Point(x[i], y[i]), r);\n\t}\n\n\tvector<Point> cps;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (!intersectCC(c[i], c[j])) return false;\n\t\t\tif (contains(c[i], c[j])) continue;\n\t\t\tif (contains(c[j], c[i])) continue;\n\t\t\tauto cp = crossPointsCC(c[i], c[j]);\n\t\t\tcps.push_back(cp.first);\n\t\t\tcps.push_back(cp.second);\n\t\t}\n\t}\n\t\n\tif (cps.empty()) return true;\n\n\tfor (auto cp : cps){\n\t\tbool f = true;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (!intersectCP(c[i], cp)) f = false;\n\t\t}\n\t\tif (f) return true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> l[i];\n\t\t}\n\t\tReal lb = 0.0, ub = *min_element(l, l + n);\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tReal md = (lb + ub) / 2;\n\t\t\t(ok(md) ? lb : ub) = md;\n\t\t}\n\t\tcout << fixed << setprecision(20) << lb << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing ll = long long;\nusing pii = pair<int,int>;\n\ntemplate<typename T> ostream& operator<< (ostream& os,const vector<T>& vec){ os << \"{\"; for(T v:vec) os << v << \",\"; os << \"}\"; }\ntemplate<typename T> ostream& operator<< (ostream& os,const set<T>& st){ os << \"{\"; for(T v:st) os << v << \",\"; os << \"}\"; }\ntemplate<typename T,typename U> ostream& operator<< (ostream& os,const pair<T,U>& p){ os << \"{\" << p.first << \",\" << p.second << \"}\"; return os; }\n\nint n;\nvector<double> x,y,l;\n\n\nvoid solve(){\n    x.assign(n,0);\n    y.assign(n,0);\n    l.assign(n,0);\n    rep(i,n) cin >> x[i] >> y[i] >> l[i];\n\n    double L,U;\n    L = 1;\n    U = 301;\n    rep(poi,100){\n        double h = (L+U)/2;\n        bool h_is_ok = true;\n        rep(i,n) if(l[i] < h){\n            h_is_ok = false;\n            break;\n        }\n        if(!h_is_ok){\n            U = h;\n            continue;\n        }\n\n        bool ok=true;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                double r1,r2;\n                r1 = sqrt(l[i]*l[i]-h*h);\n                r2 = sqrt(l[j]*l[j]-h*h);\n\n                double d = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n                if(d>r1+r2){\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok) break;\n        }\n\n        if(ok){\n            L = h;\n        }else{\n            U = h;\n        }\n    }\n    printf(\"%.20f\\n\",L);\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nbool is_in(Circle c, Point p)\n{\n\tld dist = abs(c.p - p);\n\treturn c.r - dist > -EPS;\n}\n\ntypedef pair<Point, ld> Data;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<Data> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y, l;\n\t\t\tcin >> x >> y >> l;\n\t\t\tv.emplace_back(Point(x, y), l);\n\t\t}\n\t\tld lb = 0, ub = INF;\n\t\tREP(loop, 200)\n\t\t{\n\t\t\tld height = (lb + ub) / 2.0;\n\t\t\tvector<Circle> vc;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tld r = sqrt((v[i].second * v[i].second) - height*height);\n\t\t\t\tvc.emplace_back(v[i].first, r);\n\t\t\t}\n\t\t\tvector<Point> ps;\n\t\t\tREP(i, n) ps.emplace_back(vc[i].p);\n\t\t\tREP(i, n)REP(j, i)\n\t\t\t{\n\t\t\t\tif (isis_cc(vc[i], vc[j]))\n\t\t\t\t{\n\t\t\t\t\tvector<Point> tmp = is_cc(vc[i], vc[j]);\n\t\t\t\t\tfor (auto k : tmp) ps.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = false;\n\t\t\tREP(i, ps.size())\n\t\t\t{\n\t\t\t\tbool ff = true;\n\t\t\t\tREP(j, vc.size())\n\t\t\t\t{\n\t\t\t\t\tif (!is_in(vc[j], ps[i])) ff = false;\n\t\t\t\t}\n\t\t\t\tif (ff) f = true;\n\t\t\t}\n\t\t\tif (f) lb = height;\n\t\t\telse ub = height;\n\t\t}\n\t\tcout << D10 << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n// solve //\nvector<C> in;\nvoid init(){\n  in.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C{P{x,y},r});\n  }\n  return true;\n}\nbool judge2(P p,double m){\n  for(int i=0;i<in.size();i++){\n    double dist = abs(in[i].p - p);\n    if(dist - EPS > in[i].R(m)){\n      return false;\n    }\n  }\n  return true;\n}\nbool judge(double m){\n  //cerr<<\"judge::\"<<m<<\" \";\n  for(int i=0;i<in.size();i++){\n    if(m>=in[i].r)return false;\n  }\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist>in[i].R(m)+in[j].R(m)){\n        return false;\n      }\n    }\n  }\n  if(in.size()==1)return true;\n  //cerr<<\" val \";\n  bool hoge = true;\n  for(int i=0;i<in.size();i++){\n    for(int j=0;j<in.size();j++){\n      const double dist = abs(in[i].p-in[j].p);\n      if(dist+in[i].R(m)<=in[j].R(m)+EPS)continue;\n      if(dist+in[j].R(m)<=in[i].R(m)+EPS)continue;\n      hoge = false;\n      pair<P,P> p = circle_circle_intersect(in[i].p,in[i].R(m),in[j].p,in[j].R(m));\n      if(judge2(p.first,m))return true;\n      if(judge2(p.second,m))return true;\n    }\n  }\n  return hoge;\n}\n\ndouble req(double l,double r){\n  double m = (l+r)/2;\n  if(abs(l-r)<EPS)return r;\n  if(judge(m)){\n    //cerr<<\"true\"<<endl;\n    return req(m,r);\n  }else{\n    //cerr<<\"false\"<<endl;\n    return req(l,m);\n  }\n}\n\ndouble solve(){\n  double ans = req(0.5,301.0);\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<complex>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int INF = 1000000000;\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\n\nclass Line{\n\tpublic:\n\tdouble A,B,C;\n\tLine(double A,double B,double C):A(A),B(B),C(C){}\n\tLine(){}\n};\nclass Circle : public Point{\n\tpublic:\n\tdouble R;\n\tCircle(Point pt, double R):Point(pt),R(R){}\n\tCircle(){}\n};\n\n\ndouble Dot(Point p1, Point p2){return p1.X*p2.X + p1.Y*p2.Y;}\ndouble Cross(Point p1, Point p2){return p1.X*p2.Y - p1.Y*p2.X;}\n\nbool ccw(Point p1, Point p2, Point p3){return  Cross(p2-p1, p3-p1)>=0;}\n\npair<Point,Point> Suisen(Line line, Point pt){\n\tPoint v(line.A, line.B);  v/=Point(abs(v),0);\n\tPoint toPoint;\n\t\n\tif(line.B!=0){\n\t\tPoint slide = pt-Point(0, -line.C/line.B);\n\t\ttoPoint = v*Point(Dot(v,slide),0);\n\t}else{\n\t\ttoPoint = Point(pt.X + line.C/line.A, 0);\n\t}\n\treturn pair<Point,Point>(pt-toPoint, toPoint); //場所と方向\n}\nbool CircleHit(Circle a, Circle b){return abs(a-b) <= a.R + b.R;}\nLine CircleCommonLine(Circle a,Circle b){\n\tdouble C = pow(b.R, 2)-pow(a.R, 2)+norm(a)-norm(b);\n\treturn Line(2*(b.X-a.X), 2*(b.Y-a.Y), C);\n}\npair<Point,Point> CircleCross(Circle a, Circle b){\n\tLine commonLine = CircleCommonLine(a,b);\n\tpair<Point,Point> s = Suisen(commonLine, a);\n\t\n\tdouble d = abs(s.second);\n\tif(d!=0){\n\t\tPoint e = s.second*Point(0,1)/d;\n\t\tif(a.R<d)d=a.R;\n\t\tdouble dist = sqrt(a.R*a.R - d*d);\n\t\treturn pair<Point,Point>(s.first+e*Point(dist,0), s.first+e*Point(-dist,0));\n\t}\n\treturn pair<Point,Point>(s.first-Point(0,a.R), s.first+Point(0,a.R));\n}\n\n\nconst int N = 11;\n\nint n;\nCircle cir[N];\nCircle cirnext[N];\n\nbool checknext(){\n\tvector<Point> pt;\n\trep(i,n)pt.push_back(cirnext[i]);\n\t/*\n\trep(i,n){\n\t\tcout<<cirnext[i]<<cirnext[i].R<<\" \";\n\t}puts(\"\");\n\t*/\n\trep(i,n){\n\t\treps(j,i+1,n){\n\t\t\tif(!CircleHit(cirnext[i],cirnext[j]))continue;\n\t\t\tpair<Point,Point> cross = CircleCross(cirnext[i],cirnext[j]);\n\t\t\tpt.push_back(cross.first);\n\t\t\tpt.push_back(cross.second);\n\t\t}\n\t}\n\t\n\tconst double EPS_IN = 0.00000001;\n\tbool has = false;\n\trep(i,pt.size()){\n\t\tbool ok = true;\n\t\trep(j,n){\n\t\t\tif(abs(pt[i]-cirnext[j]) > cirnext[j].R+EPS_IN)ok=false;\n\t\t}\n\t\tif(ok)has=true;\n\t}\n\t\n\treturn has;\n}\n\nbool check(double val){\n\tbool ret = true;\n\trep(i,n){\n\t\tif(val>cir[i].R)return false;\n\t\tdouble theta = asin(val/cir[i].R);\n\t\tdouble len = cir[i].R * cos(theta);\n\t\tcirnext[i]=Circle(cir[i], len);\n\t}\n\tret &= checknext();\n\treturn ret;\n}\n\n\ndouble solve(){\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcir[i] = Circle(Point(a,b),c);\n\t}\n\t\n\tdouble left = 0;\n\tdouble right = INF;\n\tconst double EPS_BS = 0.0000001;\n\t\n\twhile(1){\n\t\tdouble half = (left+right)/2;\n\t\t\n\t\tif(check(half)){\n\t\t\tleft = half;\n\t\t}else{\n\t\t\tright = half;\n\t\t}\n\t\tif(left+EPS_BS>right)break;\n\t}\n\t\n\treturn left;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include <set>\nconstexpr double EPSILON = 1e-9;\nstruct Coordinate {\n\tdouble x, y;\n\tdouble distance(const Coordinate that) const;\n};\nstruct Angle {\n\tdouble sin, cos;\n\tAngle operator-() const;\n\tstatic Angle from_cos(const double cos);\n};\nstruct Vector {\n\tdouble dx, dy;\n\tVector rotate(const Angle angle) const;\n\tdouble length() const;\n};\nVector operator*(const Vector vec, const double scala);\nVector operator*(const double scala, const Vector vec);\nVector operator-(const Coordinate to, const Coordinate from);\nCoordinate operator+(const Coordinate coord, const Vector vec);\nCoordinate operator+(const Vector vec, const Coordinate coord);\nstruct Circle {\n\tCoordinate center;\n\tdouble radius;\n\tbool contains(const Coordinate that) const;\n\tstd::vector<Coordinate> cross_points(const Circle that) const;\n};\nstruct Anchor {\n\tdouble x, y, length;\n\tCircle slice(double height) const;\n};\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<Anchor> anchors(n); for (auto& a : anchors) std::cin >> a.x >> a.y >> a.length;\n\t\tif (n == 1) {\n\t\t\tstd::cout << std::setprecision(15) << std::fixed << anchors.front().length << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble min = 0;\n\t\tdouble max = std::min_element(anchors.begin(), anchors.end(), [](const Anchor a, const Anchor b) {return a.length < b.length; })->length;\n\t\tstd::vector<Circle> circles(n);\n\t\tfor (auto i = 0; i < 60; ++i) {\n\t\t\tconst auto mid = (min + max) / 2;\n\t\t\tstd::transform(anchors.begin(), anchors.end(), circles.begin(), [mid](const Anchor a) {return a.slice(mid); });\n\t\t\tbool has_intersection = false;\n\t\t\tfor (auto i = 0; i < n && !has_intersection; ++i) {\n\t\t\t\tfor (auto j = 0; j < i && !has_intersection; ++j) {\n\t\t\t\t\tfor (const auto coordinate : circles[i].cross_points(circles[j])) {\n\t\t\t\t\t\thas_intersection = true;\n\t\t\t\t\t\tfor (auto k = 0; k < n; ++k) if (i != k && j != k) {\n\t\t\t\t\t\t\tif (!circles[k].contains(coordinate)) {\n\t\t\t\t\t\t\t\thas_intersection = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (has_intersection) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (has_intersection) continue;\n\t\t\t\thas_intersection = true;\n\t\t\t\tfor (auto j = 0; j < n && has_intersection; ++j) {\n\t\t\t\t\thas_intersection = i == j || circles[j].contains(circles[i].center);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_intersection) min = mid;\n\t\t\telse max = mid;\n\t\t}\n\t\tstd::cout << std::setprecision(15) << std::fixed << max << std::endl;\n\t}\n}\n\n\nbool Circle::contains(const Coordinate that) const\n{\n\treturn center.distance(that) <= radius + EPSILON;\n}\n\nstd::vector<Coordinate> Circle::cross_points(const Circle that) const\n{\n\tconst auto dist = center.distance(that.center);\n\tif (dist > radius + that.radius + EPSILON) return std::vector<Coordinate>{};\n\tconst auto cos = (radius * radius + dist * dist - that.radius * that.radius) / (2 * radius * dist);\n\tconst auto angle = Angle::from_cos(cos);\n\tconst auto vec = (that.center - center) * (radius / dist);\n\treturn std::vector<Coordinate>{vec.rotate(angle) + center, vec.rotate(-angle) + center};\n}\n\nVector Vector::rotate(const Angle angle) const\n{\n\treturn Vector{ dx * angle.cos - dy * angle.sin, dy * angle.cos + dx * angle.sin };\n}\n\ndouble Vector::length() const\n{\n\treturn std::sqrt(dx * dx + dy * dy);\n}\n\nAngle Angle::operator-() const\n{\n\treturn Angle{ -sin, cos };\n}\n\nAngle Angle::from_cos(const double cos)\n{\n\treturn Angle{ std::sqrt(1 - cos * cos), cos };\n}\n\nVector operator*(const Vector vec, const double scala)\n{\n\treturn Vector{ vec.dx * scala, vec.dy * scala };\n}\n\nVector operator*(const double scala, const Vector vec)\n{\n\treturn Vector{ scala * vec.dx, scala * vec.dy };\n}\n\nVector operator-(const Coordinate to, const Coordinate from)\n{\n\treturn Vector{ to.x - from.x, to.y - from.y };\n}\nCoordinate operator+(const Coordinate coord, const Vector vec)\n{\n\treturn Coordinate{ coord.x + vec.dx, coord.y + vec.dy };\n}\n\nCoordinate operator+(const Vector vec, const Coordinate coord)\n{\n\treturn Coordinate{ vec.dx + coord.x, vec.dy + coord.y };\n}\n\ndouble Coordinate::distance(const Coordinate that) const\n{\n\treturn (*this - that).length();\n}\n\nCircle Anchor::slice(double height) const\n{\n\tconst auto radius = std::sqrt(length * length - height * height);\n\treturn Circle{ Coordinate{x, y}, radius };\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n\n        vector<complex<double>> P(n);\n        vector<double> L(n);\n        for (int i = 0; i < n; ++i) {\n            double x, y; cin >> x >> y;\n            P[i] = {x, y};\n            cin >> L[i];\n        }\n\n        auto f = [&](double y, double x) {\n            double ret = numeric_limits<double>::max();\n            complex<double> p = {x, y};\n            for (int i = 0; i < n; ++i) {\n                chmin(ret, L[i]*L[i] - norm(p - P[i]));\n            }\n            return ret;\n        };\n\n        auto fx = [&](double x) {\n            double lb = -100, ub = 100;\n            while (abs(lb - ub) > 1e-9) {\n                double m1 = (2*lb+ub)/3,\n                       m2 = (lb+2*ub)/3;\n\n                if (f(m1, x) < f(m2, x)) {\n                    lb = m1;\n                } else {\n                    ub = m2;\n                }\n            }\n            return f(lb, x);\n        };\n\n        double lb = -100, ub = 100;\n        while (abs(lb - ub) > 1e-9) {\n            double m1 = (2*lb+ub)/3,\n                   m2 = (lb+2*ub)/3;\n\n            if (fx(m1) < fx(m2)) {\n                lb = m1;\n            } else {\n                ub = m2;\n            }\n        }\n\n        cout << sqrt(fx(lb)) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x, y) ((x) - (y) <= -EPS)\n#define EQ(x, y) (abs((x)-(y)) < EPS)\n#define LE(x, y) ((x) - (y) < +EPS)\n\nvector<P> cross_circles(P c1, double r1, P c2, double r2){\n    double d=abs(c2-c1);\n    if ( LT(r1+r2, d) || LT(d, fabs(r1-r2)) )\n    return vector<P>();\n    double l = 0.5* ( (r1*r1-r2*r2)/d+d);\n    double h = sqrt(r1*r1-l*l);\n    vector<P> ret(2);\n    ret[0]=P(l,+h)*(c2-c1)/d+c1;\n    ret[1]=P(l,-h)*(c2-c1)/d+c1;\n    return ret;\n}\n\nstruct rope{\n\tint x,y,l;\n\trope(int x,int y,int l):x(x),y(y),l(l){}\n\tbool operator<(const rope& other)const{\n\t\treturn l<other.l;\n\t}\n};\n\ndouble dist(P p1, P p2){\n\treturn abs(p1-p2);\n\t//double dx=p1.real()-p2.real();\n\t//double dy=p1.imag()-p2.imag();\n\t//return sqrt(dx*dx+dy*dy);\n}\n\ndouble get_height(vector<rope> ropes){\n\tsort(ALL(ropes));\n\tdouble lb=0,ub=1000;\n\tREP(c,100){\n\t\tdouble mid=(lb+ub)/2;\n\t\tvector<double> r;\n\t\tbool ok=true;\n\t\tREP(i,ropes.size()){\n\t\t\tdouble r_square=ropes[i].l*ropes[i].l-mid*mid;\n\t\t\tif(LE(r_square,0)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr.push_back(sqrt(ropes[i].l*ropes[i].l-mid*mid));\n\t\t}\n\t\tif(!ok){\n\t\t\tub=mid;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<P> itsc=cross_circles(P(ropes[0].x,ropes[0].y),r[0],P(ropes[1].x,ropes[1].y),r[1]);\n\t\tbool in=LT(dist(P(ropes[0].x,ropes[0].y),P(ropes[1].x,ropes[1].y)),max(r[0],r[1]));\n\t\tif(ropes.size()==2){\n\t\t\tif(itsc.size()||in){\n\t\t\t\tlb=mid;\n\t\t\t}else{\n\t\t\t\tub=mid;\n\t\t\t}\n\t\t}else{\n\t\t\tvector<P> itsc2=cross_circles(P(ropes[0].x,ropes[0].y),r[0],P(ropes[2].x,ropes[2].y),r[2]);\n\t\t\tvector<P> itsc3=cross_circles(P(ropes[2].x,ropes[2].y),r[2],P(ropes[1].x,ropes[1].y),r[1]);\n\t\t\tbool in2=LT(dist(P(ropes[0].x,ropes[0].y),P(ropes[2].x,ropes[2].y)),max(r[0],r[2]));\n\t\t\tbool in3=LT(dist(P(ropes[2].x,ropes[2].y),P(ropes[1].x,ropes[1].y)),max(r[2],r[1]));\n\t\t\tif(in||in2||in3){\n\t\t\t\tlb=mid;\n\t\t\t}else if((itsc.size()||in)&&(itsc2.size()||in2)&&(itsc3.size()||in3)){\n\t\t\t\tbool flag=false;\n\t\t\t\tREP(i,2){\n\t\t\t\t\tif(LT(dist(itsc[i],P(ropes[2].x,ropes[2].y)),r[2])||\n\t\t\t\t\t\tLT(dist(itsc2[i],P(ropes[1].x,ropes[1].y)),r[1])||\n\t\t\t\t\t\tLT(dist(itsc3[i],P(ropes[0].x,ropes[0].y)),r[0])){\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tlb=mid;\n\t\t\t\t}else{\n\t\t\t\t\tub=mid;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tub=mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn LT(1,ub)?ub:INT_MAX;\n}\n\nint main(){\n\tcout.precision(16);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<rope> ropes;\n\t\tREP(i,n){\n\t\t\tint x,y,l;\n\t\t\tcin>>x>>y>>l;\n\t\t\tropes.push_back(rope(x,y,l));\n\t\t}\n\t\tdouble ans=INT_MAX;\n\t\tREP(i,n){\n\t\t\tans=min(ans,(double)ropes[i].l);\n\t\t}\n\t\tREP(bit,1<<n){\n\t\t\tvector<rope> av_ropes;\n\t\t\tREP(i,n){\n\t\t\t\tif(bit&(1<<i)){\n\t\t\t\t\tav_ropes.push_back(ropes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif(av_ropes.size()==2){\n\t\t\t\tans=min(ans,get_height(av_ropes));\n\t\t\t}else if(av_ropes.size()==3){\n\t\t\t\tans=min(ans,get_height(av_ropes));\n\t\t\t}\n\t\t\t//cerr<<ans<<endl;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double ESP = 1e-10;\ndouble add(double x, double y) {\n  if (fabs(x + y) < ESP * (fabs(x) + fabs(y)))\n    return 0;\n  else return x + y;\n}\nstruct P {\n  double x, y;\n  P() {}\n  P(double X, double Y) {\n    x = X, y = Y;\n  }\n  void init(int X, int Y) {\n    x = (double) X, y = (double) Y;\n  }\n  P operator + (P p) {\n    return P(add(x, p.x), add(y, p.y));\n  }\n  P operator - (P p) {\n    return P(add(x, -p.x), add(y, -p.y));\n  }\n  P operator * (double d) {\n    return P(x * d, y * d);\n  }\n  P operator / (double d) {\n    return P(x / d, y / d);\n  }\n  double det(P p) {\n    return add(p.x * x, p.y * y);\n  }\n  double dot(P p) {\n    return add(p.y * x, -p.x * y);\n  }\n  double square() {\n    return add(x * x, y * y);\n  }\n  double size() {\n    return sqrt(square());\n  }\n  P normal() {\n    double s = size();\n    if (s < ESP) return P(0, 0);\n    return P(x / s, y / s);\n  }\n  P vertical() {\n    P t = normal();\n    return P(t.y, -t.x);\n  }\n  void print() {\n    printf(\"P:(%f, %f)\\n\", x, y);\n  }\n};\n\nbool plus(double a) {\n  return a > ESP;\n}\nbool minas(double a) {\n  return a < -ESP;\n}\nbool zero(double a) {\n  return fabs(a) <= ESP;\n}\n\nint n, x[10], y[10], l[10];\nP dir[10];\ndouble r[10];\n\nint cross(int i, int j) {\n  double s = (dir[i] - dir[j]).size();\n  if (!minas(r[i] - s)) return j; // can everywhere in j\n  if (!minas(r[j] - s)) return i; // can everywhere in i\n  if (plus(s - r[i] - r[j])) return -2; // imposible\n  return -1;\n}\n\nbool canClear(P p, int i1, int i2) {\n  //for (int i = 0; i < n; i++) if ((add((p - dir[i]).square(), -r[i] * r[i]))>0.000005&&1.0>add((p - dir[i]).square(), -r[i] * r[i]))printf(\"%f \",(add((p - dir[i]).square(), -r[i] * r[i])));\n  //for (int i = 0; i < n; i++) printf(\"%f \",(add((p - dir[i]).square(), -r[i] * r[i])));\n  //printf(\"\\n\");\n  for (int i = 0; i < n; i++) if (i != i1 && i != i2 && 0.000005 < (add((p - dir[i]).square(), -r[i] * r[i]))) return false;\n  return true;\n}\n\ndouble search(double r1, double r2, double ps, double guess, double halfsize) {\n  if (r1 < guess || r2 < guess) return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n  double t = add(sqrt(r1 * r1 - guess * guess), add(sqrt(r2 * r2 - guess * guess), -ps));\n  //printf(\"%f,%f,%f,%f,%f\\n\",r1,r2,ps,guess,t);\n  if (zero(t)) return guess;\n  if (plus(t)) return search(r1, r2, ps, guess + halfsize, halfsize / 2);\n  return search(r1, r2, ps, guess - halfsize, halfsize / 2);\n}\n\nbool check(double h) {\n  for (int i = 0; i < n; i++) {\n    if (minas((double)l[i] - h)) return false;\n    if (zero((double)l[i] - h)) return false;//r[i] = 0.0;\n    r[i] = sqrt(add((double)l[i] * l[i], -h * h));\n //   printf(\"r[%d]=%f\\n\",i,r[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      int t = cross(i, j);\n      //printf(\"\\nt:%d\\n\",t);\n      if (t == -2){ return false;}\n      if (t == -1) {\n        double l = search(r[i], r[j], (dir[i] - dir[j]).size(), 300.0, 150.0);\n        double l1 = sqrt(r[i] * r[i] - l * l);\n        double l2 = sqrt(r[j] * r[j] - l * l);\n        P ave = (dir[i] * l2 / (l1 + l2) + dir[j] * l1 / (l1 + l2));\n        P d = (dir[i] - dir[j]).vertical() * l;\n        if (canClear(ave + d, i, j)) return true;\n        if (canClear(ave - d, i, j)) return true;\n      }\n      if (t >= 0) {\n        if (canClear(dir[t], -1, -1)) return true;////////////!!!!!!!!!!\n      }\n    }\n  }\n  return false;\n}\n\ndouble getH() {\n  double lb = 1.0, ub = 300.0;\n  while (!zero(ub - lb)) {\n    double ave = (lb + ub) / 2;\n    if (check(ave)) lb = ave;\n    else ub = ave;\n//    printf(\"%f-%f\\n\",lb,ub);\n  }\n  return lb;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d\", &x[i], &y[i], &l[i]);\n    for (int i = 0; i < n; i++) dir[i].init(x[i], y[i]);\n   // printf(\"%d\\n\",(int)check(116.190917));\n    //printf(\"%d\\n\",(int)check(123.016154));\n    if (n == 1) printf(\"%f\\n\", (double)l[0]);\n    else printf(\"%f\\n\", getH());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define EPS 1e-8\n\nstruct node{\n  int x, y, len;\n  double r;\n  inline void cal_radius(double height){ r = sqrt(len * len - height * height); }\n  inline void read(){ scanf(\"%d%d%d\", &x, &y, &len); }\n} nodes[20];\n\nint n;\n\ninline bool intersect(const node &a, const node &b){ return hypot(a.x - b.x, a.y - b.y) < a.r + b.r + EPS; }\ninline double dist(const node &a, const node &b){ return hypot(a.x - b.x, a.y - b.y); }\n\ninline bool check(double height){\n  for(int i = 0; i < n; i++) nodes[i].cal_radius(height);\n  \n  for(int i = 0; i < n; i++)\n  for(int j = i + 1; j < n; j++) \n    if(!intersect(nodes[i], nodes[j])) return false;\n    \n  double left[20], right[20];\n  double maxx = 1000.0, mini = -1000.0, mid;\n  \n  for(int i = 0; i < n; i++) maxx = fmin(maxx, nodes[i].y + nodes[i].r);\n  for(int i = 0; i < n; i++) mini = fmax(mini, nodes[i].y - nodes[i].r);\n  \n  while(mini < maxx){\n    mid = (maxx + mini) * 0.5;\n    \n    for(int i = 0; i < n; i++){\n      double half_chord = sqrt(nodes[i].r * nodes[i].r - (nodes[i].y - mid) * (nodes[i].y - mid));\n      left[i] = nodes[i].x - half_chord;\n      right[i] = nodes[i].x + half_chord;\n    }\n    \n    bool up = false, down = false;\n    for(int i = 0; i < n; i++)\n    for(int j = i + 1; j < n; j++)\n    if(fmax(left[i], left[j]) > fmin(right[i], right[j]) + EPS){\n      double nxty = nodes[i].y + (nodes[j].y - nodes[i].y) * nodes[i].r / dist(nodes[i], nodes[j]);\n      if(nxty > mid) up = true;\n      else down = true;\n    }\n    \n    if(up && down) return false;\n    if(!up && !down) return true;\n    if(up) mini = mid;\n    if(down) maxx = mid;\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d\", &n) == 1 && n){\n    for(int i = 0; i < n; i++) nodes[i].read();\n    \n    double maxx = 1000.0, mini = 0.0, mid;\n    for(int i = 0; i < n; i++) maxx = fmin(maxx, nodes[i].len);\n    \n    while(maxx - mini > EPS){\n      double mid = (maxx + mini) * 0.5;\n      \n      if(check(mid)) mini = mid;\n      else maxx = mid;\n    }\n    \n    printf(\"%.7lf\\n\", maxx);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint x[11],y[11],l[11];\ndouble data[11];\n\ndouble check(double nx,double ny){\n\tfor(int i=0;i<n;i++){\n\t\tdouble xx=(nx-x[i])*(nx-x[i]);\n\t\tdouble yy=(ny-y[i])*(ny-y[i]);\n\t\tdata[i]=(double)l[i]*l[i]-xx-yy;\n\t}\n\tdouble res=data[0];\n\tfor(int i=1;i<n;i++){\n\t\tres=min(res,data[i]);\n\t}\n\treturn res;\n}\n\ndouble check_y(double nx){\n\tdouble l=-100.0,r=100.0;\n\tfor(int i=0;i<100;i++){\n\t\tdouble ly=check(nx,(l*2+r)/3);\n\t\tdouble ry=check(nx,(l+r*2)/3);\n\t\tif(ly<ry)l=(l*2+r)/3;\n\t\telse r=(r*2+l)/3;\n\t}\n\treturn max(check(nx,((l*2+r)/3)),check(nx,((l+r*2)/3)));\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d\",&x[i],&y[i],&l[i]);\n\t\t}\n\t\tdouble l=-100.0,r=100.0;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble lx=check_y((l*2+r)/3);\n\t\t\tdouble rx=check_y((l+r*2)/3);\n\t\t\tif(lx<rx)l=(l*2+r)/3;\n\t\t\telse r=(r*2+l)/3;\n\t\t}\n\t\tprintf(\"%.8f\\n\",sqrt(max(check_y((l*2.0+r)/3.0),check_y((l+r*2.0)/3.0))));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#define inf 1e9\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n  double x, y;\n  vec2d(){}\n  vec2d(double x, double y){\n    this->x = x , this->y = y;\n  }\n  double add(double a, double b){\n    if(fabs(a+b) < eps*(fabs(a)+fabs(b))) return 0.0;\n    return a+b;\n  }\n  vec2d operator+(vec2d ope){\n    return vec2d(add(x, ope.x), add(y, ope.y));\n  }\n  vec2d operator-(vec2d ope){\n    return vec2d(add(x, -ope.x), add(y, -ope.y));\n  }\n  vec2d operator*(double t){\n    return vec2d(x*t, y*t);\n  }\n  vec2d operator/(double t){\n    return vec2d(x/t, y/t);\n  }\n  double dot(vec2d ope){\n    return add(x*ope.x, y*ope.y);\n  }\n  double cross(vec2d ope){\n    return add(x*ope.y, -y*ope.x);\n  }\n  double norm(){\n    double d2 = dot(*this);\n    if(d2 > 0) return sqrt(d2);\n    return 0.0;\n  }\n};\n\nvoid getCrossPointCC(vec2d c1, double r1, vec2d c2, double r2, vec2d &lp, vec2d &rp)\n{\n  vec2d v = c2 - c1, n;\n  double d = v.norm();\n  double x = (r1*r1-r2*r2+d*d)/(2*d);\n\n  v = v * (x/d);\n  n = vec2d(-v.y, v.x);\n  if(x >= 0){\n    n = n * (sqrt(r1*r1-x*x) / n.norm());\n    lp = c1 + v - n, rp = c1 + v + n;\n  }\n  else{\n    n = n * (sqrt(r2*r2-(d-x)*(d-x))) / n.norm();\n    lp = c1 + v + n, rp = c1 + v - n;\n  }\n}\n\ndouble distPP(vec2d p, vec2d q){\n  return (p-q).norm();\n}\n\nint n;\nvec2d p[15];\ndouble h[15], r[15];\nbool used[15];\n\nbool check(double m)\n{\n  for(int i = 1; i <= n; i++){\n    double d = h[i]*h[i] - m*m;\n    if(d < 0) return false;\n    r[i] = sqrt(d);\n  }\n  /*cout << n << endl;\n  for(int i = 1; i <= n; i++){\n    cout << p[i].x << \" \" << p[i].y << \" \" << r[i] << endl;\n  }*/\n\n  for(int i = 1; i <= n; i++) used[i] = false;\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(i == j) continue;\n      if(used[i] || used[j]) continue;\n      if(distPP(p[i], p[j]) + r[j] <= r[i]) used[i] = true;\n    }\n  }\n  int cnt = 0;\n  for(int i = 1; i <= n; i++) if(!used[i]) cnt++;\n  if(cnt == 1) return true;\n\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(i >= j) continue;\n      if(used[i] || used[j]) continue;\n      if(distPP(p[i], p[j]) > r[i] + r[j]) return false;\n      vec2d u, v;\n      getCrossPointCC(p[i], r[i], p[j], r[j], u, v);\n\n      bool flag = true;\n      for(int k = 1; k <= n; k++){\n        if(used[k] || i == k || j == k) continue;\n        if(distPP(u, p[k]) > r[k]) flag = false;\n      }\n      if(flag) return true;\n\n      flag = true;\n      for(int k = 1; k <= n; k++){\n        if(i == k || j == k) continue;\n        if(distPP(v, p[k]) > r[k]) flag = false;\n      }\n      if(flag) return true;\n    }\n  }\n  return false;\n}\n\nint main(void)\n{\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 1; i <= n; i++){\n      cin >> p[i].x >> p[i].y >> h[i];\n    }\n\n    double ub = 1000, lb = 0, mid;\n    for(int i = 0; i < 100; i++){\n      mid = (ub+lb)/2;\n      if(check(mid)) lb = mid;\n      else ub = mid;\n    }\n    printf(\"%.11f\\n\", lb);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\nconst double EPS = 1e-6;\n\ndouble x[11], y[11], l[11];\n\ndouble square(double X) {return X*X;}\n\ndouble calc(int n, double X, double Y) {\n    double ret = 300;\n    for (int i = 0; i < n; i++) {\n        ret = min(ret, /*sqrt*/(square(l[i]) - square(x[i]-X) - square(y[i]-Y)));\n    }\n    return ret;\n}\n\ndouble searchY(int n, double x) {\n    double left = -100, right = 100;\n    for (int t = 0; t < 200; t++) {\n        double m1 = (2*left+right) / 3;\n        double m2 = (left+2*right) / 3;\n        double M1 = calc(n, x, m1);\n        double M2 = calc(n, x, m2);\n        if (M1 > M2) {\n            right = m2;\n        } else {\n            left = m1;\n        }\n    }\n    return calc(n, x, (right+left)/2);\n}\n\ndouble search(int n) {\n    double left = -100, right = 100;\n    for (int t = 0; t < 200; t++) {\n        double m1 = (2*left+right) / 3;\n        double m2 = (left+2*right) / 3;\n        double M1 = searchY(n, m1);\n        double M2 = searchY(n, m2);\n        if (M1 > M2) {\n            right = m2;\n        } else {\n            left = m1;\n        }\n    }\n    return searchY(n, (left+right)/2);\n}\n\nvoid solve(int n) {\n    printf(\"%.15lf\\n\", sqrt(search(n)));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> l[i];\n        }\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n \nusing namespace std;\n \n#define EPS 1e-9\n \nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[11], cP[11],nP[11];\n  \ndouble dis(point &p1,point &p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n} \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n  \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n  \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n \nint n;\ndouble x[11],y[11],r[11];\ndouble cx[11],cy[11];\ndouble sqr(double x) { return x*x; }\n \npoint rot(point p, double a) {\n    point ret;\n    double C = cos(a), S = sin(a);\n    ret.x = p.x*C - p.y*S;\n    ret.y = p.x*S + p.y*C;\n    return ret;\n}\n \ndouble aaa[1111111];\nint cs=0;\n \nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n#endif\n    while(1) {\n        scanf(\"%d\",&n); \n        if(n==0) break;\n        for(int i=0;i<n;++i) scanf(\"%lf%lf%lf\",x+i,y+i,r+i), P[i] = point(x[i],y[i]);\n \n        double ans = -1e20;\n        for(int i=0;i<n;++i) {\n            double tmp = r[i];\n            bool can = 1;\n            for(int j=0;j<n;++j) if(sqr(x[i]-x[j])+sqr(y[i]-y[j])+r[i]*r[i] > r[j]*r[j] + EPS) can = 0;\n            if(can) ans = max(ans, tmp);\n        }\n \n        for(int i=0;i<n;++i) {\n            memcpy(cP,P,sizeof(cP));\n            for(int j=0;j<n;++j) cP[j].x -= P[i].x,cP[j].y -= P[i].y;\n            for(int j=i+1;j<n;++j) if(j!=i) {\n                double d = dis(cP[i],cP[j]);\n                if(r[i]+r[j] < d-EPS) continue;\n                if(abs(r[i]-r[j]) > d+EPS) continue;\n \n                memcpy(nP,cP,sizeof(nP));\n                double a = atan2(cP[j].y,cP[j].x);\n                for(int k=0;k<n;++k) nP[k] = rot(cP[k],-a);\n \n                bool can = 1;\n                point p1,p2;\n                intersection_circle_circle(point(nP[j].x,nP[j].y),r[j],point(nP[i].x,nP[i].y),r[i],p1,p2);\n                double zz = max(p1.y,p2.y), yy = 0;\n                double xx = p1.x;\n                for(int k=0;k<n;++k) if(sqr(nP[k].x-xx)+sqr(nP[k].y-yy)+sqr(zz) > r[k]*r[k] + EPS) can = 0;\n                if(can)\n                    ans = max(ans, zz);\n \n                double rr = zz;\n                for(int k=0;k<n;++k) nP[k].x -= xx;\n                for(int k=j+1;k<n;++k) if(k!=i && k!=j && abs(nP[k].x) <= r[k]+EPS){\n                    double nr = sqrt(sqr(r[k])-sqr(nP[k].x));\n                    double d = abs(nP[k].y);\n                    if(nr+rr < d-EPS) continue;\n                    if(abs(nr-rr) > d+EPS) continue;\n \n                    bool can = 1;\n                    point p1,p2;\n                    intersection_circle_circle(point(0,0),rr,point(nP[k].y,0),nr,p1,p2);\n                    double zz = max(p1.y,p2.y), xx = 0;\n                    double yy = p1.x;\n                    for(int h=0;h<n;++h) if(sqrt(sqr(nP[h].x-xx)+sqr(nP[h].y-yy)+sqr(zz)) > r[h] + EPS) {\n                        can = 0;\n                    }\n                    if(can)\n                        ans = max(ans, zz);\n                }\n            }\n        } printf(\"%.10lf\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // counter clockwise\n    if (cross(b, c) < -eps) return -1; // clockwise\n    if (dot(b, c) < 0) return 2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\nint main() {\n\tint n;\n\tcin.sync_with_stdio(0);\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\t//va<double, 3> h;\n\t\tdouble ans = 1e9;\n\t\tint mina = 0;\n\t\trep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n\t\tans *= ans;\n\t\trep(i, n) {\n\t\t\trep(j, i) {\n\t\t\t\tdouble l = sqrt((bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n\t\t\t\tdouble a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l) / 2;\n\t\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n\t\t\t\tif (z < 0)continue;\n\t\t\t\tif (z<ans&&a > 0 && a < l)ans = z;\n\t\t\t\tdouble x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n\t\t\t\tif (x01 != 0) {\n\t\t\t\t\tdouble rv = 1 / x01;\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble a, b, c;\n\t\t\t\t\t\tif (x11 == 0) {\n\t\t\t\t\t\t\ta = x12*0.5 / x10;\n\t\t\t\t\t\t\tb = (x02*0.5 - a*x10)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdouble rv2 = x10 * x01 - x11*x00;\n\t\t\t\t\t\t\tif (rv2 == 0)continue;\n\t\t\t\t\t\t\trv2 = 1 / (rv2 + rv2);\n\t\t\t\t\t\t\ta = rv2*(x12 * x01 - x11 * x02);\n\t\t\t\t\t\t\tb = (x02 * 0.5 - a*x00)*rv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (isnan(c)) {\n\t\t\t\t\t\t\tint a = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdouble a = x02*0.5 / x00;\n\t\t\t\t\tdouble c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n\t\t\t\t\trep(k, j) {\n\t\t\t\t\t\tdouble x11 = bl[i][1] - bl[k][1];\n\t\t\t\t\t\tif (x11 == 0)continue;\n\t\t\t\t\t\tdouble x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n\t\t\t\t\t\tdouble b = (x12*0.5 - a*x00) / x11, c;\n\t\t\t\t\t\tc = c_ - (b - bl[i][1])*(b - bl[i][1]);\n\t\t\t\t\t\tif (isnan(c)) {\n\t\t\t\t\t\t\tint a = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\t\tif (c >= ans)continue;\n\t\t\t\t\t\tint cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n\t\t\t\t\t\tif (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << sqrt(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\nconst ll mod=1e9+7;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1};\n\n\ndouble dist(double x,double y){\n    return sqrt(x*x+y*y);\n}\nint main(){\n    while(1){\n    int n;\n    cin>>n;\n    if(n==0)return 0;\n    double x[n],y[n],r[n];\n    vector<double> v;\n    rep(i,n){\n        cin>>x[i]>>y[i]>>r[i];\n        v.push_back(r[i]);\n    }\n    double h[n][n],dx[n][n],dy[n][n];\n    rep(i,n)rep(j,n)h[i][j]=0;\n    rep(i,n)REP(j,i+1,n){\n        double z=dist(x[i]-x[j],y[i]-y[j]);\n        if(z*z+min(r[i]*r[i],r[j]*r[j])<max(r[i]*r[i],r[j]*r[j]))continue;\n        double s=sqrt((r[i]+r[j]+z)*(r[i]-r[j]+z)*(r[i]+r[j]-z)*(-r[i]+r[j]+z));\n        h[i][j]=h[j][i]=s/2/z;\n        dx[i][j]=x[i]+sqrt(r[i]*r[i]-h[i][j]*h[i][j])/z*(x[j]-x[i]);\n        dy[i][j]=y[i]+sqrt(r[i]*r[i]-h[i][j]*h[i][j])/z*(y[j]-y[i]);\n        v.push_back(s/2/z);\n    }\n    rep(i,n)r[i]=r[i]*r[i];\n    rep(i,n)REP(j,i+1,n)REP(k,j+1,n){\n        double a=dist(x[i]-x[j],y[i]-y[j]);\n        double b=dist(x[k]-x[j],y[k]-y[j]);\n        double c=dist(x[i]-x[k],y[i]-y[k]);\n        double s=sqrt((a+b+c)*(a-b+c)*(a+b-c)*(-a+b+c));\n        s/=4;\n        a=a*a;b=b*b;c=c*c;\n        if(h[i][j]*h[j][k]*h[k][i]*s==0)continue;\n        if(h[i][j]*h[i][j]+dist(dx[i][j]-x[k],dy[i][j]-y[k])*dist(dx[i][j]-x[k],dy[i][j]-y[k])<r[k])continue;\n        if(h[i][k]*h[i][k]+dist(dx[i][k]-x[j],dy[i][k]-y[j])*dist(dx[i][k]-x[j],dy[i][k]-y[j])<r[j])continue;\n        if(h[k][j]*h[k][j]+dist(dx[k][j]-x[i],dy[k][j]-y[i])*dist(dx[k][j]-x[i],dy[k][j]-y[i])<r[i])continue;\n        double vol=a*r[k]*(-a+b+c+r[i]+r[j]-r[k])+b*r[i]*(a-b+c-r[i]+r[j]+r[k])+c*r[j]*(a+b-c+r[i]-r[j]+r[k])-a*b*c-a*r[i]*r[j]-b*r[k]*r[j]-c*r[i]*r[k];\n        vol=sqrt(vol);\n        vol/=12;\n        v.push_back(3*vol/s);\n    }\n    sort(v.begin(),v.end());\n    cout<<fixed<<setprecision(10)<<v[0]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG p(n);\n\t\tvector<double>r(n);\n\t\trep(i,n){p[i]=pin();cin>>r[i];}\n\t\tif(n==1){\n\t\t\tcout<<r[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble h=320;\n\t\tdouble l=-1;\n\t\twhile(1){\n\t\t\tif(h-l<1e-7)break;\n\t\t\tdouble t=(h+l)/2;\n\t\t\tvector<C>c;\n\t\t\tbool h1=true;\n\t\t\trep(i,n){\n\t\t\t\tdouble go=r[i]*r[i]-t*t;\n\t\t\t\tif(go<0){h1=false;break;}\n\t\t\t\tdouble sa=sqrt(go);\n\t\t\t\tc.pb(C(p[i],sa));\n\t\t\t}\n\t\t\tif(!h1){h=t;continue;}\n\t\t\th1=true;\n\t\t\tG ko;\n\t\t\trep(i,n){\n\t\t\t\tloop(j,i+1,n){\n\t\t\t\t\tif(abs(p[i]-p[j])>c[i].r+c[j].r){h1=false;break;}\n\t\t\t\t\tL cross=crosspointCC(c[i],c[j]);\n\t\t\t\t\tko.pb(cross[0]);\n\t\t\t\t\tko.pb(cross[1]);\n\t\t\t\t}\n\t\t\t\tif(!h1)break;\n\t\t\t\t//ko.pb(p[i]);\n\t\t\t}\n\t\t\tif(!h1){h=t;continue;}\n\t/*\t\t\t\trep(e,2){\n\t\t\t\t\t\tint co=0;\n\t\t\t\t\t\trep(k,n)if(EPS+r[k]>abs(p[k]-cross[e]))co++;\n\t\t\t\t\t\tif(co>=n){h1=true;break;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h1)break;\n\t\t\t\t*/\n\t\t\th1=false;\n\t\t\trep(i,ko.size()){\n\t\t\t\tint co=0;\n\t\t\t\trep(k,n)if(EPS+c[i].r>abs(p[k]-ko[i]))co++;\n\t\t\t\tif(co>=0){h1=true;break;}\n\t\t\t\t/*h1=true;\n\t\t\t\trep(j,n)if(r[j]<abs(ko[i]-p[j])){h1=false;break;}\n\t\t\t\tif(h1)break;*/\n\t\t\t}\n\t\t\t//cout<<l<<\" \"<<h<<endl;\n\t\t\tif(h1)l=t;\n\t\t\telse h=t;\n\t\t}\n\t\tprintf(\"%.7f\\n\",(h+l)/2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nint n;\ndouble l[10];\n\nstruct C {\n\tP p;\n\tdouble r;\n\n\tC() {\n\t\tp = P(0, 0);\n\t\tr = 0;\n\t}\n\n\tC(const P& p, double r) : p(p), r(r) {\n\t}\n\n\tbool in(P t) {\n\t\treturn norm(p - t) < r * r + EPS;\n\t}\n\n\tbool in(C t) {\n\t\treturn abs(p - t.p) + t.r < r + EPS;\n\t}\n} c[10];\n\nbool check(double h) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (l[i] * l[i] - h * h < EPS) return false;\n\t\tc[i].r = sqrt(l[i] * l[i] - h * h);\n\t}\n\n\tvector<P> cs;\n\tfor (int i = 0; i < n; i++) {\n\t\tcs.push_back(c[i].p);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tC c1 = c[i], c2 = c[j];\n\t\t\tif (abs(c1.p - c2.p) > c1.r + c2.r) return false; // ????????????\n\t\t\tif (c1.in(c2) || c2.in(c1)) continue;\n\n\t\t\tP v = c2.p - c1.p;\n\t\t\tdouble t = (c1.r * c1.r + norm(v) - c2.r * c2.r) / (2 * abs(v));\n\t\t\tdouble theta = acos(t / c1.r);\n\t\t\t//assert(-1.0 <= t / c1.r && t / c1.r <= 1.0);\n\t\t\tP b[2];\n\t\t\tb[0] = c1.p + v / abs(v) * c1.r * polar(1.0, theta);\n\t\t\tb[1] = c1.p + v / abs(v) * c1.r * polar(1.0, -theta);\n\t\t\tcs.push_back(b[0]);\n\t\t\tcs.push_back(b[1]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cs.size(); i++) {\n\t\tbool flag = true;\n\t\tfor (int m = 0; m < n; m++) {\n\t\t\tif (!c[m].in(cs[i])) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n , n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y >> l[i];\n\t\t\tc[i].p = P(x, y);\n\t\t}\n\t\tcheck(0);\n\t\tdouble ok = 1, ng = 300;\n\t\tfor (int loop = 0; loop < 100; loop++) {\n\t\t\tdouble h = (ok + ng) / 2;\n\t\t\tif (check(h)) ok = h;\n\t\t\telse ng = h;\n\t\t}\n\t\tcout << setprecision(15) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nint n;\ndouble l[10];\n\nstruct C {\n\tP p;\n\tdouble r;\n\n\tC() {\n\t\tp = P(0, 0);\n\t\tr = 0;\n\t}\n\n\tC(const P& p, double r) : p(p), r(r) {\n\t}\n\n\tbool in(P t) {\n\t\treturn norm(p - t) < r * r + EPS;\n\t}\n\n\tbool in(C t) {\n\t\treturn abs(p - t.p) + t.r < r + EPS;\n\t}\n} c[10];\n\nbool check(double h) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (l[i] * l[i] - h * h < EPS) return false;\n\t\tc[i].r = sqrt(l[i] * l[i] - h * h);\n\t}\n\n\tvector<P> cs;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcs.push_back(c[i].p);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tC c1 = c[i], c2 = c[j];\n\t\t\tif (abs(c1.p - c2.p) > c1.r + c2.r) return false; // ????????????\n\t\t\tif (c1.in(c2) || c2.in(c1)) continue;\n\n\t\t\tP v = c2.p - c1.p;\n\t\t\tdouble t = (c1.r * c1.r + norm(v) - c2.r * c2.r) / (2 * abs(v));\n\t\t\tdouble theta = acos(t / c1.r);\n\t\t\tassert(-1.0 <= t / c1.r && t / c1.r <= 1.0);\n\t\t\tP b[2];\n\t\t\tb[0] = c1.p + v / abs(v) * c1.r * polar(1.0, theta);\n\t\t\tb[1] = c1.p + v / abs(v) * c1.r * polar(1.0, -theta);\n\t\t\tcs.push_back(b[0]);\n\t\t\tcs.push_back(b[1]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < cs.size(); i++) {\n\t\tbool flag = true;\n\t\tfor (int m = 0; m < n; m++) {\n\t\t\tif (!c[m].in(cs[i])) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n , n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y >> l[i];\n\t\t\tc[i].p = P(x, y);\n\t\t}\n\t\tcheck(0);\n\t\tdouble ok = 0, ng = 100000;\n\t\tfor (int loop = 0; loop < 1000; loop++) {\n\t\t\tdouble h = (ok + ng) / 2;\n\t\t\tif (check(h)) ok = h;\n\t\t\telse ng = h;\n\t\t}\n\t\tcout << setprecision(15) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LIMIT 45\nint n; long double x[100], y[100], l[100];\nlong double dst(long double ax, long double ay, long double az, long double bx, long double by, long double bz) {\n\treturn sqrtl((ax - bx)*(ax - bx) + (ay - by)*(ay - by) + (az - bz)*(az - bz));\n}\nlong double max_amari(long double ax, long double ay, long double az) {\n\tlong double maxn = 1000000000.0l;\n\tfor (int i = 0; i < n; i++) {\n\t\tmaxn = min(maxn, l[i] - dst(ax, ay, az, 0, x[i], y[i]));\n\t}\n\treturn maxn;\n}\nlong double solve2(long double h, long double X) {\n\tlong double L1 = -1000000.0l, R1 = 1000000.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = max_amari(h, X, c1);\n\t\tlong double m2 = max_amari(h, X, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\treturn maxn;\n}\nbool solve(long double h) {\n\tlong double L1 = -1000000.0l, R1 = 1000000.0l, c1, c2, maxn = -1000000000.0l;\n\tfor (int i = 0; i < LIMIT; i++) {\n\t\tc1 = (L1 + L1 + R1) / 3.0l;\n\t\tc2 = (L1 + R1 + R1) / 3.0l;\n\t\tlong double m1 = solve2(h, c1);\n\t\tlong double m2 = solve2(h, c2);\n\t\tif (m1 >= m2)R1 = c2;\n\t\tif (m1 < m2)L1 = c1;\n\t\tmaxn = max(maxn, max(m1, m2));\n\t}\n\tif (maxn > -1e-14)return true;\n\treturn false;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> x[i] >> y[i] >> l[i];\n\t\tlong double L = 0.0l, R = 1000000.0l, M;\n\t\tfor (int i = 0; i < LIMIT; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tbool a1 = solve(M);\n\t\t\tif (a1 == true)L = M;\n\t\t\tif (a1 == false)R = M;\n\t\t}\n\t\tprintf(\"%.15Lf\\n\", M);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x,y) ((x)-(y)<=-EPS)\n\nvector<P> cross_circles(P c1,double r1,P c2,double r2){\n\tdouble d=abs(c2-c1);\n\tif(LT(r1+r2,d)||LT(d,fabs(r1-r2)))\n\t\treturn vector<P>();\n\tdouble l=0.5*((r1*r1-r2*r2)/d+d);\n\tdouble h=sqrt(r1*r1-l*l);\n\tvector<P> ret(2);\n\tret[0]=P(l,+h)*(c2-c1)/d+c1;\n\tret[1]=P(l,-h)*(c2-c1)/d+c1;\n\treturn ret;\n}\n\ndouble distance(double y1,double x1,double y2,double x2){\n\tdouble dy=y1-y2;\n\tdouble dx=x1-x2;\n\treturn sqrt(dy*dy+dx*dx);\n}\n\nbool ok(vi &y,vi &x,vi &l, double h){\n\tint n=y.size();\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(l[i]<h||l[j]<h){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdouble di=sqrt(l[i]*l[i]-h*h);\n\t\t\tdouble dj=sqrt(l[j]*l[j]-h*h);\n\t\t\tdouble dist2=distance(y[i],x[i],y[j],x[j]);\n\t\t\tbool intersected=di+dj>dist2;\n\t\t\tvector<P> cross=cross_circles(P(y[i],x[i]),di,P(y[j],x[j]),dj);\n\t\t\tif(cross.size()==0){\n\t\t\t\tif(!intersected){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tREP(k,n){\n\t\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\t\tdouble dk=sqrt(l[k]*l[k]-h*h);\n\t\t\t\t\tREP(ci,2){\n\t\t\t\t\t\tif(distance(y[k],x[k],cross[ci].imag(),cross[ci].real())>dk){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tcout.precision(30);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n),y(n),l(n);\n\t\tint maxl=0;\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>l[i];\n\t\t\tmaxl=max(maxl,l[i]);\n\t\t}\n\n\t\tdouble lb=1,ub=maxl;\n\t\tREP(time,100000){\n\t\t\tdouble mid=(lb+ub)/2;\n\t\t\tif(!ok(y,x,l,mid)){\n\t\t\t\tub=mid;\n\t\t\t}else{\n\t\t\t\tlb=mid;\n\t\t\t}\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nstruct Anchor{\n  int x,y,l;\n  Anchor(int _x,int _y,int _l)\n    : x(_x), y(_y), l(_l) {}\n};\n\nbool check(const vector<Anchor>& anchors,\n\t   double x,double y,double virtical_line){\n  \n  for(int anchor_idx=0;anchor_idx<anchors.size();anchor_idx++){\n    double bottom_line\n      = sqrt((double)(anchors[anchor_idx].x - x) * (double)(anchors[anchor_idx].x - x)\n\t     + (double)(anchors[anchor_idx].y - y) * (double)(anchors[anchor_idx].y - y));\n    double diagonal_line\n      = sqrt(bottom_line * bottom_line\n\t     + virtical_line * virtical_line); \n    if((double)anchors[anchor_idx].l < diagonal_line + EPS){\n      return false;\n    }\n  }\n  return true;\n}\n\ndouble compute_height(const vector<Anchor>& anchors,\n\t\t      double x,double y){\n  double max_height = 1000000.0;\n  double min_height = 0.0;\n  for(int round = 0;round < 50;round++){\n    double mid = (max_height + min_height) / 2.0;\n    if(check(anchors,x,y,mid)){\n      min_height = mid;\n    }\n    else{\n      max_height = mid;\n    }\n  }\n  return min_height;\n}\n\nint main(){\n  int total_anchors;\n  while(~scanf(\"%d\",&total_anchors)){\n    if(total_anchors == 0) break;\n\n    vector<Anchor> anchors;\n    for(int anchor_idx=0;anchor_idx<total_anchors;anchor_idx++){\n      int x,y,l;\n      scanf(\"%d %d %d\",&x,&y,&l);\n      anchors.push_back(Anchor(x,y,l));\n    }\n\n    double res = 0.0;\n\n    \n    double min_x = -100.0;\n    double max_x = 100.0;\n    for(int round = 0; round < 50; round++){\n      double mid = (min_x + max_x) / 2.0;\n\n      double to = compute_height(anchors,mid,0.0);\n      double from = compute_height(anchors,mid-0.0000001,0.0);\n      \n      double delta = to - from;\n\n      if(delta <= 0){\n\tmax_x = mid;\n      }\n      else{\n\tmin_x = mid;\n      }\n    }\n\n    double last_x = max_x;\n    double min_y = -100.0;\n    double max_y = 100.0;\n\n    for(int round = 0; round < 50; round++){\n      double mid = (min_y + max_y) / 2.0;\n\n      double to = compute_height(anchors,max_x,mid);\n      double from = compute_height(anchors,max_x,mid - 0.0000001);\n      \n      double delta = to - from;\n\n      if(delta <= 0){\n\tmax_y = mid;\n      }\n      else{\n\tmin_y = mid;\n      }\n    }\n\n    double last_y = max_y;\n    printf(\"%.7lf\\n\",compute_height(anchors,last_x,last_y));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<const T(const T, const T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tva<int, 3> bl(n);\n\t\trep(i, n)rep(j, 3)cin >> bl[i][j];\n\t\tva<double, 6> h;\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tdouble x[2][3] = { {(double)bl[i][0] - bl[j][0],(double)bl[i][1] - bl[j][1],-pow(bl[i][2],2) + pow(bl[j][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[j][0],2) - pow(bl[j][1],2)},{ (double)bl[i][0] - bl[k][0],(double)bl[i][1] - bl[k][1],-pow(bl[i][2],2) + pow(bl[k][2],2) + pow(bl[i][0],2) + pow(bl[i][1],2) - pow(bl[k][0],2) - pow(bl[k][1],2) } };\n\t\t\tdouble a, b, c;\n\t\t\tif (x[1][1] == 0)rep(i, 3)swap(x[0][i], x[1][i]);\n\t\t\tif (x[1][1] == 0)continue;\n\t\t\tif (x[0][0] - (x[0][1] / x[1][1])*x[1][0] == 0)continue;\n\t\t\ta = (x[0][2] - x[0][1] / x[1][1] * x[1][2]) / (x[0][0] - (x[0][1] / x[1][1])*x[1][0]) / 2;\n\t\t\tb = (x[1][2] - 2 * a*x[1][0]) / 2 / x[1][1];\n\t\t\tc = pow(bl[i][2],2) - pow(a - bl[i][0], 2) - pow(b - bl[i][1], 2);\n\t\t\tif (c < 0)continue;\n\t\t\tc = sqrt(c);\n\t\t\th.push_back({ a,b,c,(double)k,(double)j,(double)i });\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tdouble l = hypot(bl[i][0] - bl[j][0], bl[i][1] - bl[j][1]);\n\t\t\tdouble a = (pow(bl[j][2], 2) - pow(bl[i][2], 2) + pow(l, 2)) / 2 / l;\n\t\t\tdouble x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = pow(bl[j][2], 2) - pow(a, 2);\n\t\t\tif (z < 0)continue;\n\t\t\tz = sqrt(z);\n\t\t\th.push_back({ (double)x,(double)y,(double)z,(double)j,(double)i,(double)i });\n\t\t}\n\t\trep(i, n)h.push_back({ (double)bl[i][0],(double)bl[i][1],(double)bl[i][2],(double)i,(double)i,(double)i });\n\t\t//sort(ALL(h), [](const array<double, 6> &a, const array<double, 6> &b) {return a[2] != b[2] ? a[2] > b[2]:a > b; });\n\t\tdouble ans = 0;\n\t\tfor (auto &&x : h) {\n\t\t\tint pos = 3;\n\t\t\tbool f = 1;\n\t\t\trep(i, n) {\n\t\t\t\tif (i == x[pos]) {\n\t\t\t\t\tif (pos != 5)pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pow(x[0] - bl[i][0], 2) + pow(x[1] - bl[i][1], 2) + pow(x[2], 2) > pow(bl[i][2], 2)+1e-7) {\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tcmax(ans, x[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef struct {P s,t;} L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef vector <C> VC;\n\nconst D eps=1.0e-10;\nconst D pi=acos(-1.0);\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\n//template<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\ntemplate<class T> int sig(T a,T b = 0) {return a < b ? -1 : b > a ? 1 : 0;}\n#define X real()\n#define Y imag()\n\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sq(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.t-l.s;}\ninline P input(){D x,y;cin >> x >> y; return P(x,y);}\n//??\\??? ???????????¬????????¨???\n\n\n// ??? not verify\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ??????\nP rot (P base, P a, D theta){\n\tP tar=a-base;return base+polar(abs(tar), arg(tar)+theta );\n}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P b,P p){ return b*ip(b,p)/norm(b);}\nP proj(L l,P p){ return l.s+proj(vec(l),p-l.s);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ???????????? verify AOJ CGL_1_C\nenum CCW{\n\tLEFT = 1,\n\tRIGHT = 2,\n\tBACK = 4,\n\tFRONT = 8,\n\tMID = 16,\n\tON=FRONT|BACK|MID\n};\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n\ta -= base; b -= base;\n\tif (ep(a, b) > 0)\n\t\treturn LEFT;    // counter clockwise\n\tif (ep(a, b) < 0)\n\t\treturn RIGHT;   // clockwise\n\tif (ip(a, b) < 0)\n\t\treturn BACK;    // b--base--a on line\n\tif (norm(a) < norm(b))\n\t\treturn FRONT;   // base--a--b on line\n\t// otherwise\n\treturn MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n// verify AOJ CGL_2_A\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ?????¨??´?????¨????????¢??£??????????????? (s??????????????????????????§?????????????¨±?????????)\nB iLL(L a,L b){return !ipar(a,b);}\n\nB eqL(L a,L b){return !iLL(a, b) && ep(vec(a), b.s - a.s)==0;}\nB iLS(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) <= 0;}\nB iLSs(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) < 0;}\n\n// ????????¨?????????????????????\n// verify AOJ CGL_2_B\nB iSS(L a,L b){\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a,L b) {\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ??????\n// verify AOJ CGL_2_C\nP pLL(L a,L b){ return a.s+vec(a)*ep(vec(b),b.s-a.s)/ep(vec(b),vec(a));}\n\n// ?????¨??´???????????¢\nD dLP(L l,P p){return abs( ep(vec(l),p-l.s) )/abs(vec(l));}\n// ?????¨??????????????¢\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.s)) <= 0) return abs(p - s.s);\n\tif (sig( ip(-vec(s), p - s.t)) <= 0) return abs(p - s.t);\n\treturn dLP(s,p);\n}\n\n// ??´?????¨??´???????????¢\nD dLL(L a,L b){ return iLL(a,b)?0:dLP(a,b.s);}\n\n// ?????¨??´?????¨????????¢??£????????¢\nD dLS(L a,L b){ return iLS(a,b)?0:min(dLP(a, b.s),dLP(a, b.t));}\n\n// ????????¨??????????????¢\n// verify AOJ CGL_2_D\nD dSS(L a,L b){ return iSS(a,b)?0:\n\tmin({ dSP(a,b.s),dSP(a,b.t),dSP(b,a.s),dSP(b,a.t)});\n}\n\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){\n\treturn (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;\n}  // base x\ninline B cmp_y(const P &a,const P &b){\n\treturn (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;\n}  // base y\ninline B cmp_a(const P &a,const P &b){\n\treturn (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);\n} // base arg\n\n// ????§???¢\n\n// ??¢???\n// Verify AOJ 1100\n// verify CGL_3_A\nD area(VP pol){\n\tint n=pol.size();\n\tD sum=0.0;\n\trep(i,n){\n\t\tD x=pol[i%n].X-pol[(i+1)%n].X;\n\t\tD y=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=x*y;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢?????????\n// verify CGL_3_B\nB is_convex(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==RIGHT) return false;\n\t}\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????)\n//verify AOJ CGL_3-C\nint in_polygon(VP pol,P p){\n\tint n=pol.size();\n\tint res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==MID)\n\t\t\treturn 1;\n\t\tD vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n\t\tD dx=pol[(i+1)%n].X-pol[i].X;\n\t\tif((pol[i].Y<=p.Y)&&(p.Y< pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res++;\n\t\tif((pol[i].Y> p.Y)&&(p.Y>=pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res--;\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????)\n// Verify AOJ 2514\n\nbool in_polygon(VP pol,L l){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar={pol[i],pol[(i+1)%n]};\n\t\tif(iSS(l,tar))\n\t\t\tcheck.push_back(pLL(l,tar));\n\t}\n\n\tcheck.push_back(l.s);\n\tcheck.push_back(l.t);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m)) return false;\n\t}\n\treturn true;\n}\n\n\n// convex_hull\n// Verify AOJ 0063\n// Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tVP res(2*n);\n\n\t//??\\??????while?????????????????????\n\t//????????????????????????????????????????????´??????<=0\n\t//???????????????????????????????????????????????´??????<0\n\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// ????????????\n// verify AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i], b = pol[(i+1)%n];\n\t\tif(ccw(l.s, l.t, a) != RIGHT) res.push_back(a);\n\t\tif((ccw(l.s, l.t, a)|ccw(l.s, l.t, b))==(LEFT|RIGHT))\n\t\t\tres.push_back(pLL({a,b}, l));\n\t}\n\treturn res;\n}\n\n// ???\n// Verify AOJ 1183\n\nenum RCC{\n\tA_IN_B=1,\n\tB_IN_A=2,\n\tA_ON_B=4,\n\tB_ON_A=8,\n\tISC=16,\n\tON_OUT=32,\n\tOUT=64,\n\tSAME=12,\n\tONS=48\n};\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// ?????¢??£???????????????\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L l) {return sig(c.r, dSP(l, c.c)) >= 0;}\nbool iCSc(C c, L l) {return iCS(c, l) && sig(c.r, max(abs(l.s - c.c), abs(l.t - c.c))) <= 0;}\n\n//2??????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.push_back(a.c+P(a.r,0));\n\t\tres.push_back(a.c+P(-a.r,0));\n\t\tres.push_back(a.c+P(0,a.r));\n\t\tres.push_back(a.c+P(0,-a.r));\n\t}else{\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (norm(d) + norm(a.r) - norm(b.r)) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c);\n\t\tif(rel==ISC){ // 2points\n\t\t\tP w = e * P(0, 1) * sq(norm(a.r)-norm(x));\n\t\t\tres.push_back(a.c + e * x - w);\n\t\t\tres.push_back(a.c + e * x + w);\n\t\t}else if(rel&ONS){ // 1points\n\t\t\tres.push_back(a.c + e * x);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l,c.c);\n\tP e = vec(l) / abs(vec(l)) * sq(norm(c.r) - norm(h - c.c));\n\tres.push_back(h - e);\n\tres.push_back(h + e);\n\treturn res;\n}\n\n\n// ????????\\???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n\n// ????????±?????\\???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tP ba=b.c-a.c;\n\tD d=ang(ba);\n\tD i=acos((a.r+b.r)/abs(ba));\n\tD o=acos((a.r-b.r)/abs(ba));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.push_back(tanC(a,d+i));\n\t\tres.push_back(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.push_back(tanC(a,d+o));\n\t\tres.push_back(tanC(a,d-o));\n\t}\n\n\tif(r&ONS) res.push_back(tanC(a,d)); //??\\????????±???????????\\???\n\n\tif(r==SAME) rep(i,5) res.push_back(tanC(a,i));\n\treturn res;\n}\n\n\nconst int vmax=1010;\nstruct node{int to;D cost;};\n// segments arrangement\nvector<node> graph[vmax];\nvoid sArr(const vector<L> &seg, vector<P> &point){\n\trep(i,seg.size()){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trange(j,i+1,seg.size()){\n\t\t\tif (iSS(seg[i],seg[j]))\n\t\t\t\tpoint.push_back( pLL(seg[i],seg[j]));\n\t\t}\n\t}\n\tsort(point.begin(),point.end(),cmp_x);\n\tpoint.erase(unique(point.begin(),point.end(),cmp_x), point.end());\n\n\trep(i,seg.size()){\n\t\tvector< pair<D, int> > list;\n\t\trep(j,point.size())\n\t\t\tif (ccw(seg[i].s,seg[i].t, point[j])==MID)\n\t\t\t\tlist.push_back(make_pair(norm(seg[i].s-point[j]), j));\n\t\tsort(list.begin(),list.end());\n\t\trange(j,1,list.size()){\n\t\t\tint a = list[j-1].second, b = list[j].second;\n\t\t\tgraph[a].push_back( {b, abs(point[a]-point[b])} );\n\t\t\tgraph[b].push_back( {a, abs(point[a]-point[b])} );\n\t\t}\n\t}\n}\n\n\n\n// under not verify\n\n// ????????????????????????\n/*\nvector<L> merge(vector<L> lines) {\n\trep(i,lines.size())\n\t\tif(lines[i].t < lines[i].s)\n\t\t\tswap(lines[i].s, lines[i].t);\n\tsort(lines.begin(),lines.end());\n\trep(i,lines.size())rep(j,i){\n\t\tif (iSS(lines[i],lines[j])&&!iSSs(lines[i],lines[j])){\n\t\t\tif(abs(lines[i].t-lines[j].s) > abs(vec(lines[j])))\n\t\t\t\tlines[j].t = lines[i].t;\n\t\t\tlines.erase(lines.begin() + i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lines;\n}\n*/\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==MID)\n\t\t\tpol.erase(pol.begin() + i--);\n\t}\n\treturn pol;\n}\n\n\nL bisector(P a, P b) {\n  P mid=(a+b)*P(0.5,0);\n  return L{mid, mid+(b-a)*P(0, pi/2)};\n}\n\nVP voronoi_cell(VP pol,VP v, int s) {\n  rep(i, v.size()) if(i!=s) pol = convex_cut(pol,bisector(v[s], v[i]));\n  return pol;\n}\n\nconst D inf = 1e9;\n\nint main(void){\n    for(int n; cin >> n, n;){\n        VP points(n);\n        vector<D> l(n);\n        rep(i, n) points[i] = input(), cin >> l[i];\n\n        D lb = 0.0, ub = *min_element(begin(l), end(l)) + eps;\n        rep(loop, 100){\n            D mid = (lb + ub) / 2.0;\n\n            VC circles(n);\n            rep(i, n){\n                circles[i] = { points[i], sq(pow(l[i], 2) - pow(mid, 2)) };\n            }\n\n            bool ok = true;\n            [&]\n            {\n                rep(i, n){\n                    range(j, i + 1, n){\n                        int ret = rCC(circles[i], circles[j]);\n                        if(pCC(circles[i], circles[j]).size() == 0 and (ret != A_IN_B and ret != B_IN_A)){\n                            ok = false;\n                            return;\n                        }\n                    }\n                }\n            }();\n\n            if(ok){\n                lb = mid;\n            }\n            else {\n                ub = mid;\n            }\n        }\n\n        cout.precision(12);\n        cout << lb << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <iomanip>\n\nusing ll = long long;\n\nusing namespace std;\n\n#define EPS (1e-10)\nusing value_t = double;\nusing point_t = complex<value_t>;\n\nstruct circle {\n    point_t c;\n    value_t r;\n    \n    int contains(const point_t p) {\n        value_t d = abs(p - c);\n        if (d < r - EPS) \n            return 2;\n        else if (d < r + EPS)\n            return 1;\n        else\n            return 0;\n    }\n};\n\nbool intersection_point(const circle a, const circle b, point_t &p1, point_t &p2) {\n    value_t dist = abs(a.c - b.c);\n    value_t rdif = abs(a.r - b.r);\n    value_t rsum = a.r + b.r;\n    if ((dist < EPS && rdif < EPS) || dist < rdif - EPS || dist > rsum + EPS) {\n        return false;\n    }\n    \n    point_t vec_ab = b.c - a.c;\n    value_t d = abs(vec_ab);\n    value_t theta = arg(vec_ab);\n    value_t alpha = acos((a.r * a.r + d * d - b.r * b.r) / (a.r * d * 2));\n\n    p1 = a.c + polar(a.r, theta + alpha);\n    p2 = a.c + polar(a.r, theta - alpha);\n\n    return true;\n}\n\nint count_overlap(vector<circle> &circles) {\n    int ans = 1;\n    size_t n = circles.size();\n    for (size_t i=0; i<n; i++) {\n        for (size_t j=0; j<i; j++) {\n            point_t p1, p2;\n            value_t dist = abs(circles[i].c - circles[j].c);\n            value_t rsum = circles[i].r + circles[j].r;\n            if (!intersection_point(circles[i], circles[j], p1, p2)) {\n                if (dist > rsum + EPS) continue;\n                circle insider = (circles[i].r < circles[j].r ? circles[i] : circles[j]);\n                p1 = p2 = insider.c;\n            }\n\n\n            int cnt1 = 0, cnt2 = 0;\n            for (size_t k=0; k<n; k++) {\n                if (circles[k].contains(p1)) cnt1++;\n                if (circles[k].contains(p2)) cnt2++;\n            }\n            ans = max({ans, cnt1, cnt2});\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vector<circle> ropes(n);\n        for (auto &ri:ropes) {\n            value_t x, y, l;\n            cin >> x >> y >> l;\n            ri = {point_t(x, y), l};\n        }\n        value_t l = 1, r = 301;\n        while (r - l > EPS) {\n            value_t m = (l + r) / 2;\n            vector<circle> circles;\n            for (auto ri:ropes) {\n                if (ri.r < m - EPS) continue;\n                ri.r = sqrt(ri.r * ri.r - m * m);\n                circles.push_back(ri);\n            }\n            if (circles.size() >= 1 && count_overlap(circles) == n) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        cout << setprecision(10) << fixed << l << '\\n'; \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n    hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n   \nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n    \nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n    \nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n    \nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;   // counter clockwise\nelse return -1;\n}\nint main() {\n    int n;\n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);\n    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);\n    cin.sync_with_stdio(0);\n    while (cin >> n, n) {\n        va<float, 3> bl(n);\n        rep(i, n)rep(j, 3)cin >> bl[i][j];\n        //va<double, 3> h;\n        double ans = 1e9;\n        int mina = 0;\n        rep(i, n)if (ans > bl[i][2])ans = bl[i][2], mina = i;\n        ans *= ans;\n        rep(i, n) {\n            rep(j, i) {\n                double l = sqrt(double(bl[i][0] - bl[j][0])*(bl[i][0] - bl[j][0]) + (bl[i][1] - bl[j][1])*(bl[i][1] - bl[j][1]));\n                double a = ((bl[j][2] * bl[j][2] - bl[i][2] * bl[i][2]) / l + l)*0.5;\n                double x = (bl[i][0] * a + bl[j][0] * (l - a)) / l, y = (bl[i][1] * a + bl[j][1] * (l - a)) / l, z = bl[j][2] * bl[j][2] - a*a;\n                if (z < 0)continue;\n                if (z<ans&&a > 0 && a < l)ans = z;\n                double x00 = bl[i][0] - bl[j][0], x01 = bl[i][1] - bl[j][1], x02 = -bl[i][2] * bl[i][2] + bl[j][2] * bl[j][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[j][0] * bl[j][0] - bl[j][1] * bl[j][1];\n                if (x01 != 0) {\n                    double rv = 1 / x01;\n                    rep(k, j) {\n                        double x10 = bl[i][0] - bl[k][0], x11 = bl[i][1] - bl[k][1], x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n                        double a, b, c;\n                        double rv2 = x10 * x01 - x11*x00;\n                        if (rv2 == 0)continue;\n                        rv2 = 1 / rv2;\n                        a = rv2*(x12 * x01 - x11 * x02)*0.5;\n                        b = (x02 * 0.5 - a*x00)*rv;\n                        c = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]) - (b - bl[i][1])*(b - bl[i][1]);\n                        if (c < 0)continue;\n                        if (c >= ans)continue;\n                        int cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                        if (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                    }\n                }\n                else {\n                    double a = x02*0.5 / x00;\n                    double c_ = bl[i][2] * bl[i][2] - (a - bl[i][0])*(a - bl[i][0]);\n                    rep(k, j) {\n                        double x11 = bl[i][1] - bl[k][1];\n                        if (x11 == 0)continue;\n                        double x10 = bl[i][0] - bl[k][0],x12 = -bl[i][2] * bl[i][2] + bl[k][2] * bl[k][2] + bl[i][0] * bl[i][0] + bl[i][1] * bl[i][1] - bl[k][0] * bl[k][0] - bl[k][1] * bl[k][1];\n                        double b = (x12*0.5 - a*x10) / x11, c;\n                        c = c_ - (b - bl[i][1])*(b - bl[i][1]);\n                        if (c < 0)continue;\n                        if (c >= ans)continue;\n                        int cc = ccw(P(a, b), P(bl[i][0], bl[i][1]), P(bl[j][0], bl[j][1]));\n                        if (cc == ccw(P(a, b), P(bl[j][0], bl[j][1]), P(bl[k][0], bl[k][1])) && cc == ccw(P(a, b), P(bl[k][0], bl[k][1]), P(bl[i][0], bl[i][1])))ans = c;\n                    }\n                }\n            }\n        }\n        cout << fixed << setprecision(7) << sqrt(ans) << endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1190: Anchored Balloon\n// 2017.12.8 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define N 35\nint n;\nint x[10], y[10], l[10];\n\ndouble sach(double xx, double yy)\n{\n\tint i;\n    double t, ans = 1e10;\n\n    for (i = 0; i < n; i++) {\n        t = l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]);\n        if (t < ans) ans = t;\n    }\n    return ans;\n}\n\ndouble ysach(double xx)\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while(i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (sach(xx, m1) > sach(xx, m2)) r = m2; else l = m1;\n    }\n    return sach(xx, l);\n}\n\ndouble xysach()\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while (i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (ysach(m1) > ysach(m2)) r = m2; else l = m1;\n    }\n    return sqrt(ysach(l));\n}\n\nint main()\n{\n\tint i;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", x+i, y+i, l+i);\n        printf(\"%.07f\\n\", xysach());\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1190: Anchored Balloon\n// 2017.12.8 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define N 100\nint n;\nint x[10], y[10], l[10];\n\ndouble sach(double xx, double yy)\n{\n\tint i;\n    double t, ans = 1e10;\n\n    for (i = 0; i < n; i++) {\n        t = l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]);\n        if (t < ans) ans = t;\n    }\n    return ans;\n}\n\ndouble ysach(double xx)\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while(i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (sach(xx, m1) > sach(xx, m2)) r = m2; else l = m1;\n    }\n    return sach(xx, l);\n}\n\ndouble xysach()\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while (i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (ysach(m1) > ysach(m2)) r = m2; else l = m1;\n    }\n    return sqrt(ysach(l));\n}\n\nint main()\n{\n\tint i;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", x+i, y+i, l+i);\n        printf(\"%.07f\\n\", xysach());\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1190: Anchored Balloon\n// 2017.12.8 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define N 75\nint n;\nint x[10], y[10], l[10];\n\ndouble sach(double xx, double yy)\n{\n\tint i;\n    double t, ans = 1e10;\n\n    for (i = 0; i < n; i++) {\n        t = l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]);\n        if (t < ans) ans = t;\n    }\n    return ans;\n}\n\ndouble ysach(double xx)\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while(i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (sach(xx, m1) > sach(xx, m2)) r = m2; else l = m1;\n    }\n    return sach(xx, l);\n}\n\ndouble xysach()\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while (i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (ysach(m1) > ysach(m2)) r = m2; else l = m1;\n    }\n    return sqrt(ysach(l));\n}\n\nint main()\n{\n\tint i;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", x+i, y+i, l+i);\n        printf(\"%.07f\\n\", xysach());\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  double x;\n  double y;\n  double l;\n} point;\n\nint n;\npoint data[15];\npoint zero;\npoint memo[15][15];\n\ndouble solve();\npoint calc(point l, point r);\npoint calc2(int i, int j, int k);\nbool check(point x);\ndouble cdis(double x1, double y1, double x2, double y2);\ndouble heron(double a, double b, double c);\n\nint main() {\n  int i, j;\n  zero.x = zero.y = zero.l = 0.0;\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    for(i = 0; i < n; ++i)\n      scanf(\"%lf %lf %lf\", &data[i].x, &data[i].y,\n            &data[i].l);\n    printf(\"%.6f\\n\", solve());\n    for(i = 0; i < n; ++i)\n      for(j = 0; j < n; ++j) memo[i][j] = zero;\n  }\n  return 0;\n}\n\ndouble solve() {\n  int i, j, k;\n  double ans = -1;\n  // one\n  for(i = 0; i < n; ++i)\n    if(check(data[i]) && data[i].l > ans) ans = data[i].l;\n  // two\n  for(i = 0; i < n; ++i)\n    for(j = i + 1; j < n; ++j) {\n      memo[i][j] = calc(data[i], data[j]);\n      if(memo[i][j].l <= 0) continue;\n      if(check(memo[i][j]) && memo[i][j].l > ans)\n        ans = memo[i][j].l;\n      memo[j][i] = memo[i][j];\n    }\n  // three\n  for(i = 0; i < n; ++i)\n    for(j = i + 1; j < n; ++j)\n      for(k = j + 1; k < n; ++k) {\n        if(i != j && j != k && k != i && memo[i][j].l > 0 &&\n           memo[j][k].l > 0 && memo[i][k].l > 0) {\n          point now = calc2(i, j, k);\n          if(now.l <= 0) continue;\n          if(check(now) && now.l > ans) ans = now.l;\n        }\n      }\n  return ans;\n}\npoint calc(point l, point r) {\n  point ans = l;\n  double t = cdis(l.x, l.y, r.x, r.y);\n  ans.l = heron(l.l, r.l, t) * 2 / t;\n  if(ans.l < 0) return ans;\n  double a, b;\n  a = sqrtl(l.l * l.l - ans.l * ans.l);\n  b = sqrtl(r.l * r.l - ans.l * ans.l);\n  ans.x += (r.x - l.x) * a / (a + b);\n  ans.y += (r.y - l.y) * a / (a + b);\n  return ans;\n}\npoint calc2(int i, int j, int k) {\n  point ans = zero, x = data[i], y = data[j], z = data[k];\n  ans.l = -1;\n  double cosin[3] = {0}, d[3] = {0};\n  d[0] = cdis(x.x, x.y, y.x, y.y);\n  d[1] = cdis(y.x, y.y, z.x, z.y);\n  d[2] = cdis(x.x, x.y, z.x, z.y);\n  cosin[0] = (x.l * x.l + y.l * y.l - d[0] * d[0]) /\n             (2.0 * x.l * y.l);\n  cosin[1] = (z.l * z.l + y.l * y.l - d[1] * d[1]) /\n             (2.0 * z.l * y.l);\n  cosin[2] = (x.l * x.l + z.l * z.l - d[2] * d[2]) /\n             (2.0 * x.l * z.l);\n  double h, t, v;\n  t = 1.0 + (2.0 * cosin[0] * cosin[1] * cosin[2]) -\n      (cosin[0] * cosin[0] + cosin[1] * cosin[1] +\n       cosin[2] * cosin[2]);\n  if(t < 0) return ans;\n  v = x.l * y.l * z.l * sqrtl(t) / 6;\n  h = v * 3.0 / heron(d[0], d[1], d[2]);\n  if(h < 0) return ans;\n  ans.l = h;\n  point p1 = x, p2 = x;\n  double nd[3], xd, yd, sincos[2], dis;\n  nd[0] = d[0];\n  nd[1] = sqrtl(x.l * x.l - h * h);\n  nd[2] = sqrtl(y.l * y.l - h * h);\n  xd = (nd[1] * nd[1] - nd[2] * nd[2] + nd[0] * nd[0]) /\n       (2.0 * nd[0]);\n  yd = heron(nd[1], nd[2], nd[0]) * 2.0 / nd[0];\n  sincos[0] = (y.x - x.x) / nd[0];\n  if(sincos[0] > -0.00001 && sincos[0] < 0.00001)\n    sincos[1] = 1;\n  else\n    sincos[1] = sincos[0] * (y.y - x.y) / (y.x - x.x);\n  p1.x += xd * sincos[0] - yd * sincos[1];\n  p1.y += xd * sincos[1] + yd * sincos[0];\n  p2.x += xd * sincos[0] + yd * sincos[1];\n  p2.y += xd * sincos[1] - yd * sincos[0];\n  dis =\n      cdis(z.x, z.y, p1.x, p1.y) - sqrtl(z.l * z.l - h * h);\n  if(dis < 0) dis *= -1;\n  if(dis < 0.00001) {\n    ans.x = p1.x;\n    ans.y = p1.y;\n  }\n  else {\n    dis = cdis(z.x, z.y, p2.x, p2.y) -\n          sqrtl(z.l * z.l - h * h);\n    if(dis < 0) dis *= -1;\n    if(dis < 0.00001) {\n      ans.x = p2.x;\n      ans.y = p2.y;\n    }\n    else {\n      ans = zero;\n      ans.l = -1;\n    }\n  }\n  return ans;\n}\nbool check(point x) {\n  int i;\n  point now;\n  double req, d;\n  for(i = 0; i < n; ++i) {\n    now = data[i];\n    d = cdis(now.x, now.y, x.x, x.y);\n    req = sqrtl(d * d + x.l * x.l);\n    if(req >= now.l + 0.00001) return 0;\n  }\n  return 1;\n}\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\ndouble heron(double a, double b, double c) {\n  if(a + b <= c || a + c <= b || b + c <= a) return -1;\n  a *= a;\n  b *= b;\n  c *= c;\n  return sqrtl(2 * (a * b + b * c + c * a) - a * a - b * b -\n               c * c) /\n         4;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct rope { double x, y, l; } Rope;\n\n/* 風船が飛ぶことのできる高さの最大値を求める */\nRope height(Rope r1, Rope r2){\n\tdouble d = sqrt((r1.x - r2.x) * (r1.x - r2.x) + (r1.y - r2.y) * (r1.y - r2.y));\n}\n\nint main(void){\n\tint n, x[10], y[10], l[10];\n\tRope r[10], min;\n\tint i, x, y, l;\n\n\twhile (scanf(\"%d\", &n) == 1 && n >= 1 && n <= 10){\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &l);\n\t\t\tr[i].x = x;\n\t\t\tr[i].y = y;\n\t\t\tr[i].l = l;\n\t\t}\n\n\t\t/* 風船が飛ぶことのできる高さの最大値を求める */\n\t\tmin = r[0];\n\t\tfor (i = 1; i < n; i++){\n\t\t\tmin = height(min, r[i]);\n\t\t}\n\n\t\t/* 出力 */\n\t\tprintf(\"%d\\n\", min.l);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tdouble x,y,z;\n} xyz_t;\n\ntypedef struct {\n\tint x,y,l;\n} kui_t;\n\nint n;\nkui_t kui[10];\n\nint is_valid(xyz_t b) {\n\tint i;\n\tif(b.z<0)return 0;\n\tfor(i=0;i<n;i++) {\n\t\tif((b.x-kui[i].x)*(b.x-kui[i].x)+(b.y-kui[i].y)*(b.y-kui[i].y)+b.z*b.z>kui[i].l*kui[i].l+EPS)return 0;\n\t}\n\treturn 1;\n}\n\nint hts_solve(double* x,double* y,int a,int b,int c,int d,int p,int q) {\n\tint delta=a*d-b*c;\n\tif(delta==0)return 0;\n\t*x=(double)(d*p-b*q)/delta;\n\t*y=(double)(-c*p+a*q)/delta;\n\treturn 1;\n}\n\nxyz_t get_one(int id) {\n\txyz_t result={kui[id].x,kui[id].y,kui[id].l};\n\treturn result;\n}\n\nxyz_t get_two(int id1,int id2) {\n\tdouble a=sqrt((kui[id1].x-kui[id2].x)*(kui[id1].x-kui[id2].x)+(kui[id1].y-kui[id2].y)*(kui[id1].y-kui[id2].y));\n\tdouble x=(a*a-kui[id2].l*kui[id2].l+kui[id1].l*kui[id1].l)/(2.0*a);\n\tdouble h=sqrt(kui[id1].l*kui[id1].l-x*x);\n\txyz_t result={kui[id1].x+(kui[id2].x-kui[id1].x)*x/a,kui[id1].y+(kui[id2].y-kui[id1].y)*x/a,h};\n\treturn result;\n}\n\nxyz_t get_three(int id1,int id2,int id3) {\n\tkui_t k1=kui[id1];\n\tkui_t k2=kui[id2];\n\tkui_t k3=kui[id3];\n\tdouble x,y,zz;\n\txyz_t err={0,0,-1};\n\txyz_t result;\n\tif(!hts_solve(&x,&y,2*(k1.x-k2.x),2*(k1.y-k2.y),2*(k2.x-k3.x),2*(k2.y-k3.y),\n\t\t\tk2.l*k2.l-k1.l*k1.l-k2.x*k2.x+k1.x*k1.x-k2.y*k2.y+k1.y*k1.y,\n\t\t\tk3.l*k3.l-k2.l*k2.l-k3.x*k3.x+k2.x*k2.x-k3.y*k3.y+k2.y*k2.y)) {\n\t\treturn err;\n\t}\n\tzz=k1.l*k1.l-k1.y*k1.y+2*y*k1.y-y*y-k1.x*k1.x+2*x*k1.x-x*x;\n\tif(zz<0)return err;\n\tresult.x=x;result.y=y;result.z=sqrt(zz);\n\treturn result;\n}\n\nint main(void) {\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tint i,j,k;\n\t\tfor(i=0;i<n;i++)scanf(\"%d%d%d\",&kui[i].x,&kui[i].y,&kui[i].l);\n\t\tdouble max_z=0;\n\t\txyz_t now;\n\t\t/* one */\n\t\tfor(i=0;i<n;i++) {\n\t\t\tnow=get_one(i);\n\t\t\tif(is_valid(now) && now.z>max_z)max_z=now.z;\n\t\t}\n\t\t/* two */\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\tnow=get_two(i,j);\n\t\t\t\tif(is_valid(now) && now.z>max_z)max_z=now.z;\n\t\t\t}\n\t\t}\n\t\t/* three */\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\tfor(k=j+1;k<n;k++) {\n\t\t\t\t\tnow=get_three(i,j,k);\n\t\t\t\t\tif(is_valid(now) && now.z>max_z)max_z=now.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15f\\n\",max_z);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1190: Anchored Balloon\n// 2017.12.8 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define N 50\nint n;\nint x[10], y[10], l[10];\n\ndouble sach(double xx, double yy)\n{\n\tint i;\n    double t, ans = 1e10;\n\n    for (i = 0; i < n; i++) {\n        t = l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]);\n        if (t < ans) ans = t;\n    }\n    return ans;\n}\n\ndouble ysach(double xx)\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while(i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (sach(xx, m1) > sach(xx, m2)) r = m2; else l = m1;\n    }\n    return sach(xx, l);\n}\n\ndouble xysach()\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while (i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (ysach(m1) > ysach(m2)) r = m2; else l = m1;\n    }\n    return sqrt(ysach(l));\n}\n\nint main()\n{\n\tint i;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", x+i, y+i, l+i);\n        printf(\"%.07f\\n\", xysach());\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1190: Anchored Balloon\n// 2017.12.8 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define N 150\nint n;\nint x[10], y[10], l[10];\n\ndouble sach(double xx, double yy)\n{\n\tint i;\n    double t, ans = 1e10;\n\n    for (i = 0; i < n; i++) {\n        t = l[i]*l[i] - (xx-x[i])*(xx-x[i]) - (yy-y[i])*(yy-y[i]);\n        if (t < ans) ans = t;\n    }\n    return ans;\n}\n\ndouble ysach(double xx)\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while(i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (sach(xx, m1) > sach(xx, m2)) r = m2; else l = m1;\n    }\n    return sach(xx, l);\n}\n\ndouble xysach()\n{\n\tint i;\n    double l = -100.0, r = 100.0, m1, m2;\n\n    i = N; while (i--) {\n        m1 = (2*l + r) / 3;\n        m2 = (l + 2*r) / 3;\n        if (ysach(m1) > ysach(m2)) r = m2; else l = m1;\n    }\n    return sqrt(ysach(l));\n}\n\nint main()\n{\n\tint i;\n\n    while (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", x+i, y+i, l+i);\n        printf(\"%.07f\\n\", xysach());\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ndouble max,x[20],y[20],l[20];\nint n;\ndouble g(double a,double b){\n  int i;\n  double d,h=1e9;\n  for(i=0;i<n;i++){\n    d=l[i]*l[i]-((x[i]-a)*(x[i]-a)+(y[i]-b)*(y[i]-b));\n    if(h>d)h=d;\n  }\n  //if(h<0)return 0;\n  return h;\n}  \nint f(double a,double b){\n  double h=g(a,b);//printf(\"h=%f\\n\",h);\n  if(max<h){\n    max=h;\n    return 1;\n  }\n  return 0;\n}\nint main(){\n  int i;\n  double a,b,c,d,na,nb,nc,nd,e=1e-12;\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<n;i++)scanf(\"%lf %lf %lf\",&x[i],&y[i],&l[i]);\n    a=b=-100;\n    c=d=100;\n    while(hypot(d-b,c-a)>e){\n      max=-1*1e9;\n      if(f((a+a+c)/3.0,(b+b+d)/3.0)){\n\tna=a;\n\tnb=b;\n\tnc=(a+c+c)/3.0;\n\tnd=(b+d+d)/3.0;\n      }\n      if(f((a+c+c)/3.0,(b+b+d)/3.0)){\n\tna=(a+a+c)/3.0;\n\tnb=b;\n\tnc=c;\n\tnd=(b+d+d)/3.0;\n      }\n      if(f((a+a+c)/3.0,(b+d+d)/3.0)){\n\tna=a;\n\tnb=(b+b+d)/3.0;\n\tnc=(a+c+c)/3.0;\n\tnd=d;\n      }\n      if(f((a+c+c)/3.0,(b+d+d)/3.0)){\n\tna=(a+a+c)/3.0;\n\tnb=(b+b+d)/3.0;\n\tnc=c;\n\tnd=d;\n      }\n      // printf(\"%f\\n\",max);\n      a=na;\n      b=nb;\n      c=nc;\n      d=nd;\n      //printf(\"%f %f %f %f\\n\",a,b,c,d);\n    }\n    printf(\"%f\\n\",sqrt(g(a,b)));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\ndouble answer();\ndouble searchY(double X);\ndouble search(double X, double Y);\n\nint n;\ndouble x[10]; double y[10]; double l[10];\n\nint main(void)\n{\n    while(1)\n    {\n        int i;\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        for(i = 0; i < n; i++)\n        { scanf(\"%lf%lf%lf\", &x[i], &y[i], &l[i]); }\n        printf(\"%.6f\\n\", answer());\n    }\n    return 0;\n}\n\ndouble answer()\n{\n    int j;\n    double l = -100.0, r = 100.0;\n    double a, b;\n    for(j = 50; j >= 0; j--)\n    {\n        a = (2*l + r) / 3;\n        b = (l + 2*r) / 3;\n        if(searchY(a) > searchY(b)) r = b; else l = a;\n    }\n    return sqrt(searchY(l));\n}\n\ndouble searchY(double X)\n{\n    int j;\n    double l = -100.0, r = 100.0, a, b;\n    for(j = 50; j >= 0; j--)\n    {\n        a = (2*l + r) / 3;\n        b = (l + 2*r) / 3;\n        if(search(X, a) > search(X, b)) r = b; else l = a;\n    }\n    return search(X, l);\n}\n\ndouble search(double X, double Y)\n{\n    int j;\n    double t, s = 100000000;\n    for(j = 0; j < n; j++)\n    {\n        t = l[j]*l[j] - (X-x[j])*(X-x[j]) - (Y-y[j])*(Y-y[j]);\n        if(t < s) s = t;\n    }\n    return s;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\ntypedef struct dataSet{\n    int x;\n    int y;\n    int l;\n} Data;\n\ntypedef struct pointSet{\n    double x;\n    double y;\n    double z;\n} Point;\n\nData data[15];\nint n;\n\ndouble solve();\ndouble one();\ndouble two();\nPoint twoPoint(int i, int j);\ndouble three();\nPoint threePoint(int i, int j, int k);\ndouble distance(Point p1, Point p2);\nint isOneAble(Point p, int avoid);\nint isTwoAble(Point p, int avoid1, int avoid2);\nint isThreeAble(Point p, int avoid1, int avoid2, int avoid3);\n\ndouble solve(){\n    double oneh, twoh, threeh;\n    oneh = one();\n    if(oneh!=0) return oneh;\n    else{\n        twoh = two();\n        threeh = three();\n        if(twoh > threeh) return twoh;\n        else return threeh;\n    }\n}\n\ndouble one(){\n    int i=0, avoid;\n    Point p;\n    double tmph = 1000;\n    for(i=0;i<n;++i){\n        if(tmph > data[i].l){\n            tmph = data[i].l;\n            p.x = data[i].x;\n            p.y = data[i].y;\n            p.z = data[i].l;\n            avoid = i;\n        }\n    }\n    if(isOneAble(p, avoid)) return tmph;\n    else return 0;\n}\n\ndouble two(){\n    int i=0, j=0;\n    double maxh = 0;\n    Point p;\n    for(i=0;i<n;++i){\n        for(j=i+1;j<n;++j){\n            p = twoPoint(i, j);\n            if(p.z==-1) continue;\n            if(isTwoAble(p, i, j)) if(maxh < p.z) maxh = p.z;\n        }\n    }\n    return maxh;\n}\n\nPoint twoPoint(int i, int j){\n    Point p, p1, p2;\n    double dis, dissub, h2, l1 = data[i].l, l2 = data[j].l, x1 = data[i].x, x2 = data[j].x, y1 = data[i].y, y2 = data[j].y;\n    p1.x = data[i].x; p1.y = data[i].y; p1.z = 0;\n    p2.x = data[j].x; p2.y = data[j].y; p2.z = 0;\n    dis = distance(p1, p2);\n    h2 = (4*dis*dis*l2*l2 - dis*dis*dis*dis + 2*dis*dis*l1*l1 - 2*dis*dis*l2*l2 + 2*l1*l1*l2*l2 - l1*l1*l1*l1 - l2*l2*l2*l2)/(4*dis*dis);\n    if((l1+l2)<dis) p.z = -1;\n    else if(h2<0) p.z = -1;\n    else p.z = sqrt(h2);\n    dissub = (dis*dis+l1*l1-l2*l2)/(2*dis);\n    p.x = x1 + (x2-x1)*dissub/dis;\n    p.y = y1 + (y2-y1)*dissub/dis;\n    return p;\n}\n\ndouble three(){\n    int i=0, j=0, k=0;\n    double maxh = 0;\n    Point p;\n    for(i=0;i<n;++i){\n        for(j=i+1;j<n;++j){\n            for(k=j+1;k<n;++k){\n                p = threePoint(i, j, k);\n                if(p.z==-1) continue;\n                if(isThreeAble(p, i, j, k)) if(maxh < p.z) maxh = p.z;\n            }\n        }\n    }\n    return maxh;\n}\n\nPoint threePoint(int i, int j, int k){\n    Point p, p1, p2, p3;\n    double mom, dis, dissub, h2,\n    l1 = data[i].l, l2 = data[j].l, l3 = data[k].l,\n    x1 = data[i].x, x2 = data[j].x, x3 = data[k].x,\n    y1 = data[i].y, y2 = data[j].y, y3 = data[k].y;\n    /*p1.x = data[i].x; p1.y = data[i].y; p1.z = 0;\n    p2.x = data[j].x; p2.y = data[j].y; p2.z = 0;\n    p3.x = data[k].x; p3.y = data[k].y; p3.z = 0;*/\n    mom = (x2-x1)*(y3-y1) - (x3-x1)*(y2-y1);\n    if(mom==0) p.z = -1;\n    else{\n        p.x = (((l1*l1-x1*x1-y1*y1-l2*l2+x2*x2+y2*y2)*(y3-y1)-(l1*l1-x1*x1-y1*y1-l3*l3+x3*x3+y3*y3)*(y2-y1))/2)/mom;\n        p.y = (((l1*l1-x1*x1-y1*y1-l2*l2+x2*x2+y2*y2)*(x3-x1)-(l1*l1-x1*x1-y1*y1-l3*l3+x3*x3+y3*y3)*(x2-x1))/2)/(-mom);\n        h2 = l1*l1 - (x1-p.x)*(x1-p.x) - (y1-p.y)*(y1-p.y);\n        if(h2<0) p.z = -1;\n        else p.z = sqrt(h2);\n    }\n    return p;\n}\n\ndouble distance(Point p1, Point p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));\n}\n\nint isOneAble(Point p, int avoid){\n    int i=0;\n    Point check;\n    for(i=0;i<n;++i){\n        if(i==avoid) continue;\n        check.x = data[i].x;\n        check.y = data[i].y;\n        check.z = 0;\n        double dis = distance(p, check);\n        if(dis > data[i].l) return 0;\n    }\n    return 1;\n}\n\nint isTwoAble(Point p, int avoid1, int avoid2){\n    int i=0;\n    Point check;\n    for(i=0;i<n;++i){\n        if(i==avoid1 || i==avoid2) continue;\n        check.x = data[i].x;\n        check.y = data[i].y;\n        check.z = 0;\n        double dis = distance(p, check);\n        if(dis > data[i].l) return 0;\n    }\n    return 1;\n}\n\nint isThreeAble(Point p, int avoid1, int avoid2, int avoid3){\n    int i=0;\n    Point check;\n    for(i=0;i<n;++i){\n        if(i==avoid1 || i==avoid2 || i==avoid3) continue;\n        check.x = data[i].x;\n        check.y = data[i].y;\n        check.z = 0;\n        double dis = distance(p, check);\n        if(dis > data[i].l) return 0;\n    }\n    return 1;\n}\n\nint main(void){\n    while(1){\n        int i=0;\n        scanf(\"%d\", &n);\n        if(n==0) break;\n        for(i=0;i<n;++i) scanf(\"%d %d %d\", &data[i].x, &data[i].y, &data[i].l);\n        double maxh = solve();\n        printf(\"%.6f\\n\", maxh);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdio.h>\n#define p2(x) ((x)*(x))\n#define UPDATE_H(h,expr) if(H<h){for(m=0;m<n;m++)if((expr)>p2(L[m])+1e-9)break;if(m==n)H=h;}\ndouble X[10],Y[10],L[10],hypot_cache[10][10],PL[10][10],PX[10][10],PY[10][10];\nint main(){\n\tint n,i,j,k,l,m;\n\tdouble H,h,px,py,pl,vx,vy,cx,cy,cl,t,d;\n\tfor(;scanf(\"%d\",&n),n;printf(\"%.6f\\n\",H)){\n\t\tH=-1;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf\",X+i,Y+i,L+i);\n\t\tfor(i=0;i<n;i++)for(j=i+1;j<n;j++)hypot_cache[i][j]=hypot_cache[j][i]=hypot(X[i]-X[j],Y[i]-Y[j]);\n\t\tfor(i=0;i<n;i++)UPDATE_H(L[i],p2(L[i])+p2(hypot_cache[i][m])); //1D\n\t\tfor(i=0;i<n;i++)for(j=i+1;j<n;j++){ //2D\n\t\t\t//三角形(長さL[i],L[j],hypot)に垂線を下ろす(長さpl)\n\t\t\t//連立方程式L[i]**2=t**2+pl**2,L[k]**2=(hypot-t)**2+pl**2の解は\n\t\t\tt=( p2(L[i])-p2(L[j])+p2(hypot_cache[i][j]) )/( 2*hypot_cache[i][j] );\n\t\t\tPL[i][j]=sqrt(p2(L[i])-p2(t));\n\t\t\t//座標はベクトルを伸縮させることで求まる\n\t\t\tPX[i][j]=X[i]+(X[j]-X[i])*t/hypot_cache[i][j];\n\t\t\tPY[i][j]=Y[i]+(Y[j]-Y[i])*t/hypot_cache[i][j];\n\t\t\tUPDATE_H(PL[i][j],p2(PL[i][j])+p2(PX[i][j]-X[m])+p2(PY[i][j]-Y[m]));\n\t\t}\n\t\tfor(i=0;i<n;i++)for(j=i+1;j<n;j++){ //3D\n\t\t\t//http://topcoder.g.hatena.ne.jp/Mi_Sawa/20130712 ※素直にcomplex使いましょう、はい--;\n\t\t\t//(vx,vy)は(X[i]-X[j],Y[i]-Y[j])に直交する\n\t\t\tvx=Y[j]-Y[i];\n\t\t\tvy=X[i]-X[j];\n\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t//(px,py)->(X[k],Y[k])を(vx,vy)に正射影する(cx,cy)\n\t\t\t\tt=((X[k]-PX[i][j])*vx+(Y[k]-PY[i][j])*vy)/(vx*vx+vy*vy);\n\t\t\t\tcx=PX[i][j]+t*vx;\n\t\t\t\tcy=PY[i][j]+t*vy;\n\t\t\t\tcl=sqrt(p2(L[k])-p2(cx-X[k])-p2(cy-Y[k])); //(cx,cy)から(求める点)までの長さは√(L[k]**2-hypot(cx-X[k],cy-Y[k])**2)\n\t\t\t\t//(px,py),(cx,cy),(求める点)を通る平面はxy平面に対して垂直なので垂線を下ろせば良い\n\t\t\t\td=hypot(cx-PX[i][j],cy-PY[i][j]);\n\t\t\t\tt=( p2(PL[i][j])-p2(cl)+p2(d) )/( 2*d );\n\t\t\t\tpl=sqrt(p2(PL[i][j])-p2(t));\n\t\t\t\tpx=PX[i][j]+(cx-PX[i][j])*t/d;\n\t\t\t\tpy=PY[i][j]+(cy-PY[i][j])*t/d;\n\t\t\t\tUPDATE_H(pl,p2(pl)+p2(px-X[m])+p2(py-Y[m]));\n\t\t\t}\n\t\t}\n\t}\nreturn 0;}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define repl(i,a,b) for(i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n\n#define EPS 1e-9\n\n#define bool int\n#define false 0\n#define true 1\n\n#define max(x,y) x>y?x:y\n#define maxch(x,y) x=max(x,y)\n\n//typedef vector<double> vec;\n//typedef vector<vec> mat;\n\nvoid swap(double* a,double* b){\n\tdouble tmp=*a;*a=*b;*b=tmp;\n}\n\ndouble X[2];\n\nvoid gauss_jordan(const double A[2][2],const double b[]){\n\tint n=2;\n\tdouble B[n][n+1];\n\tint i,j,k;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tB[i][j]=A[i][j];\n\t\t}\n\t\tB[i][n]=b[i];\n\t}\n\tX[0]=X[1]=-114514;\n\tfor(i=0;i<n;i++){\n\t\tint piv=0;\n\t\tfor(j=i;j<n;j++){\n\t\t\tif(fabs(B[j][i])>fabs(B[piv][i]))piv=j;\n\t\t}\n\t\trep(j,n+1)swap(&B[i][j],&B[piv][j]);\n\t\tif(fabs(B[i][i])<EPS)return;\n\t\tfor(j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<n;i++)X[i]=B[i][n];\n\treturn;\n}\n\nint n;\ndouble x[11],y[11],l[11];\n\nbool judge(double xx,double yy,double zz){\n\tbool ok=true;\n\tint i;\n\trep(i,n){\n\t\tif(pow(xx-x[i],2)+pow(yy-y[i],2)+pow(zz,2)-pow(l[i],2)>EPS)ok=false;\n\t}\n\treturn ok;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint i,j,k;\n\t\trep(i,n)scanf(\"%lf%lf%lf\",x+i,y+i,l+i);\n\t\tdouble res=0;\n\t\t{ /// 1\n\t\t\trep(i,n){\n\t\t\t\tif(judge(x[i],y[i],l[i])){\n\t\t\t\t\tmaxch(res,l[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ /// 2\n\t\t\trep(i,n)rep(j,i){\n\t\t\t\tif(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)-pow(l[i]+l[j],2)>EPS)continue;\n\t\t\t\tdouble d=sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2));\n\t\t\t\tdouble xx=(l[i]*l[i]-l[j]*l[j]+d*d)/(2*d);\n\t\t\t\tdouble vx=(xx/d)*x[j]+((d-xx)/d)*x[i];\n\t\t\t\tdouble vy=(xx/d)*y[j]+((d-xx)/d)*y[i];\n\t\t\t\tif(l[i]*l[i]-xx*xx<EPS)continue;\n\t\t\t\tdouble vz=sqrt(l[i]*l[i]-xx*xx);\n\t\t\t\tif(judge(vx,vy,vz)){\n\t\t\t\t\tmaxch(res,vz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ /// 3\n\t\t\trep(i,n)rep(j,i)rep(k,j){\n\t\t\t\tdouble A[2][2];\n\t\t\t\tdouble b[2];\n\t\t\t\tA[0][0]=2*(x[j]-x[i]); A[0][1]=2*(y[j]-y[i]);\n\t\t\t\tA[1][0]=2*(x[k]-x[i]); A[1][1]=2*(y[k]-y[i]);\n\t\t\t\tb[0]=l[i]*l[i]-l[j]*l[j]-(x[i]+x[j])*(x[i]-x[j])-(y[i]+y[j])*(y[i]-y[j]);\n\t\t\t\tb[1]=l[i]*l[i]-l[k]*l[k]-(x[i]+x[k])*(x[i]-x[k])-(y[i]+y[k])*(y[i]-y[k]);\n\t\t\t\tgauss_jordan(A,b);\n\t\t\t\tif(X[0]==-114514)continue;\n\t\t\t\telse{\n\t\t\t\t\tdouble vx=X[0], vy=X[1];\n\t\t\t\t\tif(l[i]*l[i]-pow(vx-x[i],2)-pow(vy-y[i],2)<EPS)continue;\n\t\t\t\t\tdouble vz=sqrt(l[i]*l[i]-pow(vx-x[i],2)-pow(vy-y[i],2));\n\t\t\t\t\tif(judge(vx,vy,vz)){\n\t\t\t\t\t\tmaxch(res,vz);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static double EPS = 1e-4;\n\t\n\tpublic static int[][] move_dir = new int[][]{\n\t\t{0, 0},\n\t\t{1, 0},\n\t\t{0, 1},\n\t\t//{1, 1},\n\t\t{-1, 0},\n\t\t{0, -1},\n\t\t//{-1, -1}\n\t};\n\t\n\tpublic static double check(final int start_pos, final int n, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tdouble x_pos = start_pos >= 0 ? xs.get(start_pos) : 0;\n\t\tdouble y_pos = start_pos >= 0 ? ys.get(start_pos) : 0;\n\t\t\n\t\tdouble z2_pos = 0;\n\t\twhile(true){\n\t\t\tboolean updated = false;\n\t\t\tdouble max_z2_pos = 0;\n\t\t\tdouble sx = 0, sy = 0;\n\t\t\t\n\t\t\tfor(int move[] : move_dir){\n\t\t\t\tfinal double next_x_pos = x_pos + move[0] * EPS;\n\t\t\t\tfinal double next_y_pos = y_pos + move[1] * EPS;\n\t\t\t\tdouble current_z2 = Double.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfinal double dx = Math.abs((next_x_pos - xs.get(i)));\n\t\t\t\t\tfinal double dy = Math.abs((next_y_pos - ys.get(i)));\n\t\t\t\t\tfinal double r2 = rs.get(i) * rs.get(i);\n\t\t\t\t\tfinal double dr2 = dx * dx + dy * dy;\n\t\t\t\t\tdouble z2 = r2 - dr2;\n\t\t\t\t\t\n\t\t\t\t\tcurrent_z2 = Math.min(current_z2, z2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max_z2_pos < current_z2){\n\t\t\t\t\tmax_z2_pos = current_z2;\n\t\t\t\t\tsx = move[0] * EPS;\n\t\t\t\t\tsy = move[1] * EPS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(max_z2_pos > z2_pos){\n\t\t\t\tupdated = true;\n\t\t\t\tz2_pos = max_z2_pos;\n\t\t\t\tx_pos += sx;\n\t\t\t\ty_pos += sy;\n\t\t\t}\n\t\t\t\n\t\t\tif(!updated){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal double z_pos = Math.sqrt(z2_pos);\n\t\t//System.out.println(start_pos + \": \" + \"(\" + x_pos + \", \" + y_pos + \", \" + z_pos + \")\");\n\t\treturn z_pos;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Double> xs = new ArrayList<Double>();\n\t\t\tArrayList<Double> ys = new ArrayList<Double>();\n\t\t\tArrayList<Double> rs = new ArrayList<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\txs.add(sc.nextDouble());\n\t\t\t\tys.add(sc.nextDouble());\n\t\t\t\trs.add(sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tdouble z_pos = check(-1, n, xs, ys, rs);\n\t\t\t\n\t\t\tSystem.out.println(z_pos);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static double EPS = 1e-5;\n\t\n\tpublic static int[][] move_dir = new int[][]{\n\t\t{0, 0},\n\t\t{1, 0},\n\t\t{0, 1},\n\t\t//{1, 1},\n\t\t{-1, 0},\n\t\t{0, -1},\n\t\t//{-1, -1}\n\t};\n\t\n\tpublic static double check(final int start_pos, final int n, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tdouble x_pos = start_pos >= 0 ? xs.get(start_pos) : 0;\n\t\tdouble y_pos = start_pos >= 0 ? ys.get(start_pos) : 0;\n\t\t\n\t\tdouble z2_pos = 0;\n\t\twhile(true){\n\t\t\tboolean updated = false;\n\t\t\tdouble max_z2_pos = 0;\n\t\t\tdouble sx = 0, sy = 0;\n\t\t\t\n\t\t\tfor(int move[] : move_dir){\n\t\t\t\tfinal double next_x_pos = x_pos + move[0] * EPS;\n\t\t\t\tfinal double next_y_pos = y_pos + move[1] * EPS;\n\t\t\t\tdouble current_z2 = Double.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfinal double dx = Math.abs((next_x_pos - xs.get(i)));\n\t\t\t\t\tfinal double dy = Math.abs((next_y_pos - ys.get(i)));\n\t\t\t\t\tfinal double r2 = rs.get(i) * rs.get(i);\n\t\t\t\t\tfinal double dr2 = dx * dx + dy * dy;\n\t\t\t\t\tdouble z2 = r2 - dr2;\n\t\t\t\t\t\n\t\t\t\t\tcurrent_z2 = Math.min(current_z2, z2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max_z2_pos < current_z2){\n\t\t\t\t\tmax_z2_pos = current_z2;\n\t\t\t\t\tsx = move[0] * EPS;\n\t\t\t\t\tsy = move[1] * EPS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(max_z2_pos > z2_pos){\n\t\t\t\tupdated = true;\n\t\t\t\tz2_pos = max_z2_pos;\n\t\t\t\tx_pos += sx;\n\t\t\t\ty_pos += sy;\n\t\t\t}\n\t\t\t\n\t\t\tif(!updated){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal double z_pos = Math.sqrt(z2_pos);\n\t\t//System.out.println(start_pos + \": \" + \"(\" + x_pos + \", \" + y_pos + \", \" + z_pos + \")\");\n\t\treturn z_pos;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Double> xs = new ArrayList<Double>();\n\t\t\tArrayList<Double> ys = new ArrayList<Double>();\n\t\t\tArrayList<Double> rs = new ArrayList<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\txs.add(sc.nextDouble());\n\t\t\t\tys.add(sc.nextDouble());\n\t\t\t\trs.add(sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tdouble z_pos = check(-1, n, xs, ys, rs);\n\t\t\t\n\t\t\tSystem.out.println(z_pos);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static Rope[] rope;\n\tpublic static int n;\n\tpublic static double EPS = 1e-8;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\trope = new Rope[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\trope[i] = new Rope(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch());\n\t\t}\n\t}\n\t\n\tpublic static double binarySearch(){\n\t\tdouble max = 300;\n\t\tdouble min = 1;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<100; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double h){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(!rope[i].setR(h)) return false;\n\t\t}\n\t\tQueue<Point> qu = new LinkedList<Point>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tqu.add(new Point(rope[i].x, rope[i].y));\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tPoint[] p = crossPoint(rope[i], rope[j]);\n\t\t\t\tqu.add(p[0]);\n\t\t\t\tqu.add(p[1]);\n\t\t\t}\n\t\t}\n\t\tout: while(!qu.isEmpty()){\n\t\t\tPoint p = qu.poll();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(!cross(rope[i], p)) continue out;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static Point[] crossPoint(Rope r1, Rope r2){\n\t\tdouble x1 = r2.x - r1.x;\n\t\tdouble y1 = r2.y - r1.y;\n\t\tdouble a = (x1*x1+y1*y1+r1.r*r1.r-r2.r*r2.r)/2.0;\n\t\tPoint[] res = {\n\t\t\t\tnew Point(culc(x1, y1, r1.r, a, true)+r1.x, culc(y1, x1, r1.r, a, false)+r1.y),\n\t\t\t\tnew Point(culc(x1, y1, r1.r, a, false)+r1.x, culc(y1, x1, r1.r, a, true)+r1.y),\n\t\t};\n\t\treturn res;\n\t}\n\t\n\tpublic static double culc(double x, double y, double r, double a, boolean sign){\n\t\treturn (a*x + (sign?1:-1)*y*Math.sqrt((x*x+y*y)*r*r-a*a))/(x*x+y*y);\n\t}\n\t\n\tpublic static boolean cross(Rope rp, Point p){\n\t\treturn dist2(rp.x, rp.y, p.x, p.y) <= rp.r*rp.r+EPS;\n\t}\n\t\n\tpublic static boolean cross(Rope r1, Rope r2){\n\t\treturn dist2(r1.x, r1.y, r2.x, r2.y) <= (r1.r + r2.r)*(r1.r + r2.r);\n\t}\n\t\n\tpublic static double dist2(double x1, double y1, double x2, double y2){\n\t\treturn (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n\t}\n}\n\nclass Point{\n\tdouble x, y;\n\tpublic Point(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Rope{\n\tint x, y, l;\n\tdouble r;\n\tpublic Rope(int x, int y, int l){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.l = l;\n\t\tr = 0;\n\t}\n\t\n\tpublic boolean setR(double h){\n\t\tif(h > l) return false;\n\t\tr =  Math.sqrt(l*l-h*h);\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic int n;\n\tstatic double[] x;\n\tstatic double[] y;\n\tstatic double[] l;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tl = new double[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tl[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tdouble xl = -100;\n\t\t\tdouble xr = 100;\n\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tdouble mxl = (2 * xl + xr) / 3;\n\t\t\t\tdouble mxr = (xl + 2 * xr) / 3;\n\t\t\t\tdouble Lmxl = len(mxl);\n\t\t\t\tdouble Lmxr = len(mxr);\n\t\t\t\tif (Lmxl < Lmxr) {\n\t\t\t\t\txl = mxl;\n\t\t\t\t} else {\n\t\t\t\t\txr = mxr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(Math.sqrt(len(xl)));\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic double len(double x) {\n\t\tdouble yl = -100;\n\t\tdouble yr = 100;\n\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tdouble myl = (2 * yl + yr) / 3;\n\t\t\tdouble myr = (yl + 2 * yr) / 3;\n\t\t\tdouble Lmyl = calc(x, myl);\n\t\t\tdouble Lmyr = calc(x, myr);\n\t\t\tif (Lmyl < Lmyr) {\n\t\t\t\tyl = myl;\n\t\t\t} else {\n\t\t\t\tyr = myr;\n\t\t\t}\n\t\t}\n\t\treturn calc(x, yl);\n\t}\n\n\tstatic double calc(double cx, double cy) {\n\t\tdouble len2 = Double.MAX_VALUE / 4;// (x-xi)^2+(y-yi)^2+z^2<=li^2\n\t\t// z^2<=li^2-(x-xi)^2-(y-yi)^2\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlen2 = Math.min(len2, l[i] * l[i] - (cx - x[i]) * (cx - x[i]) - (cy - y[i]) * (cy - y[i]));\n\t\t}\n\t\treturn len2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static double EPS = 1e-5;\n\t\n\tpublic static int[][] move_dir = new int[][]{\n\t\t{0, 0},\n\t\t{1, 0},\n\t\t{0, 1},\n\t\t//{1, 1},\n\t\t{-1, 0},\n\t\t{0, -1},\n\t\t//{-1, -1}\n\t};\n\t\n\tpublic static double max_z2(final int n, final double x, final double y, final double sx, final double sy, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tfinal double next_x_pos = x + sx;\n\t\tfinal double next_y_pos = y + sy;\n\t\tdouble current_z2 = Double.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal double dx = Math.abs((next_x_pos - xs.get(i)));\n\t\t\tfinal double dy = Math.abs((next_y_pos - ys.get(i)));\n\t\t\tfinal double r2 = rs.get(i) * rs.get(i);\n\t\t\tfinal double dr2 = dx * dx + dy * dy;\n\t\t\tdouble z2 = r2 - dr2;\n\t\t\t\n\t\t\tcurrent_z2 = Math.min(current_z2, z2);\n\t\t}\n\t\t\n\t\treturn current_z2;\n\t}\n\t\n\tpublic static double check(final int start_pos, final int n, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tdouble x_pos = start_pos >= 0 ? xs.get(start_pos) : 0;\n\t\tdouble y_pos = start_pos >= 0 ? ys.get(start_pos) : 0;\n\t\t\n\t\tdouble z2_pos = 0;\n\t\twhile(true){\n\t\t\tdouble max_z2_pos = 0;\n\t\t\tdouble sx = 0, sy = 0;\n\t\t\t\n\t\t\tfor(int move[] : move_dir){\n\t\t\t\tfinal double _sx = move[0] * EPS;\n\t\t\t\tfinal double _sy = move[1] * EPS;\n\t\t\t\tfinal double current_z2 = max_z2(n, x_pos, y_pos, _sx, _sy, xs, ys, rs);\n\t\t\t\t\n\t\t\t\tif(max_z2_pos < current_z2){\n\t\t\t\t\tmax_z2_pos = current_z2;\n\t\t\t\t\tsx = move[0] * EPS;\n\t\t\t\t\tsy = move[1] * EPS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(max_z2_pos <= z2_pos){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tfinal double next_z2 = max_z2(n, x_pos, y_pos, sx * 2, sy * 2, xs, ys, rs);\n\t\t\t\t//System.out.println(next_z2);\n\t\t\t\tif(next_z2 <= max_z2_pos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsx *= 2;\n\t\t\t\tsy *= 2;\n\t\t\t\tmax_z2_pos = next_z2;\n\t\t\t}\n\t\t\t\n\t\t\tz2_pos = max_z2_pos;\n\t\t\tx_pos += sx;\n\t\t\ty_pos += sy;\n\t\t}\n\t\t\n\t\tfinal double z_pos = Math.sqrt(z2_pos);\n\t\t//System.out.println(start_pos + \": \" + \"(\" + x_pos + \", \" + y_pos + \", \" + z_pos + \")\");\n\t\treturn z_pos;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Double> xs = new ArrayList<Double>();\n\t\t\tArrayList<Double> ys = new ArrayList<Double>();\n\t\t\tArrayList<Double> rs = new ArrayList<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\txs.add(sc.nextDouble());\n\t\t\t\tys.add(sc.nextDouble());\n\t\t\t\trs.add(sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tdouble z_pos = check(-1, n, xs, ys, rs);\n\t\t\t\n\t\t\tSystem.out.println(z_pos);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static double EPS = 1e-7;\n\t\n\tpublic static int[][] move_dir = new int[][]{\n\t\t{0, 0},\n\t\t{1, 0},\n\t\t{0, 1},\n\t\t//{1, 1},\n\t\t{-1, 0},\n\t\t{0, -1},\n\t\t//{-1, -1}\n\t};\n\t\n\tpublic static double max_z2(final int n, final double x, final double y, final double sx, final double sy, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tfinal double next_x_pos = x + sx;\n\t\tfinal double next_y_pos = y + sy;\n\t\tdouble current_z2 = Double.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal double dx = Math.abs((next_x_pos - xs.get(i)));\n\t\t\tfinal double dy = Math.abs((next_y_pos - ys.get(i)));\n\t\t\tfinal double r2 = rs.get(i) * rs.get(i);\n\t\t\tfinal double dr2 = dx * dx + dy * dy;\n\t\t\tdouble z2 = r2 - dr2;\n\t\t\t\n\t\t\tcurrent_z2 = Math.min(current_z2, z2);\n\t\t}\n\t\t\n\t\treturn current_z2;\n\t}\n\t\n\tpublic static double check(final int start_pos, final int n, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tdouble x_pos = start_pos >= 0 ? xs.get(start_pos) : 0;\n\t\tdouble y_pos = start_pos >= 0 ? ys.get(start_pos) : 0;\n\t\t\n\t\tdouble z2_pos = 0;\n\t\twhile(true){\n\t\t\tdouble max_z2_pos = 0;\n\t\t\tdouble sx = 0, sy = 0;\n\t\t\t\n\t\t\tfor(int move[] : move_dir){\n\t\t\t\tfinal double _sx = move[0] * EPS;\n\t\t\t\tfinal double _sy = move[1] * EPS;\n\t\t\t\tfinal double current_z2 = max_z2(n, x_pos, y_pos, _sx, _sy, xs, ys, rs);\n\t\t\t\t\n\t\t\t\tif(max_z2_pos < current_z2){\n\t\t\t\t\tmax_z2_pos = current_z2;\n\t\t\t\t\tsx = move[0] * EPS;\n\t\t\t\t\tsy = move[1] * EPS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(max_z2_pos <= z2_pos){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tfinal double next_z2 = max_z2(n, x_pos, y_pos, sx * 2, sy * 2, xs, ys, rs);\n\t\t\t\t//System.out.println(next_z2);\n\t\t\t\tif(next_z2 <= max_z2_pos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsx *= 2;\n\t\t\t\tsy *= 2;\n\t\t\t\tmax_z2_pos = next_z2;\n\t\t\t}\n\t\t\t\n\t\t\tz2_pos = max_z2_pos;\n\t\t\tx_pos += sx;\n\t\t\ty_pos += sy;\n\t\t}\n\t\t\n\t\tfinal double z_pos = Math.sqrt(z2_pos);\n\t\t//System.out.println(start_pos + \": \" + \"(\" + x_pos + \", \" + y_pos + \", \" + z_pos + \")\");\n\t\treturn z_pos;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Double> xs = new ArrayList<Double>();\n\t\t\tArrayList<Double> ys = new ArrayList<Double>();\n\t\t\tArrayList<Double> rs = new ArrayList<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\txs.add(sc.nextDouble());\n\t\t\t\tys.add(sc.nextDouble());\n\t\t\t\trs.add(sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tdouble z_pos = check(-1, n, xs, ys, rs);\n\t\t\t\n\t\t\tSystem.out.printf(\"%.9f\\n\", z_pos);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static int[][] rope = new int[10][3];\n    static int[][] acute = new int[10][10];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true){\n            n = sc.nextInt();\n            if(n==0) break;\n\n            for (int i = 0; i < n; i++) {\n                rope[i][0] = sc.nextInt();\n                rope[i][1] = sc.nextInt();\n                rope[i][2] = sc.nextInt();\n            }\n\n           System.out.println(maxHeight());\n        }\n    }\n\n    static double maxHeight() {\n        double max = 0;\n\n        for (int i = 0; i < n; i++) {\n            if(check((double)rope[i][0], (double)rope[i][1], (double)rope[i][2])){\n                max = Math.max(rope[i][2], max);\n            }\n        }\n\n        if (n>=2){\n            for (int i = 0; i < n; i++) {\n                for (int j = i+1; j < n; j++) {\n                    max = Math.max(max, height1(i, j));\n                }\n            }\n        }\n\n        if (n>=3){\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    for (int k = j + 1; k < n; k++) {\n                        max = Math.max(max, height2(i, j, k));\n                    }\n                }\n            }\n        }\n\n        return max;\n    }\n\n    static boolean check(double x, double y, double z) {\n        boolean ok = true;\n        for (int i = 0; i < n; i++) {\n            if(distance(i, x, y, z)-rope[i][2]*rope[i][2]>0.000000001) ok = false;\n        }\n        return ok;\n    }\n\n    static double distance(int i, double x, double y, double z) {\n        return (rope[i][0]-x)*(rope[i][0]-x)+(rope[i][1]-y)*(rope[i][1]-y)+z*z;\n    }\n\n    static double height1(int i, int j){\n        double a = Math.sqrt((rope[i][0]-rope[j][0])*(rope[i][0]-rope[j][0])\n                                +(rope[i][1]-rope[j][1])*(rope[i][1]-rope[j][1]));\n        if((rope[i][2]+rope[j][2])-a>0 && (rope[i][2]+a)-rope[j][2]>0 && (a+rope[j][2])-rope[i][2]>0){\n            double d = (rope[i][2]*rope[i][2]+a*a-rope[j][2]*rope[j][2])/(2*a);\n            double x = (d/a)*rope[j][0]+((a-d)/a)*rope[i][0];\n            double y = (d/a)*rope[j][1]+((a-d)/a)*rope[i][1];\n            double z = Math.sqrt(rope[i][2]*rope[i][2]-d*d);\n            if (check(x, y, z)){\n                return z;\n            }\n        }\n        return 0;\n    }\n\n    static double height2(int i, int j, int k) {\n        double a1 = 2*(rope[j][0]-rope[i][0]), a2 = 2*(rope[k][0]-rope[i][0]);\n        double b1 = 2*(rope[j][1]-rope[i][1]), b2 = 2*(rope[k][1]-rope[i][1]);\n        double e1 = rope[i][2]*rope[i][2]-rope[j][2]*rope[j][2]\n                    -(rope[i][0]+rope[j][0])*(rope[i][0]-rope[j][0])\n                    -(rope[i][1]+rope[j][1])*(rope[i][1]-rope[j][1]),\n                e2 = rope[i][2]*rope[i][2]-rope[k][2]*rope[k][2]\n                    -(rope[i][0]+rope[k][0])*(rope[i][0]-rope[k][0])\n                    -(rope[i][1]+rope[k][1])*(rope[i][1]-rope[k][1]);\n        if (a1*b2-b1*a2!=0 && a1*b2-a2*b1!=0) {\n            double x = (e1 * b2 - b1 * e2) / (a1 * b2 - b1 * a2);\n            double y = (e2 * a1 - e1 * a2) / (a1 * b2 - a2 * b1);\n            double z = rope[i][2] * rope[i][2] - (x - rope[i][0]) * (x - rope[i][0])\n                                                - (y - rope[i][1]) * (y - rope[i][1]);\n            if (z>0) {\n                z = Math.sqrt(z);\n                if (check(x, y, z)) return z;\n            }\n        }\n        return 0;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static double EPS = 1e-3;\n\t\n\tpublic static int[][] move_dir = new int[][]{\n\t\t{0, 0},\n\t\t{1, 0},\n\t\t{0, 1},\n\t\t//{1, 1},\n\t\t{-1, 0},\n\t\t{0, -1},\n\t\t//{-1, -1}\n\t};\n\t\n\tpublic static double check(final int start_pos, final int n, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tdouble x_pos = start_pos >= 0 ? xs.get(start_pos) : 0;\n\t\tdouble y_pos = start_pos >= 0 ? ys.get(start_pos) : 0;\n\t\t\n\t\tdouble z2_pos = 0;\n\t\twhile(true){\n\t\t\tboolean updated = false;\n\t\t\tdouble max_z2_pos = 0;\n\t\t\tdouble sx = 0, sy = 0;\n\t\t\t\n\t\t\tfor(int move[] : move_dir){\n\t\t\t\tfinal double next_x_pos = x_pos + move[0] * EPS;\n\t\t\t\tfinal double next_y_pos = y_pos + move[1] * EPS;\n\t\t\t\tdouble current_z2 = Double.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfinal double dx = Math.abs((next_x_pos - xs.get(i)));\n\t\t\t\t\tfinal double dy = Math.abs((next_y_pos - ys.get(i)));\n\t\t\t\t\tfinal double r2 = rs.get(i) * rs.get(i);\n\t\t\t\t\tfinal double dr2 = dx * dx + dy * dy;\n\t\t\t\t\tdouble z2 = r2 - dr2;\n\t\t\t\t\t\n\t\t\t\t\tcurrent_z2 = Math.min(current_z2, z2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max_z2_pos < current_z2){\n\t\t\t\t\tmax_z2_pos = current_z2;\n\t\t\t\t\tsx = move[0] * EPS;\n\t\t\t\t\tsy = move[1] * EPS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(max_z2_pos > z2_pos){\n\t\t\t\tupdated = true;\n\t\t\t\tz2_pos = max_z2_pos;\n\t\t\t\tx_pos += sx;\n\t\t\t\ty_pos += sy;\n\t\t\t}\n\t\t\t\n\t\t\tif(!updated){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal double z_pos = Math.sqrt(z2_pos);\n\t\t//System.out.println(start_pos + \": \" + \"(\" + x_pos + \", \" + y_pos + \", \" + z_pos + \")\");\n\t\treturn z_pos;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Double> xs = new ArrayList<Double>();\n\t\t\tArrayList<Double> ys = new ArrayList<Double>();\n\t\t\tArrayList<Double> rs = new ArrayList<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\txs.add(sc.nextDouble());\n\t\t\t\tys.add(sc.nextDouble());\n\t\t\t\trs.add(sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tdouble z_pos = check(-1, n, xs, ys, rs);\n\t\t\t\n\t\t\tSystem.out.println(z_pos);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static double EPS = 1e-7;\n\t\n\tpublic static int[][] move_dir = new int[][]{\n\t\t{0, 0},\n\t\t{1, 0},\n\t\t{0, 1},\n\t\t//{1, 1},\n\t\t{-1, 0},\n\t\t{0, -1},\n\t\t//{-1, -1}\n\t};\n\t\n\tpublic static double max_z2(final int n, final double x, final double y, final double sx, final double sy, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tfinal double next_x_pos = x + sx;\n\t\tfinal double next_y_pos = y + sy;\n\t\tdouble current_z2 = Double.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal double dx = Math.abs((next_x_pos - xs.get(i)));\n\t\t\tfinal double dy = Math.abs((next_y_pos - ys.get(i)));\n\t\t\tfinal double r2 = rs.get(i) * rs.get(i);\n\t\t\tfinal double dr2 = dx * dx + dy * dy;\n\t\t\tdouble z2 = r2 - dr2;\n\t\t\t\n\t\t\tcurrent_z2 = Math.min(current_z2, z2);\n\t\t}\n\t\t\n\t\treturn current_z2;\n\t}\n\t\n\tpublic static double check(final int start_pos, final int n, ArrayList<Double> xs, ArrayList<Double> ys, ArrayList<Double> rs){\n\t\tdouble x_pos = start_pos >= 0 ? xs.get(start_pos) : 0;\n\t\tdouble y_pos = start_pos >= 0 ? ys.get(start_pos) : 0;\n\t\t\n\t\tdouble z2_pos = 0;\n\t\twhile(true){\n\t\t\tdouble max_z2_pos = 0;\n\t\t\tdouble sx = 0, sy = 0;\n\t\t\t\n\t\t\tfor(int move[] : move_dir){\n\t\t\t\tfinal double _sx = move[0] * EPS;\n\t\t\t\tfinal double _sy = move[1] * EPS;\n\t\t\t\tfinal double current_z2 = max_z2(n, x_pos, y_pos, _sx, _sy, xs, ys, rs);\n\t\t\t\t\n\t\t\t\tif(max_z2_pos < current_z2){\n\t\t\t\t\tmax_z2_pos = current_z2;\n\t\t\t\t\tsx = move[0] * EPS;\n\t\t\t\t\tsy = move[1] * EPS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(max_z2_pos <= z2_pos){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tfinal double next_z2 = max_z2(n, x_pos, y_pos, sx * 2, sy * 2, xs, ys, rs);\n\t\t\t\t//System.out.println(next_z2);\n\t\t\t\tif(next_z2 <= max_z2_pos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsx *= 2;\n\t\t\t\tsy *= 2;\n\t\t\t\tmax_z2_pos = next_z2;\n\t\t\t}\n\t\t\t\n\t\t\tz2_pos = max_z2_pos;\n\t\t\tx_pos += sx;\n\t\t\ty_pos += sy;\n\t\t}\n\t\t\n\t\tfinal double z_pos = Math.sqrt(z2_pos);\n\t\t//System.out.println(start_pos + \": \" + \"(\" + x_pos + \", \" + y_pos + \", \" + z_pos + \")\");\n\t\treturn z_pos;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Double> xs = new ArrayList<Double>();\n\t\t\tArrayList<Double> ys = new ArrayList<Double>();\n\t\t\tArrayList<Double> rs = new ArrayList<Double>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\txs.add(sc.nextDouble());\n\t\t\t\tys.add(sc.nextDouble());\n\t\t\t\trs.add(sc.nextDouble());\n\t\t\t}\n\t\t\t\n\t\t\tdouble z_pos = check(-1, n, xs, ys, rs);\n\t\t\t\n\t\t\tSystem.out.println(z_pos);\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = ir.nextIntArray(3);\n\t\t\tdouble lb = -150, ub = 150;\n\t\t\tfor (int i = 0; i < 100; i++) {\n\t\t\t\tdouble l = (lb * 2 + ub) / 3.0;\n\t\t\t\tdouble r = (lb + ub * 2) / 3.0;\n\t\t\t\tif (g(l, a) >= g(r, a))\n\t\t\t\t\tub = r;\n\t\t\t\telse\n\t\t\t\t\tlb = l;\n\t\t\t}\n\t\t\tout.println(Math.sqrt(g(ub, a)));\n\t\t}\n\t}\n\n\tstatic double g(double x, int[][] a) {\n\t\tdouble lb = -150, ub = 150;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tdouble l = (lb * 2 + ub) / 3.0;\n\t\t\tdouble r = (lb + ub * 2) / 3.0;\n\t\t\tif (f(x, l, a) >= f(x, r, a))\n\t\t\t\tub = r;\n\t\t\telse\n\t\t\t\tlb = l;\n\t\t}\n\t\treturn f(x, ub, a);\n\t}\n\n\tstatic double f(double x, double y, int[][] a) {\n\t\tdouble ret = 1e9;\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\tret = Math.min(ret,\n\t\t\t\t\t(double) a[i][2] * a[i][2] - (a[i][0] - x) * (a[i][0] - x) - (a[i][1] - y) * (a[i][1] - y));\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tdouble[] xs, ys, ls;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txs=new double[n];\n\t\t\tys=new double[n];\n\t\t\tls=new double[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\txs[i]=sc.nextInt();\n\t\t\t\tys[i]=sc.nextInt();\n\t\t\t\tls[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tdouble max;\n\n\tvoid solve(){\n\t\tmax=0;\n\t\t// 1点\n\t\tfor(int i=0; i<n; i++){\n\t\t\tupdate(xs[i], ys[i]);\n\t\t}\n\t\t// 2点\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tdouble[] pin=pin(i, j);\n\t\t\t\tupdate(pin[0], pin[1]);\n\t\t\t}\n\t\t}\n\t\t// 3点\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\tfor(int k=j+1; k<n; k++){\n\t\t\t\t\t// debug(i,j,k);\n\t\t\t\t\tdouble[] pin1=pin(i, j);\n\t\t\t\t\tdouble[] pin2=pin(j, k);\n\t\t\t\t\t// debug(i, j, pin1, j, k, pin2);\n\t\t\t\t\tdouble px1=pin1[0];\n\t\t\t\t\tdouble py1=pin1[1];\n\t\t\t\t\tdouble px2=px1+(ys[j]-ys[i]);\n\t\t\t\t\tdouble py2=py1-(xs[j]-xs[i]);\n\n\t\t\t\t\tdouble qx1=pin2[0];\n\t\t\t\t\tdouble qy1=pin2[1];\n\t\t\t\t\tdouble qx2=qx1+(ys[k]-ys[j]);\n\t\t\t\t\tdouble qy2=qy1-(xs[k]-xs[j]);\n\n\t\t\t\t\tdouble[] cross=cross(px1, py1, px2, py2, qx1, qy1, qx2, qy2);\n\t\t\t\t\t// debug(cross);\n\t\t\t\t\tupdate(cross[0], cross[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug(max);\n\t\tprintln(String.format(\"%.20f\", max));\n\t}\n\n\tdouble[] cross(double px1, double py1, double px2, double py2, double qx1,\n\t\t\tdouble qy1, double qx2, double qy2){\n\t\t// debug(px1, py1, px2, py2, qx1, qy1, qx2, qy2);\n\t\tdouble det=det(qx2-qx1, qy2-qy1, px2-px1, py2-py1);\n\t\tif(abs(det)<EPS){\n\t\t\treturn new double[]{0, 0};\n\t\t}\n\t\tdouble det2=det(qx2-qx1, qy2-qy1, qx1-px1, qy1-py1);\n\t\tdouble x=px1+(px2-px1)*det2/det;\n\t\tdouble y=py1+(py2-py1)*det2/det;\n\t\treturn new double[]{x, y};\n\t}\n\n\tdouble det(double x1, double y1, double x2, double y2){\n\t\treturn x1*y2-x2*y1;\n\t}\n\n\tdouble[] pin(int i, int j){\n\t\tdouble ratio=(1+(sq(ls[i])-sq(ls[j]))\n\t\t\t\t/sq(hypot(xs[i]-xs[j], ys[i]-ys[j])))/2.0;\n\t\t// debug(\"pin\", i, j, ratio);\n\t\tdouble x=xs[i]+(xs[j]-xs[i])*ratio;\n\t\tdouble y=ys[i]+(ys[j]-ys[i])*ratio;\n\t\treturn new double[]{x, y};\n\t}\n\n\tvoid update(double x, double y){\n\t\tdouble min=Double.MAX_VALUE;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmin=min(min, sqrt(max(sq(ls[i])-sq(hypot(xs[i]-x, ys[i]-y)), 0)));\n\t\t}\n\t\t// debug(x, y, min);\n\t\tmax=max(max, min);\n\t}\n\n\tdouble sq(double x){\n\t\treturn x*x;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic double[] x;\n\tstatic double[] y;\n\tstatic double[] l;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\tl = new double[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tl[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tdouble xl = -100;\n\t\t\tdouble xr = 100;\n\n\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\tdouble mxl = (2 * xl + xr) / 3;\n\t\t\t\tdouble mxr = (xl + 2 * xr) / 3;\n\t\t\t\tdouble Lmxl = len(mxl);\n\t\t\t\tdouble Lmxr = len(mxr);\n\t\t\t\tif (Lmxl < Lmxr) {\n\t\t\t\t\txl = mxl;\n\t\t\t\t} else {\n\t\t\t\t\txr = mxr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(Math.sqrt(len(xl)));\n\t\t}\n\t\tsc.close();\n\t\tpw.close();\n\t}\n\n\tstatic double len(double x) {\n\t\tdouble yl = -100;\n\t\tdouble yr = 100;\n\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tdouble myl = (2 * yl + yr) / 3;\n\t\t\tdouble myr = (yl + 2 * yr) / 3;\n\t\t\tdouble Lmyl = calc(x, myl);\n\t\t\tdouble Lmyr = calc(x, myr);\n\t\t\tif (Lmyl < Lmyr) {\n\t\t\t\tyl = myl;\n\t\t\t} else {\n\t\t\t\tyr = myr;\n\t\t\t}\n\t\t}\n\t\treturn calc(x, yl);\n\t}\n\n\tstatic double calc(double cx, double cy) {\n\t\tdouble len2 = Double.MAX_VALUE / 4;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlen2 = Math.min(len2, l[i] * l[i] - (cx - x[i]) * (cx - x[i]) - (cy - y[i]) * (cy - y[i]));\n\t\t}\n\t\treturn len2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        AnchoredBalloon solver = new AnchoredBalloon();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AnchoredBalloon {\n        private static final double EPS = 1e-5;\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int n = in.ints();\n            int testcase = 0;\n            while (n > 0) {\n                AnchoredBalloon.Point[] points = new AnchoredBalloon.Point[n];\n                double ans = 1e5;\n                for (int i = 0; i < n; i++) {\n                    points[i] = new AnchoredBalloon.Point(in.doubles(), in.doubles(), in.doubles());\n                    ans = Math.min(ans, points[i].r);\n                }\n\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < i; j++) {\n                        AnchoredBalloon.Point p1 = points[i], p2 = points[j];\n                        double dp = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);\n                        double d = Math.sqrt(Math.max(dp, 0));\n                        double r1p = Math.pow(p1.r, 2), r2p = Math.pow(p2.r, 2);\n                        if (r1p > dp + r2p + EPS || r2p > dp + r1p + EPS) {\n                            continue;\n                        }\n\n                        double w1 = (dp + (p1.r * p1.r) - (p2.r * p2.r)) / (2 * d);\n                        double hp = p1.r * p1.r - w1 * w1;\n                        double h = Math.sqrt(Math.max(0, hp));\n                        ans = Math.min(ans, h);\n                    }\n                }\n\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < i; j++) {\n                        outer:\n                        for (int k = 0; k < j; k++) {\n                            AnchoredBalloon.Point[] p = {points[i], points[j], points[k]};\n                            double[] c = new double[3];\n                            for (int l = 0; l < 3; l++) c[l] = p[l].r * p[l].r - p[l].x * p[l].x - p[l].y * p[l].y;\n                            double det = (p[0].x - p[1].x) * (p[1].y - p[2].y) - (p[1].x - p[2].x) * (p[0].y - p[1].y);\n                            double x = (p[1].y - p[2].y) * (c[1] - c[0]) + (p[1].y - p[0].y) * (c[2] - c[1]);\n                            double y = (p[2].x - p[1].x) * (c[1] - c[0]) + (p[0].x - p[1].x) * (c[2] - c[1]);\n                            if (Math.abs(det) < EPS) {\n                                continue;\n                            }\n\n                            x /= 2 * det;\n                            y /= 2 * det;\n                            double hPow = Math.pow(p[0].r, 2) - Math.pow(x - p[0].x, 2) - Math.pow(y - p[0].y, 2);\n                            if (hPow < -EPS) {\n                                continue;\n                            }\n\n                            double[] oc = new double[3];\n                            for (int l = 0; l < 3; l++) {\n                                double x1 = p[(l + 1) % 3].x - p[l].x, x2 = x - p[l].x;\n                                double y1 = p[(l + 1) % 3].y - p[l].y, y2 = y - p[l].y;\n                                oc[l] = x1 * y2 - x2 * y1;\n                            }\n                            for (int l = 0; l < 3; l++) {\n                                if (Math.abs(oc[l]) < EPS) {\n                                    continue outer;\n                                }\n                            }\n                            for (int l = 0; l < 2; l++) {\n                                if ((oc[l] < -EPS) != (oc[l + 1] < -EPS)) {\n                                    continue outer;\n                                }\n                            }\n\n                            double h = Math.sqrt(Math.max(0, hPow));\n                            ans = Math.min(ans, h);\n                        }\n                    }\n                }\n\n                out.ansln(ans);\n                n = in.ints();\n                testcase++;\n            }\n        }\n\n        private static class Point {\n            double x;\n            double y;\n            double r;\n\n            public Point(double x, double y, double r) {\n                this.x = x;\n                this.y = y;\n                this.r = r;\n            }\n\n            public String toString() {\n                return \"Point{\" +\n                        \"x=\" + x +\n                        \", y=\" + y +\n                        \", r=\" + r +\n                        '}';\n            }\n\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private static final int DEFAULT_DOUBLE_ACC = 9;\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(double x, int n) {\n            if (!breaked) {\n                print(' ');\n            }\n            if (x < 0) {\n                print('-');\n                x = -x;\n            }\n            x += Math.pow(10, -n) / 2;\n            print(Long.toString((long) x)).print('.');\n            x -= (long) x;\n            for (int i = 0; i < n; i++) {\n                x *= 10;\n                print((char) ('0' + ((int) x)));\n                x -= (int) x;\n            }\n            return this;\n        }\n\n        public LightWriter ansln(int n, double... x) {\n            for (double x1 : x) {\n                ans(x1, n).ln();\n            }\n            return this;\n        }\n\n        public LightWriter ansln(double... x) {\n            return ansln(DEFAULT_DOUBLE_ACC, x);\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n        public double doubles() {\n            return Double.parseDouble(string());\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static Rope[] rope;\n\tpublic static int n;\n\tpublic static double EPS = 1e-9;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\trope = new Rope[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\trope[i] = new Rope(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch());\n\t\t}\n\t}\n\t\n\tpublic static double binarySearch(){\n\t\tdouble max = 300;\n\t\tdouble min = 1;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<100; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double h){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(!rope[i].setR(h)) return false;\n\t\t}\n\t\tQueue<Point> qu = new LinkedList<Point>();\n\t\tqu.add(new Point(rope[0].x, rope[0].y));\n\t\tfor(int i=1; i<n; i++){\n\t\t\tqu.add(new Point(rope[i].x, rope[i].y));\n\t\t\tPoint[] p = crossPoint(rope[i], rope[i-1]);\n\t\t\tqu.add(p[0]);\n\t\t\tqu.add(p[1]);\n\t\t}\n\t\tout: while(!qu.isEmpty()){\n\t\t\tPoint p = qu.poll();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(!cross(rope[i], p)) continue out;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static Point[] crossPoint(Rope r1, Rope r2){\n\t\tdouble x1 = r2.x - r1.x;\n\t\tdouble y1 = r2.y - r1.y;\n\t\tdouble a = (x1*x1+y1*y1+r1.r*r1.r-r2.r*r2.r)/2.0;\n\t\tPoint[] res = {\n\t\t\t\tnew Point(culc(x1, y1, r1.r, a, true)+r1.x, culc(y1, x1, r1.r, a, false)+r1.y),\n\t\t\t\tnew Point(culc(x1, y1, r1.r, a, false)+r1.x, culc(y1, x1, r1.r, a, true)+r1.y),\n\t\t};\n\t\treturn res;\n\t}\n\t\n\tpublic static double culc(double x, double y, double r, double a, boolean sign){\n\t\treturn (a*x + (sign?1:-1)*y*Math.sqrt((x*x+y*y)*r*r-a*a))/(x*x+y*y);\n\t}\n\t\n\tpublic static boolean cross(Rope rp, Point p){\n\t\treturn dist2(rp.x, rp.y, p.x, p.y) <= rp.r*rp.r+EPS;\n\t}\n\t\n\tpublic static boolean cross(Rope r1, Rope r2){\n\t\treturn dist2(r1.x, r1.y, r2.x, r2.y) <= (r1.r + r2.r)*(r1.r + r2.r);\n\t}\n\t\n\tpublic static double dist2(double x1, double y1, double x2, double y2){\n\t\treturn (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n\t}\n}\n\nclass Point{\n\tdouble x, y;\n\tpublic Point(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Rope{\n\tint x, y, l;\n\tdouble r;\n\tpublic Rope(int x, int y, int l){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.l = l;\n\t\tr = 0;\n\t}\n\t\n\tpublic boolean setR(double h){\n\t\tif(h > l) return false;\n\t\tr =  Math.sqrt(l*l-h*h);\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-10\nX, Y, L = 0, 1, 2\n\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\nend\n\nclass Circle\n  include Comparable\n  attr_accessor :x, :y, :r\n  def initialize(x=0.0, y=0.0, r=1.0)\n    @x, @y, @r = x.to_f, y.to_f, r.to_f\n  end\n  def <=>(c)\n    @x!=c.x ? @x<=>c.x : (@y!=c.y ? @y<=>c.y : @r<=>c.r)\n  end\n  def point\n    Point.new(@x, @y)\n  end\n  def distance(c)\n    (point-c.point).abs\n  end\n  def include?(p)\n    (point-p).abs - @r <= EPS\n  end\n  def in?(c)\n    distance(c) - (@r-c.r).abs < EPS\n  end\n  def touch?(c)\n    distance(c) <= @r + c.r\n  end\n  def crossPoint(c)\n    angle = Math::atan2(c.y-@y, c.x-@x)\n    d = distance(c)\n    add = Math::acos((d**2 + @r**2 - c.r**2) / (2.0*d*@r))\n    p1 = Point.new(@x+@r*Math::cos(angle+add), @y+@r*Math::sin(angle+add))\n    p2 = Point.new(@x+@r*Math::cos(angle-add), @y+@r*Math::sin(angle-add))\n    [p1, p2]\n  end\nend\n\ndef check(height)\n  result = false\n  circle = Array.new\n  @rope.each do |rope|\n    return false if rope[L] < height\n    circle.push(Circle.new(rope[X], rope[Y], Math::sqrt(rope[L]**2-height**2)))\n  end\n  crossPoint = Array.new\n  circle.each do |c1|\n    crossPoint.push(c1.point)\n    circle.each do |c2|\n      next if c1 == c2\n      next if c1.in?(c2)\n      next unless c1.touch?(c2)\n      crossPoint.push(*c1.crossPoint(c2))\n    end\n  end\n  crossPoint.each do |p|\n    ok = true\n    circle.each do |c|\n      ok = false unless c.include?(p)\n    end\n    result = true if ok\n  end\n  result\nend\n\nuntil (@n=gets.to_i).zero?\n  @rope = Array.new\n  @n.times {@rope.push(gets.split.map(&:to_f))}\n  mid = 0.0\n  low = 0.0\n  high = 300.0\n  until high-low < EPS\n    mid = (high+low) / 2.0\n    case check(mid)\n      when true\n        low = mid\n        answer = mid\n      when false\n        high = mid\n    end\n  end\n  p mid\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nEPS = 0.0000001\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tanchors = (1..n).map{gets.split.map &:to_f}\n\tmin = Float::INFINITY\n\t\n\tanchors.each do |x, y, z|\n\t\tif anchors.all?{|a, b, r| (x-a)**2 + (y-b)**2 + z**2 <= r**2 + EPS}\n\t\t\tmin = z if z < min\n\t\tend\n\tend\n\t\n\tanchors.combination(2) do |u, v|\n\t\tu, v = v, u if u[-1] < v[-1]\n\t\t(a1, b1, r1), (a2, b2, r2) = u, v\n\t\td = Math.hypot(a1-a2, b1-b2)\n\t\tl = (d + (r1**2 - r2**2) / d) / 2\n\t\tq = l / d\n\t\tnext if q < 0 || 1 < q\n\t\tx = (1-q)*a1 + q*a2\t\t\n\t\ty = (1-q)*b1 + q*b2\n\t\tz = sqrt(r1**2 - (x-a1)**2 - (y-b1)**2)\n\t\tif anchors.all?{|a, b, r| (x-a)**2 + (y-b)**2 + z**2 <= r**2 + EPS}\n\t\t\tmin = z if z < min\n\t\tend\n\tend\n\t\n\tanchors.combination(3) do |u, v, w|\n\t\t(a1, b1, r1), (a2, b2, r2), (a3, b3, r3) = u, v, w\n\t\n\t\tmat = Matrix[\n\t\t\t[2*(a1-a2), 2*(b1-b2)],\n\t\t\t[2*(a2-a3), 2*(b2-b3)]\n\t\t\t]\n\t\tnext if mat.singular?\n\t\n\t\tv = Vector[\n\t\t\tr2**2 - r1**2 + a1**2 - a2**2 + b1**2 - b2**2,\n\t\t\tr3**2 - r2**2 + a2**2 - a3**2 + b2**2 - b3**2\n\t\t\t]\n\t\n\t\tx, y =  *(mat.inv * v)\n\t\td = r1**2 - (x-a1)**2 - (y-b1)**2\n\t\tnext if d < 0\n\t\tz = sqrt(d)\n\t\n\t\tif anchors.all?{|a, b, r| (x-a)**2 + (y-b)**2 + z**2 <= r**2 + EPS}\n\t\t\tmin = z if z < min\n\t\tend\n\tend\n\tp min\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = Float::INFINITY\nDELTA = 1e-12\n\nMIN_X = MIN_Y = -100.0\nMAX_X = MAX_Y =  100.0\n\n### subroutines\n\ndef min_z2(x, y)\n  mz2 = INF\n  $rps.each do |xi, yi, li2|\n    z2 = li2 - (x - xi) ** 2 - (y - yi) ** 2\n    mz2 = z2 if mz2 > z2\n  end\n  mz2\nend\n\ndef rec_y(x)\n  min_y = MIN_Y\n  max_y = MAX_Y\n  while (max_y - min_y > DELTA)\n    y0 = (min_y * 2 + max_y) / 3\n    y1 = (min_y + 2 * max_y) / 3\n    mz20 = min_z2(x, y0)\n    mz21 = min_z2(x, y1)\n    if mz20 > mz21\n      max_y = y1\n    else\n      min_y = y0\n    end\n  end\n  min_z2(x, (min_y + max_y) / 2)\nend\n\ndef rec_xy()\n  min_x = MIN_X\n  max_x = MAX_X\n  while (max_x - min_x > DELTA)\n    x0 = (min_x * 2 + max_x) / 3\n    x1 = (min_x + 2 * max_x) / 3\n    mz20 = rec_y(x0)\n    mz21 = rec_y(x1)\n    if mz20 > mz21\n      max_x = x1\n    else\n      min_x = x0\n    end\n  end\n  rec_y((x0 + x1) / 2)\nend\n\n### main\n\nloop do \n  n = gets.to_i\n  break if n == 0\n\n  $rps = []\n  n.times do\n    xi, yi, li = gets.split.map(&:to_f)\n    $rps << [xi, yi, li * li]\n  end    \n  #p $rps\n\n  puts \"%.7f\" % Math.sqrt(rec_xy)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nEPS = 0.000001\n\ndef dist(x1, y1, z1, x2, y2, z2)\n\tsqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tanchors = (1..n).map{gets.split.map &:to_f}\n\tmax_h = -Float::INFINITY\n\n\tupdate_max_h = -> x, y, z do\n\t\tmax_h = z if z > max_h && anchors.all?{|a, b, r| dist(x, y, z, a, b, 0) <= r + EPS}\n\tend\n\t\n\tanchors.each {|x, y, z| update_max_h[x, y, z]}\n\t\n\tanchors.combination(2) do |u, v|\n\t\tu, v = v, u if u[-1] < v[-1]\n\t\t(a1, b1, r1), (a2, b2, r2) = u, v\n\t\td = hypot(a1-a2, b1-b2)\n\t\tl = (d + (r1**2 - r2**2) / d) / 2\n\t\tq = l / d\n\t\tnext if q < 0 || 1 < q\n\t\tx = (1-q)*a1 + q*a2\t\t\n\t\ty = (1-q)*b1 + q*b2\n\t\tz = sqrt(r1**2 - (x-a1)**2 - (y-b1)**2)\n\t\tupdate_max_h[x, y, z]\n\tend\n\t\n\tanchors.combination(3) do |(a1, b1, r1), (a2, b2, r2), (a3, b3, r3)|\n\t\tbegin\t\n\t\t\tx, y = *Matrix[\n\t\t\t\t[a1-a2, b1-b2],\n\t\t\t\t[a2-a3, b2-b3]\n\t\t\t].inv * Vector[\n\t\t\t\t(r2**2 - r1**2 + a1**2 - a2**2 + b1**2 - b2**2) / 2,\n\t\t\t\t(r3**2 - r2**2 + a2**2 - a3**2 + b2**2 - b3**2) / 2,\n\t\t\t]\n\t\t\n\t\t\tz = sqrt(r1**2 - (x-a1)**2 - (y-b1)**2)\n\t\t\n\t\t\tupdate_max_h[x, y, z]\n\t\trescue\n\t\tend\n\tend\n\n\tp max_h\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-10\nX, Y, L = 0, 1, 2\n\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\nend\n\nclass Circle\n  include Comparable\n  attr_accessor :x, :y, :r\n  def initialize(x=0.0, y=0.0, r=1.0)\n    @x, @y, @r = x.to_f, y.to_f, r.to_f\n  end\n  def <=>(c)\n    @x!=c.x ? @x<=>c.x : (@y!=c.y ? @y<=>c.y : @r<=>c.r)\n  end\n  def point\n    Point.new(@x, @y)\n  end\n  def distance(c)\n    (point-c.point).abs\n  end\n  def include?(p)\n    (point-p).abs <= @r\n  end\n  def in?(c)\n    distance(c) < (@r-c.r).abs\n  end\n  def touch?(c)\n    distance(c) <= @r + c.r\n  end\n  def crossPoint(c)\n    angle = Math::atan2(c.y-@y, c.x-@x)\n    d = distance(c)\n    add = Math::acos((d**2 + @r**2 - c.r**2) / (2.0*d*@r))\n    p1 = Point.new(@x+@r*Math::cos(angle+add), @y+@r*Math::sin(angle+add))\n    p2 = Point.new(@x+@r*Math::cos(angle-add), @y+@r*Math::sin(angle-add))\n    [p1, p2]\n  end\nend\n\ndef check(height)\n  result = false\n  circle = Array.new\n  @rope.each do |rope|\n    return false if rope[L] < height\n    circle.push(Circle.new(rope[X], rope[Y], Math::sqrt(rope[L]**2-height**2)))\n  end\n  crossPoint = Array.new\n  circle.each do |c1|\n    crossPoint.push(c1.point)\n    circle.each do |c2|\n      next if c1 == c2\n      next if c1.in?(c2)\n      next unless c1.touch?(c2)\n      crossPoint.push(*c1.crossPoint(c2))\n    end\n  end\n  crossPoint.each do |p|\n    ok = true\n    circle.each do |c|\n      ok = false unless c.include?(p)\n    end\n    result = true if ok\n  end\n  result\nend\n\nuntil (@n=gets.to_i).zero?\n  @rope = Array.new\n  @n.times {@rope.push(gets.split.map(&:to_f))}\n  mid = 0.0\n  low = 0.0\n  high = 300.0\n  until high-low < EPS\n    mid = (high+low) / 2.0\n    case check(mid)\n      when true\n        low = mid\n        answer = mid\n      when false\n        high = mid\n    end\n  end\n  p mid\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-8\nX, Y, L = 0, 1, 2\n\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\nend\n\nclass Circle\n  include Comparable\n  attr_accessor :x, :y, :r\n  def initialize(x=0.0, y=0.0, r=1.0)\n    @x, @y, @r = x.to_f, y.to_f, r.to_f\n  end\n  def <=>(c)\n    @x!=c.x ? @x<=>c.x : (@y!=c.y ? @y<=>c.y : @r<=>c.r)\n  end\n  def point\n    Point.new(@x, @y)\n  end\n  def distance(c)\n    (point-c.point).abs\n  end\n  def include?(p)\n    (point-p).abs <= @r\n  end\n  def in?(c)\n    distance(c) < (@r-c.r).abs\n  end\n  def touch?(c)\n    distance(c) <= @r + c.r\n  end\n  def crossPoint(c)\n    angle = Math::atan2(c.y-@y, c.x-@x)\n    d = distance(c)\n    add = Math::acos((d**2 + @r**2 - c.r**2) / (2.0*d*@r))\n    p1 = Point.new(@x+@r*Math::cos(angle+add), @y+@r*Math::sin(angle+add))\n    p2 = Point.new(@x+@r*Math::cos(angle-add), @y+@r*Math::sin(angle-add))\n    [p1, p2]\n  end\nend\n\ndef check(height)\n  result = false\n  circle = Array.new\n  @rope.each do |rope|\n    return false if rope[L] < height\n    circle.push(Circle.new(rope[X], rope[Y], Math::sqrt(rope[L]**2-height**2)))\n  end\n  crossPoint = Array.new\n  circle.each do |c1|\n    crossPoint.push(c1.point)\n    circle.each do |c2|\n      next if c1 == c2\n      next if c1.in?(c2)\n      next unless c1.touch?(c2)\n      crossPoint.push(*c1.crossPoint(c2))\n    end\n  end\n  crossPoint.each do |p|\n    ok = true\n    circle.each do |c|\n      ok = false unless c.include?(p)\n    end\n    result = true if ok\n  end\n  result\nend\n\nuntil (@n=gets.to_i).zero?\n  @rope = Array.new\n  @n.times {@rope.push(gets.split.map(&:to_f))}\n  mid = 0.0\n  low = 0.0\n  high = 300.0\n  until high-low < EPS\n    mid = (high+low) / 2.0\n    case check(mid)\n      when true\n        low = mid\n        answer = mid\n      when false\n        high = mid\n    end\n  end\n  p mid\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\ninclude Math\n\nEPS = 0.000001\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tanchors = (1..n).map{gets.split.map &:to_f}\n\tmax = -Float::INFINITY\n\t\n\tanchors.each do |x, y, z|\n\t\tif anchors.all?{|a, b, r| (x-a)**2 + (y-b)**2 + z**2 <= r**2 + EPS}\n\t\t\tmax = z if z > max\n\t\tend\n\tend\n\t\n\tanchors.combination(2) do |u, v|\n\t\tu, v = v, u if u[-1] < v[-1]\n\t\t(a1, b1, r1), (a2, b2, r2) = u, v\n\t\td = Math.hypot(a1-a2, b1-b2)\n\t\tl = (d + (r1**2 - r2**2) / d) / 2\n\t\tq = l / d\n\t\tnext if q < 0 || 1 < q\n\t\tx = (1-q)*a1 + q*a2\t\t\n\t\ty = (1-q)*b1 + q*b2\n\t\tz = sqrt(r1**2 - (x-a1)**2 - (y-b1)**2)\n\t\tif anchors.all?{|a, b, r| (x-a)**2 + (y-b)**2 + z**2 <= r**2 + EPS}\n\t\t\tmax = z if z > max\n\t\tend\n\tend\n\t\n\tanchors.combination(3) do |u, v, w|\n\t\t(a1, b1, r1), (a2, b2, r2), (a3, b3, r3) = u, v, w\n\t\n\t\tmat = Matrix[\n\t\t\t[2*(a1-a2), 2*(b1-b2)],\n\t\t\t[2*(a2-a3), 2*(b2-b3)]\n\t\t\t]\n\t\tnext if mat.singular?\n\t\n\t\tv = Vector[\n\t\t\tr2**2 - r1**2 + a1**2 - a2**2 + b1**2 - b2**2,\n\t\t\tr3**2 - r2**2 + a2**2 - a3**2 + b2**2 - b3**2\n\t\t\t]\n\t\n\t\tx, y =  *(mat.inv * v)\n\t\td = r1**2 - (x-a1)**2 - (y-b1)**2\n\t\tnext if d < 0\n\t\tz = sqrt(d)\n\t\n\t\tif anchors.all?{|a, b, r| (x-a)**2 + (y-b)**2 + z**2 <= r**2 + EPS}\n\t\t\tmax = z if z > max\n\t\tend\n\tend\n\tp max\nend"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef calc(x1, y1, rr1, x2, y2, rr2):\n    rr0 = (x2 - x1)**2 + (y2 - y1)**2\n    xd = x2 - x1\n    yd = y2 - y1\n    cv = (rr0 + rr1 - rr2)\n    if 4*rr0*rr1 < cv**2:\n        return tuple()\n    if 4*rr0*rr1 == cv**2:\n        return ((x1 + cv*xd/(2.*rr0), y1 + cv*yd/(2.*rr0)),)\n    sv = sqrt(4*rr0*rr1 - cv**2)\n    return (\n        (x1 + (cv*xd - sv*yd)/(2.*rr0), y1 + (cv*yd + sv*xd)/(2.*rr0)),\n        (x1 + (cv*xd + sv*yd)/(2.*rr0), y1 + (cv*yd - sv*xd)/(2.*rr0)),\n    )\n\ndef solve(mid):\n    ps = []\n    for i in xrange(n):\n        x1, y1, l1 = P[i]\n        if l1 < mid:\n            return 0\n        rr1 = l1**2 - mid**2\n        for j in xrange(i):\n            x2, y2, l2 = P[j]\n            rr2 = l2**2 - mid**2\n            if (x1 - x2)**2 + (y1 - y2)**2 > (sqrt(rr1)+sqrt(rr2))**2:\n                return 0\n            ps.extend(calc(x1, y1, rr1, x2, y2, rr2))\n    if not ps or n == 1:\n        return 1\n    for px, py in ps:\n        if all((px-x)**2 + (py-y)**2 < l**2 - mid**2+1e-8 for x, y, l in P):\n            return 1\n    return 0\n\nwhile 1:\n    n = input()\n    if n == 0:\n        break\n    P = [map(int, raw_input().split()) for i in xrange(n)]\n\n    left = 0; right = min(l for x, y, l in P)+1e-8\n    while left+1e-8 < right:\n        mid = (left + right) / 2.\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    print \"%.08f\" % left"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\nimport os\nimport sys\nimport math\n\ndef solve(f):\n    n = f.read_int()\n    if n == 0: raise StopIteration\n    ary = [f.read_float_list() for _ in xrange(n)]\n\n    x_min = -100.0\n    x_max = 100.0\n\n    for _ in xrange(60):\n        c1 = (x_min*2 + x_max) / 3\n        c2 = (x_min + x_max*2) / 3\n        if search_y(ary, c1) > search_y(ary, c2):\n            x_max = c2\n        else:\n            x_min = c1\n\n    return math.sqrt(search_y(ary, x_max))\n\ndef search_y(ary, x):\n    y_min = -100.0\n    y_max = 100.0\n\n    for _ in xrange(60):\n        c1 = (y_min*2 + y_max) / 3\n        c2 = (y_min + y_max*2) / 3\n        if calc(ary, x, c1) > calc(ary, x, c2):\n            y_max = c2\n        else:\n            y_min = c1\n\n    return calc(ary, x, y_max)\n\ndef calc(ary, x, y):\n    return min([item[2]**2 - (item[0]-x)**2 - (item[1]-y)**2 for item in ary])\n\n\nclass Reader(object):\n    def __init__(self, filename=None):\n        self.test_mode = filename is not None\n        self.cases = 1\n        self.buffer = []\n        if self.test_mode:\n            with open(filename) as f:\n                blank_flg = False\n                for line in f:\n                    line = line.strip()\n                    if line:\n                        self.buffer.append(line)\n                        blank_flg = False\n                    else:\n                        if not blank_flg: self.cases += 1\n                        blank_flg = True\n\n    def __readline(self):\n        return self.buffer.pop(0) if self.test_mode else raw_input()\n\n    def read_int(self):\n        return int(self.__readline())\n    def read_float(self):\n        return float(self.__readline())\n    def read_long(self):\n        return long(self.__readline())\n    def read_str(self):\n        return self.__readline()\n\n    def read_int_list(self):\n        return [int(item) for item in self.__readline().split()]\n    def read_float_list(self):\n        return [float(item) for item in self.__readline().split()]\n    def read_long_list(self):\n        return [long(item) for item in self.__readline().split()]\n    def read_str_list(self):\n        return self.__readline().split()\n\nif __name__ == '__main__':\n    filename = sys.argv[1] if len(sys.argv)>1 else None\n    f = Reader(filename)\n    while True:\n        try:\n            print solve(f)\n        except StopIteration:\n            break"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\neps = 1e-7\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi + eps:\n        m1 = (mi*2+ma) / 3.0\n        m2 = (mi+ma*2) / 3.0\n        r1 = f(m1)\n        r2 = f(m2)\n        if r1 < r2:\n            mi = m1\n        else:\n            ma = m2\n    return f((ma+mi)/2.0)\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [LI() for _ in range(n)]\n        def _f(x,y):\n            r = inf\n            for px,py,l in a:\n                r = min(r, l**2 - (x-px)**2 - (y-py)**2)\n            return r\n        def _fy(y):\n            def _ff(x):\n                return _f(x,y)\n            return bs(_ff, -100, 100)\n        r = bs(_fy,-100,100)\n\n        return \"{:0.7f}\".format(r**0.5)\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"http://mayokoex.hatenablog.com/entry/2015/06/11/124120を参照しました\"\"\"\n\"\"\"三分探索、賢い\"\"\"\nimport sys\nMI = 1e-6\ndef calc(x,y,b):\n    res = 90000\n    for bx,by,l in b:\n        d = l**2-(x-bx)**2-(y-by)**2\n        if d < res:\n            res = d\n    return res\n\ndef search_y(x,b):\n    p = [-100,-33,33,100]\n    for t in range(100):\n        if abs(p[0]-p[3]) < MI:\n            return (calc(x,p[0],b)+calc(x,p[3],b))/2\n        l = calc(x,p[1],b)\n        r = calc(x,p[2],b)\n        if l < r:\n            p[0] = p[1]\n        else:\n            p[3] = p[2]\n        p[1] = (2*p[0]+p[3])/3\n        p[2] = (p[0]+2*p[3])/3\n    return (calc(x,p[0],b)+calc(x,p[3],b))/2\n\ndef search(b):\n    p = [-100,-33,33,100]\n    for t in range(100):\n        if abs(p[0]-p[3]) < MI:\n            return (search_y(p[0],b)+search_y(p[3],b))/2\n        l = search_y(p[1],b)\n        r = search_y(p[2],b)\n        if l < r:\n            p[0] = p[1]\n        else:\n            p[3] = p[2]\n        p[1] = (2*p[0]+p[3])/3\n        p[2] = (p[0]+2*p[3])/3\n    return (search_y(p[0],b)+search_y(p[3],b))/2\n\ndef solve(n):\n    b = [[int(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    ans = 0\n    print(search(b)**0.5)\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef calc(x1, y1, rr1, x2, y2, rr2):\n    rr0 = (x2 - x1)**2 + (y2 - y1)**2\n    xd = x2 - x1\n    yd = y2 - y1\n    cv = (rr0 + rr1 - rr2)\n    if 4*rr0*rr1 < cv**2:\n        return tuple()\n    if 4*rr0*rr1 == cv**2:\n        return ((x1 + cv*xd/(2.*rr0), y1 + cv*yd/(2.*rr0)),)\n    sv = sqrt(4*rr0*rr1 - cv**2)\n    return (\n        (x1 + (cv*xd - sv*yd)/(2.*rr0), y1 + (cv*yd + sv*xd)/(2.*rr0)),\n        (x1 + (cv*xd + sv*yd)/(2.*rr0), y1 + (cv*yd - sv*xd)/(2.*rr0)),\n    )\n\ndef solve(mid):\n    ps = []\n    for i in xrange(n):\n        x1, y1, l1 = P[i]\n        if l1 < mid:\n            return 0\n        rr1 = l1**2 - mid**2\n        for j in xrange(i):\n            x2, y2, l2 = P[j]\n            rr2 = l2**2 - mid**2\n            if (x1 - x2)**2 + (y1 - y2)**2 > (sqrt(rr1)+sqrt(rr2))**2:\n                return 0\n            ps.extend(calc(x1, y1, rr1, x2, y2, rr2))\n        ps.append((x1, y1))\n    if n == 1:\n        return 1\n    for px, py in ps:\n        if all((px-x)**2 + (py-y)**2 < l**2 - mid**2 + 1e-8 for x, y, l in P):\n            return 1\n    return 0\n\nwhile 1:\n    n = input()\n    if n == 0:\n        break\n    P = [map(int, raw_input().split()) for i in xrange(n)]\n\n    left = 1.; right = min(l for x, y, l in P)+1e-8\n    while left+1e-8 < right:\n        mid = (left + right) / 2.\n        if solve(mid):\n            left = mid\n        else:\n            right = mid\n    print \"%.08f\" % left"
  },
  {
    "language": "Rust",
    "code": "/*------------------------------------------------------------------*/\n/*------------------------- begin template -------------------------*/\n/*------------------------------------------------------------------*/\n\n// ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n// diff: using Parser\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, char_) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()[0]\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, i64_) => {\n        $parser.fast_i64()\n    };\n    ($parser:ident, usize_) => {\n        $parser.fast_i64() as usize\n    };\n    ($parser:ident, usize1_) => {\n        ($parser.fast_i64() - 1) as usize\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\n\n// ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n// ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n// diff: using std::io::BufRead::fill_buf()\npub struct Parser<R> {\n    pub reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\n\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return unsafe { str::from_utf8_unchecked(&self.buf[begin..end]) }.parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n    pub fn fast_i64(&mut self) -> i64 {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            if begin == self.buf.len() {\n                self.update_buf();\n                continue;\n            }\n            let mut res = 0;\n            let (is_positive, mut end) = match self.buf[begin] {\n                b'+' => (true, begin + 1),\n                b'-' => (false, begin + 1),\n                _ => (true, begin),\n            };\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                res = res * 10 + (self.buf[end] as i64 - '0' as i64);\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return if is_positive { res } else { -res };\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::cmp::*;\n\nfn main() {\n    input! {\n        new_stdin_parser = parser,\n    }\n    let res = solve(&mut parser);\n    print!(\"{}\", res);\n}\n\n/*------------------------------------------------------------------*/\n/*-------------------------- end template --------------------------*/\n/*------------------------------------------------------------------*/\n\n#[derive(Clone, Copy, Debug)]\npub struct Vec3 {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nimpl Vec3 {\n    pub fn new(x: f64, y: f64, z: f64) -> Vec3 {\n        Vec3 { x, y, z }\n    }\n    pub fn dist(v: Vec3, u: Vec3) -> f64 {\n        let dx = u.x - v.x;\n        let dy = u.y - v.y;\n        let dz = u.z - v.z;\n        (dx * dx + dy * dy + dz * dz).sqrt()\n    }\n    pub fn to_unit(&self) -> Vec3 {\n        let d = (self.x * self.x + self.y * self.y + self.z * self.z).sqrt();\n        Vec3 {\n            x: self.x / d,\n            y: self.y / d,\n            z: self.z / d,\n        }\n    }\n}\n\nuse std::ops::*;\nimpl Add for Vec3 {\n    type Output = Vec3;\n    fn add(self, v: Vec3) -> Vec3 {\n        Vec3 {\n            x: self.x + v.x,\n            y: self.y + v.y,\n            z: self.z + v.z,\n        }\n    }\n}\n\nimpl Mul<f64> for Vec3 {\n    type Output = Vec3;\n    fn mul(self, a: f64) -> Vec3 {\n        Vec3 {\n            x: self.x * a,\n            y: self.y * a,\n            z: self.z * a,\n        }\n    }\n}\n\nuse std::fmt::Write;\nfn solve<R: BufRead>(parser: &mut Parser<R>) -> String {\n    let mut buf = String::new();\n    loop {\n        input! {\n            parser = parser,\n            n: usize,\n        }\n        if n == 0 {\n            break;\n        }\n        input! {\n            parser = parser,\n            ps: [(i64,i64,i64); n],\n        }\n        let eps = 1e-10;\n        let mut res = 0.0;\n        // <1>\n        'l1: for &(x1, y1, l1) in &ps {\n            let v = Vec3::new(x1 as f64, y1 as f64, l1 as f64);\n            for &(x2, y2, l2) in &ps {\n                let u = Vec3::new(x2 as f64, y2 as f64, 0.0);\n                if !(Vec3::dist(u, v) < l2 as f64 + eps) {\n                    continue 'l1;\n                }\n            }\n            if res < v.z {\n                res = v.z;\n            }\n        }\n        // <2>\n        for &(x1, y1, l1) in &ps {\n            'l2: for &(x2, y2, l2) in &ps {\n                let d = (((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) as f64).sqrt();\n                let d1 = ((l1 * l1 - l2 * l2) as f64 + d * d) / (2.0 * d);\n                let h = (l1 as f64 * l1 as f64 - d1 * d1).sqrt();\n                let v = Vec3::new(x1 as f64, y1 as f64, h)\n                    + Vec3::new((x2 - x1) as f64, (y2 - y1) as f64, 0.0).to_unit() * d1;\n                // eprintln!(\"d={}, d1={}, h={}\", d, d1, h);\n                // eprintln!(\"v={:?}\", v);\n                for &(x4, y4, l4) in &ps {\n                    let u = Vec3::new(x4 as f64, y4 as f64, 0.0);\n                    if !(Vec3::dist(u, v) < l4 as f64 + eps) {\n                        continue 'l2;\n                    }\n                }\n                if res < v.z {\n                    res = v.z;\n                }\n            }\n        }\n        // <3>\n        for &(x1, y1, l1) in &ps {\n            for &(x2, y2, l2) in &ps {\n                'l1: for &(x3, y3, l3) in &ps {\n                    let a = -2 * (x1 - x2);\n                    let b = -2 * (y1 - y2);\n                    let c = l1 * l1 - l2 * l2 - x1 * x1 + x2 * x2 - y1 * y1 + y2 * y2;\n                    let d = -2 * (x1 - x3);\n                    let e = -2 * (y1 - y3);\n                    let f = l1 * l1 - l3 * l3 - x1 * x1 + x3 * x3 - y1 * y1 + y3 * y3;\n                    let x = (c * e - b * f) as f64 / (a * e - b * d) as f64;\n                    let y = (a * f - c * d) as f64 / (a * e - b * d) as f64;\n                    let z = ((l1 * l1) as f64\n                        - (x - x1 as f64) * (x - x1 as f64)\n                        - (y - y1 as f64) * (y - y1 as f64))\n                        .sqrt();\n                    let v = Vec3::new(x, y, z);\n                    //// eprintln!(\"a={}, b={}, c={}, d={}, e={}, f={}\", a, b, c, d, e, f);\n                    //// eprintln!(\"v = {:?}\", v);\n                    for &(x4, y4, l4) in &ps {\n                        let u = Vec3::new(x4 as f64, y4 as f64, 0.0);\n                        if !(Vec3::dist(u, v) < l4 as f64 + eps) {\n                            continue 'l1;\n                        }\n                    }\n                    if res < v.z {\n                        res = v.z;\n                    }\n                }\n            }\n        }\n        // eprintln!(\"res = {}\", res);\n        writeln!(buf, \"{:.20}\", res);\n    }\n    buf\n}\n\n"
  }
]