[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef struct {\n    int credits;\n    int prereq_count;\n    int *prereqs;\n} Course;\n\nint min_courses = INT_MAX;\n\nvoid find_min_courses(Course *courses, int n, int U, int *taken, int current_credits, int count, int start) {\n    if (current_credits >= U) {\n        if (count < min_courses) {\n            min_courses = count;\n        }\n        return;\n    }\n\n    for (int i = start; i < n; i++) {\n        if (!taken[i]) {\n            int can_take = 1;\n            for (int j = 0; j < courses[i].prereq_count; j++) {\n                if (!taken[courses[i].prereqs[j]]) {\n                    can_take = 0;\n                    break;\n                }\n            }\n            if (can_take) {\n                taken[i] = 1;\n                find_min_courses(courses, n, U, taken, current_credits + courses[i].credits, count + 1, i + 1);\n                taken[i] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, U;\n    scanf(\"%d %d\", &n, &U);\n\n    Course *courses = malloc(n * sizeof(Course));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &courses[i].credits, &courses[i].prereq_count);\n        courses[i].prereqs = malloc(courses[i].prereq_count * sizeof(int));\n        for (int j = 0; j < courses[i].prereq_count; j++) {\n            scanf(\"%d\", &courses[i].prereqs[j]);\n        }\n    }\n\n    int *taken = calloc(n, sizeof(int));\n    find_min_courses(courses, n, U, taken, 0, 0, 0);\n\n    printf(\"%d\\n\", min_courses);\n\n    for (int i = 0; i < n; i++) {\n        free(courses[i].prereqs);\n    }\n    free(courses);\n    free(taken);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CoursePlanning {\n    static class Course {\n        int credits;\n        Set<Integer> prerequisites;\n\n        Course(int credits, Set<Integer> prerequisites) {\n            this.credits = credits;\n            this.prerequisites = prerequisites;\n        }\n    }\n\n    public static int minimumCoursesRequired(List<Course> courses, int requiredCredits) {\n        int n = courses.size();\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (dp[mask] == Integer.MAX_VALUE) continue;\n\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) continue;\n\n                boolean canTakeCourse = true;\n                for (int prereq : courses.get(i).prerequisites) {\n                    if ((mask & (1 << prereq)) == 0) {\n                        canTakeCourse = false;\n                        break;\n                    }\n                }\n\n                if (canTakeCourse) {\n                    int newMask = mask | (1 << i);\n                    dp[newMask] = Math.min(dp[newMask], dp[mask] + 1);\n                }\n            }\n        }\n\n        int minCourses = Integer.MAX_VALUE;\n        for (int mask = 0; mask < (1 << n); mask++) {\n            int totalCredits = 0;\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    totalCredits += courses.get(i).credits;\n                }\n            }\n            if (totalCredits >= requiredCredits) {\n                minCourses = Math.min(minCourses, dp[mask]);\n            }\n        }\n\n        return minCourses;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numCourses = scanner.nextInt();\n        int requiredCredits = scanner.nextInt();\n\n        List<Course> courses = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            int credits = scanner.nextInt();\n            int numPrereqs = scanner.nextInt();\n            Set<Integer> prerequisites = new HashSet<>();\n            for (int j = 0; j < numPrereqs; j++) {\n                prerequisites.add(scanner.nextInt() - 1);\n            }\n            courses.add(new Course(credits, prerequisites));\n        }\n\n        int result = minimumCoursesRequired(courses, requiredCredits);\n        System.out.println(result);\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:56:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint minCourses = INT_MAX;\n\nvoid backtrack(const vector<pair<int, vector<int>>>& courses, vector<bool>& taken, int currentCredits, int U, int index, int count) {\n    if (currentCredits >= U) {\n        if (count < minCourses) {\n            minCourses = count;\n        }\n        return;\n    }\n    if (index >= courses.size() || count >= minCourses) {\n        return;\n    }\n\n    // Option 1: Skip the current course\n    backtrack(courses, taken, currentCredits, U, index + 1, count);\n\n    // Option 2: Take the current course if prerequisites are met\n    bool canTake = true;\n    for (int prereq : courses[index].second) {\n        if (!taken[prereq]) {\n            canTake = false;\n            break;\n        }\n    }\n    if (canTake && !taken[index]) {\n        taken[index] = true;\n        backtrack(courses, taken, currentCredits + courses[index].first, U, index + 1, count + 1);\n        taken[index] = false;\n    }\n}\n\nint main() {\n    int N, U;\n    cin >> N >> U;\n\n    vector<pair<int, vector<int>>> courses(N);\n    for (int i = 0; i < N; ++i) {\n        int C, K;\n        cin >> C >> K;\n        vector<int> prereqs(K);\n        for (int j = 0; j < K; ++j) {\n            cin >> prereqs[j];\n            prereqs[j]--; // converting to 0-based index\n        }\n        courses[i] = {C, prereqs};\n    }\n\n    vector<bool> taken(N, false);\n    backtrack(courses, taken, 0, U, 0, 0);\n\n    cout << minCourses << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COURSES 100\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int credits;\n    int num_prereqs;\n    char* prerequisites[MAX_COURSES];\n    bool taken;\n} Course;\n\nint find_min_courses(Course* courses, int num_courses, int target_credits) {\n    int total_credits = 0;\n    int courses_taken = 0;\n    bool* taken_courses = calloc(num_courses, sizeof(bool));\n\n    while (total_credits < target_credits) {\n        bool course_added = false;\n        for (int i = 0; i < num_courses; i++) {\n            if (!taken_courses[i]) {\n                bool prereqs_met = true;\n                for (int j = 0; j < courses[i].num_prereqs; j++) {\n                    bool prereq_found = false;\n                    for (int k = 0; k < num_courses; k++) {\n                        if (strcmp(courses[k].name, courses[i].prerequisites[j]) == 0 && taken_courses[k]) {\n                            prereq_found = true;\n                            break;\n                        }\n                    }\n                    if (!prereq_found) {\n                        prereqs_met = false;\n                        break;\n                    }\n                }\n\n                if (prereqs_met) {\n                    total_credits += courses[i].credits;\n                    taken_courses[i] = true;\n                    courses_taken++;\n                    course_added = true;\n                }\n            }\n        }\n\n        if (!course_added) break;\n    }\n\n    free(taken_courses);\n    return total_credits >= target_credits ? courses_taken : -1;\n}\n\nint main() {\n    int num_courses, target_credits;\n    scanf(\"%d %d\", &num_courses, &target_credits);\n\n    Course* courses = malloc(num_courses * sizeof(Course));\n    \n    for (int i = 0; i < num_courses; i++) {\n        scanf(\"%s %d %d\", courses[i].name, &courses[i].credits, &courses[i].num_prereqs);\n        courses[i].taken = false;\n\n        for (int j = 0; j < courses[i].num_prereqs; j++) {\n            courses[i].prerequisites[j] = malloc(MAX_NAME_LENGTH * sizeof(char));\n            scanf(\"%s\", courses[i].prerequisites[j]);\n        }\n    }\n\n    int result = find_min_courses(courses, num_courses, target_credits);\n    printf(\"%d\\n\", result);\n\n    for (int i = 0; i < num_courses; i++) {\n        for (int j = 0; j < courses[i].num_prereqs; j++) {\n            free(courses[i].prerequisites[j]);\n        }\n    }\n    free(courses);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass CoursePlanner {\nprivate:\n    int totalCredits;\n    unordered_map<string, vector<string>> prerequisites;\n    unordered_map<string, int> courseCredits;\n\npublic:\n    CoursePlanner(int requiredCredits) : totalCredits(requiredCredits) {}\n\n    void addCourse(string course, int credits, vector<string> prereqs) {\n        courseCredits[course] = credits;\n        prerequisites[course] = prereqs;\n    }\n\n    int minimumCoursesNeeded() {\n        vector<pair<string, int>> availableCourses;\n        for (auto& course : courseCredits) {\n            if (canTakeCourse(course.first)) {\n                availableCourses.push_back({course.first, course.second});\n            }\n        }\n\n        sort(availableCourses.begin(), availableCourses.end(), \n             [](const pair<string, int>& a, const pair<string, int>& b) {\n                 return a.second > b.second;\n             });\n\n        int currentCredits = 0;\n        int courseCount = 0;\n\n        for (auto& course : availableCourses) {\n            if (currentCredits >= totalCredits) break;\n            currentCredits += course.second;\n            courseCount++;\n        }\n\n        return courseCount;\n    }\n\nprivate:\n    bool canTakeCourse(string course) {\n        for (string prereq : prerequisites[course]) {\n            if (courseCredits.find(prereq) == courseCredits.end()) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    int requiredCredits, numCourses;\n    cin >> requiredCredits >> numCourses;\n\n    CoursePlanner planner(requiredCredits);\n\n    for (int i = 0; i < numCourses; i++) {\n        string course;\n        int credits;\n        int numPrereqs;\n        \n        cin >> course >> credits >> numPrereqs;\n        \n        vector<string> prereqs;\n        for (int j = 0; j < numPrereqs; j++) {\n            string prereq;\n            cin >> prereq;\n            prereqs.push_back(prereq);\n        }\n\n        planner.addCourse(course, credits, prereqs);\n    }\n\n    cout << planner.minimumCoursesNeeded() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CoursePlanning {\n    static class Course {\n        int credits;\n        List<Integer> prerequisites;\n\n        Course(int credits, List<Integer> prerequisites) {\n            this.credits = credits;\n            this.prerequisites = prerequisites;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int U = scanner.nextInt();\n        scanner.nextLine();\n\n        Course[] courses = new Course[N];\n        for (int i = 0; i < N; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            int credits = Integer.parseInt(parts[0]);\n            int K = Integer.parseInt(parts[1]);\n            List<Integer> prerequisites = new ArrayList<>();\n            for (int j = 0; j < K; j++) {\n                prerequisites.add(Integer.parseInt(parts[2 + j]));\n            }\n            courses[i] = new Course(credits, prerequisites);\n        }\n\n        int minCourses = Integer.MAX_VALUE;\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(0, 0, 0));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.totalCredits >= U) {\n                minCourses = Math.min(minCourses, current.coursesTaken);\n                continue;\n            }\n            if (current.coursesTaken >= minCourses) {\n                continue;\n            }\n\n            for (int i = 0; i < N; i++) {\n                if ((current.bitmask & (1 << i)) == 0) {\n                    boolean canTake = true;\n                    for (int prereq : courses[i].prerequisites) {\n                        if ((current.bitmask & (1 << prereq)) == 0) {\n                            canTake = false;\n                            break;\n                        }\n                    }\n                    if (canTake) {\n                        int newBitmask = current.bitmask | (1 << i);\n                        int newTotalCredits = current.totalCredits + courses[i].credits;\n                        int newCoursesTaken = current.coursesTaken + 1;\n                        queue.add(new State(newBitmask, newTotalCredits, newCoursesTaken));\n                    }\n                }\n            }\n        }\n\n        System.out.println(minCourses);\n    }\n\n    static class State {\n        int bitmask;\n        int totalCredits;\n        int coursesTaken;\n\n        State(int bitmask, int totalCredits, int coursesTaken) {\n            this.bitmask = bitmask;\n            this.totalCredits = totalCredits;\n            this.coursesTaken = coursesTaken;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:58:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef min_courses_to_meet_units(course_data, required_units):\n    prerequisites = defaultdict(list)\n    credits = {}\n    \n    for course, credit, prereq in course_data:\n        credits[course] = credit\n        for p in prereq:\n            prerequisites[course].append(p)\n            \n    def can_take_course(course, taken):\n        return all(p in taken for p in prerequisites[course])\n\n    def find_min_courses(taken, remaining, total_credits):\n        if total_credits >= required_units:\n            return 0\n\n        min_courses = float('inf')\n        for course, credit in credits.items():\n            if course not in taken and can_take_course(course, taken):\n                new_taken = taken | {course}\n                courses_consumed = 1 + find_min_courses(new_taken, remaining - {course}, total_credits + credit)\n                min_courses = min(min_courses, courses_consumed)\n\n        return min_courses\n\n    return find_min_courses(set(), set(credits.keys()), 0)\n\n# Example usage\n# course_data is a list of tuples in the form (course_name, credit_units, [prerequisites_list])\ncourse_data = [\n    ('CS101', 3, []),\n    ('CS102', 4, ['CS101']),\n    ('CS103', 2, ['CS101']),\n    ('CS104', 3, ['CS102', 'CS103']),\n    ('CS105', 2, []),\n    ('CS106', 4, ['CS105'])\n]\nrequired_units = 7\n\nprint(min_courses_to_meet_units(course_data, required_units))",
    "timestamp": "2025-08-13 01:38:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass Course {\n    int credit;\n    List<Integer> prerequisites;\n\n    public Course(int credit) {\n        this.credit = credit;\n        this.prerequisites = new ArrayList<>();\n    }\n}\n\npublic class CoursePlanner {\n    \n    public static int minimumCourses(Map<Integer, Course> courses, int U) {\n        PriorityQueue<int[]> courseQueue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        Map<Integer, Integer> inDegree = new HashMap<>();\n        Map<Integer, Set<Integer>> adjList = new HashMap<>();\n        \n        for (var courseId : courses.keySet()) {\n            inDegree.put(courseId, 0);\n            adjList.put(courseId, new HashSet<>());\n        }\n        \n        for (var courseId : courses.keySet()) {\n            Course course = courses.get(courseId);\n            for (int prereq : course.prerequisites) {\n                adjList.get(prereq).add(courseId);\n                inDegree.put(courseId, inDegree.get(courseId) + 1);\n            }\n            if (inDegree.get(courseId) == 0) {\n                courseQueue.offer(new int[]{courseId, course.credit});\n            }\n        }\n        \n        int totalCredits = 0;\n        int courseCount = 0;\n        \n        while (!courseQueue.isEmpty() && totalCredits < U) {\n            int[] current = courseQueue.poll();\n            int courseId = current[0];\n            int courseCredit = current[1];\n            \n            totalCredits += courseCredit;\n            courseCount++;\n            \n            for (int nextCourse : adjList.get(courseId)) {\n                inDegree.put(nextCourse, inDegree.get(nextCourse) - 1);\n                if (inDegree.get(nextCourse) == 0) {\n                    courseQueue.offer(new int[]{nextCourse, courses.get(nextCourse).credit});\n                }\n            }\n        }\n        \n        return courseCount;\n    }\n    \n    public static void main(String[] args) {\n        Map<Integer, Course> courses = new HashMap<>();\n        \n        // Example course data; replace with actual input logic.\n        Course course1 = new Course(3);\n        Course course2 = new Course(2);\n        course2.prerequisites.add(1);\n        Course course3 = new Course(4);\n        course3.prerequisites.add(1);\n        \n        courses.put(1, course1);\n        courses.put(2, course2);\n        courses.put(3, course3);\n        \n        int U = 5; // Minimum required credits\n        \n        System.out.println(minimumCourses(courses, U));\n    }\n}",
    "timestamp": "2025-08-13 01:38:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int credits;\n    int num_prerequisites;\n    int* prerequisites;\n} Course;\n\nint compare(const void* a, const void* b) {\n    return ((Course*)b)->credits - ((Course*)a)->credits;\n}\n\nint can_take(Course *courses, int course_index, int *taken_courses, int num_courses) {\n    for (int i = 0; i < courses[course_index].num_prerequisites; i++) {\n        int prereq_id = courses[course_index].prerequisites[i];\n        int prereq_index = -1;\n        for (int j = 0; j < num_courses; j++) {\n            if (courses[j].id == prereq_id) {\n                prereq_index = j;\n                break;\n            }\n        }\n        if (prereq_index == -1 || !taken_courses[prereq_index]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid find_minimum_courses(Course *courses, int num_courses, int U) {\n    qsort(courses, num_courses, sizeof(Course), compare);\n    \n    int *taken_courses = (int*)calloc(num_courses, sizeof(int));\n    int total_credits = 0;\n    int courses_taken = 0;\n\n    for (int i = 0; i < num_courses; i++) {\n        if (!taken_courses[i] && can_take(courses, i, taken_courses, num_courses)) {\n            taken_courses[i] = 1;\n            total_credits += courses[i].credits;\n            courses_taken++;\n            if (total_credits >= U) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", courses_taken);\n    free(taken_courses);\n}\n\nint main() {\n    int num_courses, U;\n    scanf(\"%d %d\", &num_courses, &U);\n    \n    Course *courses = (Course*)malloc(num_courses * sizeof(Course));\n    for (int i = 0; i < num_courses; i++) {\n        scanf(\"%d %d %d\", &courses[i].id, &courses[i].credits, &courses[i].num_prerequisites);\n        courses[i].prerequisites = (int*)malloc(courses[i].num_prerequisites * sizeof(int));\n        for (int j = 0; j < courses[i].num_prerequisites; j++) {\n            scanf(\"%d\", &courses[i].prerequisites[j]);\n        }\n    }\n    \n    find_minimum_courses(courses, num_courses, U);\n    \n    for (int i = 0; i < num_courses; i++) {\n        free(courses[i].prerequisites);\n    }\n    free(courses);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 01:38:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def course_planning(courses, U):\n    # Sort courses by credits in descending order\n    courses.sort(key=lambda x: x[1], reverse=True)\n    \n    total_credits = 0\n    selected_courses = []\n    \n    # Track prerequisites\n    prereq_met = {}\n    for course, credits, prereqs in courses:\n        prereq_met[course] = False\n    \n    # First pass: check courses with no prerequisites\n    for course, credits, prereqs in courses:\n        if not prereqs:\n            if total_credits < U:\n                total_credits += credits\n                selected_courses.append(course)\n                prereq_met[course] = True\n    \n    # Second pass: add courses if prerequisites are met\n    for course, credits, prereqs in courses:\n        if total_credits >= U:\n            break\n        \n        if not prereq_met[course]:\n            # Check if all prerequisites are met\n            prereqs_satisfied = all(prereq_met.get(p, False) for p in prereqs)\n            \n            if prereqs_satisfied:\n                total_credits += credits\n                selected_courses.append(course)\n                prereq_met[course] = True\n    \n    return len(selected_courses)\n\n# Example usage\ncourses = [\n    ('CS101', 3, []),       # No prerequisites \n    ('MATH201', 4, []),     # No prerequisites\n    ('CS201', 4, ['CS101']),# Requires CS101\n    ('CS301', 5, ['CS201']),# Requires CS201\n    ('PHYS101', 3, [])      # No prerequisites\n]\n\nU = 10  # Minimum total credit units required\nprint(course_planning(courses, U))",
    "timestamp": "2025-08-13 01:38:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    U = int(data[idx])\n    idx += 1\n    \n    courses = []\n    in_degree = [0] * (N + 1)\n    adj = [[] for _ in range(N + 1)]\n    credits = [0] * (N + 1)\n    \n    for _ in range(N):\n        c = int(data[idx])\n        idx += 1\n        credit = int(data[idx])\n        idx += 1\n        credits[c] = credit\n        k = int(data[idx])\n        idx += 1\n        for _ in range(k):\n            pre = int(data[idx])\n            idx += 1\n            adj[pre].append(c)\n            in_degree[c] += 1\n    \n    heap = []\n    for c in range(1, N + 1):\n        if in_degree[c] == 0:\n            heapq.heappush(heap, (credits[c], c))\n    \n    total = 0\n    count = 0\n    while heap and total < U:\n        credit, c = heapq.heappop(heap)\n        total += credit\n        count += 1\n        for neighbor in adj[c]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                heapq.heappush(heap, (credits[neighbor], neighbor))\n    \n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 01:38:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nstruct Course {\n    int id;\n    int credits;\n    vector<int> prerequisites;\n};\n\nint findMinimumCourses(vector<Course>& courses, int U) {\n    int n = courses.size();\n    unordered_map<int, vector<int>> adjList;\n    unordered_map<int, int> inDegree;\n    unordered_map<int, int> creditMap;\n\n    for (const auto& course : courses) {\n        creditMap[course.id] = course.credits;\n        for (int prereq : course.prerequisites) {\n            adjList[prereq].push_back(course.id);\n            inDegree[course.id]++;\n        }\n    }\n\n    queue<int> q;\n    for (const auto& course : courses) {\n        if (inDegree[course.id] == 0) {\n            q.push(course.id);\n        }\n    }\n\n    vector<int> topologicalSort;\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        topologicalSort.push_back(current);\n\n        for (int neighbor : adjList[current]) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n\n    int numCourses = 0;\n    unordered_set<int> chosen;\n    vector<int> credits;\n\n    for (int id : topologicalSort) {\n        if (chosen.find(id) == chosen.end()) {\n            credits.push_back(creditMap[id]);\n            chosen.insert(id);\n            numCourses++;\n        }\n\n        if (credits.size() >= U) break;\n    }\n\n    if (credits.size() < U) {\n        vector<int> dp(U + 1, INT_MAX);\n        dp[0] = 0;\n\n        for (const auto& credit : credits) {\n            for (int j = U; j >= credit; --j) {\n                if (dp[j - credit] != INT_MAX) {\n                    dp[j] = min(dp[j], dp[j - credit] + 1);\n                }\n            }\n        }\n\n        numCourses = dp[U];\n    }\n\n    return numCourses;\n}\n\nint main() {\n    int n, U;\n    cout << \"Enter number of courses and required credits: \";\n    cin >> n >> U;\n\n    vector<Course> courses(n);\n    for (int i = 0; i < n; ++i) {\n        cout << \"Enter course id, credits, number of prerequisites and prerequisites: \";\n        cin >> courses[i].id >> courses[i].credits;\n        int prereqCount;\n        cin >> prereqCount;\n        courses[i].prerequisites.resize(prereqCount);\n        for (int j = 0; j < prereqCount; ++j) {\n            cin >> courses[i].prerequisites[j];\n        }\n    }\n\n    int result = findMinimumCourses(courses, U);\n    cout << \"Minimum number of courses needed: \" << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:01:21"
  }
]