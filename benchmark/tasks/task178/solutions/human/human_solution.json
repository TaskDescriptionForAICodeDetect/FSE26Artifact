[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nint c[30];\nint deps[30];\n\ninline unsigned next_set(unsigned x)\n{\n  unsigned smallest = x & -x;\n  unsigned ripple = x + smallest;\n  unsigned new_smallest = ripple & -ripple;\n  unsigned ones = ((new_smallest / smallest) >> 1) - 1;\n  return ripple | ones;\n}\n\ninline int bsf(int x)\n{\n  __asm__(\"bsf %1, %0;\" :\"=r\"(x) :\"r\"(x));\n  return x;\n}\n\nint main() {\n  int n, U;\n  while (scanf(\"%d%d\", &n, &U), n|U) {\n    memset(deps, 0, sizeof(deps));\n    REP(i, n) {\n      int k; scanf(\"%d%d\", &c[i], &k);\n      REP(j, k) {\n        int r; scanf(\"%d\", &r);\n        deps[i] |= 1 << r;\n      }\n    }\n    FOREQ(bits, 1, n) {\n      for (int S = (1<<bits)-1; S < (1<<n); S = next_set(S)) {\n        int sum = 0;\n        bool ok = true;\n        for (int T = S; T; T &= T-1) {\n          int i = bsf(T);\n          sum += c[i];\n          if ((S | deps[i]) != S) {\n            ok = false;\n            break;\n          }\n        }\n        if (sum >= U && ok) {\n          printf(\"%d\\n\", bits);\n          goto next;\n        }\n      }\n    }\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nchar visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n};\n\nint solve(int N, int U, int tno) {\n  queue<State> up;\n  static State s;\n  s.one = s.mask = s.have = 0;\n  visited[s.mask] = tno;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.front(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] != tno && (s.mask | need[i]) == s.mask )\n      {\n        static State next;\n        next.mask = s.mask | (1 << i);\n        next.one = s.one + 1;\n        next.have = s.have + unit[i];\n        visited[next.mask] = tno;\n        up.push(next);\n      }\n  }\n  return -1;\n}\n\nint main() {\n  for(int tno = 1;; tno++) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U, tno);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n\tNODE(){}\n};\n\nNODE Q[1<<20];\nint qsize;\n#define INF (1<<21)\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tqsize = 0;\n\t\tQ[qsize++] = NODE(0,0,0);\n\t\tdone[0] = 1;\n\t\twhile(qsize){\n\t\t\tNODE q = Q[--qsize];\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)]){\n\t\t\t\t\t\tQ[qsize++] = NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1);\n\t\t\t\t\t\tdone[q.a|(1<<i)] = true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tvi vis(1<<n);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\t//rep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(vis[b]) continue;\n\t\t\tvis[b]=1;\n\t\t\tint cnt=0,sum=0;\n\t\t\t//rep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\trep(j,n) cnt+=(b>>j&1),sum+=(b>>j&1)*cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  for(int n,u;cin>>n>>u,n|u;){\n    int ng[20],pr[20]={};\n    for(int i=0;i<n;i++){\n      int k;\n      cin>>ng[i]>>k;\n      while(k--){\n\tint r;\n\tcin>>r;\n\tpr[i]|=1<<r;\n      }\n    }\n    int m=1<<30;\n    for(int i=0;i<1<<n;i++){\n      int gs=0,ns=0;\n      for(int j=0;j<n;j++){\n\tif(i&1<<j){\n\t  if(pr[j]&~i) goto next;\n\t  gs+=ng[j];\n\t  ns++;\n\t}\n      }\n      if(u<=gs&&ns<m){\n\tm=ns;\n      }\n    next:\n      ;\n    }\n    cout<<m<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nbool visit(const Graph &g, int v, vector<int> &order, vector<int> &color) {\n  color[v] = 1;\n  fr(e, g[v]) {\n    if (color[e->dst] == 2) continue;\n    if (color[e->dst] == 1) return false;\n    if (!visit(g, e->dst, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(const Graph &g, vector<int> &order) {\n  int n = g.size();\n  vector<int> color(n);\n  rep(u, n) if (!color[u] && !visit(g, u, order, color))\n    return false;\n  reverse(all(order));\n  return true;\n}\nint n,u,ans;\nint c[20],k[20];\nGraph g;\nvi ord; bool v[20];\n\nvoid dfs(int cur,int uni,int sbj)\n{\n\tif(uni>=u)ans=min(ans,sbj);\n\tif(uni>=u||cur>=n)return;\n\t\n\tint a=ord[cur];\n\tfr(i,g[a])if(!v[i->dst])goto FAIL;\n\tv[a]=1; dfs(cur+1,uni+c[a],sbj+1); v[a]=0;\n\tFAIL:dfs(cur+1,uni,sbj);\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&u),n)\n\t{\n\t\tg.clear(); g.resize(n);\n\t\trep(i,n)\n\t\t{\n\t\t\tscanf(\"%d%d\",c+i,k+i);\n\t\t\trep(j,k[i])\n\t\t\t{\n\t\t\t\tint t; scanf(\"%d\",&t);\n\t\t\t\tg[i].pb(Edge(i,t,0));\n\t\t\t}\n\t\t}\n\t\tord.clear();\n\t\ttopologicalSort(g,ord); reverse(all(ord));\n\t\t\n\t\tans=inf; dfs(0,0,0);\n\t\trep(i,n)v[i]=0;;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bitset>\n#include<map>\n//BitCount\nint F(int x)\n{\n\tint r=0;\n\tfor(; x; x&=x-1)\n\t\t++r;\n\treturn r;\n}\nstd::bitset<1<<20>f;\nint dp[1<<20];\nint main()\n{\n\tint n,u,k,r,i,j,x,y,z;\n\twhile(scanf(\"%d%d\",&n,&u),n)\n\t{\n\t\tf.reset();\n\t\tstd::pair<int,int>a[20];\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a[i].first,&k);\n\t\t\tif(k)\n\t\t\t{\n\t\t\t\twhile(k--)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\t\ta[i].second|=(1<<r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse f[1<<i]=1,dp[1<<i]=a[i].first;\n\t\t}\n\t\tfor(i=1;i<=n;++i)\n\t\t{\n\t\t\tz=(1<<i)-1;\n\t\t\twhile(z<(1<<n))\n\t\t\t{\n\t\t\t\tif(f[z])\n\t\t\t\t{\n\t\t\t\t\tif(dp[z]>=u){printf(\"%d\\n\",F(z));goto E;}\n\t\t\t\t\tfor(j=0;j<n;++j)\n\t\t\t\t\t\tif(!(z&(1<<j)) && (z&a[j].second)==a[j].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf[z|(1<<j)]=1;\n\t\t\t\t\t\t\tdp[z|(1<<j)]=dp[z]+a[j].first;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=z&-z;\n\t\t\t\ty=z+x;\n\t\t\t\tz=((z&~y)/x/2)|y;\n\t\t\t}\n\t\t}\n\t\tE:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[20],k[20],r[20];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      r[i] = 0;\n      for(j=0; j<k[i]; j++){\n\tint t;\n\tscanf(\"%d\",&t);\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok && j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) && ((i & r[j]) != r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u && ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 20;\n\nint n, U, C[N], K[N], R[N];\n\nbool check(int s){\n  for(int i=0;i<n;i++){\n    if((s >> i) & 1){\n      if(R[i] != 0) continue;\n      if(R[i] & s != 1) return false;\n    }\n  }\n  return true;\n}\n\nmain(){\n  while(cin >> n >> U && (n|U)){\n    for(int i=0;i<n;i++){\n      cin >> C[i] >> K[i];\n      R[i] = 0;\n      for(int j=0;j<K[i];j++){\n        int r;\n        cin >> r;\n        R[i] |= 1 << r;\n      }\n    }\n    int ans = -1;\n    for(int i=0;i<(1<<n);i++){\n      int sum = 0, cnt = 0;\n      for(int j=0;j<n;j++){\n        if((i >> j) & 1){\n          sum += C[j];\n          cnt++;\n        }\n      }\n      if(sum < U) continue;\n      if((ans == -1 || ans > cnt) && check(i)) ans = cnt;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nint ans,U;\n\nvoid dfs(VI& G,VI& c,int total,int cost,int b)\n{\n  if(cost >= ans)\n    return;\n\n  int n = G.size();\n  for(int i=0;i<n;i++)\n    {\n      if((b>>i) & 1)\n\tcontinue;\n      int pre = G[i];\n      pre &= b;\n      if(pre == G[i])\n\t{\n\t  if(total+c[i] < U)\n\t    dfs(G,c,total+c[i],cost+1,b|(1<<i));\n\t  else \n\t    ans = min(ans,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  int n;\n  while(cin >> n >> U,n|U)\n    {\n      vector<int> G;\n      G.resize(n);\n      vector<int> c; \n      c.resize(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  int k;\n\t  cin >> c[i] >> k;\n\t  G[i] = 0;\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      int r;\n\t      cin >> r;\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      ans = n;\n      dfs(G,c,0,0,0);\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21][21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i][d]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tif(ret<=__builtin_popcount(i))continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tfor(int k=0;k<a;k++)\n\t\t\t\t\t\tif(g[j][k]&&!(i&(1<<k)))ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=min(ret,__builtin_popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\nint costs[32];\nint N,U,C,K;\nint ans;\npair<int, vector<int> > pivv[32];\n\nvoid dfs(int now, int nowcost, int cnt, int next)\n{\n\tif( ans<cnt )return;\n\tif( nowcost>=U ){ ans = cnt; return; }\n\tfor(int i=next; i<N; i++){\n\t\tif( !(now&(1<<i)) ){\n\t\t\tint j;\n\t\t\tfor(j=0; j<pivv[i].second.size(); j++)\n\t\t\t\tif( !(now&(1<<pivv[i].second[j])) )break;\n\t\t\tif( j==pivv[i].second.size() ){\n\t\t\t\tdfs(now|(1<<i), nowcost+pivv[i].first, cnt+1, i+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main()\n{\n\twhile(cin>>N>>U, N|U){\n\t\tpair<int, vector<int> > piv[N];\n\t\t//vector<vector<int> > vv(N);\n\t\tmemset(costs,0,sizeof(costs));\n\t\tans = INT_MAX;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tcin>>piv[i].first>>K;\n\t\t\tfor(int j=0; j<K; j++){\n\t\t\t\tint a; cin>>a;\n\t\t\t\tpiv[i].second.push_back(a);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// sort\n\t\tpair<int, vector<int> > tmp[N],pivtmp[N];\n\t\tvector<int> cv;\n\t\tint check[N];\n\t\tmemset(check,0,sizeof(check));\n\t\tfor(int i=0; i<N; i++)pivtmp[i]=piv[i];\n\t\t\n\t\tfor(int i=0; i<N; i++){\n\t\t\tint pos=-1,tmin=N+1;\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tint k;\n\t\t\t\tint c = 0;\n\t\t\t\tint n = pivtmp[j].second.size();\n\t\t\t\t\n\t\t\t\tfor(k=0; k<n; k++){\n\t\t\t\t\tint l;\n\t\t\t\t\tfor(l=0; l<i; l++)\n\t\t\t\t\t\tif( cv[l]==pivtmp[j].second[k] )break;\n\t\t\t\t\tif( l<i || l==0 )c++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( c==n && tmin>n && !check[j]){\n\t\t\t\t\tpos = j; tmin = n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//printf(\"i:%d , pos:%d\\n\",i,pos);\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tif( check[j] )continue;\n\t\t\t\tfor(int l=0; l<pivtmp[j].second.size(); l++){\n\t\t\t\t\tif( pivtmp[j].second[l]==pos ){\n\t\t\t\t\t\tpiv[j].second[l] = i;\n\t\t\t\t\t\t//printf(\"j:%d\\n\",j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp[i] = piv[pos];\n\t\t\tcheck[pos] = 1;\n\t\t\tcv.push_back(pos);\n\t\t\t\n\t\t\t// __ debug __ \n\t\t\t/*\n\t\t\tputs(\"_____debug_____\");\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tprintf(\"i:%d, C:%d _ \",i,piv[j].first);\n\t\t\t\tfor(int k=0; k<piv[j].second.size(); k++)\n\t\t\t\t\tprintf(\"%d,\",piv[j].second[k]);\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\tputs(\"_______________\");\n\t\t\t*/\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i=0; i<N; i++){\n\t\t\tprintf(\"i:%d, C:%d _ \",i,tmp[i].first);\n\t\t\tfor(int j=0; j<tmp[i].second.size(); j++)\n\t\t\t\tprintf(\"%d,\",tmp[i].second[j]);\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tfor(int i=0; i<N; i++)pivv[i] = tmp[i];\n\t\tdfs(0,0,0,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    int next_sum;\n    for(int i = 0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if(dp[s.S | (1<<i)] != -1) continue;\n\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[s.S | (1<<i)] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(s.S | (1<<i),next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  if(dp[S] != -1) return;\n  dp[S] = sum;\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] | S) == S){\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] == -1) continue;\n      if(dp[S] >= credit_requirement){\n\tres = min(res,__builtin_popcount(S));\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int a[20],b[20];\n    memset(b,0,sizeof(b));\n    for(i=0;i<n;i++){\n      int p;\n      cin>>a[i]>>p;\n      for(j=0;j<p;j++){\n\tint q;\n\tcin>>q;\n\tb[i]|=1<<q;\n      }\n    }\n    int mn=20;\n    for(i=0;i<(1<<n);i++){\n      int sm=0,ct=0;\n      for(j=0;j<n;j++){\n\tif(i&(1<<j)){\n\t  if((i&b[i])==b[i]){\n\t    sm+=a[j];\n\t    ct++;\n\t  }else{\n\t    break;\n\t  }\n\t}\n      }\n      if(j==n&&sm>=m)\n\tmn=min(mn,ct);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nchar memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n  state ns(0,0,0);;\n  int i,k;\n\n  while(!Q.empty()) {\n    ns = Q.front(); Q.pop();\n    for(i=0; i<n; ++i) {\n      k = 1<<i;\n      if(ns.used & k || memo[ns.used|k] || (ns.used & pv[i] != pv[i])) continue;\n      memo[ns.used|k] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|k),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, 0, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,int > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tif(((vpii[i].second)&s)==vpii[i].second){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; ++i){\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); ++S){\n    bitcount[S] = __builtin_popcount(S);\n  }\n\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; ++subject_i){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; ++subject_j){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); ++S){\n      if(dp[S] < credit_requirement) continue;\n      res = min(bitcount[S],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cassert>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0));\n  int i;\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(visited[ns.used]) continue;\n    if(ns.cost >= U) {\n      return pop(ns.used);\n    }\n\n    visited[ns.used] = 1;\n\n    for(i=0; i<n; ++i) {\n      if(!((ns.used>>i)&1) && (ns.used & pv[i])==pv[i]) {\n\tQ.push(state((ns.used|(1<<i)),ns.cost+cv[i]));\n      }\n    }\n  }\n\n  assert(false);\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(visited, false, sizeof(visited));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct Subject{\n  int credit;\n  int required;\n};\nstruct Data{\n  int used;\n  int credit;\n};\n\nint numofbits(long bits)\n{\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = ((bits >> 4) + bits) & 0x0f0f0f0f;\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n\nint main()\n{\n  int n,U,c,k,r;\n  while(cin>>n>>U,n|U){\n    vector<Subject>list(n);\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      list[i].credit=c;\n      list[i].required=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\tlist[i].required^=(1<<r);\n      }\n    }\n\n    queue<Data>q;\n    vector<int>visited(1<<n,0);\n    Data now={0,0};\n    q.push(now);\n    while(!q.empty()){\n      now=q.front();\n      q.pop();\n      if(visited[now.used])continue;\n      visited[now.used]=1;\n      if(now.credit>=U)\tbreak;\n      for(int i=0;i<n;i++){\n\tif(now.used & (1<<i))continue;\n\tData next=now;\n\tnext.used^=(1<<i);\n\tnext.credit+=list[i].credit;\n\tif((next.used & list[i].required) != list[i].required)continue;\n\tq.push(next);\n      }\n    }\n    int ans=numofbits(now.used);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint need[30];\nint tani[30];\n\nint main() {\n  int n, u;\n  for (;;) {\n    cin >> n >> u;\n    if (n == 0 && u == 0) break;\n    rep (i, n) {\n      int k;\n      cin >> tani[i] >> k;\n      int bit = 0;\n      rep (j, k) {\n\tint r;\n\tcin >> r;\n\tbit |= 1 << r;\n      }\n      need[i] = bit;\n    }\n    int res = n;\n    rep (bit, 1 << n) {\n      int sum = 0;\n      bool ok = true;\n      rep (i, n) if (bit & 1 << i) {\n\tif ((bit & need[i]) != need[i]) {\n\t  ok = false;\n\t  break;\n\t}\n\tsum += tani[i];\n      }\n      if (!ok || sum < u) continue;\n      res = min(res, __builtin_popcount(bit));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return __builtin_popcount(S) < __builtin_popcount(s.S);\n  }\n  bool operator>(const State& s) const {\n    return __builtin_popcount(S) > __builtin_popcount(s.S);\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if((prior[i] | s.S) == s.S){\n\tif(dp[s.S | (1<<i)] != -1) continue;\n\tdp[s.S | (1<<i)] = s.sum + credit[i];\n\n\tif(s.sum + credit[i] >= credit_requirement) {\n\t  return __builtin_popcount(s.S) + 1;\n\t}\n\tque.push(State(s.S | (1<<i),s.sum + credit[i]));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U;\n  int c[30],k[30],r[30][30];\n\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++)scanf(\"%d\",&r[i][j]);\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = __builtin_popcount(i), sum = 0;\n      if(res <= num)continue;\n\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  sum += c[j];\n\t  for(int l=0;l<k[j];l++){\n\t    f &= (i>>r[j][l])&1;\n\t    if(!f)break;\n\t  }\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tint i = (1 << bits) - 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((i & r[j]) != r[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts += c[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok && s >= u)\n\t\t\t\t{\n\t\t\t\t\tres = bits;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\t// combination\n\t\t\t\tint leastBit = i & -i;\n\t\t\t\tint mostBits = i + leastBit;\n\t\t\t\tint leastSequentialBits = i & ~mostBits;\n\t\t\t\ti = mostBits | ((leastSequentialBits / leastBit) >> 1);\n\t\t\t} while (i < 1 << n);\n\t\t}\nend:\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21][21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i][d]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tfor(int k=0;k<a;k++)\n\t\t\t\t\t\tif(g[j][k]&&!(i&(1<<k)))ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=min(ret,__builtin_popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1<<21)\nint n,U , unit[20];\n\n\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tint ans = 99;\n\t\tfor(int i = 0 ; i < (1<<n) ; i++){\n\t\t\tint v = __builtin_popcount(i) , a = 0;\n\t\t\tbool f = true;\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(i >> j & 1){\n\t\t\t\t\tif( (i & graph[j]) != graph[j] ){f = false;goto exit;}\n\t\t\t\t\ta += unit[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\texit: if(f && a >= U)ans = min(v,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nvector<int> vec,v[MAX];\n\nvoid init(int N){\n  for(int i = 1 ; i < 1<<N ; i++){\n    int idx = __builtin_popcount(i);\n    v[idx-1].push_back(i);\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < (int)v[i].size() ; j++){\n      vec.push_back(v[i][j]);\n    }\n  }\n}\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    init(N);\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF;\n    for(int i = 0 ; i < (int)vec.size() ; i++){\n      int S = vec[i];\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int j = 0 ; j < N ; j++){\n        if(S >> j & 1){\n          if(arr[j] == 0 || S & arr[j] == arr[j]){\n            cnt += c[j]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        if(total < ans){\n          ans = total;\n          break;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n};\n\n#define INF (1<<21)\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tQ.push(NODE(0,0,0));\n\t\tdone[0] = 1;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)])Q.push(NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1)) , done[q.a|(1<<i)] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n    int n, u;\n    while(cin >> n >> u, n+u){\n        vector<int> c(n), p(n);\n        for(int i = 0; i < n; i++){\n            cin >> c[i];\n            int k;  cin >> k;\n            while(k-- > 0){\n                int r;  cin >> r;\n                p[i] |= (1<<r);\n            }\n        }\n        \n        auto popcnt = [](int x)->int{\n            int ret = 0;\n            while(x > 0){\n                ret += x&1;\n                x >>= 1;\n            }\n            return ret;\n        };\n\n        int ans = 21;\n        queue<pair<int,int>> q;\n        vector<bool> visit(1<<n, 0);\n        q.push({0, 0});\n        while(!q.empty()){\n            pair<int,int> x = q.front();    q.pop();\n            int bit = x.first, score = x.second;\n            if(visit[bit])  continue;\n            visit[bit] = true;\n            if(score >= u){\n                ans = min(ans, popcnt(bit));\n                continue;\n            }\n            for(int i = 0; i < n; i++){\n                if( ((bit>>i)&1) == 1 || (p[i]&bit) != p[i] || visit[bit|(1<<i)])    continue;\n                q.push({bit|(1<<i), score+c[i]});\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct node{\n  int bits, cost;\n};\nnode info[20];\nint n, U;\nint dp[1 << 20];\n\nint rec(int used, int sbj){ //used: 修得済みの教科\n  if(~dp[used]) return dp[used];\n  if(sbj >= U) return __builtin_popcount(used);\n  int ret = n;\n  for(int i = 0; i < n; i++){\n    if(info[i].bits&~used || used >> i & 1) continue;\n    ret = min( ret, rec( used|(1 << i), sbj + info[i].cost));\n  }\n  return dp[used] = ret;\n}\n\nint main(){\n  while(cin >> n >> U, n){\n    fill_n( dp, 1 << 20, -1);\n    for(int i = 0; i < n; i++){\n      int k;\n      cin >> info[i].cost >> k;\n      info[i].bits = 0;\n      while(k--){\n        int r;\n        cin >> r;\n        info[i].bits |= 1 << r;\n      }\n    }\n    cout << rec( 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cassert>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0));\n  int i;\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(visited[ns.used]) continue;\n    if(ns.cost >= U) {\n      return pop(ns.used);\n    }\n\n    visited[ns.used] = 1;\n\n    for(i=0; i<n; ++i) {\n      if(!((ns.used>>i)&1) && (ns.used & pv[i])==pv[i]) {\n\tQ.push((state){(ns.used|(1<<i)),ns.cost+cv[i]});\n      }\n    }\n  }\n\n  assert(false);\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(visited, false, sizeof(visited));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint need[30];\nint tani[30];\n\nint main() {\n  int n, u;\n  for (;;) {\n    cin >> n >> u;\n    if (n == 0 && u == 0) break;\n    rep (i, n) {\n      int k;\n      cin >> tani[i] >> k;\n      int bit = 0;\n      rep (j, k) {\n\tint r;\n\tcin >> r;\n\tbit |= 1 << r;\n      }\n      need[i] = bit;\n    }\n    int res = n;\n    rep (bit, 1 << n) {\n      int koma = __builtin_popcount(bit);\n      if (res <= koma) continue;\n      int sum = 0;\n      bool ok = true;\n      rep (i, n) if (bit & 1 << i) {\n\tif ((bit & need[i]) != need[i]) {\n\t  ok = false;\n\t  break;\n\t}\n\tsum += tani[i];\n      }\n      if (!ok || sum < u) continue;\n      res = koma;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U;\n  int c[30],k[30],r[30][30];\n\n  while(cin >> n >> U,(n||U)){\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> k[i];\n      for(int j=0;j<k[i];j++)cin >> r[i][j];\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = 0, sum = 0;\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  num++;\n\t  sum += c[j];\n\t  for(int l=0;l<k[j];l++){\n\t  f &= (i>>r[i][l])&1;\n\t  if(!f)break;\n\t  }\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 20\n\nint n, U;\nint cs[MAX_N];\nint rs[MAX_N];\n\nbool check(int S) {\n    // 総単位数がUを越えているか\n    int unit = 0;\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            unit += cs[i];\n        }\n    }\n    if (unit < U) return false;\n\n    // 履修に必要な単位をすべて取得しているか\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            if ((S & rs[i]) != rs[i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (cin >> n >> U, n || U) {\n        memset(cs, 0, sizeof(cs));\n        memset(rs, 0, sizeof(rs));\n        for (int i = 0; i < n; i++) {\n            int c, k, r;\n            cin >> c >> k; r = 0;\n            for (int j = 0; j < k; j++) {\n                int _r; cin >> _r;\n                r |= (1<<_r);\n            }\n            cs[i] = c;\n            rs[i] = r;\n        }\n\n        int ans = (1<<28);\n        for (int S = 1; S < (1<<n); S++) {\n            if (check(S)) {\n                ans = min(ans, __builtin_popcount(S));\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool visited[20];\nint bitmask[20];\nint memo[1<<20];\nint c[20];\nint n,U;\n\nint solve(int S, int sum) {\n  if (memo[S]>=0) return memo[S];\n//  cout <<bitset<4>(S) << \" \"  << sum << endl;\n  if (sum >= U) return 0;\n  int res = INF;\n  REP(i,n) {\n    if (!(S>>i&1)) {\n      if ((S&bitmask[i]) == bitmask[i]) {\n        res = min(res, solve(S|1<<i, sum+c[i])+1);\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n>>U, n||U) {\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      cin >> c[i] >> k;\n      REP(j,k) {\n        int r;\n        cin >> r;\n        bitmask[i] |= 1<<r;\n      }\n    }\n    if (U==0) {                 // ツつ「ツづゥツつゥツ不ツ鳴セ\n      cout << 0 << endl;\n      continue;      \n    }\n\n    memset(visited,0,sizeof(visited));\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tclock_t t0=clock();\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\t\t\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\tclock_t t1=clock();\n\tprintf(\"%.3f[s]\\n\",1.*(t1-t0)/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  if(dp[S] != -1) return;\n  dp[S] = sum;\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] == -1) continue;\n      if(dp[S] >= credit_requirement){\n\tres = min(res,__builtin_popcount(S));\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nchar visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n};\n\nint solve(int N, int U, int tno) {\n  queue<State> up;\n  static State s;\n  s.one = s.mask = s.have = 0;\n  visited[s.mask] = tno;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.front(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] != tno && (s.mask | need[i]) == s.mask )\n        {\n          static State next;\n          next.mask = s.mask | (1 << i);\n          next.one = s.one + 1;\n          next.have = s.have + unit[i];\n          visited[next.mask] = 1;\n          up.push(next);\n        }\n  }\n  return -1;\n}\n\nint main() {\n  for(int tno = 0;;) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U, ++tno);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 21\n#define INF 1e9\n\nvector<int> vec,v[MAX];\n\nvoid init(int N){\n  vec.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    v[i].clear();\n  }\n  for(int i = 1 ; i < 1<<N ; i++){\n    int idx = __builtin_popcount(i);\n    v[idx-1].push_back(i);\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < (int)v[i].size() ; j++){\n      vec.push_back(v[i][j]);\n    }\n  }\n}\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    init(N);\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF;\n    for(int i = 0 ; i < (int)vec.size() ; i++){\n      int S = vec[i];\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int j = 0 ; j < N ; j++){\n        if(S >> j & 1){\n          if(arr[j] == 0 || S & arr[j] == arr[j]){\n            cnt += c[j]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        if(total < ans){\n          ans = total;\n          break;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint need[30];\nint tani[30];\n\nint main() {\n  int n, u;\n  for (;;) {\n    cin >> n >> u;\n    if (n == 0 && u == 0) break;\n    rep (i, n) {\n      int k;\n      cin >> tani[i] >> k;\n      int bit = 0;\n      rep (j, k) {\n\tint r;\n\tcin >> r;\n\tbit |= 1 << r;\n      }\n      need[i] = bit;\n    }\n    int res = n;\n    rep (bit, 1 << n) {\n      int koma = __builtin_popcount(bit);\n      if (res <= koma) continue;\n      int sum = 0, b = bit;\n      while (b) {\n\tint clz = 31 - __builtin_clz(b);\n\tif ((bit & need[clz]) != need[clz]) goto aaa;\n\tb ^= 1 << clz;\n\tsum += tani[clz];\n      }\n      if (sum < u) continue;\n      res = koma;\n    aaa:;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nbool visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n  bool operator<(const State& t) const {\n    if( one != t.one ) return one > t.one;\n    return have < t.have;    \n  }\n};\n\nint solve(int N, int U) {\n  memset(visited, 0, sizeof(visited));\n  priority_queue<State> up;\n  State s;\n  s.one = 0;\n  s.mask = 0;\n  s.have = 0;  \n  visited[s.mask] = 1;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.top(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( (s.mask & (1 << i) ) == 0 && (s.mask & need[i]) == s.mask )\n      {\n        State next;        \n        next.mask = s.mask | (1 << i);\n        if( visited[next.mask] ) continue;        \n        next.one = s.one + 1;\n        next.have = s.have + unit[i];\n        visited[next.mask] = 1;\n        up.push(next);\n      }\n  }\n  return -1;\n}\n\nint main() {\n  for(;;) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n  state ns(0,0,0);;\n  int i;\n\n  while(!Q.empty()) {\n    ns = Q.front(); Q.pop();\n    for(i=0; i<n; ++i) {\n      if((ns.used>>i) & 1\n\t || memo[ns.used|k]\n\t || (ns.used & pv[i] != pv[i])) continue;\n      memo[ns.used|(1<<i)] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, 0, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\t//for(int i = 0; i < tos[s].size(); i++){\n\t\t//\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t//\tif(minCost==1)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>tani[i]>>k;\n\t\t\tneeds[i]=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\tneeds[i]|=(1<<t);\n\t\t\t}\n\t\t}\n\t\t//for(int s = 0; s < (1<<n); s++){\n\t\t//\tfor(int i = 0; i < n; i++){\n\t\t//\t\tif(!((s>>i)&1)){\n\t\t//\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\t\ttos[s].push_back(i);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//for(int i = 0; i < (1<<n); i++)\n\t\t//\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nmain(){\n  int n,u;\n\n  while(cin>>n>>u,n|u){\n    vector<int> nec[n];\n    int tani[n];\n\n    rep(i,n){\n      cin>>tani[i];\n      int k;\n      cin>>k;\n      rep(j,k){\n\tint t;\n\tcin>>t;\n\tnec[i].pb(t);\n      }\n    }\n\n    int ans=INT_MAX/2;\n    queue<int> Q;\n    set<int> app;\n    Q.push(0);\n    app.insert(0);\n\n    while(!Q.empty()){\n      int cstate=Q.front();Q.pop();\n\n      int tu=0,ckamoku=0;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n      rep(i,n){\n\tif(app.count(cstate|(1<<i)))continue;\n\tbool ok=true;\n\trep(j,nec[i].size()){\n\t  if(cstate>>nec[i][j]&1)continue;\n\t  ok=false;\n\t  break;\n\t}\n\tif(ok){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t  app.insert(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(men >= (1<<2)-1 && ans == 2)\n\t    break;\n\t  else if(men >= (1<<3)-1 && ans == 3)\n\t    break;\n\t  else if(men >= (1<<4)-1 && ans == 4)\n\t    break;\n\t  else if(men >= (1<<5)-1  && ans == 5)\n\t    break;\n\t  else if(men >= (1<<6)-1 && ans == 6)\n\t    break;\n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<20); S++){\n      if(dp[S] < credit_requirement) continue;\n      res = min(bitcount[S],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n//vector<pair<int,int > > vpii;\n\npair<int,int> vpii[21];\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\t//vpii.push_back(p);\n\t\t\t//vpii[i]=p;\n\t\t\ttani[i]=p.first;\n\t\t\tneeds[i]=p.second;\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//vpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#ifdef _MSC_VER\n#define __builtin_popcount(x) (__popcnt(x))\n#define __builtin_popcountll(x) (__popcnt(x) + __popcnt(x >> 32))\n#endif\nint n, x, c[22], l[22], r[22][22];\nint main() {\n\twhile (cin >> n >> x, n | x) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c[i] >> l[i];\n\t\t\tfor (int j = 0; j < l[i]; j++) cin >> r[i][j];\n\t\t}\n\t\tint ret = 999999999;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tbool flag = true;\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tsum += c[j];\n\t\t\t\t\tfor (int k = 0; k < l[j]; k++) {\n\t\t\t\t\t\tif (!(i & (1 << r[j][k]))) {\n\t\t\t\t\t\t\tflag = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) break;\n\t\t\t}\n\t\t\tif (flag && sum >= x) ret = min(ret, (int)__builtin_popcount(i));\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main()\n{\n   int N,U,K;\n   while(cin>>N>>U,N|U){\n      pair<int, int> piv[N];\n      int ans = INT_MAX;\n      for(int i=0; i<N; i++){\n         cin>>piv[i].first>>K;\n         for(int j=0; j<K; j++){\n            int a; cin>>a;\n\t\t\t\tpiv[i].second |= (1<<a);\n         }\n      }\n      for(int i=1; i<(1<<N); i++){\n         int cnt = 0;\n         int sum = 0;\n         int tmp = 0;\n         for(int j=0; (1<<j)<=i; j++){\n            if( i&(1<<j) ){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tif( tmp>ans )break;\n\t\t\t\t\tif( i&piv[j].second != piv[j].second )break;\n\t\t\t\t\tsum += piv[j].first;\n\t\t\t\t\tcnt++;\n            }\n         }\n         if( tmp==cnt && sum>=U && ans>cnt){\n            ans = cnt;\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 20;\n\nint n, U, C[N], K[N], R[N];\nbool vis[1<<N];\n\nint solve(){\n  queue<P> q;\n  q.push(P(0, 0));\n  fill(vis, vis+(1<<n), false);\n  while(!q.empty()){\n    P u = q.front(); q.pop();\n    if(u.second >= U){\n      int res = 0;\n      for(int i=0;i<n;i++) if((u.first >> i) & 1) res++;\n      return res;\n    }\n    if(vis[u.first]) continue;\n    vis[u.first] = true;\n    for(int i=0;i<n;i++){\n      if(!((u.first >> i) & 1) && (u.first & R[i]) == R[i]){\n        q.push(P(u.first | (1<<i), u.second + C[i]));\n      }\n    }\n  }\n}\n\nmain(){\n  while(scanf(\"%d %d\", &n, &U) && (n|U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d\", &C[i], &K[i]);\n      R[i] = 0;\n      for(int j=0;j<K[i];j++){\n        int r;\n        scanf(\"%d\", &r);\n        R[i] |= 1 << r;\n      }\n    }\n    printf(\"%d\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<bitset>\n#include<deque>\n#include<algorithm>\nusing namespace std;\n\nstruct Pox\n{\n  int state,cost;\n  Pox(int state,int cost):state(state),cost(cost){}\n};\n\nint main()\n{\n  while(1)\n    {\n      int n,U,k,r;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int mincost[1<<n];\n      for(int i=0;i<(1<<n);i++)\n\tmincost[i] = (1<<n);\n      deque<Pox> deq;\n      int G[n];\n      int c[n];\n      for(int i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      deq.push_back(Pox(0,0));\n      mincost[0] = 0;     \n      int ans = (1<<n);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  int num = __builtin_popcount(pox.state);\n\t  if(num >= ans)\n\t    continue;\n   \n\t  if(pox.cost >= U)\n\t    {\n\t      ans = min(ans,num);\n\t      continue;\n\t    }\t \n\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((pox.state >> i) & 1)\n\t\tcontinue;\n\t      int pre = G[i];\n\t      pre &= pox.state;\n\t      if(pre != G[i])\n\t\tcontinue;\n\t      if(mincost[pox.state|(1<<i)] <= num+1)\n\t\tcontinue;\n\t      mincost[pox.state|(1<<i)] = num+1;\n\t      if(pox.cost + c[i] < U)\n\t\tdeq.push_back(Pox(pox.state|(1<<i),pox.cost+c[i]));\n\t      else \n\t\tans = min(ans,num+1);\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n, U;\n  while(cin>>n>>U, n||U) {\n    int bitmask[n];\n    int c[n];\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      cin >> c[i] >> k;\n      REP(j,k) {\n        int r;\n        cin >> r;\n        bitmask[i] |= 1<<r;\n      }\n    }\n    if (U==0) {                 // ツつ「ツづゥツつゥツ不ツ鳴セ\n      cout << 0 << endl;\n      continue;      \n    }\n    bool ok = 0;\n    int res = 0;\n    for (int k=1; k<=n; ++k) {\n      int S = (1<<k)-1;\n      while(S<1<<n) {\n        int sum = 0;\n        bool dame = 0;\n        REP(i,k) {\n          if (S>>i&1) {\n            if (S&bitmask[i] != bitmask[i]) {\n              dame = 1;\n              break;\n            }\n            sum += c[i];\n          }\n        }\n        if (!dame && sum >= U) {\n          ok = 1;\n          res = k;\n          break;\n        }\n        int x = S&-S, y=S+x;\n        S = ((S & ~y) / x >> 1) | y;\n      }\n      if (ok) break;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(men >= (1<<2)-1 && ans == 2)\n\t    break;\n\t  else if(men >= (1<<3)-1 && ans == 3)\n\t    break;\n\t  else if(men >= (1<<4)-1 && ans == 4)\n\t    break;\n\t  else if(men >= (1<<5)-1  && ans == 5)\n\t    break;\n\t  else if(men >= (1<<6)-1 && ans == 6)\n\t    break;\n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint points;\n\tvector<int> pre_SUBJECT;\n};\n\nint N,need_points,POW[21];\nInfo info[21];\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++)info[i].pre_SUBJECT.clear();\n\n\tint num,tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[i].pre_SUBJECT.push_back(tmp);\n\t\t}\n\t}\n\n\tbool FLG,check[N];\n\tint ans = BIG_NUM,count;\n\n\tfor(int state = 1; state < POW[N]; state++){\n\t\tcount = 0;\n\t\ttmp = 0;\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t\ttmp += info[loop].points;\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\t\tif(count >= ans || tmp < need_points)continue;\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(check[i]){\n\t\t\t\tfor(int k = 0; k < info[i].pre_SUBJECT.size(); k++){\n\t\t\t\t\tif(check[info[i].pre_SUBJECT[k]] == false){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\n\t\tif(FLG){\n\t\t\tans = count;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nvector<int> vec,v[MAX];\n\nvoid init(){\n  for(int i = 1 ; i < 1<<MAX ; i++){\n    int idx = __builtin_popcount(i);\n    v[idx-1].push_back(i);\n  }\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < (int)v[i].size() ; j++){\n      vec.push_back(v[i][j]);\n    }\n  }\n}\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  init();\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF,mini = INF;\n    for(int I = 0 ; I < (int)vec.size() ; I++){\n      int S = vec[I];\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int i = 0 ; i < N ; i++){\n        if(S >> i & 1){\n          if(arr[i] == 0 || S & arr[i] == arr[i]){\n            cnt += c[i]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(mini < total) break;\n      if(flg && cnt >= U){\n        if(total < ans){\n          ans = total;\n          mini = total;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<bitset>\n#include<queue>\n#include<functional>\n#include<map>\nusing namespace std;\nint F(int x)\n{\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n\tx = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n\treturn (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\ntypedef pair<int,int>P;\nstruct C:binary_function<P,P,bool>{bool operator()(P a,P b){return F(a.second)>F(b.second);}};\nint main()\n{\n\tint n,u,k,r,i,j;\n\tbitset<1<<20>f;\n\twhile(scanf(\"%d%d\",&n,&u),n)\n\t{\n\t\tf.reset();\n\t\tpair<int,int>a[20];\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tfor(scanf(\"%d%d\",&a[i].first,&k);k--;)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\ta[i].second|=(1<<r);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P>q;\n\t\tq.push(P(0,0));\n\t\tfor(;;)\n\t\t{\n\t\t\tP p=q.top();q.pop();\n\t\t\tif(f[p.second])continue;\n\t\t\tf[p.second]=1;\n\t\t\tif(p.first>=u){printf(\"%d\\n\",F(p.second));break;}\n\t\t\tfor(i=0;i<n;++i)if((p.second&a[i].second)==a[i].second)q.push(P(p.first+a[i].first,p.second|(1<<i)));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<bitset>\n#include<queue>\n#include<functional>\n#include<map>\nusing namespace std;\nint F(int x)\n{\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n\tx = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n\treturn (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\ntypedef pair<int,int>P;\nstruct C:binary_function<P,P,bool>{bool operator()(P a,P b)\n{\n\tint x=F(a.second),y=F(b.second);\n\treturn x-y?x>y:a.first>b.first;\n}\n};\nint main()\n{\n\tint n,u,k,r,i,j;\n\tbitset<1<<20>f;\n\twhile(scanf(\"%d%d\",&n,&u),n)\n\t{\n\t\tf.reset();\n\t\tpair<int,int>a[20];\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tfor(scanf(\"%d%d\",&a[i].first,&k);k--;)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\ta[i].second|=(1<<r);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P,vector<P>,C>q;\n\t\tq.push(P(0,0));\n\t\tfor(;;)\n\t\t{\n\t\t\tP p=q.top();q.pop();\n\t\t\tif(f[p.second])continue;\n\t\t\tf[p.second]=1;\n\t\t\tif(p.first>=u){printf(\"%d\\n\",F(p.second));break;}\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tif((p.second&a[i].second)==a[i].second)\n\t\t\t\t\tq.push(P(p.first+a[i].first,p.second|(1<<i)));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t      \n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\t//rep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\t//rep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\trep(j,n) cnt+=(b>>j&1),sum+=(b>>j&1)*cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct data{\n  int point, req;\n  data(){}\n  data(int p, int r):point(p),req(r){}\n};\n\nint N,U;\nvector<data> V;\nvoid init(){\n  V.clear();\n}\n\nvoid input(){\n\n  for(int i = 0; i < N; i++){\n    data d;\n    cin >> d.point;\n    int k;\n    cin >> k;\n    while(k--){\n      int in;\n      cin >> in;\n      d.req += (1<<in);\n    }\n    V.push_back(d);\n  }\n}\n\nint get(int n){\n\n  int sum = 0;\n  for(int i = 0; i < N; i++){\n    if(n&(1<<i) && n&V[i].req != V[i].req) return -1;\n    if(n&(1<<i) && n&V[i].req == V[i].req) sum += V[i].point;\n  }\n  return sum;\n}\n\nint Bit(int n){\n  int res = 0;\n  for(int i = 0; i < N; i++)\n    if(n&(1<<i)) res++;\n\n  return res;\n}\nvoid solve(){\n  int ans = 30;\n\n  for(int i = 1; i < (1<<N); i++){\n    int res = get(i);\n    if(res >= U) ans = min(ans,Bit(i));\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  \n  while(cin >> N >> U && N+U){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint n,U;\nint ans;\nint c[22],need[22]; //eÈÚÌPÊ, C·éÌÉKvÈÈÚ(rbgÇ)\n\n//ÈÚÌæèûÉµªÈ¢©Ç¤©`FbN·é\nbool check(int used){\n  rep(i,n){\n    //CÈÚÉKvÈÈÚÌPÊªæêÄé©`FbN\n    if((used & (1<<i)) > 0 && (used & need[i]) != need[i]){\n      return false;\n    }\n  }\n  return true;\n}\n\n//id:ÈÚÔ, used:ÇÌÈÚæÁ½©(rbgÇ), sum:PÊv, cnt:CÈÚ\nvoid solve(int id,int used,int sum,int cnt){\n  if(id == n){\n    if(sum >= U && ans > cnt && check(used)){\n      ans = cnt;\n    }\n    return;\n  }\n\n  solve(id+1,used,sum,cnt); //ÆçÈ¢\n  solve(id+1,used|(1<<id),sum+c[id],cnt+1); //Æé\n}\n\nint main(void){\n  while(scanf(\"%d%d\",&n,&U),n||U){\n    rep(i,n){\n      int k;\n      scanf(\"%d%d\",&c[i],&k);\n      need[i] = 0;\n\n      while(k--){\n        int r;\n        scanf(\"%d\",&r);\n        need[i] |= (1<<r);\n      }\n    }\n\n    ans = INT_MAX;\n    solve(0,0,0,0);\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Kamoku {\n\tint tani;\n\tint need;\n\tKamoku() : tani(0) {}\n};\n\nint bitcount(int n) {\n\tint cnt = 0;\n\twhile(n) {\n\t\tif(n&1) ++cnt;\n\t\tn >>= 1;\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile(true) {\n\t\tint n, U;\n\t\tcin >> n >> U;\n\t\tif(!n && !U) break;\n\t\tvector<Kamoku> v(n);\n\t\tvector<bool> islast(n, true);\n\t\tvector<int> last;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint c, k;\n\t\t\tcin >> c >> k;\n\t\t\tv[i].tani = c;\n\t\t\tv[i].need = 0;\n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\tint r;\n\t\t\t\tcin >> r;\n\t\t\t\tv[i].need |= (1<<r);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 1000000;\n\t\tvector<bool> dp(1<<n, false);\n\t\tfor(int i = 0; i < (1<<n); ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tint mask = i | (1<<j);\n\t\t\t\tif((v[j].need & mask) == v[j].need) {\n\t\t\t\t\tdp[mask] = true;\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\t\t\tif(mask & (1<<k)) {\n\t\t\t\t\t\t\tsum += v[k].tani;\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sum >= U) ans = min(ans, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\n//vector<int> tos[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\t//for(int i = 0; i < tos[s].size(); i++){\n\t\t//\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t//\tif(minCost==1)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\ttn=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\ttn|=(1<<t);\n\t\t\t}\n\t\t\ttani[i]=c;\n\t\t\tneeds[i]=tn;\n\t\t}\n\t\t//for(int s = 0; s < (1<<n); s++){\n\t\t//\tfor(int i = 0; i < n; i++){\n\t\t//\t\tif(!((s>>i)&1)){\n\t\t//\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\t\ttos[s].push_back(i);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//for(int i = 0; i < (1<<n); i++)\n\t\t//\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  State(){}\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  int next_sum;\n  int next_S;\n  State s;\n  int rest;\n  while(!que.empty()){\n    s = que.top();\n    que.pop();\n    for(int i = 0; i < total_subjects; i++){\n      if(dp[next_S = (s.S | (1<<i))] != -1) continue;\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[next_S] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(next_S,next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\tif(__builtin_popcount(b)>=res) continue;\n\t\t\trep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\npair<int,int>p[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)p[i]=make_pair(t[i],g[i]);\n\t\tstd::sort(p,p+a);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tt[i]=p[a-1-i].first;\n\t\t\tg[i]=p[a-1-i].second;\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)continue;\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n//vector<pair<int,int > > vpii;\n\npair<int,int> vpii[21];\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\t//pair<int,int > p;\n\t\t\tint tn=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\ttn|=(1<<t);\n\t\t\t}\n\t\t\t//vpii.push_back(p);\n\t\t\t//vpii[i]=p;\n\t\t\ttani[i]=c;\n\t\t\tneeds[i]=tn;\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//vpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] == -1) continue;\n      if(dp[S] >= credit_requirement){\n\tres = min(res,__builtin_popcount(S));\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bitset>\n#include<map>\nint F(int x)\n{\n\tint r=0;\n\tfor(; x; x&=x-1)\n\t\t++r;\n\treturn r;\n}\nstd::bitset<1<<20>f;\nint dp[1<<20];\nint main()\n{\n\tint n,u,k,r,i,j,x,y,z;\n\twhile(scanf(\"%d%d\",&n,&u),n)\n\t{\n\t\tf.reset();\n\t\tstd::pair<int,int>a[20];\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a[i].first,&k);\n\t\t\tif(k)\n\t\t\t{\n\t\t\t\twhile(k--)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\t\ta[i].second|=(1<<r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse f[1<<i]=1,dp[1<<i]=a[i].first;\n\t\t}\n\t\tfor(i=1;i<=n;++i)\n\t\t{\n\t\t\tz=(1<<i)-1;\n\t\t\twhile(z<(1<<n))\n\t\t\t{\n\t\t\t\tif(f[z])\n\t\t\t\t{\n\t\t\t\t\tif(dp[z]>=u){printf(\"%d\\n\",F(z));goto E;}\n\t\t\t\t\tfor(j=0;j<n;++j)\n\t\t\t\t\t\tif((z&a[j].second)==a[j].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf[z|(1<<j)]=1;\n\t\t\t\t\t\t\tdp[z|(1<<j)]=dp[z]+a[j].first;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=z&-z;\n\t\t\t\ty=z+x;\n\t\t\t\tz=((z&~y)/x/2)|y;\n\t\t\t}\n\t\t}\n\t\tE:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint main() {\n  for(;;) {\n    int N, U;\n    scanf(\"%d%d\", &N, &U);\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n    REP(i, N) {\n      scanf(\"%d\", &unit[i]);\n      int K; scanf(\"%d\", &K);\n      REP(k, K) {\n        int x; scanf(\"%d\", &x);\n        need[i] |= (1 << x);\n      }\n    }\n    \n    int all = 0;\n    REP(i, N) all += unit[i];\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    \n    int best = N;\n    for(int mask = 0; mask < 1 << N; mask++) {\n      int one = __builtin_popcount(mask);\n      if( best <= one ) continue;\n      \n      int have = 0;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) have += unit[k];        \n      if( have < U ) continue;\n      \n      bool can = true;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) {\n          if( (mask | (need[k])) != mask ) {\n            can = false;\n            break;\n          }\n        }\n\n      if( can ) \n        best = one;\n      \n    }\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\n//vector<int> tos[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\t//for(int i = 0; i < tos[s].size(); i++){\n\t\t//\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t//\tif(minCost==1)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\ttn=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\ttn|=(1<<t);\n\t\t\t}\n\t\t\ttani[i]=c;\n\t\t\tneeds[i]=tn;\n\t\t}\n\t\t//for(int s = 0; s < (1<<n); s++){\n\t\t//\tfor(int i = 0; i < n; i++){\n\t\t//\t\tif(!((s>>i)&1)){\n\t\t//\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\t\ttos[s].push_back(i);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//for(int i = 0; i < (1<<n); i++)\n\t\t//\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint n,U;\n\nint dfs(vvi &r, vi &c, vi &ng, int credits, int pos, int courses, vi &take){\n\tif(pos==n){\n\t\tREP(i,n){\n\t\t\tif(ng[i]&&take[i]){\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\t\t}\n\t\treturn (credits>=U?courses:INT_MAX);\n\t}\n\tint ret=INT_MAX;\n\tREP(i,2){\n\t\ttake[pos]=i;\n\t\tREP(j,n){\n\t\t\tif(!i){\n\t\t\t\tng[j]+=r[j][pos];\n\t\t\t}\n\t\t}\n\t\tret=min(ret,dfs(r,c,ng,credits+(i?c[pos]:0),pos+1,courses+i,take));\n\t\tREP(j,n){\n\t\t\tif(!i){\n\t\t\t\tng[j]-=r[j][pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n>>U,n||U){\n\t\tvi c(n);\n\t\tvvi r(n,vi(n));\n\t\tREP(i,n){\n\t\t\tcin>>c[i];\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tREP(i,k){\n\t\t\t\tint rr;\n\t\t\t\tcin>>rr;\n\t\t\t\tr[i][rr]=1;\n\t\t\t}\n\t\t}\n\t\tvi ng(n);\n\t\tvi take(n);\n\t\tcout<<dfs(r,c,ng,0,0,0,take)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nint best;\nint N, U;\nint tno;\nint gain[20];\nchar visited[1 << 20];\nvoid dfs(int mask, int one, int have) {\n  if( best <= one ) return;\n  if( have >= U ) {\n    best = one;\n    return;\n  }\n  if( have + gain[best - one - 1] < U ) return;\n\n  for(int i = 0; i < N; i++)\n    if ( visited[mask | (1 << i)] != tno && (mask | need[i]) == mask )\n      {\n        visited[mask | (1 << i)] = tno;\n        dfs( mask | (1 << i), one + 1, have + unit[i] );\n      }\n}\n\nint main() {\n  for(tno = 1;; tno++) {\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      gain[i] = unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n\n    sort( gain, gain + N );\n    reverse( gain, gain + N );\n    for(int i = 1; i < N; i++)\n      gain[i] += gain[i - 1];\n\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n\n    best = N;\n    dfs(0, 0, 0);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U;\n  int c[30],k[30],r[30][30];\n\n  while(cin >> n >> U,(n||U)){\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> k[i];\n      for(int j=0;j<k[i];j++)cin >> r[i][j];\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = __builtin_popcount(i), sum = 0;\n      if(res <= num)continue;\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  sum += c[j];\n\t  for(int l=0;l<k[j];l++){\n\t    f &= (i>>r[j][l])&1;\n\t    if(!f)break;\n\t  }\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20] = {};\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0));\n  int i;\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(visited[ns.used]) continue;\n    if(ns.cost >= U) {\n      return pop(ns.used);\n    }\n\n    visited[ns.used] = 1;\n\n    for(i=0; i<n; ++i) {\n      if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n\tQ.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n\n    rep(i, 1<<n) visited[i] = false;\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp;\nint c[30],k[30],r[30];\nbool f[30][30];\nint cost[1<<21],num[1<<21];\nvector<int> v;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    v.clear();\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++){\n\tif(f[i][j])r[i] |= 1<<j;\n      }\n    }\n\n    for(int i=0;i<(1<<n);i++){\n      int tmp = 0;\n      for(int j=0;j<n;j++){\n\tif( (i>>j) &1)tmp |= r[j];\n      }\n      v.push_back(tmp);\n    }\n\n    sort(v.begin(),v.end());\n    v.erase( unique(v.begin(),v.end()),v.end());\n\n    int res = 20;\n    for(int i = 0;i<(int)v.size();i++){\n      int sum = 0;\n      for(int j=0;j<n;j++){\n\tif( (v[i]>>j)&1)sum += c[j];\n      }\n      if(U<=sum)res = min(res,__builtin_popcount(v[i]));\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t;\n\nmain(){\n  int n,u;\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    int ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<int> Q;\n    Q.push(0);\n\n    while(!Q.empty()){\n      int cstate=Q.front();Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      int tu=0,ckamoku=0;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U;\n  int c[30],k[30],r[30][30];\n\n  while(cin >> n >> U,(n||U)){\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> k[i];\n      for(int j=0;j<k[i];j++)cin >> r[i][j];\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = 0, sum = 0;\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  num++;\n\t  sum += c[j];\n\t  for(int l=0;l<k[j];l++){\n\t  f &= (i>>r[j][l])&1;\n\t  if(!f)break;\n\t  }\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n    int used,cost;\n    state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n    int n = 0;\n    while(x != 0) {\n        n++;\n        x &= (x-1);\n    }\n    return n;\n}\n\ninline int bit_count(int x)\n{\n  x = (x & 0x55555555) + (x >> 1 & 0x55555555);\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n  x = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n  return (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\n\ninline unsigned next_set(unsigned x)\n{\n  unsigned smallest = x & -x;\n  unsigned ripple = x + smallest;\n  unsigned new_smallest = ripple & -ripple;\n  unsigned ones = ((new_smallest / smallest) >> 1) - 1;\n  return ripple | ones;\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        if(U == 0) {\n            cout<<0<<endl;\n            continue;\n        }\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        int ans = 100000,t;\n        for(int k=1; k<=n; ++k) {\n            for(int i=(1<<k)-1; i<1<<n; i = next_set(i)) {\n                t = 0;\n                for(int j=0; j<n; ++j) {\n                    if((i>>j)&1 != 0) {\n                        if(pv[j] != pv[j] & i) goto NEXT;\n                        t += cv[j];\n                    }\n                }\n                if(t >= U) {\n                    ans = min(ans,bit_count(i));\n                    goto END;\n                }\n            NEXT:;\n            }\n        }\n    END:;\n//        cout<<bfs()<<endl;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, U, a[20], b[20], c, r[20], popcount[1048588];\nint main() {\n\tfor (int i = 0; i < 20; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n >> U; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> b[i]; r[i] = 0;\n\t\t\tfor (int j = 0; j < b[i]; j++) { cin >> c; r[i] += (1 << c); }\n\t\t}\n\t\tint minx = 10000000;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i & (1 << j)) sum += a[j];\n\t\t\t}\n\t\t\tif (sum < U)continue;\n\t\t\tbool flag = false;\n\t\t\tint G = (1 << n) - 1; G -= i;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i & (1 << j)) && (G & r[j])) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) minx = min(minx, popcount[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<PI> Q;\n    Q.push(mp(0,0));\n\n    while(!Q.empty()){\n      cstate=Q.front().F;\n      ckamoku=Q.front().S;\n      Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      tu=0;\n\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t}\n      }\n\n      if(tu>=u){\n\tans=ckamoku;\n\tbreak;\n      }\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(mp(nstate,ckamoku+1));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<int> Q;\n    Q.push(0);\n\n    while(!Q.empty()){\n      cstate=Q.front();Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      tu=0;\n      ckamoku=0;\n\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tbreak;\n      }\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\ntypedef struct{\n  int state,tani;\n}structst;\nstructst tstr,nstr;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    rep(i,1<<n)app[i]=0;\n    queue<structst> Q;\n    tstr.state=0;\n    tstr.tani=0;\n    Q.push(tstr);\n\n    while(!Q.empty()){\n      tstr=Q.front();\n      Q.pop();\n      if(app[tstr.state])continue;\n      app[tstr.state]=true;\n\n      if(tstr.tani>=u){\n\tans=0;\n\trep(i,n)if(tstr.state>>i&1)++ans;\n\tbreak;\n      }\n\n\n      cstate=tstr.state;\n\n      rep(i,n){\n\tif((cstate&nec[i])==nec[i] && !app[cstate|1<<i]){\n\t  nstr.state=tstr.state|1<<i;\n\t  nstr.tani=tstr.tani+tani[i];\n\t  Q.push(nstr);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, U, a[20], b[20], c, r[20], popcount[1048588], sum[1048588];\nint main() {\n\tfor (int i = 0; i < 20; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (scanf(\"%d%d\", &n, &U), n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]); r[i] = 0;\n\t\t\tfor (int j = 0; j < b[i]; j++) {\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tr[i] |= 1 << c;\n\t\t\t}\n\t\t}\n\t\tsum[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\t\tsum[j] = sum[j - (1 << i)] + a[i];\n\t\t\t}\n\t\t}\n\t\tint minx = 10000000;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tif (sum[i] < U)continue;\n\t\t\tbool flag = false;\n\t\t\tint G = (1 << n) - 1; G -= i;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i & (1 << j)) && (G & r[j])) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) minx = min(minx, popcount[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\n\nint n,U,c,k,r;\nint credit[20],required[20];\n\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\nint BFS(){\n  bool visited[1<<20]={0};\n  queue<Data>q;\n  Data now={0,0};\n  q.push(now);\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(visited[now.used])continue;\n    visited[now.used]=true;\n    if(now.credit>=U)return bitcount(now.used);\n    for(int i=0;i<n;i++){\n      if(now.used & (1<<i) || (now.used & required[i]) != required[i])continue;\n      Data next=now;\n      next.used^=(1<<i);\n      next.credit+=credit[i];\n      q.push(next);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n        cin>>r;\n        required[i]^=(1<<r);\n      }\n    }\n    cout<<BFS()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint need[30];\nint tani[30];\n\nint main() {\n  int n, u;\n  for (;;) {\n    cin >> n >> u;\n    if (n == 0 && u == 0) break;\n    rep (i, n) {\n      int k;\n      cin >> tani[i] >> k;\n      int bit = 0;\n      rep (j, k) {\n\tint r;\n\tcin >> r;\n\tbit |= 1 << r;\n      }\n      need[i] = bit;\n    }\n    int res = n;\n    rep (bit, 1 << n) {\n      int koma = __builtin_popcount(bit);\n      if (res >= koma) continue;\n      int sum = 0;\n      bool ok = true;\n      rep (i, n) if (bit & 1 << i) {\n\tif ((bit & need[i]) != need[i]) {\n\t  ok = false;\n\t  break;\n\t}\n\tsum += tani[i];\n      }\n      if (!ok || sum < u) continue;\n      res = koma;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n\tint unit;\n\tint k;\n\tint end_sub[20];\n} SUBJECT;\n\nint main(void)\n{\n\tunsigned int bit;\n\tSUBJECT sub[20];\n\tint ans;\n\tint u;\n\tint n;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &n, &u);\n\t\t\n\t\tif (!n) break;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d\", &sub[i].unit, &sub[i].k);\n\t\t\tfor (int j = 0; j < sub[i].k; j++){\n\t\t\t\tscanf(\"%d\", &sub[i].end_sub[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = n;\n\t\tfor (bit = 0; bit < 1 << n; bit++){\n\t\t\tint sum;\n\t\t\tint sub_cnt;\n\t\t\t\n\t\t\tsum = sub_cnt = 0;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tint j;\n\t\t\t\t\n\t\t\t\tif ((bit >> i) & 1 == 1){\n\t\t\t\t\tsub_cnt++;\n\t\t\t\t\tfor (j = 0; j < sub[i].k; j++){\n\t\t\t\t\t\tif ((bit >> sub[i].end_sub[j]) & 1 != 1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j == sub[i].k){\n\t\t\t\t\t\tsum += sub[i].unit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (sum == u){\n\t\t\t\tans = min(ans, sub_cnt);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {\n  int r = 0, ch;\n  while( isspace(ch = getchar()));\n  do {\n    r = r * 10 + ch - '0';\n  }while( isdigit( ch = getchar() ) );\n  return r;\n}\n\nint main() {\n  for(;;) {\n    int N, U;\n    scanf(\"%d%d\", &N, &U);\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      scanf(\"%d\", &unit[i]);\n      all += unit[i];\n\n      int K; scanf(\"%d\", &K);\n      REP(k, K) {\n        int x; scanf(\"%d\", &x);\n        need[i] |= (1 << x);\n      }\n    }\n\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n\n    int best = N;\n    for(int mask = 0; mask < 1 << N; mask++) {\n      int one = __builtin_popcount(mask);\n      if( best <= one ) continue;\n\n      int have = 0;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) have += unit[k];\n      if( have < U ) continue;\n\n      bool can = true;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) {\n          if( (mask | (need[k])) != mask ) {\n            can = false;\n            break;\n          }\n        }\n\n      if( can )\n        best =one;\n    }\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint n, u;\nbool used[21];\nint C[21];\nint R[21][21];\nint RC[21];\nint solve( int k ) {\n    if ( k == n ) {\n        int answer = 0;\n        int score = 0;\n        set <int> S;\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) {\n                answer++;\n                score += C[i];\n                S.insert(i);\n            }\n        }\n        bool flag = true;\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) {\n                for ( int j = 0; j < RC[i]; j++ ) {\n                    int t = R[i][j];\n                    if ( S.find(t) == S.end() ) flag = false;\n                }\n            }\n        }\n        return ( !flag || score < u ) ? 1<<28 : answer;\n    }\n\n    used[k] = true;\n    int answer1 = solve(k+1);\n    used[k] = false;\n    int answer2 = solve(k+1);\n    return min( answer1, answer2 );\n}\n\nint main() {\n    while ( cin >> n >> u ) {\n        if ( n == 0 && u == 0 ) break;\n        for ( int i = 0; i < n; i++ ) {\n            used[i] = false;\n            cin >> C[i];\n            int k;\n            cin >> k;\n            RC[i] = 0;\n            for ( int j = 0; j < k; j++ ) {\n                cin >> R[i][RC[i]++];\n            }\n        }\n        int answer = solve(-1);\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\t\tif (u == 0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tint i = (1 << bits) - 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (i >> j & 1 && (i & r[j]) != r[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\tint s = 0;\n\t\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t\t\ts += c[j];\n\t\t\t\t\tif (s >= u)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = bits;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// combination\n\t\t\t\tint leastBit = i & -i;\n\t\t\t\tint mostBits = i + leastBit;\n\t\t\t\tint leastSequentialBits = i & ~mostBits;\n\t\t\t\ti = mostBits | ((leastSequentialBits / leastBit) >> 1);\n\t\t\t} while (i < 1 << n);\n\t\t}\nend:\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#include<map>\nusing namespace std;\nint F(int x)\n{\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n\tx = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n\treturn (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\nstd::bitset<1<<20>f;\nint dp[1<<20];\nint main()\n{\n\tint n,u,k,r,i,j;\n\twhile(scanf(\"%d%d\",&n,&u),n)\n\t{\n\t\tpair<int,int>a[20];\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tfor(scanf(\"%d%d\",&a[i].first,&k);k--;)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&r);\n\t\t\t\ta[i].second|=(1<<r);\n\t\t\t}\n\t\t}\n\t\tf.reset();\n\t\tf[0]=1;\n\t\tr=99;\n\t\tdp[0]=0;\n\t\tfor(i=0;i<(1<<n);++i)\n\t\t{\n\t\t\tif(!f[i])continue;\n\t\t\tif(dp[i]>=u)r=min(r,F(i));\n\t\t\tfor(j=0;j<n;++j)\n\t\t\t{\n\t\t\t\tif((i&(a[j].second))==a[j].second)\n\t\t\t\t{\n\t\t\t\t\tf[i|(1<<j)]=1;\n\t\t\t\t\tdp[i|(1<<j)]=dp[i]+a[j].first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  for(int n,u;cin>>n>>u,n|u;){\n    int ng[20],pr[20]={};\n    for(int i=0;i<n;i++){\n      int k;\n      cin>>ng[i]>>k;\n      while(k--){\n\tint r;\n\tcin>>r;\n\tpr[i]|=1<<r;\n      }\n    }\n    int m=1<<30;\n    for(int i=0;i<1<<n;i++){\n      int gs=0,ns=0,np=0;\n      for(int j=0;j<n;j++){\n\tif(i&1<<j){\n\t  np|=pr[j];\n\t  gs+=ng[j];\n\t  ns++;\n\t}\n      }\n      if(!(np&~i)&&u<=gs&&ns<m){\n\tm=ns;\n      }\n    }\n    cout<<m<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvoid dfs(const vvi& g,int u,vi& vis)\n{\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int v:g[u]) dfs(g,v,vis);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\tvi vis(n);\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tfill(all(vis),0);\n\t\t\trep(j,n) if((i>>j&1) && !vis[j]) dfs(g,j,vis);\n\t\t\tint cnt=0,sum=0;\n\t\t\trep(j,n) if(vis[j]) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n\nint popcount32(unsigned int x){\n\tx = (x>>1 & 0x55555555)+(x & 0x55555555);\n\tx = (x>>2 & 0x33333333)+(x & 0x33333333);\n\tx = (x>>4 & 0x0f0f0f0f)+(x & 0x0f0f0f0f);\n\tx = (x>>8 & 0x00ff00ff)+(x & 0x00ff00ff);\n\treturn (x>>16)+(x & 0x0000ffff);\n}\n\nint tanni[20];\nint prelearn[20];\n\nint main(){\n\tint n,u;\n\twhile(cin>>n>>u,n|u){\n\t\tmemset(tanni,0,sizeof(tanni));\n\t\tmemset(prelearn,0,sizeof(prelearn));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,k;\n\t\t\tcin>>c>>k;\n\t\t\ttanni[i]=c;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tprelearn[i]|=1<<r;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tint pop=popcount32(i);\n\t\t\tif(ans<pop)continue;\n\t\t\tint pre=0;\n\t\t\tint s=0;\t\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((i>>j&1)){\n\t\t\t\t\ts+=tanni[j];\n\t\t\t\t\tpre|=prelearn[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( (i&pre)==pre && u<=s)ans=pop;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\t//clock_t t0=clock();\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\t\t\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t//clock_t t1=clock();\n\t//printf(\"%.3f[s]\\n\",1.*(t1-t0)/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint memo[1<<20];\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  for(i=(1<<20); i; i--) memo[i] = cnt(i);\n\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n    int *m = &memo[(1<<n)-1];\n    for(i=0; i-n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = *m--;\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\t//if(!(!(i & (1<<j)) || !((i & r[i]) == r[j])))\n\tif(!((!(i & (1<<j))) | (!((i & r[j]) ^ r[j]))))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint n, u;\nbool used[21];\nint score;\nset <int> S;\nint cnt;\nint C[21];\nint R[21][21];\nint RC[21];\nint solve( int k ) {\n    if ( k == n ) {\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) {\n                for ( int j = 0; j < RC[i]; j++ ) {\n                    if ( S.find( R[i][j] ) == S.end() ) return 1<<24;\n                }\n            }\n        }\n        return score >= u ? cnt : 1<<24;\n    }\n\n    used[k] = true;\n    cnt++;\n    score += C[k];\n    S.insert(k);\n    int answer1 = solve(k+1);\n    S.erase(k);\n    score -= C[k];\n    cnt--;\n    used[k] = false;\n    int answer2 = solve(k+1);\n    return min( answer1, answer2 );\n}\n\nint main() {\n    while ( cin >> n >> u ) {\n        if ( n == 0 && u == 0 ) break;\n        score = 0;\n        cnt = 0;\n        S.clear();\n        for ( int i = 0; i < n; i++ ) {\n            used[i] = false;\n            cin >> C[i];\n            int k;\n            cin >> k;\n            RC[i] = 0;\n            for ( int j = 0; j < k; j++ ) {\n                cin >> R[i][RC[i]++];\n            }\n        }\n        int answer = solve(-1);\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if((prior[i] | s.S) == s.S){\n\tif(dp[s.S | (1<<i)] != -1) continue;\n\tdp[s.S | (1<<i)] = s.sum + credit[i];\n\n\tif(s.sum + credit[i] >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(s.S | (1<<i),s.sum + credit[i]));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool visited[20];\nint bitmask[20];\nint memo[1<<20];\nint c[20];\nint n,U;\n\nint solve(int S) {\n  if (memo[S]>=0) return memo[S];\n  int sum = 0;\n  REP(i,n) if (S>>i&1) sum+=c[i];\n//  cout <<bitset<4>(S) << \" \"  << sum << endl;\n  if (sum >= U) return 0;\n  int res = INF;\n  REP(i,n) {\n    if (!(S>>i&1)) {\n      if ((S&bitmask[i]) == bitmask[i]) {\n        res = min(res, solve(S|1<<i)+1);\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n>>U, n||U) {\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      cin >> c[i] >> k;\n      REP(j,k) {\n        int r;\n        cin >> r;\n        bitmask[i] |= 1<<r;\n      }\n    }\n    if (U==0) {                 // ツつ「ツづゥツつゥツ不ツ鳴セ\n      cout << 0 << endl;\n      continue;      \n    }\n\n    memset(visited,0,sizeof(visited));\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint main() {\n  for(;;) {\n    int N, U;\n    scanf(\"%d%d\", &N, &U);\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n    REP(i, N) {\n      scanf(\"%d\", &unit[i]);\n      int K; scanf(\"%d\", &K);\n      REP(k, K) {\n        int x; scanf(\"%d\", &x);\n        need[i] |= (1 << x);\n      }\n    }\n\n    int best = N;\n    for(int mask = 0; mask < 1 << N; mask++) {\n      int one = __builtin_popcount(mask);\n      if( best <= one ) continue;\n      \n      int have = 0;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) have += unit[k];        \n      if( have < U ) continue;\n      \n      bool can = true;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) {\n          if( (mask | (need[k])) != mask ) {\n            can = false;\n            break;\n          }\n        }\n\n      if( can ) {\n        best = min(best, one);\n      }\n    }\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n//vector<pair<int,int > > vpii;\n\n//pair<int,int> vpii[21];\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\nvector<int> tos[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < tos[s].size(); i++){\n\t\t\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t\tif(minCost==1)\n\t\t\t\tbreak;\n\t\t}\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\t// Ü¾JÚµÄÈ©Á½ç\n\t\t//\tif(!((s>>i)&1)){\n\t\t//\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t//\t\t\tif(minCost==1)\n\t\t//\t\t\t\tbreak;\n\t\t//\t\t}\n\t\t//\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t//\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t//\t\t//\t\tf=true;\n\t\t//\t\t//\t\tbreak;\n\t\t//\t\t//\t}\n\t\t//\t\t//}\n\t\t//\t\t//if(!f)\n\t\t//\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t//\t}\n\t\t//}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\ttn=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\ttn|=(1<<t);\n\t\t\t}\n\t\t\ttani[i]=c;\n\t\t\tneeds[i]=tn;\n\t\t}\n\t\tfor(int s = 0; s < (1<<n); s++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(!((s>>i)&1)){\n\t\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\t\ttos[s].push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<dfs(0,0)<<endl;\n\t\tfor(int i = 0; i < (1<<n); i++)\n\t\t\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Tag {\n    int pat, value, cost;\n    Tag(int p, int v, int c) : pat(p), value(v), cost(c) {}\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N, U;\n        cin >> N >> U;\n        if(!N && !U) break;\n\n        vector<int> need_mask(N, 0);\n        vector<int> value(N, 0);\n        for(int i = 0; i < N; ++i) {\n            int K;\n            cin >> value[i] >> K;\n            int mask = 0;\n            while(K--) {\n                int R;\n                cin >> R;\n                mask |= (1<<R);\n            }\n            need_mask[i] = mask;\n        }\n        int ans = N;\n        vector<int> seen(1<<N, 0);\n        queue<Tag> q;\n        q.push(Tag(0, 0, 0));\n        seen[0] = 1;\n        while(!q.empty()) {\n            Tag t = q.front();\n            if(t.value >= U) {\n                ans = t.cost;\n                break;\n            }\n            q.pop();\n            for(int i = 0; i < N; ++i) {\n                if(!(t.pat & (1<<i)) && (t.pat & need_mask[i]) == need_mask[i]) {\n                    int next_pat = t.pat | (1<<i);\n                    if(!seen[next_pat]) {\n                        seen[next_pat] = 1;\n                        q.push(Tag(next_pat, t.value + value[i], t.cost + 1));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,int > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tif(((vpii[i].second)&s)==vpii[i].second){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,vector<int> > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn 0;\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\tbool used[21];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((s>>i)&1)\n\t\t\t\tused[i]=true;\n\t\t}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tfor(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t\tif(!used[vpii[i].second[j]]){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,vector<int> > p;\n\t\t\tp.first=c;\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second.push_back(t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nint best;\nint N, U;\nint tno;\nint gain[20];\nchar visited[1 << 20];\nvoid dfs(int mask, int one, int have) {\n  if( best <= one ) return;\n  if( have >= U ) {\n    best = one;\n    return;\n  }\n  if( have + gain[best - one - 1] < U ) return;\n\n  for(int i = 0; i < N; i++)\n    if ( visited[mask | (1 << i)] != tno && (mask | need[i]) == mask )\n      {\n        visited[mask | (1 << i)] = tno;\n        dfs( mask | (1 << i), one + 1, have + unit[i] );\n      }\n}\n\nint main() {\n  for(tno = 1;; tno++) {\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n//     int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n//       all += unit[i];\n      gain[i] = unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n\n    sort( gain, gain + N );\n    reverse( gain, gain + N );\n    for(int i = 1; i < N; i++)\n      gain[i] += gain[i - 1];\n\n//     if( all == U ) {\n//       printf(\"%d\\n\", N);\n//       continue;\n//     }\n\n    best = N;\n    dfs(0, 0, 0);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nint main(){\n  int N,U,c[MAX],k[MAX],r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k[i];\n      int S = 0;\n      for(int j = 0 ; j < k[i] ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF,num = 1<<(N+1);\n    for(int S = 0 ; S < 1<<N ; S++){\n      int cnt = 0, total = 0;\n      bool flg = true;\n      if(num & S == num) continue;\n      for(int i = 0 ; i < N ; i++){\n        if(S >> i & 1){\n          if(S & arr[i] == arr[i]){\n            cnt += c[i]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        num = S;\n        ans = min(ans,total);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n    int used,cost;\n    state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n    int n = 0;\n    while(x != 0) {\n        n++;\n        x &= (x-1);\n    }\n    return n;\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        int ans = 100000,t;\n        for(int i=0; i<1<<n; ++i) {\n            t = 0;\n            for(int j=0; j<n; ++j) {\n                if((i>>j)&1 != 0) {\n                    if(pv[j] != pv[j] & i) goto NEXT;\n                    t += cv[j];\n                }\n            }\n            if(t >= U) ans = min(ans,pop(i));\n        NEXT:;\n        }\n\n//        cout<<bfs()<<endl;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi G(n);\n\t\tvi co(n);\n\t\trep(i,n){\n\t\t\tint b;\n\t\t\tcin>>co[i]>>b;\n\t\t\trep(j,b){\n\t\t\t\tint c;cin>>c;\n\t\t\t\tG[i].pb(c);\n\t\t\t}\n\t\t}\n\t\tint N=1<<n,out=inf;\n\t\trep(i,N){\n\t\t\tbool h=true;\n\t\t\trep(j,n)if(i&1<<j){\n\t\t\t\tbool q=true;\n\t\t\t\trep(k,G[j].size())if(i&1<<G[j][k]);\n\t\t\t\telse q=false;\n\t\t\t\tif(!q)h=false;\n\t\t\t}\n\t\t\tif(h){\n\t\t\t\tint sum=0,c=0;\n\t\t\t\trep(j,n)if(i&1<<j){\n\t\t\t\t\tsum+=co[j];\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif(sum>=m)out=min(out,c);\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi G(n);\n\t\tvi co(n);\n\t\trep(i,n){\n\t\t\tint b;\n\t\t\tcin>>co[i]>>b;\n\t\t\trep(j,b){\n\t\t\t\tint c;cin>>c;\n\t\t\t\tG[i].pb(c);\n\t\t\t}\n\t\t}\n\t\tint N=1<<n,out=inf;\n\t\trep(i,N){\n\t\t\tint sum=0,c=0;\n\t\t\trep(j,n)if(i&1<<j){\n\t\t\t\tsum+=co[j];\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(sum>=m&&c<out){\n\t\t\t\trep(j,n)if(i&1<<j)rep(k,G[j].size())\n\t\t\t\t\tif((i&1<<G[j][k])==0)goto end;\n\t\t\t\tout=c;\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tif(ret<=__builtin_popcount(i))continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=min(ret,__builtin_popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\n\nint n,U,c,k,r;\nint credit[20],required[20];\n\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\nint BFS(){\n  bool visited[1<<20]={0};\n  queue<Data>q;\n  Data now={0,0};\n  q.push(now);\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(visited[now.used])continue;\n    visited[now.used]=true;\n    if(now.credit>=U)return bitcount(now.used);\n    for(int i=0;i<n;i++){\n      if(now.used & (1<<i) || (now.used & required[i]) != required[i])continue;\n      Data next=now;\n      next.used^=(1<<i);\n      next.credit+=credit[i];\n      q.push(next);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n        cin>>r;\n        required[i]^=(1<<r);\n      }\n    }\n    cout<<BFS()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  int next_sum;\n  int next_S;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0,j=0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if(j++ > total_subjects - bitcount[s.S]) break;\n      if(dp[next_S = (s.S | (1<<i))] != -1) continue;\n\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[next_S] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(next_S,next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nstruct State{\n  int total,sub,S;\n  State(int total,int sub,int S) : total(total),sub(sub),S(S) {}\n};\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n\n    bool visited[1<<N];\n    memset(visited,false,sizeof(visited));   \n    visited[0] = true;\n    queue<State> Q;\n    Q.push(State(0,0,0));\n    while(!Q.empty()){\n      State now = Q.front(); Q.pop();\n      if(now.total >= U){\n\tcout << now.sub << endl;\n\tbreak;\n      }\n      for(int i = 0 ; i < N ; i++){\n\tint S = now.S; S |= 1<<i;\n\tif(!visited[S] && (S & arr[i] == arr[i])){\n\t  Q.push(State(now.total+c[i],now.sub+1,S));\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\t//for(int i = 0; i < tos[s].size(); i++){\n\t\t//\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t//\tif(minCost==1)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>tani[i]>>k;\n\t\t\tneeds[i]=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\tneeds[i]|=(1<<t);\n\t\t\t}\n\t\t\t//needs[i]=tn;\n\t\t}\n\t\t//for(int s = 0; s < (1<<n); s++){\n\t\t//\tfor(int i = 0; i < n; i++){\n\t\t//\t\tif(!((s>>i)&1)){\n\t\t//\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\t\ttos[s].push_back(i);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//for(int i = 0; i < (1<<n); i++)\n\t\t//\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvoid dfs(const vvi& g,int u,vi& vis)\n{\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int v:g[u]) dfs(g,v,vis);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tvi vis(n);\n\t\t\trep(j,n) if((i>>j&1) && !vis[j]) dfs(g,j,vis);\n\t\t\tint cnt=0,sum=0;\n\t\t\trep(j,n) if(vis[j]) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 20\n\nint n, U;\nint cs[MAX_N];\nint rs[MAX_N];\n\ninline bool check(int S) {\n    // 履修に必要な単位をすべて取得しているか\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            if ((S & rs[i]) != rs[i]) {\n                return false;\n            }\n        }\n    }\n\n    // 総単位数がUを越えているか\n    int unit = 0;\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            unit += cs[i];\n        }\n    }\n    if (unit < U) return false;\n\n    return true;\n}\n\nbool checkAllPattern(int k) {\n    int c = (1<<k)-1;\n    while (c < (1<<n)) {\n        if (check(c)) return true;\n        int x = c & -c;\n        int y = c + x;\n        c = ((c & ~y) / x >> 1) | y;\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    while (cin >> n >> U, n || U) {\n        memset(cs, 0, sizeof(cs));\n        memset(rs, 0, sizeof(rs));\n        for (int i = 0; i < n; i++) {\n            int c, k, r;\n            cin >> c >> k; r = 0;\n            for (int j = 0; j < k; j++) {\n                int _r; cin >> _r;\n                r |= (1<<_r);\n            }\n            cs[i] = c;\n            rs[i] = r;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            if (checkAllPattern(i)) {\n                cout << i << endl;\n                break;\n            }\n        }\n\n        //int ans = (1<<28);\n        //for (int S = 1; S < (1<<n); S++) {\n        //    if (check(S)) {\n        //        ans = min(ans, __builtin_popcount(S));\n        //    }\n        //}\n\n        //cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp,sum,num;\nint c[30],k[30],r[30];\nbool f[30][30],flag;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++){\n\tif(f[i][j])r[i] |= 1<<j;\n      }\n    }\n\n    int res = 20;\n    for(int i=0;i<(1<<n);i++){\n      sum = 0,num = 0;\n      flag = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  if( (i&r[j]) != r[j]){\n\t    flag = false;\n\t    break;\n\t  }\n\t  sum += c[j];\n\t  num++;\n\t  if(res<num){\n\t    flag = false;\n\t    break;\n\t  }\n\t}\n      }\n      if(flag && num<res && U<=sum)res = num;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21][21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i][d]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tif(ret>=__builtin_popcount(i))continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tfor(int k=0;k<a;k++)\n\t\t\t\t\t\tif(g[j][k]&&!(i&(1<<k)))ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=min(ret,__builtin_popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\nstruct Subject{\n  int credit;\n  int required;\n};\n\nint numofbits(long bits)\n{\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = ((bits >> 4) + bits) & 0x0f0f0f0f;\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\nint main()\n{\n  int n,U,c,k,r;\n  int MAX;\n  int ans;\n  while(cin>>n>>U,n|U){\n    vector<Subject>list(n);\n    ans=INT_MAX;\n    MAX=1;\n    for(int i=0;i<n;i++)MAX*=2;\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      list[i].credit=c;\n      list[i].required=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\tlist[i].required^=(1<<r);\n      }\n    }\n    for(int i=0;i<MAX;i++){\n      if(numofbits(i)>=ans)continue;\n      int sum=0;\n      bool ok=true;\n      for(int j=0;ok && j<n;j++){\n\tif((i & (1<<j)) == 0)continue;\n\tif((i & list[j].required) != list[j].required)ok=false;\n\tsum+=list[j].credit;\n      }\n      if(ok && sum>=U)ans=numofbits(i);\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n};\n\n#define INF (1<<21)\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tQ.push(NODE(0,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\tif(done[q.a]) continue; \n\t\t\telse done[q.a] = true;\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i] )\n\t\t\t\t\tQ.push(NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\ntypedef struct _no{\n  int nec,tani;\n  bool operator<(const _no&r)const{return tani>r.tani;};\n}no;\n\nno moku[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\ntypedef struct{\n  int state,tani;\n}structst;\nstructst tstr,nstr;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      cin>>moku[i].tani>>k;\n      moku[i].nec=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tmoku[i].nec|=1<<t;\n      }\n    }\n    sort(moku,moku+n);\n\n    rep(i,1<<n)app[i]=0;\n    queue<structst> Q;\n    tstr.state=0;\n    tstr.tani=0;\n    Q.push(tstr);\n\n    while(!Q.empty()){\n      tstr=Q.front();\n      Q.pop();\n      if(app[tstr.state])continue;\n      app[tstr.state]=true;\n\n      if(tstr.tani>=u){\n\tans=0;\n\trep(i,n)if(tstr.state>>i&1)++ans;\n\tbreak;\n      }\n\n\n      cstate=tstr.state;\n\n      rep(i,n){\n\tif((cstate&moku[i].nec)==moku[i].nec && !app[cstate|1<<i]){\n\t  nstr.state=tstr.state|1<<i;\n\t  nstr.tani=tstr.tani+moku[i].tani;\n\t  Q.push(nstr);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if((prior[i] | s.S) == s.S){\n\tif(dp[s.S | (1<<i)] != -1) continue;\n\tint next_sum = s.sum + credit[i];\n\tdp[s.S | (1<<i)] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(s.S | (1<<i),next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tif(ret<=__builtin_popcount(i))continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tif((i&g[j])!=g[j])ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=min(ret,__builtin_popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N = 20;\n\nint n, U, C[N], K[N], R[N];\n\nmain(){\n  while(scanf(\"%d %d\", &n, &U) && (n|U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d\", &C[i], &K[i]);\n      R[i] = (1 << i);\n      for(int j=0;j<K[i];j++){\n        int r;\n        scanf(\"%d\", &r);\n        R[i] |= 1 << r;\n      }\n    }\n    int ans = -1;\n    for(int i=0;i<(1<<n);i++){\n      int sum = 0, cnt = 0;\n      int s = i;\n      for(int j=0;j<n;j++) if((i >> j) & 1) s |= R[j];\n      for(int j=0;j<n;j++){\n        if((s >> j) & 1){\n          sum += C[j];\n          cnt++;\n        }\n      }\n      if(sum < U) continue;\n      if(ans == -1 || ans > cnt) ans = cnt;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[20][20],n;\nbool b[20];\npair<int,int> fn(int p){\n  int i;\n  pair<int,int> mx=make_pair(0,0);\n  if(b[p]==0){\n    mx=make_pair(1,a[p][p]);\n    for(i=0;i<n;i++){\n      if(i!=p&&a[p][i]){\n\tpair<int,int> q=fn(i);\n\tmx.first+=q.first;\n\tmx.second+=q.second;\n      }\n    }\n  }\n  return mx;\n}\nvoid fm(int p){\n  int i;\n  if(b[p]==0){\n    b[p]=1;\n    for(i=0;i<n;i++){\n      if(i!=p&&a[p][i])\n\tfm(i);\n    }\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int u;\n  while(cin>>n>>u&&n+u){\n    memset(a,0,sizeof(a));\n    for(i=0;i<n;i++){\n      int p,q;\n      cin>>p>>q;\n      a[i][i]=p;\n      for(j=0;j<q;j++){\n\tint r;\n\tcin>>r;\n\ta[i][r]=1;\n      }\n    }\n    pair<int,int> sm=make_pair(0,0);\n    memset(b,0,20);\n    while(sm.second<u){\n      int ct;\n      pair<int,int> mx=make_pair(0,0);\n      for(i=0;i<n;i++){\n\tpair<int,int> q=fn(i);\n\tif(q.first!=0&&(mx.first==0||((double)min(u-sm.second,mx.second)/mx.first<(double)min(u-sm.second,q.second)/q.first))){\n\t  mx=q;\n\t  ct=i;\n\t}\n      }\n      fm(ct);\n      sm.first+=mx.first;\n      sm.second+=mx.second;\n    }\n    cout<<sm.first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\nint deg[1<<20];\nint c[20];\nint need[20];\n\nint bitscount(int n){\n  int res = 0;\n  while(n){\n    res++;\n    n -= (n & -n);\n  }\n  return res;\n}\n\nint main(){\n  int n, U, k,r;\n  while(cin >> n >> U && (n || U)){\n    memset(deg, -1, sizeof(deg));\n    memset(need, 0, sizeof(need));\n    int res = INF;\n    rep(i, n){\n      cin >> c[i] >> k;\n      rep(j, k){\n\tcin >> r;\n\tneed[i] |= (1 << r);\n      }\n    }\n    deg[0] = 0;\n    rep(i, (1 << n)){\n      if(deg[i] == -1) continue;\n      if(deg[i] >= U) res = min(res, bitscount(i));\n      rep(j, n){\n\tif(!(i & (1 << j)) && ((i & need[j]) == need[j])){\n\t  deg[i|(1<<j)] = c[j] + deg[i];\n\t}\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<bitset>\n#include<deque>\n#include<algorithm>\nusing namespace std;\n\nstruct Pox\n{\n  int state,cost;\n  Pox(int state,int cost):state(state),cost(cost){}\n};\n\nint main()\n{\n  while(1)\n    {\n      int n,U,k,r;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      deque<Pox> deq;\n      int G[n];\n      int c[n];\n      for(int i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t    if(!k)\n\t      deq.push_back(Pox((1<<i),c[i]));\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      int ans = n;\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  int num = __builtin_popcount(pox.state);\n\t  if(num >= ans)\n\t    continue;\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((pox.state >> i) & 1)\n\t\tcontinue;\n\t      int pre = G[i];\n\t      pre &= pox.state;\n\t      if(pre != G[i])\n\t\tcontinue;\n\t      if(pox.cost + c[i] < U)\n\t\tdeq.push_back(Pox(pox.state|(1<<i),pox.cost+c[i]));\n\t      else \n\t\tans = min(ans,num+1);\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 20\n\nint n, U;\nint cs[MAX_N];\nint rs[MAX_N];\n\ninline bool check(int S) {\n    // 履修に必要な単位をすべて取得しているか\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            if ((S & rs[i]) != rs[i]) {\n                return false;\n            }\n        }\n    }\n\n    // 総単位数がUを越えているか\n    int unit = 0;\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            unit += cs[i];\n        }\n    }\n    if (unit < U) return false;\n\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int c, k, r;\n    int _r;\n    while (cin >> n >> U, n || U) {\n        memset(cs, 0, sizeof(cs));\n        memset(rs, 0, sizeof(rs));\n        for (int i = 0; i < n; i++) {\n            cin >> c >> k; r = 0;\n            for (int j = 0; j < k; j++) {\n                cin >> _r;\n                r |= (1<<_r);\n            }\n            cs[i] = c;\n            rs[i] = r;\n        }\n\n        int ans = (1<<28);\n        for (int S = 1; S < (1<<n); S++) {\n            if (check(S)) {\n                ans = min(ans, __builtin_popcount(S));\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\n\nint numofbits(long bits)\n{\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = ((bits >> 4) + bits) & 0x0f0f0f0f;\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\nint main()\n{\n  int n,U,c,k,r;\n  int credit[20],required[20];\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\trequired[i]^=(1<<r);\n      }\n    }\n\n    bool visited[1<<20]={0};\n    queue<Data>q;\n    Data now={0,0};\n    q.push(now);\n    while(!q.empty()){\n      now=q.front();\n      q.pop();\n      if(visited[now.used])continue;\n      visited[now.used]=true;\n      if(now.credit>=U)\tbreak;\n      for(int i=0;i<n;i++){\n\tif(!(now.used&(1<<i)) && ((now.used&required[i])==required[i]))\n\t  q.push((Data){now.used|(1<<i), now.credit+credit[i]});\n      }\n    }\n    cout<<numofbits(now.used)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U,tmp;\n  int c[30],k[30],r[30];\n\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      r[i] = 0;\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tr[i] |= 1<<tmp;\n      }\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = __builtin_popcount(i), sum = 0;\n      if(res <= num)continue;\n\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  f &= ( (r[j]&i) == r[j] );\n\t  if(!f)break;\n\t  sum += c[j];\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nvector<vector<int> > prev;\nint ans,n,U;\n\nvoid dfs(int used,int depth,int cost) {\n  if(depth > ans) return;\n  if(cost >= U) {\n    ans = min(ans, depth);\n    return;\n  }\n\n  for(int i=0; i<n; ++i) {\n    if((used>>i) & 1) continue;\n    if(used & pv[i] != pv[i]) continue;\n    dfs((used|(1<<i)),depth+1,cost+cv[i]);\n  }\n  return;\n}\n\nint main() {\n  int i,j,k,c,r;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    prev.clear();\n    prev.resize(n);\n    ans = 20;\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      rep(j,k) {\n\tcin>>r;\n\tprev[i].push_back(r);\n      }\n    }\n\n    rep(i,n) {\n      int t = 0;\n      rep(j,prev[i].size()) {\n\tt |= (1<<prev[i][j]);\n      }\n      pv[i] = t;\n    }\n\n    dfs(0,0,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n,U;scanf(\"%d%d\",&n,&U),n;){\n\t\tint score[20];\n\t\tbool wf[20][20]={};\n\t\trep(u,n){\n\t\t\tint m; scanf(\"%d%d\",score+u,&m);\n\t\t\trep(i,m){\n\t\t\t\tint v; scanf(\"%d\",&v);\n\t\t\t\twf[v][u]=true;\n\t\t\t}\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) wf[i][j]|=wf[i][k]&wf[k][j];\n\n\t\tint A[20]={};\n\t\trep(u,n) rep(v,n) if(u!=v && wf[v][u]) A[u]|=1<<v;\n\n\t\tint ans=n;\n\t\trep(S,1<<20){\n\t\t\tint pc=0,tot=0;\n\t\t\tbool ok=true;\n\t\t\trep(u,n) if(S&(1<<u)) {\n\t\t\t\tpc++;\n\t\t\t\ttot+=score[u];\n\t\t\t\tif((S&A[u])!=A[u]){ ok=false; break; }\n\t\t\t}\n\t\t\tif(ok && tot>=U) ans=min(ans,pc);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,int > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\tbool used[21];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((s>>i)&1)\n\t\t\t\tused[i]=true;\n\t\t}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tif(((vpii[i].second)&s)==vpii[i].second){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t}\n\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\t//p.second.push_back(t);\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n  state ns(0,0,0);;\n  int i,k;\n\n  while(!Q.empty()) {\n    ns = Q.front(); Q.pop();\n    for(i=0; i<n; ++i) {\n      k = 1<<i;\n      if(ns.used & k || memo[ns.used|k] >= 0\n\t || (ns.used & pv[i] != pv[i])) continue;\n      memo[ns.used|k] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|k),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nvector<int> vec,v[MAX],a[MAX];\n\nvoid init(int N){\n  vec.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    v[i].clear();\n  }\n  for(int i = 1 ; i < 1<<N ; i++){\n    int idx = __builtin_popcount(i);\n    v[idx-1].push_back(i);\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < (int)v[i].size() ; j++){\n      vec.push_back(v[i][j]);\n    }\n  }\n}\n\nint main(){\n  int N,U,c[MAX],k,r;\n  bool used[MAX] = {false};\n\n  while(cin >> N >> U, (N | U)){\n    if(!used[N-1]){\n      init(N);\n      a[N-1] = vec;\n      used[N-1] = true;\n    }else{\n      vec = a[N-1];\n    }\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF;\n    for(int i = 0 ; i < (int)vec.size() ; i++){\n      int S = vec[i];\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int j = 0 ; j < N ; j++){\n        if(S >> j & 1){\n          if((S & arr[j]) == arr[j]){\n            cnt += c[j]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        ans = total;\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n    int used,cost;\n    state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n    int n = 0;\n    while(x != 0) {\n        n++;\n        x &= (x-1);\n    }\n    return n;\n}\n\ninline int bit_count(int x)\n{\n  x = (x & 0x55555555) + (x >> 1 & 0x55555555);\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n  x = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n  return (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\n\ninline unsigned next_set(unsigned x)\n{\n  unsigned smallest = x & -x;\n  unsigned ripple = x + smallest;\n  unsigned new_smallest = ripple & -ripple;\n  unsigned ones = ((new_smallest / smallest) >> 1) - 1;\n  return ripple | ones;\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        int ans = 100000,t;\n        for(int k=1; k<=n; ++k) {\n            for(int i=(1<<k)-1; i<1<<n; i = next_set(i)) {\n                t = 0;\n                for(int j=0; j<n; ++j) {\n                    if((i>>j)&1 != 0) {\n                        if(pv[j] != pv[j] & i) goto NEXT;\n                        t += cv[j];\n                    }\n                }\n                if(t >= U) {\n                    ans = min(ans,bit_count(i));\n                    goto END;\n                }\n            NEXT:;\n            }\n        }\n    END:;\n//        cout<<bfs()<<endl;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv;\nvector<vector<int> > prev;\nint ans,n,U;\n\nvoid dfs(int used,int depth,int cost) {\n  if(depth > ans) return;\n  if(cost >= U) {\n    ans = min(ans, depth);\n    return;\n  }\n\n  for(int i=0; i<n; ++i) {\n    if((used>>i) & 1) continue;\n    for(int j=0; j<prev[i].size(); ++j) {\n      if((used>>prev[i][j]) & 1 == 0) goto NEXT;\n    }\n    dfs((used|(1<<i)),depth+1,cost+cv[i]);\n  NEXT:;\n  }\n  return;\n}\n\nint main() {\n  int i,j,k,c,r;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    prev.clear();\n    prev.resize(n);\n    ans = 20;\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      rep(j,k) {\n\tcin>>r;\n\tprev[i].push_back(r);\n      }\n    }\n\n    dfs(0,0,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n// ツ猟堋修ツ嘉按姪堋づ個氾板債づ必ツ要ツ嘉按姪堋づ個ペツア\npair<int,vector<int> > pivi;\n\nint main(){\n\n\tbool isGettiable[21];\n\tbool isRegistered[21];\n\n\tint n;\n\tint U;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tvector<pair<int,vector<int> > > v;\n\t\tfill(isGettiable,isGettiable+21,false);\n\t\tfill(isRegistered,isRegistered+21,false);\n\t\t//priority_queue<pair<int,int> > pq;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\t// ツ単ツ暗環青板づ必ツ要ツ嘉按姪堋づーツ登ツ録\n\t\t\tv.push_back(make_pair(c,vector<int>()));\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tv[i].second.push_back(t);\n\t\t\t}\n\t\t}\n\t\tint minCnt=100000;\n\t\tfor(int s = 0; s < (1<<n); s++){\n\t\t\tif(s==12){\n\t\t\t//\tcout<<endl;\n\t\t\t}\n\t\t\tfill(isGettiable,isGettiable+21,false);\n\t\t\tint sum=0;\n\t\t\tint cnt=0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif((s>>i)&1){\n\t\t\t\t\tisGettiable[i]=true;\n\t\t\t\t\tsum+=v[i].first;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=false;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif((s>>i)&1){\n\t\t\t\t\tfor(int j = 0; j < v[i].second.size(); j++){\n\t\t\t\t\t\tif(!isGettiable[v[i].second[j]]){\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f&&sum>=U){\n\t\t\t\tminCnt=min(minCnt,cnt);\n\t\t\t}\n\t\t}\n\t\tcout<<minCnt<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\n\nmain(){\n  int n,u;\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    int ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<int> Q;\n    Q.push(0);\n\n    while(!Q.empty()){\n      cstate=Q.front();Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      tu=0;\n      ckamoku=0;\n\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t{\n\t\t\tbool ng = false;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (i >> j & 1 && i & r[i] != r[i])\n\t\t\t\t{\n\t\t\t\t\tng = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ng)\n\t\t\t\tcontinue;\n\n\t\t\tint s = 0;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (i >> j & 1)\n\t\t\t\t\ts += c[i];\n\t\t\tif (s >= u)\n\t\t\t{\n\t\t\t\tint bits = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t\t++bits;\n\t\t\t\tmin_swap(res, bits);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp,sum;\nint c[30],k[30],r[30];\nint ans;\nbool f;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      r[i] = 0;\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tr[i] |= 1<<tmp;\n      }\n    }\n\n    f = false;;\n    for(ans=1;ans<n;ans++){\n      int comb = (1<<ans) -1;\n      while(comb < (1<<n)){\n\tsum = 0; f = true;\n\tfor(int i=0;i<n;i++){\n\t  if((comb>>i)&1){\n\t    if( (comb&r[i]) != r[i]){\n\t      f = false;\n\t      break;\n\t    }\n\t    sum += c[i];\n\t  }\n\t}\n\n\tif(f && U<=sum){\n\t  break;\n\t}\n\tf = false;\n      \n\tint x = comb & -comb, y = comb + x;\n\tcomb = ( ( (comb & ~y) /x ) >> 1) | y;\n      }\n      if(f)break;\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\n//pair<pair<int,int>,int>p[21];\n//int conv[];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<a;i++)p[i]=make_pair(t[i],g[i]),;\n\t//\tstd::sort(p,p+a);\n\t//\tfor(int i=0;i<a;i++){\n\t//\t\tt[i]=p[a-1-i].first;\n\t//\t\tg[i]=p[a-1-i].second;\n\t//\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nint dfs(int used,int depth,int cost) {\n  if(memo[used] >= 0) return memo[used];\n  if(cost >= U) {\n    return memo[used] = depth;\n  }\n\n  int t = 20;\n  for(int i=0; i<n; ++i) {\n    if((used>>i) & 1) continue;\n    if(used & pv[i] != pv[i]) continue;\n    t = min(t,dfs((used|(1<<i)),depth+1,cost+cv[i]));\n  }\n  return memo[used] = t;\n}\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(ns.cost >= U) return ns.depth;\n    for(int i=0; i<n; ++i) {\n      if((ns.used>>i) & 1) continue;\n      if(ns.used & pv[i] != pv[i]) continue;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U;\n  int c[30],k[30],r[30][30];\n\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++)scanf(\"%d\",&r[i][j]);\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = __builtin_popcount(i), sum = 0;\n      if(res <= num)continue;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 )sum += c[j];\n      }\n      if(sum<U)continue;\n\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  for(int l=0;l<k[j];l++){\n\t    f &= (i>>r[j][l])&1;\n\t    if(!f)break;Darsein\n\t  }\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0));\n  int i;\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(visited[ns.used]) continue;\n    if(ns.cost >= U) {\n      return pop(ns.used);\n    }\n\n    visited[ns.used] = 1;\n\n    for(i=0; i<n; ++i) {\n      if(!((ns.used>>i)&1) && (ns.used & pv[i])==pv[i]) {\n\tQ.push((state){ns.used|(1<<i), ns.cost+cv[i]});\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(visited, false, sizeof(visited));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N, U;\n        cin >> N >> U;\n        if(!N && !U) break;\n\n        vector<int> need_mask(N, 0);\n        vector<int> value(N, 0);\n        for(int i = 0; i < N; ++i) {\n            int K;\n            cin >> value[i] >> K;\n            int mask = 0;\n            while(K--) {\n                int R;\n                cin >> R;\n                mask |= (1<<R);\n            }\n            need_mask[i] = mask;\n        }\n        int ans = N;\n        for(int pattern = 0; pattern <= (1<<N); ++pattern) {\n            bool ok = true;\n            int sum = 0;\n            for(int pos = 0; pos < N; ++pos) {\n                if(pattern & (1<<pos)) {\n                    if((pattern & need_mask[pos]) != need_mask[pos]) {\n                        ok = false;\n                        break;\n                    }\n                    sum += value[pos];\n                }\n            }\n            if(ok && sum >= U) {\n                ans = min(ans, __builtin_popcount(pattern));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\n\nint n,U,c,k,r;\nint credit[20],required[20];\n\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\nint BFS(){\n  bool visited[1<<20]={0};\n  queue<Data>q;\n  Data now={0,0};\n  q.push(now);\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(visited[now.used])continue;\n    visited[now.used]=true;\n    if(now.credit>=U)return bitcount(now.used);\n    for(int i=0;i<n;i++){\n      if(!(now.used&(1<<i)) && ((now.used&required[i])==required[i]))\n\tq.push((Data){now.used|(1<<i), now.credit+credit[i]});\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\trequired[i]^=(1<<r);\n      }\n    }\n    cout<<BFS()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N = 20;\n\nint n, U, C[N], K[N], R[N];\nbool vis[1<<N];\n\nmain(){\n  while(scanf(\"%d %d\", &n, &U) && (n|U)){\n    fill(vis, vis+(1<<n), false);\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d\", &C[i], &K[i]);\n      R[i] = (1 << i);\n      for(int j=0;j<K[i];j++){\n        int r;\n        scanf(\"%d\", &r);\n        R[i] |= 1 << r;\n      }\n    }\n    int ans = -1;\n    for(int i=0;i<(1<<n);i++){\n      int sum = 0, cnt = 0;\n      int s = i;\n      for(int j=0;j<n;j++) if((i >> j) & 1) s |= R[j];\n      if(vis[s]) continue;\n      vis[s] = true;\n      for(int j=0;j<n;j++){\n        if((s >> j) & 1){\n          sum += C[j];\n          cnt++;\n        }\n      }\n      if(sum < U) continue;\n      if(ans == -1 || ans > cnt) ans = cnt;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint n,U,tmp;\nint c[30],k[30],r[30];\nbool f[30][30];\nint cost[1<<21],num[1<<21];\nset<int> s;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    s.clear();\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++){\n\tif(f[i][j])r[i] |= 1<<j;\n      }\n    }\n\n    for(int i=0;i<(1<<n);i++){\n      int tmp = 0;\n      for(int j=0;j<n;j++){\n\tif( (i>>j) &1)tmp |= r[j];\n      }\n      s.insert(tmp);\n    }\n\n    int res = 20;\n    for(set<int>::iterator it = s.begin();it!=s.end();it++){\n      int tmp = *it ,sum = 0;\n      for(int j=0;j<n;j++){\n\tif( (tmp>>j)&1)sum += c[j];\n      }\n      if(U<=sum)res = min(res,__builtin_popcount(tmp));\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef struct\n{\n  int c, r;\n} Subject;\n\nint n, U;\nSubject sub[20];\nint memo[1 << 20];\n\nint solve(int bit, int cnt)\n{\n  if (memo[bit] != -1)\n    return memo[bit];\n\n  if (cnt >= U) {\n    memo[bit] = __builtin_popcount(bit);\n    return memo[bit];\n  }\n\n  int ret = INF;\n  for (int i = 0; i < n; ++i) {\n    if (!(bit & (1 << i)) && (sub[i].r & bit) == sub[i].r)\n      ret = min(ret, solve(bit | (1 << i), cnt+sub[i].c));\n  }\n  memo[bit] = ret;\n  return ret;\n}\n\nint main()\n{\n  while (~scanf(\"%d %d\", &n, &U)) {\n    if (n == 0 && U == 0)\n      break;\n\n    for (int i = 0; i < (1 << 20); ++i)\n      memo[i] = -1;\n\n    for (int i = 0; i < n; ++i) {\n      sub[i].r = 0;\n      int k, r = 0;\n      scanf(\"%d %d\", &sub[i].c, &k);\n      for (int j = 0; j < k; ++j) {\n\tint r;\n\tscanf(\"%d\", &r);\n\tsub[i].r |= (1 << r);\n      }\n    }\n    printf(\"%d\\n\", solve(0, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <stack>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint main()\n{\n\tfor( int a,worse; cin>>a>>worse , a|worse ; )\n\t{\n\t\tmap< int , int > m;\n\t\tmap< int , vector<int> > flg;\n\n\t\tfor( int i=0 ; i<a ; i++ )\n\t\t{\n\t\t\tint num1,num2;\n\t\t\tcin>> num1 >> num2;\n\t\t\tm[i] = num1 ;\n\n\t\t\tif( num2 ){\n\t\t\t\tfor( int j=0 ; j<num2 ; j++ ){\n\t\t\t\t\tint before;cin>>before;\n\t\t\t\t\tflg[i].push_back( before );\n\t\t\t\t}\n\t\t\t}\n\t\t\tflg[i].push_back( -1 );\n\t\t}\n\n\t\tint result=0;\n\t\twhile( worse > 0 ){\n\t\t\tint max=0;\n\t\t\tint maxIndex=INT_MAX;\n\n\t\t\tfor( int i=0 ; i<a ; i++ ){\n\t\t\t\tif( flg[i].size() <= 1 ){\n\t\t\t\t\tif( max<m[i] ){ max=m[i]; maxIndex=i; }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( int i=0 ; i<a ; i++ ){\n\t\t\t\tvector<int>::iterator point=find( flg[i].begin() , flg[i].end() , maxIndex );\n\t\t\t\tif( point != flg[i].end() ){\n\t\t\t\t\tflg[i].erase( point );\n\t\t\t\t}\n\t\t\t}\n\t\t\tworse-=max;\n\t\t\tresult++;\n\t\t\tm[ maxIndex ] = 0;\n\t\t\t//cout << maxIndex << \":\";\n\t\t}\n\t\tcout << endl;\n\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<int> Q;\n    Q.push(0);\n\n    while(!Q.empty()){\n      cstate=Q.front();Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      tu=0;\n      ckamoku=0;\n\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nmain(){\n  int n,u;\n\n  while(cin>>n>>u,n|u){\n    vector<int> nec[n];\n    int tani[n];\n\n    rep(i,n){\n      cin>>tani[i];\n      int k;\n      cin>>k;\n      rep(j,k){\n\tint t;\n\tcin>>t;\n\tnec[i].pb(t);\n      }\n    }\n\n    int ans=INT_MAX/2;\n    queue<int> Q;\n    set<int> app;\n    Q.push(0);\n\n    while(!Q.empty()){\n      int cstate=Q.front();Q.pop();\n      if(app.count(cstate))continue;\n      app.insert(cstate);\n\n      int tu=0,ckamoku=0;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n      rep(i,n){\n\tif(cstate>>i&1)continue;\n\tbool ok=true;\n\trep(j,nec[i].size()){\n\t  if(cstate>>nec[i][j]&1)continue;\n\t  ok=false;\n\t  break;\n\t}\n\tif(ok){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  if(app.count(nstate))continue;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint n,m,c[20],k[20];\nint ans,bit[20];\nbool r[20][20]; //ツ療猟静堋配ツ療ア\n\nbool correct(string s){\n\tint x = 0;\n\trep(i,s.length()) if(s[i] == '1') x += (1<<i);\n\trep(i,s.length()) if(s[i] == '1' && (x&bit[i])!=bit[i]) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid solve(string s,int now,int sum){\n\tif(s.length() == n){\n\t\tif(sum >= m && ans > now && correct(s)) ans = now;\n\t\treturn;\n\t}\n\n\tsolve(s+\"0\",now,sum);\n\tsolve(s+\"1\",now+1,sum+c[s.length()]);\n}\n\nvoid writeBit(int id,int b){\n\tbit[id] |= b;\n\trep(i,n) if(r[i][id] && (b&(1<<i)) == 0) {\n\t\twriteBit(i,b|(1<<i));\n\t}\n}\n\nint main(void){\n\twhile(cin>>n>>m && (n||m)){\n\t\tmemset(r,0,sizeof(r));\n\t\trep(i,n){\n\t\t\tcin>>c[i]>>k[i];\n\t\t\trep(j,k[i]){\n\t\t\t\tint to;\n\t\t\t\tcin>>to;\n\t\t\t\tr[i][to] = true;\n\t\t\t}\n\t\t}\n\n\t\tmemset(bit,0,sizeof(bit));\n\t\trep(i,n) if(k[i] == 0) {\n\t\t\twriteBit(i,1<<i);\n\t\t}\n\n\t\tans = n;\n\t\tsolve(\"\",0,0);\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n  state ns(0,0,0);;\n  int i;\n\n  while(!Q.empty()) {\n    ns = Q.front(); Q.pop();\n    for(i=0; i<n; ++i) {\n      if((ns.used>>i) & 1 || memo[ns.used|(1<<i)] >= 0\n\t || (ns.used & pv[i] != pv[i])) continue;\n      memo[ns.used|(1<<i)] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  int next_sum;\n  int next_S;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if(dp[next_S = (s.S | (1<<i))] != -1) continue;\n\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[next_S] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(next_S,next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t;\n\nmain(){\n  int n,u;\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    int ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<PI> Q;\n    Q.push(mp(0,0));\n\n    while(!Q.empty()){\n      int cstate=Q.front().F,ckamoku=Q.front().S;Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      int tu=0;\n      if(ckamoku>=ans)continue;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t}\n      }\n\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(mp(nstate,ckamoku+1));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF;\n    for(int S = 1 ; S < 1<<N ; S++){\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int i = 0 ; i < N ; i++){\n        if(S >> i & 1){\n          if(arr[i] == 0 || S & arr[i] == arr[i]){\n            cnt += c[i]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        if(total < ans){\n          ans = total;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool visited[20];\nint bitmask[20];\nint memo[1<<20];\nint c[20];\nint n,U;\nint S, sum;\nint solve() {\n  if (memo[S]>=0) return memo[S];\n//  cout <<bitset<4>(S) << \" \"  << sum << endl;\n  if (sum >= U) return 0;\n  int res = INF;\n  REP(i,n) {\n    if (!(S>>i&1)) {\n      if ((S&bitmask[i]) == bitmask[i]) {\n        if (sum+c[i]>=U) return 1;\n        else {\n          S|=1<<i;\n          if (memo[S]>=0)\n            res = min(res, memo[S]+1);\n          else {\n            sum += c[i];\n            res = min(res, solve()+1);\n            sum -= c[i];\n          }\n          S^=1<<i;\n        }\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n>>U, n||U) {\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      cin >> c[i] >> k;\n      REP(j,k) {\n        int r;\n        cin >> r;\n        bitmask[i] |= 1<<r;\n      }\n    }\n\n    memset(visited,0,sizeof(visited));\n    memset(memo,-1,sizeof(memo));\n    S = 0; sum = 0;\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "k#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\n//vector<int> tos[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\t//for(int i = 0; i < tos[s].size(); i++){\n\t\t//\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t//\tif(minCost==1)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\ttn=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\ttn|=(1<<t);\n\t\t\t}\n\t\t\ttani[i]=c;\n\t\t\tneeds[i]=tn;\n\t\t}\n\t\t//for(int s = 0; s < (1<<n); s++){\n\t\t//\tfor(int i = 0; i < n; i++){\n\t\t//\t\tif(!((s>>i)&1)){\n\t\t//\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\t\ttos[s].push_back(i);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//for(int i = 0; i < (1<<n); i++)\n\t\t//\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint n,U,tmp;\nint c[30],k[30],r[30];\nbool f[30][30];\nint dp[1<<21],cost[1<<21],num[1<<21];\n\nint rec(int bit){\n  if(dp[bit]>=0)return dp[bit];\n  if(cost[bit]>=U)return dp[bit] = num[bit];\n  int res = 20;\n  for(int i=0;i<n;i++){\n    if( !( (bit>>i) &1 ) ){\n      int next = bit | r[i];\n      if(cost[next]<U)res = min(res,rec(next) );\n      else res = dp[next] = min(res,num[next]);\n    }\n  }\n  return dp[bit] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int i=0;i<(1<<n);i++){\n      dp[i] = -1;\n      num[i] = __builtin_popcount(i);\n      cost[i] = 0;\n      for(int j=0;j<n;j++)\n\tif( (i>>j)& 1)cost[i] += c[j];\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++)\n\tif(f[i][j])r[i] |= 1<<j;\n    }\n\n    printf(\"%d\\n\",rec(0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n\tNODE(){}\n};\n\n#define INF (1<<21)\nNODE Q[1<<16];\n\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tint h = 0;\n\t\tint qsize = 0;\n\t\tQ[qsize++] = NODE(0,0,0);\n\t\tdone[0] = 1;\n\t\twhile(h != qsize){\n\t\t\tNODE q = Q[h++];\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)])Q[qsize++] = (NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1)) , done[q.a|(1<<i)] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int a[20],b[20];\n    memset(b,0,sizeof(b));\n    int sm=0;\n    for(i=0;i<n;i++){\n      int p;\n      cin>>a[i]>>p;\n      sm+=a[i];\n      for(j=0;j<p;j++){\n\tint q;\n\tcin>>q;\n\tb[i]|=1<<q;\n      }\n    }\n    int d[1<<20];\n    memset(d,-1,sizeof(d));\n    int mn;\n    queue<pair<int,pair<int,int> > > c;\n    c.push(make_pair(~((~0)<<n),make_pair(n,sm)));\n    while(c.empty()==0){\n      int p,q,r;      \n      p=c.front().first;\n      q=c.front().second.first;\n      r=c.front().second.second;\n      c.pop();\n      if(d[p]){\n\td[p]=0;\n\tfor(i=0;i<n;i++){\n\t  if(p&(1<<i)){\n\t    if((p&b[i])!=b[i])\n\t      break;\n\t  }\n\t}\n\tif(i==n){\n\t  mn=q;\n\t  for(i=0;i<n;i++){\n\t    if(p&(1<<i)){\n\t      if(r-a[i]>=m)\n\t\tc.push(make_pair(p&(~(1<<i)),make_pair(q-1,r-a[i])));\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\npair<int,int>q[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)q[i]=make_pair(t[i],g[i]);\n\t\tstd::sort(q,q+a);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tt[i]=q[a-1-i].first;\n\t\t\tg[i]=q[a-1-i].second;\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n//vector<pair<int,int > > vpii;\n\npair<int,int> vpii[21];\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((vpii[i].second)&s)==vpii[i].second){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\t//vpii.push_back(p);\n\t\t\tvpii[i]=p;\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//vpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int a[20],b[20][20];\n    for(i=0;i<n;i++){\n      int p;\n      cin>>a[i]>>p;\n      for(j=0;j<p;j++)\n\tcin>>b[i][j];\n      b[i][p]=-1;\n    }\n    int mn=20;\n    for(i=0;i<(1<<n);i++){\n      int sm=0,ct=0;\n      for(j=0;j<n;j++){\n\tif(i&(1<<j)){\n\t  for(k=0;b[j][k]!=-1;k++){\n\t    if((i&(1<<b[j][k]))==0)\n\t      break;\n\t  }\n\t  if(b[j][k]==-1){\n\t    sm+=a[j];\n\t    ct++;\n\t  }else{\n\t    break;\n\t  }\n\t}\n      }\n      if(j==n&&sm>=m)\n\tmn=min(mn,ct);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<bitset>\n#include<deque>\n#include<algorithm>\nusing namespace std;\n\nstruct Pox\n{\n  int state,cost;\n  Pox(int state,int cost):state(state),cost(cost){}\n};\n\nint main()\n{\n  while(1)\n    {\n      int n,U,k,r;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int mincost[1<<n];\n      for(int i=0;i<(1<<n);i++)\n\tmincost[i] = n;\n      deque<Pox> deq;\n      int G[n];\n      int c[n];\n      for(int i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t    if(!k)\n\t      {\n\t\tdeq.push_back(Pox((1<<i),c[i]));\n\t\tmincost[(1<<i)] = 1;\n\t      }\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      deq.push_back(Pox(0,0));\n      mincost[0] = 0;\n     \n      int ans = n;\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  int num = __builtin_popcount(pox.state);\n\t  if(num >= ans)\n\t    continue;\n\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((pox.state >> i) & 1)\n\t\tcontinue;\n\t      int pre = G[i];\n\t      pre &= pox.state;\n\t      if(pre != G[i])\n\t\tcontinue;\n\t      if(mincost[pox.state|(1<<i)] <= num+1)\n\t\tcontinue;\n\t      mincost[pox.state|(1<<i)] = num+1;\n\t      if(pox.cost + c[i] < U)\n\t\tdeq.push_back(Pox(pox.state|(1<<i),pox.cost+c[i]));\n\t      else \n\t\tans = min(ans,num+1);\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  int next_sum;\n  int next_S;\n  int rest;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    rest = total_subjects - bitcount[s.S];\n    for(int i = 0,j=0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if(j++ > rest) break;\n      if(dp[next_S = (s.S | (1<<i))] != -1) continue;\n\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[next_S] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(next_S,next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\nint costs[32];\nint N,U,C,K;\nint ans;\n\nvoid dfs(vector<vector<int> >& vv, int now, int nowcost, int cnt)\n{\n\tif( ans<cnt )return;\n\tif( nowcost>=U ){ ans = cnt; return; }\n\tfor(int i=0; i<N; i++){\n\t\tif( !(now&(1<<i)) ){\n\t\t\tint j;\n\t\t\tfor(j=0; j<vv[i].size(); j++)\n\t\t\t\tif( !(now&(1<<vv[i][j])) )break;\n\t\t\tif( j==vv[i].size() ){\n\t\t\t\tdfs(vv, now|(1<<i), nowcost+costs[i], cnt+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\twhile(cin>>N>>U, N|U){\n\t\tvector<vector<int> > vv(N);\n\t\tmemset(costs,0,sizeof(costs));\n\t\tans = INT_MAX;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tcin>>costs[i]>>K;\n\t\t\tfor(int j=0; j<K; j++){\n\t\t\t\tint a; cin>>a; vv[i].push_back(a);\n\t\t\t}\n\t\t}\n\t\tdfs(vv,0,0,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nint main(){\n  int N,U,c[MAX],k[MAX],r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k[i];\n      int S = 0;\n      for(int j = 0 ; j < k[i] ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF,num = 1<<(N+1);\n    for(int S = 0 ; S < 1<<N ; S++){\n      int cnt = 0, total = 0;\n      bool flg = true;\n      if(num & S == num) continue;\n      for(int i = 0 ; i < N ; i++){\n        if(S >> i & 1){\n          if(S & arr[i] == arr[i]){\n            cnt += c[i]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        if(total < ans){\n          num = S;\n          ans = total;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  for(int n,u;cin>>n>>u,n|u;){\n    int ng[20],pr[20]={};\n    for(int i=0;i<n;i++){\n      int k;\n      cin>>ng[i]>>k;\n      while(k--){\n\tint r;\n\tcin>>r;\n\tpr[i]|=1<<r;\n      }\n    }\n    int m=1<<30;\n    for(int i=0;i<1<<n;i++){\n      int gs=0,ns=0;\n      for(int j=0;j<n;j++){\n\tif(i&1<<j){\n\t  for(int k=0;k<n;k++){\n\t    if(pr[j]&1<<k&&!(i&1<<k)){\n\t      goto next;\n\t    }\n\t  }\n\t  gs+=ng[j];\n\t  ns++;\n\t}\n      }\n      if(u<=gs&&ns<m){\n\tm=ns;\n      }\n    next:\n      ;\n    }\n    cout<<m<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main()\n{\n\tint N,U,K;\n\twhile(cin>>N>>U,N|U){\n\t\tpair<int, vector<int> > piv[N];\n\t\tint ans = INT_MAX;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tcin>>piv[i].first>>K;\n\t\t\tfor(int j=0; j<K; j++){\n\t\t\t\tint a; cin>>a; piv[i].second.push_back(a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<(1<<N); i++){\n\t\t\tint cnt = 0;\n\t\t\tint sum = 0;\n\t\t\tint tmp = 0;\n\t\t\tfor(int j=0; (1<<j)<=i; j++){\n\t\t\t\tif( i&(1<<j) ){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tint k;\n\t\t\t\t\tfor(k=0; k<piv[j].second.size(); k++)\n\t\t\t\t\t\tif( !(i&(1<<piv[j].second[k])) )break;\n\t\t\t\t\tif( k==piv[j].second.size() ){\n\t\t\t\t\t\t//printf(\"i:%d  j:%d\\n\",i,j);\n\t\t\t\t\t\tsum += piv[j].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( tmp==cnt && sum>=U && ans>cnt){\n\t\t\t\tans = cnt;\n\t\t\t\t//puts(\"_____ok_____\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] < credit_requirement) continue;\n      res = min(res,__builtin_popcount(S));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; i++){\n    if(S & (1<<i)) continue;\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] < credit_requirement) continue;\n      res = min(res,__builtin_popcount(S));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nmain(){\n  int n,u;\n\n  while(cin>>n>>u,n|u){\n    vector<int> nec[n];\n    int tani[n];\n\n    rep(i,n){\n      cin>>tani[i];\n      int k;\n      cin>>k;\n      rep(j,k){\n\tint t;\n\tcin>>t;\n\tnec[i].pb(t);\n      }\n    }\n\n    int ans=INT_MAX/2;\n    queue<int> Q;\n    set<int> app;\n    Q.push(0);\n\n    while(!Q.empty()){\n      int cstate=Q.front();Q.pop();\n      if(app.count(cstate))continue;\n      app.insert(cstate);\n\n      int tu=0,ckamoku=0;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n      if(ckamoku>ans)continue;\n      if(tu>=u)ans=min(ans,ckamoku);\n\n      rep(i,n){\n\tif(cstate>>i&1)continue;\n\tbool ok=true;\n\trep(j,nec[i].size()){\n\t  if(cstate>>nec[i][j]&1)continue;\n\t  ok=false;\n\t  break;\n\t}\n\tif(ok){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1<<21)\n\n\nint main(){\n\tint n,U;\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tvector<int> graph[21] ;\n\t\tint unit[20];\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tgraph[i].resize(k);\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tcin >> graph[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 99;\n\t\tfor(int i = 0 ; i < (1<<n) ; i++){\n\t\t\tint v = __builtin_popcount(i) , a = 0;\n\t\t\tbool f = true;\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(i >> j & 1){\n\t\t\t\t\tfor(int k = 0 ; k < graph[j].size() ; k++){\n\t\t\t\t\t\tif( !(i >> graph[j][k] & 1) ){f = false;goto exit;}\n\t\t\t\t\t}\n\t\t\t\t\ta += unit[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\texit: if(f && a >= U)ans = min(v,ans);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool visited[20];\nint bitmask[20];\nint memo[1<<20];\nint c[20];\nint n,U;\nint S, sum;\nint solve() {\n  if (memo[S]>=0) return memo[S];\n//  cout <<bitset<4>(S) << \" \"  << sum << endl;\n  if (sum >= U) return 0;\n  int res = INF;\n  REP(i,n) {\n    if (!(S>>i&1)) {\n      if ((S&bitmask[i]) == bitmask[i]) {\n        if (sum+c[i]>=U) return memo[S]=1;\n        else {\n          S|=1<<i;\n          if (memo[S]>=0)\n            res = min(res, memo[S]+1);\n          else {\n            sum += c[i];\n            res = min(res, solve()+1);\n            sum -= c[i];\n          }\n          S^=1<<i;\n        }\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n>>U, n||U) {\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      cin >> c[i] >> k;\n      REP(j,k) {\n        int r;\n        cin >> r;\n        bitmask[i] |= 1<<r;\n      }\n    }\n    if (U==0) {                 // ツつ「ツづゥツつゥツ不ツ鳴セ\n      cout << 0 << endl;\n      continue;      \n    }\n\n    memset(visited,0,sizeof(visited));\n    memset(memo,-1,sizeof(memo));\n    S = 0; sum = 0;\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n\tNODE(){}\n};\n\n#define INF (1<<21)\nNODE Q[1<<18];\n\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tint h = 0;\n\t\tint qsize = 0;\n\t\tQ[qsize++] = NODE(0,0,0);\n\t\tdone[0] = 1;\n\t\twhile(h != qsize){\n\t\t\tNODE q = Q[h++];\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)])Q[qsize++] = (NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1)) , done[q.a|(1<<i)] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int a[20],b[20];\n    memset(b,0,sizeof(b));\n    int sm=0;\n    for(i=0;i<n;i++){\n      int p;\n      cin>>a[i]>>p;\n      sm+=a[i];\n      for(j=0;j<p;j++){\n\tint q;\n\tcin>>q;\n\tb[i]|=1<<q;\n      }\n    }\n    int mn;\n    queue<pair<int,pair<int,int> > > c;\n    c.push(make_pair(~0,make_pair(n,sm)));\n    while(c.empty()==0){\n      int p,q,r;      \n      p=c.front().first;\n      q=c.front().second.first;\n      r=c.front().second.second;\n      c.pop();\n      for(i=0;i<n;i++){\n\tif(p&(1<<i)){\n\t  if((p&b[i])!=b[i])\n\t    break;\n\t}\n      }\n      if(i==n){\n\tmn=q;\n\tfor(i=0;i<n;i++){\n\t  if(p&(1<<i)){\n\t    if(r-a[i]>=m)\n\t      c.push(make_pair(p&(~(1<<i)),make_pair(q-1,r-a[i])));\n\t  }\n\t}\n      }\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nint c[20], v[20];\nint visit[1 << 20];\nint ans;\nint n, U;\n\nvoid dfs(int cnt, int bits, int sum){\n\tif (visit[bits]) return;\n\tvisit[bits] = 1;\n\tif (ans <= cnt) return;\n\tif (sum >= U){\n\t\tans = cnt;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < n; ++i){\n\t\tif (bits&(1 << i))continue;\n\t\tif ((bits&v[i]) != v[i]) continue;\n\t\tdfs(cnt + 1, bits | (1 << i), sum + c[i]);\n\t}\n}\n\nint main(){\n\twhile (cin >> n >> U, n|U){\n        rep(i, n){\n            cin >> c[i];\n            int k;\n            cin >> k;\n\t\t\tv[i] = 0;\n            rep(j, k){\n                int x;\n                cin >> x;\n                v[i] |= 1<<x;\n            }\n        }\n        ans = n;\n\t\tMEMSET(visit, 0);\n\t\tdfs(0, 0, 0);\n        cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint points;\n\tvector<int> next_SUBJECT;\n};\n\nstruct Data{\n\tint sum_points,number,subj_num;\n\tshort in_num[20];\n};\n\nint N,need_points,POW[21];\nInfo info[20];\nint first_in_num[20];\nbool LOG[1048576];\n\nvoid copyData(Data& to,Data from){\n\tfor(int i = 0; i < N; i++){\n\t\tto.in_num[i] = from.in_num[i];\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++)info[i].next_SUBJECT.clear();\n\tfor(int i = 0; i < POW[N]; i++)LOG[i] = false;\n\n\tint num,tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\t\tfirst_in_num[i] = num;\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[tmp].next_SUBJECT.push_back(i);\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(first_in_num[i] == 0){\n\t\t\tData new_data;\n\t\t\tfor(int k = 0; k < N; k++)new_data.in_num[k] = first_in_num[k];\n\t\t\tnew_data.subj_num = 1;\n\t\t\tnew_data.sum_points = info[i].points;\n\t\t\tnew_data.number = POW[i];\n\t\t\tLOG[POW[i]] = true;\n\t\t\tfor(int k = 0; k < info[i].next_SUBJECT.size(); k++){\n\t\t\t\tnew_data.in_num[info[i].next_SUBJECT[k]]--;\n\t\t\t}\n\t\t\tQ.push(new_data);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().sum_points >= need_points){\n\t\t\tprintf(\"%d\\n\",Q.front().subj_num);\n\t\t\treturn;\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\t\tif(Q.front().number & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tif(Q.front().in_num[loop] == 0){\n\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\tcopyData(new_data,Q.front());\n\t\t\t\t\t\tnew_data.subj_num = Q.front().subj_num+1;\n\t\t\t\t\t\tnew_data.sum_points = Q.front().sum_points+info[loop].points;\n\t\t\t\t\t\tnew_data.number = Q.front().number+POW[loop];\n\t\t\t\t\t\tif(LOG[new_data.number])continue;\n\t\t\t\t\t\tLOG[new_data.number] = true;\n\t\t\t\t\t\tfor(int k = 0; k < info[loop].next_SUBJECT.size(); k++){\n\t\t\t\t\t\t\tnew_data.in_num[info[loop].next_SUBJECT[k]]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(ans == 2)\n\t    break;\n\t  else if(ans == 3)\n\t    break;\n\t  else if(ans == 4)\n\t    break;\n\t      \n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\t//clock_t t0=clock();\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\t\t\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t//clock_t t1=clock();\n\t//printf(\"%.3f[s]\\n\",1.*(t1-t0)/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n = 0, U = 0;\n  while(scanf(\"%d %d\", &n, &U) != EOF && n){\n    int c[20];\n    int need[20] = {};\n    REP(i, n){\n      int k;\n      scanf(\"%d %d\",&c[i], &k);\n      need[i] |= 1<<i;\n      REP(j, k){\n        int a; cin>>a;\n        need[i] |= (1<<a);\n      }\n    }\n    /*\n    for(int S = 0; S < 1<<n; S++){\n      int cnt = __builtin_popcount(S);\n      if(ans <= cnt) continue;\n      bool ok = true;\n      int sum = 0;\n      for(int i = 0; i < n; i++)if(S >> i & 1){\n        if(need[i] != (S & need[i])){\n          ok = false;\n          break;\n        }\n        sum += c[i];\n      }\n      if(ok && sum >= U) ans = cnt;\n    }\n    */\n    int ans = n;\n    for(int k = 1; k < n; k++){\n      int comb = (1<<k) - 1;\n      while(comb < (1 << n)){\n        int S = comb;\n        bool ok = true;\n        int sum = 0;\n        for(int i = 0; i < n; i++)if(S >> i & 1){\n          if(need[i] != (S & need[i])){\n            ok = false;\n            break;\n          }\n          sum += c[i];\n        }\n        if(ok && sum >= U){\n          ans = k;\n          goto OUTPUT;\n        }\n        int x = comb & -comb, y = comb + x;\n        comb = ((comb & ~y) / x >> 1) | y;\n      }\n    }\n\nOUTPUT:;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nclass Cl{\npublic:\n  Cl() {}\n  Cl(int _pt, vector<int> _v): pt(_pt), v(_v) {}\n\n  int pt;\n  vector<int> v;\n};\n\nclass St{\npublic:\n  int cnt, sm;\n  vector<int> vis;\n\n  St() {}\n  St(int _cnt, int _sm, vector<int> _vis): cnt(_cnt), sm(_sm), vis(_vis) {}\n\n  bool operator>(const St& st) const{\n    return cnt > st.cnt;\n  }\n};\n\nint n, u;\nvector<Cl> vec;\n\nbool check(int p, vector<int> v)\n{\n  bool f = true;\n  for(int i = 0; i < vec[p].v.size(); ++i)\n    f = f && (v[vec[p].v[i]] == 0);\n\n  return f;\n}\n\nint bfs()\n{\n  St st;\n  priority_queue<St, vector<St>, greater<St> > que;\n  vector<int> vc = vector<int>(21, 1);\n  que.push(St(0, 0, vc));\n\n  while(!que.empty()){\n    st = que.top();\n    que.pop();\n\n    if(st.sm >= u) return st.cnt;\n\n    for(int i = 0; i < n; ++i){\n      if(st.vis[i]){\n\tif(vec[i].v.size() && !check(i, st.vis)) continue;\n\tvc = st.vis;\n\tvc[i] = 0;\n\tque.push(St(st.cnt+1, st.sm+vec[i].pt, vc));\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main()\n{\n  int s, t;\n  vector<int> tmp;\n\n  while(cin>>n>>u && n+u){\n    for(int i = 0; i < n; ++i){\n      cin >> t >> s;\n      if(s){\n        tmp = vector<int>(s);\n        for(int i = 0; i < s; ++i) cin >> tmp[i];\n      }\n      vec.push_back(Cl(t, tmp));\n      tmp.clear();\n    }\n\n    cout << bfs() << endl;\n    vec.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp,sum;\nint c[30],k[30],r[30],low[30];\nint ans;\nbool f;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      low[i] = c[i];\n      r[i] = 0;\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tr[i] |= 1<<tmp;\n      }\n    }\n\n    sort(low,low+n,greater<int>());\n\n    int l; sum = 0;\n    for(l=0;l<n;l++){\n      sum += c[l];\n      if(U<=sum)break;\n    }\n\n    f = false;;\n    for(ans=l+1;ans<n;ans++){\n      int comb = (1<<ans) -1;\n      while(comb < (1<<n)){\n\tsum = 0; f = true;\n\tfor(int i=0;i<n;i++){\n\t  if((comb>>i)&1){\n\t    if( (comb&r[i]) != r[i]){\n\t      f = false;\n\t      break;\n\t    }\n\t    sum += c[i];\n\t  }\n\t}\n\n\tif(f && U<=sum){\n\t  break;\n\t}\n\tf = false;\n      \n\tint x = comb & -comb, y = comb + x;\n\tcomb = ( ( (comb & ~y) /x ) >> 1) | y;\n      }\n      if(f)break;\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    ans=INT_MAX/2;\n    rep(i,1<<n)app[i]=0;\n    queue<int> Q;\n    Q.push(0);\n\n    while(!Q.empty()){\n      cstate=Q.front();\n      Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      tu=0;\n      ckamoku=0;\n\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n\n      if(tu>=u){\n\tans=ckamoku;\n\tbreak;\n      }\n\n      rep(i,n){\n\tif((cstate&nec[i])==nec[i] && !app[cstate|1<<i]){\n\t  nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,int > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tif(((vpii[i].second)&s)==vpii[i].second){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint popcount32(unsigned int x){\n\tx = (x>>1 & 0x55555555)+(x & 0x55555555);\n\tx = (x>>2 & 0x33333333)+(x & 0x33333333);\n\tx = (x>>4 & 0x0f0f0f0f)+(x & 0x0f0f0f0f);\n\tx = (x>>8 & 0x00ff00ff)+(x & 0x00ff00ff);\n\treturn (x>>16)+(x & 0x0000ffff);\n}\n\nint tanni[20];\nint prelearn[20];\n\nint main(){\n\tint n,u;\n\twhile(cin>>n>>u,n|u){\n\t\tmemset(tanni,0,sizeof(tanni));\n\t\tmemset(prelearn,0,sizeof(prelearn));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,k;\n\t\t\tcin>>c>>k;\n\t\t\ttanni[i]=c;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tprelearn[i]|=1<<r;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tint pop=popcount32(i);\n\t\t\tif(ans<pop)continue;\n\t\t\tbool valid=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((i>>j&1)&&(prelearn[j]&i)!=prelearn[j]){\n\t\t\t\t\tvalid=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!valid)continue;\t\t\t\n\t\t\tint s=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i>>j&1)s+=tanni[j];\n\t\t\t}\n\t\t\tif(u<=s)ans=pop;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<bitset>\n\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n \nint check(int state,VVI& G,VI& c)\n{\n  int n = G.size();\n  int res = 0;\n  for(int j=0;j<n;j++)\n    {\n      if((state >> j) & 1)\n\t{\n\t  res += c[j];\n\t  for(int k=0;k<G[j].size();k++)\n\t    if(!((state >> G[j][k]) & 1))\n\t      return -1; \n\t}     \n    }\n  return res;\n}\n\nint main()\n{\n  int n,U;\n  while(cin >> n >> U,n|U)\n    {\n      vector<vector<int> > G;\n      G.resize(n);\n      vector<int> c; \n      c.resize(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  int k;\n\t  cin >> c[i] >> k;\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      int r;\n\t      cin >> r;\n\t      G[i].push_back(r);\n\t    }\n\t}\n\n      int ans = (1<<29);\n      for(int i=0;i<(1<<n);i++)\n\t{\n\t  int men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\t  int res;\n\t  if((res = check(i,G,c)) == -1)\t \n\t    continue;\n\t  if(res >= U)\n\t    ans = min(ans,men);\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntypedef struct\n{\n  int c, r;\n} Subject;\n\nint n, U;\nSubject sub[20];\nbool memo[1 << 20];\n\nint solve(int bit, int cnt)\n{\n  if (memo[bit])\n    return __builtin_popcount(bit);\n\n  if (cnt >= U) {\n    memo[bit] = true;\n    return __builtin_popcount(bit);\n  }\n\n  int ret = INF;\n  for (int i = 0; i < n; ++i) {\n    if (!(bit & (1 << i)) && (sub[i].r & bit) == sub[i].r)\n      ret = min(ret, solve(bit | (1 << i), cnt+sub[i].c));\n  }\n  return ret;\n}\n\nint main()\n{\n  while (~scanf(\"%d %d\", &n, &U)) {\n    if (n == 0 && U == 0)\n      break;\n\n    for (int i = 0; i < (1 << 20); ++i)\n      memo[i] = false;\n\n    for (int i = 0; i < n; ++i) {\n      sub[i].r = 0;\n      int k, r = 0;\n      scanf(\"%d %d\", &sub[i].c, &k);\n      for (int j = 0; j < k; ++j) {\n\tint r;\n\tscanf(\"%d\", &r);\n\tsub[i].r |= (1 << r);\n      }\n    }\n    printf(\"%d\\n\", solve(0, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include<iostream>\n#include<cmath>\n\n\nstruct Subject {\n\tint point{ 0 }, need{ 0 };\n};\n\nint main() {\n\tstd::vector<std::vector<int>> by_digit(21);\n\tfor (auto i = 0; i < (1 << 20); ++i) {\n\t\tint count = 0;\n\t\tfor (auto j = i; j > 0; j >>= 1) {\n\t\t\tcount += j % 2;\n\t\t}\n\t\tby_digit[count].push_back(i);\n\t}\n\twhile (true) {\n\t\tint n, u; std::cin >> n >> u; if (n == 0) break;\n\t\tstd::vector<Subject> subjects(n);\n\t\tfor (auto &s: subjects) {\n\t\t\tint prev;\n\t\t\tstd::cin >> s.point >> prev;\n\t\t\tfor (auto i = 0; i < prev; ++i) {\n\t\t\t\tint a; std::cin >> a;\n\t\t\t\ts.need |= (1 << a);\n\t\t\t}\n\t\t}\n\t\tint min_count = -1;\n\t\tfor (auto d = 1; min_count == -1; ++d) {\n\t\t\tfor (const auto p : by_digit[d]) {\n\t\t\t\tint point = 0;\n\t\t\t\tfor (auto i = 0; i < subjects.size(); ++i) if ((p & (1 << i)) != 0) {\n\t\t\t\t\tif ((p & (subjects[i].need)) != subjects[i].need) {\n\t\t\t\t\t\tpoint = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpoint += subjects[i].point;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (point >= u) {\n\t\t\t\t\tmin_count = d;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << min_count << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t{\n\t\t\tbool ng = false;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (i >> j & 1 && i & r[i] != r[i])\n\t\t\t\t{\n\t\t\t\t\tng = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ng)\n\t\t\t\tcontinue;\n\n\t\t\tint s = 0;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (i >> j & 1)\n\t\t\t\t\ts += c[i];\n\t\t\tif (s >= u)\n\t\t\t\tmin_swap(res, popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\npair<int,int>p[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)p[i]=make_pair(t[i],g[i]);\n\t\tstd::sort(p,p+a);\n\t//\tfor(int i=0;i<a;i++){\n\t//\t\tt[i]=p[a-1-i].first;\n\t//\t\tg[i]=p[a-1-i].second;\n\t//\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,u;\n  while(cin>>n>>u,n||u){\n    int a[20],b[20]={};    \n    for(i=0;i<n;++i){\n      cin>>a[i];\n      int m;\n      cin>>m;\n      for(j=0;j<m;++j){\n\tint p;\n\tcin>>p;\n\tb[i]|=1<<p;\n      }\n    }\n    bool c[1<<20]={};\n    c[0]=true;\n    queue<pair<pair<int,int>,int> > d;\n    d.push(make_pair(make_pair(0,0),0));\n    while(!d.empty()){\n      int p,q,r;\n      p=d.front().first.first;\n      q=d.front().first.second;\n      r=d.front().second;\n      if(q>=u)\n\tbreak;\n      d.pop();\n      for(i=0;i<n;++i){\n\tif((p&(1<<i))||(p&b[i])!=b[i]||c[p|(1<<i)])\n\t  continue;\n\tc[p|(1<<i)]=true;\n\td.push(make_pair(make_pair(p|(1<<i),q+a[i]),r+1));\n      }\n    }\n    cout<<d.front().second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nint visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n};\n\nint solve(int N, int U, int tno) {\n  queue<State> up;\n  static State s;\n  s.one = s.mask = s.have = 0;\n  visited[s.mask] = tno;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.front(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] != tno && (s.mask | need[i]) == s.mask )\n      {\n        static State next;\n        next.mask = s.mask | (1 << i);\n        next.one = s.one + 1;\n        next.have = s.have + unit[i];\n        visited[next.mask] = 1;\n        up.push(next);\n      }\n  }\n  return -1;\n}\n\nint main() {\n  for(int tno = 1;; tno++) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n    \n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U, tno);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool solve(bitset<18>bs, vector<vector<int>>&dp,const vector<pair<int,int>>&vs,const int now) {\n\tif(dp[now][bs.to_ulong()]!=-1)return dp[now][bs.to_ulong()];\n\n\tbool ok = false;\n\tif(bs.count()==vs.size())ok=true;\n\telse {\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tif (bs[i]) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (vs[i].first == now || now == 7) {\n\t\t\t\t\tbs[i] = true;\n\t\t\t\t\tbool aok = solve(bs, dp, vs, vs[i].second);\n\t\t\t\t\tif (aok)ok = true;\n\t\t\t\t\tbs[i] = false;\n\t\t\t\t}\n\t\t\t\tif (vs[i].second == now || now == 7) {\n\t\t\t\t\tbs[i] = true;\n\t\t\t\t\tbool aok = solve(bs, dp, vs, vs[i].first);\n\t\t\t\t\tif(aok)ok=true;\n\t\t\t\t\tbs[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t}\n\treturn dp[now][bs.to_ulong()]=ok;\n}\n\nvoid solve(vector<int>&memo,const int rest,const vector<int>&values, const vector<vector<int>>&rev_edges, int sum, int now,const vector<int>&perms,int&ans) {\n\tif (rest <= 0) {\n\t\tans=min(ans,sum);\n\t\treturn ;\n\t}\n\telse if (now == values.size()) {\n\t\treturn;\n\t}\n\telse {\n\t\tsolve(memo,rest,values,rev_edges,sum,now+1,perms,ans);\n\n\t\tbool ok=true;\n\t\tfor (auto re : rev_edges[perms[now]]) {\n\t\t\tif(!memo[re])ok=false;\n\t\t}\n\t\tif (ok) {\n\t\t\tmemo[perms[now]]=true;\n\t\t\tsolve(memo,rest-values[perms[now]],values,rev_edges,sum+1,now+1,perms,ans);\n\t\t\tmemo[perms[now]]=false;\n\t\t}\n\t}\n\n}\nint main()\n{\n\twhile (true) {\n\t\tint N,U;cin>>N>>U;\n\t\tif(!N)break;\n\t\tvector<int>values(N);\n\t\tvector<vector<int>>edges(N);\n\t\tvector<vector<int>>rev_edges(N);\n\t\tvector<int>comes(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint c,k;cin>>c>>k;\n\t\t\tvalues[i]=c;\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint a;cin>>a;\n\t\t\t\tedges[a].push_back(i);\n\t\t\t\trev_edges[i].push_back(a);\n\t\t\t\tcomes[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<int>que;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (comes[i] == 0) {\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t\tvector<int>perms;\n\t\twhile (!que.empty()) {\n\t\t\tint atop(que.front());\n\t\t\tque.pop();\n\t\t\tperms.push_back(atop);\n\t\t\tfor (auto e : edges[atop]) {\n\t\t\t\tcomes[e]--;\n\t\t\t\tif (comes[e] == 0) {\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>rev_perms(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\trev_perms[perms[i]]=i;\n\t\t}\n\t\tint ans=100;\n\t\tvector<int>memo(N);\n\t\tsolve(memo,U,values,rev_edges,0,0,perms,ans);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nchar memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n  state ns(0,0,0);;\n  int i;\n\n  while(!Q.empty()) {\n    ns = Q.front(); Q.pop();\n    for(i=0; i<n; ++i) {\n      if((ns.used>>i) & 1\n\t || memo[ns.used|(1<<i)]\n\t || (ns.used & pv[i] != pv[i])) continue;\n      memo[ns.used|(1<<i)] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, 0, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    int next_sum;\n    for(int i = 0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if((prior[i] | s.S) == s.S){\n\tif(dp[s.S | (1<<i)] != -1) continue;\n\tnext_sum = s.sum + credit[i];\n\tdp[s.S | (1<<i)] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(s.S | (1<<i),next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n    int used,cost;\n    state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n    int n = 0;\n    while(x != 0) {\n        n++;\n        x &= (x-1);\n    }\n    return n;\n}\n\ninline int bit_count(int x)\n{\n  x = (x & 0x55555555) + (x >> 1 & 0x55555555);\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n  x = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n  return (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        int ans = 100000,t;\n        for(int i=0; i<1<<n; ++i) {\n            t = 0;\n            for(int j=0; j<n; ++j) {\n                if((i>>j)&1 != 0) {\n                    if(pv[j] != pv[j] & i) goto NEXT;\n                    t += cv[j];\n                }\n            }\n            if(t >= U) ans = min(ans,bit_count(i));\n        NEXT:;\n        }\n\n//        cout<<bfs()<<endl;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\n//pair<pair<int,int>,int>p[21];\n//int conv[];\nint bp[1<<20];\nint main(){\n\tint a,b;\n\tfor(int i=0;i<(1<<20);i++)bp[i]=__builtin_popcount(i);\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<a;i++)p[i]=make_pair(t[i],g[i]),;\n\t//\tstd::sort(p,p+a);\n\t//\tfor(int i=0;i<a;i++){\n\t//\t\tt[i]=p[a-1-i].first;\n\t//\t\tg[i]=p[a-1-i].second;\n\t//\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=bp[i];\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tint i = (1 << bits) - 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbool ng = false;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (i >> j & 1 && i & r[j] != r[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tng = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ng)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t\ts += c[j];\n\t\t\t\tif (s >= u)\n\t\t\t\t{\n\t\t\t\t\tres = bits;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\t// combination\n\t\t\t\tint leastBit = i & -i;\n\t\t\t\tint mostBits = i + leastBit;\n\t\t\t\tint leastSequentialBits = i & ~mostBits;\n\t\t\t\ti = mostBits | ((leastSequentialBits / leastBit) >> 1);\n\t\t\t} while (i < 1 << n);\n\t\t}\nend:\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#ifdef _MSC_VER\n#define __builtin_popcount(x) (__popcnt(x))\n#define __builtin_popcountll(x) (__popcnt(x) + __popcnt(x >> 32))\n#endif\nint n, x, l, v, c[22], r[22];\nint main() {\n\twhile (cin >> n >> x, n | x) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c[i] >> l; r[i] = 0;\n\t\t\tfor (int j = 0; j < l; j++) cin >> v, r[i] += (1 << v);\n\t\t}\n\t\tint ret = n;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tbool flag = true;\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tsum += c[j];\n\t\t\t\t\tif ((i | r[j]) != i) {\n\t\t\t\t\t\tflag = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) break;\n\t\t\t}\n\t\t\tif (flag && sum >= x) ret = min(ret, (int)__builtin_popcount(i));\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nint n,U;\n\nvector<int> req;\nvector<int> unit;\n\nint main()\n{\n  while(scanf(\"%d%d\", &n, &U), n || U) {\n    req = vector<int>(n, 0);\n    unit = vector<int>(n);\n    int k,r;\n    for(int i=0; i<n; ++i) {\n      scanf(\"%d%d\", &unit[i], &k);\n      for(int j=0; j<k; ++j) {\n\t\t\tscanf(\"%d\", &r);\n\t\t\treq[i] |= 1 << r;\n      }\n    }\n    int j, sol = 100, u, c, skip;\n    for(int i=0; i<(1<<n); ++i) {\n      u = c = 0;\n      for(j=n-1; j>=0; --j) {\n\t\t\tif(!(i&(1<<j))) continue;\n\t\t\tc++;\n\t\t\tif((i&req[j])!=req[j] || sol<c) {\n\t\t\t\ti += (((skip=((i&req[j])^req[j]|1<<j))&-skip)-1)&~i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tu += unit[j];\n      }\n      sol = j < 0 && u >= U ? min(sol, c) : sol;\n    }\n    printf(\"%d\\n\", sol);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint n, U, a[100], b[100], c;\nvector<int>x[100], p; queue<int>Q;\nint dp[100][1000];\nint dp2[100][1000];\nbool used[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 100; i++) { a[i] = 0; b[i] = 0; used[i] = false; for (int j = 0; j < 1000; j++) { dp[i][j] = 0; dp2[i][j] = 0; }x[i].clear(); }\n\t\tcin >> n >> U; if (n == 0 && U == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tfor (int j = 0; j < b[i]; j++) {\n\t\t\t\tcin >> c; x[c].push_back(i);\n\t\t\t}\n\t\t}\n\t\tQ.push(n);\n\t\tfor (int i = 0; i < n; i++) { if (b[i] == 0)x[n].push_back(i); }\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop(); p.push_back(a1); used[a1] = true;\n\t\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\t\tif (used[x[a1][i]] == false) { Q.push(x[a1][i]); used[x[a1][i]] = true; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++)dp[i][j] = 100000000;\n\t\t}\n\t\treverse(p.begin(), p.end());\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\tint a1 = p[i];\n\t\t\tfor (int k = 0; k <= x[a1].size(); k++) {\n\t\t\t\tfor (int l = 0; l < 200; l++)dp2[k][l] = 10000000;\n\t\t\t}\n\t\t\tdp2[0][0] = 0;\n\t\t\tfor (int k = 0; k < x[a1].size(); k++) {\n\t\t\t\tfor (int l = 0; l < 200; l++) {\n\t\t\t\t\tif (dp2[k][l] == 10000000)continue;\n\t\t\t\t\tfor (int m = 0; m < 200; m++) {\n\t\t\t\t\t\tdp2[k + 1][l + m] = min(dp2[k + 1][l + m], dp2[k][l] + dp[x[a1][k]][m]);\n\t\t\t\t\t}\n\t\t\t\t\tdp2[k + 1][l] = min(dp2[k + 1][l], dp2[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tdp[a1][j + a[a1]] = min(dp[a1][j + a[a1]], dp2[x[a1].size()][j] + 1);\n\t\t\t}\n\t\t}\n\t\tint minx = 10000000;\n\t\tfor (int i = U; i < 1000; i++) {\n\t\t\tminx = min(minx, dp[n][i]);\n\t\t}\n\t\tcout << minx - 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#ifdef _MSC_VER\n#define __builtin_popcount(x) (__popcnt(x))\n#define __builtin_popcountll(x) (__popcnt(x) + __popcnt(x >> 32))\n#endif\nint n, x, l, v, c[22], r[22];\nint main() {\n\twhile (cin >> n >> x, n | x) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c[i] >> l; r[i] = 0;\n\t\t\tfor (int j = 0; j < l; j++) cin >> v, r[i] += (1 << v);\n\t\t}\n\t\tint ret = n;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tbool flag = true;\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tsum += c[j];\n\t\t\t\t\tif ((i | r[j]) != i) {\n\t\t\t\t\t\tflag = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag && sum >= x) ret = min(ret, (int)__builtin_popcount(i));\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U,tmp;\n  int c[30],k[30],r[30];\n\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      r[i] = 0;\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tr[i] |= 1<<tmp;\n      }\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = __builtin_popcount(i), sum = 0;\n      if(res <= num)continue;\n\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  f &= ( (r[j]&i) == r[j] );\n\t  if(!f)break;\n\t  sum += c[j];\n\t  f &= sum<=U;\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 28;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint sensyu[20];\nint tanni[20];\nvector<int> sen[20];\n\nint get_sensyu(int v){\n\tint res = 0;\n\trep(i, (int)sen[v].size()){\n\t\tres |= sen[v][i];\n\t\tres |= get_sensyu(sen[v][i]);\n\t}\n\treturn res;\n}\n\nint C(int state, int n){\n\tint res = 0;\n\trep(i, n){\n\t\tif(state & (1 << i)){\n\t\t\tif((state | sensyu[i]) != state) return -1;\n\t\t\telse res += tanni[i];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, U, k, id;\n\tint res;\n\twhile(cin >> n >> U && (n || U)){\n\t\trep(i, 20) sen[i].clear();\n\t\tres = n;\n\t\trep(i, n){\n\t\t\tcin >> tanni[i];\n\t\t\tcin >> k;\n\t\t\trep(j, k){\n\t\t\t\tcin >> id;\n\t\t\t\tsen[i].push_back(id);\n\t\t\t}\n\t\t}\n\t\trep(i, n){\n\t\t\tsensyu[i] = get_sensyu(i);\n\t\t}\n\t\trep(i, 1 << n){\n\t\t\tint cnt = 0;\n\t\t\trep(j, n) if(i & (1 << j)) cnt++;\n\t\t\tif(C(i, n) >= U){\n\t\t\t\tres = min(cnt, res);\n\t\t\t}\n\t\t}\n\t\tcout <<res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool visited[20];\nint bitmask[20];\nint memo[1<<20];\nint c[20];\nint n,U;\nint S, sum;\nint solve() {\n  if (memo[S]>=0) return memo[S];\n//  cout <<bitset<4>(S) << \" \"  << sum << endl;\n  if (sum >= U) return 0;\n  int res = INF;\n  REP(i,n) {\n    if (!(S>>i&1)) {\n      if ((S&bitmask[i]) == bitmask[i]) {\n        S|=1<<i;\n        if (memo[S]>=0)\n          res = min(res, memo[S]+1);\n        else {\n          sum += c[i];\n          res = min(res, solve()+1);\n          sum -= c[i];\n        }\n        S^=1<<i;\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n>>U, n||U) {\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      cin >> c[i] >> k;\n      REP(j,k) {\n        int r;\n        cin >> r;\n        bitmask[i] |= 1<<r;\n      }\n    }\n    if (U==0) {                 // ツつ「ツづゥツつゥツ不ツ鳴セ\n      cout << 0 << endl;\n      continue;      \n    }\n\n    memset(visited,0,sizeof(visited));\n    memset(memo,-1,sizeof(memo));\n    S = 0; sum = 0;\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct data{\n  int point, req;\n  data(){}\n  data(int p, int r):point(p),req(r){}\n};\n\nint N,U;\nvector<data> V;\nvoid init(){\n  V.clear();\n}\n\nvoid input(){\n\n  for(int i = 0; i < N; i++){\n    data d;\n    cin >> d.point;\n    int k;\n    cin >> k;\n    while(k--){\n      int in;\n      cin >> in;\n      d.req += (1<<in);\n    }\n    V.push_back(d);\n  }\n}\n\nint get(int n){\n\n  int sum = 0;\n  for(int i = 0; i < (1<<N); i++){\n    if(n&(1<<i) && n&V[i].req != V[i].req) return -1;\n    if(n&(1<<i) && n&V[i].req == V[i].req) sum += V[i].point;\n  }\n  return sum;\n}\n\nint Bit(int n){\n  int res = 0;\n  for(int i = 0; i < (1<<N); i++)\n    if(n&(1<<i)) res++;\n\n  return res;\n}\nvoid solve(){\n  int ans = 30;\n\n  for(int i = 1; i < (1<<N); i++){\n    int res = get(i);\n    if(res >= U) ans = min(ans,Bit(i));\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  \n  while(cin >> N >> U && N+U){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nbool visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n  bool operator<(const State& t) const {\n    if( one != t.one ) return one > t.one;\n    return have < t.have;    \n  }\n};\n\nint solve(int N, int U) {\n  memset(visited, 0, sizeof(visited));  \n  priority_queue<State> up;\n  State s;\n  s.one = 0;\n  s.mask = 0;\n  s.have = 0;  \n  visited[s.mask] = 1;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.top(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( (s.mask & (1 << i)) == 0 && (s.mask | need[i]) == s.mask )\n      {\n        State next;        \n        next.mask = s.mask | (1 << i);\n        if( visited[next.mask] ) continue;        \n        next.one = s.one + 1;\n        next.have = s.have + unit[i];\n        visited[next.mask] = 1;\n        up.push(next);\n      }\n  }\n  return -1;\n}\n\nint main() {\n  for(;;) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    REP(i, N) {\n      unit[i] = nextInt();\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    int best = solve(N, U);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, U, a[20], b[20], c, r[20], popcount[1048588], sum[1048588];\nvector<pair<int, int>>popcnts[21];\nint main() {\n\tfor (int i = 0; i < 20; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 20; i++) {\n\t\tfor (int j = 0; j < (1 << i); j++)popcnts[i].push_back(make_pair(popcount[j], j));\n\t\tsort(popcnts[i].begin(), popcnts[i].end());\n\t}\n\twhile (scanf(\"%d%d\", &n, &U), n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]); r[i] = 0;\n\t\t\tfor (int j = 0; j < b[i]; j++) {\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tr[i] |= 1 << c;\n\t\t\t}\n\t\t}\n\t\tsum[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\t\tsum[j] = sum[j - (1 << i)] + a[i];\n\t\t\t}\n\t\t}\n\t\tint minx = 10000000;\n\t\tfor (int h = 0; h < (1 << n); h++) {\n\t\t\tint i = popcnts[n][h].second;\n\t\t\tif (sum[i] < U)continue;\n\t\t\tbool flag = false;\n\t\t\tint G = (1 << n) - i - 1;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i & (1 << j)) && (G & r[j])) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) { minx = min(minx, popcount[i]); break; }\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\ntypedef struct{\n  int state,kamoku,tani;\n}structst;\nstructst tstr,nstr;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    ans=INT_MAX/2;\n    rep(i,1<<n)app[i]=0;\n    queue<structst> Q;\n    tstr.state=0;\n    tstr.kamoku=0;\n    tstr.tani=0;\n    Q.push(tstr);\n\n    while(!Q.empty()){\n      tstr=Q.front();\n      Q.pop();\n      if(app[tstr.state])continue;\n      app[tstr.state]=true;\n\n      if(tstr.tani>=u){\n\tans=tstr.kamoku;\n\tbreak;\n      }\n\n      nstr.kamoku=tstr.kamoku+1;\n      cstate=tstr.state;\n\n      rep(i,n){\n\tif((cstate&nec[i])==nec[i] && !app[cstate|1<<i]){\n\t  nstr.state=tstr.state|1<<i;\n\t  nstr.tani=tstr.tani+tani[i];\n\t  Q.push(nstr);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint memo[1<<20];\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  int *m = memo;\n  register unsigned int i,j,l;\n  for(i=0; i<(1<<20); i++) *m++ = cnt(i);\n\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n    m = &memo[(1<<n)-1];\n    for(i=0; i-n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = *m--;\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\t//if(!(!(i & (1<<j)) || !((i & r[i]) == r[j])))\n\tif(!((!(i & (1<<j))) | (!((i & r[j]) ^ r[j]))))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, U, a[20], b[20], c, r[20];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> U; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> b[i]; r[i] = 0;\n\t\t\tfor (int j = 0; j < b[i]; j++) { cin >> c; r[i] += (1 << c); }\n\t\t}\n\t\tint minx = 10000000;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint bit[20]; for (int j = 0; j < n; j++) { bit[j] = (i / (1 << j)) % 2; }\n\t\t\tint sum = 0; for (int j = 0; j < n; j++) { if (bit[j] == 1)sum += a[j]; }\n\t\t\tif (sum < U)continue; bool flag = false;\n\t\t\tint G = (1 << n) - 1; G ^= i;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (bit[j] == 0)continue;\n\t\t\t\tif ((G & r[j]) != 0) { flag = true; break; }\n\t\t\t}\n\t\t\tif (flag == false) {\n\t\t\t\tint cnt = 0; for (int j = 0; j < n; j++) { if (bit[j] == 1)cnt++; }\n\t\t\t\tminx = min(minx, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp;\nint c[30],k[30],r[30];\nbool f[30][30];\nint cost[1<<21],num[1<<21];\nvector<int> v;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    v.clear();\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++){\n\tif(f[i][j])r[i] |= 1<<j;\n      }\n    }\n\n    for(int i=0;i<(1<<n);i++){\n      int tmp = 0;\n      for(int j=0;j<n;j++){\n\tif( (i>>j) &1)tmp |= r[j];\n      }\n      v.push_back(tmp);\n    }\n\n    int res = 20;\n    for(int i = 0;i<(int)v.size();i++){\n      int sum = 0;\n      for(int j=0;j<n;j++){\n\tif( (v[i]>>j)&1)sum += c[j];\n      }\n      if(U<=sum)res = min(res,__builtin_popcount(v[i]));\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint out_num,in_num,points;\n\tbool erased;\n\tvector<int> pre_SUBJECT,next_SUBJECT;\n};\n\nint N,need_points;\nInfo info[21];\n\nvoid func(){\n\n\tfor(int i = 1; i <= N; i++){\n\t\tinfo[i].out_num = 0;\n\t\tinfo[i].in_num = 0;\n\t\tinfo[i].erased = false;\n\t\tinfo[i].pre_SUBJECT.clear();\n\t\tinfo[i].next_SUBJECT.clear();\n\t}\n\n\tint num,tmp,SUM = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\t\tSUM += info[i].points;\n\t\tinfo[i].in_num = num;\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[i].pre_SUBJECT.push_back(tmp);\n\t\t\tinfo[tmp].next_SUBJECT.push_back(i);\n\t\t\tinfo[tmp].out_num++;\n\t\t}\n\t}\n\n\tint ans = N;\n\tint point_MIN,min_index;\n\tbool is_OUT;\n\n\twhile(true){\n\t\tpoint_MIN = BIG_NUM;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(info[i].erased)continue;\n\n\t\t\tif(info[i].out_num == 0){\n\t\t\t\tif(info[i].points < point_MIN){\n\t\t\t\t\tpoint_MIN = info[i].points;\n\t\t\t\t\tis_OUT = true;\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(info[i].in_num == 0){\n\t\t\t\tif(info[i].points < point_MIN){\n\t\t\t\t\tpoint_MIN = info[i].points;\n\t\t\t\t\tis_OUT = false;\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo[min_index].erased = true;\n\n\t\tif(is_OUT){\n\t\t\tfor(int i = 0; i < info[min_index].pre_SUBJECT.size(); i++){\n\t\t\t\tinfo[info[min_index].pre_SUBJECT[i]].out_num--;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0; i < info[min_index].next_SUBJECT.size(); i++){\n\t\t\t\tinfo[info[min_index].next_SUBJECT[i]].in_num--;\n\t\t\t}\n\t\t}\n\n\t\tif(SUM-info[min_index].points < need_points){\n\t\t\tbreak;\n\t\t}\n\n\t\tSUM -= info[min_index].points;\n\t\tans -= 1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 20\n\nint n, U;\nint cs[MAX_N];\nint rs[MAX_N];\n\ninline bool check(int S) {\n    // 総単位数がUを越えているか\n    int unit = 0;\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            unit += cs[i];\n        }\n    }\n    if (unit < U) return false;\n\n    // 履修に必要な単位をすべて取得しているか\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            if ((S & rs[i]) != rs[i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    while (cin >> n >> U, n || U) {\n        memset(cs, 0, sizeof(cs));\n        memset(rs, 0, sizeof(rs));\n        for (int i = 0; i < n; i++) {\n            int c, k, r;\n            cin >> c >> k; r = 0;\n            for (int j = 0; j < k; j++) {\n                int _r; cin >> _r;\n                r |= (1<<_r);\n            }\n            cs[i] = c;\n            rs[i] = r;\n        }\n\n        int ans = (1<<28);\n        for (int S = 1; S < (1<<n); S++) {\n            if (check(S)) {\n                ans = min(ans, __builtin_popcount(S));\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(men >= (1<<2)-1 && ans == 2)\n\t    break;\n\t  else if(men >= (1<<3)-1 && ans == 3)\n\t    break;\n\t  else if(men >= (1<<4)-1 && ans == 4)\n\t    break;\n\t  else if(men >= (1<<5)-1  && ans == 5)\n\t    break;\n\t  else if(men >= (1<<6)-1 && ans == 6)\n\t    break;\n\t  else if(men >= (1<<7)-1 && ans == 7)\n\t    break;\n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n    int used,cost;\n    state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n    int n = 0;\n    while(x != 0) {\n        n++;\n        x &= (x-1);\n    }\n    return n;\n}\n\ninline int bit_count(int x)\n{\n  x = (x & 0x55555555) + (x >> 1 & 0x55555555);\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);\n  x = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);\n  return (x & 0x0000ffff) + (x >>16 & 0x0000ffff);\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        int ans = 100000,t;\n        for(int i=0; i<1<<n; ++i) {\n            t = 0;\n            for(int j=0; j<n; ++j) {\n                if((i>>j)&1 != 0) {\n                    if(pv[j] != pv[j] & i) goto NEXT;\n                    t += cv[j];\n                }\n            }\n            if(t >= U) {\n                ans = min(ans,bit_count(i));\n                break;\n            }\n        NEXT:;\n        }\n\n//        cout<<bfs()<<endl;\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nint main(){\n\tint n, U;\n\twhile (cin >> n >> U, n|U){\n        vector<int> c(n), v(n);\t\n        rep(i, n){\n            cin >> c[i];\n            int k;\n            cin >> k;\n            rep(j, k){\n                int x;\n                cin >> x;\n                v[i] |= 1<<x;\n            }\n        }\n        int ans = 1<<30;\n        rep(i, 1<<n){\t\t\t\n            int sum = 0, cnt = 0, ok = true;\n            rep(j, n){\n                if(~i&(1<<j)) continue;\n                if((i&v[j])!=v[j]) ok = false;\n                sum += c[j];\n\t\t\t\t++cnt;\n            }\n            if(ok && sum >= U) ans = min(ans, cnt);\n        }\n        cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        cout<<bfs()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int a[20],b[20];\n    memset(b,0,sizeof(b));\n    for(i=0;i<n;i++){\n      int p;\n      cin>>a[i]>>p;\n      for(j=0;j<p;j++){\n\tint q;\n\tcin>>q;\n\tb[i]|=1<<q;\n      }\n    }\n    int mn=20;\n    for(i=0;i<(1<<n);i++){\n      int sm=0,ct=0;\n      for(j=0;j<n;j++){\n\tif(i&(1<<j)){\n\t  if((i&b[j])==b[j]){\n\t    sm+=a[j];\n\t    ct++;\n\t  }else{\n\t    break;\n\t  }\n\t}\n      }\n      if(j==n&&sm>=m)\n\tmn=min(mn,ct);\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main()\n{\n\tint N,U,K;\n\twhile(cin>>N>>U,N|U){\n\t\tpair<int, vector<int> > piv[N];\n\t\tint ans = INT_MAX;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tcin>>piv[i].first>>K;\n\t\t\tfor(int j=0; j<K; j++){\n\t\t\t\tint a; cin>>a; piv[i].second.push_back(a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<(1<<N); i++){\n\t\t\tint cnt = 0;\n\t\t\tint sum = 0;\n\t\t\tint tmp = 0;\n\t\t\tfor(int j=0; (1<<j)<=i; j++){\n\t\t\t\tif( i&(1<<j) ){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tif( tmp>ans )break;\n\t\t\t\t\tint k;\n\t\t\t\t\tfor(k=0; k<piv[j].second.size(); k++)\n\t\t\t\t\t\tif( !(i&(1<<piv[j].second[k])) )break;\n\t\t\t\t\tif( k==piv[j].second.size() ){\n\t\t\t\t\t\t//printf(\"i:%d  j:%d\\n\",i,j);\n\t\t\t\t\t\tsum += piv[j].first; cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( tmp==cnt && sum>=U && ans>cnt){\n\t\t\t\tans = cnt;\n\t\t\t\t//puts(\"_____ok_____\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] | S) == S){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] < credit_requirement) continue;\n      res = min(bitcount[S],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint points;\n\tvector<int> next_SUBJECT;\n};\n\nstruct Data{\n\tint sum_points,number,subj_num;\n\tshort in_num[20];\n};\n\nint N,need_points,POW[21];\nInfo info[20];\nint first_in_num[20];\nbool LOG[1048576];\n\nvoid copyData(Data& to,Data from){\n\tfor(int i = 0; i < N; i++){\n\t\tto.in_num[i] = from.in_num[i];\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++)info[i].next_SUBJECT.clear();\n\tfor(int i = 0; i < POW[N]; i++)LOG[i] = false;\n\n\tint num,tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\t\tfirst_in_num[i] = num;\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[tmp].next_SUBJECT.push_back(i);\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(first_in_num[i] == 0){\n\t\t\tData new_data;\n\t\t\tfor(int k = 0; k < N; k++)new_data.in_num[k] = first_in_num[k];\n\t\t\tnew_data.subj_num = 1;\n\t\t\tnew_data.sum_points = info[i].points;\n\t\t\tnew_data.number = POW[i];\n\t\t\tLOG[POW[i]] = true;\n\t\t\tfor(int k = 0; k < info[i].next_SUBJECT.size(); k++){\n\t\t\t\tnew_data.in_num[info[i].next_SUBJECT[k]]--;\n\t\t\t}\n\t\t\tQ.push(new_data);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().sum_points >= need_points){\n\t\t\tprintf(\"%d\\n\",Q.front().subj_num);\n\t\t\treturn;\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\t\tif(Q.front().number & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tif(Q.front().in_num[loop] == 0){\n\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\tcopyData(new_data,Q.front());\n\t\t\t\t\t\tnew_data.subj_num = Q.front().subj_num+1;\n\t\t\t\t\t\tnew_data.sum_points = Q.front().sum_points+info[loop].points;\n\t\t\t\t\t\tnew_data.number = Q.front().number+POW[loop];\n\t\t\t\t\t\tif(LOG[new_data.number])continue;\n\t\t\t\t\t\tLOG[new_data.number] = true;\n\t\t\t\t\t\tfor(int k = 0; k < info[loop].next_SUBJECT.size(); k++){\n\t\t\t\t\t\t\tnew_data.in_num[info[loop].next_SUBJECT[k]]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint n, U, a[100], b[100], c;\nvector<int>x[100], p; queue<int>Q;\nint dp[100][1000];\nint dp2[100][1000];\nbool used[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 100; i++) { a[i] = 0; b[i] = 0; used[i] = false; for (int j = 0; j < 1000; j++) { dp[i][j] = 0; dp2[i][j] = 0; }x[i].clear(); }\n\t\tcin >> n >> U; if (n == 0 && U == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tfor (int j = 0; j < b[i]; j++) {\n\t\t\t\tcin >> c; x[c].push_back(i);\n\t\t\t}\n\t\t}\n\t\tQ.push(n);\n\t\tfor (int i = 0; i < n; i++) { if (b[i] == 0)x[n].push_back(i); }\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop(); p.push_back(a1); used[a1] = true;\n\t\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\t\tif (used[x[a1][i]] == false) { Q.push(x[a1][i]); used[x[a1][i]] = true; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 1; j < 1000; j++)dp[i][j] = 100000000;\n\t\t}\n\t\treverse(p.begin(), p.end());\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\tint a1 = p[i];\n\t\t\tfor (int k = 0; k <= x[a1].size(); k++) {\n\t\t\t\tfor (int l = 0; l < 200; l++)dp2[k][l] = 10000000;\n\t\t\t}\n\t\t\tdp2[0][0] = 0;\n\t\t\tfor (int k = 0; k < x[a1].size(); k++) {\n\t\t\t\tfor (int l = 0; l < 200; l++) {\n\t\t\t\t\tif (dp2[k][l] == 10000000)continue;\n\t\t\t\t\tfor (int m = 0; m < 200; m++) {\n\t\t\t\t\t\tdp2[k + 1][l + m] = min(dp2[k + 1][l + m], dp2[k][l] + dp[x[a1][k]][m]);\n\t\t\t\t\t}\n\t\t\t\t\tdp2[k + 1][l] = min(dp2[k + 1][l], dp2[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 200; j++) {\n\t\t\t\tdp[a1][j + a[a1]] = min(dp[a1][j + a[a1]], dp2[x[a1].size()][j] + 1);\n\t\t\t}\n\t\t}\n\t\tint minx = 10000000;\n\t\tfor (int i = U; i < 1000; i++) {\n\t\t\tminx = min(minx, dp[n][i]);\n\t\t}\n\t\tcout << minx - 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int c,nc,ng;\n};\n\nint main(){\n  for(int n,u;cin>>n>>u,n|u;){\n    int ng[20],pr[20]={};\n    for(int i=0;i<n;i++){\n      int k;\n      cin>>ng[i]>>k;\n      while(k--){\n\tint r;\n\tcin>>r;\n\tpr[i]|=1<<r;\n      }\n    }\n    queue<S> que;\n    S is={0,0,0};\n    que.push(is);\n    bool p[1<<20];\n    fill(p,p+(1<<n),false);\n    for(;;){\n      S c=que.front();\n      if(c.ng>=u)break;\n      que.pop();\n      if(p[c.c]++)continue;\n      for(int i=0;i<n;i++){\n\tif(!(c.c&1<<i)&&!(pr[i]&~c.c)){\n\t  S n={c.c|1<<i,c.nc+1,c.ng+ng[i]};\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<que.front().nc<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tvi vis(1<<n);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\t//rep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(vis[b]) continue;\n\t\t\tvis[b]=1;\n\t\t\tint cnt=0,sum=0;\n\t\t\t//rep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\trep(j,n) cnt+=(b>>j&1),sum+=(b>>j&1)*cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n\tNODE(){}\n};\n\n#define INF (1<<21)\nNODE Q[1<<20];\n\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tint h = 0;\n\t\tint qsize = 0;\n\t\tQ[qsize++] = NODE(0,0,0);\n\t\tdone[0] = 1;\n\t\twhile(h != qsize){\n\t\t\tNODE q = Q[h++];\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)])Q[qsize++] = (NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1)) , done[q.a|(1<<i)] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return __builtin_popcount(S) < __builtin_popcount(s.S);\n  }\n  bool operator>(const State& s) const {\n    return __builtin_popcount(S) > __builtin_popcount(s.S);\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s.sum >= credit_requirement) {\n      return __builtin_popcount(s.S);\n    }\n    for(int i = 0; i < total_subjects; i++){\n      if((prior[i] | s.S) == s.S){\n\tif(dp[s.S | (1<<i)] != -1) continue;\n\tdp[s.S | (1<<i)] = s.sum + credit[i];\n\tque.push(State(s.S | (1<<i),s.sum + credit[i]));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n,U;scanf(\"%d%d\",&n,&U),n;){\n\t\tint score[20];\n\t\tbool wf[20][20]={};\n\t\trep(u,n){\n\t\t\tint m; scanf(\"%d%d\",score+u,&m);\n\t\t\trep(i,m){\n\t\t\t\tint v; scanf(\"%d\",&v);\n\t\t\t\twf[v][u]=true;\n\t\t\t}\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) wf[i][j]|=wf[i][k]&wf[k][j];\n\n\t\tint A[20]={};\n\t\trep(u,n) rep(v,n) if(u!=v && wf[v][u]) A[u]|=1<<v;\n\n\t\tint ans=n;\n\t\trep(S,1<<n){\n\t\t\tint pc=0,tot=0;\n\t\t\tbool ok=true;\n\t\t\trep(u,n) if(S&(1<<u)) {\n\t\t\t\tpc++;\n\t\t\t\ttot+=score[u];\n\t\t\t\tif((S&A[u])!=A[u]){ ok=false; break; }\n\t\t\t}\n\t\t\tif(ok && tot>=U) ans=min(ans,pc);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while(!isdigit(g = getchar()));\n  ret = g-'0';\n  while(isdigit(g = getchar())){\n    ret *= 10;\n    ret += g-'0';\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp;\nint c[30],k[30],r[30];\nbool f[30][30];\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++){\n\tif(f[i][j])r[i] |= 1<<j;\n      }\n    }\n\n    int res = 20;\n    for(int i=0;i<(1<<n);i++){\n      tmp = 0;\n      int sum = 0,num = 0;\n      for(int j=0;j<n;j++){\n\tif( (i>>j) &1){\n\t  tmp |= r[j];\n\t  sum += c[j];\n\t  num++;\n\t  if(res<num)break;\n\t}\n      }\n      if(num<res && U<=sum)res = num;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main()\n{\n   int N,U,K;\n   while(cin>>N>>U,N|U){\n      pair<int, int> piv[N];\n      int ans = INT_MAX;\n      for(int i=0; i<N; i++){\n         cin>>piv[i].first>>K;\n         for(int j=0; j<K; j++){\n            int a; cin>>a;\n\t\t\t\tpiv[i].second |= (1<<a);\n         }\n      }\n      for(int i=1; i<(1<<N); i++){\n         int cnt = 0;\n         int sum = 0;\n         int tmp = 0;\n         for(int j=0; (1<<j)<=i; j++){\n            if( i&(1<<j) ){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tif( tmp>N || ans<tmp )break;\n\t\t\t\t\tif( i&piv[j].second != piv[j].second )break;\n\t\t\t\t\tsum += piv[j].first;\n\t\t\t\t\tcnt++;\n            }\n         }\n         if( tmp==cnt && sum>=U && ans>cnt){\n            ans = cnt;\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint points;\n\tvector<int> next_SUBJECT;\n};\n\nstruct Data{\n\tint sum_points,number,subj_num;\n\tshort in_num[20];\n};\n\nint N,need_points,POW[21];\nInfo info[20];\nint first_in_num[20];\n\nvoid copyData(Data& to,Data from){\n\tfor(int i = 0; i < N; i++){\n\t\tto.in_num[i] = from.in_num[i];\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++)info[i].next_SUBJECT.clear();\n\n\tint num,tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\t\tfirst_in_num[i] = num;\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[tmp].next_SUBJECT.push_back(i);\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(first_in_num[i] == 0){\n\t\t\tData new_data;\n\t\t\tfor(int k = 0; k < N; k++)new_data.in_num[k] = first_in_num[k];\n\t\t\tnew_data.subj_num = 1;\n\t\t\tnew_data.sum_points = info[i].points;\n\t\t\tnew_data.number = POW[i];\n\t\t\tfor(int k = 0; k < info[i].next_SUBJECT.size(); k++){\n\t\t\t\tnew_data.in_num[info[i].next_SUBJECT[k]]--;\n\t\t\t}\n\t\t\tQ.push(new_data);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().sum_points >= need_points){\n\t\t\tprintf(\"%d\\n\",Q.front().subj_num);\n\t\t\treturn;\n\t\t}else{\n\n\t\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\t\tif(Q.front().number & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tif(Q.front().in_num[loop] == 0){\n\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\tcopyData(new_data,Q.front());\n\t\t\t\t\t\tnew_data.subj_num = Q.front().subj_num+1;\n\t\t\t\t\t\tnew_data.sum_points = Q.front().sum_points+info[loop].points;\n\t\t\t\t\t\tnew_data.number = Q.front().number+POW[loop];\n\t\t\t\t\t\tfor(int k = 0; k < info[loop].next_SUBJECT.size(); k++){\n\t\t\t\t\t\t\tnew_data.in_num[info[loop].next_SUBJECT[k]]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nint dfs(int used,int depth,int cost) {\n  if(memo[used] >= 0) return memo[used];\n  if(cost >= U) {\n    return memo[used] = depth;\n  }\n\n  int t = 20;\n  for(int i=0; i<n; ++i) {\n    if((used>>i) & 1) continue;\n    if(used & pv[i] != pv[i]) continue;\n    t = min(t,dfs((used|(1<<i)),depth+1,cost+cv[i]));\n  }\n  return memo[used] = t;\n}\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(ns.cost >= U) return ns.depth;\n    for(int i=0; i<n; ++i) {\n      if((ns.used>>i) & 1) continue;\n      if(ns.used & pv[i] != pv[i]) continue;\n      if((memo[ns.used|(1<<i)] >= 0)) continue;\n      memo[ns.used|(1<<i)] = 1;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n,U;scanf(\"%d%d\",&n,&U),n;){\n\t\tint score[20];\n\t\tbool wf[20][20]={};\n\t\trep(u,n){\n\t\t\tint m; scanf(\"%d%d\",score+u,&m);\n\t\t\trep(i,m){\n\t\t\t\tint v; scanf(\"%d\",&v);\n\t\t\t\twf[v][u]=true;\n\t\t\t}\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) wf[i][j]|=wf[i][k]&wf[k][j];\n\n\t\tint A[20]={}; // A[u] := m[h u ÌæcSÌ\n\t\trep(u,n) rep(v,n) if(u!=v && wf[v][u]) A[u]|=1<<v;\n\n\t\tint ans=n;\n\t\tint nn=1<<n;\n\t\trep(S,nn){\n\t\t\tint pc=0,tot=0;\n\t\t\tbool ok=true;\n\t\t\trep(u,n) if(S&(1<<u)) {\n\t\t\t\tpc++;\n\t\t\t\ttot+=score[u];\n\t\t\t\tif((S&A[u])!=A[u]){ ok=false; break; }\n\t\t\t}\n\t\t\tif(ok && tot>=U) ans=min(ans,pc);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\n\nint n,U,c,k,r;\nint credit[20],required[20];\n\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\nint BFS(){\n  bool visited[1<<20]={0};\n  queue<Data>q;\n  Data now={0,0};\n  q.push(now);\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    visited[now.used]=true;\n    if(now.credit>=U)return bitcount(now.used);\n    for(int i=0;i<n;i++){\n      if(!(now.used&(1<<i)) && ((now.used&required[i])==required[i] && !visited[now.used|(1<<i)]))\n\tq.push((Data){now.used|(1<<i), now.credit+credit[i]});\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\trequired[i]^=(1<<r);\n      }\n    }\n    cout<<BFS()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\n\nint numofbits(long bits)\n{\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = ((bits >> 4) + bits) & 0x0f0f0f0f;\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\nint main()\n{\n  int n,U,c,k,r;\n  int credit[20],required[20];\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\trequired[i]^=(1<<r);\n      }\n    }\n\n    bool visited[1<<20]={0};\n    queue<Data>q;\n    Data now={0,0};\n    q.push(now);\n    while(!q.empty()){\n      now=q.front();\n      q.pop();\n      if(visited[now.used])continue;\n      visited[now.used]=true;\n      if(now.credit>=U)\tbreak;\n      for(int i=0;i<n;i++){\n\tif(!(now.used&(1<<i)) && ((now.used&required[i])==required[i]))\n\t  q.push((Data){now.used|(1<<i), now.credit+credit[i]});\n      }\n    }\n    cout<<bitcount(now.used)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,int > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tif(((vpii[i].second)&s)==vpii[i].second){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,int > p;\n\t\t\tp.first=c;\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second|=(1<<t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\nint k,t,cstate,nstate,tu,ckamoku;\nint bitto[1<<20];\nint n,u,ans;\n\nmain(){\n\n  while(scanf(\"%d%d\",&n,&u),n|u){\n    rep(i,n){\n      scanf(\"%d%d\",tani+i,&k);\n      nec[i]=0;\n      rep(j,k){\n\tscanf(\"%d\",&t);\n\tnec[i]|=1<<t;\n      }\n    }\n\n    ans=INT_MAX/2;\n    rep(i,1<<n)app[i]=0;\n    queue<PI> Q;\n    Q.push(mp(0,0));\n\n    while(!Q.empty()){\n      cstate=Q.front().F;\n      ckamoku=Q.front().S;\n      Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      tu=0;\n\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t}\n      }\n\n      if(tu>=u){\n\tans=ckamoku;\n\tbreak;\n      }\n\n      rep(i,n){\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(mp(nstate,ckamoku+1));\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint a[20],b[20][20],c[20],d[1<<20],n,u;\nint fi(int p,int q,int r){\n  int i,j;\n  int mn=1<<30;\n  if(d[p]){\n    if(r>=u){\n      mn=q;\n    }else{\n      for(i=0;i<n;++i){\n\tif(c[i]==0){\n\t  for(j=0;b[i][j]!=-1;++j){\n\t    if(c[b[i][j]]==0){\n\t      p|=1<<b[i][j];\n\t      ++q;\n\t      r+=a[b[i][j]];\n\t    }\n\t    ++c[b[i][j]];    \n\t  }\n\t  mn=min(mn,fi(p|(1<<i),q+1,r+a[i]));\n\t  for(j=0;b[i][j]!=-1;++j){\n\t    --c[b[i][j]];\n\t    if(c[b[i][j]]==0){\n\t      p&=~(1<<b[i][j]);\n\t      --q;\n\t      r-=a[b[i][j]];\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return mn;\n}\nint main(){\n  int i,j;\n  while(cin>>n>>u,n||u){\n    fill(b[0],b[0]+20*20,-1);\n    for(i=0;i<n;++i){\n      cin>>a[i];\n      int m;\n      cin>>m;\n      for(j=0;j<m;++j)\n\tcin>>b[i][j];\n    }\n    fill(c,c+20,0);\n    fill(d,d+(1<<20),-1);\n    cout<<fi(0,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nstruct State{\n  int total,sub,S;\n  State(int total,int sub,int S) : total(total),sub(sub),S(S) {}\n};\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n\n    bool visited[1<<N];\n    memset(visited,false,sizeof(visited));   \n    visited[0] = true;\n    queue<State> Q;\n    Q.push(State(0,0,0));\n    while(!Q.empty()){\n      State now = Q.front(); Q.pop();\n      if(now.total >= U){\n        cout << now.sub << endl;\n        break;\n      }\n      for(int i = 0 ; i < N ; i++){\n        if(now.S >> i & 1) continue;\n        int S = now.S; S |= 1<<i;\n        if(!visited[S] && (S & arr[i] == arr[i])){\n          visited[S] = true;\n          Q.push(State(now.total+c[i],now.sub+1,S));\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Kamoku {\n\tint tani;\n\tint alltani;\n\tint k;\n\tbool calced;\n\tvector<int> need;\n\tset<int> use;\n\tKamoku() : tani(0), k(0), calced(false) {}\n};\n\nvoid dfs(vector<Kamoku> &v, int start) {\n\tif(v[start].calced) return;\n\n\tfor(int i = 0; i < v[start].need.size(); ++i) {\n\t\tv[start].use.insert(v[start].need[i]);\n\t\tdfs(v, v[start].need[i]);\n\t}\n\tfor(int i = 0; i < v[start].need.size(); ++i) {\n\t\tfor(set<int>::iterator it = v[v[start].need[i]].use.begin(); it != v[v[start].need[i]].use.end(); ++it) {\n\t\t\tv[start].use.insert(*it);\n\t\t}\n\t}\n\tv[start].alltani = 0;\n\tv[start].use.insert(start);\n\tfor(set<int>::iterator it = v[start].use.begin(); it != v[start].use.end(); ++it) {\n\t\tv[start].alltani += v[*it].tani;\n\t}\n\tv[start].calced = true;\n}\n\nint main() {\n\twhile(true) {\n\t\tint n, U;\n\t\tcin >> n >> U;\n\t\tif(!n && !U) break;\n\t\tvector<Kamoku> v(n);\n\t\tvector<bool> islast(n, true);\n\t\tvector<int> last;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint c, k;\n\t\t\tcin >> c >> k;\n\t\t\tv[i].tani = c;\n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\tint r;\n\t\t\t\tcin >> r;\n\t\t\t\tv[i].need.push_back(r);\n\t\t\t\tislast[r] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(islast[i]) {\n\t\t\t\tdfs(v, i);\n\t\t\t}\n\t\t}\n\n\t\tint minimum = 10000;\n\t\tint lim = 1<<n;\n\t\tfor(int i = 0; i < lim; ++i) {\n\t\t\tint sum = 0;\n\t\t\tint k = 0;\n\t\t\tvector<bool> used(n, false);\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tif(i & (1<<j)) {\n\t\t\t\t\tsum += v[j].alltani;\n\t\t\t\t\tfor(set<int>::iterator it = v[j].use.begin(); it != v[j].use.end(); ++it) {\n\t\t\t\t\t\tif(used[*it]) continue;\n\t\t\t\t\t\t++k;\n\t\t\t\t\t\tused[*it] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum >= U) {\n\t\t\t\t//if(minimum > k.size()) cout << i << endl;\n\t\t\t\tminimum = min(minimum, (int)k);\n\t\t\t}\n\t\t}\n\t\tcout << minimum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nint best;\nint N, U;\nint tno;\n// char visited[1 << 20];\nvoid dfs(int mask, int one, int have) {\n  if( best <= one ) return;\n  if( have >= U ) {\n    best = one;\n    return;\n  }\n  \n  for(int i = 0; i < N; i++)\n    if ( // visited[mask | (1 << i)] != tno &&\n         (mask | need[i]) == mask )\n      {\n//         visited[mask | (1 << i)] = tno;\n        dfs( mask | (1 << i), one + 1, have + unit[i] );\n      }\n}\n\nint main() {\n  for(tno = 1;; tno++) {\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    best = N;\n    dfs(0, 0, 0);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint solve(int u, vector<int>& unit, vector<bitset<20> > condition)\n{\n    int n = unit.size();\n\n    int ret = INT_MAX;\n    for(int i=0; i<(1<<n); ++i){\n        bitset<20> bs(i);\n        int num = bs.count();\n        if(num >= ret)\n            continue;\n\n        int tmp = 0;\n        bitset<20> bs1;\n        for(int j=0; j<n; ++j){\n            if(bs[j]){\n                tmp += unit[j];\n                bs1 |= condition[j];\n            }\n        }\n        if(tmp < u || (~bs & bs1).any())\n            continue;\n\n        ret = bs.count();\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n, u;\n        cin >> n >> u;\n        if(n == 0)\n            return 0;\n        \n        vector<int> unit(n);\n        vector<bitset<20> > condition(n);\n        for(int i=0; i<n; ++i){\n            cin >> unit[i];\n            int k;\n            cin >> k;\n            for(int j=0; j<k; ++j){\n                int tmp;\n                cin >> tmp;\n                condition[i][tmp] = true;\n            }\n        }\n\n        cout << solve(u, unit, condition) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n\nint popcount32(unsigned int x){\n\tx = (x>>1 & 0x55555555)+(x & 0x55555555);\n\tx = (x>>2 & 0x33333333)+(x & 0x33333333);\n\tx = (x>>4 & 0x0f0f0f0f)+(x & 0x0f0f0f0f);\n\tx = (x>>8 & 0x00ff00ff)+(x & 0x00ff00ff);\n\treturn (x>>16)+(x & 0x0000ffff);\n}\n\nint tanni[20];\nint prelearn[20];\n\nint main(){\n\tint n,u;\n\twhile(cin>>n>>u,n|u){\n\t\tmemset(tanni,0,sizeof(tanni));\n\t\tmemset(prelearn,0,sizeof(prelearn));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,k;\n\t\t\tcin>>c>>k;\n\t\t\ttanni[i]=c;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tprelearn[i]|=1<<r;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tint pop=popcount32(i);\n\t\t\tif(ans<pop)continue;\n\t\t\tbool valid=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((i>>j&1)&&(prelearn[j]&i)!=prelearn[j]){\n\t\t\t\t\tvalid=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!valid)continue;\t\t\t\n\t\t\tint s=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i>>j&1)s+=tanni[j];\n\t\t\t}\n\t\t\tif(u<=s)ans=pop;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nint visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n};\n\nint solve(int N, int U, int tno) {\n  queue<State> up;\n  static State s;\n  s.one = s.mask = s.have = 0;\n  visited[s.mask] = tno;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.front(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] != tno && (s.mask | need[i]) == s.mask )\n        {\n          static State next;\n          next.mask = s.mask | (1 << i);\n          next.one = s.one + 1;\n          next.have = s.have + unit[i];\n          visited[next.mask] = 1;\n          up.push(next);\n        }\n  }\n  return -1;\n}\n\nint main() {\n  for(int tno = 0;;) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U, ++tno);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(ans == 2)\n\t    break;\n\t      \n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  State(){}\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  int next_sum;\n  int next_S;\n  State s;\n  int rest;\n  while(!que.empty()){\n    s = que.top();\n    que.pop();\n    rest = total_subjects - bitcount[s.S];\n    for(int i = 0,j=0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if(j++ > rest) break;\n      if(dp[next_S = (s.S | (1<<i))] != -1) continue;\n\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[next_S] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(next_S,next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n  int used;\n  int credit;\n};\n\nint n,U,c,k,r;\nint credit[20],required[20];\n\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\nint BFS(){\n  bool visited[1<<20]={0};\n  queue<Data>q;\n  Data now={0,0};\n  q.push(now);\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(visited[now.used])continue;\n    visited[now.used]=true;\n    if(now.credit>=U)return bitcount(now.used);\n    for(int i=0;i<n;i++){\n      if(now.used & (1<<i) || (now.used & required[i]) != required[i])continue;\n      Data next=now;\n      next.used^=(1<<i);\n      next.credit+=credit[i];\n      q.push(next);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin>>n>>U,n|U){\n    for(int i=0;i<n;i++){\n      cin>>c>>k;\n      credit[i]=c;\n      required[i]=0;\n      for(int j=0;j<k;j++){\n\tcin>>r;\n\trequired[i]^=(1<<r);\n      }\n    }\n    cout<<BFS()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n\nint popcount32(unsigned int x){\n\tx = (x>>1 & 0x55555555)+(x & 0x55555555);\n\tx = (x>>2 & 0x33333333)+(x & 0x33333333);\n\tx = (x>>4 & 0x0f0f0f0f)+(x & 0x0f0f0f0f);\n\tx = (x>>8 & 0x00ff00ff)+(x & 0x00ff00ff);\n\treturn (x>>16)+(x & 0x0000ffff);\n}\n\nint main(){\n\tint tanni[20];\n\tint prelearn[20];\n\tint n,u;\n\twhile(cin>>n>>u,n|u){\n\t\tmemset(tanni,0,sizeof(tanni));\n\t\tmemset(prelearn,0,sizeof(prelearn));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,k;\n\t\t\tcin>>c>>k;\n\t\t\ttanni[i]=c;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tprelearn[i]|=1<<r;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tint pop=popcount32(i);\n\t\t\tif(ans<=pop)continue;\n\t\t\tint pre=0;\n\t\t\tint s=0;\t\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((i>>j&1)){\n\t\t\t\t\ts+=tanni[j];\n\t\t\t\t\tpre|=prelearn[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( (i&pre)==pre && u<=s)ans=pop;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nbool visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n//   bool operator<(const State& t) const {\n//     if( one != t.one ) return one > t.one;\n//     return have < t.have;\n//   }\n};\n\nint solve(int N, int U) {\n  memset(visited, 0, sizeof(visited));\n  //  priority_queue<State> up;\n  queue<State> up;\n  State s;\n  s.one = 0;\n  s.mask = 0;\n  s.have = 0;\n  visited[s.mask] = 1;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.front(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] == 0 && (s.mask | need[i]) == s.mask )\n        {\n          State next;\n          next.mask = s.mask | (1 << i);\n          next.one = s.one + 1;\n          next.have = s.have + unit[i];\n          visited[next.mask] = 1;\n          up.push(next);\n        }\n  }\n  return -1;\n}\n\nint main() {\n  for(;;) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn pre_num < arg.pre_num;\n\t}\n\tint index,points,pre_num;\n\tvector<int> pre_SUBJECT;\n};\n\nint N,need_points,POW[21];\nInfo info[20];\nint loc[20];\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tinfo[i].index = i;\n\t\tinfo[i].pre_SUBJECT.clear();\n\t}\n\n\tint num,tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\t\tinfo[i].pre_num = num;\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[i].pre_SUBJECT.push_back(tmp);\n\t\t}\n\t}\n\n\tsort(info,info+N);\n\tfor(int i = 0; i < N; i++){\n\t\tloc[info[i].index] = i;\n\t}\n\n\tbool FLG,check[N];\n\tint ans = BIG_NUM,count;\n\n\tfor(int state = 1; state < POW[N]; state++){\n\t\tcount = 0;\n\t\ttmp = 0;\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tcheck[loop] = true;\n\t\t\t\ttmp += info[loop].points;\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tcheck[loop] = false;\n\t\t\t}\n\t\t}\n\t\tif(count >= ans || tmp < need_points)continue;\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(check[i]){\n\t\t\t\tfor(int k = 0; k < info[i].pre_SUBJECT.size(); k++){\n\t\t\t\t\tif(check[loc[info[i].pre_SUBJECT[k]]] == false){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\n\t\tif(FLG){\n\t\t\tans = count;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 20; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tfor( int a,worse; cin>>a>>worse , a|worse ; )\n\t{\n\t\tmap< int , int > m;\n\t\tmap< int , vector<int> > flg;\n\n\t\tfor( int i=0 ; i<a ; i++ )\n\t\t{\n\t\t\tint num1,num2;\n\t\t\tcin>> num1 >> num2;\n\t\t\tm[i] = num1 ;\n\n\t\t\tif( num2 ){\n\t\t\t\tfor( int j=0 ; j<num2 ; j++ ){\n\t\t\t\t\tint before;cin>>before;\n\t\t\t\t\tflg[i].push_back( before );\n\t\t\t\t}\n\t\t\t}\n\t\t\tflg[i].push_back( -1 );\n\t\t}\n\n\t\tint result=0;\n\t\twhile( worse > 0 ){\n\t\t\tint max=0;\n\t\t\tint maxIndex=INT_MAX;\n\n\t\t\tfor( int i=0 ; i<a ; i++ ){\n\t\t\t\tif( flg[i].size() <= 1 ){\n\t\t\t\t\tif( max<m[i] ){ max=m[i]; maxIndex=i; }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor( int i=0 ; i<a ; i++ ){\n\t\t\t\tvector<int>::iterator point=find( flg[i].begin() , flg[i].end() , maxIndex );\n\t\t\t\tif( point != flg[i].end() ){\n\t\t\t\t\tflg[i].erase( point );\n\t\t\t\t}\n\t\t\t}\n\t\t\tworse-=max;\n\t\t\tresult++;\n\t\t\tm[ maxIndex ] = 0;\n\t\t\t//cout << maxIndex << \":\";\n\t\t}\n\t\tcout << endl;\n\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nint c[30];\nint deps[30];\n\nint main() {\n  int n, U;\n  while (scanf(\"%d%d\", &n, &U), n|U) {\n    memset(deps, 0, sizeof(deps));\n    REP(i, n) {\n      int k; scanf(\"%d%d\", &c[i], &k);\n      REP(j, k) {\n        int r; scanf(\"%d\", &r);\n        deps[i] |= 1 << r;\n      }\n    }\n    int ans = n;\n    REP(S, 1<<n) {\n      int bitcount = __builtin_popcount(S);\n      if (bitcount >= ans) { continue; }\n      int sum = 0;\n      REP(i, n) {\n        if (S & (1 << i)) { sum += c[i]; }\n      }\n      if (sum < U) { continue; }\n      bool ok = true;\n      REP(i, n) {\n        if (S & (1 << i)) {\n          if ((S | deps[i]) != S) {\n            ok = false;\n            break;\n          }\n        }\n      }\n      if (ok) { ans = bitcount; }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 20\n\nint n, U;\nint cs[MAX_N];\nint rs[MAX_N];\n\ninline bool check(int S) {\n    // 履修に必要な単位をすべて取得しているか\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            if ((S & rs[i]) != rs[i]) {\n                return false;\n            }\n        }\n    }\n\n    // 総単位数がUを越えているか\n    int unit = 0;\n    for (int i = 0; i < n; i++) {\n        if (S & (1<<i)) {\n            unit += cs[i];\n        }\n    }\n    if (unit < U) return false;\n\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    while (cin >> n >> U, n || U) {\n        memset(cs, 0, sizeof(cs));\n        memset(rs, 0, sizeof(rs));\n        for (int i = 0; i < n; i++) {\n            int c, k, r;\n            cin >> c >> k; r = 0;\n            for (int j = 0; j < k; j++) {\n                int _r; cin >> _r;\n                r |= (1<<_r);\n            }\n            cs[i] = c;\n            rs[i] = r;\n        }\n\n        int ans = (1<<28);\n        for (int S = 1; S < (1<<n); S++) {\n            if (check(S)) {\n                ans = min(ans, __builtin_popcount(S));\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint bitcount[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return bitcount[S] < bitcount[s.S];\n  }\n  bool operator>(const State& s) const {\n    return bitcount[S] > bitcount[s.S];\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nint bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  int next_sum;\n  int next_S;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    int rest = total_subjects - bitcount[s.S];\n    for(int i = 0,j=0; i < total_subjects; i++){\n      if(s.S & (1<<i)) continue;\n      if(j++ > rest) break;\n      if(dp[next_S = (s.S | (1<<i))] != -1) continue;\n\n      if((prior[i] | s.S) == s.S){\n\tnext_sum = s.sum + credit[i];\n\tdp[next_S] = next_sum;\n\n\tif(next_sum >= credit_requirement) {\n\t  return bitcount[s.S] + 1;\n\t}\n\tque.push(State(next_S,next_sum));\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  for(int S = 0; S < (1<<20); S++){\n    bitcount[S] = __builtin_popcount(S);\n  }\n  \n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    \n    printf(\"%d\\n\",bfs());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\t//clock_t t0=clock();\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tvi sums(1<<n);\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t//clock_t t1=clock();\n\t//printf(\"%.3f[s]\\n\",1.*(t1-t0)/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\npair<int,int>q[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)q[i]=make_pair(t[i],g[i]);\n\t\tstd::sort(q,q+a);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tt[i]=q[a-1-i].first;\n\t\t\tg[i]=q[a-1-i].second;\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s!=b)continue;\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<bitset>\n#include<deque>\n#include<algorithm>\nusing namespace std;\n\nstruct Pox\n{\n  int state,cost;\n  Pox(int state,int cost):state(state),cost(cost){}\n};\n\nint main()\n{\n  while(1)\n    {\n      int n,U,k,r;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int mincost[1<<n];\n      for(int i=0;i<(1<<n);i++)\n\tmincost[i] = n;\n      deque<Pox> deq;\n      int G[n];\n      int c[n];\n      for(int i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t    if(!k)\n\t      {\n\t\tdeq.push_back(Pox((1<<i),c[i]));\n\t\tmincost[(1<<i)] = 1;\n\t      }\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n     \n      int ans = n;\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  int num = __builtin_popcount(pox.state);\n\t  if(num >= ans)\n\t    continue;\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((pox.state >> i) & 1)\n\t\tcontinue;\n\t      int pre = G[i];\n\t      pre &= pox.state;\n\t      if(pre != G[i])\n\t\tcontinue;\n\t      if(mincost[pox.state|(1<<i)] <= num+1)\n\t\tcontinue;\n\t      mincost[pox.state|(1<<i)] = num+1;\n\t      if(pox.cost + c[i] < U)\n\t\tdeq.push_back(Pox(pox.state|(1<<i),pox.cost+c[i]));\n\t      else \n\t\tans = min(ans,num+1);\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nvoid dfs(int S,int sum){\n  for(int i = 0; i < total_subjects; i++){\n    if((prior[i] & S) == prior[i]){\n      if(dp[S | (1<<i)] != -1) continue;\n      dp[S | (1<<i)] = sum + credit[i];\n      dfs(S | (1<<i),sum + credit[i]);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    dfs(0,0);\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] < credit_requirement) continue;\n      res = min(res,__builtin_popcount(S));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Kamoku {\n\tint tani;\n\tint alltani;\n\tint k;\n\tbool calced;\n\tvector<int> need;\n\tset<int> use;\n\tKamoku() : tani(0), k(0), calced(false) {}\n};\n\nvoid dfs(vector<Kamoku> &v, int start) {\n\tif(v[start].calced) return;\n\n\tfor(int i = 0; i < v[start].need.size(); ++i) {\n\t\tv[start].use.insert(v[start].need[i]);\n\t\tdfs(v, v[start].need[i]);\n\t}\n\tfor(int i = 0; i < v[start].need.size(); ++i) {\n\t\tfor(set<int>::iterator it = v[v[start].need[i]].use.begin(); it != v[v[start].need[i]].use.end(); ++it) {\n\t\t\tv[start].use.insert(*it);\n\t\t}\n\t}\n\tv[start].alltani = 0;\n\tv[start].use.insert(start);\n\tfor(set<int>::iterator it = v[start].use.begin(); it != v[start].use.end(); ++it) {\n\t\tv[start].alltani += v[*it].tani;\n\t}\n\tv[start].calced = true;\n}\n\nint main() {\n\twhile(true) {\n\t\tint n, U;\n\t\tcin >> n >> U;\n\t\tif(!n && !U) break;\n\t\tvector<Kamoku> v(n);\n\t\tvector<bool> islast(n, true);\n\t\tvector<int> last;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint c, k;\n\t\t\tcin >> c >> k;\n\t\t\tv[i].tani = c;\n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\tint r;\n\t\t\t\tcin >> r;\n\t\t\t\tv[i].need.push_back(r);\n\t\t\t\tislast[r] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(islast[i]) {\n\t\t\t\tdfs(v, i);\n\t\t\t}\n\t\t}\n\n\t\tint minimum = 10000;\n\t\tint lim = 1<<n;\n\t\tfor(int i = 0; i < lim; ++i) {\n\t\t\tint sum = 0;\n\t\t\tset<int> k;\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tif(i & (1<<j)) {\n\t\t\t\t\tsum += v[j].alltani;\n\t\t\t\t\tfor(set<int>::iterator it = v[j].use.begin(); it != v[j].use.end(); ++it) {\n\t\t\t\t\t\tk.insert(*it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum >= U) {\n\t\t\t\t//if(minimum > k.size()) cout << i << endl;\n\t\t\t\tminimum = min(minimum, (int)k.size());\n\t\t\t}\n\t\t}\n\t\tcout << minimum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nchar visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n};\n\nint solve(int N, int U, int tno) {\n  queue<State> up;\n  State s;\n  s.one = s.mask = s.have = 0;\n  visited[s.mask] = tno;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.front(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] != tno && (s.mask | need[i]) == s.mask )\n        {\n          State next;\n          next.mask = s.mask | (1 << i);\n          next.one = s.one + 1;\n          next.have = s.have + unit[i];\n          visited[next.mask] = 1;\n          up.push(next);\n        }\n  }\n  return -1;\n}\n\nint main() {\n  for(int tno = 1;; tno++) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U, tno);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\nbool app[1<<20];\n\nmain(){\n  int n,u;\n\n  while(cin>>n>>u,n|u){\n    rep(i,n){\n      cin>>tani[i];\n      int k;\n      cin>>k;\n      nec[i]=0;\n      rep(j,k){\n\tint t;\n\tcin>>t;\n\tnec[i]|=1<<t;\n      }\n    }\n\n    int ans=INT_MAX/2;\n    memset(app,0,sizeof(app));\n    queue<int> Q;\n    Q.push(0);\n\n    while(!Q.empty()){\n      int cstate=Q.front();Q.pop();\n      if(app[cstate])continue;\n      app[cstate]=true;\n\n      int tu=0,ckamoku=0;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n\n      rep(i,n){\n\n\tif(app[cstate|1<<i])continue;\n\tif((cstate&nec[i])==nec[i]){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nint dfs(int used,int depth,int cost) {\n  if(memo[used] >= 0) return memo[used];\n  if(cost >= U) {\n    return memo[used] = depth;\n  }\n\n  int t = 20;\n  for(int i=0; i<n; ++i) {\n    if((used>>i) & 1) continue;\n    if(used & pv[i] != pv[i]) continue;\n    t = min(t,dfs((used|(1<<i)),depth+1,cost+cv[i]));\n  }\n  return memo[used] = t;\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<dfs(0,0,0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n};\n\n#define INF (1<<21)\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tQ.push(NODE(0,0,0));\n\t\tdone[0] = 1;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)])Q.push(NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\t\tint res = n;\n\t\tif (u == 0)\n\t\t{\n\t\t\tres = 0;\n\t\t\tgoto end;\n\t\t}\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tint i = (1 << bits) - 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbool ng = false;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (i >> j & 1 && i & r[j] != r[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tng = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ng)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t\ts += c[j];\n\t\t\t\tif (s >= u)\n\t\t\t\t{\n\t\t\t\t\tres = bits;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\t// combination\n\t\t\t\tint leastBit = i & -i;\n\t\t\t\tint mostBits = i + leastBit;\n\t\t\t\tint leastSequentialBits = i & ~mostBits;\n\t\t\t\ti = mostBits | ((leastSequentialBits / leastBit) >> 1);\n\t\t\t} while (i < 1 << n);\n\t\t}\nend:\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t{\n\t\t\tbool ng = false;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (i >> j & 1 && i & r[j] != r[j])\n\t\t\t\t{\n\t\t\t\t\tng = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ng)\n\t\t\t\tcontinue;\n\n\t\t\tint s = 0;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (i >> j & 1)\n\t\t\t\t\ts += c[j];\n\t\t\tif (s >= u)\n\t\t\t\tmin_swap(res, popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint unit;\n\tint k;\n\tint end_sub[20];\n} SUBJECT;\n\nint main(void)\n{\n\tunsigned int bit;\n\tSUBJECT sub[20];\n\tint ans;\n\tint u;\n\tint n;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &n, &u);\n\t\t\n\t\tif (!n) break;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d\", &sub[i].unit, &sub[i].k);\n\t\t\tfor (int j = 0; j < sub[i].k; j++){\n\t\t\t\tscanf(\"%d\", &sub[i].end_sub[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = n;\n\t\tfor (bit = 0; bit < 1 << n; bit++){\n\t\t\tint sum;\n\t\t\tint sub_cnt;\n\t\t\t\n\t\t\tsum = sub_cnt = 0;\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tint j;\n\t\t\t\t\n\t\t\t\tif ((bit >> i) & 1 == 1){\n\t\t\t\t\tsub_cnt++;\n\t\t\t\t\tfor (j = 0; j < sub[i].k; j++){\n\t\t\t\t\t\tif ((bit >> sub[i].end_sub[j]) & 1 != 1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j == sub[i].k){\n\t\t\t\t\t\tsum += sub[i].unit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (sum == u){\n\t\t\t\tans = min(ans, sub_cnt);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint nec[20];\nint tani[20];\n\nmain(){\n  int n,u;\n\n  while(cin>>n>>u,n|u){\n    rep(i,n){\n      cin>>tani[i];\n      int k;\n      cin>>k;\n      nec[i]=0;\n      rep(j,k){\n\tint t;\n\tcin>>t;\n\tnec[i]|=1<<t;\n      }\n    }\n\n    int ans=INT_MAX/2;\n    queue<int> Q;\n    set<int> app;\n    Q.push(0);\n    app.insert(0);\n\n    while(!Q.empty()){\n      int cstate=Q.front();Q.pop();\n\n      int tu=0,ckamoku=0;\n      rep(i,n){\n\tif(cstate>>i&1){\n\t  tu+=tani[i];\n\t  ++ckamoku;\n\t}\n      }\n      if(ckamoku>=ans)continue;\n      if(tu>=u){\n\tans=ckamoku;\n\tcontinue;\n      }\n\n      rep(i,n){\n\tif(app.count(cstate|(1<<i)))continue;\n\n\tif((cstate&nec[i])==nec[i]){\n\t  int nstate=cstate;\n\t  nstate|=1<<i;\n\t  Q.push(nstate);\n\t  app.insert(nstate);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n  state ns(0,0,0);;\n  int i;\n\n  while(!Q.empty()) {\n    ns = Q.front(); Q.pop();\n    for(i=0; i<n; ++i) {\n      if((ns.used>>i) & 1\n\t || memo[ns.used|(1<<i)]\n\t || (ns.used & pv[i] != pv[i])) continue;\n      memo[ns.used|(1<<i)] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, 0, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n){\n\t\t\tint b=0;\n\t\t\t//rep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\t//rep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\trep(j,n) cnt+=(b>>j&1),sum+=(b>>j&1)*cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint out_num,points;\n\tbool erased;\n\tvector<int> pre_SUBJECT;\n};\n\nint N,need_points;\nInfo info[21];\n\nvoid func(){\n\n\tfor(int i = 1; i <= N; i++){\n\t\tinfo[i].out_num = 0;\n\t\tinfo[i].erased = false;\n\t\tinfo[i].pre_SUBJECT.clear();\n\t}\n\n\tint num,tmp,SUM = 0;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d %d\",&info[i].points,&num);\n\t\tSUM += info[i].points;\n\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tinfo[i].pre_SUBJECT.push_back(tmp);\n\t\t\tinfo[tmp].out_num++;\n\t\t}\n\t}\n\n\tint ans = N;\n\tint point_MIN,min_index;\n\n\twhile(SUM >= need_points){\n\t\tpoint_MIN = BIG_NUM;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(info[i].erased)continue;\n\n\t\t\tif(info[i].out_num == 0){\n\t\t\t\tif(info[i].points < point_MIN){\n\t\t\t\t\tpoint_MIN = info[i].points;\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo[min_index].erased = true;\n\t\tfor(int i = 0; i < info[min_index].pre_SUBJECT.size(); i++){\n\t\t\tinfo[info[min_index].pre_SUBJECT[i]].out_num--;\n\t\t}\n\t\tSUM -= info[min_index].points;\n\t\tans -= 1;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&need_points);\n\t\tif(N == 0 && need_points == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint prior[21];\nint credit[21];\nint dp[1<<20];\nint total_subjects;\nint credit_requirement;\n\nclass State {\npublic:\n  int S;\n  int sum;\n  bool operator<(const State& s) const {\n    return __builtin_popcount(S) < __builtin_popcount(s.S);\n  }\n  bool operator>(const State& s) const {\n    return __builtin_popcount(S) > __builtin_popcount(s.S);\n  }\n  State(int S,int sum) : S(S),sum(sum) {}\n};\n\nvoid bfs(){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(0,0));\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    dp[s.S] = s.sum;\n    if(s.sum >= credit_requirement) break;\n    for(int i = 0; i < total_subjects; i++){\n      if((prior[i] | s.S) == s.S){\n\tif(dp[s.S | (1<<i)] != -1) continue;\n\tque.push(State(s.S | (1<<i),s.sum + credit[i]));\n      }\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_subjects,&credit_requirement)){\n    if(total_subjects == 0 && credit_requirement == 0) break;\n    memset(dp,-1,sizeof(dp));\n    memset(prior,0,sizeof(prior));\n\n    for(int subject_i = 0; subject_i < total_subjects; subject_i++){\n      int prior_subject_num;\n      scanf(\"%d %d\",&credit[subject_i],&prior_subject_num);\n      for(int subject_j = 0; subject_j < prior_subject_num; subject_j++){\n\tint subject_code;\n\tscanf(\"%d\",&subject_code);\n\tprior[subject_i] |= (1<<subject_code);\n      }\n    }\n    bfs();\n    int res = INF;\n    for(int S = 0; S < (1<<total_subjects); S++){\n      if(dp[S] < credit_requirement) continue;\n      res = min(res,__builtin_popcount(S));\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvoid dfs(const vvi& g,int u,vi& vis)\n{\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int v:g[u]) dfs(g,v,vis);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\tvi vis(n);\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tfill(all(vis),0);\n\t\t\trep(j,n) if((i>>j&1) && !vis[j]) dfs(g,j,vis);\n\t\t\tint cnt=0,sum=0;\n\t\t\trep(j,n) if(vis[j]) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\ttni += ((!(i & (1<<j))-1) & c[j]);\n\tok |= !((i & (1<<j)) & ((i & r[j]) ^ r[j]));\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint n,U,tmp;\nint c[30],k[30],r[30];\nbool f[30][30];\nint dp[1<<21],cost[1<<21];\n\nint rec(int bit){\n  if(dp[bit]>=0)return dp[bit];\n  if(cost[bit]>=U)return dp[bit] = __builtin_popcount(bit);\n  int res = 20;\n  for(int i=0;i<n;i++){\n    if( !( (bit>>i) &1 ) ){\n      int next = bit | r[i];\n      if(cost[next]<U)res = min(res,rec(next) );\n      else res = dp[next] = min(res,__builtin_popcount(next));\n    }\n  }\n  return dp[bit] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)f[i][j] = (i-j)?false:true;\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tf[i][tmp] = true;\n      }\n    }\n\n    for(int i=0;i<(1<<n);i++){\n      dp[i] = -1;\n      cost[i] = 0;\n      for(int j=0;j<n;j++)\n\tif( (i>>j)& 1)cost[i] += c[j];\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)f[i][j] |= f[i][k] && f[k][j];\n\n    for(int i=0;i<n;i++){\n      r[i] = 0;\n      for(int j=0;j<n;j++)\n\tif(f[i][j])r[i] |= 1<<j;\n    }\n\n    printf(\"%d\\n\",rec(0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nint memo[1<<20];\n\nstruct state {\n  int used,cost,depth;\n  state(int used,int depth,int cost) : used(used), depth(depth), cost(cost) {;}\n};\n\nint bfs() {\n  queue<state> Q;\n  Q.push(state(0,0,0));\n\n  while(!Q.empty()) {\n    state ns = Q.front(); Q.pop();\n    if(ns.cost >= U) return ns.depth;\n    for(int i=0; i<n; ++i) {\n      if((ns.used>>i) & 1) continue;\n      if(ns.used & pv[i] != pv[i]) continue;\n      if((memo[ns.used|(1<<i)] >= 0)) continue;\n      memo[ns.used|(1<<i)] = 1;\n      if(ns.cost+cv[i] >= U) return ns.depth+1;\n      Q.push(state((ns.used|(1<<i)),ns.depth+1,ns.cost+cv[i]));\n    }\n  }\n}\n\nint main() {\n  int i,j,k,c,r,tmp;\n  while(cin>>n>>U, n|U) {\n    cv.clear();\n    pv.clear();\n    pv.resize(n);\n    memset(memo, -1, sizeof(memo));\n\n    rep(i,n) {\n      cin>>c>>k;\n      cv.push_back(c);\n      tmp = 0;\n      rep(j,k) {\n\tcin>>r;\n\ttmp |= (1<<r);\n      }\n      pv[i] = tmp;\n    }\n\n    cout<<bfs()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nstruct State{\n  int total,sub,S;\n  State(int total,int sub,int S) : total(total),sub(sub),S(S) {}\n};\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n\n    bool visited[1<<N];\n    memset(visited,false,sizeof(visited));   \n    visited[0] = true;\n    queue<State> Q;\n    Q.push(State(0,0,0));\n    while(!Q.empty()){\n      State now = Q.front(); Q.pop();\n      if(now.total >= U){\n        cout << now.sub << endl;\n        break;\n      }\n      for(int i = 0 ; i < N ; i++){\n        if(now.S >> i & 1) continue;\n        int S = now.S; S |= 1<<i;\n        if(!visited[S] && (!arr[i] || S & arr[i] == arr[i])){\n          visited[S] = true;\n          Q.push(State(now.total+c[i],now.sub+1,S));\n        }\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> cv,pv;\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n        cv.clear();\n        pv.clear();\n        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        cout<<bfs()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi bs(n);\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\trep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi bs(n);\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\tif(__builtin_popcount(b)>=res) continue;\n\t\t\trep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n\nint popcount32(unsigned int x){\n\tx = (x>>1 & 0x55555555)+(x & 0x55555555);\n\tx = (x>>2 & 0x33333333)+(x & 0x33333333);\n\tx = (x>>4 & 0x0f0f0f0f)+(x & 0x0f0f0f0f);\n\tx = (x>>8 & 0x00ff00ff)+(x & 0x00ff00ff);\n\treturn (x>>16)+(x & 0x0000ffff);\n}\n\nint main(){\n\tint tanni[20];\n\tint prelearn[20];\n\tint n,u;\n\twhile(cin>>n>>u,n|u){\n\t\tmemset(tanni,0,sizeof(tanni));\n\t\tmemset(prelearn,0,sizeof(prelearn));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,k;\n\t\t\tcin>>c>>k;\n\t\t\ttanni[i]=c;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint r;\n\t\t\t\tcin>>r;\n\t\t\t\tprelearn[i]|=1<<r;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tint pop=popcount32(i);\n\t\t\tif(ans<=pop)continue;\n\t\t\tint pre=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tpre|=(i>>j&1)*prelearn[j];\n\t\t\t}\n\t\t\tif((i&pre)!=pre)continue;\n\t\t\tint s=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\ts+=(i>>j&1)*tanni[j];\n\t\t\t}\n\t\t\tif(u<=s)ans=pop;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\npair<int,int>p[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)p[i]=make_pair(t[i],g[i]);\n\t\tstd::sort(p,p+a);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tt[i]=p[a-1-i].first;\n\t\t\tg[i]=p[a-1-i].second;\n\t\t}\n\t\tint sum=0;\n\t\tfor(int i=0;i<a;i++)sum+=t[i];\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=sum;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}else{\n\t\t\t\t\ts-=t[j];\n\t\t\t\t\tif(s<b){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint tani[21];\nint needs[21];\n\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\n// s«æ\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\telse if(sum>=U){\n\t\tdp[s]=0;\n\t\treturn dp[s];\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\t//bool used[21];\n\t\t//for(int i = 0; i < n; i++){\n\t\t//\tif((s>>i)&1)\n\t\t//\t\tused[i]=true;\n\t\t//}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\t//for(int i = 0; i < tos[s].size(); i++){\n\t\t//\tminCost=min(minCost,dfs(s|(1<<(tos[s][i])),sum+tani[tos[s][i]])+1);\n\t\t//\tif(minCost==1)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+tani[i])+1);\n\t\t\t\t\tif(minCost==1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t//\tif(!used[vpii[i].second[j]]){\n\t\t\t\t//\t\tf=true;\n\t\t\t\t//\t\tbreak;\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t\t//if(!f)\n\t\t\t\t//\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\tint c,k;\n\tint t;\n\tint tn;\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tfill(dp,dp+(1<<20),-1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>tani[i]>>k;\n\t\t\tneeds[i]=0;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tcin>>t;\n\t\t\t\tneeds[i]|=(1<<t);\n\t\t\t}\n\t\t}\n\t\t//for(int s = 0; s < (1<<n); s++){\n\t\t//\tfor(int i = 0; i < n; i++){\n\t\t//\t\tif(!((s>>i)&1)){\n\t\t//\t\t\tif(((needs[i])&s)==needs[i]){\n\t\t//\t\t\t\ttos[s].push_back(i);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\tcout<<dfs(0,0)<<endl;\n\t\t//for(int i = 0; i < (1<<n); i++)\n\t\t//\ttos[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n, U;\n  while(scanf(\"%d%d\",&n,&U), n||U) {\n    int bitmask[n];\n    int c[n];\n    memset(bitmask,0,sizeof(bitmask));\n    REP(i,n) {\n      int k;\n      scanf(\"%d%d\",c+i, &k);\n      REP(j,k) {\n        int r;\n        scanf(\"%d\",&r);\n        bitmask[i] |= 1<<r;\n      }\n    }\n    if (U==0) {                 // ツつ「ツづゥツつゥツ不ツ鳴セ\n      printf(\"%d\\n\",0);\n      continue;      \n    }\n    bool ok = 0;\n    int res = 0;\n    for (int k=1; k<=n; ++k) {\n      int S = (1<<k)-1;\n      while(S<1<<n) {\n        int sum = 0;\n        bool dame = 0;\n        REP(i,k) {\n          if (S>>i&1) {\n            if (S&bitmask[i] != bitmask[i]) {\n              dame = 1;\n              break;\n            }\n            sum += c[i];\n          }\n        }\n        if (!dame && sum >= U) {\n          ok = 1;\n          res = k;\n          break;\n        }\n        int x = S&-S, y=S+x;\n        S = ((S & ~y) / x >> 1) | y;\n      }\n      if (ok) break;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntemplate <unsigned T>\nbool nextBitset(bitset<T> &bs, int digit)\n{\n    bitset<T> x, y, z;\n    x = bs.to_ulong() & (~(bs.to_ulong()) + 1ULL);\n    y = bs.to_ulong() + x.to_ulong() + 0ULL;\n    z = bs & ~y;\n    if(bs[digit-1] && bs == z)\n        return false;\n    bs = ((z.to_ulong() / x.to_ulong()) >> 1) + 0ULL;\n    bs |= y;\n    return true;\n}\n\nint solve(int u, vector<int>& unit, vector<bitset<20> > condition)\n{\n    int n = unit.size();\n\n    int a = 1;\n    int b = n;\n    while(a < b){\n        int c = (a + b) / 2;\n        bitset<20> bs((1<<c)-1);\n        bool ok = false;\n        do{\n            int tmp = 0;\n            bitset<20> bs1;\n            for(int j=0; j<n; ++j){\n                if(bs[j]){\n                    tmp += unit[j];\n                    bs1 |= condition[j];\n                }\n            }\n            if(tmp < u || (~bs & bs1).any())\n                continue;\n            b = c;\n            ok = true;\n            break;\n        }while(nextBitset(bs, n));\n\n        if(!ok)\n            a = c + 1;\n    }\n\n    return a;\n}\n\nint main()\n{\n    for(;;){\n        int n, u;\n        cin >> n >> u;\n        if(n == 0)\n            return 0;\n        \n        vector<int> unit(n);\n        vector<bitset<20> > condition(n);\n        for(int i=0; i<n; ++i){\n            cin >> unit[i];\n            int k;\n            cin >> k;\n            for(int j=0; j<k; ++j){\n                int tmp;\n                cin >> tmp;\n                condition[i][tmp] = true;\n            }\n        }\n\n        cout << solve(u, unit, condition) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint need[30];\nint tani[30];\n\nint main() {\n  int n, u;\n  for (;;) {\n    cin >> n >> u;\n    if (n == 0 && u == 0) break;\n    rep (i, n) {\n      int k;\n      cin >> tani[i] >> k;\n      int bit = 0;\n      rep (j, k) {\n\tint r;\n\tcin >> r;\n\tbit |= 1 << r;\n      }\n      need[i] = bit;\n    }\n    int res = n;\n    rep (bit, 1 << n) {\n      int koma = __builtin_popcount(bit);\n      if (res <= koma) continue;\n      int sum = 0;\n      rep (i, n) if (bit & 1 << i) {\n\tif ((bit & need[i]) != need[i]) goto aaa;\n\tsum += tani[i];\n      }\n      if (sum < u) continue;\n      res = koma;\n    aaa:;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\n// vector<int> cv,pv;\nint cv[20], pv[20];\nint n,U;\n\nbool visited[1<<20];\n\nstruct state {\n  int used,cost;\n  state(int used,int cost) : used(used), cost(cost) {;}\n};\n\nint pop(int x) {\n  int n = 0;\n  while(x != 0) {\n    n++;\n    x &= (x-1);\n  }\n  return n;\n}\n\nint bfs() {\n    queue<state> Q;\n    Q.push(state(0,0));\n    int i;\n\n    while(!Q.empty()) {\n        state ns = Q.front(); Q.pop();\n        if(visited[ns.used]) continue;\n        if(ns.cost >= U) {\n            return pop(ns.used);\n        }\n\n        visited[ns.used] = 1;\n\n        for(i=0; i<n; ++i) {\n            if(!(ns.used&(1<<i)) && (ns.used & pv[i])==pv[i]) {\n                Q.push( state(ns.used|(1<<i), ns.cost+cv[i]) );\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int i,j,k,c,r,tmp;\n    while(cin>>n>>U, n|U) {\n//        cv.clear();\n//        pv.clear();\n//        pv.resize(n);\n\n        memset(visited, false, sizeof(visited));\n        rep(i,n) {\n            cin>>c>>k;\n            cv[i] = c;\n//            cv.push_back(c);\n            tmp = 0;\n            rep(j,k) {\n                cin>>r;\n                tmp |= (1<<r);\n            }\n            pv[i] = tmp;\n        }\n\n        cout<<bfs()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nvector<int> vec,v[MAX],a[MAX];\n\nvoid init(int N){\n  vec.clear();\n  for(int i = 0 ; i < MAX ; i++){\n    v[i].clear();\n  }\n  for(int i = 1 ; i < 1<<N ; i++){\n    int idx = __builtin_popcount(i);\n    v[idx-1].push_back(i);\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < (int)v[i].size() ; j++){\n      vec.push_back(v[i][j]);\n    }\n  }\n}\n\nint main(){\n  int N,U,c[MAX],k,r;\n  bool used[MAX] = {false};\n\n  while(cin >> N >> U, (N | U)){\n    if(!used[N-1]){\n      init(N);\n      a[N-1] = vec;\n      used[N-1] = true;\n    }else{\n      vec = a[N-1];\n    }\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF;\n    for(int i = 0 ; i < (int)vec.size() ; i++){\n      int S = vec[i];\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int j = 0 ; j < N ; j++){\n        if(S >> j & 1){\n          if(arr[j] == 0 || S & arr[j] == arr[j]){\n            cnt += c[j]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(flg && cnt >= U){\n        if(total < ans){\n          ans = total;\n          break;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nbool visited[1 << 20];\n\nstruct State {\n  int one, mask, have;\n  bool operator<(const State& t) const {\n    if( one != t.one ) return one > t.one;\n    return have < t.have;\n  }\n};\n\nint solve(int N, int U) {\n  memset(visited, 0, sizeof(visited));\n  priority_queue<State> up;\n  State s;\n  s.one = 0;\n  s.mask = 0;\n  s.have = 0;\n  visited[s.mask] = 1;\n  up.push(s);\n  while( !up.empty() ) {\n    s = up.top(); up.pop();\n\n    if( s.have >= U ) return s.one;\n\n    for(int i = 0; i < N; i++)\n      if ( visited[s.mask | (1 << i)] == 0 && (s.mask | need[i]) == s.mask )\n        {\n          State next;\n          next.mask = s.mask | (1 << i);\n          next.one = s.one + 1;\n          next.have = s.have + unit[i];\n          visited[next.mask] = 1;\n          up.push(next);\n        }\n  }\n  return -1;\n}\n\nint main() {\n  for(;;) {\n    int N, U;\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    int best = solve(N, U);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(ans == 2)\n\t    break;\n\t  else if(ans == 3)\n\t    break;\n\t  else if(ans == 4)\n\t    break;\n\t  else if(ans == 5)\n\t    break;\n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N, U;\n        cin >> N >> U;\n        if(!N && !U) break;\n\n        vector<int> need_mask(N, 0);\n        vector<int> value(N, 0);\n        for(int i = 0; i < N; ++i) {\n            int K;\n            cin >> value[i] >> K;\n            int mask = 0;\n            while(K--) {\n                int R;\n                cin >> R;\n                mask |= (1<<R);\n            }\n            need_mask[i] = mask;\n        }\n        while(true) {\n            bool update = false;\n            for(int i = 0; i < N; ++i) {\n                int tmp = need_mask[i];\n                for(int j = 0; j < N; ++j) {\n                    if(need_mask[i] & (1<<j)) {\n                        tmp |= need_mask[j];\n                    }\n                }\n                if(tmp != need_mask[i]) {\n                    need_mask[i] = tmp;\n                    update = true;\n                }\n            }\n            if(!update) break;\n        }\n        vector<int> seen(1<<N, 0);\n        int ans = N;\n        for(int pattern = 0; pattern < (1<<N); ++pattern) {\n            if(seen[pattern]) continue;\n            int pat = pattern;\n            for(int pos = 0; pos < N; ++pos) {\n                if(pattern & (1<<pos)) {\n                    pat |= need_mask[pos];\n                }\n            }\n            if(seen[pat]) continue;\n\n            int sum = 0;\n            for(int pos = 0; pos < N; ++pos) {\n                if(pat & (1<<pos)) sum += value[pos];\n            }\n            if(sum >= U) {\n                ans = min(ans, __builtin_popcount(pat));\n            }\n            seen[pat] = 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {\n  int r = 0, ch;\n  while( isspace(ch = getchar()));\n  do {\n    r = r * 10 + ch - '0';\n  }while( isdigit( ch = getchar() ) );\n  return r;\n}\n\nint main() {\n  for(;;) {\n    int N, U;\n    scanf(\"%d%d\", &N, &U);\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      scanf(\"%d\", &unit[i]);\n      all += unit[i];\n\n      int K; scanf(\"%d\", &K);\n      REP(k, K) {\n        int x; scanf(\"%d\", &x);\n        need[i] |= (1 << x);\n      }\n    }\n\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n\n    int best = N;\n    for(int mask = 0; mask < 1 << N; mask++) {\n      int one = __builtin_popcount(mask);\n      if( best <= one ) continue;\n\n      int have = 0;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) have += unit[k];\n      if( have < U ) continue;\n\n      bool can = true;\n      for(int k = 0; k < N; k++) if( mask & (1 << k) ) {\n          if( (mask | (need[k])) != mask ) {\n            can = false;\n            break;\n          }\n        }\n\n      if( can )\n        best =one;\n    }\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi G(n);\n\t\tvi co(n);\n\t\trep(i,n){\n\t\t\tint b;\n\t\t\tcin>>co[i]>>b;\n\t\t\trep(j,b){\n\t\t\t\tint c;cin>>c;\n\t\t\t\tG[i].pb(c);\n\t\t\t}\n\t\t}\n\t\tint N=1<<n,out=inf;\n\t\tvi dp(n);\n\t\trep(i,n)rep(j,G[i].size())dp[i]|=1<<G[i][j];\n\t\trep(i,N){\n\t\t\tint sum=0,c=0;\n\t\t\trep(j,n)if(i&1<<j){\n\t\t\t\tsum+=co[j];\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(sum>=m&&c<out){\n\t\t\t\trep(j,n)if(i&dp[j]!=dp[j])goto end;\n\t\t\t\tout=c;\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tclock_t t0=clock();\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tvi sums(1<<n);\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\tclock_t t1=clock();\n\tprintf(\"%.3f[s]\\n\",1.*(t1-t0)/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0 | g>9);\n  ret = g;\n  while((g = getchar() - '0'), g>=0 & g<=9){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i=0;i<(int)(N);++i)\n\nint unit[20];\nint need[20];\n\nint nextInt() {int r = 0, ch; while( isspace(ch = getchar())); do {r = r * 10 + ch - '0';}while( isdigit( ch = getchar() ) ); return r;}\n\nint best;\nint N, U;\nint tno;\nint visited[1 << 20];\nvoid dfs(int mask, int one, int have) {\n  if( best <= one ) return;\n  if( have >= U ) {\n    best = one;\n    return;\n  }\n  for(int i = 0; i < N; i++)\n    if ( visited[mask | (1 << i)] != tno && (mask | need[i]) == mask )\n      {\n        visited[mask | (1 << i)] = tno;\n        dfs( mask | (1 << i), one + 1, have + unit[i] );\n      }\n}\n\nint main() {\n  for(tno = 1;; tno++) {\n    N = nextInt();\n    U = nextInt();\n    if( N == 0 && U == 0 ) break;\n    REP(i, N) need[i] = 0;\n\n    int all = 0;\n    REP(i, N) {\n      unit[i] = nextInt();\n      all += unit[i];\n      int K = nextInt();\n      REP(k, K) {\n        int x = nextInt();\n        need[i] |= (1 << x);\n      }\n    }\n    if( all == U ) {\n      printf(\"%d\\n\", N);\n      continue;\n    }\n    best = N;\n    dfs(0, 0, 0);\n    printf(\"%d\\n\", best);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi bs(n);\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\tper(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\tif(__builtin_popcount(i)>=res) continue;\n\t\t\trep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF,num = 1<<(N+1),mini = INF;\n    for(int S = 0 ; S < 1<<N ; S++){\n      int cnt = 0, total = 0;\n      bool flg = true;\n      if(num & S == num) continue;\n      for(int i = 0 ; i < N ; i++){\n        if(S >> i & 1){\n          if(S & arr[i] == arr[i]){\n            cnt += c[i]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(mini < total) break;\n      if(flg && cnt >= U){\n        if(total < ans){\n          num = S;\n          ans = total;\n          mini = total;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass St{\npublic:\n  St() {}\n  St(int _pt, vector<int> _v): pt(_pt), v(_v) {}\n\n  int pt;\n  vector<int> v;\n};\n\nint n, u, res;\nvector<St> vec;\nbool used[21];\n\nbool check(vector<int> v)\n{\n  bool f = true;\n  for(int i = 0; i < v.size(); ++i)\n    f = (f && !used[v[i]]);\n\n  return f;\n}\n\nvoid func(int cnt, int sm)\n{\n  if(sm >= u){\n    res = min(cnt, res);\n    return ;\n  }\n  if(res <= cnt) return;\n\n  for(int i = 0; i < n; ++i)\n    if(used[i] && check(vec[i].v)){\n      used[i] = false;\n      func(cnt+1, sm+vec[i].pt);\n      used[i] = true;\n    }\n}\n\nint main()\n{\n  int s, t;\n  vector<int> tmp;\n\n  while(cin>>n>>u && n+u){\n    fill(used, used+21, true);\n    res = 21;\n\n    for(int i = 0; i < n; ++i){\n      cin >> t >> s;\n      if(s){\n        tmp = vector<int>(s);\n        for(int i = 0; i < s; ++i) cin >> tmp[i];\n      }\n      vec.push_back(St(t, tmp));\n      tmp.clear();\n    }\n\n    func(0, 0);\n    cout << res << endl;\n    vec.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n\tNODE(){}\n};\n\nNODE Q[65536];\nint qsize;\n#define INF (1<<21)\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tqsize = 0;\n\t\tQ[qsize++] = NODE(0,0,0);\n\t\tdone[0] = 1;\n\t\twhile(qsize){\n\t\t\tNODE q = Q[--qsize];\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)]){\n\t\t\t\t\t\tQ[qsize++] = NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1);\n\t\t\t\t\t\tdone[q.a|(1<<i)] = true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvoid dfs(const vvi& g,int u,vi& vis)\n{\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int v:g[u]) dfs(g,v,vis);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n){\n\t\t\tvi vis(n);\n\t\t\trep(j,n) if((i>>j&1) && !vis[j]) dfs(g,j,vis);\n\t\t\tint cnt=0,sum=0;\n\t\t\trep(j,n) if(vis[j]) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\t\tif (u == 0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tint i = (1 << bits) - 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((i & r[j]) != r[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts += c[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\t//int s = 0;\n\t\t\t\t\t//for (int j = 0; j < n; ++j)\n\t\t\t\t\t//\tif (i >> j & 1)\n\t\t\t\t\t//\t\ts += c[j];\n\t\t\t\t\tif (s >= u)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = bits;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// combination\n\t\t\t\tint leastBit = i & -i;\n\t\t\t\tint mostBits = i + leastBit;\n\t\t\t\tint leastSequentialBits = i & ~mostBits;\n\t\t\t\ti = mostBits | ((leastSequentialBits / leastBit) >> 1);\n\t\t\t} while (i < 1 << n);\n\t\t}\nend:\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\t//clock_t t0=clock();\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\t\t\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t//clock_t t1=clock();\n\t//printf(\"%.3f[s]\\n\",1.*(t1-t0)/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main()\n{\n   int N,U,K;\n   while(cin>>N>>U,N|U){\n      pair<int, int> piv[N];\n      int ans = INT_MAX;\n      for(int i=0; i<N; i++){\n         cin>>piv[i].first>>K;\n         for(int j=0; j<K; j++){\n            int a; cin>>a;\n\t\t\t\tpiv[i].second |= (1<<a);\n         }\n      }\n      for(int i=1; i<(1<<N); i++){\n         int cnt = 0;\n         int sum = 0;\n         int tmp = 0;\n         for(int j=0; (1<<j)<=i; j++){\n            if( i&(1<<j) ){\n\t\t\t\t\ttmp++;\n\t\t\t\t\tif( tmp>N || ans<tmp )break;\n\t\t\t\t\tif( i&piv[j].second != piv[j].second )break;\n\t\t\t\t\tsum += piv[j].first;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tif( sum>=U )break;\n            }\n         }\n         if( tmp==cnt && sum>=U && ans>cnt){\n            ans = cnt;\n         }\n      }\n      printf(\"%d\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:45~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi bs(n);\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n){\n\t\t\tint b=0;\n\t\t\trep(j,n) if(i>>j&1) b|=bs[j];\n\t\t\tint cnt=0,sum=0;\n\t\t\trep(j,n) if(b>>j&1) cnt++,sum+=cs[j];\n\t\t\tif(sum>=m) res=min(res,cnt);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint n, U, a[100], b[100], c;\nvector<pair<int, int>>vec2;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> U; if (n == 0 && U == 0)break; vec2.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tfor (int j = 0; j < b[i]; j++) { cin >> c; vec2.push_back(make_pair(c, i)); }\n\t\t}\n\t\tint minx = 100000000;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint sum = 0, cnt = 0; vector<int>vec;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 0)vec.push_back(j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < vec.size(); j++)sum += a[vec[j]]; cnt = vec.size();\n\t\t\tif (sum < U || minx <= cnt)continue;\n\t\t\tbool r[20]; for (int j = 0; j < n; j++)r[j] = false;\n\t\t\tfor (int j = 0; j < vec.size(); j++)r[vec[j]] = true;\n\t\t\tbool flag2 = false;\n\t\t\tfor (int j = 0; j < vec2.size(); j++) {\n\t\t\t\tif (r[vec2[j].first] == false && r[vec2[j].second] == true) {\n\t\t\t\t\tflag2 = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag2 == false)minx = min(minx, cnt);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int i = 0, until = 1 << n; i < until; ++i)\n\t\t{\n\t\t\tbool ng = false;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (i >> j & 1 && i & r[j] != r[j])\n\t\t\t\t{\n\t\t\t\t\tng = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ng)\n\t\t\t\tcontinue;\n\n\t\t\tint s = 0;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (i >> j & 1)\n\t\t\t\t\ts += c[j];\n\t\t\tif (s >= u)\n\t\t\t\tmin_swap(res, popcount(i));\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n#define INF (1<<29)\ntypedef pair<int,int> P;\n\nP u[MAX];\nint unit[MAX],N,U,ucnt;\nvector<int> vec[MAX];\n\nint Cnt(int cur){\n  int sum = 0;\n  ucnt += vec[cur].size();\n  if(vec[cur].size() == 0) return unit[cur];\n  for(int i = 0 ; i < (int)vec[cur].size() ; i++){\n    if(unit[vec[cur][i]] == INF) return -1;\n    sum += Cnt(vec[cur][i]);\n  }\n  return sum;\n}\n\nint solve(int cur,int sum,int num){\n  if(sum >= U) return num;\n  if(cur == N) return INF;\n  int res = INF;\n  for(int i = 0 ; i < N ; i++){\n    res = min(solve(cur+1,sum,num),solve(cur+1,sum+u[i].first,num+u[i].second));\n  }\n  return res;\n}\n\nint main(){\n  int K,in;\n  bool used[MAX];\n  while(cin >> N >> U, (N | U)){\n    memset(used,false,sizeof(used));\n    for(int i = 0 ; i < N ; i++){\n      vec[i].clear();\n    }\n    for(int i = 0 ; i < N ; i++){\n      cin >> unit[i] >> K;\n      for(int j = 0 ; j < K ; j++){\n        cin >> in;\n        vec[i].push_back(in);\n      }\n      if(K == 0) u[i] = P(unit[i],1), used[i] = true;\n    }\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < N ; j++){\n        if(!used[j] || vec[j].size()){\n          ucnt = 1;\n          int cnt = Cnt(j);\n          if(cnt != -1){\n            used[j] = true;\n            u[j] = P(cnt,ucnt);\n          }\n        }\n      }\n    }\n    cout << solve(0,0,0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\nint deg[1<<20];\nint c[20];\nint need[20];\n\nint bitscount(int n){\n  int res = 0;\n  while(n){\n    res++;\n    n -= (n & -n);\n  }\n  return res;\n}\n\nint main(){\n  int n, U, k,r;\n  while(cin >> n >> U && (n || U)){\n    memset(deg, -1, sizeof(deg));\n    memset(need, 0, sizeof(need));\n    int res = INF;\n    rep(i, n){\n      cin >> c[i] >> k;\n      rep(j, k){\n\tcin >> r;\n\tneed[i] |= (1 << r);\n      }\n    }\n    deg[0] = 0;\n    rep(i, (1 << n)){\n      if(deg[i] == -1) continue;\n      if(deg[i] >= U){\n\tres = min(res, bitscount(i));\n\tcontinue;\n      }\n      rep(j, n){\n\tif(!(i & (1 << j)) && ((i & need[j]) == need[j])){\n\t  deg[i|(1<<j)] = c[j] + deg[i];\n\t}\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,U;\n  int c[30],k[30],r[30][30];\n\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(int j=0;j<k[i];j++)scanf(\"%d\",&r[i][j]);\n    }\n\n    int res = n;\n    for(int i=0;i<(1<<n);i++){\n      int num = __builtin_popcount(i), sum = 0;\n      if(res <= num)continue;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 )sum += c[j];\n      }\n      if(sum<U)continue;\n\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif( (i>>j)&1 ){\n\t  for(int l=0;l<k[j];l++){\n\t    f &= (i>>r[j][l])&1;\n\t    if(!f)break;\n\t  }\n\t  if(!f)break;\n\t}\n      }\n      if(f && U<=sum)res = min(res,num);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[21];\nint t[21];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tg[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint c;scanf(\"%d%d\",t+i,&c);\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tg[i]+=1<<d;\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<(1<<a);i++){\n\t\t\tint q=__builtin_popcount(i);\n\t\t\tif(ret<=q)continue;\n\t\t\tint s=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\ts+=t[j];\n\t\t\t\t\tif((i&g[j])!=g[j]){ok=false;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s<b)ok=false;\n\t\t\tif(ok)ret=q;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nint c[20], v[20];\nint visit[1 << 20];\nint ans;\nint n, U;\n\nvoid dfs(int cnt, int bits, int sum){\n\tif (visit[bits]) return;\n\tvisit[bits] = 1;\n\tif (ans <= cnt) return;\n\tif (sum >= U){\n\t\tans = cnt;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < n; ++i){\n\t\tif (bits&(1 << i))continue;\n\t\tif ((bits&v[i]) != v[i]) continue;\n\t\tdfs(cnt + 1, bits | (1 << i), sum + c[i]);\n\t}\n}\n\nint main(){\n\twhile (cin >> n >> U, n|U){\n        rep(i, n){\n            cin >> c[i];\n            int k;\n            cin >> k;\n            rep(j, k){\n                int x;\n                cin >> x;\n                v[i] |= 1<<x;\n            }\n        }\n        ans = 100;\n    //    rep(i, 1<<n){\t\t\t\n    //        int sum = 0, cnt = 0, ok = true;\n    //        rep(j, n){\n    //            if(~i&(1<<j)) continue;\n    //            if((i&v[j])!=v[j]) ok = false;\n    //            sum += c[j];\n\t\t\t\t//++cnt;\n    //        }\n    //        if(ok && sum >= U) ans = min(ans, cnt);\n    //    }\n\t\tMEMSET(visit, 0);\n\t\tdfs(0, 0, 0);\n        cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nstruct State{\n  int total,sub,S;\n  State(int total,int sub,int S) : total(total),sub(sub),S(S) {}\n};\n\nint main(){\n  int N,U,c[MAX],k,r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k;\n      int S = 0;\n      for(int j = 0 ; j < k ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n\n    bool visited[1<<N];\n    memset(visited,false,sizeof(visited));   \n    visited[0] = true;\n    queue<State> Q;\n    Q.push(State(0,0,0));\n    while(!Q.empty()){\n      State now = Q.front(); Q.pop();\n      if(now.total >= U){\n\tcout << now.sub << endl;\n\tbreak;\n      }\n      for(int i = 0 ; i < N ; i++){\n\tint S = now.S; S |= 1<<i;\n\tif(!visited[S] && (S & arr[i] == arr[i])){\n\t  Q.push(State(now.total+c[i],now.sub+1,S));\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct NODE{\n\tint a,b,c;\n\tNODE(int x,int y,int z){ a = x , b = y , c = z;}\n\tNODE(){}\n};\n\n#define INF (1<<21)\nNODE Q[1<<20];\n\nint n,U , unit[20];\nchar done[1<<20];\nint main(){\n\twhile(cin >> n >> U , n){\n\t\t\n\t\tint graph[21] = {0};\n\t\tmemset(done,0,sizeof(done));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint k;\n\t\t\tcin >> unit[i] >> k;\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\tgraph[i] |= (1<<a);\n\t\t\t}\n\t\t}\n\t\tint qsize = 0;\n\t\tQ[qsize++] = NODE(0,0,0);\n\t\tdone[0] = 1;\n\t\twhile(qsize){\n\t\t\tNODE q = Q[--qsize];\n\t\t\tif(q.b >= U){cout << q.c << endl; break;} \n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif( !(q.a >> i & 1) && (q.a & graph[i]) == graph[i])\n\t\t\t\t\tif(!done[q.a | (1<<i)])Q[qsize++] = (NODE( q.a | (1<<i) , q.b + unit[i] , q.c+1)) , done[q.a|(1<<i)] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tstatic int lg[1<<20];\n\trep(u,20) lg[1<<u]=u;\n\n\tfor(int n,lb;scanf(\"%d%d\",&n,&lb),n;){\n\t\tint score[20];\n\t\tbool wf[20][20]={};\n\t\trep(u,n){\n\t\t\tint m; scanf(\"%d%d\",score+u,&m);\n\t\t\trep(i,m){\n\t\t\t\tint v; scanf(\"%d\",&v);\n\t\t\t\twf[v][u]=true;\n\t\t\t}\n\t\t}\n\n\t\trep(k,n) rep(i,n) rep(j,n) wf[i][j]|=wf[i][k]&wf[k][j];\n\n\t\tint a[20]={};\n\t\trep(u,n) rep(v,n) if(u!=v && wf[v][u]) a[u]|=1<<v;\n\n\t\tstatic int pc[1<<20],sum[1<<20],A[1<<20];\n\n\t\tint ans=n;\n\t\tfor(int S=1;S<(1<<n);S++){\n\t\t\tint T=S&~(S&(-S));\n\t\t\tint lsb=lg[S&(-S)];\n\t\t\tpc[S]=pc[T]+1;\n\t\t\tsum[S]=sum[T]+score[lsb];\n\t\t\tA[S]=A[T]|a[lsb];\n\t\t\tif((S&A[S])==A[S] && sum[S]>=lb) ans=min(ans,pc[S]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<pair<int,vector<int> > > vpii;\n\n// iÌóÔ©çUÈãÌPÊÉ½Çè­Å¬C\nint dp[1<<20];\nint U;\nint n;\n\nint dfs(int s,int sum){\n\tif(sum>=U){\n\t\tdp[s]=0;\n\t\treturn 0;\n\t}\n\telse{\n\t\tint minCost=1000000;\n\t\tbool used[21];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((s>>i)&1)\n\t\t\t\tused[i]=true;\n\t\t}\n\t\t// Â¬ÉÇ±ÖJÚ·é©\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// Ü¾JÚµÄÈ©Á½ç\n\t\t\tif(!((s>>i)&1)){\n\t\t\t\tbool f=false;\n\t\t\t\tfor(int j = 0; j < vpii[i].second.size(); j++){\n\t\t\t\t\tif(!used[vpii[i].second[j]]){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tminCost=min(minCost,dfs(s|(1<<i),sum+vpii[i].first)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[s]=minCost;\n\t\treturn dp[s];\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n>>U&&!(n==0&&U==0)){\n\t\tint c,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>c>>k;\n\t\t\tpair<int,vector<int> > p;\n\t\t\tp.first=c;\n\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tp.second.push_back(t);\n\t\t\t}\n\t\t\tvpii.push_back(p);\n\t\t}\n\t\tcout<<dfs(0,0)<<endl;\n\t\tvpii.clear();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nint main(){\n  int N,U,c[MAX],k[MAX],r;\n\n  while(cin >> N >> U, (N | U)){\n    int arr[MAX];\n    for(int i = 0 ; i < N ; i++){\n      cin >> c[i] >> k[i];\n      int S = 0;\n      for(int j = 0 ; j < k[i] ; j++){\n        cin >> r;\n        S |= 1<<r;\n      }\n      arr[i] = S;\n    }\n    int ans = INF;\n    for(int S = 0 ; S < 1<<N ; S++){\n      int cnt = 0, total = 0;\n      bool flg = true;\n      for(int i = 0 ; i < N ; i++){\n        if(S >> i & 1){\n          if(arr[i] == 0 || (S & arr[i] == arr[i])){\n            cnt += c[i]; total++;\n          }else{\n            flg = false;\n            break;\n          }\n        }\n      }\n      if(cnt >= U){\n        ans = min(ans,total);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\t\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint main()\n{\n\tint n, u;\n\twhile (scanf(\"%d%d\", &n, &u), n | u)\n\t{\n\t\tint c[32], r[32];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(\"%d%d\", c + i, &k);\n\t\t\tr[i] = 0;\n\t\t\twhile (k--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tr[i] |= 1 << t;\n\t\t\t}\n\t\t}\n\t\tif (u == 0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int bits = 1; bits < n; ++bits)\n\t\t{\n\t\t\tint i = (1 << bits) - 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tint s = 0;\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (i >> j & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((i & r[i]) != r[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts += c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\t//int s = 0;\n\t\t\t\t\t//for (int j = 0; j < n; ++j)\n\t\t\t\t\t//\tif (i >> j & 1)\n\t\t\t\t\t//\t\ts += c[j];\n\t\t\t\t\tif (s >= u)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = bits;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// combination\n\t\t\t\tint leastBit = i & -i;\n\t\t\t\tint mostBits = i + leastBit;\n\t\t\t\tint leastSequentialBits = i & ~mostBits;\n\t\t\t\ti = mostBits | ((leastSequentialBits / leastBit) >> 1);\n\t\t\t} while (i < 1 << n);\n\t\t}\nend:\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n \n#define MAX 20\n#define INF 1e9\n \nvector<int> vec,v[MAX],a[MAX];\n \nvoid init(int N){\n    vec.clear();\n    for(int i = 0 ; i < MAX ; i++){\n\tv[i].clear();\n    }\n    for(int i = 1 ; i < 1<<N ; i++){\n\tint idx = __builtin_popcount(i);\n\tv[idx-1].push_back(i);\n    }\n    for(int i = 0 ; i < N ; i++){\n\tfor(int j = 0 ; j < (int)v[i].size() ; j++){\n\t    vec.push_back(v[i][j]);\n\t}\n    }\n}\n \nint main(){\n    int N,U,c[MAX],k,r;\n    bool used[MAX] = {false};\n \n    while(cin >> N >> U, (N | U)){\n\tif(!used[N-1]){\n\t    init(N);\n\t    a[N-1] = vec;\n\t    used[N-1] = true;\n\t}else{\n\t    vec = a[N-1];\n\t}\n\tint arr[MAX];\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> c[i] >> k;\n\t    int S = 0;\n\t    for(int j = 0 ; j < k ; j++){\n\t\tcin >> r;\n\t\tS |= 1<<r;\n\t    }\n\t    arr[i] = S;\n\t}\n\tint ans = INF;\n\tfor(int i = 0 ; i < (int)vec.size() ; i++){\n\t    int S = vec[i];\n\t    int cnt = 0, total = 0;\n\t    bool flg = true;\n\t    for(int j = 0 ; j < N ; j++){\n\t\tif(S >> j & 1){\n\t\t    if((S & arr[j]) == arr[j]){\n\t\t\tcnt += c[j]; total++;\n\t\t    }else{\n\t\t\tflg = false;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if(flg && cnt >= U){\n\t\tans = total;\n\t\tbreak;\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tvi cs(n);\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&cs[i]);\n\t\t\tint k; scanf(\"%d\",&k);\n\t\t\trep(j,k){\n\t\t\t\tint r; scanf(\"%d\",&r);\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi bs(n);\n\t\trep(i,n) bs[i]=dfs(g,i);\n\t\t\n\t\tvi sums(1<<n);\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\t\t\n\t\tint res=INF;\n\t\trep(i,1<<n) if(popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,popcount(b));\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint n, U, a[100], b[100], c;\nvector<pair<int, int>>vec2;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> U; if (n == 0 && U == 0)break; vec2.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tfor (int j = 0; j < b[i]; j++) { cin >> c; vec2.push_back(make_pair(c, i)); }\n\t\t}\n\t\tint minx = 100000000;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint sum = 0, cnt = 0; vector<int>vec;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)vec.push_back(j);\n\t\t\t}\n\t\t\tfor (int j = 0; j < vec.size(); j++)sum += a[vec[j]]; cnt = vec.size();\n\t\t\tif (sum < U || minx <= cnt)continue;\n\n\t\t\tbool r[20]; for (int j = 0; j < n; j++)r[j] = false;\n\t\t\tfor (int j = 0; j < vec.size(); j++)r[vec[j]] = true;\n\t\t\tbool flag2 = false;\n\t\t\tfor (int j = 0; j < vec2.size(); j++) {\n\t\t\t\tif (r[vec2[j].first] == false && r[vec2[j].second] == true) {\n\t\t\t\t\tflag2 = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag2 == false)minx = min(minx, cnt);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,U,tmp,sum;\nint c[30],k[30],r[30],low[30];\nint ans;\nbool f;\n\nint main(){\n  while(scanf(\"%d%d\",&n,&U),(n||U)){\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      low[i] = c[i];\n      r[i] = 0;\n      for(int j=0;j<k[i];j++){\n\tscanf(\"%d\",&tmp);\n\tr[i] |= 1<<tmp;\n      }\n    }\n\n    sort(low,low+n,greater<int>());\n\n    int l; sum = 0;\n    for(l=0;l<n;l++){\n      sum += low[l];\n      if(U<=sum)break;\n    }\n\n    f = false;;\n    for(ans=l+1;ans<n;ans++){\n      int comb = (1<<ans) -1;\n      while(comb < (1<<n)){\n\tsum = 0; f = true;\n\tfor(int i=0;i<n;i++){\n\t  if((comb>>i)&1){\n\t    if( (comb&r[i]) != r[i]){\n\t      f = false;\n\t      break;\n\t    }\n\t    sum += c[i];\n\t  }\n\t}\n\n\tif(f && U<=sum){\n\t  break;\n\t}\n\tf = false;\n      \n\tint x = comb & -comb, y = comb + x;\n\tcomb = ( ( (comb & ~y) /x ) >> 1) | y;\n      }\n      if(f)break;\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[10],k[10],r[10][10];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(j=0; j<k[i]; j++)\n\tscanf(\"%d\",&r[i][j]);\n    }\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      for(j=0; ok && j<n; j++)\n\tif(i & (1<<j)){\n\t  tni += c[j];\n\t  for(l=0; ok && l<k[j]; l++)\n\t    if(!(i & (1<<r[j][l])))\n\t      ok = 0;\n\t}\n      if(ok && tni >= u && ans > cc)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\t/*\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n\t*/\n\tok = !((i & (1<<j)) && ((i & r[j]) ^ r[j]));\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while(!isdigit(g = getchar()));\n  ret = g-'0';\n  while(isdigit(g = getchar())){\n    ret *= 10;\n    ret += g-'0';\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok && j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) && ((i & r[j]) != r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u && ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U)\n\t    if(ans > men)\n\t      ans = men;\n\t}\n      \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  res += c[j];\n\t\t  int pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    res = -1;\n\t\t}\n\t      if(res == -1)\n\t\tbreak;\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U)\n\t    if(ans > men)\n\t      ans = men;\n\t}\n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,U,c[20],R[20],a,i;S(k,s,A,m,b){b=s<U;b&k<n&&S(k+1,s,A,m)+S(k+1,s+c[k],A|1<<k,m+1);for(i=n*!b;i--;)b|=A&1<<i&&A&R[i]^R[i];m<a*!b?a=m:0;}main(k,t){for(;scanf(\"%d%d\",&n,&U)*n;S(0,0,0,0),printf(\"%d\\n\",a))for(a=i=n;i--;)for(R[i]=!scanf(\"%d%d\",c+i,&k);k--;R[i]|=1<<n-1-t)scanf(\"%d\",&t);}"
  },
  {
    "language": "C",
    "code": "int __builtin_popcount(int i,int n)\n{\n  int j,res;\n  res = 0;\n  for(j = 0;j<n;j++)\n    if((i >> j) & 1)\n      res++;\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n][21];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t  if(k == 0)\n\t    G[i][0] = -1;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i][j] = r;\n\t      \n\t      G[i][j+1] = -1;\n\t  \n\t    }\n\t}\n\n      ans = (1<<29);\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  res += c[j];\n\t\t  for(k=0;G[j][k] != -1;k++)\n\t\t    {\n\t\t      if(!((i>>G[j][k]) & 1))\n\t\t\t{\n\t\t\t  res = -1;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      if(res == -1)\n\t\tbreak;\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U)\n\t    if(ans > men)\n\t      ans = men;\n\t}\n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0 | g>9);\n  ret = g;\n  while((g = getchar() - '0'), g>=0 & g<=9){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[20],k[20],r[20][20];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(j=0; j<k[i]; j++)\n\tscanf(\"%d\",&r[i][j]);\n    }\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      for(j=0; ok && j<n; j++)\n\tif(i & (1<<j)){\n\t  tni += c[j];\n\t  for(l=0; ok && l<k[j]; l++)\n\t    if(!(i & (1<<r[j][l])))\n\t      ok = 0;\n\t}\n      if(ok && tni >= u && ans > cc)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\n#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[20],k[20],r[20][20];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(j=0; j<k[i]; j++)\n\tscanf(\"%d\",&r[i][j]);\n    }\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      for(j=0; ok && j<n; j++)\n\tif(i & (1<<j)){\n\t  tni += c[j];\n\t  for(l=0; ok && l<k[j]; l++)\n\t    if(!(i & (1<<r[j][l])))\n\t      ok = 0;\n\t}\n      if(ok && tni >= u && ans > cc)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint bit_count(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\treturn ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n}\n\nint n, U;\nint c[20];\nint k[20];\nint r[20][5];\nint zyouken[20];\n\nint memo[1 << 20];\n\nint search(int current) {\n\tint ret = 100000;\n\tint i;\n\tint tani = 0;\n\tif (memo[current]) return ~memo[current];\n\tfor (i = 0; i < n; i++) {\n\t\tif ((current >> i) & 1) {\n\t\t\ttani += c[i];\n\t\t\tif (tani >= U) return ~(memo[current] = ~bit_count(current));\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif (!((current >> i) & 1)) {\n\t\t\tint candidate = search(current | (1 << i) | zyouken[i]);\n\t\t\tif (candidate < ret) ret = candidate;\n\t\t}\n\t}\n\treturn ~(memo[current] = ~ret);\n}\n\nint main(void) {\n\twhile (scanf(\"%d%d\", &n, &U) == 2 && (n > 0 || U > 0)) {\n\t\tint i, j;\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%d%d\", &c[i], &k[i]) != 2) return 1;\n\t\t\tzyouken[i] = 0;\n\t\t\tfor (j = 0; j < k[i]; j++) {\n\t\t\t\tif (scanf(\"%d\", &r[i][j]) != 1) return 1;\n\t\t\t\tzyouken[i] |= 1 << r[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", search(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(men >= (1<<2)-1 && ans == 2)\n\t    break;\n\t  else if(men >= (1<<3)-1 && ans == 3)\n\t    break;\n\t  else if(men >= (1<<4)-1 && ans == 4)\n\t    break;\n\t  else if(men >= (1<<5)-1  && ans == 5)\n\t    break;\n\t  else if(men >= (1<<6)-1 && ans == 6)\n\t    break;\n\t  else if(men >= (1<<7)-1 && ans == 7)\n\t    break;\n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t\n\t      \n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint bit_count(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\treturn ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n}\n\nint n, U;\nint c[20];\nint k[20];\nint r[20][5];\nint zyouken[20];\n\nint memo[1 << 20];\n\nint search(int current) {\n\tint ret = 100000;\n\tint i;\n\tint tani = 0;\n\tif (memo[current]) return ~memo[current];\n\tfor (i = 0; i < n; i++) {\n\t\tif ((current >> i) & 1) tani += c[i];\n\t}\n\tif (tani >= U) {\n\t\tret = bit_count(current);\n\t} else {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (!((current >> i) & 1)) {\n\t\t\t\tint candidate = search(current | (1 << i) | zyouken[i]);\n\t\t\t\tif (candidate < ret) ret = candidate;\n\t\t\t}\n\t\t}\n\t}\n\treturn ~(memo[current] = ~ret);\n}\n\nint main(void) {\n\twhile (scanf(\"%d%d\", &n, &U) == 2 && (n > 0 || U > 0)) {\n\t\tint i, j;\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%d%d\", &c[i], &k[i]) != 2) return 1;\n\t\t\tzyouken[i] = 0;\n\t\t\tfor (j = 0; j < k[i]; j++) {\n\t\t\t\tif (scanf(\"%d\", &r[i][j]) != 1) return 1;\n\t\t\t\tzyouken[i] |= 1 << r[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", search(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1032 Course Planning for Lazy Students\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int s, c; } Q;\nQ q[10000]; int top, tail;\nint c[22], r[22];\nchar mk[1<<20];\n\nint bitcount(int bits)\n{\n    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n    return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main()\n{\n\tint n, U, i, k, s;\n\t\n\twhile (n = in()) {\n\t\tU = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tc[i] = in(), r[i] = 0;\n\t\t\tk = in(); while (k--) r[i] |= 1 << in();\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].s = q[0].c = 0, top = 0, tail = 1;\n\t\twhile (top != tail) {\n\t\t\ts = q[top].s, k = q[top++].c;\n\t\t\tif (mk[s]) continue;\n\t\t\tmk[s] = 1;\n\t\t\tif (k >= U) break;\n\t\t\tfor (i = 0; i < n; i++) if (!(s & (1<<i)) && (r[i] & s) == r[i]) {\n\t\t\t\tq[tail].s = s | (1<<i), q[tail++].c = k + c[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", bitcount(s));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint memo[1<<20];\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  for(i=0; i<(1<<20); i++) memo[i] = cnt(i);\n\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n    int *m = &memo[(1<<n)-1];\n    for(i=0; i-n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = *m--;\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\t//if(!(!(i & (1<<j)) || !((i & r[i]) == r[j])))\n\tif(!((!(i & (1<<j))) | (!((i & r[j]) ^ r[j]))))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint n, U;\n\twhile (scanf(\"%d%d\", &n, &U) == 2 && (n > 0 || U > 0)) {\n\t\tint c[20];\n\t\tint k[20];\n\t\tint r[20][5];\n\t\tint zyouken[20] = {0};\n\t\tint i, j;\n\t\tint tani, kamokusuu;\n\t\tint answer = n + 1;\n\t\tint search, search_max;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%d%d\", &c[i], &k[i]) != 2) return 1;\n\t\t\tfor (j = 0; j < k[i]; j++) {\n\t\t\t\tif (scanf(\"%d\", &r[i][j]) != 1) return 1;\n\t\t\t\tzyouken[i] |= 1 << r[i][j];\n\t\t\t}\n\t\t}\n\t\tsearch_max = 1 << n;\n\t\tfor (search = 0; search < search_max; search++) {\n\t\t\ttani = 0;\n\t\t\tkamokusuu = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tif ((search >> i) & 1) {\n\t\t\t\t\tif ((search & zyouken[i]) != zyouken[i]) {\n\t\t\t\t\t\tint mask = ~((1 << i) - 1);\n\t\t\t\t\t\tif ((search & zyouken[i] & mask) != (zyouken[i] & mask)) {\n\t\t\t\t\t\t\tsearch = ((search + (1 << i)) & mask) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttani += c[i];\n\t\t\t\t\tkamokusuu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= n && tani >= U) {\n\t\t\t\tif (kamokusuu < answer) answer = kamokusuu;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while(!isdigit(g = getchar()));\n  ret = g-'0';\n  while(isdigit(g = getchar())){\n    ret *= 10;\n    ret += g-'0';\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok && j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) && ((i & r[j]) != r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u && ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[20],k[20],r[20][20];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(j=0; j<k[i]; j++)\n\tscanf(\"%d\",&r[i][j]);\n    }\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      for(j=0; ok && j<n; j++)\n\tif(i & (1<<j)){\n\t  tni += c[j];\n\t  for(l=0; ok && l<k[j]; l++)\n\t    if(!(i & (1<<r[j][l])))\n\t      ok = 0;\n\t}\n      if(ok && tni >= u && ans > cc)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1032\nTitle:Course Planning for Lazy Students\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n#include <limits.h>\n//Global data section\n#define NOOFSUBJECT 20\nint n;\nint U;\nstruct subj_st\n{int c;\n  int k;\n  int r[NOOFSUBJECT];\n  int take;\n} subj[NOOFSUBJECT];\nint min_kamoku;\n//\nvoid print_kamoku()\n{\n  int i;\n  printf(\"take=\");\n  for(i=0;i<n;i++)\n    if(subj[i].take)\n      printf(\"%d(%d),\",i,subj[i].take);\n  printf(\"\\n\");\t     \n}\n\nvoid regist(int k)\n{\n#ifdef DEBUG\n  if(min_kamoku == k)\n      print_kamoku();\n#endif\n  if(min_kamoku > k)\n    {\n      min_kamoku = k;\n#ifdef DEBUG\n      print_kamoku();\n#endif\n    }\n}\nvoid search(int unit,int from,int kamoku,int depth)\n{\n  int i,j,u,km,sks,sb;\n  //printf(\"u %dfr:%d;\\n\",unit,from);\n  //print_kamoku();\n  if(unit<=0)\n    {\n      regist(kamoku);\n      return;\n    }\n  for(i=from;i<n;i++)\n    {\n      if(subj[i].take)\n\tcontinue;\n      sks=subj[i].k;\n      //printf(\"i %d sks:%d\",i,sks);\n      u=subj[i].c;\n      km=1;\n      \n      for(j=0;j<sks;j++)\n\t{\n\t  sb = subj[i].r[j];\n\t  if(!subj[sb].take)\n\t    {\n\t      u+=subj[sb].c;\n\t      km++;\n\t      subj[sb].take=depth;\n\t    }\n\t}\n      \n      //printf(\"i1:%d\",i);\n      subj[i].take=depth;\n      search(unit-u,i+1,kamoku+km,depth+1);\n      //printf(\"i2:%d\",i);\n       \n      for(j=0;j<n;j++)\n\t{\n\t  if(subj[j].take==depth)\n\t    subj[j].take=0;\t    \n\t}\n      \n    }\n}\n\nmain()\n{\n  int i,j;\n\n  while(EOF!=scanf(\"%d %d\",&n,&U) && (n || U))\n    {\n      min_kamoku = INT_MAX;\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%d \",&(subj[i].c));\n\t  scanf(\"%d \",&(subj[i].k));\n\t  for(j=0;j<subj[i].k;j++)\n\t    scanf(\"%d \",&(subj[i].r[j]));\n\t  subj[i].take=0;\n\t}\n      search(U,0,0,1);\n      printf(\"%d\\n\",min_kamoku);\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men+1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t\n\t      \n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j)){\n\t  tni += c[j];\n\t  if(((i & r[j]) ^ r[j]))\n\t    ok = 0;\n\t}\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), (g < 0));\n  ret = g;\n  while((g = getchar() - '0'), (g >= 0)){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint n, U;\n\twhile (scanf(\"%d%d\", &n, &U) == 2 && (n > 0 || U > 0)) {\n\t\tint c[20];\n\t\tint k[20];\n\t\tint r[20][5];\n\t\tint zyouken[20] = {0};\n\t\tint i, j;\n\t\tint tani, kamokusuu;\n\t\tint answer = n + 1;\n\t\tint search, search_max;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%d%d\", &c[i], &k[i]) != 2) return 1;\n\t\t\tfor (j = 0; j < k[i]; j++) {\n\t\t\t\tif (scanf(\"%d\", &r[i][j]) != 1) return 1;\n\t\t\t\tzyouken[i] |= 1 << r[i][j];\n\t\t\t}\n\t\t}\n\t\tsearch_max = 1 << n;\n\t\tfor (search = 0; search < search_max; search++) {\n\t\t\ttani = 0;\n\t\t\tkamokusuu = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tif ((search >> i) & 1) {\n\t\t\t\t\tif ((search & zyouken[i]) != zyouken[i]) break;\n\t\t\t\t\ttani += c[i];\n\t\t\t\t\tkamokusuu++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= n && tani >= U) {\n\t\t\t\tif (kamokusuu < answer) answer = kamokusuu;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[20],k[20],r[20];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      r[i] = 0;\n      for(j=0; j<k[i]; j++){\n\tint t;\n\tscanf(\"%d\",&t);\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok && j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) && ((i & r[j]) != r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u && ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while(!isdigit(g = getchar()));\n  ret = g-'0';\n  while(isdigit(g = getchar())){\n    ret *= 10;\n    ret += g-'0';\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1032 Course Planning for Lazy Students\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define MAX (1<<20)\ntypedef struct { int s; short c; } Q;\nQ q[MAX+10]; int top, tail;\nint c[20], r[20];\nchar mk[MAX];\n\nint bitcount(int bits)\n{\n    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n    return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main()\n{\n\tint n, U, i, j, k, s, t;\n\t\n\twhile (n = in()) {\n\t\tU = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tc[i] = in(), r[i] = 0;\n\t\t\tk = in(); while (k--) r[i] |= 1 << in();\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].s = q[0].c = 0, top = 0, tail = 1; mk[0] = 1;\n\t\twhile (top != tail) {\n\t\t\ts = q[top].s, k = q[top++].c;\n\t\t\tif (k >= U) break;\n\t\t\tfor (j = 1, i = 0; i < n; i++, j <<= 1) {\n\t\t\t\tif (s & j) continue;\n\t\t\t\tt = s | j;\n\t\t\t\tif ((r[i] & s) == r[i] && !mk[t]) {\n\t\t\t\t\tmk[t] = 1;\n\t\t\t\t\tq[tail].s = t, q[tail++].c = k + c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", bitcount(s));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "n,U,c[20],R[20],ans;\nS(now,sum,attend,anum){\n\tint i;\n\tif(sum>=U){\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(attend&(1<<i)){\n\t\t\t\tif((attend&R[i])!=R[i]){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tanum<ans?ans=anum:0;\n\t}else if(now<n){\n\t\tS(now+1,sum,attend,anum);\n\t\tS(now+1,sum+c[now],attend|1<<now,anum+1);\n\t}\n}\nmain(){\n\tint i,j,k,t;\n\tfor(;scanf(\"%d%d\",&n,&U)*n;){\n\t\tans=n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",c+i,&k);\n\t\t\tR[i]=0;\n\t\t\tfor(;k--;){\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tR[i]|=1<<t;\n\t\t\t}\n\t\t}\n\t\tS(0,0,0,0);\n\t\tprintf(\"%d \\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nint ans,U;\n\nvoid dfs(VI& G,VI& c,int total,int cost,int b)\n{\n  if(cost >= ans)\n    return;\n\n  int n = G.size();\n  for(int i=0;i<n;i++)\n    {\n      if((b>>i) & 1)\n\tcontinue;\n      int pre = G[i];\n      pre &= b;\n      if(pre == G[i])\n\t{\n\t  if(total+c[i] < U)\n\t    dfs(G,c,total+c[i],cost+1,b|(1<<i));\n\t  else \n\t    ans = min(ans,cost+1);\n\t}\n    }\n\n}\n\nint main()\n{\n  int n;\n  while(cin >> n >> U,n|U)\n    {\n      vector<int> G;\n      G.resize(n);\n      vector<int> c; \n      c.resize(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  int k;\n\t  cin >> c[i] >> k;\n\t  G[i] = 0;\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      int r;\n\t      cin >> r;\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      ans = n;\n      dfs(G,c,0,0,0);\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,U,c[20],R[20],a;S(k,s,A,m){int i;if(s>=U){for(i=n;i--;)if(A&1<<i&&A&R[i]^R[i])return;m<a?a=m:0;}else if(k<n){S(k+1,s,A,m);S(k+1,s+c[k],A|1<<k,m+1);}}main(i,k,t){for(;scanf(\"%d%d\",&n,&U)*n;S(0,0,0,0),printf(\"%d\\n\",a))for(a=i=n;i--;)for(R[i]=!scanf(\"%d%d\",c+i,&k);k--;R[i]|=1<<t)scanf(\"%d\",&t);for(i=9e5;i--;)getchar();exit(0);}"
  },
  {
    "language": "C",
    "code": "n,U,c[20],R[20],a,i;\nS(k,s,A,m,b){\n\tif(s<U){\n\t\tb=1;\n\t\tk<n&&S(k+1,s,A,m)+S(k+1,s+c[k],A|1<<k,m+1);\n\t}else{\n\t\tb=0;\n\t\tfor(i=n;i--;)\n\t\t\tb|=A&1<<i&&A&R[i]^R[i];\n\t}\n\tm<a*!b?a=m:0;\n}\nmain(k,t){\n\tfor(;scanf(\"%d%d\",&n,&U)*n;S(0,0,0,0),printf(\"%d \\n\",a))\n\t\tfor(a=i=n;i--;)\n\t\t\tfor(R[i]=!scanf(\"%d%d\",c+i,&k);k--;R[i]|=1<<t)\n\t\t\t\tscanf(\"%d\",&t);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint memo[1<<20];\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  for(i=0; i<(1<<20); i++) memo[i] = cnt(i);\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = memo[i];\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\tif(!(i & (1<<j))-1 & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  res += c[j];\n\t\t  int pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U)\n\t    if(ans > men)\n\t      ans = men;\n\t}\n      \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      if(U == 0)\n\t{\n\t  puts(\"0\");      \n\t  continue;\n\t}\n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t  if(ans == 1)\n\t    break;\t\n\t  else if(men >= (1<<2)-1 && ans == 2)\n\t    break;\n\t  else if(men >= (1<<3)-1 && ans == 3)\n\t    break;\n\t  else if(men >= (1<<4)-1 && ans == 4)\n\t    break;\n\t  else if(men >= (1<<5)-1  && ans == 5)\n\t    break;\n\t  else if(men >= (1<<6)-1 && ans == 6)\n\t    break;\n\t  else if(men >= (1<<7)-1 && ans == 7)\n\t    break;\n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1032\nTitle:Course Planning for Lazy Students\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n#include <limits.h>\n//Global data section\n#define NOOFSUBJECT 20\nint n;\nint U;\nstruct subj_st\n{int c;\n  int k;\n  int r[NOOFSUBJECT];\n  int take;\n} subj[NOOFSUBJECT];\nint min_kamoku;\n//\nvoid senkou_kamoku_set_r(int i,int depth,int * up,int * kmp)\n{\n  int j,sb,sks;\n\n\n  sks=subj[i].k;\n  for(j=0;j<sks;j++)\n    {\n#ifdef DEBUG\n  printf(\"*\");\n#endif\n      sb = subj[i].r[j];\n      if(!subj[sb].take)\n\t{\n\t  *up+=subj[sb].c;\n\t  *kmp=*kmp+1;\n\t  subj[sb].take=depth;\n\t  senkou_kamoku_set_r(sb,depth,up,kmp);\n\t}\n    }\n}\nvoid print_kamoku()\n{\n  int i;\n  printf(\"take=\");\n  for(i=0;i<n;i++)\n    if(subj[i].take)\n      printf(\"%d(%d),\",i,subj[i].take);\n  printf(\"\\n\");\t     \n}\n\nvoid regist(int k)\n{\n#ifdef DEBUG\n  if(min_kamoku == k)\n      print_kamoku();\n#endif\n  if(min_kamoku > k)\n    {\n      min_kamoku = k;\n#ifdef DEBUG\n      print_kamoku();\n#endif\n    }\n}\nvoid search(int unit,int from,int kamoku,int depth)\n{\n  int i,j,u,km,sks,sb;\n  //printf(\"u %d;\\n\",unit);\n  //print_kamoku();\n  if(unit<=0)\n    {\n      regist(kamoku);\n      return;\n    }\n  for(i=from;i<n;i++)\n    {\n      if(subj[i].take)\n\tcontinue;\n      sks=subj[i].k;\n\n      u=subj[i].c;\n      km=1;\n      \n      senkou_kamoku_set_r(i,depth,&u,&km);\n\n      \n      subj[i].take=depth;\n      search(unit-u,i+1,kamoku+km,depth+1);\n\n       \n      for(j=0;j<n;j++)\n\t{\n\t  if(subj[j].take==depth)\n\t    subj[j].take=0;\t    \n\t}\n      \n    }\n}\n\nmain()\n{\n  int i,j;\n\n  while(EOF!=scanf(\"%d %d\",&n,&U) && (n || U))\n    {\n      min_kamoku = INT_MAX;\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%d \",&(subj[i].c));\n\t  scanf(\"%d \",&(subj[i].k));\n\t  for(j=0;j<subj[i].k;j++)\n\t    scanf(\"%d \",&(subj[i].r[j]));\n\t  subj[i].take=0;\n\t}\n      search(U,0,0,1);\n      printf(\"%d\\n\",min_kamoku);\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0 | g>9);\n  ret = g;\n  while((g = getchar() - '0'), g>=0 & g<=9){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men-1 >= ans)\n\t    continue;\n\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U && ans > men)\n\t    ans = men;\n\t\n\t      \n\t}     \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int main()\n{\n  while(1)\n    {\n      int n,U,i,j,k,men,r,ans,res,pre;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      int G[n];\n      int c[n];\n      for(i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t  for(j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n      \n      ans = n;\n      for(i = 1;i<(1<<n);i++)\n\t{\n\t  men = __builtin_popcount(i);\n\t  if(men >= ans)\n\t    continue;\n\t  //check\n\t  res = 0;\n\t  for(j=0;j<n;j++)\n\t    {\n\t      if((i >> j) & 1)\n\t\t{\n\t\t  pre = G[j];\n\t\t  pre &= i;\n\t\t  if(pre != G[j])\n\t\t    {\n\t\t      res = -1;\n\t\t      break;\n\t\t    }\n\t\t  res += c[j];\n\t\t  if(res >= U)\n\t\t    break;\n\t\t}\n\t    }\n\t  //check\n\t  if(res == -1)\n\t    continue;\n\t  if(res >= U)\n\t    if(ans > men)\n\t      ans = men;\n\t}\n      \n      printf(\"%d\\n\",ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = cnt(i);\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\tif((i & (1<<j)) && ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cnt(int n){\n  int ret = 0;\n  while(n){\n    ret++;\n    n ^= (n & (-n));\n  }\n  return ret;\n}\n\nint main(){\n  int c[20],k[20],r[20][20];\n  int n,u;\n  int i,j,l;\n  while(scanf(\"%d%d\",&n,&u), n+u){\n    int ans = n;\n    for(i=0; i<n; i++){\n      scanf(\"%d%d\",&c[i],&k[i]);\n      for(j=0; j<k[i]; j++)\n\tscanf(\"%d\",&r[i][j]);\n    }\n    for(i=0; i<(1<<n); i++){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      if(cc >= ans) continue;\n      for(j=0; ok && j<n; j++)\n\tif(i & (1<<j))\n\t  tni += c[j];\n      if(tni < u) continue;\n      for(j=0; ok && j<n; j++)\n\tif(i & (1<<j))\n\t  for(l=0; ok && l<k[j]; l++)\n\t    if(!(i & (1<<r[j][l])))\n\t      ok = 0;\n\n      if(ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint memo[1<<20];\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  for(i=0; i<(1<<20); i++) memo[i] = cnt(i);\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = memo[i];\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\tif((i & (1<<j)) && ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<iostream>\n#include<bitset>\n#include<deque>\n#include<algorithm>\nusing namespace std;\n\nstruct Pox\n{\n  int state,cost;\n  Pox(int state,int cost):state(state),cost(cost){}\n};\n\nint main()\n{\n  while(1)\n    {\n      int n,U,k,r;\n      scanf(\"%d %d\",&n,&U);\n      if(n+U == 0)\n\tbreak;\n      deque<Pox> deq;\n      int G[n];\n      int c[n];\n      for(int i = 0;i<n;i++)\n\t{\n\t  scanf(\"%d %d\",&c[i],&k);\n\t    G[i] = 0;\n\t    if(!k)\n\t      deq.push_back(Pox((1<<i),c[i]));\n\t  for(int j=0;j<k;j++)\n\t    {\n\t      scanf(\"%d\",&r);\n\t      G[i] |= (1<<r);\n\t    }\n\t}\n\n      int ans = n;\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  int num = __builtin_popcount(pox.state);\n\t  if(num >= ans)\n\t    continue;\n\t  for(int i=0;i<n;i++)\n\t    {\n\t      if((pox.state >> i) & 1)\n\t\tcontinue;\n\t      int pre = G[i];\n\t      pre &= pox.state;\n\t      if(pre != G[i])\n\t\tcontinue;\n\t      if(pox.cost + c[i] < U)\n\t\tdeq.push_back(Pox(pox.state|(1<<i),pox.cost+c[i]));\n\t      else \n\t\tans = min(ans,num+1);\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1032 Course Planning for Lazy Students\n// 2018.2.28 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define QMAX 500000\ntypedef struct { int s, c; } Q;\nQ q[QMAX+3]; int top, tail;\nint c[22], r[22];\nchar mk[1<<20];\n\nint bitcount(int bits)\n{\n    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n    return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main()\n{\n\tint n, U, i, k, s;\n\t\n\twhile (n = in()) {\n\t\tU = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tc[i] = in(), r[i] = 0;\n\t\t\tk = in(); while (k--) r[i] |= 1 << in();\n\t\t}\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].s = q[0].c = 0, top = 0, tail = 1;\n\t\twhile (top != tail) {\n\t\t\ts = q[top].s, k = q[top].c; if (++top == QMAX) top = 0;\n\t\t\tif (mk[s]) continue;\n\t\t\tmk[s] = 1;\n\t\t\tif (k >= U) break;\n\t\t\tfor (i = 0; i < n; i++) if (!(s & (1<<i)) && (r[i] & s) == r[i]) {\n\t\t\t\tq[tail].s = s | (1<<i), q[tail].c = k + c[i];\n\t\t\t\tif (++tail == QMAX) tail = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", bitcount(s));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0);\n  ret = g;\n  while((g = getchar() - '0'), g>=0){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint memo[1<<20];\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  register unsigned int i,j,l;\n  for(i=0; i<(1<<20); i++) memo[i] = cnt(i);\n\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n    int *m = &memo[(1<<n)-1];\n    for(i=0; i-n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 0xFFFFFFFF;\n      int cc  = *m--;\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j-n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\n\tif(!(i & (1<<j))-1 & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint bit_count(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\treturn ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n}\n\nint n, U;\nint c[20];\nint k[20];\nint r[20][5];\nint zyouken[20];\n\nint memo[1 << 20];\n\nint search(int current) {\n\tint ret = 100000;\n\tint i;\n\tint tani = 0;\n\tif (memo[current]) return ~memo[current];\n\tfor (i = 0; i < n; i++) {\n\t\tif ((current >> i) & 1) {\n\t\t\ttani += c[i];\n\t\t\tif (tani >= U) return ~(memo[current] = ~bit_count(current));\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif (!((current >> i) & 1)) {\n\t\t\tint candidate = search(current | (1 << i) | zyouken[i]);\n\t\t\tif (candidate < ret) ret = candidate;\n\t\t}\n\t}\n\treturn ~(memo[current] = ~ret);\n}\n\nint main(void) {\n\twhile (scanf(\"%d%d\", &n, &U) == 2 && (n > 0 || U > 0)) {\n\t\tint i, j;\n\t\tint sinchoku;\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%d%d\", &c[i], &k[i]) != 2) return 1;\n\t\t\tzyouken[i] = 0;\n\t\t\tfor (j = 0; j < k[i]; j++) {\n\t\t\t\tif (scanf(\"%d\", &r[i][j]) != 1) return 1;\n\t\t\t\tzyouken[i] |= 1 << r[i][j];\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tsinchoku = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tint new_value = zyouken[i];\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tif ((zyouken[i] >> j) & 1) new_value |= zyouken[j];\n\t\t\t\t}\n\t\t\t\tif (new_value != zyouken[i]) {\n\t\t\t\t\tzyouken[i] = new_value;\n\t\t\t\t\tsinchoku = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (sinchoku);\n\t\tprintf(\"%d\\n\", search(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstatic inline int getint(){\n  int ret = 0;\n  int g;\n  while((g = getchar() - '0'), g<0 | g>9);\n  ret = g;\n  while((g = getchar() - '0'), g>=0 & g<=9){\n    ret *= 10;\n    ret += g;\n  }\n  return ret;;\n}\n\nstatic inline int cnt(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n  int c[20],k,r[20];\n  int n,u;\n  unsigned int i,j,l;\n  while(n=getint(), u=getint(), n+u){\n    int ans = n;\n\n    for(i=0; i<n; i++){\n      c[i]=getint(); k=getint();\n      r[i] = 0;\n      for(j=0; j<k; j++){\n\tint t = getint();\n\tr[i] |= (1<<t);\n      }\n    }\n\n    for(i=(1<<n)-1; i; i--){\n      int tni = 0;\n      int ok  = 1;\n      int cc  = cnt(i);\n\n      if(cc >= ans) continue;\n\n      for(j=0; ok & j<n; j++){\n\tif(i & (1<<j))\n\t  tni += c[j];\n\tif((i & (1<<j)) & ((i & r[j]) ^ r[j]))\n\t  ok = 0;\n      }\n\n      if(tni >= u & ok)\n\tans = cc;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<Item> items;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint U = sc.nextInt();\n\t\t\tif (N == 0 && U == 0) break;\n\t\t\titems = new ArrayList<Item>();\n\t\t\tArrayList<ArrayList<Integer>> c = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tItem item = new Item(sc.nextInt());\n\t\t\t\titems.add(item);\n\t\t\t\tArrayList<Integer> cs = new ArrayList<Integer>();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tcs.add(r);\n\t\t\t\t}\n\t\t\t\tc.add(cs);\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j : c.get(i)) {\n\t\t\t\t\titems.get(i).child.add(items.get(j));\n\t\t\t\t\titems.get(j).parent.add(items.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayList<Item> sorted = sort();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsorted.get(i).index = i;\n\t\t\t}\n\t\t\tint ans = N;\n\t\t\tint[] units = new int[1 << N];\n\t\t\tArrays.fill(units, -1);\n\t\t\tunits[0] = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint mask = sorted.get(i).mask();\n\t\t\t\tfor (int j = 0; j < (1 << i); ++j) {\n\t\t\t\t\tif (units[j] == -1 || (j & mask) != mask) continue;\n\t\t\t\t\tint newUnits = units[j] + sorted.get(i).unit;\n\t\t\t\t\tunits[j + (1 << i)] = newUnits;\n\t\t\t\t\tint count = Integer.bitCount(j) + 1;\n\t\t\t\t\tif (newUnits >= U && count < ans) {\n\t\t\t\t\t\tans = count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic ArrayList<Item> sort() {\n\t\tArrayList<Item> sorted = new ArrayList<Item>();\n\t\tfor (int i = 0; i < items.size(); ++i) {\n\t\t\tdfs(sorted, items.get(i));\n\t\t}\n\t\tCollections.reverse(sorted);\n\t\treturn sorted;\n\t}\n\n\tstatic void dfs(ArrayList<Item> sorted, Item cur) {\n\t\tif (cur.visited) return;\n\t\tcur.visited = true;\n\t\tfor (Item c : cur.child) {\n\t\t\tdfs(sorted, c);\n\t\t}\n\t\tsorted.add(cur);\n\t}\n\n\tstatic class Item {\n\t\tint unit;\n\t\tArrayList<Item> child = new ArrayList<Item>();\n\t\tArrayList<Item> parent = new ArrayList<Item>();\n\t\tboolean visited = false;\n\t\tint index;\n\n\t\tItem(int c) {\n\t\t\tthis.unit = c;\n\t\t}\n\n\t\tint mask() {\n\t\t\tint ret = 0;\n\t\t\tfor (Item p : parent) {\n\t\t\t\tret |= p.mask();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = num[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(num);\n\t\t\tint sum = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tsum += num[i];\n\t\t\t\tif (sum >= u) {\n\t\t\t\t\tm = n - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = m; i < n; i++) {\n\t\t\t\tv = new boolean[1 << n];\n\t\t\t\tif (slove(0, 0, 0, i)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int bit, int one, int have, int depth) {\n\t\tif (u <= have)\n\t\t\treturn true;\n\t\tif (one == depth)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tif (slove(a, one + 1, have + unit[i], depth))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint m;\n\tint n, u;\n\tint[] need, unit, num;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tgain = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = gain[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans <= one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (((bit >> i) & 1) == 1)\n\t\t\t\tcontinue;\n\t\t\tif ((need[i] & bit) != need[i])\n\t\t\t\tcontinue;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit, gain;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans == one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\t\tif (ans - 1 == one)\n\t\t\treturn;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(a, one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tgain = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = gain[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(gain);\n\t\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\t\tgain[i] += gain[i + 1];\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans <= one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\t\tif (have + gain[n - (ans - one - 1) - 1] < u)\n\t\t\treturn;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit, gain;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\tpublic static final int MAX = 20;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] req_bit = new int[MAX];\n\t\tint[] amounts = new int[MAX];\n\t\tint[] DP = new int[1 << MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int U = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && U == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tamounts[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tint bit = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tbit |= 1 << (sc.nextInt());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treq_bit[i] = bit;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(DP, INF);\n\t\t\tDP[0] = 0;\n\t\t\t\n\t\t\tfinal int bit_size = 1 << n;\n\t\t\tfor(int bit = 0; bit < bit_size; bit++){\n\t\t\t\tif(DP[bit] >= U){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int next = 0; next < n; next++){\n\t\t\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if((bit & (req_bit[next])) != req_bit[next]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tDP[bit | (1 << next)] = Math.min(DP[bit | (1 << next)], DP[bit] + amounts[next]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < bit_size; i++){\n\t\t\t\tSystem.out.println(Integer.toBinaryString(i) + \"\\t : \" + DP[i]);\n\t\t\t}\n\t\t\t*/\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i < bit_size; i++){\n\t\t\t\tif(DP[i] >= U && DP[i] < INF){\n\t\t\t\t\t//System.out.println(Integer.toBinaryString(i) + \"\\t : \" + DP[i]);\n\t\t\t\t\tmin = Math.min(min, Integer.bitCount(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Course Planning for Lazy Students\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint u = sc.nextInt();\n\t\t\tif((n|u)==0)break;\n\t\t\tint[] c = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t\tint x = 0;\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)x|=(1<<sc.nextInt());\n\t\t\t\tr[i] = x;\n\t\t\t}\n\t\t\tSet<Integer> s = new HashSet<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(r[i]==0)s.add(1<<i);\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tSet<Integer> next = new HashSet<Integer>();\n\t\t\t\tfor(int v:s){\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif((v&(1<<i))>0){\n\t\t\t\t\t\t\tsum += c[i];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((r[i]&v)==r[i])next.add(v|(1<<i));\n\t\t\t\t\t}\n\t\t\t\t\tif(u<=sum){\n\t\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t\ts = next;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tint U;\n\tint[] c, m;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = Integer.parseInt(sc.next());\n\t\t\tU = Integer.parseInt(sc.next());\n\t\t\tif( (n|U) == 0 ) break;\n\t\t\tc = new int[n];\n\t\t\tm = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tc[i] = Integer.parseInt(sc.next());\n\t\t\t\tint k = Integer.parseInt(sc.next());\n\t\t\t\tint mask = 0;\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint r = Integer.parseInt(sc.next());\n\t\t\t\t\tmask += (1<<r);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tm[i] = mask;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n//\t\t\tfor(Sub s: subs) debug(s.c, s.mask);\n\t\t\t\n/*\t\t\tint min = INF;\n\t\t\tfor(int i=0;i<(1<<n);i++) {\n\t\t\t\tint u = 0;\n\t\t\t\tfor(int j=0;j<n;j++)if((subs[j].mask&i) == subs[j].mask) {\n\t\t\t\t\tu += subs[j].c * ( (i>>j) & 1 );\n\t\t\t\t}\n//\t\t\t\tdebug(\" \", i, u);\n\t\t\t\tif( u >= U ) min = min(min, Integer.bitCount(i));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);*/\n\t\t\tdp = new int[1<<n];\n\t\t\tfill(dp, -1);\n\t\t\tSystem.out.println(solve(U, 0));\n\t\t}\n\t}\n\t\n\tint[] dp;\n\tint solve(int u, int S) {\n\t\tif( dp[S] >= 0 ) return dp[S];\n\t\tif( u <= 0 ) return dp[S] = 0;\n\t\tif( S+1 == (1<<n) ) return dp[S] = 0;\n\t\tint min = INF;\n\t\tfor(int i=0;i<n;i++) if(((S>>i)&1) == 0 && (m[i]&S) == m[i]) {\n\t\t\tmin = min(min, solve(u-c[i], S|(1<<i))+1);\n\t\t}\n\t\t\n\t\treturn dp[S] = min;\n\t}\n\t\n\tclass Sub {\n\t\tint c, mask;\n\t\tSub(int c, int mask) {\n\t\t\tthis.c = c;\n\t\t\tthis.mask = mask;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid debug(Object...os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n=sc.nextInt(),U=sc.nextInt();\n\t\t\tif(n==0&&U==0)return;\n\t\t\tboolean[][] f=new boolean[n][n];\n\t\t\tint[] c=new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc[i]=sc.nextInt();\n\t\t\t\tint k=sc.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tf[i][sc.nextInt()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif(f[i][k]&&f[k][j])f[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] bit=new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif(f[i][j])bit[i]|=1<<j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res=n;\n\t\t\tfor (int mask = 0; mask < 1<<n; mask++) {\n\t\t\t\tint u = 0;\n\t\t\t\tboolean ok=true;\n\t\t\t\tfor (int i = 0; i < n; i++)if(((mask>>i)&1)==1) {\n\t\t\t\t\tu+=c[i];\n\t\t\t\t\tif((bit[i] & mask)!=bit[i])ok=false;\n\t\t\t\t}\n\t\t\t\tif(u>=U && ok)res=min(res,Integer.bitCount(mask));\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans == one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(a, one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = num[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(num);\n\t\t\tint sum = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tsum += num[i];\n\t\t\t\tif (sum >= u) {\n\t\t\t\t\tm = n - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = new boolean[1 << n];\n\t\t\tfor (int i = m; i < n; i++) {\n\t\t\t\tif (slove(0, 0, 0, i)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tArrays.fill(v, false);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int bit, int one, int have, int depth) {\n\t\tif (u <= have)\n\t\t\treturn true;\n\t\tif (one == depth)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tif (slove(a, one + 1, have + unit[i], depth))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint m;\n\tint n, u;\n\tint[] need, unit, num;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = num[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(num);\n\t\t\tint sum = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tsum += num[i];\n\t\t\t\tif (sum >= u) {\n\t\t\t\t\tm = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = m; i < n; i++) {\n\t\t\t\tv = new boolean[1 << n];\n\t\t\t\tif (slove(0, 0, 0, i)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int bit, int one, int have, int depth) {\n\t\tif (u <= have)\n\t\t\treturn true;\n\t\tif (one == depth)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tif (slove(a, one + 1, have + unit[i], depth))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint m;\n\tint n, u;\n\tint[] need, unit, num;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\t\tif (ans - 1 == one)\n\t\t\treturn;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\t\tif (ans - 1 == one)\n\t\t\treturn;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(a, one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv = new boolean[1 << n];\n\t\t\tPriorityQueue<Point> deque = new PriorityQueue<Point>();\n\t\t\tdeque.offer(new Point(0, 0, 0));\n\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tif (p.have >= u) {\n\t\t\t\t\tSystem.out.println(p.one);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint a = p.bit | (1 << i);\n\t\t\t\t\tif (v[a] || (a | need[i]) != a)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tv[a] = true;\n\t\t\t\t\tdeque.offer(new Point(a, p.one + 1, p.have + unit[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint bit, one, have;\n\n\t\tpublic Point(int bit, int one, int have) {\n\t\t\tsuper();\n\t\t\tthis.bit = bit;\n\t\t\tthis.one = one;\n\t\t\tthis.have = have;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [bit=\" + bit + \", one=\" + one + \", have=\" + have\n\t\t\t\t\t+ \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (one == o.one)\n\t\t\t\treturn o.have - have;\n\t\t\treturn one - o.one;\n\t\t}\n\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv = new boolean[1 << n];\n\t\t\tDeque<Point> deque = new ArrayDeque<Point>();\n\t\t\tdeque.offer(new Point(0, 0, 0));\n\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tif (p.have >= u) {\n\t\t\t\t\tSystem.out.println(p.one);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint a = p.bit | (1 << i);\n\t\t\t\t\tif (v[a] || (a | need[i]) != a)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tv[a] = true;\n\t\t\t\t\tdeque.offer(new Point(a, p.one + 1, p.have + unit[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Point {\n\t\tint bit, one, have;\n\n\t\tpublic Point(int bit, int one, int have) {\n\t\t\tsuper();\n\t\t\tthis.bit = bit;\n\t\t\tthis.one = one;\n\t\t\tthis.have = have;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [bit=\" + bit + \", one=\" + one + \", have=\" + have\n\t\t\t\t\t+ \"]\";\n\t\t}\n\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = num[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(num);\n\t\t\tint sum = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tsum += num[i];\n\t\t\t\tif (sum >= u) {\n\t\t\t\t\tm = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tv = new boolean[1 << n];\n\t\t\t\tif (slove(0, 0, 0, i)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int bit, int one, int have, int depth) {\n\t\tif (u <= have)\n\t\t\treturn true;\n\t\tif (one == depth)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tif (slove(a, one + 1, have + unit[i], depth))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint m;\n\tint n, u;\n\tint[] need, unit, num;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Course Planning for Lazy Students\npublic class Main{\n\n\tint n, u;\n\tint[] c, r;\n\tint ans;\n\tboolean[] v;\n\t\n\tvoid dfs(int s, int sum, int depth){\n\t\tif(u<=sum)ans = depth;\n\t\tif(ans<=depth)return;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((s&(1<<i))>0)continue;\n\t\t\tif((r[i]&s)!=r[i])continue;\n\t\t\tint x = s|1<<i;\n\t\t\tif(v[x])continue;\n\t\t\tv[x] = true;\n\t\t\tdfs(x, sum+c[i], depth+1);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tu = sc.nextInt();\n\t\t\tif((n|u)==0)break;\n\t\t\tc = new int[n];\n\t\t\tr = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t\tint x = 0;\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++)x|=1<<sc.nextInt();\n\t\t\t\tr[i] = x;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1<<n];\n\t\t\tfor(int i=0;i<n;i++)if(r[i]==0){v[1<<i]=true;dfs(1<<i,c[i],1);}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tgain = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = gain[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0, -1);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have, int r) {\n\t\tif (ans <= one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = r + 1; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i], i);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit, gain;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\tpublic static final int MAX = 20;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] req_bit = new int[MAX];\n\t\tint[] amounts = new int[MAX];\n\t\tint[] DP = new int[1 << MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int U = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && U == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tamounts[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfinal int k = sc.nextInt();\n\t\t\t\tint bit = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tbit |= 1 << (sc.nextInt());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treq_bit[i] = bit;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(DP, INF);\n\t\t\tDP[0] = 0;\n\t\t\t\n\t\t\tfinal int bit_size = 1 << n;\n\t\t\tfor(int bit = 0; bit < bit_size; bit++){\n\t\t\t\tif(DP[bit] >= INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int next = 0; next < n; next++){\n\t\t\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if((bit & (req_bit[next])) != req_bit[next]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tDP[bit | (1 << next)] = Math.min(DP[bit | (1 << next)], DP[bit] + amounts[next]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < bit_size; i++){\n\t\t\t\tSystem.out.println(Integer.toBinaryString(i) + \"\\t : \" + DP[i]);\n\t\t\t}\n\t\t\t*/\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i < bit_size; i++){\n\t\t\t\tif(DP[i] >= U && DP[i] < INF){\n\t\t\t\t\t//System.out.println(Integer.toBinaryString(i) + \"\\t : \" + DP[i]);\n\t\t\t\t\tmin = Math.min(min, Integer.bitCount(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<Item> items;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint U = sc.nextInt();\n\t\t\tif (N == 0 && U == 0) break;\n\t\t\titems = new ArrayList<Item>();\n\t\t\tArrayList<ArrayList<Integer>> c = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tItem item = new Item(sc.nextInt());\n\t\t\t\titems.add(item);\n\t\t\t\tArrayList<Integer> cs = new ArrayList<Integer>();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tcs.add(r);\n\t\t\t\t}\n\t\t\t\tc.add(cs);\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j : c.get(i)) {\n\t\t\t\t\titems.get(i).child.add(items.get(j));\n\t\t\t\t\titems.get(j).parent.add(items.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayList<Item> sorted = sort();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsorted.get(i).index = i;\n\t\t\t}\n\t\t\tint ans = N;\n\t\t\tint[] units = new int[1 << N];\n\t\t\tArrays.fill(units, -1);\n\t\t\tunits[0] = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint mask = sorted.get(i).mask() - (1 << i);\n\t\t\t\tfor (int j = 0; j < (1 << i); ++j) {\n\t\t\t\t\tif (units[j] == -1 || (j & mask) != mask) continue;\n\t\t\t\t\tint newUnits = units[j] + sorted.get(i).unit;\n\t\t\t\t\tunits[j + (1 << i)] = newUnits;\n\t\t\t\t\tint count = Integer.bitCount(j) + 1;\n\t\t\t\t\tif (newUnits >= U && count < ans) {\n\t\t\t\t\t\tans = count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic ArrayList<Item> sort() {\n\t\tArrayList<Item> sorted = new ArrayList<Item>();\n\t\tfor (int i = 0; i < items.size(); ++i) {\n\t\t\tdfs(sorted, items.get(i));\n\t\t}\n\t\tCollections.reverse(sorted);\n\t\treturn sorted;\n\t}\n\n\tstatic void dfs(ArrayList<Item> sorted, Item cur) {\n\t\tif (cur.visited) return;\n\t\tcur.visited = true;\n\t\tfor (Item c : cur.child) {\n\t\t\tdfs(sorted, c);\n\t\t}\n\t\tsorted.add(cur);\n\t}\n\n\tstatic class Item {\n\t\tint unit;\n\t\tArrayList<Item> child = new ArrayList<Item>();\n\t\tArrayList<Item> parent = new ArrayList<Item>();\n\t\tboolean visited = false;\n\t\tint index;\n\n\t\tItem(int c) {\n\t\t\tthis.unit = c;\n\t\t}\n\n\t\tint mask() {\n\t\t\tint ret = 1 << index;\n\t\t\tfor (Item p : parent) {\n\t\t\t\tret |= p.mask();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint U = sc.nextInt();\n\t\t\tif( (n|U) == 0 ) break;\n\t\t\tSub[] subs = new Sub[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint mask = 0;\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tmask += (1<<r);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsubs[i] = new Sub(c, mask);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n//\t\t\tfor(Sub s: subs) debug(s.c, s.mask);\n\t\t\t\n\t\t\tint min = INF;\n\t\t\tfor(int i=0;i<(1<<n);i++) {\n\t\t\t\tint u = 0;\n\t\t\t\tfor(int j=0;j<n;j++)if((subs[j].mask&i) == subs[j].mask) {\n\t\t\t\t\tu += subs[j].c * ( (i>>j) & 1 );\n\t\t\t\t}\n//\t\t\t\tdebug(\" \", i, u);\n\t\t\t\tif( u >= U ) min = min(min, Integer.bitCount(i));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tclass Sub {\n\t\tint c, mask;\n\t\tSub(int c, int mask) {\n\t\t\tthis.c = c;\n\t\t\tthis.mask = mask;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tint U;\n\tSub[] subs;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tU = sc.nextInt();\n\t\t\tif( (n|U) == 0 ) break;\n\t\t\tsubs = new Sub[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint mask = 0;\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tmask += (1<<r);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsubs[i] = new Sub(c, mask);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n//\t\t\tfor(Sub s: subs) debug(s.c, s.mask);\n\t\t\t\n/*\t\t\tint min = INF;\n\t\t\tfor(int i=0;i<(1<<n);i++) {\n\t\t\t\tint u = 0;\n\t\t\t\tfor(int j=0;j<n;j++)if((subs[j].mask&i) == subs[j].mask) {\n\t\t\t\t\tu += subs[j].c * ( (i>>j) & 1 );\n\t\t\t\t}\n//\t\t\t\tdebug(\" \", i, u);\n\t\t\t\tif( u >= U ) min = min(min, Integer.bitCount(i));\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);*/\n\t\t\tdp = new int[1<<n];\n\t\t\tfill(dp, -1);\n\t\t\tSystem.out.println(solve(U, 0));\n\t\t}\n\t}\n\t\n\tint[] dp;\n\tint solve(int u, int S) {\n\t\tif( dp[S] >= 0 ) return dp[S];\n\t\tif( u <= 0 ) return dp[S] = 0;\n\t\tif( S+1 == (1<<n) ) return dp[S] = 0;\n\t\tint min = INF;\n\t\tfor(int i=0;i<n;i++) if(((S>>i)&1) == 0 && (subs[i].mask&S) == subs[i].mask) {\n\t\t\tmin = min(min, solve(u-subs[i].c, S|(1<<i))+1);\n\t\t}\n\t\t\n\t\treturn dp[S] = min;\n\t}\n\t\n\tclass Sub {\n\t\tint c, mask;\n\t\tSub(int c, int mask) {\n\t\t\tthis.c = c;\n\t\t\tthis.mask = mask;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tgain = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = gain[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans <= one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit, gain;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tgain = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = gain[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(gain);\n\t\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\t\tgain[i] += gain[i + 1];\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans <= one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\t\tif (have + gain[n - (ans - one - 1) - 1] < u)\n\t\t\treturn;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (((bit >> i) & 1) == 1)\n\t\t\t\tcontinue;\n\t\t\tif ((need[i] & bit) != need[i])\n\t\t\t\tcontinue;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit, gain;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic ArrayList<Item> items;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint U = sc.nextInt();\n\t\t\tif (N == 0 && U == 0) break;\n\t\t\titems = new ArrayList<Item>();\n\t\t\tArrayList<ArrayList<Integer>> c = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tItem item = new Item(sc.nextInt());\n\t\t\t\titems.add(item);\n\t\t\t\tArrayList<Integer> cs = new ArrayList<Integer>();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tcs.add(r);\n\t\t\t\t}\n\t\t\t\tc.add(cs);\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j : c.get(i)) {\n\t\t\t\t\titems.get(i).parent.add(items.get(j));\n\t\t\t\t\titems.get(j).child.add(items.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayList<Item> sorted = sort();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsorted.get(i).index = i;\n\t\t\t}\n\t\t\tint ans = N;\n\t\t\tint[] units = new int[1 << N];\n\t\t\tArrays.fill(units, -1);\n\t\t\tunits[0] = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint mask = sorted.get(i).mask() - (1 << i);\n\t\t\t\tfor (int j = 0; j < (1 << i); ++j) {\n\t\t\t\t\tif (units[j] == -1 || (j & mask) != mask) continue;\n\t\t\t\t\tint newUnits = units[j] + sorted.get(i).unit;\n\t\t\t\t\tunits[j + (1 << i)] = newUnits;\n\t\t\t\t\tint count = Integer.bitCount(j) + 1;\n\t\t\t\t\tif (newUnits >= U && count < ans) {\n\t\t\t\t\t\tans = count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic ArrayList<Item> sort() {\n\t\tArrayList<Item> sorted = new ArrayList<Item>();\n\t\tfor (int i = 0; i < items.size(); ++i) {\n\t\t\tdfs(sorted, items.get(i));\n\t\t}\n\t\tCollections.reverse(sorted);\n\t\treturn sorted;\n\t}\n\n\tstatic void dfs(ArrayList<Item> sorted, Item cur) {\n\t\tif (cur.visited) return;\n\t\tcur.visited = true;\n\t\tfor (Item c : cur.child) {\n\t\t\tdfs(sorted, c);\n\t\t}\n\t\tsorted.add(cur);\n\t}\n\n\tstatic class Item {\n\t\tint unit;\n\t\tArrayList<Item> child = new ArrayList<Item>();\n\t\tArrayList<Item> parent = new ArrayList<Item>();\n\t\tboolean visited = false;\n\t\tint index;\n\n\t\tItem(int c) {\n\t\t\tthis.unit = c;\n\t\t}\n\n\t\tint mask() {\n\t\t\tint ret = 1 << index;\n\t\t\tfor (Item p : parent) {\n\t\t\t\tret |= p.mask();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn this.index + \" \" + this.unit + \" \" + this.child;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = num[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrays.sort(num);\n\t\t\tint sum = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tsum += num[i];\n\t\t\t\tif (sum >= u) {\n\t\t\t\t\tm = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = m; i < n; i++) {\n\t\t\t\tv = new boolean[1 << n];\n\t\t\t\tif (slove(0, 0, 0, i)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int bit, int one, int have, int depth) {\n\t\tif (u <= have)\n\t\t\treturn true;\n\t\tif (one == depth)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tif (slove(a, one + 1, have + unit[i], depth))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint m;\n\tint n, u;\n\tint[] need, unit, num;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.math.BigInteger.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid debug(Object...os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n=sc.nextInt(),U=sc.nextInt();\n\t\t\tif(n==0&&U==0)return;\n\t\t\tboolean[][] f=new boolean[n][n];\n\t\t\tint[] c=new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc[i]=sc.nextInt();\n\t\t\t\tint k=sc.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tf[i][sc.nextInt()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif(f[i][k]&&f[k][j])f[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] bit=new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif(f[i][j])bit[i]|=1<<j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res=n;\n\t\t\tfor (int mask = 0; mask < 1<<n; mask++)if(Integer.bitCount(mask)<res) {\n\t\t\t\tint u = 0;\n\t\t\t\tboolean ok=true;\n\t\t\t\tfor (int i = 0; i < n; i++)if(((mask>>i)&1)==1) {\n\t\t\t\t\tu+=c[i];\n\t\t\t\t\tif((bit[i] & mask)!=bit[i])ok=false;\n\t\t\t\t}\n\t\t\t\tif(u>=U && ok)res=min(res,Integer.bitCount(mask));\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tgain = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = gain[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(gain);\n\t\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\t\tgain[i] += gain[i + 1];\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = n;\n\t\t\tv = new boolean[1 << n];\n\t\t\tslove(0, 0, 0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void slove(int bit, int one, int have) {\n\t\tif (ans <= one)\n\t\t\treturn;\n\t\tif (have >= u) {\n\t\t\tans = one;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tv[a] = true;\n\t\t\tslove(bit | (1 << i), one + 1, have + unit[i]);\n\t\t}\n\t}\n\n\tint n, u;\n\tint[] need, unit, gain;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tv = new boolean[1 << n];\n\t\t\t\tif (slove(0, 0, 0, i)) {\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int bit, int one, int have, int depth) {\n\t\tif (u <= have)\n\t\t\treturn true;\n\t\tif (one == depth)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = bit | (1 << i);\n\t\t\tif (v[a] || (bit | need[i]) != bit)\n\t\t\t\tcontinue;\n\t\t\tif (slove(a, one + 1, have + unit[i], depth))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tu = scanner.nextInt();\n\t\t\tif ((n | u) == 0)\n\t\t\t\tbreak;\n\t\t\tneed = new int[n];\n\t\t\tint all = 0;\n\t\t\tunit = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tunit[i] = scanner.nextInt();\n\t\t\t\tall += unit[i];\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tneed[i] |= (1 << x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all == u) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv = new boolean[1 << n];\n\t\t\tDeque<Point> deque = new ArrayDeque<Point>();\n\t\t\tdeque.offer(new Point(0, 0, 0));\n\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tif (p.have == u) {\n\t\t\t\t\tSystem.out.println(p.one);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint a = p.bit | (1 << i);\n\t\t\t\t\tif (v[a] || (a | need[i]) != a)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tv[a] = true;\n\t\t\t\t\tdeque.offer(new Point(a, p.one + 1, p.have + unit[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Point {\n\t\tint bit, one, have;\n\n\t\tpublic Point(int bit, int one, int have) {\n\t\t\tsuper();\n\t\t\tthis.bit = bit;\n\t\t\tthis.one = one;\n\t\t\tthis.have = have;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [bit=\" + bit + \", one=\" + one + \", have=\" + have\n\t\t\t\t\t+ \"]\";\n\t\t}\n\n\t}\n\n\tint n, u;\n\tint[] need, unit;\n\tint ans;\n\tboolean[] v;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n \nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n \n \nclass Sol{\n\t \n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t \n\tstatic int n;\n\tstatic int U;\n \n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t \n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n \n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t \n\t\tClassSet C=null;\n\t\tint ans=21;\n\t\t \n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\t//if((ss&(0x1<<i))==0){\n\t\t\t\t\tC=new ClassSet(ss|ToGet[i].State);\n\t\t\t\t\tif(C.Score>=U && C.Count<ans)ans=C.Count;\n\t\t\t\t\tif(C.Score<U)Hash[i+1].Add(C.State);\n\t\t\t\t//}\n\t\t\t}\n//Console.WriteLine(\"Hash[{0}].Count={1}\",i+1,Hash[i+1].Count);\n\t\t}\n\t\t \n\t\tConsole.WriteLine(ans);\n \n\t}\n\t \n\tint search(int d){\n \n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t \n \n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n \n \n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tint s=state;\n\t\t\t\tint i=0;\n\t\t\t\tfor(;s>0;s=s>>1){\n\t\t\t\t\tscore+=(s&0x1)*ScoreTable[i++];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n \n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n \n \nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t\n\t\tint ans=21;\n\t\t\n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\tif((ss&(0x1<<i))==0){\n\t\t\t\t\tif(Score(ss|(0x1<<i))>=U && Count(ss|(0x1<<i))<ans)ans=Count(ss|(0x1<<i));\n\t\t\t\t\tHash[i+1].Add(ss|(0x1<<i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(ans);\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint Count(int state){\n\t\tint i=state;\n\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\treturn i;\n\t}\n\n\tint Score(int state){\n\t\tint score=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t}\n\t\treturn score;\n\t}\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t\n\t\tClassSet C=null;\n\t\tint ans=21;\n\t\t\n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\tC=new ClassSet(ss|ToGet[i].State);\n\t\t\t\tif(C.Score>=U && C.Count<ans)ans=C.Count;\n\t\t\t\tHash[i+1].Add(C.State);\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(ans);\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int> Hash=new HashSet<int>();\n\t\tList<ClassSet> L=new List<ClassSet>();\n\t\t\n\t\tint st=0;\n\t\tint k=0;\n\t\tfor(int i=0;i<(0x1<<n);i++){\n\t\t\tst=0;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tif((i&(0x1<<k))!=0)st=st|ToGet[k].State;\n\t\t\t}\n\t\t\tif(!Hash.Contains(st)){\n\t\t\t\tif((new ClassSet(st)).Score>=U)L.Add(new ClassSet(st));\n\t\t\t}\n\t\t\tHash.Add(st);\n\t\t}\n\t\t\n\t\t//CompareToの実装から\n\t\t//　単位数小⇒　単位数同じ（科目数大⇒科目数小）⇒単位数大　の向きにSortされる\n\t\tL.Sort();\n\n\t\t//uboundでターゲットの科目数をサーチ\n\t\tint left=0;\n\t\tint right=L.Count-1;\n\t\tint mid=(right+left)/2;\n\t\twhile(mid!=left&&mid!=right){\n\n\t\t\tif(L[mid].Score<=U){\n\t\t\t\tleft=mid;\n\t\t\t}\n\t\t\tif(L[mid].Score>U){\n\t\t\t\tright=mid;\n\t\t\t}\n\t\t\tmid=(right+left)/2;\n\t\t}\n\t\t//微調整。。。\n\t\twhile( L[mid].Score<=U && mid<L.Count-1 )mid++;\n\t\twhile( L[mid].Score>U && mid>0 )mid--;\n\t\t\n\t\tConsole.WriteLine(L[mid].Count);\n\t\t\n\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t//for(int i=0;i<n;i++)Table[i]=0x1<<i;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n\t\t}\n\t\t\n\t\t//優先度はClassSetで定義\n\t\tPriorityQueue<ClassSet> PQ=new PriorityQueue<ClassSet>();\n\t\tfor(int i=0;i<n;i++)PQ.Push(ToGet[i]);\n\t\t\n\t\tClassSet C=null;\n\t\twhile(PQ.Count>0){\n\t\t\tC=PQ.Top;PQ.Pop();\n\t\t\tif(C.Score==U){\n\t\t\t\tConsole.WriteLine(C.Count);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((C.State|ToGet[j].State)!=C.State){\n\t\t\t\t\tPQ.Push(new ClassSet(C.State|ToGet[j].State));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tConsole.WriteLine(n);\n\t\treturn;\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//科目数少ない方が優先度高い(+)\n\t\t\tif(T.Count-this.Count!=0)return T.Count-this.Count;\n\t\t\t//科目数同じなら単位数多い方が優先度高い\n\t\t\treturn this.Score-T.Score;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\nclass dbg{\n\tpublic static void Write(){\n\t\tConsole.WriteLine(\"ok\");\n\t}\n\tpublic static void Write(int i){\n\t\tConsole.WriteLine(i);\n\t}\n}\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t//for(int i=0;i<n;i++)Table[i]=0x1<<i;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n\t\t}\n\t\t\n\t\t//優先度はClassSetで定義\n\t\tPriorityQueue<ClassSet> PQ=new PriorityQueue<ClassSet>();\n\t\tfor(int i=0;i<n;i++)PQ.Push(ToGet[i]);\n\t\t\n\t\tClassSet C=null;\n\t\twhile(PQ.Count>0){\n\t\t\tC=PQ.Top;PQ.Pop();\n\t\t\tif(C.Score==U){\n\t\t\t\tConsole.WriteLine(C.Count);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((C.State|ToGet[j].State)!=C.State){\n\t\t\t\t\tPQ.Push(new ClassSet(C.State|ToGet[j].State));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tConsole.WriteLine(n);\n\t\treturn;\n\t}\n\t\n\tint search(int d){\n//dbg.Write(d);\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tpublic　ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//科目数少ない方が優先度高い(+)\n\t\t\tif(T.Count-this.Count!=0)return T.Count-this.Count;\n\t\t\t//科目数同じなら単位数多い方が優先度高い\n\t\t\treturn this.Score-T.Score;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t//for(int i=0;i<n;i++)Table[i]=0x1<<i;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n\t\t}\n\t\t\n\t\t//優先度はClassSetで定義\n\t\tPriorityQueue<ClassSet> PQ=new PriorityQueue<ClassSet>();\n\t\tfor(int i=0;i<n;i++)PQ.Push(ToGet[i]);\n\t\t\n\t\tClassSet C=null;\n\t\twhile(PQ.Count>0){\n\t\t\tC=PQ.Top;PQ.Pop();\n\t\t\tif(C.Score==U){\n\t\t\t\tConsole.WriteLine(C.Count);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((C.State|ToGet[j].State)!=C.State){\n\t\t\t\t\tPQ.Push(new ClassSet(C.State|ToGet[j].State));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tConsole.WriteLine(n);\n\t\treturn;\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tpublic　ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//科目数少ない方が優先度高い(+)\n\t\t\tif(T.Count-this.Count!=0)return T.Count-this.Count;\n\t\t\t//科目数同じなら単位数多い方が優先度高い\n\t\t\treturn this.Score-T.Score;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tint[] ToGet=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=search(i);\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tDictionary<int,int>[] Dict=new Dictionary<int,int>[n+1];\n\t\t\n\t\tint ans=21;\n\t\t\n\t\tDict[0]=new Dictionary<int,int>();\n\t\tDict[0].Add(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tDict[i+1]=new Dictionary<int,int>();\n\t\t\tforeach(KeyValuePair<int,int> kvp in Dict[i]){\n\t\t\t\tDict[i+1].Add(kvp.Key,kvp.Value);\n\t\t\t\tif(Dict[i].ContainsKey(kvp.Key|(0x1<<i))==false)Dict[i+1].Add(kvp.Key|(0x1<<i),Score(kvp.Key|(0x1<<i)));\n\t\t\t\tif(Score(kvp.Key|(0x1<<i))==U && Count(kvp.Key|(0x1<<i))<ans)ans=Count(kvp.Key|(0x1<<i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(ans);\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint Count(int state){\n\t\tint i=state;\n\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\treturn i;\n\t}\n\n\tint Score(int state){\n\t\tint score=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t}\n\t\treturn score;\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n \nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n \n \nclass Sol{\n\t \n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t \n\tstatic int n;\n\tstatic int U;\n \n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t \n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n \n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t \n\t\tClassSet C=null;\n\t\tint ans=21;\n\t\t \n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\t//if((ss&(0x1<<i))==0){\n\t\t\t\t\tC=new ClassSet(ss|ToGet[i].State);\n\t\t\t\t\tif(C.Score>=U && C.Count<ans)ans=C.Count;\n\t\t\t\t\tif(C.Score<U)Hash[i+1].Add(C.State);\n\t\t\t\t//}\n\t\t\t}\nConsole.WriteLine(\"Hash[{0}].Count={1}\",i+1,Hash[i+1].Count);\n\t\t}\n\t\t \n\t\tConsole.WriteLine(ans);\n \n\t}\n\t \n\tint search(int d){\n \n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t \n \n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n \n \n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n \n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n \n \nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t\n\t\tint ans=21;\n\t\t\n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\tif((ss&(0x1<<i))==0){\n\t\t\t\t\tif(Score(ss|(0x1<<i))>=U && Count(ss|(0x1<<i))<ans)ans=Count(ss|(0x1<<i));\n\t\t\t\t\tHash[i+1].Add(ss|(0x1<<i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(ans);\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int Count(int state){\n\t\tint i=state;\n\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\treturn i;\n\t}\n\n\tstatic int Score(int state){\n\t\tint score=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t}\n\t\treturn score;\n\t}\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int> Hash=new HashSet<int>();\n\t\tList<ClassSet> L=new List<ClassSet>();\n\t\t\n\t\tint st=0;\n\t\tint k=0;\n\t\tfor(int i=0;i<(0x1<<n);i++){\n\t\t\tst=0;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tif((i&(0x1<<k))!=0)st=st|ToGet[k].State;\n\t\t\t}\n\t\t\tif(!Hash.Contains(st)){\n\t\t\t\tL.Add(new ClassSet(st));\n\t\t\t}\n\t\t\tHash.Add(st);\n\t\t}\n\t\t\n\t\t//CompareToの実装から\n\t\t//　単位数小⇒　単位数同じ（科目数大⇒科目数小）⇒単位数大　の向きにSortされる\n\t\tL.Sort();\n\n\t\t//uboundでターゲットの科目数をサーチ\n\t\tint left=0;\n\t\tint right=L.Count-1;\n\t\tint mid=(right+left)/2;\n\t\twhile(mid!=left&&mid!=right){\n\n\t\t\tif(L[mid].Score<=U){\n\t\t\t\tleft=mid;\n\t\t\t}\n\t\t\tif(L[mid].Score>U){\n\t\t\t\tright=mid;\n\t\t\t}\n\t\t\tmid=(right+left)/2;\n\t\t}\n\t\t//微調整。。。\n\t\twhile( L[mid].Score<=U && mid<L.Count-1 )mid++;\n\t\twhile( L[mid].Score>U && mid>0 )mid--;\n\t\t\n\t\tConsole.WriteLine(L[mid].Count);\n\t\t\n\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t\n\t\tClassSet C=null;\n\t\tint ans=21;\n\t\t\n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\tif((ss&(0x1<<i))!=0){\n\t\t\t\t\tC=new ClassSet(ss|ToGet[i].State);\n\t\t\t\t\tif(C.Score>=U && C.Count<ans)ans=C.Count;\n\t\t\t\t\tHash[i+1].Add(C.State);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(ans);\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n\n\nclass Sol{\n\t\n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t\n\tstatic int n;\n\tstatic int U;\n\n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n\n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t\n\t\tClassSet C=null;\n\t\tint ans=21;\n\t\t\n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\tif((ss&(0x1<<i))==0){\n\t\t\t\t\tC=new ClassSet(ss|ToGet[i].State);\n\t\t\t\t\tif(C.Score>=U && C.Count<ans)ans=C.Count;\n\t\t\t\t\tHash[i+1].Add(C.State);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(ans);\n\n\t}\n\t\n\tint search(int d){\n\n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n\n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n\n\nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n \nclass TEST{\n\tstatic void Main(){\n\twhile(true){\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tif(s[0]==\"0\" && s[1]==\"0\")break;\n\t\tSol mySol=new Sol(int.Parse(s[0]),int.Parse(s[1]));\n\t\tmySol.Solve();\n\t}\n\t}\n}\n \n \nclass Sol{\n\t \n\tstatic int[] Table;\n\tstatic int[] ScoreTable;\n\t \n\tstatic int n;\n\tstatic int U;\n \n\tpublic Sol(int n_,int U_){\n\t\tn=n_;U=U_;\n\t\tScoreTable=new int[n];\n\t\tTable=new int[n];\n\t\tfor(int i=0;i<n;i++)Table[i]=0;\n\t\t \n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tScoreTable[i]=d[0];\n\t\t\tfor(int j=0;j<d[1];j++){\n\t\t\t\tTable[i]=Table[i]|(0x1<<d[j+2]);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tpublic void Solve(){\n\t\tClassSet[] ToGet=new ClassSet[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tToGet[i]=new ClassSet(search(i));\n//Console.Write(\"{0}-th\",i);for(int j=0;j<n;j++){if((ToGet[i].State&(0x1<<j))>0)Console.Write(\" {0}\",j);}Console.WriteLine(\"\");\n\t\t}\n \n\t\tHashSet<int>[] Hash=new HashSet<int>[n+1];\n\t\t \n\t\tClassSet C=null;\n\t\tint ans=21;\n\t\t \n\t\tHash[0]=new HashSet<int>();\n\t\tHash[0].Add(0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tHash[i+1]=new HashSet<int>();\n\t\t\tforeach(int ss in Hash[i]){\n\t\t\t\tHash[i+1].Add(ss);\n\t\t\t\t//if((ss&(0x1<<i))==0){\n\t\t\t\t\tC=new ClassSet(ss|ToGet[i].State);\n\t\t\t\t\tif(C.Score>=U && C.Count<ans)ans=C.Count;\n\t\t\t\t\tif(C.Score<U)Hash[i+1].Add(C.State);\n\t\t\t\t//}\n\t\t\t}\n//Console.WriteLine(\"Hash[{0}].Count={1}\",i+1,Hash[i+1].Count);\n\t\t}\n\t\t \n\t\tConsole.WriteLine(ans);\n \n\t}\n\t \n\tint search(int d){\n \n\t\t//dをとるのに必要な全科目を調べる\n\t\tint ret=0x1<<d;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((Table[d]&(0x1<<i))>0)ret=ret|search(i);\n\t\t}\n\t\treturn ret;\n\t}\n\t \n \n\tclass ClassSet:IComparable<ClassSet>{\n\t\tint state;\n\t\tpublic int State{\n\t\t\tget{return state;}\n\t\t}\n\t\tpublic int Count{\n\t\t\tget{\n\t\t\t\tint i=state;\n\t\t\t\ti=(i&0x55555555)+((i>>1)&0x55555555);\n\t\t\t\ti=(i&0x33333333)+((i>>2)&0x33333333);\n\t\t\t\ti=(i&0x0F0F0F0F)+((i>>4)&0x0F0F0F0F);\n\t\t\t\ti=(i&0x00FF00FF)+((i>>8)&0x00FF00FF);\n\t\t\t\ti=(i&0x0000FFFF)+((i>>16)&0x0000FFFF);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n \n \n\t\tpublic int Score{\n\t\t\tget{\n\t\t\t\tint score=0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif((state&(0x1<<i))>0)score+=ScoreTable[i];\n\t\t\t\t}\n\t\t\t\treturn score;\n\t\t\t}\n\t\t}\n\t\tpublic ClassSet(int state_){\n\t\t\tstate=state_;\n\t\t}\n \n\t\tpublic int CompareTo(ClassSet T){\n\t\t\t//単位数多い方が優先度高い(+)\n\t\t\tif(this.Score!=T.Score)return this.Score-T.Score;\n\t\t\t//単位数同じなら科目数少ない方が優先度高い\n\t\t\treturn T.Count-this.Count;\n\t\t}\n\t}\n}\n \n \nstatic class dbg{\n\tpublic static void w(String s){\n\t\tConsole.WriteLine(s);\n\t}\n\tpublic static void w(int d){\n\t\tConsole.WriteLine(d);\n\t}\n\tpublic static void w(long d){\n\t\tConsole.WriteLine(d);\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1032.rb: Course Planning for Lazy Students\n#\n\n### main\n\nloop do\n  n, u = gets.split.map(&:to_i)\n  break if n == 0 && u == 0\n\n  finished = n.times.map{false}\n  cis = []\n  kis = []\n  follows = n.times.map{[]}\n\n  for i in (0...n)\n    ci, ki, *ris = gets.split.map(&:to_i)\n    cis << ci\n    kis << ki\n\n    for ri in ris\n      follows[ri] << i\n    end\n  end\n\n  sumc = 0\n  count = 0\n\n  while sumc < u\n    max_ci = 0\n    max_i = nil\n\n    for i in (0...n)\n      if ! finished[i] && kis[i] == 0 && max_ci < cis[i]\n        max_ci = cis[i]\n        max_i = i\n      end\n    end\n    break if max_i.nil?\n\n    finished[max_i] = true\n    sumc += max_ci\n    count += 1\n\n    for ri in follows[max_i]\n      kis[ri] -= 1\n    end\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1032.rb: Course Planning for Lazy Students\n#\n\n### subroutines\n\ndef count_rec(k, num, csum, bits)\n  return num if csum >= $u\n  return $n if k >= $n\n\n  min_num = count_rec(k + 1, num, csum, bits)\n\n  ci, bi = $ncrs[k]\n  if (bits & bi) == bi\n    num0 = count_rec(k + 1, num + 1, csum + ci, bits | (1 << k))\n    min_num = num0 if min_num > num0\n  end\n\n  min_num\nend\n\n### main\n\nloop do\n  $n, $u = gets.split.map(&:to_i)\n  break if $n == 0 && $u == 0\n\n  crs = []\n\n  for i in (0...$n)\n    ci, ki, *ris = gets.split.map(&:to_i)\n    crs << [i, ci, ki, ris]\n  end\n\n  newseq = []\n  newid = 0\n  q = crs.clone\n\n  while newid < $n\n    cr = q.shift\n    i, ci, ki, ris = cr\n\n    if ris.select{|ri| newseq[ri].nil?}.length == 0\n      newseq[i] = newid\n      newid += 1\n    else\n      q << cr\n    end\n  end\n  #p newseq\n\n  $ncrs = []\n  for cr in crs\n    i, ci, ki, ris = cr\n\n    nid = newseq[i]\n    nrib = ris.inject(0){|b, ri| b | (1 << newseq[ri])}\n\n    $ncrs[nid] = [ci, nrib]\n  end\n  #p $ncrs\n\n  min_num = count_rec(0, 0, 0, 0)\n  puts min_num\nend"
  },
  {
    "language": "Python",
    "code": "code=\"\"\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n\"\"\"\n\nimport os,tempfile\n(_,filename)=tempfile.mkstemp(\".cpp\")\n\nf=open(filename,\"w\")\nf.write(code)\nf.close()\n\nos.system(\"g++ -std=c++0x {} -o ./a.out\".format(filename))\nos.system(\"./a.out\")"
  },
  {
    "language": "Python",
    "code": "# AOJ 1032 Course Planning for Lazy Students\n# Python3 2018.7.6 bal4u\n\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\ndef bitcount(bits): return bin(bits).count('1')\n\nwhile True:\n\tn, U = map(int, input().split())\n\tif n == 0: break\n\tc, r = [], []\n\tfor i in range(n):\n\t\ta = list(map(int, input().split()))\n\t\tc.append(a[0])\n\t\tt = 0\n\t\tfor x in a[2:]: t |= (1<<x)\n\t\tr.append(t)\n\tmk = [0]*(1<<n)\n\tmk[0] = 1\n\tQ = []\n\tQ.append((0, 0))\n\twhile Q != []:\n\t\ts, k = Q.pop(0)\n\t\tif k >= U: break\n\t\tfor i in range(n):\n\t\t\tif s & (1<<i): continue\n\t\t\tt = s | (1<<i)\n\t\t\tif (r[i]&s) == r[i] and mk[t] == 0:\n\t\t\t\tmk[t] = 1\n\t\t\t\tQ.append((t, k+c[i]))\n\tprint(bitcount(s))\n"
  },
  {
    "language": "Python",
    "code": "code=\"\"\"\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint dfs(const vvi& g,int u)\n{\n\tint res=1<<u;\n\tfor(int v:g[u]) res|=dfs(g,v);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tarray<int,20> cs;\n\t\tvvi g(n);\n\t\trep(i,n){\n\t\t\tcin>>cs[i];\n\t\t\tint k; cin>>k;\n\t\t\trep(j,k){\n\t\t\t\tint r; cin>>r;\n\t\t\t\tg[i].push_back(r);\n\t\t\t}\n\t\t}\n\n\t\tarray<int,20> bs;\n\t\trep(i,n) bs[i]=dfs(g,i);\n\n\t\tstatic array<int,1<<20> sums; sums.fill(0);\n\n\t\trep(i,n) sums[1<<i]=cs[i];\n\t\trep(i,1<<n) sums[i]=sums[i&-i]+sums[i-(i&-i)];\n\n\t\tint res=INF;\n\t\trep(i,1<<n) if(__builtin_popcount(i)<res){\n\t\t\tint b=0;\n\t\t\trep(j,n) b|=(i>>j&1)*bs[j];\n\t\t\tif(sums[b]>=m) res=min(res,__builtin_popcount(b));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n\"\"\"\n\nimport os,tempfile\n(_,filename)=tempfile.mkstemp(\".cpp\")\n\nf=open(filename,\"w\")\nf.write(code)\nf.close()\n\nos.system(\"g++ -std=c++0x {} -o ./a.out\".format(filename))\nos.system(\"./a.out\")"
  }
]