[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\n\nint X[100011];\nint C[15];\nint dp[1<<15];\nbool zero[1<<15];\n\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y, a;\n\tscanf(\"%d%d%d\", &x, &y, &a);\n\tX[x] ^= a;\n\tX[y] ^= a;\n    }\n\n    int ans = 0;\n    int mask = 0;\n\n    REP (i, N) if (X[i]) C[X[i]-1]++;\n    REP (t, 15) {\n\tans += C[t] / 2;\n\tif (C[t] & 1) mask |= 1<<t;\n    }\n\n    REP (s, 1<<15) {\n\tint x = 0;\n\tREP (t, 15) if (s>>t&1) x ^= t+1;\n\tzero[s] = (x == 0);\n    }\n\n    memset(dp, 0x3f, sizeof dp);\n    const int INF = dp[0];\n    dp[mask] = 0;\n    for (int s=mask; s>=0; s--) if (dp[s] < INF) {\n\tfor (int sub=s; sub; sub=(sub-1)&s) if (zero[sub]) {\n\t    amin(dp[s^sub], dp[s] + __builtin_popcount(sub) - 1);\n\t}\n    }\n\n    ans += dp[0];\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\t//     . .. ... .... ..... be name khoda ..... .... ... .. .     \\\\\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int in() { int x; scanf(\"%d\", &x); return x; }\nconst int N = 200002, M = 16;\n\nint a[N], cnt[M];\nint dp[1 << M], val[1 << M];\n\nint main()\n{\n\tint n = in();\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u = in(), v = in(), x = in();\n\t\ta[u] ^= x;\n\t\ta[v] ^= x;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tvector <int> x;\n\tint reserved = cnt[0];\n\tcnt[0] = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(cnt[a[i]] % 2)\n\t\t\tx.push_back(a[i]);\n\t\treserved += cnt[a[i]]/2;\n\t\tcnt[a[i]] = 0;\n\t}\n\tint m = x.size();\n\tint tot = (1 << m);\n\tfor(int i = 0; i < tot; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tif(i >> j & 1)\n\t\t\t\tval[i] ^= x[j];\n\tfor(int mask = 1; mask < tot; mask++)\n\t{\n\t\tif(val[mask] != 0)\n\t\t\tcontinue;\n\t\tdp[mask] = 1;\n\t\tfor(int smask = mask; smask > 0; smask = (smask - 1) & mask)\n\t\t\tif(!val[smask])\n\t\t\t\tdp[mask] = max(dp[mask], dp[smask] + dp[mask ^ smask]);\n\t}\n\tcout << n - dp[tot - 1] - reserved << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst int INF = 0x2fffffff;\n\nstruct Edge {\n  int to;\n  int v;\n};\n\nint N;\nvector<Edge> es[114514];\nvector<Edge> des[114514];\nint cnt[16];\nint dp[1 << 16];\n\nvoid Dfs(int v, int p, int av) {\n  int tot = 0;\n  for (auto &e : es[v]) {\n    int u = e.to;\n    if (u == p) continue;\n    Dfs(u, v, e.v);\n    tot ^= e.v;\n  }\n  if (av != -1) cnt[av^tot]++;\n}\n\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int u, v, a;\n    scanf(\"%d%d%d\", &u, &v, &a);\n    es[u].eb(Edge{v, a});\n    es[v].eb(Edge{u, a});\n  }\n\n  Dfs(0, 0, -1);\n\n  priority_queue<pii, vector<pii>, greater<pii>> que;\n  int lim = 1 << 15;\n  rep(st, lim) {\n    dp[st] = __builtin_popcount(st);\n    que.push(pii(dp[st], st));\n\n    rep(i, 15) {\n      rep(j, 15) {\n        if (i == j) continue;\n        int k = ((i+1)^(j+1)) - 1;\n        assert(k >= 0);\n\n        int ext = 0;\n        if (st >> j & 1) ext++;\n        if (st >> k & 1) ext++;\n        int nst = st;\n        nst ^= 1 << i;\n        nst ^= 1 << j;\n        nst ^= 1 << k;\n        des[nst].eb(Edge{st, ext});\n      }\n    }\n  }\n\n  while (!que.empty()) {\n    auto &p = que.top(); que.pop();\n    int cost = p.first;\n    int v = p.second;\n    if (dp[v] < cost) continue;\n\n    for (auto &e : des[v]) {\n      int u = e.to;\n      int l = e.v;\n      if (dp[u] > cost + l) {\n        dp[u] = cost + l;\n        que.push(pii(dp[u], u));\n      }\n    }\n  }\n\n  int ans = 0;\n  int st = 0;\n  reps(i, 1, 16) {\n    ans += cnt[i]/2;\n    st += (cnt[i]%2) << (i-1);\n  }\n  //printf(\"dp[%d]: %d\\n\", st, dp[st]);\n  printf(\"%d\\n\", ans + dp[st]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100100;\nconst int maxj = 17;\n\nint n,res,mask,nn,a[maxn],cnt[maxn],dp[(int)1<<maxj],good[(int)1<<maxj];\n\nint main() {\n //   freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        a[x]^=z;\n        a[y]^=z;\n    }\n    for (int i=0;i<n;i++) cnt[a[i]]++;\n    for (int i=0;i<=maxj;i++) {\n        res+=cnt[i]/2;\n        cnt[i]%=2;\n    }\n    for (int i=0;i<=maxj;i++)\n        if (cnt[i]!=0) {\n            mask|=(1<<i);\n            nn++;\n        }\n    for (int tt=0;tt<(1<<maxj);tt++) {\n        int x=0;\n        for (int i=0;i<=maxj;i++)\n            if ((tt>>i)&1 == 1) x^=i;\n        good[tt] = (x==0);\n    }\n    for (int tt=0;tt<(1<<maxj);tt++) {\n        int u=tt;\n        while (u>0) {\n            if (good[u]) dp[tt] = max(dp[tt],dp[tt^u] + 1);\n            u = (u-1)&tt;\n        }\n    }\n    cout<<res+nn-dp[mask];\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  cpp\n//\n//  Created by Hao He on 8/13/17.\n//  Copyright Â© 2017 Hao He. All rights reserved.\n//\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <map>\n#include <unordered_map>\n#include \"complex\"\nusing namespace std;\n#define rep(i,n) for(int i=0; i<int(n); ++i)\n#define repp(i,l,r) for(int i=l; i<int(r); ++i)\n#define mp make_pair\n#define X first\n#define Y second\n#define maxn 100005\n\nint d[4][maxn];\nint n, x, y, z;\nvoid solve(){\n    cin >> n;\n    rep(i, n - 1){\n        cin >> x >> y >> z;\n        rep(j, 4) if((z>>j)&1){\n            d[j][x] ++;\n            d[j][y] ++;\n        }\n    }\n    int ans = 0;\n    rep(j, 4){\n        int cnt = 0;\n        rep(i, n) cnt += d[j][i] & 1;\n        ans += cnt / 2;\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]) {\n    std::ios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100100\nusing namespace std;\n\nint n,num[N],ans,cnt[160],tmp,dp[400000],tm[160];\nbool hav[160];\n\nint dfs(int zt)\n{\n\tif(dp[zt]!=-1) return dp[zt];\n\tint i,j,k,tt=0,res=30;\n\tmemset(hav,0,sizeof(hav));\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tif((1 << (i-1))&zt) tm[++tt]=i,hav[i]=1;\n\t}\n\tfor(i=1;i<=tt;i++)\n\t{\n\t\tfor(j=1;j<=tt;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tk=tm[j]^tm[i];\n\t\t\tif(hav[k])\n\t\t\t{\n\t\t\t\tres=min(res,dfs(zt^(1 << (tm[j]-1))^(1 << (tm[i]-1))^(1 << (k-1)))+2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres=min(res,dfs(zt^(1 << (tm[i]-1))^(1 << (tm[j]-1))^(1 << (k-1)))+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[zt]=res;\n}\n\nint main()\n{\n\tint i,j,p,q,o;\n\tcin>>n;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&p,&q,&o);\n\t\tnum[++p]^=o;\n\t\tnum[++q]^=o;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n//\t\tcout<<num[i]<<\" \";\n\t\tcnt[num[i]]++;\n\t}\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\ttmp|=cnt[i]*(1 << (i-1));\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0]=0;\n\tcout<<dfs(tmp)+ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\n#define sz(a) (int)((a).size())\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing namespace std; using ll = long long; using pii = pair<int, int>; using vi = vector<int>; using ld = long double;\n\nconst int N = 1e5;\n\nint n;\nvector<pii> g[N];\nint a[N];\nint xr[1 << 15];\nint dp[1 << 15];\n\nint32_t main() {\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//ifstream cin(\"in.txt\");\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\t--u; --v;\n\t\tg[u].pb({ v, w });\n\t\tg[v].pb({ u, w });\n\t}\n\tfor (int u = 0; u < n; u++) {\n\t\tfor (pii& e : g[u]) {\n\t\t\ta[u] ^= e.second;\n\t\t}\n\t}\n\tsort(a, a + n);\n\tint ans = n;\n\tvi rem;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!a[i]) {\n\t\t\tans--;\n\t\t}\n\t\telse if (i < n - 1 && a[i] == a[i + 1]) {\n\t\t\tans--;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\trem.pb(a[i]);\n\t\t}\n\t}\n\tn = sz(rem);\n\tfor (int msk = 1; msk < (1 << n); msk++) {\n\t\tdp[msk] = -n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((msk >> i) & 1) {\n\t\t\t\txr[msk] ^= rem[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int msk = 1; msk < (1 << n); msk++) {\n\t\tfor (int s = msk; s > 0; s = (s - 1) & msk) {\n\t\t\tif (!xr[s]) {\n\t\t\t\tdp[msk] = max(dp[msk], 1 + dp[msk ^ s]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans - dp[(1 << n) - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w[10000001],d[100000001],cnt[20],res,n,st,sxr[100000001];\nbool book[10000001];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&u,&v,&va);\n        w[u]^=va;\n        w[v]^=va;\n    }\n    for(int i=0;i<n;i++)\n        cnt[w[i]]++; \n    for(int i=1;i<=15;i++)\n    {\n        res+=cnt[i]/2;\n        st|=(cnt[i]&1)<<(i-1); \n    }\n    for(int i=1;i<(1<<15);i++)\n        d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)\n        d[i]-=1;\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)\n            if((i>>j)&1)\n                sxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++)\n    {\n        if(sxr[i]!=0)\n            continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)\n                d[i]=min(d[i],d[k]+d[i^k]);\n    }\n        printf(\"%d\",res+d[st]);\n    getchar();getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\nbool book[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\tfor(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n\tfor(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)d[i]-=1;\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n\tfor(int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sxr[i]!=0)continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t\tif(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n\t}printf(\"%d\",res+d[st]);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+(k!=0));\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+(j!=0));\n                    temp2[0]=min(temp2[0],temp[j]+dp[V[n][i].first][k]+(k!=0) + (j!=0));\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<=15;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n            dp[n][0]=min(dp[n][0],temp[i]+1);\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+(val!=0));\n            dp[n][i]=min(dp[n][i],temp[i]+(val!=0));\n            dp[n][0]=min(dp[n][0],temp[i]+(val!=0) + (i!=0));\n\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 5, M = 16, inf = 1e9;\nint a[N], cnt[M], p[M], dp[1<<M], Xor[1<<M];\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, x; cin >> u >> v >> x;\n        a[u] ^= x, a[v] ^= x;\n    }\n    for (int i = 0; i < n; i++) cnt[a[i]]++;\n    int res = cnt[0], m = 0;\n    for (int i = 1; i < M; i++) {\n        res += (cnt[i]>>1);\n        if (cnt[i]&1) p[m++] = i;\n    }\n    fill(dp + 1, dp + (1<<M), -inf);\n    for (int mask = 1; mask < (1<<m); mask++) {\n        Xor[mask] = p[__builtin_ctz(mask)] ^ Xor[mask^(mask&(-mask))];\n        for (int sub = mask; sub; sub = (sub - 1)&mask) if (Xor[sub] == 0)\n            dp[mask] = max(dp[mask], dp[mask^sub] + 1);\n    }\n    cout << n - res - dp[(1<<m) - 1] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint d[N],n,ct[20],Ans,F[N],S[N];\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tfor(int i=1;i<(1<<16);i++)\n\t\tF[i]=F[i-(i&-i)]^(__builtin_popcount((i&-i)-1));\n\t// for(int i=0;i<=10;i++) printf(\"%d\\n\",F[i]);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read()+1, v=read()+1, w=read();\n\t\td[u]^=w; d[v]^=w;\n\t}\n\t// for(int i=1;i<=n;i++) printf(\"%d \",d[i]); puts(\"\");\n\tfor(int i=1;i<=n;i++) ct[d[i]]++;\n\tfor(int i=1;i<16;i++) Ans+=ct[d[i]]/2,ct[d[i]]&=1;\n\tmemset(S,0x3f,sizeof S); S[0]=0;\n\tfor(int i=1;i<(1<<16);i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\tif(!F[j]) S[i]=min(S[i],S[i^j]+1);\n\t}\n\tint Ret=0; for(int i=1;i<16;i++) Ret|=(ct[i]<<i);\n\t// cout << Ret << endl;\n\tcout << Ans+__builtin_popcount(Ret)-S[Ret] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cout << 0 << endl;\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nconst ll inf = 0x3f3f3f3f3f3f3f3fll;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxm], dp[1 << 16];\nll cnt[maxn];\nll ans;\nll DP(ll S){\n    // cout << S << endl;\n    if(dp[S] != inf) return dp[S];\n    for(int i = 1;i < 16;i++){\n        if(((S >> i) & 1) == 0) continue;\n        for(int j = 1;j < 16;j++){\n            if(((S >> j) & 1) == 0) continue;\n            ll k = i ^ j;\n            if(k == 0){\n                dp[S] = min(dp[S], DP(S ^ (1 << i)) + 1);\n            } else if(((S >> k) & 1) == 0){\n                dp[S] = min(dp[S], DP(S ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 1);\n            } else {\n                dp[S] = min(dp[S], DP(S ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 2);\n            }\n        }\n    }\n    return dp[S];\n}\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << i);\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[0] = 0;\n    cout << ans + DP(init) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(998244353);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nint a[100100],cnt[16],memo[1<<16];\nbool done[1<<16];\n\nint solve(int st){\n\tint i,j,k;\n\tif(done[st]){\n\t\treturn memo[st];\n\t}\n\tdone[st] = true;\n\tif(!st){\n\t\treturn memo[st] = 0;\n\t}\n\tmemo[st] = INF;\n\tfor(i=1; i<16; ++i){\n\t\tif(!(st&(1<<i))){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=1; j<i; ++j){\n\t\t\tif(!(st&(1<<j))){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk = i^j;\n\t\t\tif(st&(1<<k)){\n\t\t\t\tmemo[st] = min(memo[st],solve(st-(1<<i)-(1<<j)-(1<<k))+2);\n\t\t\t}else{\n\t\t\t\tmemo[st] = min(memo[st],solve(st-(1<<i)-(1<<j)+(1<<k))+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[st];\n}\n\nint main(void){\n\tint n,i,x,y,z,ans=0,left=0;\n\tcin >> n;\n\tfor(i=1; i<n; ++i){\n\t\tcin >> x >> y >> z;\n\t\ta[x] ^= z;\n\t\ta[y] ^= z;\n\t}\n\tfor(i=0; i<n; ++i){\n\t\t++cnt[a[i]];\n\t}\n\tfor(i=1; i<16; ++i){\n\t\tans += cnt[i]/2;\n\t\tif(cnt[i]%2){\n\t\t\tleft += (1<<i);\n\t\t}\n\t}\n\tans += solve(left);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof a)\n#define PII pair<int,int>\n#define PI acos(-1.0)\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF=0x3f3f3f3f;\nconst int maxn=1e5+10;\nint dp[1<<16],V[maxn],cnt[16];\nint n,x,y,a;\ninline int Count(int x)\n{\n\tint ans=0;\n\tfor(int i=0;i<=15;++i) if(x&(1<<i)) ans++;\n\treturn ans;\n}\nint Work(int S)\n{\n    if(S==0) return 0;\n    if(dp[S]!=-1) return dp[S];\n    dp[S]=INF;\n    for(int i=1;i<16;i++)\n    {\n    \tif(S&(1<<i))\n            for(int j=1;j<16;j++)\n            {\n            \t\n            \tif(S&(1<<j))\n                {\n                    int cs=S^(1<<i)^(1<<j)^(1<<(i^j));\n                    if(i!=j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(((1<<(i^j)) & S) == (1<<(i^j))) dp[S]=min(dp[S], Work(cs) + 2);\n\t\t\t\t\t\telse dp[S]=min(dp[S], Work(cs) + 1 ); \n\t\t\t\t\t}\n                }\n\t\t\t}\n\t}\n    return dp[S];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&a);\n        V[x]^=a; V[y]^=a;\n    }\n    for(int i=0;i<n;i++) if(V[i]) cnt[V[i]]++;\n    int ans=0,s=0;\n    for(int i=0;i<16;i++) ans += cnt[i]/2, s^=(cnt[i]&1)<<i;\n    memset(dp,-1,sizeof dp);\n    ans+=Work(s);\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" \" << x << '\\n'\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pli = pair<ll,int>;\nconst int INF = 0x3f3f3f3f, N = 1e5 + 5;\nconst ll LINF = 1e18 + 5;\nconstexpr int mod = 1e9 + 7;\nint n, dp[1<<16], a[N], cnt[16];\nint dfs(int S)\n{\n\tif(!S) return 0;\n\tif(~dp[S]) return dp[S];\n\tint &x = dp[S]; x = INF;\n\tfor(int i=0; i<=15; i++) if((S>>i)&1)\n\t\tfor(int j=0; j<=15; j++) if(i^j && (S>>j)&1)\n\t\t{\n\t\t\tint k = i^j;\n\t\t\tint T = S^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif((T>>k)&1) x = min(x, dfs(T)+1);\n\t\t\telse x = min(x, dfs(T)+2);\n\t\t}\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint x, y, z;\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x] ^= z; a[y] ^= z;\n\t}\n\tfor(int i=0; i<n; i++) cnt[a[i]]++;\n\tmemset(dp, -1, sizeof(dp));\n\tint S = 0, ans = 0;\n\tfor(int i=1; i<=15; i++)\n\t{\n\t\tans += cnt[i]/2;\n\t\tif(cnt[i]&1) S |= (1<<i);\n\t}\n\tprintf(\"%d\\n\", dfs(S) + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22],lg[66666];\nint f[66666],q[66666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tint ans=0;\n\tfor(register int i=2,j=1;i<65536;i<<=1,++j)lg[i]=j;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])w|=1<<i;\n\tf[w]=0;\n\tfor(q[hq=1]=w,tq=2;hq!=tq;++hq)\n\t{\n\t\tint o=q[hq];\n\t\tint l=lg[o&-o];\n\t\tfor(register int i=l+1;i<16;++i)\n\t\t\tif(o&1<<i)\n\t\t\t{\n\t\t\t\tint t=o^1<<l^1<<i^1<<(l^i);\n\t\t\t\tt&=~1;\n\t\t\t\tif(f[t]>33333)f[t]=f[o]+1+(bool)(o&1<<(i^l)),q[tq++]=t;\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[0]); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nlong long max(long long x, long long y){return (x > y ? x : y);}\nlong long min(long long x, long long y){return (x < y ? x : y);}\nint gcd(int a, int b) { return b ? gcd(b, a%b) : a; }\n\n#define ll int\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=1e5+500;\nconst ll inf=1e9+800;\nconst ll mod=1e9+7;\n\nll dp[1<<16];\nll xx[1<<16];\nvoid cal(){\n\txx[0]=0;\n\tfor(ll i=1;i<(1<<16);i++){\n\t\tll lb;\n\t\tfor(ll j=0;j<16;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tlb=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\txx[i]=(xx[i^(1<<lb)]^lb);\n  \t}\n\tdp[0]=0;\n\tfor(ll i=1;i<(1<<16);i++){\n\t\t// dp[i]\n\t\tfor(ll mas=i;mas>0;mas=((mas-1)&i)){\n\t\t\tif(xx[mas]==0)\n\t\t\t\tdp[i]=max(dp[i],dp[i^mas]+1);\n\t\t}\n\t}\n}\n\nvector<pii> ger[maxn];\nll cnt[16];\n\nvoid dfs(ll a,ll p=-1){\n\tll val=0;\n\tFOR(i,ger[a]){\n\t\tll v=ger[a][i].F;\n\t\tll w=ger[a][i].S;\n\t\tval^=w;\n\t\tif(v!=p)\n\t\tdfs(v,a);\n\t}\n\tif(p!=-1)\n\t\tcnt[val]++;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tll n;\n\tcin>>n;\n\tfor(ll i=1;i<n;i++){\n\t\tll v,u,w;\n\t\tcin>>v>>u>>w;\n\t\tger[v].pb(mp(u,w));\n\t\tger[u].pb(mp(v,w));\n\t}\n\tdfs(0);\n\tll ans=0;\n\tfor(ll i=1;i<16;i++){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\tll res=0;\n\tfor(ll i=1;i<16;i++){\n\t\tif(cnt[i]){\n\t\t\tres^=i;\n\t\t}\n\t}\n\tcnt[res]++;\n\tcnt[res]=0;\n\tans+=cnt[res]/2;\n\tcnt[res]%=2;\n\n\tres=0;\n\tll t=0;\n\tfor(ll i=1;i<16;i++){\n\t\tif(cnt[i]){\n\t\t\tres+=(1<<i);\n\t\t\tt++;\n\t\t}\n\t}\n\tcal();\n\tcout<<ans+t-dp[res];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntypedef long long ll;\n\nint n,r;\nint x[100005];\nint dp[1<<15];\n\nint f(int m){\n\tint& r=dp[m];\n\tif(r>=0)return r;\n\tr=1<<30;\n\tfore(i,1,15)if(m&(1<<i))fore(j,1,15)if(j!=i&&(m&(1<<j))){\n\t\tint k=i^j;\n\t\tint nm=m^(1<<i)^(1<<j);\n\t\tint a=1;\n\t\tif(k){\n\t\t\tif(nm&(1<<k))a++;\n\t\t\tnm^=1<<k;\n\t\t}\n\t\tr=min(r,a+f(nm));\n\t}\n\treturn r;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfore(_,1,n){\n\t\tint i,j,a;\n\t\tscanf(\"%d%d%d\",&i,&j,&a);\n\t\tx[i]^=a;x[j]^=a;\n\t}\n\tint m=0;\n\tfore(i,0,n){\n\t\tif(!x[i])continue;\n\t\tif(m&(1<<x[i]))r++;\n\t\tm^=1<<x[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));dp[0]=0;\n\tprintf(\"%d\\n\",r+f(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 100100;\nconst int A = 16;\nconst int B = 1 << A;\nconst int ROOT = 0;\n\nvector<int> g[M], h[M];\n\nint n;\nint cnt[A];\nint d[B];\n\nvoid read() {\n  cin >> n;\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, x;\n    cin >> u >> v >> x;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    h[u].push_back(x);\n    h[v].push_back(x);\n  }\n}\n\nvoid dfs(int v, int from, int by) {\n  int cur = 0;\n  for (int i = 0; i < (int) g[v].size(); ++i) {\n    int to = g[v][i];\n    if (to == from)\n      continue;\n    cur ^= h[v][i];\n    dfs(to, v, h[v][i]);\n  }\n  cnt[by ^ cur]++;\n}\n\nint bit(int mask, int i) {\n  return (mask >> i) & 1;\n}\n\nbool good(int mask) {\n  int res = 0;\n  for (int i = 1; i < A; ++i)\n    if (bit(mask, i))\n      res ^= i;\n  return res == 0;\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"f.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  int root = ROOT % n;\n  dfs(root, -1, 0);\n\n  int ans = 0;\n  int rmask = 0;\n \n  for (int i = 1; i < A; ++i) {\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n    if (cnt[i])\n      rmask |= 1 << i;\n  }\n\n  d[0] = 0;\n  for (int i = 1; i < B; ++i)\n    d[i] = 1;\n\n  assert(good(rmask));\n\n  for (int c = 1; c < B; ++c)\n    if (good(c)) {\n      int rem = (B - 1) ^ c;\n      for (int t = rem; ; t = (t - 1) & rem) {\n        d[t ^ c] = max(d[t ^ c], 1 + d[t]);\n        if (t == 0)\n          break;\n      }\n    }\n\n  ans += __builtin_popcount(rmask) - d[rmask];\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC target(\"avx,sse4\")\n\n#define mms(a,n) memset(a,0,sizeof((a)[0])*(n))\n#define mmp(a,b,n) memcpy(a,b,sizeof((b)[0])*(n))\n#define lowbit(x) ((x)&-(x))\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fo(i,l,r) for(register int i=l,_lim_=r;i<=_lim_;i++)\n#define fd(i,r,l) for(register int i=r,_lim_=l;i>=_lim_;i--)\n#define fos(i,l,r,d) for(register int i=l,_lim_=r;i<=r;i+=d)\n#define fol(i,l,r) for(register ll i=l,_lim_=r;i<=_lim_;i++)\n#define fdl(i,r,l) for(register ll i=r,_lim_=l;i>=_lim_;i--)\n#define fosl(i,l,r,d) for(register ll i=l,_lim_=r;i<=r;i+=d)\n#define Clear(a) memset(a,0,sizeof(a))\n#define Copy(a,b) memcpy(a,b,sizeof(b))\n#define ALL(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef double db;\ntypedef pair<int,ll> pi;\n\nnamespace io{\n\tconst int L=(1<<21)+1;\n\tchar ibuf[L],*iS,*iT,obuf[L],*oS=obuf,*oT=obuf+L-1,c,st[55];int f,tp;\n\t#ifdef whzzt\n\t\t#define gc() getchar()\n\t#else\n\t\t#define gc() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,L,stdin),(iS==iT?EOF:*iS++)):*iS++)\n\t#endif\n\tinline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}\n\tinline void putc(char x){*oS++=x;if(oS==oT)flush();}\n\ttemplate<class I>\n\tinline void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n\ttemplate<class I>\n\tinline void print(I x){\n\t\tif(!x)putc('0');if(x<0)putc('-'),x=-x;\n\t\twhile(x)st[++tp]=x%10+'0',x/=10;\n\t\twhile(tp)putc(st[tp--]);\n\t}\n\tinline void gs(char*s,int&l){\n\t\tfor(c=gc();c<'a'||c>'z';c=gc());\n\t\tfor(l=0;c<='z'&&c>='a';c=gc())s[l++]=c;\n\t}\n\tinline char O(){\n\t\tfor(c=gc();c!='C'&&c!='Q'&&c!='R';c=gc());\n\t\treturn c;\n\t}\n\tinline void ps(const char*s){\n\t\tfo(i,0,strlen(s)-1)putc(s[i]);\n\t}\n};\nusing io::putc;\nusing io::gi;\nusing io::gs;\nusing io::print;\n\nconst int N=100005;\nint n,x[N],cnt[1<<4],u,v,w,ans,dp[1<<16],st;\nbool vi[1<<16];\n\nint dfs(int S){\n\tif(!S)return 0;if(vi[S])return dp[S];\n\tvi[S]=true;\n\tint ret=233;\n\tfo(i,1,15)if(S>>i&1)fo(j,1,15)if(i!=j&&(S>>j&1)){\n\t\tint T=S^(1<<i)^(1<<j)^(1<<(i^j));\n\t\tif(__builtin_popcount(T)<__builtin_popcount(S))ret=min(ret,dfs(T)+1+(~T>>(i^j)&1));\n\t}\n\treturn dp[S]=ret;\n}\n\nint main(){\n\tgi(n);\n\tfo(i,2,n)gi(u),gi(v),gi(w),x[u+1]^=w,x[v+1]^=w;\n\tfo(i,1,n)if(x[i])cnt[x[i]]++;\n\tfo(i,0,15)ans+=cnt[i]>>1,st|=(cnt[i]&1)<<i;\n\tans+=dfs(st);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        A[u]^=to.se;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    for(int m=l+1;m<16;m++){\n                        if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[m]&&cnt[i^j^k^l^m]){\n                            ans+=5;\n                            cnt[i]=0;\n                            cnt[j]=0;\n                            cnt[k]=0;\n                            cnt[l]=0;\n                            cnt[m]=0;\n                            cnt[i^j^k^l^m]=0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nint dp[1<<16][16];\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    rep(i,n-1){\n        int s,t,c;\n        cin >> s >> t >> c;\n        a[s]^=c;\n        a[t]^=c;\n    }\n    int sm = 0;\n    vector<int> c(16);\n    rep(i,n){\n        c[a[i]]++;\n    }\n    cerr << endl;\n    rep(i,16){\n        sm += c[i]/2;\n        c[i]%=2;\n    }\n    int tar = 0;\n    for(int i=1;i<16;i++){\n        tar ^= (c[i]<<(i-1));\n    }\n    Fill(dp,inf);\n    dp[0][0] = 0;\n    for(int bits=0;bits<(1<<16);bits++){\n        for(int i=0;i<16;i++){\n            for(int j=1;j<16;j++){\n                if((bits>>(j-1))&1)continue;\n                chmin(dp[bits^(1<<(j-1))][i^j],dp[bits][i] + 1);\n            }\n        }\n    }\n    int ss = dp[tar][0];\n    cout << sm + ss - 1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nconst int inf = 1<<16;\nint N,x,y,z,need[100010],tot[20],ans,md[inf],all;\nbool vis[inf];\nint read()\n{\n\tstatic int x;\n\tstatic char ch;\n\tx = 0;\n\tfor(ch=getchar();ch>'9'||ch<'0';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x = x * 10 + ch - '0';\n\treturn x;\n}\nint length(int x)\n{\n\tint len = 0; \n\twhile (x)\n\t{\n\t\tlen += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn len;\n}\nint find(int now)\n{\n\tif (!now) return 0;\n\tif (vis[now]) return md[now];\n\tvis[now] = true;\n\tint ret = 20,next;\n\tfor (int i = 1;i<=15;++i)\n\t if ((now >> i) & 1)\n\t  for (int j = 1;j<=15;++j)\n\t   if ((i!=j) && ((now>>j)&1))\n\t     {\n\t     \tnext = now ^ (1<<i) ^ (1<<j) ^ (1<<(i ^ j));\n\t     \tif (length(next) < length(now)) ret = min(ret , find(next) + 1 + (~next >> (i ^ j) & 1));\n\t\t }\n\t return md[now] = ret;\t\n}\nint main()\n{\n\tN = read();\n\tfor (int i = 1;i<N;++i)\n\t{\n\t\tx = read() + 1;\n\t\ty = read() + 1;\n\t\tz = read();\n\t\tneed[x]^=z;need[y]^=z;\n\t}\n\tans = 0;\n\tfor (int i = 1;i<=N;++i) tot[need[i]]++;\n\tfor (int i = 1;i<=15;++i) ans += tot[i] >> 1,all |= (tot[i] & 1) << i;\n\tans += find(all);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std ;\nconst int MAXN = 1e5 + 10 ;\nint n , a[MAXN] , cnt[MAXN] , sum[1 << 16] , f[1 << 16] , ans , t ;\nint min (int a , int b) {\n\treturn a < b ? a : b ;\n}\nint main () {\n\tscanf (\"%d\" , &n) ;\n\tfor (int i = 1 ; i < n ; i++) {\n\t\tint u , v , w ;\n\t\tscanf (\"%d %d %d\" , &u , &v , &w) ;\n\t\ta[u] ^= w ; a[v] ^= w ;\n\t}\n\tfor (int i = 0 ; i < n ; i++) cnt[a[i]]++ ;\n\tfor (int i = 1 ; i < 16 ; i++) {\n\t\tans += (cnt[i] >> 1) ;\n\t\tif (cnt[i] & 1) t |= (1 << (i - 1)) ;\n\t}\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tf[i] = f[i >> 1] + (i & 1) ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++) f[i]-- ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tfor (int j = 0 ; j < 15 ; j++)\n\t\t\tif (i & (1 << j)) \n\t\t\t\tsum[i] ^= (j + 1) ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tif (!sum[i])\n\t\t\tfor (int j = (i - 1) & i ; j ; j = (j - 1) & i)\n\t\t\t\tif (!sum[j])\n\t\t\t\t\tf[i] = min (f[i] , f[j] + f[i ^ j]) ;\n\tprintf (\"%d\\n\" , ans + f[t]) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+(k!=0));\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+(j!=0));\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<20;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+(val!=0));\n            dp[n][i]=min(dp[n][i],temp[i]+(val!=0));\n\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef  long long LL;\ntypedef  unsigned long long ULL;\ntypedef  double db;\ntypedef  long double ld;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define fuck(x) cout<<x<<endl\n#define fuck1(x,y) cout<<x<<\" \"<<y<<endl\n#define lson root<<1,l,mid\n#define rson root<<1|1,mid+1,r\n#define MP(a,b) make_pair(a,b)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\nconst int INF = 0x3f3f3f3f3f,mod = 1e9+7,maxn = 3e5+100;\nconst double eps  =1e-6,PI = acos(-1);\ntemplate<typename T> inline void read(T &x){\n    x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\nint N,val[maxn],cnt[20];\nint d[maxn],ss[maxn];\nint main(){\n    read(N);\n    for(int i = 0;i<N-1;i++){\n        int x,y,a;\n        read(x),read(y),read(a);\n        val[x]^=a;\n        val[y]^=a;\n    }\n    for(int i = 0;i<N;i++){\n        if(val[i])cnt[val[i]]++;\n    }\n    int ans = 0,st = 0;\n    for(int i = 0;i<16;i++){\n        ans+=cnt[i]/2;\n        if(cnt[i]&1)st = st|(1<<i);\n    }\n    for(int i = 1;i<=(1<<15);i++)d[i] = d[i>>1]+(i&1);\n    for(int i = 1;i<=(1<<15);i++)d[i]--;\n    for(int i = 1;i<=(1<<15);i++){\n        for(int j = 1;j<=15;j++){\n            if(i&(1<<j))ss[i]^=(j);\n        }\n    }\n    for(int i = 1;i<=(1<<15);i++){\n        if(ss[i]!=0)continue;\n        for(int k = (i-1)&i;k;k = (k-1)&i){\n            if(ss[k]==0)d[i] = min(d[i],d[k]+d[i^k]);\n        }\n    }\n    printf(\"%d\\n\",ans+d[st]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\nconst int maxn = 1e5 + 20;\nconst int maxs = (1 << 16) + 7;\n\nint n;\nint val[maxn], cnt[16], ans;\nint dp[maxs];\n\ntemplate<class TAT>void checkmin(TAT &x,const TAT &y)\n{\n\tif(y < x) x = y;\n}\nint dfs(int x)\n{\n\tif(dp[x] != -1) return dp[x];\n\t\n\tdp[x] = maxs;\n\t\n\tfor(int i = 0; i < 16; i++)\n\t\tfor(int j = 0; j < 16; j++)\n\t\t\tif(((x >> i) & 1) && ((x >> j) & 1))\n\t\t\t{\n\t\t\t\tint tmp = x ^ (1 << i) ^ (1 << j);\n\t\t\t\tint modify = i ^ j;\n\t\t\t\t\n\t\t\t\tcheckmin(dp[x], tmp ^ (1 << modify) + 1 + ((tmp >> modify) & 1));\n\t\t\t}\n\t\n\treturn dp[x];\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, x, y, a; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\t++x, ++y;\n\t\tval[x] ^= a, val[y] ^= a;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(val[i])\n\t\t{\n\t\t\tans += cnt[val[i]];\n\t\t\tcnt[val[i]] ^= 1;\n\t\t}\n\t}\n\t\n\tint now = 0;\n\t\n\tfor(int i = 0; i < 16; i++) now |= (1 << i) * cnt[i];\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0] = 0;\n\tans += dfs(now);\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///****In the name of Allah, most Gracious, most Compassionate****//\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\n#define ALL(a) a.begin(), a.end()\n#define FastIO ios::sync_with_stdio(false); cin.tie(nullptr);cout.tie(nullptr)\n#define IN freopen(\"input.txt\",\"r+\",stdin)\n#define OUT freopen(\"output.txt\",\"w+\",stdout)\n\n#define DBG(a) cout<< #a <<\" --> \"<<(a)<<endl\n#define NL cout<<\"\\n\"\n\ntemplate < class T1,class T2>\nostream &operator <<(ostream &os,const pair < T1,T2 > &p)\n{\n    os<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return os;\n}\n\nconst int N=3e5+5;\nconst int oo=1e9+7;\n\nint cnt[N];\nint val[N];\nint dp[1<<16];\nint rec(int mask)\n{\n    if(mask==0) return 0;\n    if(dp[mask]!=-1) return dp[mask];\n    int &ret = dp[mask]  = oo;\n    for(int j=1; j<=15; j++)\n    {\n        if(mask & (1<<j) == 0) continue;\n        for(int k=j+1; k<=15; k++)\n        {\n            if(mask &(1<<k)  )\n            {\n//                DBG(mask & (1<<k));\n                int to = j^k;\n                int tomask = mask^(1<<j)^(1<<k);\n\n\n                bool jog =tomask&(1<<to);\n                tomask = tomask^(1<<to);\n//                DBG(mask);\n//                DBG(tomask);\n//\n//                DBG(j);\n//                DBG(k);\n//                DBG(to);\n//                DBG(bitset<16> (mask));\n//                DBG(bitset<16> (tomask));\n//                NL;\n                assert(__builtin_popcount(mask)> __builtin_popcount(tomask));\n                ret = min(ret, 1 + rec(tomask) + jog);\n            }\n        }\n    }\n    return ret;\n}\nint32_t main()\n{\n    FastIO;\n    int n;\n    cin>>n;\n    for(int i=1; i<=n-1; i++)\n    {\n        int u,v,a;\n        cin>>u>>v>>a;\n        val[u]^=a;\n        val[v]^=a;\n    }\n//    for(int i=0; i<n; i++) cout<<val[i]<<\" \";\n//    NL;\n    for(int i=0; i<n; i++)\n        cnt[val[i]]++;\n\n    int ans  = 0, mask = 0, jor = 0;\n    for(int i=1; i<=15; i++)\n    {\n        ans+=cnt[i]/2;\n        cnt[i]%=2;\n        if(cnt[i])\n            mask|=(1<<i), jor^=i;\n    }\n    memset(dp ,  -1 , sizeof dp);\n    ans+=rec(mask);\n    cout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<lint, int> pi;\ntypedef long long lint;\nconst int MAXN = 100005;\n\nint n;\nint cnt[16], arr[MAXN];\nint dp[MAXN];\n\nint bfs(int msk){\n\tfor(int i=1; i<(1<<16); i++){\n\t\tint ans = 0;\n\t\tdp[i] = -1e9;\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif((i >> j) & 1) ans ^= j;\n\t\t}\n\t\tif(ans == 0) dp[i] = 1;\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tdp[i] = max(dp[j] + dp[i^j], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<16; i++) if((msk >> i) & 1) ans++;\n\treturn ans - dp[msk];\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e, x;\n\t\tscanf(\"%d %d %d\",&s,&e,&x);\n\t\tarr[s] ^= x;\n\t\tarr[e] ^= x;\n\t}\n\tfor(int i=0; i<n; i++) cnt[arr[i]]++;// printf(\"%d\\n\", arr[i]);\n\tint msk = 0, ans = 0;\n\tfor(int i=1; i<16; i++){\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1) msk |= (1 << i);\n\t}\n\tcout << ans + bfs(msk) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Int register int\n#define INF 0x7f7f7f7f \n#define MAXN 100005\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nint n,val[MAXN],tong[16],f[1 << 16];\n\nint count (int S){//ç»è®¡Sä¸­1çä¸ªæ°\n\tint sum = 0;\n\tfor (Int i = 0;(1 << i) <= S;++ i) sum += (S >> i & 1); \n\treturn sum;\n}\n\nint Sum (int S){\n\tint sum = 0;\n\tfor (Int i = 0;(1 << i) <= S;++ i) if (S >> i & 1) sum ^= i;\n\treturn sum;\n} \n\nsigned main(){\n\tread (n);\n\tfor (Int i = 2,u,v,w;i <= n;++ i) read (u,v,w),val[u] ^= w,val[v] ^= w;\n\tint tot = 0;\n\tfor (Int i = 0;i < n;++ i) tong[val[i]] ++;\n\tfor (Int i = 1;i <= 15;++ i) if (tong[i] & 1) tot += (tong[i] - 1) / 2,tong[i] = 1;else tot += tong[i] / 2,tong[i] = 0;\n\tint up = 1 << 16;\n\tfor (Int S = 1;S < up;++ S) f[S] = Sum (S) ? INF : count (S) - 1;\n\tfor (Int S = 1;S < up;++ S)\n\t\tfor (Int T = S;T;T = (T - 1) & S)\n\t\t\tf[S] = min (f[S],f[T] + f[S ^ T]);\n\tint now = 0;\n\tfor (Int i = 1;i <= 15;++ i) if (tong[i]) now |= 1 << i;\n\twrite (f[now] + tot),putchar ('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;vi v[N];\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=1;i<(1<<n);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=1;j<n;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=j;\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n\t\t}\n\t}\n\treturn;\n}\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=1<<i;\n\t\t}\n\t}\n\tinit();\n\tfor(int i=1;i<=mask;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nint val[N], cnt[16];\nint dis[1 << 16];\n\nqueue<int> q;\n\nvoid relax(int o, int d){\n\tif(dis[o] > d) dis[o] = d, q.push(o);\n}\n\nint SPFA(int S){\n\tmemset(dis, 0x3f, sizeof dis);\n\tdis[S] = 0;\n\tq.push(S);\n\twhile(!q.empty()){\n\t\tint o = q.front(); q.pop();\n\t\tif(!o) return dis[o];\n\t\tFor(i, 0, 14) if(o & (1 << i)) relax(o ^ (1 << i), dis[o] + 1);\n\t\tFor(i, 0, 14) if(o & (1 << i)) For(j, i + 1, 14) if(o & (1 << j))\n\t\t\tFor(k, 1, 15){\n\t\t\t\tint u = (i + 1) ^ k, v = (j + 1) ^ k;\n\t\t\t\tint st = o ^ (1 << i) ^ (1 << j), w = dis[o] + 1;\n\t\t\t\t\n\t\t\t\tif(u){\n\t\t\t\t\tif(o & (1 << (u - 1))) ++w;\n\t\t\t\t\tst ^= 1 << (u - 1);\n\t\t\t\t}\n\t\t\t\tif(v){\n\t\t\t\t\tif(o & (1 << (v - 1))) ++w;\n\t\t\t\t\tst ^= 1 << (v - 1);\n\t\t\t\t}\n\n\t\t\t\trelax(st, w);\n\t\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tval[u] ^= w, val[v] ^= w;\n\t}\n\tFor(i, 2, n) cnt[val[i]]++;\n\n\tint ans = 0;\n\tFor(i, 1, 15) ans += cnt[i] / 2, cnt[i] &= 1;\n\t\n\tint st = 0;\n\tFor(i, 1, 15) st |= cnt[i] << (i - 1);\n\tprintf(\"%d\\n\", ans + SPFA(st));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint x = 0;\n\nstruct Path {\n    static constexpr int N = 1 << 4;\n    Path() {\n        for (int i = 0; i < N; i++) {\n            k[i] = 0;\n        }\n    }\n    int sum() {\n        int s = 0;\n        for (int i = 1; i < N; i++) {\n            s += k[i];\n        }\n        return s;\n    }\n    int join() {\n        int s = 0;\n        for (int i = 1; i < N; i++) {\n            if (k[i] >= 2) {\n                s += k[i] / 2;\n                k[i] &= 1;\n            }\n        }\n        x += s;\n        return s;\n    }\n    int join2() {\n        int s = 0;\n        for (int i = 1; i < N; i++) {\n            for (int j = 1; j < i; j++) {\n                if (k[i] & k[j] & k[i ^ j]) {\n                    s++;\n                    k[i ^ j] = 0;\n                }\n            }\n        }\n        return s;\n    }\n    Path& operator+=(const Path& p) {\n        k[0] ^= p.k[0];\n        for (int i = 1; i < N; i++) {\n            k[i] += p.k[i];\n        }\n        return *this;\n    }\n    Path& operator+=(int c) {\n        if (c != 0) {\n            k[0] ^= c;\n            if (k[c]) {\n                k[c] = 0;\n                x++;\n            } else {\n                k[c] = 1;\n            }\n        }\n        return *this;\n    }\n    int k[N];\n};\n\nstruct Graph {\n    struct Vertex { int n; };\n    struct Edge { int i, n, c; Path p; };\n    Graph(int n, int m) : v(n, { -1 }), e(m), n(n), m(0) {}\n    void add_edge(int i, int j, int c) {\n        e[m] = { j, v[i].n, c };\n        v[i].n = m;\n        m++;\n    }\n    Path dfs(int i, int q) {\n        Path p;\n        for (int j = v[i].n; j >= 0; j = e[j].n) {\n            Edge& o = e[j];\n            if (o.i == q) continue;\n            Path t = dfs(o.i, i);\n            int c = o.c ^ t.k[0];\n            t += c;\n            p += t;\n            o.p = t;\n        }\n        p.join();\n        return p;\n    }\n    Path dfs2(int i, int q) {\n        Path p[2];\n        for (int j = v[i].n; j >= 0; j = e[j].n) {\n            Edge& o = e[j];\n            if (o.i == q) continue;\n            Path t = dfs(o.i, i);\n            int c = o.c ^ t.k[0];\n            t += c;\n            p[o.c != 0] += t;\n        }\n        p[1].join();\n        p[0] += p[1];\n        int s = p[0].join();\n        //if (s == 0)\n        return p[0];\n    }\n    vector<Vertex> v;\n    vector<Edge> e;\n    int n, m;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    Graph g(n, (n - 1) * 2);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        g.add_edge(a, b, c);\n        g.add_edge(b, a, c);\n    }\n\n    Path p = g.dfs(0, -1);\n    p.join2();\n\n    cout << p.sum() + x << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    for(int i=0; i<16; i++) ans+=cnt[i]>>1, cnt[i]=cnt[i]&1;\n    ans+=cnt[0];\n    cnt[0]=0;\n    dp[0]=0;\n    for(int mask=1; mask<(1<<16); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            int nw=0;\n            for(int i=0; i<16; i++) if((sub>>i)&1) if(cnt[i]) nw^=i;\n            if(nw==0) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<16)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<15;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[16], f[MaxM+10];\nbool xr[MaxM+10];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), ++x, ++y, v[x]^=z, v[y]^=z;\n\tfor (int i=1; i<=n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=1; i<=15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=i;\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MN 200005\nusing namespace std;\nint n,m,a[MN],val[MN],ans,f[1<<16],sum[20];\nint main(){\n\tscanf(\"%d\",&n);int x,y,v;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d%d\",&x,&y,&v),a[x]^=v,a[y]^=v;\n\tfor(int i=0;i<n;i++)sum[a[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=sum[i]/2;\n\t\tif(sum[i]%2)val[m++]=i;\n\t}memset(f,0x3f,sizeof(f));f[0]=0;\n\tfor(int i=1;i<(1<<m);i++){\n\t\tint x=0,cnt=0;\n\t\tfor(int j=0;j<m;j++)if(i&(1<<j))x^=val[j],cnt++;\n\t\tif(!x)f[i]=cnt-1;\n\t\tfor(int y=i-(i&(-i)),z=y;z;z=(z-1)&y,f[i]=min(f[i],f[z]+f[i^z]));\n\t}printf(\"%d\\n\",f[(1<<m)-1]+ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n\nint N, X[100000];\nint dp[1 << 16];\nint ok[1 << 16];\n\nint rec(int bit) {\n  if(~dp[bit]) return dp[bit];\n  int ret = ok[bit];\n  for(int i = bit; i > 0; i = (i - 1) & bit) {\n    if(i == bit) continue;\n    int other = i ^bit;\n    ret = min(ret, rec(i) + rec(other));\n  }\n  return dp[bit] = ret;\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    X[x] ^= z;\n    X[y] ^= z;\n  }\n  int bit = 0, ret = 0;\n  for(int i = 0; i < N; i++) {\n    if(X[i] == 0) continue;\n    if(bit & (1 << X[i])) ++ret;\n    bit ^= 1 << X[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  for(int i = 1; i < (1 << 16); i++) {\n    ok[i] = ok[i >> 1] + 1;\n  }\n  for(int i = 1; i < (1 << 16); i++) {\n    int v = 0;\n    for(int j = 0; j < 16; j++) {\n      if((i >> j) & 1) v ^= j;\n    }\n    if(v == 0) --ok[i];\n  }\n  cout << ret + rec(bit) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nint a[MAXN];\nint cnt[16];\nint dp[(1<<15)];\nint solve(int mask)\n{\n    if(mask==0) return 0;\n    if(dp[mask]!=-1) return dp[mask];\n    int ans=INF;\n    for(int i=0;i<15;i++)\n    {\n        if(!(mask&(1<<i))) continue;\n        for(int j=i+1;j<15;j++)\n        {\n            if(!(mask&(1<<j))) continue;\n            int newmask=mask^(1<<i)^(1<<j);\n            int to=((i+1)^(j+1))-1;\n            if(mask&(1<<to)) ans=min(ans,solve(newmask^(1<<to))+2);\n            else ans=min(ans,solve(newmask^(1<<to))+1);\n        }\n    }\n    return dp[mask]=ans;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);u++;v++;\n        a[u]^=w;a[v]^=w;\n    }\n    for(int i=1;i<=n;i++) cnt[a[i]]++;\n    int ans=0,mask=0;\n    for(int i=1;i<=15;i++)\n    {\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n        if(cnt[i]) mask+=1<<(i-1);\n    }\n    memset(dp,-1,sizeof(dp));\n    printf(\"%d\\n\",ans+solve(mask));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint b[110000];\nvector<pair<int,int> > g[110000];\nint cnt[20];\nint dp[1<<16];\nint calc(int a){\n\tif(dp[a]>=0)return dp[a];\n\tif(a==0)return dp[a]=0;\n\tint ret=mod;\n\tfor(int i=0;i<16;i++){\n\t\tif(a&(1<<i)){\n\t\t\tret=min(ret,calc(a-(1<<i))+1);\n\t\t\tfor(int j=0;j<16;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(a&(1<<j)){\n\t\t\t\t\tint to=i^j;\n\t\t\t\t\tif(a&(1<<to)){\n\t\t\t\t\t\tret=min(ret,calc(a-(1<<i)-(1<<j)-(1<<to))+2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret=min(ret,calc(a-(1<<i)-(1<<j)+(1<<to))+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tg[p].push_back(make_pair(q,r));\n\t\tg[q].push_back(make_pair(p,r));\n\t}\n\tfor(int i=1;i<a;i++){\n\t\tfor(int j=0;j<g[i].size();j++)b[i]^=g[i][j].second;\n\t}\n\tfor(int i=0;i<a;i++)cnt[b[i]]++;\n\tfor(int i=0;i<(1<<16);i++)dp[i]=-1;\n\tint ret=0;\n\tint st=0;\n\tfor(int i=1;i<16;i++){\n\t\tret+=cnt[i]/2;\n\t\tif(cnt[i]%2)st+=(1<<i);\n\t}\n\tprintf(\"%d\\n\",ret+calc(st));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch)){ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x;\n}\nconst int N = 1e6;\nint n,sum[1<<17],val[N],num[N],S,dp[1<<17];\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i < n;i++)\n\t{\n\t\tint a = read()+1,b = read()+1,w = read();\n\t\tval[a] ^= w;val[b] ^= w;\n\t}\n\tfor(int i = 1;i <= n;i++) num[val[i]]++;\n\tint ans = 0;\n\tfor(int i = 1;i < 16;i++)\n\tans += num[i]/2,S |= ((num[i]&1)<<i-1);\n\tfor(int i = 1;i < 1<<15;i++)\n\t{\n\t\tfor(int j = 1;j < 16;j++)\n\t\t{\n\t\t\tsum[i] ^= j * ((i>>(j-1))&1);\n\t\t\tdp[i] += (i>>(j-1))&1;\n\t\t}\n\t\tdp[i]--;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1;i < 1<<15;i++)\n\t{\n\t\tif(sum[i]) continue;\n\t\tfor(int j = i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(sum[j]) continue;\n\t\t\tdp[i] = min(dp[i],dp[i^j]+dp[j]);\n\t\t}\n\t}\n\tcout<<ans+dp[S]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nvector<pa> G[100020];\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\nint n;\n \tcin>>n;\n \tfor(int i=0;i<n-1;i++){\n \tint y,yy,yyy;\n \t\tcin>>y>>yy>>yyy;\n \t\t\tG[y].pb({yy,yyy});\n \t\t\tG[yy].pb({y,yyy});\n \t}\n \tint a[16]={};\n \tfor(int i=0;i<n;i++){\n \tint wa=0;\n \t\tfor(auto v:G[i])wa^=v.second;\n \t\n \ta[wa]++;\n \t}\n \t\n \tint ans=0;\n \tfor(int i=1;i<16;i++){\n \tans+=a[i]/2;\n \t\ta[i]&=1;\n \t}\n \tint t=0;\n \tfor(int i=1;i<16;i++){\n \t\tif(a[i])t++;\n \t}\n \tif(t)t--;\n \tcout<<ans+t<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define LL long long\n#define DB double\n#define MAXN 100000\n#define MOD 1000000007\n#define Pr pair<int,int>\n#define X first\n#define Y second\n#define INF 1000000000000000000\n#define mem(x,v) memset(x,v,sizeof(x))\n\nLL read(){\n\tLL x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\n\nint n,val[MAXN+5],cnt[MAXN+5],ans,st;\nint dp[MAXN+5],flag[MAXN+5];\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint u=read(),v=read(),w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++)cnt[val[i]]++;\n\tfor(int i=1;i<=15;i++)ans+=cnt[i]/2,st|=(cnt[i]&1)*(1<<(i-1));\n\tdp[0]=-1;\n\tfor(int S=1;S<(1<<15);S++)dp[S]=dp[S>>1]+(S&1);\n\tdp[0]=0;\n\tfor(int S=1;S<(1<<15);S++)\n\t\tfor(int i=0;i<15;i++)\n\t\tif(S&(1<<i))flag[S]^=(i+1);\n\tfor(int S=1;S<(1<<15);S++)\n\tif(!flag[S]){\n\t\tfor(int nS=(S-1)&S;nS;nS=(nS-1)&S)\n\t\tif(!flag[nS])dp[S]=min(dp[S],dp[nS]+dp[S^nS]);\n\t}\n\tprintf(\"%d\",ans+dp[st]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, sum[100005], cnt[16], dp[1 << 15];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v, c; i < n; ++i) {\n\t\tscanf(\"%d%d%d\", &u, &v, &c);\n\t\tsum[u] ^= c, sum[v] ^= c;\n\t}\n\tfor (int i = 0; i < n; ++i) ++cnt[sum[i]];\n\tint ans = 0, buc = 0;\n\tfor (int i = 1; i < 16; ++i) ans += cnt[i] >> 1, buc |= (cnt[i] & 1) << i - 1;\n\tfor (int s = 1; s <= buc; ++s) {\n\t\tint t = 0;\n\t\tfor (int i = 0; i < 15; ++i)\n\t\t\tif (s >> i & 1) ++dp[s], t ^= i + 1;\n\t\tdp[s] -= !t;\n\t\tfor (int t = s - 1 & s; t; t = t - 1 & s)\n\t\t\tdp[s] = min(dp[s], dp[t] + dp[s ^ t]);\n\t}\n\tprintf(\"%d\\n\", ans + dp[buc]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic vector<int> vec;\n\tfor(int i = 1 ; i < (1<<16) ; i ++){\n\t\tint sum = 0;\n\t\tfor(int j = 0 ; j < 16 ; j ++){\n\t\t\tif((i>>j)&1)sum ^=j;\n\t\t}\n\t\tif(sum == 0){\n\t\t\tvec.pb(i);\n\t\t\t//if(i < 32)cout << i << endl;\n\t\t}\n\t}\n\t\n\tstatic int dp[1<<16];\n\tdp[0] = 0;\n\tfor(int i = 1 ; i < (1<<16) ; i ++){\n\t\tfor(int j = 0 ; j < vec.size() ; j ++){\n\t\t\tif((i&vec[j]) == vec[j]){\n\t\t\t\tdp[i] = max( dp[i] , dp[i^vec[j]] + 1 );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int N;\n\tstatic int x[100010],y[100010],a[100010];\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N-1 ; i ++){\n\t\tscanf(\"%d%d%d\",&x[i],&y[i],&a[i]);\n\t}\n\t\n\tstatic int b[100010] = {};\n\tfor(int i = 1 ; i <= N-1 ; i ++){\n\t\tb[x[i]] ^= a[i];\n\t\tb[y[i]] ^= a[i];\n\t}\n\t\n\t/*for(int i = 0 ; i < N ; i ++){\n\t\tprintf(\"%d \",b[i]);\n\t}\n\tcout << endl;*/\n\t\n\tstatic int cnt[1<<4] = {};\n\tfor(int i = 0 ; i < N ; i ++){\n\t\tcnt[b[i]] ++;\n\t}\n\t\n\tstatic int ret = cnt[0];\n\tstatic int t = 0;\n\tfor(int i = 1 ; i <= 15 ; i ++){\n\t\tret += cnt[i]/2;\n\t\tif(cnt[i]&1)t |= 1<<i;\n\t}\n\t//cout << t << \" \" << dp[t] << endl;\n\tret += dp[t];\n\t\n\tcout << N-ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Set(a,b) memset(a,b,sizeof(a))\ntemplate<class T>inline void init(T&x){\n\tx=0;char ch=getchar();bool t=0;\n\tfor(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);\n\tif(t) x=-x;return;\n}typedef long long ll;\nconst int N=1e5+10;\nstruct edge{\n\tint to,next,w;\n}a[N<<1];\nint head[N],cnt=0;\ninline void add(int x,int y,int w){a[++cnt]=(edge){y,head[x],w};head[x]=cnt;}\nint ans=0,n;\nint bac[20];\nint dfs(int u,int fa,int fr){\n\tfor(int v,i=head[u];i;i=a[i].next) {v=a[i].to;if(v==fa) continue;fr^=dfs(v,u,a[i].w);}\n\tif(fr&&fa) ++bac[fr];return 0;\n}\nint dp[1<<16];\ninline int DP(int s){\n\tif(~dp[s]) return dp[s];\n\tdp[s]=1e9;\n\tfor(int i=1;i<16;++i) {\n\t\tif(s&(1<<i)) {\n\t\t\tdp[s]=min(dp[s],DP(s^(1<<i))+1);\n\t\t\tfor(int j=i+1;j<16;++j) {\n\t\t\t\tif(s&(1<<j)) {\n\t\t\t\t\tint t=s^(1<<i)^(1<<j);\n\t\t\t\t\tint k=i^j;int f=1;\n\t\t\t\t\tif(t&(1<<k)) t^=1<<k,++f;\n\t\t\t\t\telse t|=1<<k;\n\t\t\t\t\tf+=DP(t);dp[s]=min(dp[s],f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tinit(n);Set(dp,-1);\n\tfor(int i=1;i<n;++i) {\n\t\tint u,v,w;init(u),init(v),init(w);\n\t\t++u,++v;add(u,v,w),add(v,u,w);\n\t}dfs(1,0,0);\n\tint ans=0;int s=0;\n\tdp[0]=0;\n\tfor(int i=1;i<16;++i) {ans+=bac[i]>>1;bac[i]&=1;if(bac[i]) s|=1<<i;}\n\tans+=DP(s);cout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Maxn = 100010;\nconst int inf = 0x7fffffff;\nint po[Maxn];\nint f[1<<15], bit[1<<15], n;\nvector <int> vec[20];\nvoid down(int &x, int y) { if(x > y) x = y; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; i++){\n\t\tint x, y, d;\n\t\tscanf(\"%d%d%d\", &x, &y, &d);\n\t\tpo[x] ^= d; po[y] ^= d;\n\t}\n\tfor(i = 1; i < 1<<15; i++){ bit[i] = bit[i>>1]+(i&1); vec[bit[i]].push_back(i); }\n\tint p = 0, ans = 0;\n\tfor(i = 0; i < 1<<15; i++) f[i] = inf;\n\tfor(i = 0; i < n; i++){\n\t\tif(!po[i]) continue;\n\t\tif(p&(1<<po[i]-1)) ans++;\n\t\tp ^= (1<<po[i]-1);\n\t}\n\tf[p] = 0;\n\tfor(i = 15; i >= 1; i--){\n\t\tfor(j = 0; j < vec[i].size(); j++){\n\t\t\tint x = vec[i][j];\n\t\t\tif(f[x] == inf) continue;\n\t\t\tfor(k = 0; k < 15; k++){\n\t\t\t\tif(x&(1<<k)){\n\t\t\t\t\tfor(int u = 0; u < 15; u++){\n\t\t\t\t\t\tif(k != u && x&(1<<u)){\n\t\t\t\t\t\t\tint t = (k+1)^(u+1);\n\t\t\t\t\t\t\tif(x&(1<<t-1)) down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+2);\n\t\t\t\t\t\t\telse down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define lson l,(l+r)/2,rt<<1\n#define rson (l+r)/2+1,r,rt<<1|1\n#define dbg(x) cout<<#x<<\" = \"<< (x)<< endl\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define sz(x) (int)(x).size()\nconst int mxn=1e5+10;\nint b[mxn];\nint cnt[16];\nint a[20];\nint sz=0;\nint dp[mxn];\nbool flag[mxn];\ninline void check(int mask){\n\tint x=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(mask &(1<<i))x^=a[i];\n\t}\n\tflag[mask]= (x==0);\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\tb[u]^=w;\n\t\tb[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcnt[b[i]]++;\n\t}\n\tint component=cnt[0];\n\tfor(int i=1;i<16;i++){\n\t\tcomponent+=cnt[i]/2;\n\t\tif(cnt[i]%2)a[sz++]=i;\n\t}\n\tint up=(1<<sz)-1;\n\tfor(int i=1;i<=up;i++){\n\t\tcheck(i);\n\t\tfor(int x=i;x;x=((x-1)&i)){\n\t\t\tif(flag[i])dp[i]=max(dp[i],1+dp[x^i]);\n\t\t}\n\t}\n\tcout<<n-component-dp[up];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint cnt[20],v[20];\nint dp[N];\nint dfs(int s)\n{\n\tif(s==0) return 0;\n\tif(dp[s]!=-1) return dp[s];\n\tdp[s]=0x3f3f3f3f;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tif(s>>i&1)\n\t\t{\n\t\t\tfor(int j=0;j<16;j++)\n\t\t\t{\n\t\t\t\tif(s>>j&1)\n\t\t\t\t{\n\t\t\t\t\tint x=j^i;\n\t\t\t\t\tint ns=s^(1<<j)^(1<<i)^(1<<x);\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t dp[s]=min(dp[s],dfs(ns)+1+((s&(1<<x))==(1<<x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;\n\t\tv[y]^=z; \n\t}\n\tmemset(dp,-1,sizeof dp);\n\tfor(int i=0;i<n;i++)\n\t if(v[i]) cnt[v[i]]++;\n\tint ans=0,st=0;;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst|=(cnt[i]&1)<<i;\n\t}\n\tans+=dfs(st);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n    tn x=0,f=1;char c=' ';\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar() ) x=x*10+c-'0';\n    a=x*f;\n}\nconst int N=1e5+5;\nconst int M=1<<16;\nint a[N],n,bak[16],cnt,f[M];\nbool b[N],v[M],g[M];\nbool cmx[16];\nint dfs(int x){\n\tif(v[x]) return f[x];\n\tint lpl=0;\n\tfor(int s=x;s;s=(s-1)&x)\n\t\tif(g[s]) lpl=max(lpl,1+dfs(x^s));\n\tv[x]=1;\n\treturn (f[x]=lpl); \n}\nbool calc(int x){\n\tmemset(cmx,0,sizeof(cmx));\n\tfor(int i=0;x;i++){\n\t\tcmx[i]=(x&1);\n\t\tx>>=1;\n\t} \n\tint z=0;\n\tfor(int i=0;i<16;i++)\n\t\tif(cmx[i]) z^=i;\n\treturn (z==0);\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,c;\n\t\tread(x);read(y);read(c);\n\t\tif(!b[x]){\n\t\t\tb[x]=1;a[x]=c;\n\t\t\tcontinue;\n\t\t}\n\t\tb[y]=1;a[y]=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tprintf(\"%d \",a[i]);\n\tfor(int i=1;i<=n;i++) bak[a[i]]++;\n\tcnt=bak[0];\n\tfor(int i=1;i<16;i++){\n\t\tcnt+=bak[i]>>1;\n\t\tbak[i]%=2;\n\t} \n\tfor(int i=0;i<M;i++)\n\t\tg[i]=calc(i);\n\tint tot=bak[0];\n\tfor(int i=1;i<=15;i++){\n\t\ttot<<=1;\n\t\ttot+=bak[i];\n\t}\n\tputs(\"\");\n\tv[0]=1;\n\tprintf(\"%d\\n\",n-dfs(tot)-cnt+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, num[16], ret[1<<16];\nvpi adj[MX], ADJ[MX];\n\nint dfs(int x, int pre, int val) {\n    for (auto a: adj[x]) if (a.f != pre) {\n        dfs(a.f,x, a.s);\n        val ^= a.s;\n    }\n    if (x) num[val] ++;\n    return val;\n}\n\nvoid addEdge(int z, int i, int j) {\n    int Z = z; Z ^= 1<<i;\n    if (j == -1) {\n        ADJ[Z].pb({z,1});\n    } else {\n        Z ^= 1<<j;\n        if (Z & 1<<(i^j)) ADJ[Z^(1<<(i^j))].pb({z,2});\n        else ADJ[Z^(1<<(i^j))].pb({z,1});\n    }\n}\n\nvoid gen() {\n    F0R(z,1<<16) if (!(z&1)) {\n        F0R(i,16) if (z&(1<<i)) {\n            FOR(j,1,16) if (i != j && (z&(1<<j))) addEdge(z,i,j);\n            addEdge(z,i,-1);\n        }\n    }\n    \n    FOR(i,1,1<<16) ret[i] = MOD;\n    vi todo[17]; todo[0].pb(0); ret[0] = 0;\n    F0R(i,16) while (sz(todo[i])) {\n        int x = todo[i].back(); todo[i].pop_back();\n        if (ret[x] != i) continue;\n        for (auto a: ADJ[x]) if (i+a.s < ret[a.f]) {\n            ret[a.f] = i+a.s;\n            todo[ret[a.f]].pb(a.f);\n        }\n    } \n    /*cout << \"ZZ \" << ret[(1<<16)-2] << \"\\n\";\n    cout << \"ZZ \" << ret[(1<<3)^(1<<4)^(1<<7)] << \"\\n\";\n    cout << \"ZZ \" << ret[(1<<3)^(1<<4)] << \"\\n\";\n    exit(0);*/\n}\n\nint main() {\n    gen();\n    // freopen(\"Input.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N-1) {\n        // int a = i,b = i+1,c = 13; \n        int a,b,c; cin >> a >> b >> c;\n        // cout << a << \" \" << b << \"\\n\";\n        adj[a].pb({b,c}), adj[b].pb({a,c});\n    }\n    dfs(0,-1,0); num[0] = 0;\n    int cur = 0, ans = 0;\n    F0R(i,16) {\n        ans += num[i]/2; \n        if (num[i]&1) cur ^= (1<<i);\n    }\n    cout << ans+ret[cur];\n    // F0R(i,16) cout << num[i] << \" \";\n    // cout << \"\\n\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst long long mod = 1000000007;\nconst int maxn = 100100;\nint deg[maxn], cnt[16];\nint dp[1<<16], xo[1<<16];\nint main(){\n    int n;\n    cin >> n;\n    for(int e = 0; e < n - 1; e++){\n        int u, v, w;\n        cin >> u >> v >> w;\n        deg[u] ^= w;\n        deg[v] ^= w;\n    }\n    for(int e = 0; e < n; e++){\n        cnt[deg[e]]++;\n    }\n    int ans = cnt[0];\n    for(int e = 1; e < 16; e++){\n        ans += cnt[e] / 2;\n        cnt[e] %= 2;\n    }\n    for(int e = 1; e < 1<<16; e++){\n        xo[e] = 0;\n        for(int f = 0; f < 15; f++)\n            if(e & (1<<f)) xo[e] ^= f;\n    }\n    dp[0] = 0;\n    for(int e = 1; e < 1<<16; e++){\n        for(int f = e; f > 0; f = (f - 1) & e){\n            if(xo[f] == 0) dp[e] = max(dp[e], dp[f] + 1);\n        }\n    }\n    int msk = 0;\n    for(int e = 1; e < 16; e++)\n        if(cnt[e]) msk |= (1<<e);\n    ans += dp[msk];\n    cout << n - ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#define N 100020\n#define M 16\nusing namespace std;\n\nint a[N];\nbool u[N];\nint f[1 << M | 1], g[1 << M | 1];\n\nint main(void)\n{\n    int n, u, v, w;\n    int i, j, o;\n\n    scanf(\"%d\", &n);\n    for(i = 1; i < n; i ++)\n    {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        a[u] ^= w;\n        a[v] ^= w;\n    }\n    for(i = o = 0; i < n; i ++)\n        if(a[i])\n        {\n            o += ::u[a[i]];\n            ::u[a[i]] ^= 1;\n        }\n    for(i = n = 0; i < M; i ++)\n        if(::u[i])\n            a[n ++] = i;\n\n    // for(i=0;i<n;i++)cout<<a[i]<<' ';cout<<endl;\n\n    for(i = 1; i < (1 << n); i ++)\n    {\n        f[i] = __builtin_popcount(i) - 1;\n        g[i] = g[i & (i - 1)] ^ a[__builtin_ctz(i)];\n        for(j = i & (i - 1); j; j = i & (j - 1))\n            if(!g[j])\n                f[i] = min(f[i], f[j] + f[i ^ j]);\n    }\n    printf(\"%d\\n\", o + f[(1 << n) - 1]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxm], dp[1 << 16];\nll cnt[maxn];\nll ans;\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << (i - 1));\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[init] = 0;\n    for(int i = 15;i > 0;i--){\n        for(int S = 0;S < (1 << 15);S++){\n            ll cnt = 0;\n            for(int k = 0;k < 15;k++){\n                if((S >> k) & 1) cnt++;\n            }\n            if(cnt != i) continue;\n            // cout << cnt << \" \" << S << endl;\n            for(int k = 0;k < 15;k++){\n                if(!((S >> k) & 1)) continue;\n                for(int w = 0;w < 15;w++){\n                    if(k == w) continue;\n                    if(!((S >> w) & 1)) continue;\n                    ll newnum = ((k + 1) ^ (w + 1)) - 1;\n                    if(((S >> newnum) & 1) == 1){\n                        dp[(S ^ (1 << k) ^ (1 << w)) ^ (1 << newnum)] = \n                        min(dp[S ^ (1 << k) ^ (1 << w) ^ (1 << newnum)], dp[S] + 2);\n                    } else {\n                        dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)] = \n                        min(dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)], dp[S] + 1);\n                    }\n                }\n            }\n        }\n    }\n    ans += dp[0];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    ans+=cnt[0];\n    for(int i=1; i<16; i++) ans+=cnt[i]>>1, cnt[i]%=2;\n    cnt[0]=0;\n    dp[0]=0;\n    vector<int> v;\n    for(int i=0; i<16; i++) if(cnt[i]) v.eb(i);\n    int m=v.size();\n    for(int mask=1; mask<(1<<m); mask++){\n        int nw=0;\n        for(int i=0; i<m; i++) if((mask>>i)&1) nw^=v[i];\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<m); mask++){\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=max(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<m)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, A[MX];\nint cnt[16];\n\nint B[1<<16];\nint D[1<<16];\n\nint d(int mask){\n    int &res=D[mask];\n    if(res<inf) return res;\n    cout<<mask<<'\\n';\n    for(int i=mask; i>0; i=(i-1)&mask)\n        if(B[i]>=0) res=min(res, d(mask^i)+B[i]-1);\n    return res;\n}\n\nbool valid(int s){\n    int res=0;\n    for(int i=0; i<16; i++) if(s&(1<<i)) res^=i;\n    return res==0;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for(int i=1; i<n; i++){\n        int u,v,c; cin>>u>>v>>c;\n        A[u]^=c, A[v]^=c;\n    }\n\n    for(int i=0; i<n; i++) cnt[A[i]]++;\n    int ans=0, mask=0;\n    for(int i=1; i<16; i++) ans+=cnt[i]/2, cnt[i]%=2;\n    for(int i=1; i<16; i++) if(cnt[i]) mask|=(1<<i);\n\n    for(int i=0; i<(1<<16); i++){\n        if(valid(i)) B[i]=__builtin_popcount(i);\n        else B[i]=-1;\n    }\n\n    for(int i=0; i<(1<<16); i++) D[i]=inf;\n    D[0]=0;\n\n    ans+=d(mask);\n\n    cout<<ans<<'\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=1;i<(1<<16);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=1;j<16;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=j;\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n\t\t}\n\t}\n\treturn;\n}//Accepted\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}//Accepted\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=(1<<i);\n\t\t}\n\t}\n\tinit();//Accetped\n\tfor(int i=0;i<=mask;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, ans, a[N], cnt[M], dp[N];\n\nbool ok(int mask) {\n\tint res = 0;\n\tfor (int i = 0; i < M; i++)\n\t\tif (mask & (1 << i))\n\t\t\tres ^= i;\n\treturn res == 0;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tfor (int i = 1; i < M; i++) {\n\t\tans += (cnt[i] >> 1);\n\t\tcnt[i] &= 1;\n\t}\n\tint mask = 0;\n\tfor (int i = 1; i < M; i++)\n\t\tif (cnt[i])\n\t\t\tmask |= 1 << i;\n\tans += max(0, __builtin_popcount(mask) - 1);\n\tfor (int x = 1; x <= mask; x++) {\n\t\tif ((mask & x) == x)\n\t\t\tfor (int y = x; y; y = (--y & x))\n\t\t\t\tif (y < x && ok(y))\n\t\t\t\t\tdp[x] = max(dp[x], dp[y] + dp[x ^ y]);\n\t}\n\tans -= dp[mask];\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Sasayego! Sasayego! Shinzou wo Sasageyo!\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <ctime>\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define lid (id << 1)\n#define rid (lid ^ 1)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll, ll> pll;\ntypedef pair <int, int> pii;\n\nconst int maxN = 1e5 + 5;\nconst int maxA = 15;\nconst int maxK = (1 << maxA) + 5;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nint a[maxN], cnt[16];\nint l = 0, b[maxN];\nint arumin[2][maxK];\n\nint main(){\n\ttime_t START = clock();\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++){\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\tfor (int i = 1; i < 16; i++){\n\t\tans += (cnt[i] >> 1);\n\t\tcnt[i] &= 1;\n\t\tif (cnt[i])\n\t\t\tb[l++] = i;\n\t}\n\tfor (int mask = 1; mask < (1 << l); mask++){\n\t\tint lb = __builtin_ctz(mask);\n\t\tarumin[0][mask] = b[lb] ^ arumin[0][mask ^ (1 << lb)];\n\t\tif (arumin[0][mask] == 0){\n\t\t\tarumin[1][mask] = 1;\n\t\t\tfor (int sub = mask & (mask - 1); sub > 0; sub = (sub - 1) & mask)\n\t\t\t\tif (arumin[0][sub] == 0)\n\t\t\t\t\tarumin[1][mask] = max(arumin[1][mask], arumin[1][sub] + arumin[1][mask ^ sub]);\n\t\t}\n\t}\n\tans += l - arumin[1][(1 << l) - 1];\n\tprintf(\"%d\\n\", ans);\n\ttime_t FINISH = clock();\n\tcerr << \"Execution time: \" << (ld)(FINISH - START) / CLOCKS_PER_SEC * 1000.0 << \" milliseconds.\\n\";\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\n// const int na = 1<<11;\n// int A[na];\n\nlli dp[1<<16];\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n; cin>>n;\n  vi D(n);\n  FOR(i,n-1) {\n    lli u,v,e; cin>>u>>v>>e;\n    D[u] ^= e; D[v] ^= e;\n  }\n  vi C(16); FOR(i,n) C[D[i]]++;\n  lli ans=0;\n  lli bs = 0;\n  FOR(i,16) if(i) {\n    ans += C[i]/2;\n    C[i] %= 2;\n    if(C[i]) bs |= (1<<i);\n  }\n  FOR(m,1<<16) if(m) {\n    dp[m] = 1ll<<60;\n    FOR(i,16) if(i) FOR(j,16) if(j) if(i!=j && (m&(1<<i)) && (m&(1<<j))) {\n      int m2 = m^(1<<i)^(1<<j);\n      if(m2 & (1<<(i^j))) {\n        dp[m] = min(dp[m], dp[m2^(1<<(i^j))]+2);\n      }else{\n        dp[m] = min(dp[m], dp[m2^(1<<(i^j))]+1);\n      }\n    }\n  }\n  cout << ans+dp[bs] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nint N;\nvector<int> x, y, a;\nmap<int, vector<pint>> edges;\n\nvector<int> dp;\nint dfs(int now, int prv, int val = 0)\n{\n    dp[now] = val;\n    for (auto nxt : edges[now]) if (nxt.first != prv)\n    {\n        dp[now] = dp[now] xor dfs(nxt.first, now, nxt.second);\n    }\n    return dp[now];\n}\n\n// Solve ax+by=gcd(a, b)\nlint extgcd(lint a, lint b, lint &x, lint &y)\n{\n    lint d = a;\n    if (b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    else x = 1, y = 0;\n    return d;\n}\n// Calc a^(-1) (MOD m)\nlint mod_inverse(lint a, lint m)\n{\n    lint x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\nvector<vector<lint>> gauss_jordan(vector<vector<lint>> mtr, lint mod)\n{\n    // Gauss-Jordan elimination è¡åºæ¬å¤å½¢ã®ã¿ãç¨ããã¬ã¦ã¹æ¶å»æ³\n    int H = mtr.size(), W = mtr[0].size(), c = 0;\n    REP(h, H)\n    {\n        if (c == W) break;\n        int piv = -1;\n        FOR(j, h, H) if (mtr[j][c])\n        {\n            if (piv == -1 or abs(mtr[j][c]) > abs(mtr[piv][c])) piv = j;\n        }\n        if (piv == -1) { c++; h--; continue; }\n        swap(mtr[piv], mtr[h]);\n        if (h != piv) REP(w, W) mtr[piv][w] = mtr[piv][w] ? mod - mtr[piv][w] : 0; // è¡åå¼ç¬¦å·ä¸å¤\n        lint pivinv = mod_inverse(mtr[h][c], mod);\n        FOR(hh, h + 1, H) IFOR(w, c, W) mtr[hh][w] = (mtr[hh][w] - mtr[h][w] * mtr[hh][c] % mod * pivinv % mod + mod) % mod;\n        c++;\n    }\n    return mtr;\n}\n\n\nint main()\n{\n    cin >> N;\n    x.resize(N - 1);\n    y.resize(N - 1);\n    a.resize(N - 1);\n    dp.resize(N);\n    REP(i, N - 1)\n    {\n        cin >> x[i] >> y[i] >> a[i];\n        edges[x[i]].emplace_back(y[i], a[i]);\n        edges[y[i]].emplace_back(x[i], a[i]);\n    }\n    dfs(0, -1);\n    dbg(dp);\n    vector<int> cou(16);\n    REP(i, N)\n    {\n        int st = 0;\n        for (auto nxt : edges[i]) st = st xor nxt.second;\n        cou[st]++;\n    }\n    // for (auto v : dp) cou[v]++;\n    int ans = 0;\n    cou[0] = 0;\n    for (auto &c : cou)\n    {\n        ans += c / 2;\n        c %= 2;\n    }\n\n    vector<vector<lint>> mat(cou.size(), vector<lint>(4));\n    int nok = 0;\n    REP(i, cou.size()) if (cou[i])\n    {\n        nok++;\n        REP(d, 4) mat[i][d] = ((POW2(d) & i) != 0);\n    }\n\n    auto mat2 = gauss_jordan(mat, 2);\n    int rank = 0;\n    REP(h, mat2.size()) for (auto v : mat2[h]) if (v) mmax(rank, h + 1);\n    ans += rank - 1 + (nok - rank + 2) / 2;\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<17)+10],ans;\nint dp(int s)\n{\n\tif(!s)\n\t\treturn 0;\n\tif(f[s])\n\t\treturn f[s];\n\tf[s]=INF;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tif(!(s&(1<<i)))\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=15;j++)\n\t\t{\n\t\t\tif(i==j||!(s&(1<<j)))\n\t\t\t\tcontinue;\n\t\t\tint k=i^j;\n\t\t\tint t=s^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif(s&(1<<k))\n\t\t\t\tf[s]=min(f[s],dp(t)+2);\n\t\t\telse\n\t\t\t\tf[s]=min(f[s],dp(t)+1);\n\t\t}\n\t}\n\treturn f[s];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=((book[i]&1)<<i);//å¥æ°æåå©ä¸\n\t}\n\tprintf(\"%d\",ans+dp(s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\nconst int N=2e5;\nint ans,n,a[N],t=-1,f[1<<20][20],q[N];\nint main()\n{\n\tn=read();\n\tint x,y,v;\n\tfor(int i=1;i<n;++i)x=read()+1,y=read()+1,v=read(),a[x]^=v,a[y]^=v;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)\n\tif(i<n&&a[i]==a[i+1]) a[i]!=0?ans++:0,i+=2;\n\telse q[++t]=a[i];\n\tmemset(f,0x3f,sizeof(f));\n\tfor(int i=0;i<t;++i)\n\t{\n\t\tf[1<<i][q[i]]=0;\n\t\tfor(int i=0;i<16;++i)if(i!=q[i])f[1<<i][i]=1;\n\t}\n\tfor(int i=0;i<(1<<t);++i)\n\tfor(int j=0;j<16;++j)\n\tfor(int k=0;k<t;++k)\n\tif(i&(1<<k))\n\tf[i][j]=min(f[i][j],f[i-(1<<k)][j^q[k]]+1);\n\tprintf(\"%d\\n\",f[(1<<t)-1][0]+ans);\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5, M = 15;\n\nint A[N], C[M + 1], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 0; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 0; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tint x = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) C[A[i]] ^= A[i], x ^= (1 << (A[i] - 1)), cnt += !C[A[i]];\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[25]={0},f[(1<<16)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint all=15,s=0,res=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=0;i<=all;i++)res+=v[i]/2,v[i]%=2,s|=(1<<v[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<all);i++)\n\t\tfor(int u=0;u<=15;u++){\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=15;v++){\n\t\t\t\tif(i&(1<<v)){\n\t\t\t\t\tint w=u^v;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long\t  ll;\ntypedef long double ld;\n\nconst int MAXN= 1e5+10;;\n\nint n;\n\nvector<pair<int,int>> adj[MAXN];\n\nint mem[MAXN];\n\nbool vis[MAXN];\nint dfs(int u, int bm, int p=-1) { //returns cost if we get i for free\n\tif (vis[u])  return mem[u];\n\tvis[u] = 1;\n\tint ans[16], nans[16];\n\tmemset(ans, 0x3f, sizeof ans);\n\tmemset(nans, 0x3f, sizeof nans);\n\tans[bm] = 0;\n\tfor(auto pp: adj[u]) {\n\t\tint v = pp.first;\n\t\tint c = pp.second;\n\t\tif (v==p) continue;\n\t\tdfs(v,c,u);\n\t}\n\tfor(auto pp: adj[u]) {\n\t\tint v = pp.first;\n\t\tint c = pp.second;\n\t\tif (v==p) continue;\n\t\t//cerr << \"@ \" << u << \" going to \" << v <<endl;\n\t\tfor(int ibm=0;ibm<16;ibm++) {\n\t\t\tnans[ibm] = min(nans[ibm], ans[ibm]+dfs(v, c, u)+(ibm>0));\n\t\t\tnans[ibm^c] = min(nans[ibm^c], ans[bm^c]+dfs(v, c, u)+((bm^c)>0));\n\t\t}\n//\t\tfor(int ibm=0;ibm<16;ibm++) { cerr << nans[ibm] << \" \"; } cerr <<endl;\n\t\tswap(ans, nans);\n\t\tmemset(nans, 0x3f, sizeof nans);\n\t}\n\tmem[u] = ans[0];\n\tfor(int i=1;i<16;i++) {\n\t\tmem[u] = min(ans[i], mem[u]);\n\t}\n\treturn mem[u];\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor(int i=0;i<n-1;i++) {\n\t\tint x, y, a;\n\t\tcin >> x >> y>> a;\n\t\tadj[x].push_back({y,a});\n\t\tadj[y].push_back({x,a});\n\t}\n\tint leaf=0;\n\tfor(int i=0;i<n;i++) {\n\t\tif (adj[i].size() == 1) {\n\t\t\tleaf = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ans = MAXN;\n\tfor(int i=0;i<=15;i++) {\n\t\tans = min((i>0)+dfs(leaf,i), ans);\n\t}\n\n\tcout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst int MX = 100005;\nint n, x, y, a, b[MX], c[16], ans, d[1<<16], k, t;\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n-1){\n\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\tb[x] ^= a;\n\t\tb[y] ^= a;\n\t}\n\trep(i,n) c[b[i]]++;\n\tfor(int i=1; i<1<<16; i++){\n\t\tk = 0;\n\t\trep(j,16) if(i>>j&1) k ^= j;\n\t\tif(!k){\n\t\t\td[i] = 1;\n\t\t\tfor(int j=(i-1)&i; j; j=(j-1)&i) d[i] = max(d[i], d[j]+d[j^i]);\n\t\t}\n\t}\n\tfor(int i=1; i<16; i++){\n\t\tans += c[i] / 2;\n\t\tif(c[i]&1) t ^= 1<<i;\n\t}\n\tprintf(\"%d\\n\", ans + __builtin_popcount(t) - d[t]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    for(Int i=0;i<16;i++){      \n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\t{\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^(i&j));\n\t  fix(j^(i&j));\n\t  assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t}\n        {\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^j);\n\t  fix(0);\n\t  assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t}\n      }\n    }\n  }\n  \n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint in[N],n,ans,is,msk,to = 1<<26,from,lol = 1;\nvector<int>v;\nshort dp[1<<26];\nvoid val(int msk){\n\tv.clear();\n\twhile(msk)\n\t\tv.push_back(msk%3),\n\t\tmsk/=3;\n\twhile(v.size() < 16)v.push_back(0);\n\treverse(v.begin(),v.end());\n}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1,a,b,c;i < n;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tin[a]^=c;\n\t\tin[b]^=c;\n\t}\n\tfor(int i = 0;i < n;i++)\n\t\tans+=!!(is&(1<<in[i])) && in[i],\n\t\tis^=1<<in[i];\n\tis&=(~0) - 1;\n\tfor(int i = 0;i < to;i++)dp[i] = 17;\n \tfor(int i = 15;i + 1;i--)msk = msk*3 + (!(is&(1<<i)) ? 2 : 0),lol*=3;\n \t\tlol/=3;\n\tdp[msk] = 0;\n\tfor(int i = 0;i < to;i++)\n\t\tif(dp[i] < 17){\n\t\t\tval(i);\n\t\t\tint three = lol, freq = 0,temp = 0;\n\t\t\tfrom = 0;\n\t\t\tfor(int j = 0;j < 16;j++,three/=3){\n\t\t\t\tif(!v[j])dp[i + three] = min(dp[i + three],dp[i]);\n\t\t\t\tif(v[j] == 1)temp^=(15 - j),freq++;\n\t\t\t\tfrom = from*3 + (v[j] ? 2 : 0);\n\t\t\t}\n\t\t\tshort lol = dp[i] + freq - (freq > 1);\n\t\t\tif(!temp)dp[from] = min(dp[from],lol);\n\t\t}\n\tfrom = 0;\n\tfor(int i = 0;i < 16;i++)from = from*3 + 2;\n\tcout << ans + dp[from] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sign(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N;\nint x[110000], y[110000], a[110000];\nint t[110000], cnt[16];\nint dp[bit(16)][16];\nsigned main() {\n    cin >> N;\n    rep(i, N - 1) {\n        cin >> x[i] >> y[i] >> a[i];\n        t[x[i]] ^= a[i], t[y[i]] ^= a[i];\n    }\n    rep(i, N) { cnt[t[i]]++; }\n    vint v;\n    int ans = 0;\n    reps(i, 15) {\n        ans += cnt[i] / 2;\n        if (cnt[i] & 1) { v.emplace_back(i); }\n    }\n    rep(i, bit(16)) { rep(j, 16) { dp[i][j] = INT_MAX; }}\n    dp[0][0] = 0;\n    rep(i, bit(v.size())) {\n        rep(j, 16) {\n            rep(k, v.size()) {\n                if (i & bit(k)) { continue; }\n                int inc = (j ^ v[k]) ? 1 : 0;\n                chmin(dp[i | bit(k)][j ^ v[k]], dp[i][j] + inc);\n            }\n        }\n    }\n    ans += dp[bit(v.size()) - 1][0];\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 100005\n#define MAXM 65537\n#define INF 0x3f3f3f3f\n//#define int long long\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0'||ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0'&&ch<='9'){\n\t\tx=(x*10)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nint dp[MAXM];\nint val[MAXN],cnt[MAXN];\nint dfs(int s){\n\t//printf(\"s:%d\\n\",s);\n\tif (s==0) return dp[s]=0;\n\tif (dp[s]!=INF) return dp[s];\n\tfor (register int i=0;i<16;++i){\n\t\tif (!(s&(1<<i))) continue;\n\t\tfor (register int j=0;j<16;++j){\n\t\t\tif (i==j||(!(s&(1<<j)))) continue;\n\t\t\tint p=i^j;\n\t\t\tdp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<p))+1+((s&(1<<p))?1:0));\n\t\t}\n\t}\n\treturn dp[s];\n}\n//#undef int\nint main(){\n//#define int long long\n\tint n=read();\n\tfor (register int i=1;i<n;++i){\n\t\tint u=read()+1,v=read()+1,w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor (register int i=1;i<=n;++i){\n\t\tcnt[val[i]]++;\n\t}\n\tint ans=0,s=0;\n\tfor (register int i=1;i<16;++i){\n\t\tans+=cnt[i]>>1;\n\t\tif (cnt[i]&1) s|=(1<<i);\n\t}\n\t//printf(\"OK\\n\");\n\tmemset(dp,0x3f,sizeof(dp));\n\tprintf(\"%d\\n\",ans+dfs(s));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n//#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\n//int mod = 1000000007;\n//int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n#define N_max 100000\nint cnt[16] = {};\nint xx[N_max] = {};\n\n\nsigned main(){\n\n    int N;\n    scanf(\"%d\", &N);\n    int x, y, a;\n    REP(i, N - 1){\n        scanf(\"%d %d %d\", &x, &y, &a);\n        xx[x] ^= a, xx[y] ^= a;\n    }\n    REP(i, N) cnt[xx[i]]++;\n\n    int ans = 0, X = 0;\n    REP(i, 15){\n        ans += cnt[i + 1] / 2;\n        if(cnt[i + 1] & 1) X ^= bit(i);\n    }\n    //ans += dp[X];\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\tå°è¾¹å¼æè½¬åæç¹å¼æ\n\tæåç¶å dp å³å¯ \n*/\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define N 100005\n\nusing namespace std;\n\nconst int upp = 1 << 16;\n\nint n, ans, fin;\nint val[N], f[upp], cnt[16];\nbool legal[upp];\n\ninline int bitcnt(int x) {\n\tint res = 0;\n\tfor(int i = x; i; i -= i & -i)\n\t\t++res;\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, u, v, w; i < n; ++i) {\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t++u, ++v;\n\t\tval[u] ^= w, val[v] ^= w;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t\t++cnt[val[i]];\n\n\tcnt[0] = 0;\n\tfor(int i = 1; i < 16; ++i) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1) fin |= 1 << i;\n\t}\n\n\tfor(int i = 0; i < upp; ++i) {\n\t\tint r = 0;\n\t\tfor(int o = 0; o < 16; ++o)\n\t\t\tif(i >> o & 1)\n\t\t\t\tr ^= o;\n\t\tif(!r) legal[i] = true;\n\t}\n\n\tmemset(f, 32, sizeof f), f[0] = 0;\n\tfor(int i = 1; i <= fin; ++i) {\n\t\tif((fin | i & fin) != fin || !legal[i]) continue;\n\t\tf[i] = bitcnt(i) - 1;\n\t\tfor(int x = i; x; x = x - 1 & i) {\n\t\t\tint y = i ^ x;\n\t\t\tif(legal[x] && legal[y])\n\t\t\t\tf[i] = min(f[i], f[x] + f[y]);\n\t\t}\n\t}\n\n\tans += f[fin];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<set<int> > edges;\n\nint dp(int v, int p){\n\tint sum = 0;\n\tbool seen = false;\n\tfor(int w : edges[v]){\n\t\tif(w == p) continue;\n\t\tint x = dp(w, v);\n\t\tif(x == 0){\n\t\t\tif(seen){\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\tseen = true;\n\t\t\t}\n\t\t}\n\t\tsum += x;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tedges.resize(n);\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tedges[u].insert(v);\n\t\tedges[v].insert(u);\n\t}\n\tint nl = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(edges[i].size() == 1) nl++;\n\t}\n\tvector<bool> done(n, false);\n\tfor(int i = 0; i < n; i++){\n\t\tint v = i;\n\t\tif(edges[v].size() != 1) continue;\n\t\twhile(true){\n\t\t\tint w = *edges[v].begin();\n\t\t\tif(done[w]) break;\n\t\t\tif(edges[w].size() == 2){\n\t\t\t\tedges[v].erase(w);\n\t\t\t\tedges[w].erase(v);\n\t\t\t\tv = w;\t\t\t\t\n\t\t\t} else {\n\t\t\t\tdone[w] = true;\n\t\t\t\tnl--;\n\t\t\t}\n\t\t}\n\t}\n\tnl = max(nl, 1);\n\tcout << nl << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 200005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\nstring bins(int x, int n) {\n  string res;\n  rep(i,n) res += \"01\"[x&1], x >>= 1;\n  reverse(rng(res));\n  return res;\n}\n\nconst int n = 16;\nconst int n2 = 1<<n;\n\nint c[n];\nint dp[n2];\nint ok[n2];\n\nvi to[MX];\nvi co[MX];\n\nint dfs(int v, int p=-1) {\n  int cur = 0, px = 0;\n  rep(i,sz(to[v])) {\n    int u = to[v][i];\n    if (u == p) {\n      px = co[v][i];\n      continue;\n    }\n    int r = dfs(u,v);\n    cur ^= r;\n  }\n  int now = cur^px;\n  if (now) c[now]++;\n  return cur^now;\n}\n\nint main() {\n  int m;\n  scanf(\"%d\",&m);\n  rep(i,m-1) {\n    int a,b,x;\n    scanf(\"%d%d%d\",&a,&b,&x);\n    to[a].pb(b); co[a].pb(x);\n    to[b].pb(a); co[b].pb(x);\n  }\n  dfs(0);\n  int s = 0, ans = 0;\n  rep(i,n) {\n    ans += c[i]/2;\n    s |= (c[i]&1)<<i;\n  }\n  // cerr<<bins(s,n)<<endl;\n  rep(i,n2) {\n    int x = 0;\n    rep(j,n) if (i>>j&1) x ^= j;\n    ok[i] = !x;\n  }\n  rep(i,n2) dp[i] = -INF;\n  dp[s] = 0;\n  drep(i,n2) {\n    if (dp[i] == INF) continue;\n    for (int j = i; j; j = (j-1)&i) {\n      if (ok[j]) maxs(dp[i^j], dp[i]+1);\n    }\n  }\n\n  ans += pcnt(s)-dp[0];\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nusing edge = struct {int to, cost;};\nvector<edge> graph[limit];\n\nint group[1 << 16];\nint value[limit];\n\nvoid dfs(int v, int p, int x) {\n\tvalue[v] = x;\n\tfor (auto &e : graph[v]) {\n\t\tif (e.to == p) continue;\n\t\tdfs(e.to, v, x ^ e.cost);\n\t}\n\treturn;\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tgroup[0] = 0;\n\trep(mask, 1 << 16) {\n\t\trep(i, 1, 16) {\n\t\t\tif (mask & (1 << i)) continue;\n\t\t\tconst int nmask = mask | (1 << i);\n\t\t\tint cur = 0;\n\t\t\trep(j, 1, 16) if (nmask & (1 << j)) cur ^= j;\n\t\t\tchmax(group[nmask], group[mask] + (cur == 0));\n\t\t}\n\t}\n\n\trep(i, n - 1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgraph[x].push_back({y, a});\n\t\tgraph[y].push_back({x, a});\n\t}\n\n\tdfs(0, -1, 0);\n\n\tint ans = 1 << 30;\n\n\tvector<int> num(16, 0);\n\trep(i, n) {\n\t\tconst int x = value[i];\n\t\tnum[x]++;\n\t}\n\n\tint cur = n - num[0], mask = 0;\n\trep(i, 1, 16) {\n\t\tmask |= ((num[i] % 2) << i);\n\t\tcur -= num[i] / 2;\n\t}\n\tcur -= group[mask];\n\tchmin(ans, cur);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n \n#pragma comment(linker, \"/STACK:336777216\")  \n \nusing namespace std;\n\nconst int MAXN = 200000 + 10;\n\nint N;\nint To[MAXN], Wt[MAXN], Next[MAXN], Node[MAXN], nE;\nint iw[MAXN], rem[MAXN];\nint Cnt[MAXN][16];\n\nvoid InsertEdge(int a, int b, int c)\n{\n\tTo[nE] = b;\n\tWt[nE] = c;\n\tNext[nE] = Node[a];\n\tNode[a] = nE ++;\n}\n\nvoid DFS(int i, int Par)\n{\n\tfor (int e = Node[i]; e != -1; e = Next[e])\n\t{\n\t\tint j = To[e];\n\t\tif (j == Par) continue;\n\t\tiw[j] = iw[i] ^ Wt[e];\n\t\tDFS(j, i);\n\t}\n\n\trem[i] = iw[i];\n\tfor (int e = Node[i]; e != -1; e = Next[e])\n\t{\n\t\tint j = To[e];\n\t\tif (j == Par) continue;\n\t\tfor (int msk = 0; msk < 16; msk ++)\n\t\t{\n\t\t\tCnt[i][msk] += Cnt[j][msk];\n\t\t\tif (Cnt[j][msk] % 2 == 1)\n\t\t\t\trem[i] ^= msk;\n\t\t}\n\t}\n\tCnt[i][rem[i]] ++;\n}\n\nint Step[1 << 16], Q[1 << 16];\n\nvoid Work()\n{\n\tscanf(\"%d\", &N);\n\tmemset(Node, -1, sizeof(Node));\n\tnE = 0;\n\tfor (int i = 1; i < N; i ++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tInsertEdge(a, b, c);\n\t\tInsertEdge(b, a, c);\n\t}\n\tDFS(0, -1);\n\t\n\tCnt[0][0] = 0;\n\tint m = 0;\n\tfor (int msk = 0; msk < 16; msk ++)\n\t\tif (Cnt[0][msk] % 2 == 1)\n\t\t\tm |= (1 << msk);\n\n\tmemset(Step, -1, sizeof(Step));\n\tStep[m] = 0;\n\tint Tail = 0;\n\tQ[Tail ++] = m;\n\tfor (int h = 0; h < Tail; h ++)\n\t{\n\t\tint msk = Q[h];\n\t\tfor (int i = 1; i < 16; i ++)\n\t\t\tfor (int j = i + 1; j < 16; j ++)\n\t\t\t\tif ((msk & (1 << i)) && (msk & (1 << j)))\n\t\t\t\t{\n\t\t\t\t\tint nmsk = msk ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\t\tif (msk & (1 << (i ^ j)))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Step[nmsk] == -1 || Step[nmsk] > Step[msk] + 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStep[nmsk] = Step[msk] + 2;\n\t\t\t\t\t\t\tQ[Tail ++] = nmsk;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Step[nmsk] == -1 || Step[nmsk] > Step[msk] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStep[nmsk] = Step[msk] + 1;\n\t\t\t\t\t\t\tQ[Tail ++] = nmsk;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\tint Ans = 0;\n\tfor (int msk = 1; msk < 16; msk ++)\n\t\tAns += Cnt[0][msk] / 2;\n\tAns += Step[0];\n\tprintf(\"%d\\n\", Ans);\n}\n\nint main()\n{\n\tWork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nnamespace Fread {\n\tconst int MAXN=1<<20;\n\tchar buf[MAXN],*S,*T;\n\tinline char getchar() {\n\t\tif (S==T) {\n\t\t\tT=(S=buf)+fread(buf,1,MAXN,stdin);\n\t\t\tif (S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n}\ninline int read() {\n\tint x(0),neg(1);\n\tchar ch=getchar();\n\twhile(!isdigit(ch)) {\n\t\tif (ch=='-') neg=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) {\n\t\tx=(x<<1)+(x<<3)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn x*neg;\n}\n#ifdef ONLINE_JUDGE\n\t#define getchar Fread::getchar\n#endif\n#define pb push_back\n#define mp make_pair\nconst int MAXN=1e5;\nint n;\nint val[MAXN+5];\nint num[25];\nint dp[1<<20],xr[1<<20];\nsigned main() {\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor (int i=1;i<n;++i) {\n\t\tint u(read()),v(read()),w(read());\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tsort(val+1,val+n+1);\n\tint pos=1,ans=0,cnt=0;\n\twhile(pos<=n) {\n\t\tif (val[pos]==val[pos+1]) {\n\t\t\tans+=1;\n\t\t\tpos+=2;\n\t\t}\n\t\telse {\n\t\t\tnum[++cnt]=val[pos];\n\t\t\t++pos;\n\t\t}\n\t}\n\tint S=0;\n\tfor (int i=1;i<=cnt;++i) {\n\t\tS |= (1<<num[i]);\n\t} \n\tfor (int i=1;i<(1<<15);++i) dp[i]=dp[i>>1]+(i&1);\n\tfor (int i=1;i<(1<<15);++i) --dp[i];\n\tfor (int i=1;i<=(1<<15);++i) {\n\t\tfor (int j=1;j<=15;++j) {\n\t\t\tif (i&(1<<(j-1))) {\n\t\t\t\txr[i]^=j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<(1<<15);++i) {\n\t\tif (xr[i]) continue;\n\t\tfor (int j=i&(i-1);j;j=(j-1)&i) {\n\t\t\tif (!xr[j]) {\n\t\t\t\tdp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t}\n\t\t}\n\t}\n    printf(\"%lld\\n\",ans+dp[S]-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint a[N],c[N];\nint n,m,v[20];\nint f[N],ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z; a[y]^=z;\n\t}\n\tfor (int i=0;i<n;i++)\n\t\tc[a[i]]++;\n\tfor (int i=1;i<16;i++)\n\t{\n\t\tans+=c[i]/2;\n\t\tif (c[i]&1) v[m++]=i;\n\t}\n\tf[0]=0;\n\tfor (int i=1;i<1<<m;i++)\n\t{\n\t\tint k=0,x=0;\n\t\tfor (int j=0;j<m;j++)\n\t\t\tif ((i>>j)&1)\n\t\t\t{\n\t\t\t\tx^=v[j];\n\t\t\t\tk++;\n\t\t\t}\n\t\tf[i]=(x?100:k-1);\n\t\tfor (int p=i-(i&(-i)),j=p;;j=(j-1)&p)\n\t\t{\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t\tif (!j) break; \n\t\t}\n\t}\n\tprintf(\"%d\",ans+f[(1<<m)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 1e5 + 10, M = 16, INF = 1e7;\nVI e[N], c[N];\nint dp[N][M];\n\nvoid dfs(int now, int past, int x){\n    REP(j,M) dp[now][j] = INF;\n    dp[now][0] = 0;\n    REP(i,e[now].size()){\n        int next = e[now][i];\n        if (next == past) continue;\n        dfs(next, now, c[now][i]);\n\n        VI tmp(M, INF);\n        REP(j,M) REP(k,M){\n            tmp[j ^ k] = min(tmp[j ^ k], dp[now][j] + dp[next][k] + (j != k));\n        }\n        REP(j,M) dp[now][j] = tmp[j];\n    }\n\n    // cout << \"now \" << now << endl;\n    // cout << \"merged\" << endl;\n    // REP(j,M) cout << dp[now][j] << \" \";\n    // cout << endl;\n\n    if (x != 0){\n        VI tmp(M, INF);\n        REP(j,M){\n            tmp[j ^ x] = min(tmp[j ^ x], dp[now][j] + (j != x));\n            tmp[j] = min(tmp[j], dp[now][j] + (j != x));\n        }\n        REP(j,M) dp[now][j] = tmp[j];\n    }\n\n    // cout << now << \" \" << x << endl;\n    // REP(i,M) cout << dp[now][i] << \" \";\n    // cout << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    REP(i,n-1){\n        int u, v, a;\n        scanf(\"%d %d %d\", &u, &v, &a);\n        e[u].push_back(v);\n        c[u].push_back(a);\n        e[v].push_back(u);\n        c[v].push_back(a);\n    }\n\n    dfs(0, -1, 0);\n\n    // REP(i,n){\n    //     REP(j,M) cout << dp[i][j] << \" \";\n    //     cout << endl;\n    // }\n\n    cout << dp[0][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[s[i]]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint c[101000],ok[10000000];\nint h[101000],nxt[201000],K=0,to[201000],cost[201000];int cnt[16],ans=0;\nvoid ins(int u,int v,int c){nxt[++K]=h[u];h[u]=K;to[K]=v;cost[K]=c;}\nvoid dfs(int x,int f,int val)\n{\n\tint k=0;\n\tfor(int i=h[x];i;i=nxt[i])\n\t{\n\t\tif(to[i]==f)continue;\n\t\tk^=cost[i];dfs(to[i],x,cost[i]);\n\t}\n\tif(x)cnt[val^k]++;\n}\nint a[18],tot=0,dp[1<<15];\nint DP(int S)\n{\n\t\n\tif(dp[S]!=-1)return dp[S];dp[S]=2000000000;\n\tfor(int i=0;i<15;i++)\n\tfor(int j=i+1;j<15;j++)\n\t{\n\t\tif(((S>>i)&1)&&((S>>j)&1))\n\t\t{\n\t\t\tint k=(i+1)^(j+1);\n\t\t\tdp[S]=min(dp[S],DP(S^(1<<(k-1))^(1<<j)^(1<<i))+1+(((S>>(k-1))&1)?1:0));\n\t\t}\n\t}\n\tfor(int i=0;i<15;i++)\n\t\tif((S>>i)&1)\n\t\t\tdp[S]=min(dp[S],DP(S^(1<<i))+1);\n\treturn dp[S];\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){int x,y,c;scanf(\"%d%d%d\",&x,&y,&c);ins(x,y,c);ins(y,x,c);}\n\tdfs(0,-1,0);\n\tint S=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)S|=1<<(i-1);\n\t}\n\tmemset(dp,-1,sizeof(dp));dp[0]=0;\n\tprintf(\"%d\",DP(S)+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxn=100005;\nint n,x[maxn],a[16],dp[1<<16],s,mask[1<<16];\nvector<int> v;\nvector<pii> G[maxn];\nvoid dfs(int u,int fa) {\n    for (int i=0;i<(int)G[u].size();++i) {\n        int v=G[u][i].first,w=G[u][i].second;\n        if (v==fa)\n            continue;\n        x[v]=w^x[u];\n        dfs(v,u);\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=0;i<n-1;++i) {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        x[u]^=w;\n        x[v]^=w;\n        G[u].push_back(pii(v,w));\n        G[v].push_back(pii(u,w));\n    }\n    //dfs(0,-1);\n    for (int i=0;i<n;++i)\n        ++a[x[i]];\n    int res=n-a[0];\n    for (int i=1;i<16;++i) {\n        if (a[i]%2==1)\n            v.push_back(i);\n        res-=a[i]/2;\n    }\n    if (!v.size())\n        return 0*printf(\"%d\\n\",res);\n    s=1<<v.size();\n    for (int i=0;i<s;++i)\n        for (int j=0;j<(int)v.size();++j)\n            if (i&(1<<j))\n                mask[i]^=v[j];\n    for (int i=0;i<s;++i)\n        for (int j=0;j<(int)v.size();++j)\n            if (i&(1<<j))\n                dp[i]=max(dp[i],dp[i^(1<<j)]+(mask[i]==0));\n    printf(\"%d\\n\",res-dp[s-1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F(i, s, t) for (int i = (s), _ = (t); i <= _; i ++)\nint rd() {\n\tint x = 0; char c;\n\tdo { c = getchar(); } while (!isdigit(c));\n\tdo { x = x*10+c-'0', c = getchar(); } while (isdigit(c));\n\treturn x;\n}\nconst int N = 100005;\nint n;\nstruct Edge {\n\tint v, a, nx;\n}mp[N << 1];\nint tot, hd[N];\nint a[N], cnt;\nvoid Dp(int x, int par) {\n\tfor (int k = hd[x]; k; k = mp[k].nx) {\n\t\tint v = mp[k].v;\n\t\tif (v != par) {\n\t\t\ta[x] ^= mp[k].a;\n\t\t\ta[v] ^= mp[k].a;\n\t\t\tDp(v, x);\n\t\t}\n\t}\n}\nint main() {\n\tn = rd();\n\tF(i, 1, n-1) {\n\t\tint x = rd(), y = rd(), a = rd();\n\t\tx ++, y ++;\n\t\tmp[++ tot] = (Edge){y, a, hd[x]}, hd[x] = tot;\n\t\tmp[++ tot] = (Edge){x, a, hd[y]}, hd[y] = tot;\n\t}\n\tDp(1, 0);\n\tF(i, 1, n) cnt += (a[i] > 0);\n\tcout << (cnt + 1 >> 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt[20],ok[1<<17],dp[1<<17],val[N];\ntypedef pair<int,int> pii;\nvector<pii> e[N];\nvoid dfs(int x,int fa){\n\tfor (auto i:e[x]){\n\t\tint v=i.first;\n\t\tif (v==fa) continue;\n\t\tval[v]=i.second;\n\t\tval[x]^=val[v];\n\t\tdfs(v,x);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v,l;\n\t\tscanf(\"%d%d%d\",&u,&v,&l);u++;v++;\n\t\te[u].push_back(pii(v,l));\n\t\te[v].push_back(pii(u,l));\n\t}\n\tdfs(1,0);\n\tfor (int i=2;i<=n;i++) cnt[val[i]]++;\n\tint ans=0;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,cnt[i]%=2;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i];\n\tcnt[0]=0;\n\tint U=1<<16;\n\tfor (int i=0;i<U;i++){\n\t\tint s=0;\n\t\tfor (int j=0;j<16;j++)\n\t\tif (i>>j&1) s^=j;\n\t\tif (!s) ok[i]=1;\n\t}\n\tfor (int i=0;i<U;i++)\n\tfor (int j=i;j;j=(j-1)&i){\n\t\tif (ok[j]) dp[i]=max(dp[i],dp[i^j]+1);\n\t\tdp[i]=max(dp[i],dp[i^j]);\n\t}\n\tint tmp=0;\n\tfor (int i=0;i<16;i++) tmp^=cnt[i]<<i;\n\tprintf(\"%d\\n\",ans-dp[tmp]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10;  \n\nint n, ans, state, tot; \nint val[maxn], cnt[20], f[maxm], s[maxn], sum[maxm]; \n// sumè¡¨ç¤ºæ¯ä¸ªéåçå¼æå¼\nint main() {\n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z; \n\t\tscanf(\"%d%d%d\", &x, &y, &z); \n\t\tx++, y++; \n\t\tval[x] ^= z, val[y] ^= z; \n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[val[i]]++; \n\tans = n; ans -= cnt[0]; \n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans -= cnt[i] / 2 ; \n\t\tstate += (cnt[i] & 1) * (1 << i); \n\t}\n\ttot = 1 << 15; \n\tfor (int i = 0; i < tot; ++i) {\n\t\tint tmp = 0; \t\n\t\tfor (int j = 1; j <= 15; ++j) {\n\t\t\tif ((i >> j) & 1) tmp ^= j; \n\t\t}\n\t\tsum[i] = tmp; \n\t}\n\tfor (int i = 1; i < tot; ++i) {\n\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\tif (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1); \n\t\t}\n\t}\n\tans -= f[state]; \n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[s[i]]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int) x.size()\n\nconst int N = 1e5;\nint n;\nvector <pair <int, int>> G[N + 7];\n\nint xorDrzewa[N + 7];\nint war[N + 7];\n\nvoid dfs0(int v, int p) {\n  war[v] = xorDrzewa[v];\n  \n  for (auto u : G[v]) {\n    if (u.first != p) {\n      xorDrzewa[u.first] = u.second;\n      war[v] ^= u.second;\n      dfs0(u.first, v);\n    }\n  }\n}\n\nint ile[16];\nbool pusty[(1 << 15)];\nint dp[(1 << 15)];\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n;\n  for (int i = 1; i < n; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    G[a + 1].push_back({b + 1, c});\n    G[b + 1].push_back({a + 1, c});\n  } \n    \n  dfs0(1, 0);\n  for (int i = 1; i <= n; ++i) ile[war[i]]++;\n  \n  int kraw = 0;\n  ile[0] = 0;\n  \n  for (int i = 1; i < 16; ++i) {\n    kraw += ile[i] / 2;\n    ile[i] %= 2;\n  }\n  \n  vector <int> roz;\n  for (int i = 1; i < 16; ++i) if (ile[i]) roz.push_back(i);\n  \n  int m = SZ(roz);\n  for (int x = 0; x < (1 << m); ++x) {\n    int xr = 0;\n    for (int i = 0; i < m; ++i) {\n      if (x & (1 << i)) xr ^= roz[i]; \n    }\n    if (xr == 0) pusty[x] = 1;\n  } \n  \n  for (int x = 1; x < (1 << m); ++x) {\n    int res = -1e9;\n    if (pusty[x]) res = 1;\n    \n    int y = (x - 1) & x;\n    while (y > 0) {\n      res = max(res, dp[y] + dp[x ^ y]);\n      y = (y - 1) & x;\n    } \n    \n    dp[x] = res;\n  }\n  \n  /*\n  for (int x = 1; x < (1 << m); ++x) {\n    for (int i = 0; i < m; ++i) if (x & (1 << i)) cout << roz[i] << ' ';\n    cout << \"- \";\n    cout << pusty[x] << endl;\n  }*/\n  \n  kraw += m - dp[(1 << m) - 1];\n  cout << kraw << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,x,y,z,ans,f[1<<15],a[100100],c[20];\nvector<int>o;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tscanf(\"%d\", &n);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z,a[y]^=z;\n\t}\n\tfor(int i=0;i<n;++i)++c[a[i]];\n\tfor(int i=1;i<=15;++i){\n\t\tans+=c[i]>>1;\n\t\tif(c[i]&1)o.push_back(i);\n\t}\n\tf[0]=0;\n\tfor(int i=1;i<(1<<o.size());++i){\n\t\tint x=0,k=0,j=0;\n\t\tfor(;j<o.size();++j)\n\t\t\tif(i&(1<<j))x^=o[j],++k;\n\t\tf[i]=x? 19260817:k-1;\n\t\tfor(j=i-(i&-i);j;j=(i-(i&-i))&(j-1))\n\t\t\tf[i]=min(f[i],f[j]+f[j^i]);\n\t}\n\tprintf(\"%d\\n\",f[(1<<o.size())-1]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n#define bit(a , b) (((a)>>(b))&1)\n\nconst int maxn = 1e5 + 20;\nconst int maxm = 16;\n\nint t[maxn] , a[maxm] , dp[1 << maxm];\n\nint And[1 << maxm];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b , c;\n\t\tcin >> a >> b >> c;\n\n\t\tt[a] ^= c;\n\t\tt[b] ^= c;\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[t[i]]++;\n\n\tint res = a[0] , mask = 0;\n\tfor(int i = 1; i < maxm; i++)\n\t{\n\t\tres += a[i] / 2;\n\t\ta[i] %= 2;\n\n\t\tmask += (1 << i) * a[i];\n\t}\n\n\tfor(int i = 0; i < maxm; i++)\n\t\tAnd[1 << i] = i;\n\n\tfor(int mask = 1; mask < (1 << maxm); mask++)\n\t{\n\t\tint lb = (mask&(-mask));\n\n\t\tif(lb == mask)\n\t\t\tcontinue;\n\n\t\tAnd[mask] = And[mask ^ lb] ^ And[lb];\n\t}\n\n\tfor(int mask = 1; mask < (1 << maxm); mask++)\n\t{\n\t\tif(And[mask] != 0)\n\t\t\tcontinue;\n\n\t\tdp[mask] = 1;\n\t\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask)\n\t\t\tif(submask != mask && And[submask] == 0)\n\t\t\t\tdp[mask] = max(dp[mask] , dp[submask] + dp[submask ^ mask] + 1);\n\t}\n\n\tcout << n - res - dp[mask] << endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint A[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tA[a] ^= c;\n\t\tA[b] ^= c;\n\t}\n\trep(i, 0, N) cnt[A[i]]++;\n\n\tint ans = 0, remain = 0;\n\trep(i, 1, 16) {\n\t\tans += cnt[i] / 2;\n\t\tremain += cnt[i] % 2;\n\t}\n\tans += max(remain - 1, 0);\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*input\n\n*/\n#include <iostream>\n#include <fstream>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n#include <ctime>\n#include <algorithm>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define endl '\\n'\n#define mp make_pair\n#define pb push_back\n#define MOD 1000000007ULL\n#define MOD2 1000000009ULL\n#define INF 1000000000ULL\n#define F first\n#define S second\n#define eps 1e-9\n#define PI 3.14159265358979\n#define gcd __gcd\n#define sd(x) scanf(\"%d\", &(x))\n#define slld(x) scanf(\"%lld\", &(x))\n#define ss(x) scanf(\"%s\", x)\n#define sc(x) scanf(\" %c\", &x)\n#define pd(x) printf(\"%d\\n\", (x))\n#define plld(x) printf(\"%lld\\n\", (x));\n#define gc getchar\n\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<int, int> vii;\ntypedef vector<ll, ll> vll;\n\nvoid scanint(int &x)\n{\n    register int c = gc();\n    bool flag = false;\n    x = 0;\n    for(;((c<48 && c!=45) || c>57);c = gc());\n    if(c==45)\n    {\n\t\tflag = true;\n\t\tc = gc();\n    }\n    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n    if(flag)\n    \tx = x - (x<<1);\n    return;\n}\n\nvoid scanll(ll &x)\n{\n\tregister long long c;\n\tbool flag = false;\n\tx = 0;\n\tfor(;((c<48 && c!=45) || c>57);c = gc());\n\tif(c==45)\n\t{\n\t\tflag = true;\n\t\tc = gc();\n\t}\n\tfor(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n\tif(flag)\n    \tx = x - (x<<1);\n\treturn;\n}\n\nconst int N = 100005;\nconst int M = 16;\nvector<pii> v[N];\nbool visited[N];\nint cnt[M];\nint dp[1<<M];\nint val[1<<M];\nint arr[M], sz_arr;\n\nvoid dfs(int u)\n{\n\tvisited[u] = true;\n\tpii pt;\n\tint d = 0;\n\tfor(int i = 0; i<v[u].size(); i++)\n\t{\n\t\tpt = v[u][i];\n\t\td = d^pt.S;\n\t\tif(!visited[pt.F])\n\t\t\tdfs(pt.F);\n\t}\n\tcnt[d]++;\n\treturn;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t// clock_t clk;\n\t// clk = clock();\n\t// freopen(\"in.in\", \"r\", stdin);\n\t// freopen(\"out.out\", \"w\", stdout);\n\t\n\tint n, a, b, w;\n\tcin >> n;\n\tfor(int i = 1; i<n; i++)\n\t{\n\t\tcin >> a >> b >> w;\n\t\ta++;\n\t\tb++;\n\t\tv[a].pb(mp(b, w));\n\t\tv[b].pb(mp(a, w));\n\t}\n\tdfs(1);\n\tint ans = 0;\n\tsz_arr = 0;\n\tfor(int i = 1; i<M; i++)\n\t{\n\t\tans += cnt[i]/2;\n\t\tcnt[i] = cnt[i]%2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tarr[sz_arr] = i;\n\t\t\tsz_arr++;\n\t\t}\n\t}\n\tint up = (1<<sz_arr), temp;\n\tfor(int i = 0; i<up; i++)\n\t{\n\t\tval[i] = 0;\n\t\tfor(int j = 0; j<sz_arr; j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tval[i] = val[i]^arr[j];\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1; i<up; i++)\n\t{\n\t\tif(val[i] != 0)\n\t\t\tcontinue;\n\n\t\tdp[i] = __builtin_popcount(i) - 1;\n\t\tfor(int j = i; j>0; j = i&(j-1))\n\t\t\tif(val[j] == 0 && val[i^j] == 0)\n\t\t\t\tdp[i] = min(dp[i], dp[j]+dp[i^j]);\n\t}\n\tcout << dp[up-1] + ans << \"\\n\";\n\n\t// clk = clock() - clk;\n\t// cout << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\t// printf(\"Time: %lf\", ((double)clk)/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n\tint to;\n\tint cost;\n\tedge(int t, int c) : to(t), cost(c) {}\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tgraph G(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tG[x].emplace_back(y, a);\n\t\tG[y].emplace_back(x, a);\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tbool flag = false;\n\t\tvector<int> used(G[i].size());\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tbool ok = false;\n\t\t\tbool kaburi = false;\n\t\t\tfor (int k = 0; k < (int)G[i].size(); k++) {\n\t\t\t\tok ^= (G[i][k].cost >> j) & 1;\n\t\t\t\tif (G[i][k].cost & (1 << j)) {\n\t\t\t\t\tkaburi |= used[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok && !kaburi) {\n\t\t\t\tcnt++;\n\t\t\t\tfor (int k = 0; k < (int)G[i].size(); k++) {\n\t\t\t\t\tif (G[i][k].cost & (1 << j)) {\n\t\t\t\t\t\tused[k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (cnt + 1) / 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,ans;\nint val[100005];\nint S;\nint A[100005],siz[100005],F[100005];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<N;i++){\n\t\tint u,v,c;scanf(\"%d%d%d\",&u,&v,&c);\n\t\tval[u]^=c;val[v]^=c;\n\t}\n\tfor(int i=0;i<N;i++)if(val[i]){S^=(1<<val[i]);if(!((S>>val[i])&1)) ans++;}\n\tfor(int i=1;i<(1<<16);i++){\n\t\tint j=0;\n\t\tfor(;;j++) if((i>>j)&1) break;\n\t\tA[i]=A[i^(1<<j)]^j; \n\t\tsiz[i]=siz[i>>1]+(i&1);\n\t}\n\tfor(int i=1;i<(1<<16);i++)if(A[i]==0){\n\t\tF[i]=siz[i]-1;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i) if(A[j]==0)\n\t\t\tF[i]=min(F[i],F[j]+F[i^j]);\n\t}\n\tprintf(\"%d\\n\",ans+F[S]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e9\n\nusing namespace std;\n\nstruct edge{\n\tint u, v;\n\tint cost;\n\tedge(){}\n\tedge(int a, int b, int c){\n\t\tu = a, v = b, cost = c;\n\t}\n\tint get(int a)\n\t{\n\t\tif(u == a) return v;\n\t\telse return u;\n\t}\n};\n\nint N;\nvector<int> G[100005];\nedge E[100005];\nint cnt[16];\n\nint V = 1 << 16, S;\nint dist[1<<16];\n\nvoid bfs(){\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(S);\n\tint v, nv;\n\twhile(Q.size()){\n\t\tv = Q.front();\n\t\tQ.pop();\n\t\tif(v == 0) break;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif(v & (1<<i)){\n\t\t\t\tnv = v & ~(1<<i);\n\t\t\t\tif(dist[nv] < inf) continue;\n\t\t\t\tQ.push(nv);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif((v & (1<<i)) == 0) continue;\n\t\t\tfor(int j = 1; j < 16; j++){\n\t\t\t\tif((v & (1<<j)) == 0) continue;\n\t\t\t\tif(i == j) continue;\n\t\t\t\tnv = v;\n\t\t\t\tnv &= ~(1<<i);\n\t\t\t\tnv ^= 1<<(i^j);\n\t\t\t\tif(dist[nv] < inf) continue;\n\t\t\t\tQ.push(nv);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int prev, int val)\n{\n\tint ret = val;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(E[G[v][i]].get(v) == prev) continue;\n\t\tret ^= dfs(E[G[v][i]].get(v), v, E[G[v][i]].cost);\n\t}\n\tcnt[ret]++;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint x, y, a;\n\tfor(int i = 0; i < N-1; i++){\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(i);\n\t\tG[y].push_back(i);\n\t\tE[i] = edge(x, y, a);\n\t}\n\t\n\tdfs(0, -1, 0);\n\t\n\tint ans = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t}\n\tcnt[0] = 0;\n\tfor(int i = 0; i < 16; i++) if(cnt[i]) S += (1<<i);\n\t\n\tbfs();\n\tans += dist[0];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+100;\nint cnt[N],v[N],dp[N];\nint dfs(int s)\n{\n\tif(s==0) return 0;\n\tif(dp[s]!=-1) return dp[s];\n\tdp[s]=0x3f3f3f3f;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tif(s>>i&1)\n\t\t{\n\t\t\tfor(int j=0;j<16;j++)\n\t\t\t{\n\t\t\t\tif(s>>j&1)\n\t\t\t\t{\n\t\t\t\t\tint x=i^j;int ns=s^(1<<i)^(1<<j)^(1<<x);\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t dp[s]=min(dp[s],dfs(ns)+1+((s&(1<<x))==(1<<x)));\n\t\t\t\t}\n\t\t\t} \n\t    }\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;\n\t\tv[y]^=z;\n\t}\n\tmemset(dp,-1,sizeof dp);\n\tfor(int i=0;i<n;i++)\n\t if(v[i]) cnt[v[i]]++;\n\tint st=0,ans=0;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst|=(cnt[i]&1)*(1<<i);\n\t} \n\tans+=dfs(st);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\n\nvector<pair<int, int>> E[MAX];\n\nint a[MAX];\nint sa[MAX];\n\nvoid Dfs(int x, int prev, int dad) {\n  for (auto& p: E[x]) {\n    int y = p.first;\n    int w = p.second;\n    if (y != dad) {\n      Dfs(y, w, x);\n      sa[x] ^= sa[y];\n    }\n  }\n\n  a[x] = sa[x] ^ prev;\n  sa[x] = sa[x] ^ a[x];\n\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N-1) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    E[a].push_back({b, c});\n    E[b].push_back({a, c});\n  }\n\n  Dfs(0, 0, -1);\n\n  int mask = 0;\n  int ret = 0;\n  FOR(i, 1, N) {\n    if (a[i] == 0) continue;\n    if (mask & (1<<a[i])) {\n      ret++;\n    }\n    mask ^= 1 << a[i];\n  }\n\n  queue<int> Q[16];\n  vector<int> dist(1<<16, 1000000000);\n\n  dist[mask] = 0;\n  Q[0].push(mask);\n\n  REP(i, 16) {\n    while (!Q[i].empty()) {\n      int mask = Q[i].front();\n      Q[i].pop();\n      if (i != dist[mask]) continue;\n\n      REP(x, 16) {\n        if (mask & (1<<x)) {\n          if (i + 1 < 16) {\n            int nmask = mask ^ (1 << x);\n            if (i + 1 < dist[nmask]) {\n              dist[nmask] = i + 1;\n              Q[i + 1].push(nmask);\n            }\n          }\n\n\n          REP(y, x) {\n            if ((mask & (1<<y))) {\n              REP(z, 16) {\n                int nmask = mask, cost = i;\n\n                nmask ^= 1 << x;\n                nmask ^= 1 << y;\n                cost++;\n\n                if (x != z) {\n                  if (nmask & (1 << (x^z))) cost++;\n                  nmask ^= 1 << (x^z);\n                }\n\n                if (y != z) {\n                  if (nmask & (1 << (y^z))) cost++;\n                  nmask ^= 1 << (y^z);\n                }\n                if (cost < 16 && cost < dist[nmask]) {\n                  dist[nmask] = cost;\n                  Q[cost].push(nmask);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  ret += dist[0];\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    mat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        dp = mat(N, vec(4, INF));\n    }\n\n    void add_edge(int from, int to, int cost = 0){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost = 0){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int p = -1){\n        dp[v] = vec(4, 0);\n        int wp;\n        int tmp = 0;\n        int cnt[4] = {};\n        for(auto e: G[v]){\n            if(e.to == p) wp = e.cost;\n            else{\n                dfs(e.to, v);\n                REP(k, 4){\n                    if((e.to >> k) & 1) cnt[k]++;\n                    dp[v][k] += dp[e.to][k];\n                }\n            }\n        }\n        REP(k, 4){\n            dp[v][k] -= cnt[k] / 2;\n            if(p != -1){\n                if(((wp >> k) & 1) && !(cnt[k] % 2)) dp[v][k]++;\n            }\n        }\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    int x, y, a;\n    REP(i, N - 1){\n        cin >> x >> y >> a;\n        G.add_edge2(x, y, a);\n    }\n    G.dfs(0);\n    int ans = 0;\n    REP(k, 4) ans += G.dp[0][k];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst long long mod = 1000000007;\nconst int maxn = 100100;\nint deg[maxn], cnt[16];\nint dp[1<<16], xo[1<<16];\nint main(){\n    int n;\n    cin >> n;\n    for(int e = 0; e < n - 1; e++){\n        int u, v, w;\n        cin >> u >> v >> w;\n        deg[u] ^= w;\n        deg[v] ^= w;\n    }\n    for(int e = 0; e < n; e++){\n        cnt[deg[e]]++;\n    }\n    int ans = cnt[0];\n    for(int e = 1; e < 16; e++){\n        ans += cnt[e] / 2;\n        cnt[e] %= 2;\n    }\n    for(int e = 1; e < 1<<16; e++){\n        xo[e] = 0;\n        for(int f = 0; f < 16; f++)\n            if(e & (1<<f)) xo[e] ^= f;\n    }\n    dp[0] = 0;\n    for(int e = 1; e < 1<<16; e++){\n        for(int f = e; f > 0; f = (f - 1) & e){\n            if(xo[f] == 0) dp[e] = max(dp[e], dp[f ^ e] + 1);\n        }\n    }\n    int msk = 0;\n    for(int e = 1; e < 16; e++)\n        if(cnt[e]) msk |= (1<<e);\n    ans += dp[msk];\n    cout << n - ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 10000000;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 1<<16;\n\nvector<pii> T[MX];\nint state[MX], val[MX];\nint N, ans = 0;\n\nvoid dfs(int x, int p = -1){\n\tfor(pii e : T[x]){\n\t\tint c = e.second, d = e.first;\n\t\tif( c == p ) continue;\n\t\tdfs(c, x);\n\t\tif( d && state[c]&1<<d ) ans++;\n\t\tstate[c] ^= 1<<d;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif( state[c]&1<<i && state[x]&1<<i ){\n\t\t\t\tstate[i] ^= 1<<i;\n\t\t\t\tstate[c] ^= 1<<i;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tstate[x] |= state[c];\n\t}\n}\n\nint chk(int x){\n\tint c = 0, v = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tif( x&1<<i-1 ) v ^= i, c++;\n\t}\n\tif( c == 1 ) return 1;\n\tif( v ) return -1;\n\treturn c-1;\n}\n\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tT[a].emplace_back(c, b);\n\t\tT[b].emplace_back(c, a);\n\t}\n\tdfs(0);\n\tfor(int i = 1; i < 1<<15; i++){\n\t\tval[i] = 1e9;\n\t\tfor(int j = i; j; j = (j-1)&i){\n\t\t\tint v = chk(j);\n\t\t\tif( v != -1 ) val[i] = min(val[i], val[i^j] + v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", val[state[0]/2] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdint>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nqueue<int> Q;\nvector<int> a[200001];\nvector<int> b[200001];\nint sum[100001],deg[100001];\nint fax[100001];\nint fa[100001];\nbool v[100001];\nint ans;\ninline void dfs1(int d)\n{\n\tv[d]=true;\n\tint i;\n\tfor(i=0;i<a[d].size();i++)\n\t{\n\t\tint t=a[d][i];\n\t\tif(!v[t])\n\t\t{\n\t\t\tfa[t]=d;\n\t\t\tfax[t]=b[d][i];\n\t\t\tdfs1(t);\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s,t,x;\n\tint i;\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&s,&t,&x);\n\t\ts++;\n\t\tt++;\n\t\ta[s].push_back(t);\n\t\ta[t].push_back(s);\n\t\tb[t].push_back(x);\n\t\tb[s].push_back(x);\n\t}\n\tdfs1(1);\n\tfor(i=1;i<=n;i++)\n\t\tdeg[fa[i]]++;\n\tfor(i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint d=Q.front();\n\t\tQ.pop();\n\t\tdeg[fa[d]]--;\n\t\tif(fa[d]!=0&&deg[fa[d]]==0)\n\t\t\tQ.push(fa[d]);\n\t\tsum[fax[d]]++;\n\t\tfax[fa[d]]^=fax[d];\n\t\tfax[d]=0;\n\t}\n//\tfor(i=1;i<=15;i++)\n//\t\tans+=(sum[i]+1)/2;\n\tfor(i=1;i<=15;i++)\n\t\tans+=sum[i];\n\tprintf(\"%d\\n\",ans/3*2+ans%3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*     !ya khoda!     */\n#include <bits/stdc++.h>\n\n#define ll long long\n#define ld long double\n\n#define pp push\n#define po pop()\n#define pb push_back\n#define pf push_front\n#define pob pop_back()\n#define pof pop_front()\n#define I insert\n#define E erase\n\n#define F first\n#define S second\n\n#define mkp make_pair\n#define pll pair<ll,ll>\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define all(a) a.begin(),a.end()\n\n#define coutghat(x)      cout<<tolower(x);\n#define coutashar(x,d)   cout<<fixed<<setprecision(x)<<(ld)d\n#define IOS ios_base::sync_with_stdio(false) , cin.tie(0);\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n//#define poow(a,b,M)   b?(poow((a*a)%M,b/2)%M * (b&1?a))%M:1 ;\n/*==========================================================================*/\nusing namespace std;\nll poow(ll x,ll n,ll Mod=1e9+7) { return (n==0?1:poow(x*x%Mod,n/2)*(n&1?x:1)%Mod); }\n//#pragma optimize O3\n// 107,109, 211,223, 307, 401,409, 503,509, 601,607, 701,709, 809, 907, 1009\n/*==========================================================================*/\nconst int N=2e5+10  , M=1e4+10  , SQ=320 , LG=23 , base=2;\nconst int mod=1e9+7 , MOD=1e9+9;\nconst ll  INF=1e9   , inf=1e18 , super_inf=~0ull/4;\nll n,m,a[N]  ,  cnt[16]  ,  dp[1<<16],val[1<<16]  ,  x,k;\nvector<ll>vec;\n/*==========================================================================*/\nint main()\n{\n    IOS;\n    cin>>n;\n\tfor(int i=1;i<n;i++)\n\t{   ll v,u,w;\n        cin>>v>>u>>w;\n\t\ta[v]^=w  ,  a[u]^=w;\n\t}\n\tfor(int i=0;i<n;i++)   cnt[a[i]]++;\n\n\n\tx=cnt[0]  ,  cnt[0]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cnt[a[i]]%2)    vec.pb(a[i]);\n\t\tx+=cnt[a[i]]/2  ,  cnt[a[i]]=0;\n\t}\n\n\tm=vec.size() , k=(1<<m);\n\tfor(int i=0;i<k;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(i>>j&1)\n\t\t\t\tval[i]^=vec[j];\n\n\tfor(int i=1;i<k;i++)\n\t{   dp[i]=1;\n\t\tif(val[i]!=0)   continue;\n\t\tfor(int j=i;j>0;j=(j-1)&i)\n\t\t\tif(!val[j])\n\t\t\t\tdp[i]=max(dp[i],dp[j]+dp[i^j]);\n\t}\n\n\tcout<<n-(dp[k-1]+x);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=1e5+5;\nint a[N],f[N],sz[N],xr[N],Log[N],st[25],cnt[25],top,n,res,lim;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(R int i=1,u,v,w;i<n;++i)scanf(\"%d%d%d\",&u,&v,&w),a[u+1]^=w,a[v+1]^=w;\n\tfp(i,1,n)++cnt[a[i]];\n\tfp(i,1,15){\n\t\tres+=cnt[i]>>1;\n\t\tif(cnt[i]&1)st[top++]=i;\n\t}\n\tlim=(1<<top);\n\tfp(i,0,15)Log[1<<i]=i;\n\tfp(i,1,lim-1)sz[i]=sz[i>>1]+(i&1),xr[i]=xr[i-(i&-i)]^st[Log[i&-i]];\n\tf[0]=0;\n\tfp(i,1,lim-1){\n\t\tif(!xr[i])f[i]=sz[i]-1;\n\t\t\telse f[i]=top;\n//\t\tprintf(\"%d %d\\n\",i,xr[i]);\n\t\tfor(R int s=i;s;s=(s-1)&i)cmin(f[i],f[s]+f[s^i]);\n\t}\n\tprintf(\"%d\\n\",res+f[lim-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n\n\nint cnt = 0;\nvector< vector<int> > hoges;\nvoid dfs(vector<int> items){\n\t\n\tint ok = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tint flg = 1;\n\t\tfor( int j : items ){\n\t\t\tif( (j & i) == i ) flg = 0;\n\t\t}\n\t\tif(flg==0) break;\n\t\tvector<int> t = items;\n\t\tt.push_back(i);\n\t\tdfs(t);\n\t\tok = 1;\n\t}\n\tif(!ok){\n\t\thoges.push_back(items);\n\t}\n}\n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a), b(b), c(c){}\n};\n\nint deg[100010];\nint f(vector<int> hoge, vector<Edge> es){\n\tint ans = 0;\n\tfor(auto h : hoge ){\n\t\tmemset(deg, 0, sizeof(deg));\t\n\t\tfor( auto &e : es ){\n\t\t\tif( (e.c & h) != h ) continue;\n\t\t\tdeg[e.a]++;\n\t\t\tdeg[e.b]++;\n\t\t\te.c -= h;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0 ; i < es.size() + 1 ; i++){\n\t\t\tif( deg[i] == 1 ) cnt++;\n\t\t}\n\t\tans += (cnt + 1) / 2;\n\t}\n\tfor( auto &e : es ){\n\t\tif( e.c != 0 ) return 1e9;\n\t}\n\treturn ans;\n}\n\nvoid solve(ll N, vector<ll> x, vector<ll> y, vector<ll> a){\n\ttime_t start = clock();\n\tdfs({});\n\tsrand(time(NULL));\n\trandom_shuffle(hoges.begin(), hoges.end());\n\n\t\n\tint ans = 1e9;\n\tvector<Edge> es;\n\tfor(int i = 0 ; i < x.size() ; i++){\n\t\tes.push_back(Edge(x[i], y[i], a[i]));\n\t}\n\tfor( auto hoge : hoges ){\n\t\ttime_t end = clock();\n\t\tif( 1.0 * (end-start) / CLOCKS_PER_SEC > 1.8 ) break;\n\t\tans = min(ans, f(hoge, es));\n\t}\n\tcout << ans << endl;\n\n}\n\nint main(){\t\n\tll N;\n\tscanf(\"%lld\",&N);\n\tvector<ll> x((N-1)-1+1);\n\tvector<ll> y((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor(int i = 0 ; i <= (N-1)-1 ; i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t\tscanf(\"%lld\",&y[i]);\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tsolve(N, x, y, a);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 100000\n#define P 15\n#define INF 1e9\n#define Gmin(x,y) (x>(y)&&(x=(y)))\nconst int maxn = 100035;\nconst int maxs = 1<<17;\n\nint n,cnt,a[maxn],f[maxs],sta,ans;\n\nclass Class_FIO\n{\n\tprivate:\n\t\t#define FS 100000\n\t\t#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)\n\t\t#define pc(c) (putchar(c))\n\t\t#define tn(x) (x<<3)+(x<<1)\n\t\t#define D isdigit(c=tc())\n\t\tint T;char c,*A,*B,FI[FS],S[FS];\n\tpublic:\n\t\tI Class_FIO() {A=B=FI;}\n\t\tTp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}\n\t\tTp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}\n\t\tTs I void read(Ty& x,Ar&... y) {read(x),read(y...);}\n}F;\nint dp(int x)\n{\n\tif (!x) return 0;\n\tif (f[x]!=-1) return f[x];\n\tint ret = 1e9;\n\tfor (int i=1; i<16; i++)\n\t\tif (x&(1<<i)) for (int j=1; j<16; j++)\n\t\t\tif ((x&(1<<j))&&i!=j)\n\t\t\t\tret = std::min(ret, dp(x^(1<<i)^(1<<j)^(1<<(i^j)))+1+((x&(1<<(i^j)))?1:0));\n\tf[x] = ret;\n\treturn ret;\n}\nint main()\n{\n\tF.read(n);\n\tmemset(f, -1, sizeof f);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint x,y,z;\n\t\tF.read(x), ++x, F.read(y), ++y, F.read(z);\n\t\ta[x] ^= z, a[y] ^= z;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tif (a[i]&&((sta>>a[i])&1)) sta ^= 1<<a[i], ++ans;\n\t\telse if (a[i]) sta ^= 1<<a[i];\n\tprintf(\"%d\\n\",ans+dp(sta));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint dp[1 << 16];\nvoid init() {\n\tfill(dp, dp + (1 << 16), mod);\n\tdp[0] = 0;\n\trep(i, (1 << 16)) {\n\t\tvector<int> r;\n\t\trep(j, 16) {\n\t\t\tif ((i&(1 << j)) == 0) {\n\t\t\t\tr.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint len = r.size();\n\t\trep1(j, (1 << len) - 1) {\n\t\t\tint s = 0; int tmp = 0;\n\t\t\tint ss = 0;\n\t\t\trep(k, len) {\n\t\t\t\tif (j&(1 << k)) {\n\t\t\t\t\ts ^= r[k]; tmp++;\n\t\t\t\t\tss += (1 << r[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == 0) {\n\t\t\t\tdp[i + ss] = min(dp[i + ss], dp[i] + tmp - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + ss] = min(dp[i + ss], dp[i] + tmp);\n\t\t\t}\n\t\t}\n\t}\n\tper(i, (1 << 16)) {\n\t\tvector<int> r;\n\t\trep(j, 16) {\n\t\t\tif ((i&(1 << j)) == 0) {\n\t\t\t\tr.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint len = r.size();\n\t\trep(j, len) {\n\t\t\tint ni = i ^ (1 << r[j]);\n\t\t\tdp[i] = min({ dp[i],dp[ni] });\n\t\t}\n\t}\n}\n\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[1 << 17];\nint ans;\n\nvector<int> dfs(int v, int fr, int c) {\n\tvector<int> ret(16, 0);\n\trep(j, G[v].size()) {\n\t\tint to = G[v][j].to;\n\t\tint cost = G[v][j].cost;\n\t\tif (to == fr)continue;\n\t\tvector<int> nex = dfs(to, v, cost);\n\t\trep(i, 16) {\n\t\t\tif (ret[i] && nex[i]) {\n\t\t\t\tif (i>0)ans++; ret[i] = 0;\n\t\t\t}\n\t\t\telse if (nex[i])ret[i] = 1;\n\t\t}\n\t}\n\tif (v == 0)return ret;\n\tint s = 0;\n\trep(i, 16)if (ret[i])s ^= i; s ^= c;\n\tif (ret[s]) {\n\t\tif (s > 0)ans++; ret[s] = 0;\n\t}\n\telse {\n\t\tret[s] = true;\n\t}\n\treturn ret;\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint x, y, a; cin >> x >> y >> a;\n\t\tG[x].push_back({ y,a });\n\t\tG[y].push_back({ x,a });\n\t}\n\tvector<int> nex = dfs(0, -1, -1);\n\tint s = 0;\n\trep(i, 16) {\n\t\tif (nex[i]) {\n\t\t\ts += (1 << i);\n\t\t}\n\t}\n\tans += dp[s];\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, num[16], ret[1<<16];\nvpi adj[MX], ADJ[MX];\n\nvoid dfs(int x, int pre, int val) {\n    if (x) num[val] ++;\n    for (auto a: adj[x]) if (a.f != pre) dfs(a.f,x,val^a.s);\n}\n\nvoid addEdge(int z, int i, int j) {\n    int Z = z; Z ^= 1<<i;\n    if (j == -1) {\n        ADJ[Z].pb({z,1});\n    } else {\n        Z ^= 1<<j;\n        if (Z & 1<<(i^j)) ADJ[Z^(1<<(i^j))].pb({z,2});\n        else ADJ[Z^(1<<(i^j))].pb({z,1});\n    }\n}\n\nvoid gen() {\n    F0R(z,1<<16) if (!(z&1)) {\n        F0R(i,16) if (z&(1<<i)) {\n            FOR(j,1,16) if (i != j && (z&(1<<j))) addEdge(z,i,j);\n            addEdge(z,i,-1);\n        }\n    }\n    \n    FOR(i,1,1<<16) ret[i] = MOD;\n    vi todo[17]; todo[0].pb(0); ret[0] = 0;\n    F0R(i,16) while (sz(todo[i])) {\n        int x = todo[i].back(); todo[i].pop_back();\n        if (ret[x] != i) continue;\n        for (auto a: ADJ[x]) if (i+a.s < ret[a.f]) {\n            ret[a.f] = i+a.s;\n            todo[ret[a.f]].pb(a.f);\n        }\n    } \n    /*cout << \"ZZ \" << ret[(1<<16)-2] << \"\\n\";\n    cout << \"ZZ \" << ret[(1<<3)^(1<<4)^(1<<7)] << \"\\n\";\n    cout << \"ZZ \" << ret[(1<<3)^(1<<4)] << \"\\n\";\n    exit(0);*/\n}\n\nint main() {\n    gen();\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N-1) {\n        int a,b,c; cin >> a >> b >> c;\n        adj[a].pb({b,c}), adj[b].pb({a,c});\n    }\n    dfs(0,-1,0); num[0] = 0;\n    int cur = 0, ans = 0;\n    F0R(i,16) {\n        ans += num[i]/2;\n        if (num[i]) cur ^= (1<<i);\n    }\n    cout << ans+ret[cur];\n    // F0R(i,16) cout << num[i] << \" \";\n    // cout << \"\\n\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>bin[200];\nconst int maxn=10000000;\nint n,d[maxn+4]={0},v[2000005]={0},f[(1<<20)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint all=15,s=0,res=0,t=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=1;i<=all;i++){\n\t\tres+=v[i]/2,v[i]%=2;\n\t\tif(v[i]){\n\t\t\ts|=(1<<(i-1));\n\t\t\tt++;\n\t\t}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<all)-1;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=14;j++)\n\t\t\tif(i&(1<<j))cnt++;\n\t\tbin[cnt].push_back(i);\n\t}\n\tfor(int p=2;p<=t;p++)\n\t\tfor(int k=0;k<bin[p].size();k++){\n\t\t\tint i=bin[p][k];\n\t\t\tfor(int u=0;u<=14;u++)\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=14;v++)\n\t\t\t\tif(i&(1<<v)){\n\t\t\t\t\tint w=u^v;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nconst int bits = 15;\nconst int limit = 1 << bits;\n\nint n, i, x, y, z, ans;\nvector< pair<int, int> > list[maxN];\nint dp[limit];\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > H;\nint tp;\n\nvoid pre() {\n    int i, j, to, aux, cnt = 0;\n\n    for (i = 0; i < limit; i++) dp[i] = bits + 1;\n    dp[0] = 0;\n    H.push(mp(0, 0));\n\n    while (!H.empty()) {\n        int conf = H.top().second;\n        int cost = H.top().first;\n        H.pop();\n\n        if (dp[conf] != cost) continue;\n        cnt++;\n\n        for (i = 0; i < bits; i++) {\n            for (j = 0; j < bits; j++) {\n                if (i == j) continue;\n                to = conf ^ (1 << i) ^ (1 << j);\n\n                aux = 1 << (((i + 1) ^ (j + 1)) - 1);\n                //if (conf & aux) continue;\n                to ^= aux;\n\n                if (dp[to] > dp[conf] + 1) {\n                    dp[to] = dp[conf] + 1;\n                    H.push(mp(dp[to], to));\n                }\n            }\n\n            to = conf ^ (1 << i);\n            if (dp[to] > dp[conf] + 1) {\n                dp[to] = dp[conf] + 1;\n                H.push(mp(dp[to], to));\n            }\n        }\n    }\n\n    //for (i = 0; i < 256; i++) cerr << dp[i] << ' ';\n    //cerr << '\\n';\n\n    cerr << limit - cnt << '\\n';\n}\n\nvoid dfs(int node, int root, int need) {\n    int act = 0;\n\n    for (auto to : list[node])\n        if (to.first != root)\n            dfs(to.first, node, to.second), act ^= to.second;\n\n    if (node != 1 && act != need)\n        tp ^= (1 << (act ^ need)), ans++;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    pre();\n    for (i = 1; i < n; i++) {\n        cin >> x >> y >> z;\n        x++; y++;\n        list[x].pb(mp(y, z));\n        list[y].pb(mp(x, z));\n    }\n\n    dfs(1, 0, 0);\n    ans += dp[tp];\n\n    if (ans % 1) cerr << \"Error\";\n    cout << ans / 2;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define ll long long\n#define ull  unsigned long long\n#define pb push_back\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 200000;\nint a[N], cnt[N], d[N];\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\",\"w\", stdout);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v, x;\n        cin >> u >> v >> x;\n        a[u] ^= x;\n        a[v] ^= x;\n    }\n    for (int i = 0; i < n; i++){\n        cnt[a[i]]++;\n    }\n    int ans = 0;\n    int s = 0;\n    for (int i = 1; i < 16; i++){\n        ans += cnt[i] / 2;\n        if (cnt[i] % 2) s |= (1 << i);\n    }\n    for (int i = 0; i < (1 << 16); i++) d[i] = 1e9;\n    d[s] = 0;\n    queue < int > q;\n    q.push(s);\n    while(!q.empty()){\n        int mask = q.front();\n        q.pop();\n        for (int i = 1; i < 16; i++){\n            if (mask & (1 << i))\n            for (int j = i + 1; j < 16; j++){\n                if (mask & (1 << j))\n                for (int l = 0; l < 16; l++){\n                    int x = (i ^ l);\n                    int y = (j ^ l);\n                    int c = 1;\n                    int newmask = mask;\n                    newmask ^= (1 << i);\n                    newmask ^= (1 << j);\n                    if (newmask & (1 << x)) c++;\n                    if (newmask & (1 << y)) c++;\n                    newmask ^= (1 << x);\n                    newmask ^= (1 << y);\n                    if (d[newmask] > d[mask] + c){\n                        d[newmask] = d[mask] + c;\n                        q.push(newmask);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans + min(d[0], d[1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define ll long long\n#define ull  unsigned long long\n#define pb push_back\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 200000;\nint a[N], cnt[N], d[N];\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\",\"w\", stdout);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v, x;\n        cin >> u >> v >> x;\n        a[u] ^= x;\n        a[v] ^= x;\n    }\n    for (int i = 0; i < n; i++){\n        cnt[a[i]]++;\n    }\n    int ans = 0;\n    int s = 0;\n    for (int i = 1; i < 16; i++){\n        ans += cnt[i] / 2;\n        if (cnt[i] % 2) s |= (1 << i);\n    }\n    for (int i = 0; i < (1 << 16); i++) d[i] = 1e9;\n    d[s] = 0;\n    queue < int > q;\n    q.push(s);\n    while(!q.empty()){\n        int mask = q.front();\n        q.pop();\n        for (int i = 1; i < 16; i++){\n            if (mask & (1 << i))\n            for (int j = i + 1; j < 16; j++){\n                if (mask & (1 << j))\n                for (int l = 0; l < 16; l++){\n                    int x = (i ^ l);\n                    int y = (j ^ l);\n                    int c = 1;\n                    int newmask = mask;\n                    newmask ^= (1 << i);\n                    newmask ^= (1 << j);\n                    if (newmask & (1 << x) && x != 0) c++;\n                    if (newmask & (1 << y) && y != 0) c++;\n                    newmask ^= (1 << x);\n                    newmask ^= (1 << y);\n                    if (d[newmask] > d[mask] + c){\n                        d[newmask] = d[mask] + c;\n                        q.push(newmask);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans + min(d[0], d[1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<29;\nconst LL OO=1e18;\n\nconst int N=1e5+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nint d[N];\nint bug[N];\nint v[16];\nint f[1<<16];\nint main()\n{\n\tint n=gi(),i,s,t,a,b,c,ans=0,m=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi(),c=gi();\n\t\td[a]^=c,d[b]^=c;\t\n\t}\n\tfor (i=0;i<n;i++) ++bug[d[i]];\n\tfor (i=1;i<16;i++) {\n\t\tans+=bug[i]/2;\n\t\tif (bug[i]&1) v[m++]=i;\n\t}\n\tfor (s=1;s<1<<m;s++) {\n\t\tfor (i=c=0;i<m;i++) if (s>>i&1) c^=v[i];\n\t\tif (c) f[s]=oo;\n\t\telse for (i=0,f[s]=-1;i<m;i++) f[s]+=s>>i&1;\n\t\tfor (t=s;(--t)&=s;)\n\t\t\tupmin(f[s],f[t]+f[s^t]);\n\t}\n\tcout<<ans+f[(1<<m)-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    os << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<pair<int,int>>> G(N);\n    for (int i=0;i<N-1;++i){\n        int x,y,a; cin >> x >> y >> a;\n        G[x].emplace_back(y,a);\n        G[y].emplace_back(x,a);\n    }\n    vector<int> cnt(16,0);\n    auto dfs=[&](auto self,int v,int p,int a)->void{\n        for (auto e:G[v]){\n            int u=e.first;\n            if (u==p) continue;\n            self(self,u,v,e.second);\n            a^=e.second;\n        }\n        ++cnt[a];\n    };\n    dfs(dfs,0,-1,0);\n    int bit=0,ans=0;\n    for (int i=1;i<16;++i){\n        ans+=(cnt[i]>>1)+(cnt[i]&1);\n        bit|=(cnt[i]&1)<<(i-1);\n    }\n    vector<int> dp(1<<15,20);\n    dp[0]=0;\n    for (int mask=1;mask<(1<<15);++mask){\n        int XOR=0;\n        for (int i=0;i<15;++i){\n            if (mask&1<<i){\n                XOR^=i+1;\n            }\n        }\n        if (!XOR) dp[mask]=1;\n        for (int sub=mask;;sub=(sub-1)&mask){\n            dp[mask]=min(dp[mask],dp[sub]+dp[mask^sub]);\n            if (!sub) break;\n        }\n    }\n    cout << ans-dp[bit] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\ntypedef long long ll;\nconst int N = 1e5 + 9;\n\nint n, a[N], t[N];\nll f[N << 2], INF;\n\nvoid addmin(ll &x, ll y) {\n\tx = std::min(x, y);\n}\n\nll dfs(int st) {\n\tif (st == 0) return 0;\n\tif (f[st] != INF) return f[st];\n\tfor (int i = 0; i < 16; ++i) if ((st >> i) & 1)\n\t\tfor (int j = 0; j < 16; ++j) if (((st >> j) & 1) && i != j) {\n\t\t\tint st_ = st ^ (1 << (i ^ j)) ^ (1 << i) ^ (1 << j);\n\t\t\tif (st >> (i ^ j) & 1)\n\t\t\t\taddmin(f[st], dfs(st_) + 2);\n\t\t\telse\n\t\t\t\taddmin(f[st], dfs(st_) + 1);\n\t\t}\n\treturn f[st];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t++u, ++v;\n\t\ta[u] ^= w, a[v] ^= w;\n\t}\n\tll ans = 0;\n\tint st = 0;\n\tfor (int i = 1; i <= n; ++i) t[a[i]]++;\n\tfor (int i = 1; i < 16; ++i) {\n\t\tans += t[i] / 2;\n\t\tst |= (1 << i) * (t[i] & 1);\n\t}\n//\tprintf(\"%d\\n\", st);\n\tmemset(f, 0x3f, sizeof f);\n\tINF = f[0];\n\tf[0] = 0;\n\tprintf(\"%lld\\n\", dfs(st) + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][20][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 50) return 1e9;\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e5 + 5, MAXS = ( 1 << 16 ) + 5;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MIN( const _T a, const _T b )\n{\n\treturn a < b ? a : b;\n}\n\nint f[MAXS];\nint w[MAXN];\nint N, cnt;\nbool vis[MAXS];\n\nbool chk( const int S, const int b ) { return S >> b & 1; }\n\nint DFS( const int S )\n{\n\tif( ! S ) return f[S] = 0;\n\tif( vis[S] ) return f[S];\n\tvis[S] = true;\n\tfor( int i = 1 ; i <= 15 ; i ++ )\n\t\tfor( int j = i + 1 ; j <= 15 ; j ++ )\n\t\t\tif( chk( S, i - 1 ) && chk( S, j - 1 ) )\n\t\t\t{\n\t\t\t\tint t = S ^ ( 1 << i - 1 ) ^ ( 1 << j - 1 );\n\t\t\t\tint v = i ^ j, nxt = t ^ ( 1 << v - 1 );\n\t\t\t\tf[S] = MIN( f[S], DFS( nxt ) + 1 + chk( t, v - 1 ) );\n\t\t\t}\n\treturn f[S];\n}\n\nint main()\n{\n\tread( N );\n\tfor( int i = 1, x, y, b ; i < N ; i ++ )\n\t\tread( x ), read( y ), read( b ),\n\t\tw[x + 1] ^= b, w[y + 1] ^= b;\n\tint sta = 0, tot = 0;\n\tfor( int i = 1 ; i <= N ; i ++ )\n\t\ttot += ( sta >> w[i] - 1 ) & 1, \n\t\tsta ^= 1 << w[i] - 1;\n\tmemset( f, 0x3f, sizeof f );\n\twrite( DFS( sta ) + tot ), putchar( '\\n' ); \n\treturn 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22],lg[66666];\nint f[66666],q[66666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tint ans=0;\n\tfor(register int i=2,j=1;i<65536;i<<=1,++j)lg[i]=j;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])++w;//w|=1<<i;\n\tf[w]=0;\n\tfor(q[hq=1]=w,tq=2;hq!=tq;++hq)\n\t{\n\t\tint o=q[hq];\n\t\tint l=lg[o&-o];\n\t\tfor(register int i=l+1;i<16;++i)\n\t\t\tif(o&1<<i)\n\t\t\t{\n\t\t\t\tint t=o^1<<l^1<<i^1<<(l^i);\n\t\t\t\tif(f[t]==0)f[t]=f[o]+1,q[tq++]=t;\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[0]); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nvector<pair<int,int> > g[400010];\nint a[200010],w[200010],cnt[20],p[1000010],x,y,z,n,ans;\nbool vis[1000010];\nvoid dfs(int p,int fa)\n{\n\tfor(auto i:g[p])if(i.first!=fa)a[i.first]=i.second,dfs(i.first,p);\n\tfor(auto i:g[p])if(i.first!=fa)w[p]^=w[i.first];\n\ta[p]^=w[p];w[p]^=a[p];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)scanf(\"%d%d%d\",&x,&y,&z),x++,y++,g[x].pb({y,z}),g[y].pb({x,z});\n\tdfs(1,0);\n\tfor(int i=1;i<=n;i++)++cnt[a[i]];\n\tfor(int i=1;i<16;i++)ans+=cnt[i]/2,cnt[i]&=1;\n\tfor(int i=1;i<16;i++)if(cnt[i])++ans;\n\tfor(int i=1;i<(1<<16);i++)p[i]=-100;\n\tfor(int i=0;i<(1<<15);i++)\n\t{\n\t\tint tp=i,ts=1,now=0;\n\t\tfor(;tp;tp>>=1,++ts)if(tp&1)now^=ts;\n\t\tvis[i]=!now;\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\tif(vis[i])\n\t{\n\t\tp[i]=1;\n\t\tfor(int j=i;j;j=(j-1)&i)if(vis[j])p[i]=max(p[i],p[j]+p[i^j]);\n\t}\n\tint tp=0;\n\tfor(int i=15;i;i--)tp=(tp<<1)|cnt[i];\n\tprintf(\"%d\\n\",ans-p[tp]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define N 2001001\n#define MAX 2001\n#define re register\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst ll mod=1000000007; \ninline void read(re ll &ret)\n{\n    ret=0;re char c=getchar();re bool pd=false;\n    while(!isdigit(c)){pd|=c=='-';c=getchar();}\n    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}\n    ret=pd?-ret:ret;\n    return;\n}\nll n,x[N],y[N],a[N],w[N],cnt[N],ans,st,dp[N],sum[N];\nsigned main()\n{\n\tread(n);\n\tfor(re int i=1;i<n;i++)\n\t{\n\t\tread(x[i]);\n\t\tread(y[i]);\n\t\tread(a[i]);\n\t\tw[x[i]]^=a[i];\n\t\tw[y[i]]^=a[i];\n\t}\n\tfor(re int i=0;i<n;i++)\n\t\tcnt[w[i]]++;\n\tfor(re int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]>>1;\n\t\tst|=(cnt[i]&1)<<(i-1);\n\t}\n\tfor(re int i=1;i<(1<<15);i++)\n\t\tdp[i]=dp[i>>1]+(i&1);\n\tfor(re int i=1;i<(1<<15);i++)\n\t\tdp[i]--;\n\tfor(re int i=1;i<(1<<15);i++)\n\t\tfor(re int j=0;(1<<j)<=i;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tsum[i]^=j+1;\n\tfor(re int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sum[i])\n\t\t\tcontinue;\n\t\tfor(re int j=(i-1)&i;j;j=((j-1)&j))\n\t\t\tif(!sum[j])\n\t\t\t\tdp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tprintf(\"%lld\\n\",ans+dp[st]);\n\texit(0);\n}\n/*\n9 9\n9 8 7 6 2 4 5 3 1\n4 9 3 6\n2 9 1 8\n3 8 2 4\n3 9 2 7\n2 8 1 6\n1 9 1 9\n1 3 5 7\n2 3 3 3\n6 6 6 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(998244353);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nint a[100100],cnt[16],memo[1<<16];\nbool done[1<<16];\n\nint solve(int st){\n\tint i,j,k;\n\tif(done[st]){\n\t\treturn memo[st];\n\t}\n\tdone[st] = 0;\n\tif(!st){\n\t\treturn memo[st] = 0;\n\t}\n\tmemo[st] = INF;\n\tfor(i=1; i<16; ++i){\n\t\tif(!(st&(1<<i))){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=1; j<i; ++j){\n\t\t\tif(!(st&(1<<j))){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tk = i^j;\n\t\t\tif(st&(1<<k)){\n\t\t\t\tmemo[st] = min(memo[st],solve(st-(1<<i)-(1<<j)-(1<<k))+2);\n\t\t\t}else{\n\t\t\t\tmemo[st] = min(memo[st],solve(st-(1<<i)-(1<<j)+(1<<k))+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[st];\n}\n\nint main(void){\n\tint n,i,x,y,z,ans=0,left=0;\n\tcin >> n;\n\tfor(i=1; i<n; ++i){\n\t\tcin >> x >> y >> z;\n\t\ta[x] ^= z;\n\t\ta[y] ^= z;\n\t}\n\tfor(i=0; i<n; ++i){\n\t\t++cnt[a[i]];\n\t}\n\tfor(i=1; i<16; ++i){\n\t\tans += cnt[i]/2;\n\t\tif(cnt[i]%2){\n\t\t\tleft += (1<<i);\n\t\t}\n\t}\n\tans += solve(left);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define LINF 1000000000000000000\n#define MOD 1000000007\n#define mod 1000007\n#define INF63 1061109567\n#define INF127 9187201950435737471\n#define F first\n#define S second\n#define ll long long\n#define N 100010\n#define M 20\n#define NM 70000\nusing namespace std;\nint n,m,val[N],tms[M],v=0,ans=0,dp[NM];\nbool can[NM]={};\nint main(){\n\tint i,j,x,y,z;\n\tcin>>n;\n\tmemset(tms,0,sizeof(tms));\n\tmemset(val,0,sizeof(val));\n\tfor(i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tval[x]^=z;\n\t\tval[y]^=z;\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\ttms[val[i]]++;\n\t}\n\tfor(i=1;i<16;i++)\n\t{\n\t\tif(tms[i]%2==1)\n\t\t{\n\t\t\tv+=(1<<i);\n\t\t}\n\t\tans+=tms[i]/2;\n\t}\n\tfor(i=0;i<(1<<16);i++)\n\t{\n\t\tx=0;\n\t\tfor(j=1;j<16;j++)\n\t\t{\n\t\t\tif((i&(1<<j))!=0)\n\t\t\t{\n\t\t\t\tx^=j;\n\t\t\t}\n\t\t}\n\t\tif(x==0)\n\t\t{\n\t\t\tcan[i]=true;\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor(i=0;i<(1<<16);i++)\n\t{\n\t\tfor(j=i;j!=0;j=j&(j-1))\n\t\t{\n\t\t\tif(can[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tans+=__builtin_popcount(v)-dp[v];\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    for(int i=0; i<16; i++) ans+=cnt[i]>>1, cnt[i]=cnt[i]&1;\n    ans+=cnt[0];\n    cnt[0]=0;\n    dp[0]=0;\n    for(int mask=1; mask<(1<<16); mask++){\n        int nw=0;\n        for(int i=0; i<16; i++) if(((mask>>i)&1)&&cnt[i]) nw^=i;\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<16); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[mask]) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<16)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, M;\nint A[MAX_N];\nint cnt[MAX_N];\n\nint dp[(1 << 16)];\nint ok[(1 << 16)];\nvector<int> vec;\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tA[a] ^= c;\n\t\tA[b] ^= c;\n\t}\n\trep(i, 0, N) cnt[A[i]]++;\n\t// debug(vi(A, A + N));\n\t// debug(vi(cnt, cnt + 16));\n\n\tint ans = 0;\n\trep(i, 1, 16) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] % 2) vec.pb(i);\n\t}\n\tM = sz(vec);\n\n\trep(bit, 1, (1 << M)) {\n\t\tint tmp = 0, res = 0;\n\t\trep(i, 0, M) {\n\t\t\tif(!(bit & (1 << i))) continue;\n\t\t\ttmp ^= vec[i];\n\t\t\tres++;\n\t\t}\n\t\tif(tmp == 0) ok[bit] = res - 1;\n\t\telse ok[bit] = N;\n\t}\n\tfill(dp, dp + (1 << M), M);\n\tdp[0] = 0;\n\trep(bit, 0, (1 << M)) {\n\t\tvector<int> vt;\n\t\trep(i, 0, M) {\n\t\t\tif(!(bit & (1 << i))) vt.pb(i);\n\t\t}\n\t\trep(bit2, 1, (1 << sz(vt))) {\n\t\t\tint to = 0;\n\t\t\trep(i, 0, sz(vt)) {\n\t\t\t\tif(bit2 & (1 << i)) to |= (1 << vt[i]);\n\t\t\t}\n\t\t\tMIN(dp[bit2 | to], dp[bit] + ok[to]);\n\t\t}\n\t}\n\tcout << ans + dp[(1 << M) - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 100010, N=16;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN];\nint cnt[MAXN];\nint dp[1<<N], xo[1<<N];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tcin>>u>>v>>x;\n\t\tA[u]^=x;\n\t\tA[v]^=x;\n\t}\n\tfor (int i=1; i<=n; i++) cnt[A[i]]++;\n\tans=cnt[0];\n\tcnt[0]=0;\n\tfor (int i=1; i<N; i++) ans+=cnt[i]/2, cnt[i]%=2;\n\tfor (int mask=1; mask<(1<<N); mask++){\n\t\tint bit=__builtin_ctz(mask);\n\t\txo[mask]=xo[mask^(1<<bit)]^bit;\n\t}\n\tfor (int mask=1; mask<(1<<N); mask++)\n\t\tfor (int submask=mask; submask; submask=(submask-1)&mask)\n\t\t\tif (!xo[submask]) dp[mask]=max(dp[mask], dp[mask^submask] + 1);\n\t\n\tint mask=0;\n\tfor (int i=0; i<N; i++) if (cnt[i]) mask|=(1<<i);\n\tans+=dp[mask];\n\tcout<<n-ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,val[100009],ans,mask,cnt[16],good[1<<16],dp[1<<16];\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++) {\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tval[a]^=c;\n\t\tval[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++) cnt[val[i]]++;\n\tfor(int i=1;i<16;i++) {\n\t\tans+=cnt[i]>>1;\n\t\tif(cnt[i]&1) mask|=1<<i;\n\t}\n\tfor(int i=1;i<1<<16;i++) {\n\t\tint j=0;\n\t\tfor(int k=0;k<16;k++)\n\t\t\tif(1<<k&i)\n\t\t\t\tj^=k;\n\t\tgood[i]=j==0;\n\t}\n\tfor(int i=2;i<1<<16;i+=2)\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\tif(good[j])\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\tprintf(\"%d\\n\",ans+__builtin_popcount(mask)-dp[mask]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1000000000;\n\nint main()\n{\n  int N=(1<<16);\n  vector<vector<pair<int,int> > > E(N);\n  for(int I=0;I<(1<<16);I+=2){\n    for(int j=1;j<16;j++){\n      for(int k=j+1;k<16;k++){\n\tif(!((I>>j)&1)||!((I>>k)&1))continue;\n\tint J=I^(1<<j)^(1<<k)^(1<<(j^k));\n\tint t=((I>>(j^k))&1)+1;\n\tE[J].push_back(make_pair(I,t));\n      }\n    }\n  }\n  vector<int> V(N,INF);\n  V[0]=0;\n  priority_queue<pair<int,int> > Q;\n  Q.push(make_pair(0,0));\n  while(!Q.empty()){\n    int d=-Q.top().first,i=Q.top().second;\n    Q.pop();\n    if(V[i]<d)continue;\n    for(int x=0;x<E[i].size();x++){\n      int j=E[i][x].first,D=d+E[i][x].second;\n      if(D<V[j]){\n\tV[j]=D;\n\tQ.push(make_pair(-D,j));\n      }\n    }\n  }\n  int n;\n  scanf(\"%d\",&n);\n  vector<vector<pair<int,int> > > e(n);\n  for(int i=0;i<n-1;i++){\n    int x,y,a;\n    scanf(\"%d%d%d\",&x,&y,&a);\n    e[x].push_back(make_pair(y,a));\n    e[y].push_back(make_pair(x,a));\n  }\n  int C[16]={0};\n  for(int i=0;i<n;i++){\n    int t=0;\n    for(int x=0;x<e[i].size();x++){\n      t^=e[i][x].second;\n    }\n    C[t]++;\n  }\n  int I=0;\n  int ans=0;\n  for(int t=1;t<16;t++){\n    I|=((C[t]&1)<<t);\n    ans+=C[t]/2;\n  }\n  ans+=V[I];\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\n\nint N;\nvector<pii> gg[MN], g[MN];\nint ret;\n\nvoid pre(int v, int p)\n{\n\tfor (pii e : gg[v]) if (e.fi != p) {\n\t\tg[v].eb(e);\n\t\tpre(e.fi, v);\n\t}\t\n}\n\nint dfs(int v)\n{\n\tvi cnt(16);\n\n\tfor (pii e : g[v]) {\n\t\tint res = dfs(e.fi);\n\t\t++cnt[res ^ e.se];\n\t}\n\n\tint xo = 0;\n\n\trep(i, 16) {\n\t\tret += cnt[i] / 2;\n\t\tif (cnt[i] & 1) {\n\t\t\txo ^= i;\n\t\t}\n\t}\n\n\tif (v == 0) {\n\t\tfor (int i = 1; i < 16; ++i) {\n\t\t\tret += cnt[i] & 1;\n\t\t}\n\t}\n\n\treturn xo;\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgg[x].eb(y, a);\n\t\tgg[y].eb(x, a);\n\t}\n\n\tpre(0, -1);\n\tdfs(0);\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\nbool B(int x,int i){return (x>>i)&1;}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tint N;\n\tcin >> N;\n\tV<int> v(N);\n\trep(i,N-1){\n\t\tint x,y,a;\n\t\tcin >> x >> y >> a;\n\t\tv[x] ^= a;\n\t\tv[y] ^= a;\n\t}\n\tint s = 0;\n\tint ans = 0;\n\trep(i,N){\n\t\tif(v[i] == 0) ans++;\n\t\telse{\n\t\t\tif(B(s,v[i])){\n\t\t\t\ts ^= 1<<v[i];\n\t\t\t\tans++;\n\t\t\t}else{\n\t\t\t\ts ^= 1<<v[i];\n\t\t\t}\n\t\t}\n\t}\n\tV<int> dp(1<<16);\n\trep(b,1<<16) if((s&b) == b){\n\t\t{\n\t\t\tint x = 0;\n\t\t\trep(i,16) if(B(b,i)) x ^= i;\n\t\t\tif(x == 0) dp[b]++;\n\t\t}\n\t\trep(i,16) if(!B(b,i) && B(s,i)){\n\t\t\tchmax(dp[b|(1<<i)],dp[b]);\n\t\t}\n\t}\n\tint mx = 0;\n\trep(b,1<<16) chmax(mx,dp[b]);\n\tans += mx-1;\n\tcout << N - ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n//#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\n//int mod = 1000000007;\n//int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n#define N_max 100000\nint cnt[16] = {};\nint xx[N_max] = {};\nint dp[bit(15)]={0,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,3,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,-1,-1,-1,-1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,3,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,8,-1,-1,-1,-1,-1,3,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,4,-1,2,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,8,-1,-1,-1,-1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,4,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,4,-1,-1,-1,-1,-1,4,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,4,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,6,-1,5,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,7,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,7,-1,-1,-1,-1,-1,-1,6,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,8,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,8,-1,-1,-1,-1,-1,5,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,6,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,7,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,7,-1,-1,-1,-1,-1,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,8,-1,-1,-1,-1,-1,8,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,8,-1,-1,-1,-1,-1,8,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,-1,-1,-1,-1,-1,-1,10};\n\n\nsigned main(){\n\n    int N;\n    scanf(\"%d\", &N);\n    int x, y, a;\n    REP(i, N - 1){\n        scanf(\"%d %d %d\", &x, &y, &a);\n        xx[x] ^= a, xx[y] ^= a;\n    }\n    REP(i, N) cnt[xx[i]]++;\n\n    int ans = 0, X = 0;\n    REP(i, 15){\n        ans += cnt[i + 1] / 2;\n        if(cnt[i + 1] & 1) X ^= bit(i);\n    }\n    ans += dp[X];\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint a[100005];\nint cnt[16];\nint ok[1 << 16], f[1 << 16];\nint ans = 0;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v, w; cin >> u >> v >> w;\n\t\ta[u] ^= w, a[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tans += cnt[a[i]] && a[i];\n\t\tcnt[a[i]] ^= 1;\n\t}\n\tint all = 0;\n\tfor (int i = 1; i < 16; ++i) if (cnt[i]) {\n\t\tall |= (1 << i);\n\t}\n\tfor (int mask = 0; mask < (1 << 16); ++mask) {\n\t\tint sum = 0;\n\t\tfor (int i = 1; i < 16; ++i) if ((mask >> i) & 1) {\n\t\t\tsum ^= i;\n\t\t} \n\t\tok[mask] = sum == 0;\n\t} \n\tfor (int mask = 0; mask < (1 << 16); ++mask) {\n\t\tint cur = mask;\n\t\twhile (cur) {\n\t\t\tif (ok[cur]) f[mask] = max(f[mask], f[mask ^ cur] + 1);\n\t\t\tcur = (cur - 1) & mask;\n\t\t}\n\t}\n\tcout << (ans + __builtin_popcount(all) - f[all]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[16][1 << 16][8];\nint dp2(int idx, int mask, int tidx, int tcnt) {\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask);\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(idx, mask, tidx + 1, tcnt);\n\n    if(cc2[idx][mask][tidx].find(tcnt) != cc2[idx][mask][tidx].end()) return cc2[idx][mask][tidx][tcnt];\n    int &ret = cc2[idx][mask][tidx][tcnt];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(idx, mask, tidx + 1, tcnt));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(idx, mask ^ (1 << tidx) ^ (1 << didx), tidx + 1, tcnt + 1));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(idx, mask, 1, 0);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[1<<15];\nint v[100005];\nint n,cnt[16];\nint solve(int mask){\n\tif(mask==0)return 0;\n\tif(~dp[mask])return dp[mask];\n\tint &ret=dp[mask];ret=inf;\n\tfor(int i=1;i<=15;i++){\n\t\tif(mask&(1<<i-1)){\n\t\t\tfor(int j=i+1;j<=15;j++){\n\t\t\t\tif(mask&(1<<j-1)){\n\t\t\t\t\tret=min(ret,solve((mask^(1<<i-1)^(1<<j-1))^(1<<(i^j)-1))\n\t\t\t\t\t+1+((mask&(1<<(i^j)-1))?1:0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tmemset(dp,-1,sizeof dp);\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;cin>>x>>y>>z;x++;y++;\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tfor(int i=1;i<=n;i++)cnt[v[i]]++;\n\tint mask=0,ans;\n\tfor(int i=1;i<=15;i++){\n\t\tif(cnt[i]%2)mask|=(1ll<<i-1);\n\t\tans+=cnt[i]/2;\n\t}\n\tcout<<solve(mask)+ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <unordered_map>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T> struct CVECTOR {\n\tstd::vector<T> cumsum;\n\tCVECTOR(const std::vector<T>& a) : cumsum(a.size() + 1, 0) {\n\t\tfor (size_t i = 0; i < a.size(); ++i) cumsum[i + 1] = cumsum[i] + a[i];\n\t}\n\tT operator[](int idx) { return cumsum[idx + 1]; }\n};\ntemplate<class T> CVECTOR<T> make_cvector(const std::vector<T>& a) {\n\treturn CVECTOR<T>(a);\n}\n// ------------>8------------------------------------->8------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y, a);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\tg[x[i]].emplace_back(y[i]);\n\t\tg[y[i]].emplace_back(x[i]);\n\t}\n\tstd::vector<std::vector<PAIR>> G(n);\n\tREP(i, n - 1) {\n\t\tG[x[i]].emplace_back(PAIR(y[i], a[i]));\n\t\tG[y[i]].emplace_back(PAIR(x[i], a[i]));\n\t}\n\n\tstd::vector<int> b(n, 0);\n\t{\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (e.first == par) continue;\n\t\t\t\tb[e.first] = e.second;\n\t\t\t\tdfs(e.first, v);\n\t\t\t}\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\n\tstd::vector<int> dp2(1 << 15, INFINT);\n\tdp2[0] = 0;\n\tREP(i, 15) {\n\t\tdp2[1 << i] = 1;\n\t}\n\tstd::function<int(int)> calc = [&](int bit) {\n\t\tif (dp2.at(bit) != INFINT) return dp2.at(bit);\n\n\t\tstd::vector<int> bitv;\n\t\tREP(j, 15) {\n\t\t\tif ((bit >> j) & 1) bitv.emplace_back(j);\n\t\t}\n\t\tREP(j, bitv.size()) FOR(k, j + 1, bitv.size()) {\n\t\t\tint mask = bit;\n\t\t\tmask &= ~(1 << bitv.at(j));\n\t\t\tmask &= ~(1 << bitv.at(k));\n\t\t\tint pos = ((bitv.at(j) + 1) ^ (bitv.at(k) + 1)) - 1;\n\t\t\tif (!IN(0, pos, 15)) {\n\t\t\t\tVAR(int, x);\n\t\t\t}\n\t\t\tif (mask & (1 << pos)) {\n\t\t\t\tCHMIN(dp2.at(bit), calc(mask ^ (1 << pos)) + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCHMIN(dp2.at(bit), calc(mask ^ (1 << pos)) + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp2.at(bit);\n\t};\n\tFOR(i, 3, 1 << 15) {\n\t\tcalc(i);\n\t}\n\n\tstd::vector<PAIR> dp(n, PAIR(0, 0));\n\t{\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\tbool chi = true;\n\t\t\tint mask = 0, mask2 = 0;\n\t\t\tint cnt = 0;\n\t\t\tstd::set<int> set;\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (to == par) continue;\n\t\t\t\tchi = false;\n\t\t\t\tdfs(to, v);\n\t\t\t\tPAIR p = dp[to];\n\t\t\t\tmask ^= p.first;\n\t\t\t\tif (p.first != 0) {\n\t\t\t\t\tif (set.count(p.first)) {\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\tset.erase(p.first);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tset.insert(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt += p.second;\n\t\t\t}\n\t\t\tif (chi) {\n\t\t\t\tdp[v] = PAIR(b[v], 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (auto& x : set) {\n\t\t\t\tmask2 |= 1 << (x - 1);\n\t\t\t}\n\t\t\tif (mask != 0 && (mask & b[v]) == 0) {\n\t\t\t\t++cnt;\n\t\t\t\tmask = b[v];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt += dp2[mask2];\n\t\t\t\tmask ^= b[v];\n\t\t\t}\n\t\t\tdp[v] = PAIR(mask, cnt);\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\tOUT(dp[0].second)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int N=1e5+5;\nint n,dp[1<<16],tot[20]={},a[N]={};bool vis[1<<16]={};\nint len(int x) {\n    int res=0;for(int i=1;i<16;i++) if(x>>i&1) res++;return res;\n}\nint dfs(int x) {\n    if(x<=1) return 0;\n    if(len(x)==1) return N;\n    if(vis[x]) return dp[x];\n    int res=N;vis[x]=true;\n    for(int i=1;i<16;i++) {\n        if(~x>>i&1) continue;\n        for(int j=1;j<16;j++) {\n            if(i==j||(~x>>j&1)) continue;\n            int nxt=x^(1<<i)^(1<<j)^(1<<(i^j));\n            if(len(nxt)>=len(x)) continue;\n            res=std::min(res,dfs(nxt)+1+(~nxt>>(i^j)&1));\n        }\n    }\n    return dp[x]=res;\n}\nint main() {\n    scanf(\"%d\",&n);int x,y,z;\n    for(int i=1;i<n;i++) scanf(\"%d%d%d\",&x,&y,&z),a[x]^=z,a[y]^=z;\n    for(int i=0;i<n;i++) tot[a[i]]++;\n    int ans=0,sta=0;\n    for(int i=1;i<16;i++) ans+=(tot[i]>>1),sta|=(tot[i]&1)<<i;\n    printf(\"%d\\n\",ans+dfs(sta));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#define ed end\n#define bg begin\n#define fr first\n#define sc second\n#define il inline\n#define LL long long\n#define pb push_back\n#define mk make_pair\n#define to(k) E[k].to\n#define val(k) E[k].val\n#define next(k) E[k].next\n#define pint pair<int, int>\n\n#define MAXN 400010\n#define MAXS 1200100\n#define Inf 998244353\n\nusing namespace std ;\nstruct Edge{\n\tint to, next, val ;\n}E[MAXN << 1] ; int head[MAXN], cnt, sz[MAXS] ; \nint N, vals[MAXN], dp[MAXN], ctn[MAXN], now_st, ans ; \n\nvoid add(int u, int v, int w){\n\tE[++ cnt].to = v, E[cnt].val = w,\n\tE[cnt].next = head[u], head[u] = cnt ;\n\tE[++ cnt].to = u, E[cnt].val = w,\n\tE[cnt].next = head[v], head[v] = cnt ;\n}\nint do_do(int stt){\n\tif (!stt) return 0 ;\n\tif (dp[stt] != -1) return dp[stt] ;\n\tint ret = Inf ;\n\tfor (int i = 1 ; i <= 15 ; ++ i){\n\t\tif (!(stt >> i & 1)) continue ;\n\t\tfor (int j = 1 ; j <= 15 ; ++ j){\n\t\t\tif (i == j || !(stt >> j & 1)) continue ;\n\t\t\tint now_st = stt ^ (1 << i) ^ (1 << j) ;\n\t\t\tint q = i ^ j ; now_st ^= (1 << q) ; \n\t\t\tif (sz[now_st] < sz[stt]) ret = min(ret, do_do(now_st) + 1 + (~now_st >> (q) & 1)) ; \n\t\t}\n\t}\n\treturn dp[stt] = ret ; \n}\nint main(){\n\tcin >> N ; \n\tint u, v, w, i ; \n\tmemset(dp, -1, sizeof(dp)) ;\n\tfor (i = 1 ; i < N ; ++ i) \n\t\tscanf(\"%d%d%d\", &u, &v, &w), \n\t\tadd(u + 1, v + 1, w), vals[u + 1] ^= w, vals[v + 1] ^= w ;  \n\tfor (i = 1 ; i <= N ; ++ i) if (vals[i]) ctn[vals[i]] ++ ; \n\tfor (i = 0 ; i <= 15 ; ++ i) ans += ctn[i] / 2, now_st |= (ctn[i] & 1) << i ;\n\tfor (i = 1 ; i < MAXS ; ++ i) sz[i] = sz[i - (i & -i)] + 1 ; \n\tans += do_do(now_st) ; cout << ans << endl ; return 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,X[100100],C[1<<16],D[1<<16];\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y,c; scanf (\"%d %d %d\",&x,&y,&c);\n\t\tX[x] ^= c;\n\t\tX[y] ^= c;\n\t}\n\n\tfor (int i=0;i<N;i++) C[1<<X[i]]++;\n\tC[1] = 0;\n\n\tint ans = 16;\n\tfor (int i=1;i<16;i++){\n\t\tint &c = C[1<<i];\n\t\tans += c / 2;\n\t\tc = c % 2 * i;\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tint x = i & (-i);\n\t\tC[i] = C[i-x] ^ C[x];\n\n\t\tD[i] = -99999;\n\t\tfor (int j=i;j;j=(j-1)&i) if (C[j] == 0){\n\t\t\tif (D[i] < D[i-j] + 1)\n\t\t\t\tD[i] = D[i-j] + 1;\n\t\t}\n\t}\n\tans -= D[(1<<16)-1];\n\n\tprintf (\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int TOT = 1 << 15, N = 100010;\nint dp[TOT],n,val[N],cnt[16],ans,sta,res[TOT];\nint main() {\n  int a,b,c,tmp;\n  scanf(\"%d\",&n);\n  for (int i = 1 ; i < n ; ++ i) {\n    scanf(\"%d%d%d\",&a,&b,&c);\n    a++, b++;\n    val[a] ^= c;\n    val[b] ^= c;\n  }\n  for (int i = 1 ; i <= n ; ++ i)\n    ++ cnt[val[i]];\n  ans = n;\n  ans -= cnt[0];\n  for (int i = 1 ; i <= 15 ; ++ i)\n    ans -= cnt[i]/2, sta |= (cnt[i]&1) << i >> 1;\n  for (int i = 0 ; i < TOT ; ++ i) {\n    tmp = 0;\n    for (int j = 1 ; j <= 15 ; ++ j)\n      if ((i >> j-1)&1) tmp ^= j;\n    res[i] = tmp;\n  }\n  for (int i = 1 ; i < TOT ; ++ i) {\n    for (int j = i ; j ; j = (j-1) & i)\n      if (!res[j]) dp[i] = max(dp[i],dp[i^j] + 1);\n  }\n  ans -= dp[sta];\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;vi v[N];\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=(j+1);\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n//\t\t\tdp[i]=1;\n\t\t}\n\t}\n\treturn;\n}\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++,cout<<i<<' '<<num[i]<<endl;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=1<<(i-1);\n\t\t}\n\t}\n\tinit();\n\tfor(int i=0;i<=mask;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,x,y,z,now,ans,a[120000],cnt[16],f[1<<15];\nvector<int> vec;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z; a[y]^=z;\n\t}\n\tfor (int i=0;i<n;++i) ++cnt[a[i]];\n\tfor (int i=1;i<=15;++i){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tnow|=cnt[i]<<(i-1);\n\t}\n\tmemset(f,-1,sizeof f);\n\tf[now]=ans; vec.push_back(now);\n\tfor (int i=0;i<(int)vec.size();++i){\n\t\tint S=vec[i];\n\t\tif (S==0){printf(\"%d\\n\",f[0]); return 0;}\n\t\tfor (int j1=1;j1<=15;++j1)\n\t\t\tif (1<<(j1-1)&S){\n\t\t\t\tfor (int j2=j1+1;j2<=15;++j2)\n\t\t\t\t\tif (1<<(j2-1)&S){\n\t\t\t\t\t\tfor (int k=1;k<=15;++k){\n\t\t\t\t\t\t\tint t1=j1^k,t2=j2^k,T=S,tmp=1;\n\t\t\t\t\t\t\tT^=1<<(j1-1); T^=1<<(j2-1);\n\t\t\t\t\t\t\tif (1<<(t1-1)&T) ++tmp;\n\t\t\t\t\t\t\tif (1<<(t2-1)&T) ++tmp;\n\t\t\t\t\t\t\tif (t1) T^=1<<(t1-1); if (t2) T^=1<<(t2-1);\n\t\t\t\t\t\t\tif (f[T]==-1||f[S]+tmp<f[T]){\n\t\t\t\t\t\t\t\tf[T]=f[S]+tmp;\n\t\t\t\t\t\t\t\tvec.push_back(T);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 2e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[33], p[33], dp[1 << 17], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << 16; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <unordered_map>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T> struct CVECTOR {\n\tstd::vector<T> cumsum;\n\tCVECTOR(const std::vector<T>& a) : cumsum(a.size() + 1, 0) {\n\t\tfor (size_t i = 0; i < a.size(); ++i) cumsum[i + 1] = cumsum[i] + a[i];\n\t}\n\tT operator[](int idx) { return cumsum[idx + 1]; }\n};\ntemplate<class T> CVECTOR<T> make_cvector(const std::vector<T>& a) {\n\treturn CVECTOR<T>(a);\n}\n// ------------>8------------------------------------->8------------\n\nconst int pop[] = { 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4 };\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y, a);\n\tstd::vector<std::vector<int>> g(n);\n\tstd::map<int, std::map<int, int>> map;\n\tstd::vector<int> in(n, 0);\n\tREP(i, n - 1) {\n\t\t++in[x[i]]; ++in[y[i]];\n\t\tg[x[i]].emplace_back(y[i]);\n\t\tg[y[i]].emplace_back(x[i]);\n\t\tmap[x[i]][y[i]] = map[y[i]][x[i]] = a[i];\n\t}\n\tstd::vector<int> used(n, false);\n\n\tstruct Node {\n\t\tint i, mask;\n\t\tbool operator<(const Node& r) const {\n\t\t\treturn pop[mask] > pop[r.mask];\n\t\t}\n\t};\n\tstd::priority_queue<Node> pq;\n\tREP(i, n) {\n\t\tif (g[i].size() == 1) {\n\t\t\tpq.push(Node{ i, map[i][g[i][0]] });\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (!pq.empty()) {\n\t\tauto now = pq.top(); pq.pop();\n\t\tif (used[now.i]) continue;\n\t\tused[now.i] = true;\n\t\tif (now.mask != 0) {\n\t\t\t++ans;\n\t\t\tint pos = now.i;\n\t\t\tstd::set<int> set;\n\t\t\twhile (true) {\n\t\t\t\tset.insert(pos);\n\t\t\t\tbool conti = false;\n\t\t\t\tfor (auto& to : g[pos]) {\n\t\t\t\t\tif (used[to] || set.count(to)) continue;\n\t\t\t\t\tint ma = map[pos][to];\n\t\t\t\t\tif ((ma & now.mask) == now.mask) {\n\t\t\t\t\t\tmap[pos][to] ^= now.mask;\n\t\t\t\t\t\tmap[to][pos] ^= now.mask;\n\t\t\t\t\t\tif (in[to] == 1) {\n\t\t\t\t\t\t\tpq.push(Node{ to, map[pos][to] });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = to;\n\t\t\t\t\t\tconti = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!conti) break;\n\t\t\t}\n\t\t}\n\t\tfor (auto& to : g[now.i]) {\n\t\t\tif (used[to]) continue;\n\t\t\t--in[to];\n\t\t\tif (in[to] == 1) {\n\t\t\t\tfor (auto& toto : g[to]) {\n\t\t\t\t\tif (used[toto]) continue;\n\t\t\t\t\tpq.push(Node{ to, map[to][toto] });\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 1e5 + 51;\n\nint dp[N], xorv[N];\nint dfs(int S) {\n\tif (dp[S]) return dp[S];\n\tint ret = __builtin_popcount(S) - 1;\n\tfor (int T = (S - 1) & S, tmp; T; T = (T - 1) & S)\n\t\tif (!(xorv[T] || xorv[S ^ T]) && (tmp = dfs(T) + dfs(S ^ T)) < ret)\n\t\t\treturn dp[S] = tmp;\n\treturn dp[S] = ret;\n}\n\nint n, x, y, z, v[N], c[22], ans, msk;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\tx[v] ^= z, y[v] ^= z;\n\t}\n\tfor (int i = 1; i <= n; i++) i[v][c]++;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tans += i[c] / 2;\n\t\tmsk |= (i[c] & 1) << (i - 1);\n\t}\n\tfor (int i = 0; i < 32768; i++)\n\t\tfor (int j = 1; j <= 15; j++)\n\t\t\tif ((i >> (j - 1)) & 1) xorv[i] ^= j;\n\tprintf(\"%d\", ans + (msk ? dfs(msk) : 0));\n}"
  },
  {
    "language": "C++",
    "code": "/*\næ°æ®ä¸æ¸ç©ºï¼çé¶ä¸¤è¡æ³ªã\nå¤æµä¸è¯»å®ï¼çé¶ä¸¤è¡æ³ªã\nè¾¹çä¸ç¹å¤ï¼çé¶ä¸¤è¡æ³ªã\nè´ªå¿ä¸è¯æï¼çé¶ä¸¤è¡æ³ªã\nD P é¡ºåºéï¼çé¶ä¸¤è¡æ³ªã\nå¤§å°å°ç­å·ï¼çé¶ä¸¤è¡æ³ªã\nåéä¸ç»ä¸ï¼çé¶ä¸¤è¡æ³ªã\nè¶çä¸å¤æ­ï¼çé¶ä¸¤è¡æ³ªã\nè°è¯ä¸æ³¨éï¼çé¶ä¸¤è¡æ³ªã\næº¢åºä¸ l lï¼çé¶ä¸¤è¡æ³ªã\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nconst int inf=0x3f3f3f3f;\nint lowbit(int x){return x&-x;}\nint ppc(int x){return __builtin_popcount(x);}\nconst int N=100000;\nint n;\nvector<pair<int,int> > nei[N+1];\nint buc[16];\nint dfs(int x=1,int fa=0){\n\tint xsm=0;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i].X,v=nei[x][i].Y;\n\t\tif(y==fa)continue;\n\t\tint tmp=dfs(y,x)^v;\n\t\txsm^=tmp;\n\t\tbuc[tmp]++;\n\t}\n\treturn xsm;\n}\nint dp[1<<15];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tx++;y++;\n\t\tnei[x].pb(mp(y,z));nei[y].pb(mp(x,z));\n\t}\n\tdfs();\n\tfor(int i=1;i<1<<15;i++){\n\t\tif(lowbit(i)==i){dp[i]=1;continue;}\n\t\tint xsm=0;\n\t\tfor(int j=1;j<=15;j++)if(i&1<<j-1)xsm^=j;\n\t\tif(!xsm)dp[i]=ppc(i)-1;\n\t\tdp[i]=inf;\n\t\tfor(int j=i-1&i;j;j=j-1&i)dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tint ans=0,msk=0;\n\tfor(int i=1;i<=15;i++)ans+=buc[i]>>1,msk|=(buc[i]&1)<<i-1;\n\tcout<<ans+dp[msk];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\n#ifdef DEBUG\nstruct Timestamper {\n  string msg;\n  clock_t start;\n\n  Timestamper(const string &_msg) : msg(_msg), start(clock()) {}\n  ~Timestamper() {\n    eprintf(\"[ %s ] Time=%.3lfs\\n\", msg.c_str(), (clock() - start) * 1.0 / CLOCKS_PER_SEC);\n  }\n} __timestamper(\"end\");\n#else\nstruct Timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nconst int inf = 1e9;\n\nint solve(int msk) {\n  vi ts;\n  forn (i, 16) if (msk & (1 << i)) ts.pb(i);\n  int r = 0;\n  forn (x, 4) {\n    if (r >= sz(ts)) break;\n    for (int i = r; i < sz(ts); i++) \n      if (ts[i] & (1 << x)) {\n        swap(ts[r], ts[i]);\n        break;\n      }\n    if (!(ts[r] & (1 << x))) continue;\n    for (int i = r + 1; i < sz(ts); i++)\n      ts[i] ^= ts[r];\n    r++;\n  }\n  eprintf(\"r=%d\\n\", r);\n  return r;\n}\n\nvector<vector<pii>> es;\nvi cnts;\n\nvoid dfs(int v, int par = -1) {\n  int tails = 0;\n  for (pii e : es[v])\n    if (e.first == par) {\n      tails ^= e.second;\n    } else {\n      dfs(e.first, v);\n      tails ^= e.second;\n    }\n//  eprintf(\"v=%d, tails=%d\\n\", v, tails);\n  cnts[tails]++;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    es = vector<vector<pii>>(n);\n    forn (i, n - 1) {\n      int a, b, w;\n      scanf(\"%d%d%d\", &a, &b, &w);\n      es[a].eb(b, w);\n      es[b].eb(a, w);\n    }\n    cnts = vi(16, 0);\n    dfs(0);\n    cnts[0] = 0;\n//    eprintf(\"cnts:\\n\");\n//    forn (i, 16)\n//      eprintf(\"  [%d]=%d\\n\", i, cnts[i]);\n    int ans = 0;\n    int msk = 0;\n    forn (i, 16) {\n      ans += cnts[i] / 2;\n      if (cnts[i] & 1) {\n        msk |= 1 << i;\n      }\n    }\n    eprintf(\"preans=%d\\n\", ans);\n    ans += solve(msk);\n    printf(\"%d\\n\", ans);\n    eprintf(\"=====\\n\");\n    fflush(stdout);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt[100003],cntt[16],ans;\nint dp[65536];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){int x,y,a;cin>>x>>y>>a;cnt[x]^=a;cnt[y]^=a;}\n\tfor(int i=0;i<n;i++)cntt[cnt[i]]++;\n\tfor(int i=1;i<16;i++)ans+=cntt[i]/2,cntt[i]%=2;\n\tint tmp=0;for(int i=1;i<16;i++)tmp=tmp+cntt[i]*(1<<i);\n\tmemset(dp,31,sizeof(dp));\n\tdp[tmp]=0; \n\tfor(int i=tmp;i>0;i-=2)\n\t\tif(dp[i]<20000000)\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tfor(int k=j+1;k<16;k++)\n\t\t\t\t\tif((i|(1<<j))==i&&(i|(1<<k))==i)\n\t\t\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t\t\t\tif(((j|k)|l)==(j|k))\n\t\t\t\t\t\t\t\tdp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]=min(dp[i]+1+bool((i&(1<<(j^l)))!=0)+\n\t\t\t\t\t\t\t\tbool((i&(1<<(k^l)))!=0),dp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]);\n\tcout<<ans+dp[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nint N;\nmap<int, vector<pint>> edges;\n\nvector<int> xors;\n\nint next_combination(int comb)\n{\n    int x = comb & -comb, y = comb + x;\n    return ((comb & ~y) / x >> 1) | y;\n}\n\nconstexpr int D = 15;\n\nint main()\n{\n    cin >> N;\n    REP(i, N - 1)\n    {\n        int x, y, a;\n        cin >> x >> y >> a;\n        edges[x].emplace_back(y, a);\n        edges[y].emplace_back(x, a);\n    }\n    xors.resize(N);\n    REP(i, N) for (auto e : edges[i]) xors[i] ^= e.second;\n\n    vector<int> cou(D);\n    for (auto v : xors) if (v) cou[v - 1]++;\n\n    vector<int> dp(POW2(D), 100);\n    dp[0] = 0;\n\n    FOR(npop, 3, D + 1)\n    {\n        int S = POW2(npop) - 1;\n        while (S < POW2(D))\n        {\n            int d1 = __builtin_ffs(S);\n            REP(d, D) if (S & POW2(d))\n            {\n                mmin(dp[S], dp[S xor POW2(d)] + 1);\n                if (d != d1)\n                {\n                    int new_a = ((d + 1) xor (d1 + 1)) - 1;\n                    if (S & POW2(new_a)) mmin(dp[S], dp[S xor POW2(d) xor POW2(d1) xor POW2(new_a)] + 2);\n                    else mmin(dp[S], dp[S xor POW2(d) xor POW2(d1) xor POW2(new_a)] + 1);\n                }\n            }\n            S = next_combination(S);\n        }\n    }\n    int ans = 0;\n    int S = 0;\n    REP(i, D)\n    {\n        ans += cou[i] / 2;\n        S += POW2(i) * (cou[i] % 2);\n    }\n    cout << ans + dp[S] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define ll long long\n#define ull  unsigned long long\n#define pb push_back\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 200000;\nint a[N], cnt[N], d[N];\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\",\"w\", stdout);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v, x;\n        cin >> u >> v >> x;\n        a[u] ^= x;\n        a[v] ^= x;\n    }\n    for (int i = 0; i < n; i++){\n        cnt[a[i]]++;\n    }\n    int ans = 0;\n    int s = 0;\n    for (int i = 1; i < 16; i++){\n        ans += cnt[i] / 2;\n        if (cnt[i] % 2) s |= (1 << i);\n    }\n    for (int i = 0; i < (1 << 16); i++) d[i] = 1e9;\n    d[s] = 0;\n    queue < int > q;\n    q.push(s);\n    while(!q.empty()){\n        int mask = q.front();\n        q.pop();\n        for (int i = 1; i < 16; i++){\n            if (mask & (1 << i))\n            for (int j = i + 1; j < 16; j++){\n                if (mask & (1 << j))\n                for (int l = 0; l < 16; l++){\n                    int x = (i ^ l);\n                    int y = (j ^ l);\n                    int c = 1;\n                    int newmask = mask;\n                    newmask ^= (1 << i);\n                    newmask ^= (1 << j);\n                    if (newmask & (1 << x) && x != 0) c++;\n                    if (newmask & (1 << y) && y != 0) c++;\n                    newmask ^= (1 << x);\n                    newmask ^= (1 << y);\n                    if (d[newmask] > d[mask] + c){\n                        d[newmask] = d[mask] + c;\n                        q.push(newmask);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans + min(d[0], d[1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct edge{\n\tint to,nxt,dis;\n}e[200101];\nint head[101010],tot,n;\ninline void made(int from,int to,ll dis){\n\te[++tot].to=to;e[tot].nxt=head[from];head[from]=tot;\n\te[tot].dis=dis;\n}\nint a[101010],b[100],f[201010],g[202020];\nvoid dfs(int u,int faa){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==faa) continue; \n\t\ta[v]=e[i].dis;\n\t\tdfs(v,u);\n\t\ta[u]^=a[v];\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tmade(x+1,y+1,z),made(y+1,x+1,z);\n\t}\n\tdfs(1,0);\n\tint all=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]) b[a[i]-1]^=1,all^=(1<<(a[i]-1));\n\t}\n\tfor (int zt=1;zt<=all;zt++){\n\t\tbool flag=0;\n\t\tfor (int i=0;i<15;i++){\n\t\t\tif (((1<<i)&zt)&&(!b[i])){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t\telse if ((1<<i)&zt) g[zt]^=i+1;\n\t\t}\n\t\tif (!flag){\n\t\t\tf[zt]=__builtin_popcount(zt)-1;\n\t\t\tfor (int i=zt&(zt-1);i;i=zt&(i-1)){\n\t\t\t\tif (g[zt^i]|g[i]){\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[all];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n \nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n \n \nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\ndouble bp[(1 << A) + 5];\nint get(int x, int y) {\n\treturn (x >> y) & 1;\n}\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n \n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}*/\n\tfor (int mask = 0; mask < 1 << A; mask++) {\n\t\tbp[mask] = __builtin_popcount(mask);\n\t}\n\tfor (int k = 0; k < A; k++) {\n\t\tfor (int mask = 0; mask < 1 << A; mask++) {\n\t\t\tfor (int i = 0; i < A; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tint mask2 = mask;\n\t\t\t\t\tint x = 0;\n\t\t\t\t\tdouble y = 0;\n\t\t\t\t\tif (get(mask, i)) {\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (get(mask, j)) {\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (get(mask, ((i + 1) ^ (j + 1)) - 1)) {\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (x == 3) {\n\t\t\t\t\t\ty = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ty = 1.5;\n\t\t\t\t\t}\n\t\t\t\t\tmask2 ^= 1 << i;\n\t\t\t\t\tmask2 ^= 1 << j;\n\t\t\t\t\tmask2 ^= 1 << (((i + 1) ^ (j + 1)) - 1);\n\t\t\t\t//\tif (mask == 19) {\n\t\t\t\t//\t\tcout << \"48 \" << mask << \" \" << mask2 << \" \" << i << \" \" << j << \" \" << bp[mask2] << endl;\n\t\t\t\t//\t}\n\t\t\t\t\tbp[mask] = min(bp[mask], bp[mask2] + y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int mask = 0; mask < 1 << A; mask++) {\n//\t\t\n//\t\tcout << mask << \" \" << bp[mask] << endl;\n//\t}\n\tint mask = 0;\n\tfor (int i = 1; i <= A; i++) {\n\t\tif (dp[1][i]) {\n\t\t\tmask += 1 << (i - 1);\n\t\t}\n\t}\n\tcout << ans + int(ceil(bp[mask])) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 2e5 + 5; \nint N, val[MAX_N], f[MAX_N]; \nint ans, S, cnt[20], sum[MAX_N]; \nint main () { \n\tN = gi(); \n\tfor (int i = 1; i < N; i++) {\n\t\tint u = gi(), v = gi(), w = gi(); \n\t\tval[u] ^= w, val[v] ^= w; \n\t} \n\tfor (int i = 0; i < N; i++) ++cnt[val[i]]; \n    for (int i = 1; i <= 15; i++) ans += (cnt[i] >> 1), S |= (cnt[i] & 1) << (i - 1); \n\tfor (int i = 1; i < (1 << 15); i++) f[i] = f[i >> 1] + (i & 1); \n\tfor (int i = 1; i < (1 << 15); i++) --f[i]; \n\tfor (int i = 1; i < (1 << 15); i++) \n\t\tfor (int j = 0; j < 15; j++) if ((i >> j) & 1) sum[i] ^= (j + 1); \n\tfor (int i = 1; i < (1 << 15); i++) \n\t    for (int j = (i - 1) & i; j; j = (j - 1) & i) \n\t\t\tif (!sum[j]) f[i] = min(f[i], f[j] + f[i ^ j]); \n\tprintf(\"%d\\n\", f[S] + ans); \n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\n\nvector<pair<int, int>> E[MAX];\n\nint a[MAX];\n\nvoid Dfs(int x, int prev, int dad) {\n  a[x] = prev;\n  for (auto& p: E[x]) {\n    int y = p.first;\n    int w = p.second;\n    if (y != dad) {\n      Dfs(y, w, x);\n      a[x] ^= a[y];\n    }\n  }\n}\n\nconst int MAXB = 1<<16;\n\nint f[MAXB];\n\nint Solve(int mask) {\n  if (f[mask] != -1) return f[mask];\n  if (mask == 0) return f[mask] = 0;\n\n  f[mask] = 100000;\n  REP(x, 16) {\n    if (mask & (1<<x)) {\n      f[mask] = min(f[mask], Solve(mask ^ (1<<x)) + 1);\n      REP(y, 16) {\n        if (x != y && (mask & (1<<y))) {\n          int nmask = mask ^ (1<<x) ^ (1<<y);\n          int cost = 1;\n          int z = x ^ y;\n          if (nmask & (1<<z)) cost++;\n          nmask ^= 1<<z;\n          f[mask] = min(f[mask], cost + Solve(nmask));\n        }\n      }\n    }\n  }\n\n  return f[mask];\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N-1) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    E[a].push_back({b, c});\n    E[b].push_back({a, c});\n  }\n\n  Dfs(0, 0, -1);\n\n  int mask = 0;\n  int ret = 0;\n  FOR(i, 1, N) {\n    if (a[i] == 0) continue;\n    if (mask & (1<<a[i])) {\n      ret++;\n    }\n    mask ^= 1 << a[i];\n  }\n\n  queue<int> Q[16];\n  vector<int> dist(1<<16, 1000000000);\n\n  dist[mask] = 0;\n  Q[0].push(mask);\n\n  REP(i, 16) {\n    while (!Q[i].empty()) {\n      int mask = Q[i].front();\n      Q[i].pop();\n      if (i != dist[mask]) continue;\n\n      REP(x, 16) {\n        if (mask & (1<<x)) {\n          if (i + 1 < 16) {\n            int nmask = mask ^ (1 << x);\n            if (i + 1 < dist[nmask]) {\n              dist[nmask] = i + 1;\n              Q[i + 1].push(nmask);\n            }\n          }\n\n\n          REP(y, x) {\n            if ((mask & (1<<y))) {\n              REP(z, 16) {\n                int nmask = mask, cost = i;\n\n                nmask ^= 1 << x;\n                nmask ^= 1 << y;\n                cost++;\n\n                if (x != z) {\n                  if (nmask & (1 << (x^z))) cost++;\n                  nmask ^= 1 << (x^z);\n                }\n\n                if (y != z) {\n                  if (nmask & (1 << (y^z))) cost++;\n                  nmask ^= 1 << (y^z);\n                }\n                if (cost < 16 && cost < dist[nmask]) {\n                  dist[nmask] = cost;\n                  Q[cost].push(nmask);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  ret += dist[0];\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define b(x) ((x)==0?0:(1<<((x)-1)))\n#define lb(x) ((x)&(-(x)))\nconst int nMaxn = 100005, nMaxs = 114514;\nint N, nXorperp[nMaxn] = {0}, bRec[nMaxs];\nint bCalcable[nMaxs], bExibits[nMaxs];\nint nStstat = 0, bOutsteps = 0;\n\nint dfs(int vCur) {\n    if (bRec[vCur] != -1) return bRec[vCur];\n    int& vRes = bRec[vCur];\n    vRes = bExibits[vCur]-1;\n    \n    int bPos = lb(vCur);\n    for (int vSpl=(vCur-1)&vCur; vSpl; vSpl=(vSpl-1)&vCur) {\n        if ((vSpl&bPos)&&bCalcable[vSpl]&&bCalcable[vCur^vSpl]) {\n            vRes = min(vRes, dfs(vSpl)+dfs(vCur^vSpl));\n        }\n    }\n    \n    return vRes;\n}\n\ninline void check(int vStat) {\n    int bCov = 0, bBit = 0;\n    int vCopied = vStat;\n    while (vCopied) {\n        ++bBit;\n        if (vCopied&1) ++bExibits[vStat], bCov^=bBit;\n        vCopied >>= 1;\n    }\n    bCalcable[vStat] = bCov==0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N;\n    int u, v, w;\n    for (int i=1; i<N; ++i) \n        cin >> u >> v >> w,\n        nXorperp[u] ^= w,\n        nXorperp[v] ^= w;\n    for (int i=0; i<N; ++i)\n        nStstat ^= b(nXorperp[i]),\n        bOutsteps += nXorperp[i]&&!(nStstat&b(nXorperp[i]));\n    for (int i=0; i<nMaxs; ++i) \n        bRec[i] = -1,\n        check(i);\n    cout << max(0, dfs(nStstat)+bOutsteps) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    a[x] ^= z;\n    a[y] ^= z;\n  }\n  vector<int> cnt(16);\n  for (int i = 0; i < n; i++) {\n    ++cnt[a[i]];\n  }\n  int res = 0;\n  int have = 0;\n  for (int i = 1; i < 16; i++) {\n    res += cnt[i] / 2;\n    cnt[i] &= 1;\n    have |= (cnt[i] << i);\n  }\n  vector<int> dp(have + 1);\n  for (int mask = 2; mask <= have; mask++) {\n    dp[mask] = n;\n    for (int i = 0; i < 16; i++) {\n      for (int j = i + 1; j < 16; j++) {\n        int go = mask ^ (1 << i) ^ (1 << j);\n        bool ext = (go >> (i ^ j)) & 1;\n        go ^= (1 << (i ^ j));\n        if (go < mask) {\n          dp[mask] = min(dp[mask], dp[go] + 1 + ext);\n        }\n      }\n    }\n  }\n  cout << res + dp[have] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define LL long long\n#define INF 0x3f3f3f3f\n#define Inf 1000000000000000000LL\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\nusing namespace std;\nint n,s[233333],S,ans,f[66666],inf,sum[20];\nint dfs(int S){\n\tif(!S)return 0;\n\tif(f[S]<inf)return f[S];\n\tfor(int i=0;i<16;i++)if((S>>i)&1)\n\t\tfor(int j=0;j<16;j++)if(i!=j&&(S>>j)&1){\n\t\t\tint p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n\t\t\tif(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n\t\t\telse f[S]=min(f[S],dfs(x)+1);\n\t\t}\n\treturn f[S];\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1,a,b,c;i<n;i++){\n\t\tcin>>a>>b>>c;\n\t\ts[a]^=c,s[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)sum[s[i]]++;\n\tfor(int i=1;i<16;i++){\n\t\tans+=(sum[i]>>1);\n\t\tS+=(1<<i)*(sum[i]&1);\n\t}\n\tmemset(f,127,sizeof f);\n\tinf=f[0];\n\tans+=dfs(S);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define N_ 101000\nvector<int>E[N_], L[N_], Ch[N_];\nint D[N_][20], S[20], T[20];\nint n;\nvoid DFS(int a, int pp) {\n\tint i, j, x, k;\n\tfor (i = 0; i < E[a].size(); i++) {\n\t\tx = E[a][i];\n\t\tif (x == pp)continue;\n\t\tDFS(x, a);\n\t\tCh[a].push_back(x);\n\t}\n\tif (Ch[a].empty()) {\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++)D[a][i] = 1;\n\t\tD[a][0] = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 16; i++)S[i] = 0;\n\tfor (i = 0; i < E[a].size(); i++) {\n\t\tx = E[a][i];\n\t\tif (x == pp)continue;\n\t\tfor (j = 0; j < 16; j++)T[j] = 1e9;\n\t\tint d = L[a][i];\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tT[j^d] = min(S[j] + D[x][d], T[j^d]);\n\t\t}\n\t\tfor (j = 0; j < 16; j++)S[j] = T[j];\n\t}\n\tint Mn = 1e9;\n\tfor (j = 0; j < 16; j++)Mn = min(Mn, S[j]);\n\tfor (j = 0; j < 16; j++)D[a][j] = min(S[j], Mn + 1);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta++, b++;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t\tL[a].push_back(c);\n\t\tL[b].push_back(c);\n\t}\n\tDFS(1, 0);\n\tprintf(\"%d\\n\", D[1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 5, M = 16, inf = 1e9;\nint a[N], cnt[M], p[M], dp[1<<M], Xor[1<<M];\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, x; cin >> u >> v >> x;\n        a[u] ^= x, a[v] ^= x;\n    }\n    for (int i = 0; i < n; i++) cnt[a[i]]++;\n    int res = cnt[0], m = 0;\n    for (int i = 1; i < M; i++) {\n        res += (cnt[i]>>1);\n        if (cnt[i]&1) p[m++] = i;\n    }\n    fill(dp + 1, dp + M, -inf);\n    for (int mask = 1; mask < (1<<m); mask++) {\n        Xor[mask] = p[__builtin_ctz(mask)] ^ Xor[mask^(mask&(-mask))];\n        for (int sub = mask; sub; sub = (sub - 1)&mask) if (Xor[sub] == 0)\n            dp[mask] = max(dp[mask], dp[mask^sub] + 1);\n    }\n    cout << n - res - dp[(1<<m) - 1] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<16];\nint main()\n{\n\tmemset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot+=(1<<i);\n\tf[0]=0;\n\tfor(int s=1;s<=tot;s++){\n\t\tfor(int i=1;i<=15;i++)if(s>>i&1){\n\t\t\tfor(int j=1;j<=15;j++)if((s>>j&1) && (i!=j)){\n\t\t\t\tif(!(i^j)&s)f[s]=min(f[s],f[s-(1<<i)+(1<<(i^j))]+1);\n\t\t\t\telse{\n\t\t\t\t\tf[s]=min(f[s],f[s-(1<<i)-(1<<j)-(1<<i^j)]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "/*     !ya khoda!     */\n#include <bits/stdc++.h>\n\n#define ll long long\n#define ld long double\n\n#define pp push\n#define po pop()\n#define pb push_back\n#define pf push_front\n#define pob pop_back()\n#define pof pop_front()\n#define I insert\n#define E erase\n\n#define F first\n#define S second\n\n#define mkp make_pair\n#define pll pair<ll,ll>\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define all(a) a.begin(),a.end()\n\n#define coutghat(x)      cout<<tolower(x);\n#define coutashar(x,d)   cout<<fixed<<setprecision(x)<<(ld)d\n#define IOS ios_base::sync_with_stdio(false) , cin.tie(0);\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n//#define poow(a,b,M)   b?(poow((a*a)%M,b/2)%M * (b&1?a))%M:1 ;\n/*==========================================================================*/\nusing namespace std;\nll poow(ll x,ll n,ll Mod=1e9+7) { return (n==0?1:poow(x*x%Mod,n/2)*(n&1?x:1)%Mod); }\n//#pragma optimize O3\n// 107,109, 211,223, 307, 401,409, 503,509, 601,607, 701,709, 809, 907, 1009\n/*==========================================================================*/\nconst int N=2e5+10  , M=1e4+10  , SQ=320 , LG=23 , base=2;\nconst int mod=1e9+7 , MOD=1e9+9;\nconst ll  INF=1e9   , inf=1e18 , super_inf=~0ull/4;\nll n,m,a[N]  ,  cnt[16]  ,  dp[1<<16],val[1<<16]  ,  x,k;\nvector<ll>vec;\n/*==========================================================================*/\nint main()\n{\n    IOS;\n    cin>>n;\n\tfor(int i=1;i<n;i++)\n\t{   ll v,u,w;\n        cin>>v>>u>>w;\n\t\ta[v]^=w  ,  a[u]^=w;\n\t}\n\tfor(int i=0;i<n;i++)   cnt[a[i]]++;\n\n\n\tx=cnt[0]  ,  cnt[0]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cnt[a[i]]%2)   vec.pb(a[i]);\n\t\tx+=cnt[a[i]]/2;\n\t\tcnt[a[i]]=0;\n\t}\n\n\tm=vec.size() , k=(1<<m);\n\tfor(int i=0;i<k;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(i>>j&1)\n\t\t\t\tval[i]^=vec[j];\n\n\tfor(int i=1;i<k;i++)\n\t{   dp[i]=1;\n\t\tif(val[i]!=0)   continue;\n\t\tfor(int j=i;j>0;j=(j-1)&i)\n\t\t\tif(!val[j])\n\t\t\t\tdp[i]=max(dp[i],dp[j]+dp[i^j]);\n\t}\n\n\tcout<<n-(dp[k-1]+x);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int maxN = 1e5 + 10;\nint nodeN, tot;\nint val[maxN], cntHas[maxN], dp[1 << 16], num[20], xorSum[1 << 16];\n\nint main () {\n\tscanf(\"%d\", &nodeN);\n\tfor (int nodeI = 1; nodeI < nodeN; ++nodeI) {\n\t\tint n1, n2, len;\n\t\tscanf(\"%d%d%d\", &n1, &n2, &len);\n\t\t++n1, ++n2;\n\t\tval[n1] ^= len;\n\t\tval[n2] ^= len;\n\t}\n\tfor (int nodeI = 1; nodeI <= nodeN; ++nodeI) ++cntHas[val[nodeI]];\n\tint ans = 0;\n\tfor (int valI = 1; valI < 16; ++valI) {\n\t\tans += cntHas[valI] >> 1;\n\t\tcntHas[valI] &= 1;\n\t\tif (cntHas[valI] != 0) {\n\t\t\tnum[++tot] = valI;\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\txorSum[stI] ^= num[weiJ + 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] > 0) {\n\t\t\tdp[stI] = 0x3f3f3f3f;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\t++dp[stI];\n\t\t\t}\n\t\t}\n\t\t--dp[stI];\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (dp[stI] != 0) continue;\n\t\tfor (int son = stI & (stI - 1); son; son = stI & (son - 1)) {\n\t\t\tif (xorSum[son] == 0) {\n\t\t\t\tdp[stI] = min(dp[stI], dp[stI ^ son] + dp[son]);\n\t\t\t}\n\t\t}\n\t}\n\tans += dp[(1 << tot) - 1];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 10000000;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 1<<17;\n\nvector<pii> T[MX];\nint state[MX], val[MX];\nint N, ans = 0;\n\nvoid dfs(int x, int p = -1){\n\tstate[x] = 0;\n\tfor(pii e : T[x]){\n\t\tint c = e.second, d = e.first;\n\t\tif( c == p ) continue;\n\t\tdfs(c, x);\n\n\t\tfor(int i = 1; i < 16; i++) if( state[c]&1<<i ) d ^= i;\n\t\tif( d && state[c]&1<<d ) ans++;\n\t\tstate[c] ^= 1<<d;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif( state[c]&1<<i && state[x]&1<<i ){\n\t\t\t\tstate[x] ^= 1<<i;\n\t\t\t\tstate[c] ^= 1<<i;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tstate[x] |= state[c];\n\t}\n}\n\nint chk(int x){\n\tint c = 0, v = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tif( x&1<<i-1 ) v ^= i, c++;\n\t}\n\tif( c == 1 ) return 1;\n\tif( v ) return -1;\n\treturn c-1;\n}\n\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tT[a].emplace_back(c, b);\n\t\tT[b].emplace_back(c, a);\n\t}\n\tfor(int i = 1; i < 1<<15; i++){\n\t\tval[i] = 1e9;\n\t\tfor(int j = i; j; j = (j-1)&i){\n\t\t\tint v = chk(j);\n\t\t\tif( v != -1 ) val[i] = min(val[i], val[i^j] + v);\n\t\t}\n\t}\n\tfor(int i = 0; i < 1; i++){\n\t\tans = 0;\n\t\tdfs(i);\n\t\tprintf(\"%d\\n\", val[state[i]/2] + ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=100005;\nint val[N],cnt[N],sxr[1<<17];\nint a[17];\nint dp[1<<17];\ninline int read(){\n\tint x=0;char e=getchar();\n\tfor (;e<'0'||e>'9';e=getchar());\n\tfor (;e>='0'&&e<='9';e=getchar()) x=(x<<1)+(x<<3)+(e^48);\n\treturn x;\n}\ninline int Min(int a,int b){\n\treturn a<b?a:b;\n}\nint main (){\n\tint n=read();\n\tfor (int i=1;i<n;i++){\n\t\tint u=read()+1,v=read()+1,w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tint ans=0,to=0;\n\tfor (int i=1;i<16;i++){\n\t\tans+=(cnt[i]>>1);\n\t\tif (cnt[i]&1) to|=(1<<i);\n\t}\n\tfor (int i=0;i<(1<<16);i++)\n\t\tfor (int j=0;j<16;j++)\n\t\t\tif (i&(1<<j)) sxr[i]^=j;\n\tfor(int i=0;i<(1<<16);i++) dp[i]=dp[i>>1]+(i&1);\n    for(int i=0;i<(1<<16);i++) dp[i]--;\n\tfor (int i=0;i<(1<<16);i++){\n        if (sxr[i]) continue;\n        for (int k=(i-1)&i;k;k=(k-1)&i)\n            if (!sxr[k]) dp[i]=Min(dp[i],dp[k]+dp[i^k]);\n\t}\n\tprintf (\"%d\",dp[to]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+1);\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+1);\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<20;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+1);\n            dp[n][i]=min(dp[n][i],temp[i]+1);\n            \n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//It is made by M_sea\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=200000+10;\n\nint w[N],cnt[20],f[1<<16],sxor[1<<16];\n\nint main() {\n    int n=read();\n    for (re int i=1;i<n;++i) {\n        int u=read()+1,v=read()+1,val=read();\n        w[u]^=val,w[v]^=val;\n    }\n    for (re int i=1;i<=n;++i) ++cnt[w[i]];\n    int ans=0,s=0;\n    for (re int i=1;i<=15;++i) ans+=cnt[i]/2,s|=(cnt[i]&1)<<(i-1);\n    for (re int i=1;i<(1<<15);++i) f[i]=f[i>>1]+(i&1);\n    for (re int i=1;i<(1<<15);++i) --f[i];\n    for (re int i=1;i<(1<<15);++i)\n        for (re int j=1;j<=15;++j)\n            if (i&(1<<(j-1))) sxor[i]^=j;\n    for (re int i=1;i<(1<<15);++i) {\n        if (sxor[i]) continue;\n        for (re int j=i&(i-1);j;j=(j-1)&i)\n            if (!sxor[j]) f[i]=min(f[i],f[j]+f[i^j]);\n    }\n    printf(\"%d\\n\",ans+f[s]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nint solve(int n, const vector<int> & x, const vector<int> & y, const vector<int> & a) {\n    constexpr int MAX_A = 0xf;\n    assert (*max_element(ALL(a)) <= MAX_A);\n\n    // make the adjacent list\n    vector<vector<int> > g(n);\n    REP (i, n - 1) {\n        g[x[i]].push_back(y[i]);\n        g[y[i]].push_back(x[i]);\n    }\n\n    // fix a root\n    vector<int> parent(n, -1);\n    function<void (int)> go = [&](int i) {\n        for (int j : g[i]) if (j != parent[i]) {\n            parent[j] = i;\n            go(j);\n        }\n    };\n    constexpr int root = 0;\n    go(root);\n\n    // move labels to nodes\n    vector<int> b(n, -1);\n    REP (i, n - 1) {\n        if (parent[x[i]] == y[i]) {\n            b[x[i]] = a[i];\n        } else if (x[i] == parent[y[i]]) {\n            b[y[i]] = a[i];\n        } else {\n            assert (false);\n        }\n    }\n\n    // tree dp\n    int removed = 0;\n    function<array<bool, MAX_A + 1> (int)> dp = [&](int i) {\n        array<bool, MAX_A + 1> cnt1 = {};\n        int k = b[i];\n        for (int j : g[i]) if (j != parent[i]) {\n            array<bool, MAX_A + 1> cnt2 = dp(j);\n            REP (i, MAX_A + 1) if (cnt2[i]) {\n                if (k != -1) {\n                    k ^= i;\n                }\n                removed += cnt1[i];\n                cnt1[i] ^= 1;\n            }\n        }\n        if (k >= 1) {\n            removed += cnt1[k];\n            cnt1[k] ^= 1;\n        }\n        return cnt1;\n    };\n    array<bool, MAX_A + 1> cnt = dp(root);\n\n    // finialize\n    REP_R (i, MAX_A + 1) if (cnt[i]) {\n        REP_R (j, i) if (cnt[j]) {\n            if (cnt[i ^ j]) {\n                cnt[i] ^= 1;\n                cnt[j] ^= 1;\n                cnt[i ^ j] ^= 1;\n                removed += 2;\n                break;\n            }\n        }\n    }\n    return removed + accumulate(ALL(cnt), 0);\n}\n\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> x(n - 1), y(n - 1), a(n - 1);\n    REP (i, n - 1) {\n        cin >> x[i] >> y[i] >> a[i];\n    }\n\n    // solve\n    int answer = solve(n, x, y, a);\n\n    // output\n    cout << answer << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n};\nstruct state {\n\tint bit, cost;\n};\nbool operator>(const state& s1, const state& s2) {\n\treturn s1.cost > s2.cost;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(edge{ y, a });\n\t\tG[y].push_back(edge{ x, a });\n\t}\n\tvector<int> seq = { 0 };\n\tfunction<void(int, int)> make_seq = [&](int pos, int pre) {\n\t\tfor (edge e : G[pos]) {\n\t\t\tif (e.to != pre) {\n\t\t\t\tseq.push_back(e.cost);\n\t\t\t\tmake_seq(e.to, pos);\n\t\t\t\tseq.push_back(e.cost);\n\t\t\t}\n\t\t}\n\t};\n\tmake_seq(0, -1);\n\tseq.push_back(0);\n\tint bit = 0, off = 0;\n\tfor (int i = 1; i < seq.size(); ++i) {\n\t\tint d = seq[i] ^ seq[i - 1];\n\t\tif (d != 0 && ((bit >> d) & 1)) ++off;\n\t\tbit ^= 1 << d;\n\t}\n\tpriority_queue<state, vector<state>, greater<state> > que; que.push(state{ bit, 0 });\n\tvector<int> d(1 << 15, -1); d[bit / 2] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.top().bit; que.pop();\n\t\tfor (int i = 1; i < 16; ++i) {\n\t\t\tfor (int j = 1; j < 16; ++j) {\n\t\t\t\tif (!((u >> j) & 1)) continue;\n\t\t\t\tfor (int k = 1; k < j; ++k) {\n\t\t\t\t\tif (!((u >> k) & 1)) continue;\n\t\t\t\t\tint delta = 1;\n\t\t\t\t\tint nxtbit = u - (1 << j) - (1 << k);\n\t\t\t\t\tif ((nxtbit >> (j ^ i)) & 1) ++delta; nxtbit ^= 1 << (j ^ i);\n\t\t\t\t\tif ((nxtbit >> (k ^ i)) & 1) ++delta; nxtbit ^= 1 << (k ^ i);\n\t\t\t\t\tif (nxtbit & 1) nxtbit -= 1;\n\t\t\t\t\tif (d[nxtbit / 2] == -1 || d[nxtbit / 2] > d[u / 2] + delta) {\n\t\t\t\t\t\td[nxtbit / 2] = d[u / 2] + delta;\n\t\t\t\t\t\tque.push(state{ nxtbit, d[nxtbit / 2] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << d[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans;\nint dp(int s)\n{\n\tif(!s)\n\t\treturn 0;\n\tif(f[s])\n\t\treturn f[s];\n\tf[s]=INF;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tif(!(s&(1<<i)))\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=15;j++)\n\t\t{\n\t\t\tif(i==j||!(s&(1<<j)))\n\t\t\t\tcontinue;\n\t\t\tint k=i^j;\n\t\t\tint t=s^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif(s&(1<<k))\n\t\t\t\tf[s]=min(f[s],dp(t)+2);\n\t\t\telse\n\t\t\t\tf[s]=min(f[s],dp(t)+1);\n\t\t}\n\t}\n\treturn f[s];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=((book[i]&1)<<i);//å¥æ°æåå©ä¸\n\t}\n\tprintf(\"%d\",ans+dp(s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\nconst int MaxN=2e5+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[20], d[MaxN];\nbool xr[MaxN];\nint main()\n{\n    int n, ans=0, state=0; read(n);\n    for  (int i=1,u,v,va; i<n; ++i)  read(x, y, z), v[x]^=z, v[y]^=z;\n    for (int i=0; i< n; ++i) ++cnt[v[i]]; //è´ªå¿\n    for (int i=1; i<=15; ++i) ans+=cnt[i]/2, state|=(cnt[i]&1)<<(i-1);\n\n    for (int i=1; i< (1<<15) ++i) d[i]=d[i>>1]+(i&1);\n    for (int i=1; i< (1<<15) ++i) --d[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n    for (int i=1; i< (1<<15) ++i)\n        for (int j=0; j< 15; ++j)\n\t\t\tif((i>>j)&1)sxr[i]^=(j+1);//é¢å¤çéåçå¼æå\n\n    for (int i=1; i< (1<<15) ++i)//æä¸¾å­éè¿è¡è½¬ç§»\n    {\n        if (xr[i]!=0)continue;\n        for (int k=(i-1)&i; k; k=(k-1)&i)\n            if (xr[k]==0) chkMin(d[i], d[k]+d[i^k]);\n    }\n    write(ans+f[state], '\\n');\n    IO::flush();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, ans, a[N], cnt[M];\n\nbool ok(int mask) {\n\tint res = 0;\n\tfor (int i = 0; i < M; i++)\n\t\tif (mask & (1 << i))\n\t\t\tres ^= i;\n\treturn res == 0;\n}\nvoid solve(int mask) {\n\tif (__builtin_popcount(mask) <= 1)\n\t\treturn;\n\tfor (int sub = mask; sub; sub = (--sub & mask))\n\t\tif (sub < mask && ok(sub)) {\n\t\t\tsolve(sub);\n\t\t\tsolve(mask ^ sub);\n\t\t\treturn;\n\t\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tfor (int i = 1; i < M; i++) {\n\t\tans += (cnt[i] >> 1);\n\t\tcnt[i] &= 1;\n\t}\n\tint mask = 0;\n\tfor (int i = 1; i < M; i++)\n\t\tif (cnt[i])\n\t\t\tmask |= 1 << i;\n\tans += max(0, __builtin_popcount(mask) - 1);\n\tsolve(mask);\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\n\nint n, ans = 0, state = 0;\nint a[MAXN], sum[MAXN], cnt[MAXN], f[MAXN];\n\nint main()\n{\n    scanf(\"%d\", &n);\n    int u, v, w;\n    for(int i = 1; i < n; i++) {\n        scanf(\"%d%d%d\", &u, &v, &w);\n        a[u] ^= w, a[v] ^= w;\n    }\n    for (int i = 0; i < n; i++) ++cnt[a[i]];\n    for (int i = 1; i <= 15; i++) ans += (cnt[i] >> 1), state |= ((cnt[i] & 1) << (i - 1));\n    int sta_max = (1 << 15) - 1;\n    for (int sta = 1; sta <= sta_max; sta++) f[sta] = f[sta & (sta - 1)] + 1;\n    for (int sta = 1; sta <= sta_max; sta++) --f[sta];\n    for (int sta = 1; sta <= sta_max; sta++)\n        for (int i = 1; i <= 15; i++)\n            if((sta >> (i - 1)) & 1) sum[sta] ^= i;\n    for (int sta = 1; sta <= sta_max; sta++) {\n        if(sum[sta]) continue;\n        for (int i = (sta & (sta - 1)); i; i = ((i - 1) & sta))\n            if (!sum[i]) f[sta] = min(f[sta], f[i] + f[sta ^ i]);\n    }\n    printf(\"%d\\n\", ans + f[state]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e5 + 10;\n\nint n;\nint p[MAXN];\nint mask[MAXN];\nint cnt[MAXN][16];\nvector <pair <int, int>> adj[MAXN];\n\nvoid dfs(int u, int parent) {\n    p[u] = parent;\n    for (auto v : adj[u]) {\n        if (v.first != parent)\n            dfs(v.first, u);\n        else\n            mask[u] = v.second;\n    }\n}\n\nvoid calc(int u) {\n    int val = 0;\n    for (auto v : adj[u]) {\n        if (v.first == p[u])\n            continue;\n        calc(v.first);\n        val ^= v.second;\n        for (int i = 1; i < 16; i++)\n            cnt[u][i] += cnt[v.first][i];\n    }\n    cnt[u][mask[u] ^ val]++;\n\n    /*\n    cout << u << \":\";\n    for (int i = 1; i < 16; i++)\n        cout << \" \" << cnt[u][i];\n    cout << endl;\n    */\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, a;\n        cin >> u >> v >> a;\n        adj[u].push_back({v, a});\n        adj[v].push_back({u, a});\n    }\n\n    int root = 0;\n    while (root < n && adj[root].size() > 1)\n        root++;\n    dfs(root, -1);\n    calc(root);\n    // cout << \"r: \" << root << endl;\n\n    int total = 0;\n    // matched\n    for (int i = 1; i < 16; i++) {\n        // cout << i << \": \" << cnt[root][i] << endl;\n        total += cnt[root][i] / 2;\n        cnt[root][i] %= 2;\n    }\n\n    // merge\n    for (int i = 1; i < 16; i++)\n        for (int j = i + 1; j < 16; j++)\n            if (cnt[root][i] > 0 && cnt[root][j] > 0\n                    && cnt[root][i ^ j] > 0) {\n                total += 2;\n                cnt[root][i]--;\n                cnt[root][j]--;\n                cnt[root][i ^ j]--;\n            }\n    for (int i = 1; i < 16; i++)\n        for (int j = i + 1; j < 16; j++)\n            for (int k = j + 1; k < 16; k++)\n                if (cnt[root][i] > 0 && cnt[root][j] > 0 && cnt[root][k] > 0\n                        && cnt[root][i ^ j ^ k] > 0) {\n                    total += 3;\n                    cnt[root][i]--;\n                    cnt[root][j]--;\n                    cnt[root][k]--;\n                    cnt[root][i ^ j ^ k]--;\n                }\n    // leftover\n    for (int i = 1; i < 16; i++)\n        if (cnt[root][i] > 0) {\n            total++;\n            cnt[root][i]--;\n        }\n\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = (int) 1e9 + 1e6 + 123;\nconst ll LINF = (ll) 1e18 + 1e9 + 123;\n\n#define rep(i, s, t) for (auto i = s; i < (t); ++i)\n#define per(i, s, t) for (auto i = s; i >= (t); --i)\n#define sz(x) ((int) (x).size())\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n\ntemplate<typename A, typename B> bool mini(A &x, const B &y) {\n    if (y < x) {\n        x = y;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<typename A, typename B> bool maxi(A &x, const B &y) {\n    if (y > x) {\n        x = y;\n        return 1;\n    }\n    return 0;\n}\n\nvoid run();\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    run();\n    return 0;\n}\n\nconst int N = (int) 1e5 + 123;\nconst int M = 16;\n\nint n;\nint a[N];\n\nint m;\nint cnt[M], b[M];\nint dp[1 << M];\nint val[1 << M];\n\nvoid run() {\n    cin >> n;\n    rep(i, 0, n - 1) {\n        int u, v, x;\n        cin >> u >> v >> x;\n        a[u] ^= x;\n        a[v] ^= x;\n    }\n    \n    int ans = n;\n    rep(i, 0, n) {\n        cnt[a[i]]++;\n    }\n    ans -= cnt[0];\n    rep(i, 1, M) {\n        ans -= cnt[i] / 2;\n        if (cnt[i] % 2 == 1) {\n            b[m++] = i;\n        }\n    }\n    \n    rep(i, 0, m) val[1 << i] = b[i];\n    rep(mask, 1, 1 << m) val[mask] = val[mask & (mask - 1)] ^ val[mask ^ (mask & (mask - 1))];\n    \n    rep(mask, 1, 1 << m) {\n        for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n            if (val[submask] == 0) {\n                maxi(dp[mask], dp[mask ^ submask] + 1);\n            }\n        }\n    }\n    \n    ans -= dp[(1 << m) - 1];\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <unordered_map>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T> struct CVECTOR {\n\tstd::vector<T> cumsum;\n\tCVECTOR(const std::vector<T>& a) : cumsum(a.size() + 1, 0) {\n\t\tfor (size_t i = 0; i < a.size(); ++i) cumsum[i + 1] = cumsum[i] + a[i];\n\t}\n\tT operator[](int idx) { return cumsum[idx + 1]; }\n};\ntemplate<class T> CVECTOR<T> make_cvector(const std::vector<T>& a) {\n\treturn CVECTOR<T>(a);\n}\n// ------------>8------------------------------------->8------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y, a);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\tg[x[i]].emplace_back(y[i]);\n\t\tg[y[i]].emplace_back(x[i]);\n\t}\n\tstd::vector<std::vector<PAIR>> G(n);\n\tREP(i, n - 1) {\n\t\tG[x[i]].emplace_back(PAIR(y[i], a[i]));\n\t\tG[y[i]].emplace_back(PAIR(x[i], a[i]));\n\t}\n\n\tstd::vector<int> b(n, 0);\n\tREP(i, n) {\n\t\tfor (auto& e : G[i]) {\n\t\t\tb[e.first] ^= e.second;\n\t\t}\n\t}\n\n\tstd::vector<int> dp(1 << 15, INFINT);\n\tdp[0] = 0;\n\tREP(i, 15) {\n\t\tdp[1 << i] = 1;\n\t}\n\tstd::function<int(int)> calc = [&](int bit) {\n\t\tif (dp[(bit)] != INFINT) return dp[(bit)];\n\n\t\tstd::vector<int> bitv;\n\t\tREP(j, 15) {\n\t\t\tif ((bit >> j) & 1) bitv.emplace_back(j);\n\t\t}\n\t\tREP(j, bitv.size()) FOR(k, j + 1, bitv.size()) {\n\t\t\tint mask = bit;\n\t\t\tmask &= ~(1 << bitv[(j)]);\n\t\t\tmask &= ~(1 << bitv[(k)]);\n\t\t\tint pos = ((bitv[(j)] + 1) ^ (bitv[(k)] + 1)) - 1;\n\t\t\tif (!IN(0, pos, 15)) {\n\t\t\t\tVAR(int, x);\n\t\t\t}\n\t\t\tif (mask & (1 << pos)) {\n\t\t\t\tCHMIN(dp[(bit)], calc(mask ^ (1 << pos)) + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCHMIN(dp[(bit)], calc(mask ^ (1 << pos)) + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp[(bit)];\n\t};\n\tFOR(i, 3, 1 << 15) {\n\t\tcalc(i);\n\t}\n\n\tint ans = 0;\n\tint mask = 0;\n\tREP(i, n) {\n\t\tif (b[i] == 0) continue;\n\t\t--b[i];\n\t\tif (mask & (1 << b[i])) {\n\t\t\t++ans;\n\t\t}\n\t\tmask ^= (1 << b[i]);\n\t}\n\tans += dp[mask];\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5, M = 15;\n\nint A[N], C[M + 1], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 0; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 0; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tfor (int i = 0; i < n; i++) C[A[i]]++;\n\tint x = 0, cnt = C[0];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcnt += C[i] >> 1;\n\t\tif (C[i] & 1) x ^= (1 << (i - 1));\n\t}\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nvoid chkmin(int &x,int y){\n\tx=x<y?x:y;\n}\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],w[maxn<<1],e;\nvoid putin(int s,int t,int v){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n\tw[e]=v;\n}\nint cnt[20],ans;\nvoid dfs(int u,int fa,int fv){\n\tint sum=fv;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tdfs(tto[i],u,w[i]);\n\t\tsum^=w[i];\n\t}\n\tif(sum==0) return;\n\tans+=cnt[sum];\n\tcnt[sum]^=1;\n}\nint dp[1<<15];\nint popcnt[1<<15];\nint main(){\n//\tfreopen(\"F.in\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s,t,v;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&v);\n\t\ts++,t++;\n\t\tputin(s,t,v);\n\t\tputin(t,s,v);\n\t}\n\tdfs(1,0,0);\n\tfor(int i=1;i<(1<<15);i++)\n\t\tpopcnt[i]=popcnt[i>>1]+(i&1);\n\n\tint val;\n\tfor(int i=1;i<(1<<15);i++){\n\t\tdp[i]=popcnt[i];\n\t\tval=0;\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tval^=j+1;\n\t\tif(val==0)\n\t\t\tdp[i]--;\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=i;j;j=i&(j-1))\n\t\t\tchkmin(dp[i],dp[j]+dp[i^j]);\n\tval=0;\n\tfor(int i=1;i<=15;i++)\n\t\tif(cnt[i])\n\t\t\tval|=1<<(i-1);\n\tans=ans+dp[val];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#define SIZE 100005\n#define MX 20\n#define BT (1<<16)+5\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nint dp[BT],rv[MX];\nint nw[BT];\nint nm[MX];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y,a;\n\t\tscanf(\"%d %d %d\",&x,&y,&a);\n\t\tA[x]^=a;\n\t\tA[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnm[A[i]]++;\n\t}\n\tint ret=nm[0];\n\tfor(int i=1;i<MX;i++)\n\t{\n\t\tret+=nm[i]/2;\n\t\tnm[i]%=2;\n\t}\n\tvector <int> vt;\n\tfor(int i=1;i<MX;i++) if(nm[i]==1) vt.push_back(i);\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(rv,-1,sizeof(rv));\n\tfor(int i=0;i<vt.size();i++) rv[vt[i]]=i;\n\tdp[0]=0;\n\tfor(int i=0;i<vt.size();i++)\n\t{\n\t\tmemset(nw,-1,sizeof(nw));\n\t\tfor(int S=0;S<1<<i;S++)\n\t\t{\n\t\t\tif(dp[S]==-1) continue;\n\t\t\tnw[S|1<<i]=max(nw[S|1<<i],dp[S]);\n\t\t\tfor(int a=0;a<i;a++)\n\t\t\t{\n\t\t\t\tif(!(S>>a&1)) continue;\n\t\t\t\tfor(int b=a+1;b<i;b++)\n\t\t\t\t{\n\t\t\t\t\tif(!(S>>b&1)) continue;\n\t\t\t\t\tif(vt[a]^vt[b]^vt[i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b);\n\t\t\t\t\t\tnw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=b+1;c<i;c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(S>>c&1)) continue;\n\t\t\t\t\t\tint t=vt[a]^vt[b]^vt[c]^vt[i];\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b)-(1<<c);\n\t\t\t\t\t\tif(t==0) nw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t\telse if(rv[t]!=-1&&(T>>rv[t]&1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint K=T-(1<<rv[t]);\n\t\t\t\t\t\t\tnw[K]=max(nw[K],dp[S]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int S=0;S<1<<(i+1);S++) dp[S]=nw[S];\n\t}\n\tint mx=0;\n\tfor(int i=0;i<BT;i++) mx=max(mx,dp[i]);\n\tprintf(\"%d\\n\",n-ret-mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\nbool book[N];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&u,&v,&va);\n        w[u]^=va;\n        w[v]^=va;\n    }\n    for(int i=0;i<n;i++)\n        cnt[w[i]]++; \n    for(int i=1;i<=15;i++)\n    {\n        res+=cnt[i]/2;\n        st|=(cnt[i]&1)<<(i-1); \n    }\n    for(int i=1;i<(1<<15);i++)\n        d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)\n        d[i]-=1;\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)\n            if((i>>j)&1)\n                sxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++)\n    {\n        if(sxr[i]!=0)\n            continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)\n                d[i]=min(d[i],d[k]+d[i^k]);\n    }\n        printf(\"%d\",res+d[st]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<ll, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<ldouble, ldouble> pdd;\n\nint n;\nvector <pii> E[100010];\nint A[100010];\nint B[16];\nint ans;\n\nvoid dfs(int x, int fa) {\n\tfor(pii e : E[x]) if(e.Se != fa) {\n\t\tdfs(e.Se, x);\n\t\tA[e.Se] ^= e.Fi;\n\t\tA[x] ^= e.Fi;\n\t}\n}\n\nint D[1<<16];\nint X[1<<16];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\trep(i, n-1) {\n\t\tint x, y, z; scanf(\"%d%d%d\", &x, &y, &z); ++x; ++ y;\n\t\tE[x].pb(pii(z, y));\n\t\tE[y].pb(pii(z, x));\n\t}\n\tdfs(1, -1);\n\tfor(int i=2;i<=n;i++) B[A[i]]++;\n\tB[0] = 0;\n\trep(i, 16) ans += B[i] / 2, B[i] &= 1;\n\tvector <int> v;\n\tint L = 0;\n\trep(i, 16) {\n\t\tif(B[i]) v.pb(i), L |= 1<<i;\n\t}\n\trep(b, 1<<16) {\n\t\trep(i, 16) if(1<<i & b) X[b] ^= i;\n\t}\n\trep(b, 1<<16) {\n\t\tfor(int i=b;i;i=(i-1)&b) {\n\t\t\tif(X[i] == 0) {\n\t\t\t\tD[b] = max(D[b], D[b^i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans + szz(v) - D[L]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\n#define sz(a) (int)((a).size())\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing namespace std; using ll = long long; using pii = pair<int, int>; using vi = vector<int>; using ld = long double;\n\nconst int N = 1e5;\n\nint n;\nvector<pii> g[N];\nint a[N];\nint xr[1 << 15];\nint dp[1 << 15];\n\nint32_t main() {\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//ifstream cin(\"in.txt\");\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\t--u; --v;\n\t\tg[u].pb({ v, w });\n\t\tg[v].pb({ u, w });\n\t}\n\tfor (int u = 0; u < n; u++) {\n\t\tfor (pii& e : g[u]) {\n\t\t\ta[u] ^= e.second;\n\t\t}\n\t}\n\tsort(a, a + n);\n\tint ans = n;\n\tvi rem;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!a[i]) {\n\t\t\tans--;\n\t\t}\n\t\telse if (i < n - 1 && a[i] == a[i + 1]) {\n\t\t\tans--;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\trem.pb(a[i]);\n\t\t}\n\t}\n\tn = sz(rem);\n\tfor (int msk = 1; msk < (1 << n); msk++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((msk >> i) & 1) {\n\t\t\t\txr[msk] ^= rem[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int msk = 1; msk < (1 << n); msk++) {\n\t\tfor (int s = msk; s > 0; s = (s - 1) & msk) {\n\t\t\tif (!xr[s]) {\n\t\t\t\tdp[msk] = max(dp[msk], 1 + dp[msk ^ s]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans - dp[(1 << n) - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <utility>\n#include <list>\n\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <bitset>\n#include <complex>\n#include <climits>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\ntypedef pair<double, double> dd;\ntypedef unsigned long long ull;\n#define mp make_pair\n#define pb push_back\n\n#define debug(x) cerr << #x << \" = \" << x << \" \"\n\nconst int N = 1e5;\nint val[N];\nconst int B = 4;\nconst int MB = 1<<B;\nconst int MMB = 1<<MB;\nint cnt[MB];\nint d[MMB];\nint bitvalue[MMB];\nint bitcnt[MMB];\nint main()\n{\n  int n; scanf(\"%d\", &n);\n  for (int i = 1; i <= n-1; ++i)\n    {\n      int u, v, x;\n      scanf(\"%d %d %d\", &u, &v, &x);\n      val[u] ^= x;\n      val[v] ^= x;\n    }\n  for (int i = 0; i < n; ++i) ++cnt[val[i]];\n  int ans = 0;\n  for (int i = 0; i < MB; ++i) bitvalue[1<<i] = i;\n  for (int i = 1; i < MB; ++i) ans += cnt[i]/2, cnt[i] %= 2;\n  for (int i = 1; i < MMB; ++i)\n    {\n      int lb = i&-i;\n      bitvalue[i] = bitvalue[i^lb] ^ bitvalue[lb];\n      bitcnt[i] = bitcnt[i>>1] + (i&1);\n      d[i] = MB;\n      for (int sub = i; sub; sub = (sub-1)&i)\n\tif (bitvalue[sub] == 0)\n\t  d[i] = min(d[i], bitcnt[sub] -1 + d[i^sub]);\n    }\n  int mask = 0;\n  for (int i = 1; i < n; ++i) mask ^= cnt[i] << i;\n  printf(\"%d\\n\", d[mask] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  scanf(\"%d\", &n);\n\n  vector<int> vals(n);\n  for (int i = 0; i < n-1; i++) {\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    vals[a] ^= c;\n    vals[b] ^= c;\n  }\n\n  int ans = n;\n  int mask = 0;\n  for (int i = 0; i < n; i++) {\n    if (vals[i] == 0) {\n      ans--;\n    } else {\n      if (mask & (1 << vals[i])) {\n        ans--;\n      }\n      mask ^= (1 << vals[i]);\n    }\n  }\n\n  const int K = 16;\n\n  vector<int> dp(1 << K);\n  for (int i = 1; i < (1 << K); i++) {\n    int v = 0;\n    for (int j = 0; j < K; j++) {\n      if (i & (1 << j)) {\n        v ^= j;\n      }\n    }\n    if (!v) {\n      dp[i] = 1;\n    } else {\n      dp[i] = -10000;\n    }\n\n    for (int j = i; j; j = (j - 1) & i) {\n      dp[i] = max(dp[i], dp[j] + dp[i ^ j]);\n    }\n  }\n\n  eprintf(\"ans = %d, mask = %d, dp[mask] = %d\\n\", ans, mask, dp[mask]);\n\n  ans -= dp[mask];\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int inf = 1e9,maxn=3e5+5,maxs=(1<<16) + 5;\n\nint n,cnt[maxn],w[maxn],ans;\nint goodst[maxs], dp[maxs];\n\nint main(){\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t++x;++y;\n\t\tw[x] ^= z;w[y] ^= z;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)++cnt[w[i]];\n\tfor(int i=1;i<=n;i++)\n\t\tans += cnt[i]/2, cnt[i]%=2;\n\tint lim=0;for(int i=0;i<=15;i++)lim |= (cnt[i] == 0?0:(1<<i)), ans += (cnt[i]!=0);\n\tfor(int S=0;S<=(1<<16)-1;S++){\n\t\tint x=0;\n\t\tfor(int i=0;i<=15;i++)\n\t\t\tif(S&(1<<i))x^=i;\n\t\tgoodst[S] = 0;if(x==0)goodst[S] = 1;\n\t}\n\t\n\tfor(int S=0;S<=(1<<16)-1;S++){\n\t\tif(S&1)continue;\n\t\tfor(int T=S;T;T=(T-1)&S){\n\t\t\tif(goodst[T])\n\t\t\t\tdp[S] = max(dp[S], dp[S^T]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans-dp[lim]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nconst int N=100000+10;\nconst int B=15;\nconst int S=1<<B;\n\nint _r;char _c;\n\nint read()\n{\n\twhile(!isdigit(_c=getchar()));\n\t_r=_c-48;\n\twhile(isdigit(_c=getchar()))\n\t\t_r=_r*10-48+_c;\n\treturn _r;\n}\n\nint n,b[N],ans,fl[B+1];\nint sum[S],dp[S];\n\nint count(int x)\n{\n\tint cnt(1);\n\twhile(!(x&1))\n\t{\n\t\t++cnt;\n\t\tx>>=1;\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tans=(n=read())-1;\n\tint i,j,k,x,y,a;\n\tfor(i=1;i<n;++i)\n\t{\n\t\tx=read();y=read();a=read();\n\t\tb[x]^=a;\n\t\tb[y]^=a;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\t++fl[b[i]];\n\tif(fl[0]==n)\n\t{\n\t\tprintf(\"0\");\n\t\treturn 0;\n\t}\n\tans-=fl[0];\n\tfor(i=1;i<=B;++i)\n\t{\n\t\tans-=fl[i]>>1;\n\t\tfl[i]&=1;\n\t}\n\tfor(i=1;i<S;++i)\n\t{\n\t\tk=count(j=i&(-i));\n\t\tsum[i]=sum[i^j]^(fl[k]*k);\n\t}\n\tfor(i=0;i<S;++i)\n\t{\n\t\tk=(S-1)^i;\n\t\tfor(j=k;j;(j-=1)&=k)if(!sum[j])\n\t\t\tdp[i^j]=min(dp[i^j],dp[i]+1);\n\t}\n\tprintf(\"%d\",ans-dp[S-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 50010;\n\nint n, m, a[N], b[20];\n\nint st, dp[100010];\n\nint dfs(int x) {\n\tif (dp[x] != -1) return dp[x];\n\tint res = 1e9;\n\tfor (int i = 1; i < 16; i ++)\n\t\tif ((x >> i) & 1)\n\t\t\tfor (int j = 1; j < 16; j ++)\n\t\t\t\tif (((x >> j) & 1) && (i != j)) {\n\t\t\t\t\tint k = i ^ j;\n\t\t\t\t\tif ((st >> k) & 1) res = min(res, dfs(x ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 2);\n\t\t\t\t\telse res = min(res, dfs(x ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 1);\n\t\t\t\t}\n\treturn dp[x] = res;\n} \n\nint main() {\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int u, v, w, i = 1; i < n; i ++) {\n\t\tcin >> u >> v >> w, u ++, v ++;\n\t\ta[u] ^= w, a[v] ^= w;\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tb[a[i]] ++;\n\tfor (int i = 1; i < 16; i ++) {\n\t\tm += b[i] / 2;\n\t\tif (b[i] & 1) st |= 1 << i;\n\t}\n\t//cout << st << endl;\n\tfor (int i = 1, j = 1 << 16; i < j; i ++)\n\t\tdp[i] = -1;\n\tcout << m + dfs(st) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 100010;\nint n;\nint x[MAX];\nint il[16];\nint dp[1 << 17];\nint xx[1 << 17];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  R(i,n-1){\n    int a,b,c;\n    cin >> a >> b >> c;\n    x[a]^=c;\n    x[b]^=c;\n  }\n  R(i,n){\n    il[x[i]]++;\n  }\n  vector<int> pom;\n  int res = 0;\n  R(i,16)if(i){\n    if(il[i]&1){\n      pom.PB(i);\n    }\n    res += il[i]/2;\n  }\n  R(i,1<<SZ(pom)){\n    R(j,SZ(pom))if((i >> j)&1){\n      xx[i] ^= pom[j];\n    }\n  }\n  R(i,1<<SZ(pom)){\n    debug(xx[i],i);\n    if(xx[i] == 0){\n      dp[i] = 1;\n      for(int j = (i - 1) & i; j ; j = (j -1)&i){\n        if(xx[j] == 0){\n          maxi(dp[i], dp[j] + 1);\n        }\n      }\n    }\n  }\n  debug(SZ(pom),res,dp[(1 << SZ(pom))-1]);\n  cout << res + max(0ll, SZ(pom) - dp[(1 << SZ(pom))-1]) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n\n\nint cnt = 0;\nvector< vector<int> > hoges;\nvoid dfs(vector<int> items){\n\t\n\tint ok = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tint flg = 1;\n\t\tfor( int j : items ){\n\t\t\tif( (j & i) == i ) flg = 0;\n\t\t}\n\t\tif(flg==0) break;\n\t\tvector<int> t = items;\n\t\tt.push_back(i);\n\t\tdfs(t);\n\t\tok = 1;\n\t}\n\tif(!ok){\n\t\thoges.push_back(items);\n\t}\n}\n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a), b(b), c(c){}\n};\n\nint deg[100010];\nint f(vector<int> hoge, vector<Edge> es){\n\treverse(hoge.begin(), hoge.end());\n\tint ans = 0;\n\tfor(auto h : hoge ){\n\t\tmemset(deg, 0, sizeof(deg));\t\n\t\tfor( auto &e : es ){\n\t\t\tif( (e.c & h) != h ) continue;\n\t\t\tdeg[e.a]++;\n\t\t\tdeg[e.b]++;\n\t\t\te.c -= h;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0 ; i < es.size() + 1 ; i++){\n\t\t\tif( deg[i] == 1 ) cnt++;\n\t\t}\n\t\tans += (cnt + 1) / 2;\n\t}\n\tfor( auto &e : es ){\n\t\tif( e.c != 0 ) return 1e9;\n\t}\n\treturn ans;\n}\n\nvoid solve(ll N, vector<ll> x, vector<ll> y, vector<ll> a){\n\ttime_t start = clock();\n\tdfs({});\n\tsrand(time(NULL));\n\trandom_shuffle(hoges.begin(), hoges.end());\n\n\t\n\tint ans = 1e9;\n\tvector<Edge> es;\n\tfor(int i = 0 ; i < x.size() ; i++){\n\t\tes.push_back(Edge(x[i], y[i], a[i]));\n\t}\n\tfor( auto hoge : hoges ){\n\t\ttime_t end = clock();\n\t\tif( 1.0 * (end-start) / CLOCKS_PER_SEC > 1.8 ) break;\n\t\tans = min(ans, f(hoge, es));\n\t}\n\tcout << ans << endl;\n\n}\n\nint main(){\t\n\tll N;\n\tscanf(\"%lld\",&N);\n\tvector<ll> x((N-1)-1+1);\n\tvector<ll> y((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor(int i = 0 ; i <= (N-1)-1 ; i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t\tscanf(\"%lld\",&y[i]);\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tsolve(N, x, y, a);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#define ll long long\n#define qwq 100007\nint n;\nint val[qwq];\nbool Map[30];\nint ans;\nint dp[1<<20];\nint dfs(int s){\n\tif(s==0)return 0;\n\tif(dp[s]!=0x3f3f3f3f)return dp[s];\n\tfor(int i=1;i<=16;++i){\n\t\tif(!(s&(1<<i)))continue;\n\t\tfor(int j=1;j<=16;++j){\n\t\t\tif(i==j)continue;\n\t\t\tif(!(s&(1<<j)))continue;\n\t\t\tint x=i^j;\n\t\t\tif(s&(1<<x))dp[s]=std::min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<x))+2);\n\t\t\telse dp[s]=std::min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<x))+1);\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint a,b,v;\n\t\tscanf(\"%d%d%d\",&a,&b,&v);\n\t\t++a;++b;\n\t\tval[a]^=v;val[b]^=v;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(val[i]==0)continue;\n\t\tif(!Map[val[i]])Map[val[i]]=true;\n\t\telse ++ans,Map[val[i]]=false;\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tint s=0;\n\tfor(int i=1;i<=16;++i){\n\t\ts+=Map[i]<<i;\n\t}\n\tprintf(\"%d\\n\",ans+dfs(s));\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  //cout<<ans<<\":\"<<res<<endl;\n  ans/=2;\n\n  cout<<ans<<endl;\n  return 0;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    for(Int i=0;i<16;i++){\n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\tInt dif=bc[i&j]-1;\n\tInt nb=b^(1<<i)^(1<<j);\n\tif((nb>>(i^(i&j)))&1) dif+=max<Int>(0,bc[i^(i&j)]-1);\n\tif((nb>>(j^(i&j)))&1) dif+=max<Int>(0,bc[j^(i&j)]-1);\n\tnb^=1<<(i^(i&j));\n\tnb^=1<<(j^(i&j));\n\tif(dp[nb]>=dp[b]+dif) continue;\n\tdp[nb]=dp[b]+dif;\n\tpq.emplace(calc(nb),nb);\n      }\n    }\n  }\n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long \n#define pb push_back\n//#define mp make_pair\n#define fr first\n#define sc second\n#define N ((ll)(2e6+100))\n#define MAX ((ll)(1e16+100))\n#define ARRS ((ll)(3e5+100))\n#define MOD ((ll)(1e9+7))\n#define M1 ((ll)(1001783))\n#define M2 ((ll)(1001941))\n#define M3 ((ll)(1002073))\n#define pb push_back\n\nll dp[ARRS];\nll f[ARRS];\nll c[ARRS];\n\n\nll go(ll x){\n\tif(x&1)x^=1;\n\tif(!x)return 0;\n\tif(dp[x])return dp[x];\n\tll a[18];\n\tll b[18];\n\tfor(int i=0; i<16; i++)a[i]=(x>>i)&1;\n\tdp[x]=MAX;\n\tfor(int i=1; i<16; i++){\n\t\tfor(int j=i+1; j<16; j++){\n\t\t\tif(a[i]&&a[j]){\n\t\t\t\tfor(int t=1; t<16; t++){\n\t\t\t\t\tfor(int i=0; i<16; i++)b[i]=a[i];\n\t\t\t\t\tb[i]--;\n\t\t\t\t\tb[j]--;\n\t\t\t\t\tb[i^t]++;\n\t\t\t\t\tb[j^t]++;\n\t\t\t\t\tll k=0;\n\t\t\t\t\tll r=0;\n\t\t\t\t\tfor(int i=0; i<16; i++){\n\t\t\t\t\t\tk+=b[i]/2;\n\t\t\t\t\t\tb[i]&=1;\n\t\t\t\t\t\tr=r|(b[i]<<i);\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<bitset<16>(x)<<endl;\n\t\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<t<<\" \"<<k<<endl;\n\t\t\t\t\t//cout<<bitset<16>(r)<<endl;\n\t\t\t\t\t//cout<<endl;\n\t\t\t\t\tif(x==r)continue;\n\t\t\t\t\tdp[x]=min(dp[x],go(r)+k+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[x];\n}\n\n\nint main(){\n\n\tll n;\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tll k,p,c;\n\t\tcin>>k>>p>>c;\n\t\tf[k]^=c;\n\t\tf[p]^=c;\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tc[f[i]]++;\n\n\tll t=0;\n\tll pas=0;\n\tfor(int i=0; i<16; i++){\n\t\tif(i)\n\t\tpas+=c[i]/2;\n\t\tc[i]&=1;\n\t\tt=t|(c[i]<<(i));\n\t}\n\n\tpas+=go(t);\n\n\tcout<<pas;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i = (int)(a); i <= (int)(b); i++)\n#define NFOR(i,a,b) for(int i = (int)(a); i >= (int)(b); --i)\n#define endl \"\\n\"\n#define mp make_pair\n#define X first\n#define Y second\n#define inf 1e18\n#define mod 1000000007\n#define pb push_back\n#define Case cout<<\"Case #\"<<++cas<<\": \";\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define all(v) v.begin(),v.end()\n#define sz(x) int(x.size())\n// #define lli int\ntypedef long long int lli;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<lli,lli> pll;\ntypedef vector<lli> vl;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cerr << str << \" : \" << t << \"\\n\";}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cerr << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cerr << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cerr << \", \"; cerr << *i;} cerr << \"]\\n\";}\n\nconst int N = 100010;\n\nint val1[N];\nbool isPresent[N];\nint dp[(1<<16) + 1];\nbool good[(1<<16) + 1];\n\nint main() {\n\tint n; cin >> n;\n\tFOR(i, 1, n-1) {\n\t\tint a1, b1, c1; cin >> a1 >> b1 >> c1; a1++, b1++;\n\t\tval1[a1] ^= c1, val1[b1] ^= c1;\n\t}\n\tint answer1 = 0;\n\tint remain = 0;\n\tFOR(i, 1, n) {\n\t\tif (val1[i] == 0) {\n\t\t\tanswer1++; continue;\n\t\t}\n\t\tif (isPresent[val1[i]]) {\n\t\t\tanswer1++, isPresent[val1[i]] = false;\n\t\t} else {\n\t\t\tisPresent[val1[i]] = true;\n\t\t}\n\t\tremain ^= (1<<val1[i]);\n\t}\n\tFOR(i, 0, (1<<16)-1) {\n\t\tint currentMask = 0;\n\t\tFOR(j, 0, 16) {\n\t\t\tif (i & (1<<j)) {\n\t\t\t\tcurrentMask ^= j;\n\t\t\t}\n\t\t}\n\t\tif (currentMask == 0) {\n\t\t\tgood[i] = true;\n\t\t}\n\t}\n\tFOR(i, 0, (1<<16)-1) {\n\t\tfor (int j = i; j > 0; j = (j -1) & i) {\n\t\t\tif (good[i ^ j]) {\n\t\t\t\tdp[i] = max(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << n - (answer1 + dp[remain]) << \"\\n\";\nreturn 0;}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\n// const int na = 1<<11;\n// int A[na];\n\nlli f(lli bs) {\n  vvii G(1<<16);\n  FOR(m,1<<16) FOR(i,16) if(i&&(m&(1<<i))) FOR(j,16) if(i<j&&j&&(m&(1<<j))) FOR(l,16) if(l) {\n        lli co = 1;\n        lli i2 = i^l;\n        lli j2 = j^l;\n        lli m2 = m^(1<<i)^(1<<j);\n        if(i2) {\n          if(m2&(1<<i2)) co++;\n          m2^=(1<<i2);\n        }\n        if(j2){\n          if(m2&(1<<j2)) co++;\n          m2^=(1<<j2);\n        }\n        G[m2].pb(mt(m,co));\n      }\n  min_queue<pii> Q; vi D(1<<16,1ll<<60);\n  Q.push(mt(0,0)); D[0] = 0;\n  while(!Q.empty()) {\n    lli d,m; tie(d,m) = Q.top(); Q.pop();\n    if(D[m] != d) continue;\n    if(m == bs) return d;\n    for(auto e : G[m]) {\n      lli dd,m2; tie(m2,dd) = e;\n      dd += d;\n      if(dd < D[m2]) { D[m2] = dd; Q.push(mt(dd,m2)); }\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n; cin>>n;\n  vi D(n);\n  FOR(i,n-1) {\n    lli u,v,e; cin>>u>>v>>e;\n    D[u] ^= e; D[v] ^= e;\n  }\n  vi C(16); FOR(i,n) C[D[i]]++;\n  lli ans=0;\n  lli bs = 0;\n  FOR(i,16) if(i) {\n    ans += C[i]/2;\n    C[i] %= 2;\n    if(C[i]) bs |= (1<<i);\n  }\n  cout << ans+f(bs) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=1e5,M=2e6+1000;\nint n,a[N],f[M],cnt[M],as,st,S,x[M];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\t//freopen(\"3913.in\",\"r\",stdin);freopen(\"3913.out\",\"w\",stdout);\n\tn=read();rp(i,1,n-1){ri x=read()+1,y=read()+1,z=read();a[x]^=z;a[y]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\tf[0]=0;rp(i,1,S)f[i]=f[i>>1]+(i&1);\n\trp(i,1,S)--f[i];rp(i,1,S)rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nconst int MAXN = 1e5 + 5;\n\nint n;\nstd::vector<std::pair<int, int> > G[MAXN];\n\nint DFS(int now, int fa, int S) {\n    int res = 0, cnt[4] = {0, 0, 0, 0};\n    for (auto e: G[now]) {\n        if (e.first == fa) continue;\n        res += DFS(e.first, now, e.second);\n        for (int i = 0; i < 4; ++i) {\n            if (e.second & (1 << i)) ++cnt[i];\n        }\n    }\n    for (int i = 0; i < 4; ++i) {\n        res += cnt[i] / 2;\n        if ((cnt[i] & 1) && !(S & (1 << i))) ++res;\n    }\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        static int u, v, d;\n        \n        scanf(\"%d%d%d\", &u, &v, &d);\n        G[u].emplace_back(v, d);\n        G[v].emplace_back(u, d);\n    }\n    \n    printf(\"%d\\n\", DFS(0, 0, 0));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define b(x) ((x)==0?0:(1<<((x)-1)))\n#define lb(x) ((x)&(-(x)))\nconst int nMaxn = 100005, nMaxs = 114514;\nint N, nXorperp[nMaxn] = {0}, bRec[nMaxs];\nint bCalcable[nMaxs], bExibits[nMaxs];\nint nStstat = 0, bOutsteps = 0;\n\nint dfs(int vCur) {\n    if (bRec[vCur] != -1) return bRec[vCur];\n    int& vRes = bRec[vCur];\n    vRes = bExibits[vCur]-1;\n    \n    int bPos = lb(vCur);\n    for (int vSpl=(vCur-1)&vCur; vSpl; vSpl=(vSpl-1)&vCur) {\n        if ((vSpl&bPos)&&bCalcable[vSpl]&&bCalcable[vCur^vSpl]) {\n            vRes = min(vRes, dfs(vSpl)+dfs(vCur^vSpl));\n        }\n    }\n    \n    return vRes;\n}\n\ninline void check(int vStat) {\n    int bCov = 0, bBit = 0;\n    int vCopied = vStat;\n    while (vCopied) {\n        ++bBit;\n        if (vCopied&1) ++bExibits[vStat], bCov^=bBit;\n        vCopied >>= 1;\n    }\n    bCalcable[vStat] = bCov==0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N;\n    int u, v, w;\n    for (int i=1; i<N; ++i) \n        cin >> u >> v >> w,\n        nXorperp[u] ^= w,\n        nXorperp[v] ^= w;\n    for (int i=0; i<N; ++i)\n        nStstat ^= b(nXorperp[i]),\n        bOutsteps += nXorperp[i]&&!(nStstat&b(nXorperp[i]));\n    for (int i=0; i<nMaxs; ++i) \n        bRec[i] = -1,\n        check(i);\n    cout << max(0, dfs(nStstat))+bOutsteps << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\nusing namespace std;\nint n,x,y,z,ans,val[1<<(N+1)],cnt[N*2],dp[1<<N];\nvector<int>G[N*2];\ninline int read(){\n\tchar ch=getchar();int f=1,w=0;\n\tfor (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) w=w*10+ch-'0';\n\treturn w*f;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tx=read()+1;y=read()+1;z=read();\n\t\tval[x]^=z;val[y]^=z;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,val[i]=cnt[i]%2;\n\tint now=0,tot=0;\n\tfor (int i=1;i<=15;i++) if (val[i]) now|=(1<<i),tot++;\n\tmemset(dp,127,sizeof(dp));int inf=dp[now];dp[now]=0;\n\tfor (int i=0;i<(1<<16);i++) G[__builtin_popcount(i)].push_back(i);\n\t/*for (int i=tot;i;i--){\n\t\tfor (int j=0;j<(int)G[i].size();j++){\n\t\t\tint S=G[i][j];\n\t\t\tif (dp[S]==inf) continue;\n\t\t\tfor (int x=1;x<=15;x++){\n\t\t\t\tfor (int y=1;y<=15;y++){\n\t\t\t\t\tif (x==y||(!(S>>x&1))||(!(S>>y&1))) continue;\n\t\t\t\t\tint tmp=x^y;\n\t\t\t\t\tint S1=S^(1<<x)^(1<<y);\n\t\t\t\t\tif (S1&(1<<tmp)) dp[S1^(1<<tmp)]=min(dp[S1^(1<<tmp)],dp[S]+2);\n\t\t\t\t\telse dp[S1|(1<<tmp)]=min(dp[S1|(1<<tmp)],dp[S]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i=tot;i;i--){\n\t\tfor (int j=0;j<(int)G[i].size();j++){\n\t\t\tint S=G[i][j];\n\t\t\tif (dp[S]==inf) continue;\n\t\t\tx=__builtin_ctz(S);\n\t\t\t\tfor (int y=1;y<=15;y++){\n\t\t\t\t\tif (x==y||(!(S>>x&1))||(!(S>>y&1))) continue;\n\t\t\t\t\tint tmp=x^y;\n\t\t\t\t\tint S1=S^(1<<x)^(1<<y);\n\t\t\t\t\tif (S1&(1<<tmp)) dp[S1^(1<<tmp)]=min(dp[S1^(1<<tmp)],dp[S]+2);\n\t\t\t\t\telse dp[S1|(1<<tmp)]=min(dp[S1|(1<<tmp)],dp[S]+1);\n\t\t\t\t}\n\t\t}\n\t}\n\t//cerr<<inf<<endl;\n\tprintf(\"%d\\n\",min(dp[1],dp[0])+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][20][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 20) return 1e9;\n    if(tidx == 4| tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=200010,M=20,Inf=2e9;\nint n,a[N],cnt[M],ans,f[1<<M];\nvoid chkmin(int &x,int y){x=min(x,y);}\nint main(){\n\tn=gi();\n\tfor(int i=1;i<n;i++){\n\t\tint u=gi()+1,v=gi()+1,w=gi();\n\t\ta[u]^=w;a[v]^=w;\n\t}\n\tint now=0;\n\tfor(int i=1;i<=n;i++)cnt[a[i]]++;\n\tfor(int i=1;i<=15;i++){ans+=cnt[i]/2;cnt[i]&=1;now+=cnt[i]<<(i-1);}\n\tmemset(f,127,sizeof(f));f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<Inf)\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k){\n\t\t\t\t\t\t\tint x=j^k;\n\t\t\t\t\t\t\tif(i&(1<<x-1))chkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<x-1)],f[i]+2);\n\t\t\t\t\t\t\telse chkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<x-1)],f[i]+1);\n\t\t\t\t\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 200007\n\nint n , num[20] , val[N] ;\nint C[N] , Cnt[N] ;\n\nint main()\n{\n    scanf(\"%d\" , &n ) ;\n    for(int i = 1 ; i <= n - 1 ; i++ ){ int u , v , w ; scanf(\"%d%d%d\" , &u , &v , &w ) ; val[u] ^= w , val[v] ^= w ;  }\n    for(int i = 0 ; i <= n - 1 ; i++ ) num[val[i]]++ ;\n    int ans = 0 , ed = 0 ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ){\n        for(int j = 0 ; j < 15 ; j++ ) if( i & ( 1 << j ) ) C[i] = C[i] | ( j + 1 ) ;\n    }\n    for(int i = 1 ; i <= 15 ; i++ ) ans += num[i] / 2 ;\n    for(int i = 1 ; i <= 15 ; i++ ) if( num[i] & 1 ) ed |= ( 1 << ( i - 1 ) ) ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ) Cnt[i] = Cnt[i >> 1] + ( i & 1 ) ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ){\n        Cnt[i]-- ;\n        if( C[i] ) continue ;\n        for(int k = ( i - 1 ) & i ; k ; k = ( k - 1 ) & i ){\n            if( C[k] ) Cnt[i] = min( Cnt[i ^ k] + Cnt[k] , Cnt[i] ) ;\n        }\n    }\n    printf(\"%d\\n\" , ans + Cnt[ed] ) ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans;\nint dp(int s)\n{\n\tif(!s)\n\t\treturn 0;\n\tif(f[s])\n\t\treturn f[s];\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tif(!(s&(1<<i)))\n\t\t\tcontinue;\n\t\tfor(int j=1;j<=15;j++)\n\t\t{\n\t\t\tif(i==j||!(s&(1<<j)))\n\t\t\t\tcontinue;\n\t\t\tint k=i^j;\n\t\t\tint t=s^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif(s&(1<<k))\n\t\t\t\tf[s]=min(f[s],dp(t)+2);\n\t\t\telse\n\t\t\t\tf[s]=min(f[s],dp(t)+1);\n\t\t}\n\t}\n\treturn f[s];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tprintf(\"%d\",ans+dp(s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n#define fillZero(a) memset((a), 0,  sizeof(a))\n#define fillINF(a) memset((a), 0x3f, sizeof(a)) // 3f3f3f3f = 1,061,109,567 < 2^30\n#define all(a) (a).begin(), (a).end()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n\nclass Edge {\npublic:\n\tvirtual int from() const = 0;\n\tvirtual int to() const = 0;\n\tvirtual Edge* reversedEdge() = 0;\n};\n\ntypedef int EdgeWeight;\nclass SimpleEdge : public Edge {\n\tint from_, to_;\n\tEdgeWeight weight_;\npublic:\n\tSimpleEdge(int from,int to,EdgeWeight weight_) : from_(from), to_(to), weight_(weight_) {}\n\tstatic SimpleEdge* createFromInput(){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\treturn new SimpleEdge(a,b,w);\n\t}\n\tint to() const { return to_; }\n\tint from() const { return from_; } \n\tint weight() const { return weight_; }\n\tSimpleEdge* reversedEdge(){\n\t\treturn new SimpleEdge(to_, from_, weight_);\n\t}\n};\n\nclass Graph {\npublic:\n\tvirtual vector<Edge*> *connectedEdges(int v) = 0;\n\tvirtual void addEdge(Edge *edge) = 0;\n};\n\nclass UndirectedGraph : public Graph {\nprivate:\n\tvector<Edge*> edges;\n\tvector< vector<Edge*> > graph;\npublic:\n\tUndirectedGraph(int n){\n\t\tgraph.resize(n);\n\t}\n\t\n\tsize_t size(){\n\t\treturn graph.size();\n\t}\n\n\tvoid addEdge(Edge *edge){\n\t\tedges.push_back(edge);\n\t\tassert(edge->from() < size());\n\t\tassert(edge->to() < size());\n\n\t\tgraph[edge->from()].push_back(edge);\n\t\tgraph[edge->to()].push_back(edge->reversedEdge());\n\t}\n\tvector<Edge*> *connectedEdges(int v){\n\t\treturn &graph[v];\n\t}\n\tvector<Edge*> *allEdges(){\n\t\treturn &edges;\n\t}\n};\n\n\nconst int N_MAX = 100010;\nbool canMakeZero(int bit){\n\tint tst = 0;\n\trep(i,16) if( bit >> i & 1 ) tst ^= bit;\n\treturn tst == 0;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tUndirectedGraph g(n);\n\tfor(int i = 0 ; i < n - 1 ; i++){\n\t\tg.addEdge(SimpleEdge::createFromInput());\n\t}\n\t\n\tint vXors[N_MAX] = {};\n\tfor( auto e : *g.allEdges() ){\n\t\tvXors[e->from()] ^= ((SimpleEdge*)e)->weight();\n\t\tvXors[e->to()] ^= ((SimpleEdge*)e)->weight();\n\t}\n\tint freq[16] = {};\n\trep(i,g.size()){\n\t\tfreq[vXors[i]]++;\n\t}\n\tint baseAnswer = 0;\n\tint freqBit = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tbaseAnswer += freq[i] / 2;\n\t\tfreqBit |= (freq[i]%2) << i;\n\t}\n\n\tint dp[1<<16];\n\tfillINF(dp);\n\tdp[0] = 0;\n\tfor(int i = 0 ; i <= freqBit ; i+=2){\n\t\tint j = i;\n\t\twhile(j){\n\t\t\tdp[i] = min(dp[i], dp[i^j] + popcount(j) - (canMakeZero(j) ? 1 : 0));\n\t\t\tj = (j-1) & i;\n\t\t}\n\t}\n\tcout << dp[freqBit] + baseAnswer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=2e5+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[20], f[MaxM];\nbool xr[MaxM];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[x]^=z, v[y]^=z;\n\tfor (int i=0; i<n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=0; i< 15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=(i+1);\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::vector<int> a(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, w;\n    std::cin >> u >> v >> w;\n    a[u] ^= w;\n    a[v] ^= w;\n  }\n  std::array<int, 16> cnt{};\n  for (int i = 0; i < n; ++i) cnt[a[i]]++;\n  int ans = 0;\n  for (int i = 0; i < 16; ++i) {\n    if (i > 0) ans += cnt[i] / 2;\n    cnt[i] &= 1;\n  }\n  std::vector<std::vector<std::pair<int, int>>> g(1 << 16);\n  for (int s = 0; s < (1 << 16); ++s) {\n    for (int i = 0; i < 16; ++i) {\n      if ((s >> i & 1) == 0) continue;\n      for (int j = i + 1; j < 16; ++j) {\n        if ((s >> j & 1) == 0) continue;\n        for (int v = 0; v < 16; ++v) {\n          int mask = s ^ (1 << i) ^ (1 << j);\n          int w = 1;\n          if (mask >> (i ^ v) & 1) w++;\n          if (mask >> (j ^ v) & 1) w++;\n          mask ^= (1 << (i ^ v));\n          mask ^= (1 << (j ^ v));\n          g[s].emplace_back(mask, w);\n        }\n      }\n    }\n  }\n  int mask = 0;\n  for (int i = 0; i < 16; ++i) {\n    if (cnt[i] > 0) mask ^= (1 << i);\n  }\n  std::array<int, 1 << 16> d{};\n  std::bitset<1 << 16> used;\n  constexpr int kInf = 1'000'000'000;\n  std::fill(d.begin(), d.end(), kInf);\n  d[mask] = 0;\n  std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,\n                      std::greater<std::pair<int, int>>>\n      pq;\n  pq.emplace(0, mask);\n  while (!pq.empty()) {\n    int x = pq.top().second;\n    pq.pop();\n    if (used[x]) continue;\n    used[x] = true;\n    for (auto e : g[x]) {\n      if (d[x] + e.second < d[e.first]) {\n        d[e.first] = d[x] + e.second;\n        pq.emplace(d[e.first], e.first);\n      }\n    }\n  }\n  std::cout << ans + std::min(d[0], d[1]) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\n\nint n,ans;\nint t[N],a[18];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tt[x]^=z;\n\t\tt[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\ta[t[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t\tans+=a[i]>>1,a[i]&=1;\n\tfor(int i=1;i<=15;i++)\n\tfor(int j=i+1;j<=15;j++)\n\t\tif(a[i^j] && a[i] && a[j]) a[i]=0,a[j]=0,a[i^j]=0,ans+=2;\n\tfor(int i=1;i<=15;i++)\n\tfor(int j=i+1;j<=15;j++)\n\tfor(int k=j+1;k<=15;k++)\n\t\tif(a[i] && a[j] && a[k] && a[i^j^k]) a[i]=0,a[j]=0,a[k]=0,a[i^j^k]=0,ans+=3;\n\tfor(int i=1;i<=15;i++)\n\t\tif(a[i]) a[16]++;\n\tif(a[16]>=5) ans+=a[16]-1;\n\telse ans+=a[16];\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    a[x] ^= z;\n    a[y] ^= z;\n  }\n  vector<int> cnt(16);\n  for (int i = 0; i < n; i++) {\n    ++cnt[a[i]];\n  }\n  int res = 0;\n  int have = 0;\n  for (int i = 1; i < 16; i++) {\n    res += cnt[i] / 2;\n    cnt[i] &= 1;\n    have |= (cnt[i] << i);\n  }\n  vector<bool> ok(1 << 16);\n  for (int mask = 0; mask < (1 << 16); mask++) {\n    int here = 0;\n    for (int i = 0; i < 16; i++) {\n      if ((mask >> i) & 1) {\n        here ^= i;\n      }\n    }\n    ok[mask] = (here == 0);\n  }\n  vector<int> dp(1 << 16);\n  for (int mask = 1; mask < (1 << 16); mask++) {\n    if (mask & 1) continue;\n    for (int smsk = (mask - 1) & mask; true; smsk = (smsk - 1) & mask) {\n      if (ok[smsk]) {\n        dp[mask] = max(dp[mask], dp[mask ^ smsk] + 1);\n      }\n      if (smsk == 0) break;\n    }\n  }\n  cout << res + __builtin_popcount(have) - dp[have] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint c[101000];int ok[100000],tot[100000];\nint h[101000],nxt[201000],K=0,to[201000],cost[201000];int cnt[16],ans=0;\nvoid ins(int u,int v,int c){nxt[++K]=h[u];h[u]=K;to[K]=v;cost[K]=c;}\nvoid dfs(int x,int f,int val)\n{\n\tint k=0;\n\tfor(int i=h[x];i;i=nxt[i])\n\t{\n\t\tif(to[i]==f)continue;\n\t\tk^=cost[i];dfs(to[i],x,cost[i]);\n\t}\n\tif(x)cnt[val^k]++;\n}\nint a[18],dp[1<<15];\nint DP(int S)\n{\n\tif(dp[S]!=-1)return dp[S];dp[S]=2000000000;\n\tfor(int i=S;i&=S;i--)if(ok[i]==0)dp[S]=min(dp[S],DP(S^i)+tot[i]-1); \n\treturn dp[S];\n}\nint main()\n{\n\tfor(int S=0;S<(1<<15);S++)\n\t{\n\t\tint k=0,u=0;\n\t\tfor(int i=0;i<15;i++)if((S>>i)&1)k^=(i+1),u++;\n\t\tok[S]=k;tot[S]=u;\n\t\tif(u==1)ok[S]=0,tot[S]=2;\n\t}\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){int x,y,c;scanf(\"%d%d%d\",&x,&y,&c);ins(x,y,c);ins(y,x,c);}\n\tdfs(0,-1,0);\n\tint S=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)S|=1<<(i-1);\n\t}\n\tmemset(dp,-1,sizeof(dp));dp[0]=0;\n\tprintf(\"%d\",DP(S)+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt[100003],cntt[16],ans;\nint dp[65536];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){int x,y,a;cin>>x>>y>>a;cnt[x]^=a;cnt[y]^=a;}\n\tfor(int i=0;i<n;i++)cntt[cnt[i]]++;\n\tfor(int i=1;i<16;i++)ans+=cntt[i]/2,cntt[i]%=2;\n\tint tmp=0;for(int i=1;i<16;i++)tmp=tmp+cntt[i]*(1<<i);\n\tmemset(dp,31,sizeof(dp));\n\tdp[tmp]=0; \n\tfor(int i=tmp;i>0;i-=2)\n\t\tif(dp[i]<20000000)\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tfor(int k=j+1;k<16;k++)\n\t\t\t\t\tif((i|(1<<j))==i&&(i|(1<<k))==i)\n\t\t\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t\t\t\tif(((j&k)|l)==(j&k))\n\t\t\t\t\t\t\t\tdp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]=min(dp[i]+1+bool((i&(1<<(j^l)))!=0)+\n\t\t\t\t\t\t\t\tbool((i&(1<<(k^l)))!=0),dp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]);\n\tcout<<ans+dp[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <queue>\n#include <iomanip>\n#include <algorithm>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 100005;\nconst int Maxm = 16;\n\nint n;\nint my[Maxn];\nint got[1 << Maxm];\nint cnt[1 << Maxm];\nll res;\n\nvoid Gen(int lvl, int mask1, int mask2, int cand)\n{\n\tif (lvl >= Maxm) {\n\t\tif (mask2 && cand == 0)\n\t\t\tgot[mask1] = min(got[mask1], got[mask1 ^ mask2] + __builtin_popcount(mask2) - 1);\n\t} else {\n\t\tGen(lvl + 1, mask1, mask2, cand);\n\t\tGen(lvl + 1, mask1 | (1 << lvl), mask2, cand);\n\t\tGen(lvl + 1, mask1 | (1 << lvl), mask2 | (1 << lvl), (cand ^ lvl));\n\t}\n}\n\nint main()\n{\n\tfill(got, got + (1 << Maxm), Maxn);\n\tgot[0] = 0;\n\tGen(1, 0, 0, 0);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b, c; scanf(\"%d %d %d\", &a, &b, &c);\n\t\tmy[a] ^= c; my[b] ^= c;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (my[i] != 0) cnt[my[i]]++;\n\tint lft = 0;\n\tfor (int i = 0; i < 1 << Maxm; i++) {\n\t\tres += cnt[i] / 2;\n\t\tif (cnt[i] % 2) lft |= 1 << i;\n\t}\n\tres += got[lft];\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,p[20],cnt[20],f[1<<16];\nbool good[1<<16];\nvector<pii> g[N];\n\ninline int dfs(int x,int F=-1,int w=0){\n\tint res=w;\n\tfor(auto i:g[x]){\n\t\tint y=i.FF;\n\t\tif(y==F) continue;\n\t\tres^=dfs(y,x,i.SS);\n\t}\n\tcnt[res]++;\n\treturn w;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\tg[x].pb(mp(y,z));g[y].pb(mp(x,z));\n\t}\n\tdfs(0);\n\tint ans=0;\n\tfor(int i=1;i<16;i++)\n\t\tans+=(cnt[i]+1)/2,cnt[i]&=1;\n\tfor(int i=0;i<16;i++)\n\t\tdprintf(\"%d \",i?cnt[i]:0);dprintf(\"\\n\");\n\tfor(int i=1;i<16;i++)\n\t\tif(cnt[i]) p[m++]=i;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tint res=0;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(i&(1<<j)) res^=p[j];\n\t\tif(!res) good[i]=1;\n\t}\n//\tdebug(good[7]);\n\tfor(int i=1;i<(1<<m);i++){\n\t\tif(!good[i]) continue;\n\t\tfor(int u=(1<<m)-1^i,j=u;j;j=(j-1)&u)\n\t\t\tgmax(f[i|j],f[j]+1);\n\t\tgmax(f[i],1);\n\t}\n\tint mx=0;\n\tfor(int i=1;i<(1<<m);i++)\n\t\tgmax(mx,f[i]);\n\tprint(ans-mx);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint read() {\n\tint w = 1,res = 0;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') w = -1;\n\t\tch = getchar();\n\t}\n\twhile(ch >= '0' && ch <= '9') res = res * 10 + ch - '0', ch = getchar();\n\treturn w * res;\n}\nint w[200010], cnt[200010], res, st, d[66000], xr[66000], m = 1 << 15;\nint main() {\n\tint n = read();\n\tfor(int i = 1; i < n; i ++) {\n\t\tint u = read(), v = read(), val = read();\n\t\tw[u] = w[u] ^ val;\n\t\tw[v] = w[v] ^ val;\n\t}\n\tfor(int i = 0; i < n; i ++) cnt[w[i]] ++;\n\tfor(int i = 1; i <= 15; i ++) res += cnt[i] / 2, st = st | (cnt[i] & 1) << (i - 1);\n\tfor(int i = 1; i < m; i ++) d[i] = d[i >> 1] + (i & 1);\n\tfor(int i = 1; i < m; i ++) d[i] -= 1;\n\tfor(int i = 1; i < m; i ++)\n\t\tfor(int j = 0; j < 15; j ++) if((i >> j) & 1) xr[i] = xr[i] ^ (j + 1);\n\tfor(int i = 1; i < m; i ++) {\n\t\tif(xr[i] != 0) continue;\n\t\tfor(int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\t\tif(xr[j] == 0) d[i] = min(d[i], d[j] + d[i ^ j]);\n\t}\n\tprintf(\"%d\", res + d[st]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define mpr make_pair\n#define pii pair<int,int>\n\ntypedef long long ll;\nconst int maxn = 1e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, s;\nint cnt[maxn], a[maxn], dp[maxn];\n\nsigned main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    for(int i = 1, u, v, w; i < n; i++)\n    {\n        cin>> u >> v >> w; u++; v++;\n        (a[v] ^= w);\n        (a[u] ^= w);\n    }\n    for(int v = 1; v <= n; v++) cnt[a[v]]++;\n\n    /// dp = maximum tedad daste\n    for(int msk = 0; msk < (1<<15); msk++)\n    {\n        dp[msk] = -inf;\n        int X = 0, id, is = 0;\n        for(int i = 0; i < 15; i++)\n            if((1<<i) & msk)\n            {\n                if(cnt[i]&1) (X ^= i);\n                if(cnt[i]) is = 1;\n                id = i;\n            }\n\n        if(X == 0 && msk > 0)\n        {\n            if(__builtin_popcount(msk) == 1)\n            {\n                dp[msk] = cnt[id]/2;\n                if(id == 0) dp[msk] = cnt[id];\n            }\n            else\n            {\n                dp[msk] = 1 * is;\n                for(int s = ((msk-1)&msk); s; s = ((s-1)&msk))\n                    dp[msk] = max(dp[msk], dp[s] + dp[msk^s]);\n            }\n        }\n    }\n\n    int msk = (1<<15)-1;\n    cout<< n-dp[msk];\n}\n\n/*\n2\nT 30\nW 1\n3\nT 1\nW 1\nT 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    a[x] ^= z;\n    a[y] ^= z;\n  }\n  vector<int> cnt(16);\n  for (int i = 0; i < n; i++) {\n    ++cnt[a[i]];\n  }\n  int res = 0;\n  int have = 0;\n  for (int i = 1; i < 16; i++) {\n    res += cnt[i] / 2;\n    cnt[i] &= 1;\n    have |= (cnt[i] << i);\n  }\n  vector<bool> ok(1 << 16);\n  for (int mask = 0; mask < (1 << 16); mask++) {\n    int here = 0;\n    for (int i = 0; i < 16; i++) {\n      if ((mask >> i) & 1) {\n        here ^= i;\n      }\n    }\n    ok[mask] = (here == 0);\n  }\n  vector<int> dp(1 << 16);\n  for (int mask = 1; mask < (1 << 16); mask++) {\n    if (mask & 1) continue;\n    for (int smsk = mask; smsk > 0; smsk = (smsk - 1) & mask) {\n      if (ok[smsk]) {\n        dp[mask] = max(dp[mask], dp[mask ^ smsk] + 1);\n      }\n    }\n  }\n  cout << res + __builtin_popcount(have) - dp[have] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 100000;\nconst int S = 1 << 16;\n\nint n;\nint val[N + 5];\nbool can[S + 5];\nint dp[S + 5], cnt[16];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        static int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        ++ cnt[val[i]];\n    }\n\n    int ans = 0, mask = 0;\n    for(int i = 1; i < 16; ++i) {\n        ans += cnt[i] / 2;\n        if(cnt[i] &= 1) mask |= 1 << i;\n    }\n\n    for(int i = 0; i < S; ++i) {\n        int res = 0;\n        for(int j = 0; j < 16; ++j) if(i >> j & 1) res ^= j;\n        if(res == 0) can[i] = true;\n    }\n\n    for(int i = 0; i < S; ++i) {\n        for(int j = i; j; j = (j - 1) & i) \n            if(can[j]) { chkmax(dp[i], dp[i ^ j] + 1); }\n    }\n\n    printf(\"%d\\n\", ans + __builtin_popcount(mask) - dp[mask]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\nconst int N = 1e5+7;\n\nint n, s, ans;\n\nint x[N];\nint sub[1<<15];\nint dp[1<<15];\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t++a;\n\t\t++b;\n\t\tx[a] ^= c;\n\t\tx[b] ^= c;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(!x[i])\n\t\t\t++ans;\n\t\telse \n\t\t{\n\t\t\ts ^= 1<<x[i];\n\n\t\t\tif((s&(1<<x[i]))==0)\n\t\t\t\t++ans;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 1<<15; ++i)\n\t{\n\t\tfor(int j = 0; j < 15; ++j)\n\t\t{\n\t\t\tif(i&(1<<j))\n\t\t\t\tsub[i] ^= j+1;\n\t\t}\n\n\t\tdp[i] = inf;\n\t}\n\n\tdp[0] = 0;\n\n\tfor(int i = 1; i < 1<<15; ++i)\n\t{\n\t\tfor(int j = i; j > 0; j = (j-1)&i)\n\t\t{\n\t\t\tif(!sub[j])\n\t\t\t\tdp[i] = min(dp[i], dp[i^j]+1);\n\t\t}\n\t}\n\n\tcout << n-ans-dp[s>>1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\ntypedef long long ll;\n#define inc(i) (++ (i))\n#define dec(i) (-- (i))\n#define Rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i <= i##Limit ; inc(i))\n#define rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i >= i##Limit ; dec(i))\n#define Eep(i , u , v) for(int i = Head[u] , v = Node[i] ; i ; v = Node[i = Next[i]])\nusing namespace std;\n\nconst int N = 100000 + 7 , M = 16;\nint n , tot[M] , Dp[(1 << 16) + 7] , W[N] , Sum[N];\n\nint main() {\n\tint u , v , w , S = 0 , Ret = 0;\n\tscanf(\"%d\" , &n);\n\tRep(i , 2 , n) scanf(\"%d%d%d\" , &u , &v , &w) , W[u + 1] ^= w , W[v + 1] ^= w;\n\tRep(i , 1 , n) inc(tot[W[i]]);\n\tRep(i , 1 , 15) Ret += tot[i] / 2 , S |= (tot[i] & 1) << i;\n\tRep(i , 1 , (1 << 16) - 1) Dp[i] = Dp[i >> 1] + (i & 1);\n\tRep(i , 1 , (1 << 16) - 1) Dp[i] -= 1;\n\tRep(i , 1 , (1 << 16) - 1)\n\t\tRep(j , 0 , 15) if((i >> j) & 1) Sum[i] ^= j;\n\tRep(i , 1 , (1 << 16) - 1) if(!Sum[i]) {\n\t\tfor(int k = i & (i - 1) ; k ; k = (k - 1) & i)\n\t\t\tif(!Sum[k]) Dp[i] = min(Dp[i] , Dp[i ^ k] + Dp[k]);\n\t}\n\tprintf(\"%d\" , Ret + Dp[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define INF 0x3FFFFFFF\nusing namespace std;\nint a[MAXN],w[MAXN],dp[MAXN];\nint u,v,val;\nint dfs(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s])\n\t\treturn dp[s];\n\tdp[s]=INF;\n\tfor(int i=1;i<16;i++)\n\t\tif(s&(1<<i)){\n\t\t\tfor(int j=1;j<16;j++){\n\t\t\t\tif(j!=i&&(s&(1<<j))){\n\t\t\t\t\tint q=i^j;\n\t\t\t\t\tif(s&(1<<q))\n\t\t\t\t\t\tdp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<q))+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<q))+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n}\nint main(){\n\tint S,n,ans=0;\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tSF(\"%d%d%d\",&u,&v,&val);\n\t\ta[u]^=val;\n\t\ta[v]^=val;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tw[a[i]]++;\n\tfor(int i=1;i<16;i++){\n\t\tans+=w[i]/2;\n\t\tif(w[i]%2==1)\n\t\t\tS^=(1<<i);\n\t}\n\tPF(\"%d\",ans+dfs(S));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(ll i=a;i<b;i++)\n#define Ford(i,a,b) for(ll i=a;i>=b;i--)\n#define RET(x) { cout << x; exit(0); }\n#define smin(a,b) a=min(a,b)\n#define smax(a,b) a=max(a,b)\n#define SZ(x) ((ll)((x).size()))\n#define PB push_back\n#define ER(x) cout << #x << ' ' << x << '\\n';\n#define X first\n#define Y second\n\ntypedef long long int LL;\ntypedef LL ll;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n\nconst ll M=1e5+5,LG=30,mod=924844033;\nll pw(ll x,ll y){ if (y==0) return 1; return pw(x*x%mod,y/2)*(y&1?x:1)%mod; }\n\n#define MOK(x) if (x>=mod) x-=mod;\n\n\nvll g[M];\nll uu[M],vv[M],ww[M];\nll n;\nll co[LG];\n\nll nwbk[LG],nw[LG];\n\n\nll bu(){\n  ll res=0;\n  For(i,1,16){\n    if (nw[i]) res+=(1<<(i-1));\n  }\n  return res;\n}\n\nvoid backup(){\n  For(i,1,16) nwbk[i]=nw[i];\n}\n\nvoid unpack(){\n  For(i,1,16) nw[i]=nwbk[i];\n}\n\nll dfs(ll x,ll p){\n  ll s=0;\n  for (ll e:g[x]){\n    ll y=uu[e]^vv[e]^x;\n    if (y==p){\n      s^=ww[e];\n      continue;\n    }\n    s^=dfs(y,x);\n  }\n  co[s]++;\n  return s;\n}\n\nvector<pll> gd[M];\nll qu[M],qh,qt;\nll vis[M];\nll dp[M];\n\nvoid dpupd(){\n  For(i,0,1<<15){\n    For(j,1,16){\n      nw[j]=(i>>(j-1)&1);\n    }\n    For(j,1,16){\n      if (!nw[j]) continue;\n      nw[j]=0;\n      //ER(i);ER(bu());\n      gd[bu()].PB({i,1});\n      nw[j]=1;\n    }\n    For(a,1,16) For(b,a+1,16){\n      if (!nw[a] || !nw[b]) continue;\n      For(c,1,16){\n\tbackup();\n\tnw[a]=0;\n\tnw[b]=0;\n\tll ap=a^c;\n\tll bp=b^c;\n\tll r=1;\n\tif (nw[ap]){\n\t  r++;\n\t  nw[ap]=0;\n\t}\n\telse{\n\t  nw[ap]=1;\n\t}\n\tif (nw[bp]){\n\t  r++;\n\t  nw[bp]=0;\n\t}\n\telse{\n\t  nw[bp]=1;\n\t}\n\tgd[bu()].PB({i,r});\n\tunpack();\n      }\n    }\n  }\n  memset(dp,31,sizeof dp);\n  qu[0]=0;\n  dp[0]=0;\n  qh=0;\n  qt=1;\n  while (qh!=qt){\n    ll u=qu[qh++];\n    vis[u]=0;\n    for (pll e:gd[u]){\n      ll v=e.X;\n      ll rd=dp[u]+e.Y;\n      if (dp[v]<=rd) continue;\n      dp[v]=rd;\n      if (!vis[v]){\n\tvis[v]=1;\n\tqu[qt++]=v;\n      }\n    }\n  }\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin >> n;\n  For(i,1,n){\n    ll u,v,w;\n    cin >> u >> v >> w;\n    uu[i]=u;vv[i]=v;ww[i]=w;\n    g[u].PB(i);\n    g[v].PB(i);\n  }\n  co[dfs(0,0)]--;\n  ll res=0;\n  ll mymsk=0;\n  For(i,1,16){\n    //ER(i);ER(co[i]);\n    res+=co[i]/2;\n    co[i]=co[i]%2;\n    if (co[i])\n      mymsk+=1<<(i-1);\n  }\n  dpupd();\n  ER(mymsk);ER(dp[mymsk]);\n  res+=dp[mymsk];\n  RET(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Set(a,b) memset(a,b,sizeof(a))\ntemplate<class T>inline void init(T&x){\n\tx=0;char ch=getchar();bool t=0;\n\tfor(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);\n\tif(t) x=-x;return;\n}typedef long long ll;\nconst int N=1e5+10;\nstruct edge{\n\tint to,next,w;\n}a[N<<1];\nint head[N],cnt=0;\ninline void add(int x,int y,int w){a[++cnt]=(edge){y,head[x],w};head[x]=cnt;}\nint ans=0,n;\nint bac[20];\nvoid dfs(int u,int fa,int fr){\n\tint x=fr;\n\tfor(int v,i=head[u];i;i=a[i].next) {v=a[i].to;if(v==fa) continue;x^=a[i].w;dfs(v,u,a[i].w);}\n\t++bac[x];\n}\nint dp[1<<16];\ninline int DP(int s){\n\tif(~dp[s]) return dp[s];\n\tdp[s]=1e9;\n\tfor(int i=1;i<16;++i) {\n\t\tif(s&(1<<i)) {\n\t\t\tfor(int j=i+1;j<16;++j) {\n\t\t\t\tif(s&(1<<j)) {\n\t\t\t\t\tint t=s^(1<<i)^(1<<j);\n\t\t\t\t\tint k=i^j;int f=1;\n\t\t\t\t\tif(t&(1<<k)) t^=1<<k,++f;\n\t\t\t\t\telse t|=1<<k;\n\t\t\t\t\tf+=DP(t);dp[s]=min(dp[s],f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tinit(n);Set(dp,-1);\n\tfor(int i=1;i<n;++i) {\n\t\tint u,v,w;init(u),init(v),init(w);\n\t\t++u,++v;add(u,v,w),add(v,u,w);\n\t}dfs(1,0,0);\n\tint ans=0;int s=0;\n\tdp[0]=0;\n\tfor(int i=1;i<16;++i) {ans+=bac[i]>>1;bac[i]&=1;if(bac[i]) s|=1<<i;}\n\tans+=DP(s);cout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <climits>\n#include <functional>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <time.h>\n#include <utility>\n#include <vector>\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\n\nstruct edge {\n\tuint32 to;\n\tuint32 a;\n};\n\nint main(void) {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tuint32 n;\n\tstd::cin >> n;\n\tstd::vector<std::vector<edge>> G(n);\n\tuint32 tx, ty, ta;\n\tfor (uint32 i = 1;i < n;++i) {\n\t\tstd::cin >> tx >> ty >> ta;\n\t\tG[tx].push_back({ ty,ta });\n\t\tG[ty].push_back({ tx,ta });\n\t}\n\tstd::vector<uint32[15]> dp(n);\n\tstd::vector<uint32> D(n);\n\tuint32 m;\n\tstd::function<void(uint32, uint32)> dfs = [&](uint32 node, uint32 prev) {\n\t\tfor (uint32 i = 0;i < 16;++i) {\n\t\t\tdp[node][i] = 0;\n\t\t}\n\t\tD[node] = 0;\n\t\tuint32 temp;\n\t\tfor (uint32 i = 0;i < G[node].size();++i) {\n\t\t\tuint32 e = G[node][i].to;\n\t\t\tif (e == prev) continue;\n\t\t\tdfs(e, node);\n\t\t\tD[node]+= D[e];\n\t\t\ttemp = G[node][i].a;\n\t\t\tfor (uint32 j = 0;j < 16;++j) {\n\t\t\t\tif (dp[e][j]) {\n\t\t\t\t\tif (dp[node][j]) {\n\t\t\t\t\t\tdp[node][j] = 0;\n\t\t\t\t\t\t--D[node];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[node][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\ttemp ^= j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp == m) continue;\n\t\t\tif (dp[node][temp^m]) {\n\t\t\t\tdp[node][temp^m] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[node][temp^m] = 1;\n\t\t\t\t++D[node];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t};\n\tuint32 ans = UINT32_MAX;\n\tfor (uint32 i = 0;i < 16;++i) {\n\t\tm = i;\n\t\tdfs(0, n);\n\t\tans = std::min(ans, D[0]);\n\t}\n\tstd::cout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e5 + 5, MAXS = ( 1 << 16 ) + 5;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MIN( const _T a, const _T b )\n{\n\treturn a < b ? a : b;\n}\n\nint f[MAXS];\nint w[MAXN];\nint N, cnt;\nbool vis[MAXS];\n\nbool chk( const int S, const int b ) { return S >> b & 1; }\n\nint DFS( const int S )\n{\n\tif( ! S ) return f[S] = 0;\n\tif( vis[S] ) return f[S];\n\tvis[S] = true;\n\tfor( int i = 1 ; i <= 15 ; i ++ )\n\t\tfor( int j = i + 1 ; j <= 15 ; j ++ )\n\t\t\tif( chk( S, i - 1 ) && chk( S, j - 1 ) )\n\t\t\t{\n\t\t\t\tint t = S ^ ( 1 << i - 1 ) ^ ( 1 << j - 1 );\n\t\t\t\tint v = i ^ j, nxt = t ^ ( 1 << v - 1 );\n\t\t\t\tf[S] = MIN( f[S], DFS( nxt ) + 1 + chk( t, v - 1 ) );\n\t\t\t}\n\treturn f[S];\n}\n\nint main()\n{\n\tread( N );\n\tfor( int i = 1, x, y, b ; i < N ; i ++ )\n\t\tread( x ), read( y ), read( b ),\n\t\tw[x + 1] ^= b, w[y + 1] ^= b;\n\tint sta = 0, tot = 0;\n\tfor( int i = 1 ; i <= N ; i ++ )\n\t\tif( w[i] )\n\t\t\ttot += ( sta >> w[i] - 1 ) & 1, \n\t\t\tsta ^= 1 << w[i] - 1;\n\tmemset( f, 0x3f, sizeof f );\n\twrite( DFS( sta ) + tot ), putchar( '\\n' ); \n\treturn 0;\n}\n/*\n3\n0 1 1\n0 2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std ;\nint n ;\nconst int N = 1e5 + 10 ;\nconst int M = 1 << 17 ;\nint s[N] , S , ans , f[M] , inf , sum[20] ;\n \ninline int dfs(int S) {\n  if(! S) return 0 ;\n  if(f[S] < inf) return f[S] ;\n  for(register int i = 0 ; i < 16 ; i ++)\n    if(S & (1 << i)) {\n      for(register int j = 0 ; j < 16 ; j ++)\n        if(i != j && (S & (1 << j))) {\n          int p = i ^ j ;\n          int x = S ^ (1 << i) ^ (1 << j) ^ (1 << p) ;\n          if(S & (1 << p)) { f[S] = min(f[S] , dfs(x) + 2) ; }\n          else { f[S] = min(f[S] , dfs(x) + 1) ; }\n        }\n    }\n    return f[S] ;\n}\nsigned main(){\n  ios :: sync_with_stdio(false) ;\n  cin.tie(0) ;\n  cout.tie(0) ;\n  cin >> n ;\n  for(register int i = 1 ; i < n ; i ++) { int a , b , c ; cin >> a >> b >> c ; s[a] ^= c ; s[b] ^= c ; }\n  for(register int i = 0 ; i < n ; i ++) { sum[s[i]] ++ ; }\n  for(register int i = 1 ; i < 16 ; i ++)\n    ans += (sum[i] >> 1) , S += (1 << i) * (sum[i] & 1) ;\n  memset(f , 0x7f , sizeof(f)) ; inf = f[0] ;\n  cout << ans + dfs(S) << '\\n' ;\n}\n/*\n5\n0 1 1\n0 2 3\n0 3 6\n3 4 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#define SIZE 100005\n#define MX 20\n#define BT (1<<16)+5\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct edge\n{\n\tint to,cost;\n\tedge(int to=0,int cost=0):to(to),cost(cost){}\n};\nvector <edge> vec[SIZE];\nint A[SIZE];\nint dp[BT],rv[MX];\nint nw[BT];\nint nm[MX];\n\nint dfs(int v=0,int p=-1)\n{\n\tint all=0;\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tedge e=vec[v][i];\n\t\tif(e.to!=p)\n\t\t{\n\t\t\tint g=dfs(e.to,v);\n\t\t\tA[e.to]=g^e.cost;\n\t\t\tall^=A[e.to];\n\t\t}\n\t}\n\treturn all;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y,a;\n\t\tscanf(\"%d %d %d\",&x,&y,&a);\n\t\tvec[x].push_back(edge(y,a));\n\t\tvec[y].push_back(edge(x,a));\n\t}\n\tdfs();\n\t//for(int i=1;i<n;i++) printf(\"%d\\n\",A[i]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tnm[A[i]]++;\n\t}\n\tint ret=nm[0];\n\tfor(int i=1;i<MX;i++)\n\t{\n\t\tret+=nm[i]/2;\n\t\tnm[i]%=2;\n\t}\n\tvector <int> vt;\n\tfor(int i=1;i<MX;i++) if(nm[i]==1) vt.push_back(i);\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(rv,-1,sizeof(rv));\n\tfor(int i=0;i<vt.size();i++) rv[vt[i]]=i;\n\tdp[0]=0;\n\tfor(int i=0;i<vt.size();i++)\n\t{\n\t\tmemset(nw,-1,sizeof(nw));\n\t\tfor(int S=0;S<1<<i;S++)\n\t\t{\n\t\t\tif(dp[S]==-1) continue;\n\t\t\tnw[S|1<<i]=max(nw[S|1<<i],dp[S]);\n\t\t\tfor(int a=0;a<i;a++)\n\t\t\t{\n\t\t\t\tif(!(S>>a&1)) continue;\n\t\t\t\tfor(int b=a+1;b<i;b++)\n\t\t\t\t{\n\t\t\t\t\tif(!(S>>b&1)) continue;\n\t\t\t\t\tif(vt[a]^vt[b]^vt[i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b);\n\t\t\t\t\t\tnw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=b+1;c<i;c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(S>>c&1)) continue;\n\t\t\t\t\t\tint t=vt[a]^vt[b]^vt[c];\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b)-(1<<c);\n\t\t\t\t\t\tif(t^vt[i]==0) nw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt^=vt[i];\n\t\t\t\t\t\t\tif(rv[t]!=-1&&(T>>rv[t]&1))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint K=T-(1<<rv[t]);\n\t\t\t\t\t\t\t\tnw[K]=max(nw[K],dp[S]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int S=0;S<1<<(i+1);S++) dp[S]=nw[S];\n\t}\n\tint mx=0;\n\tfor(int i=0;i<BT;i++) mx=max(mx,dp[i]);\n\tprintf(\"%d\\n\",n-1-ret-mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n#include<set>\nusing namespace std;\nint cnt[16], val[100005], Xor[1<<15], num[1<<15], dp[1<<15];\n\ninline int read()\n{\n    int x=0,f=1; char ch=getchar();\n    for (; ch<'0' || ch>'9'; ch=getchar()) if (ch=='-') f=-1;\n    for (; ch>='0' && ch<='9'; ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\n\nint main()\n{\n    int n=read(), ans=0, sta=0;\n    for (int i=1; i<n; i++) \n    {\n        int u=read(), v=read(), w=read();\n        val[u]^=w; val[v]^=w;\n    }\n    for (int i=1; i<=n; i++) cnt[val[i]]++;\n    for (int i=0; i<=15; i++) ans+=cnt[i]/2, sta|=(cnt[i]&1)<<(i-1);\n    for (int i=0; i<(1<<15); i++) num[i]=num[i>>1]+(i&1);\n    for (int i=0; i<(1<<15); i++) dp[i]=num[i]-1;\n    for (int i=0; i<(1<<15); i++) \n        for (int j=1; j<=15; j++) if ((i>>(j-1))&1) Xor[i]^=j;\n    for (int i=0; i<(1<<15); i++)\n        if (!Xor[i])\n            for (int j=i; j; j=(j-1)&i)\n                if (!Xor[j]) dp[i]=dp[j]+dp[i^j];\n    ans+=dp[sta];\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cassert>\n \ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n \nconst int MAXN=1E5+10;\n \nint n,val[MAXN],S;\nint cnt[20],ans,f[1<<16];\nint stk[20],top,bin[20];\n \nint main()\n{\n    scanf(\"%d\",&n);memset(f,0x3f,sizeof f);\n    bin[0]=1;\n    for(int i=1;i<=15;i++) bin[i]=bin[i-1]<<1;\n    for(int i=1,u,v,w;i<n;i++)\n        scanf(\"%d%d%d\",&u,&v,&w),++u,++v,val[u]^=w,val[v]^=w;\n    for(int i=1;i<=n;i++) cnt[val[i]]++;\n    for(int i=1;i<=15;i++) ans+=cnt[i]>>1,S|=(cnt[i]&1)<<i;\n    f[0]=0;\n    for(int l=1;l<=15;l++)\n        for(int s=0;s<(1<<16);s++)\n            if(__builtin_popcount(s)==l&&(s&1)==0)\n                {\n                    top=0;\n                    for(int i=1;i<16;i++) if((s>>i)&1) stk[++top]=i;\n                    for(int i=1;i<=top;i++)\n                        for(int j=i+1;j<=top;j++)\n                            f[s]=min(f[s],f[s^bin[stk[i]]^bin[stk[j]]^bin[stk[i]^stk[j]]]+1+((s>>(stk[i]^stk[j]))&1));\n                }\n    printf(\"%d\\n\",f[S]+ans);\n    #ifdef LOCAL\n        system(\"pause\");\n    #endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst char nl = '\\n';\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> pt;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5+10, B = 16;\n\nint val[N];\nint dp[1 << B];\n\nint solve(int bm) {\n    if (!bm) return 0;\n    if (dp[bm] != -1) return dp[bm];\n    //dp[bm] = INF;\n    int ans = INF;\n    for (int i = 0; i < B; i++) {\n        if (!(bm & (1 << i))) continue;\n        for (int j = i+1; j < B; j++) {\n            if (!(bm & (1 << j)) ) continue;\n            int nbm = bm ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n            bool b = bm & (1 << (i ^ j));\n            ans = min(ans, solve(nbm) + 1 + b);\n        }\n    }\n    return dp[bm] = ans;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int x, y, a; cin >> x >> y >> a;\n        val[x] ^= a;\n        val[y] ^= a;\n    }\n    int ans = 0;\n    int bm = 0;\n    for (int i = 0; i < n; i++) {\n        if (!val[i]) continue;\n        if (bm & (1 << val[i])) ans++;\n        bm ^= 1 << val[i];\n    }\n    memset(dp, -1, sizeof dp);\n    cout << ans + solve(bm) << nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nint dp[1<<16][16];\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    rep(i,n-1){\n        int s,t,c;\n        cin >> s >> t >> c;\n        a[s]^=c;\n        a[t]^=c;\n    }\n    int sm = 0;\n    vector<int> c(16);\n    rep(i,n){\n        c[a[i]]++;\n    }\n    cerr << endl;\n    rep(i,16){\n        sm += c[i]/2;\n        c[i]%=2;\n    }\n    int tar = 0;\n    for(int i=1;i<16;i++){\n        tar ^= (c[i]<<(i-1));\n    }\n    Fill(dp,inf);\n    dp[0][0] = 0;\n    for(int bits=0;bits<(1<<16);bits++){\n        for(int i=0;i<16;i++){\n            for(int j=1;j<16;j++){\n                if((bits>>(j-1))&1)continue;\n                chmin(dp[bits^(1<<(j-1))][i^j],dp[bits][i] + 1);\n            }\n        }\n    }\n    int ss = dp[tar][0];\n    if(ss==0){\n        cout << sm << endl;\n    }else{\n        cout << sm + ss - 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500005\nusing namespace std;\nint n;\nint head[N],ver[N],nxt[N],tot,quan[N];\nvoid add(int a,int b,int c)\n{\n\ttot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;quan[tot]=c;return ;\n}\nint v[20],f[1<<16];\nint g[1<<16];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint t1,t2,t3;\n\tint ans=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&t1,&t2,&t3);\n\t\tv[t3]++;\n\t}\n\tfor(int i=1;i<=15;i++)ans+=v[i]/2,v[i]%=2;\n\tfor(int i=1;i<=15;i++)ans+=v[i];\n//\tcout<<ans<<endl;\n\tv[0]=0;\n\tf[0]=0;\n\tfor(int i=1;i<1<<16;i++)\n\t{\n\t\tbool fl=0;int now=0;\n\t\tfor(int k=0;k<16;k++)\n\t\t{\n\t\t\tif(((1<<k)&i)&&!v[k])fl=1;\n\t\t\tif(((1<<k)&i))now^=k;\n\t\t}\n\t\tif(now==0&&!fl)g[i]=1;\n\t}\n\tfor(int i=1;i<1<<16;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\t\n\t\t\tint now=0;\n\t\t\t\n\t\t//\tcout<<now<<endl;\n\t\t\tif(g[j])f[i]=max(f[i],f[i-j]+1);\n\t\t}\n\t}\n\tint tmp=0;\n\tfor(int i=0;i<=15;i++)if(v[i])tmp^=(1<<i);\n\t\n\tfor(int i=(tmp-1)&tmp;i>0;i=(i-1)&tmp)\n\t{\n\t\tf[tmp]=max(f[tmp],f[i]);\n\t}\n\tcout<<ans-f[tmp]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  scanf(\"%d\", &n);\n\n  vector<int> vals(n);\n  for (int i = 0; i < n-1; i++) {\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    vals[a] ^= c;\n    vals[b] ^= c;\n  }\n\n  int ans = n;\n  int mask = 0;\n  for (int i = 0; i < n; i++) {\n    if (mask & (1 << vals[i])) {\n      ans--;\n    }\n    mask ^= (1 << vals[i]);\n  }\n\n  const int K = 16;\n\n  vector<int> dp(1 << K);\n  for (int i = 0; i < (1 << K); i++) {\n    int v = 0;\n    for (int j = 0; j < K; j++) {\n      if (i & (1 << j)) {\n        v ^= j;\n      }\n    }\n    if (!v) {\n      dp[i] = 1;\n    } else {\n      dp[i] = -1000000;\n    }\n\n    for (int j = (i - 1) & i; j; j = (j - 1) & i) {\n      dp[i] = max(dp[i], dp[j] + dp[i ^ j]);\n    }\n  }\n\n  eprintf(\"ans = %d, mask = %d, dp[mask] = %d\\n\", ans, mask, dp[mask]);\n\n  ans -= dp[mask];\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxm], dp[1 << 16];\nll cnt[maxn];\nll ans;\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << (i - 1));\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[init] = 0;\n    for(int i = 15;i > 0;i--){\n        for(int S = 0;S < (1 << 15);S++){\n            ll cnt = 0;\n            for(int k = 0;k < 15;k++){\n                if((S >> k) & 1) cnt++;\n            }\n            if(cnt != i) continue;\n            // cout << cnt << \" \" << S << endl;\n            for(int k = 0;k < 15;k++){\n                if(!((S >> k) & 1)) continue;\n                for(int w = 0;w < 15;w++){\n                    if(k == w){\n                        dp[S ^ (1 << k)] = min(dp[S ^ (1 << k)], dp[S] + 1);\n                        continue;\n                    }\n                    if(!((S >> w) & 1)) continue;\n                    ll newnum = ((k + 1) ^ (w + 1)) - 1;\n                    if(((S >> newnum) & 1) == 1){\n                        dp[(S ^ (1 << k) ^ (1 << w)) ^ (1 << newnum)] = \n                        min(dp[S ^ (1 << k) ^ (1 << w) ^ (1 << newnum)], dp[S] + 2);\n                    } else {\n                        dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)] = \n                        min(dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)], dp[S] + 1);\n                    }\n                }\n            }\n        }\n    }\n    ans += dp[0];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\nint n ;\nconst int N = 1e5 + 10 ;\nconst int M = 1 << 17 ;\nint s[N] , S , ans , f[M] , inf , sum[20] ;\n\ninline int dfs(int S) {\n  if(! S) return 0 ;\n  if(f[S] < inf) return f[S] ;\n  for(register int i = 0 ; i < 16 ; i ++)\n    if(S & (1 << i)) {\n      for(register int j = 0 ; j < 16 ; j ++)\n        if(i != j && (S & (1 << j))) {\n          int p = i ^ j ;\n          int x = S ^ (1 << i) ^ (1 << j) ^ (1 << p) ;\n          if(S & (1 << p)) { f[S] = min(f[S] , dfs(x) + 2) ; }\n          else { f[S] = min(f[S] , dfs(x) + 1) ; }\n        }\n    }\n    return f[S] ;\n}\nsigned main(){\n  ios :: sync_with_stdio(false) ;\n  cin.tie(0) ;\n  cout.tie(0) ;\n  cin >> n ;\n  for(register int i = 1 ; i < n ; i ++) { int a , b , c ; cin >> a >> b >> c ; s[a] ^= c ; s[b] ^= c ; }\n  for(register int i = 0 ; i < n ; i ++) { sum[s[i]] ++ ; }\n  for(register int i = 1 ; i < 16 ; i ++)\n    ans += (sum[i] >> 1) , S += (1 << i) * (sum[i] & 1) ;\n  memset(f , 0x7f , sizeof(f)) ; inf = f[0] ;\n  cout << ans + dfs(S) << '\\n' ;\n}\n/*\n5\n0 1 1\n0 2 3\n0 3 6\n3 4 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10;  \n\nint n, ans, state, tot; \nint val[maxn], cnt[20], f[maxm], s[maxn], sum[maxm]; \n// sumè¡¨ç¤ºæ¯ä¸ªéåçå¼æå¼\nint main() {\n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z; \n\t\tscanf(\"%d%d%d\", &x, &y, &z); \n\t\tx++, y++; \n\t\tval[x] ^= z, val[y] ^= z; \n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[val[i]]++; \n\tans = n; ans -= cnt[0]; \n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans -= cnt[i] / 2 ; \n\t\tstate += (cnt[i] & 1) * (1 << i); \n\t}\n\ttot = 1 << 15; \n\tfor (int i = 1; i < tot; ++i) {\n\t\tint tmp = 0; \t\n\t\tfor (int j = 1; j <= 15; ++j) {\n\t\t\tif (i & (1 << j)) tmp ^= j; \n\t\t}\n\t\tsum[i] = tmp; \n\t}\n\tfor (int i = 1; i < tot; ++i) {\n\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\tif (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1); \n\t\t}\n\t}\n\tans -= f[state]; \n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\nll N;\nvector<pll> xyav[101010];\nll c[20],P3[20];\nll i,j,k,ans;\nll bdp[1<<16];\n\n\n\nint main(){\n    scanf(\"%lld\",&N);\n    fornum(i,1,N){\n        ll x,y,a;\n        scanf(\"%lld%lld%lld\", &x, &y, &a);\n        xyav[x].push_back({y, a});\n        xyav[y].push_back({x, a});\n    }\n    fornum(i,0,N){\n        ll b=0;\n        fornum(j,0,xyav[i].size()){\n            b ^= xyav[i][j].second;\n        }\n        //printf(\"%lld-%lld\\n\", i, b);\n        c[b]++;\n    }\n    j = 0;\n    k = 99;\n    P3[0] = 1;\n    ans = 1;\n    fornum(i,1,16){\n        //printf(\"%lld,%lld\\n\", i, c[i]);\n        ans += c[i] / 2;\n        c[i] %= 2;\n        if(c[i]){\n            j += 1<<i;\n            //k = min(k, i);\n        }\n        //P3[i] = P3[i - 1] * 3;\n    }\n    bdp[j] = ans;\n    queue<ll> q;\n    q.push(j);\n    while(q.size()){\n        ll qa = q.front();\n        q.pop();\n        //cout << bitset<6>(qa) << \" \"<<bdp[qa]<<\" \"<<q.size()<< endl;\n        if(qa==0){\n            break;\n        }\n        fornum(i,1,16){\n            if(qa&(1<<i)){\n                break;\n            }\n        }\n        ll nxt = qa ^ (1 << i);\n        fornum(j,i+1,16){\n            if(qa&(1<<j)){\n                \n                ll b = i ^ j;\n                ll nxtt = nxt ^ (1 << j) ^ (1 << b);\n                if(nxtt&(1<<b)){\n                    ll a = bdp[qa] + 1;\n                    if(bdp[nxtt]==0){\n                        bdp[nxtt] = a;\n                        q.push(nxtt);\n                    }else{\n                        bdp[nxtt] = min(bdp[nxtt], a);\n                    }\n                }else{\n                    ll a = bdp[qa] + 2;\n                    if(bdp[nxtt]==0){\n                        bdp[nxtt] = a;\n                        q.push(nxtt);\n                    }else{\n                        bdp[nxtt] = min(bdp[nxtt], a);\n                    }\n                }\n                //printf(\" %lld %lld\\n\", j, bdp[nxtt]);\n            }\n        }\n    }\n    printf(\"%lld\", bdp[0] - 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+(k!=0));\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+(j!=0));\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<=15;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+(val!=0));\n            dp[n][i]=min(dp[n][i],temp[i]+(val!=0));\n\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[100010],t[16],ans,S,f[1100010];\nvector<int>g[16];\nint main()\n{\n\tmemset(f,0x3f,sizeof(f));\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1,u,v,w;i<n;i++)scanf(\"%d%d%d\",&u,&v,&w),a[u]^=w,a[v]^=w;\n\tfor(int i=0;i<n;i++)t[a[i]]++;\n\tfor(int i=1;i<16;i++)ans+=(t[i]>>1),S|=(t[i]&1)<<(i-1);\n\tfor(int i=0;i<=S;i++)\n\t{\n\t\tint x=i,ss=0;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)ss++; \n\t\t\tx>>=1;\n\t\t}\n\t\tg[ss].push_back(i);\n\t} \n\tf[S]=0;\n\tfor(int p=15;p>=2;p--)\n\t\tfor(int e=0,s;e<g[p].size();e++)\n\t\t{\n\t\t\ts=g[p][e];if(f[s]==f[S+1])continue;\n\t\t\tfor(int i=1;i<16;i++)if(s&(1<<(i-1)))for(int j=1;j<16;j++)if(i!=j&&(s&(1<<(j-1))))\n\t\t\t{\n\t\t\t\tint a=i^j; \n\t\t\t\tif(s&(1<<(a-1)))f[s-(1<<(i-1))-(1<<(j-1))-(1<<(a-1))]=min(f[s-(1<<(i-1))-(1<<(j-1))-(1<<(a-1))],f[s]+2);\n\t\t\t\telse f[s-(1<<(i-1))-(1<<(j-1))+(1<<(a-1))]=min(f[s-(1<<(i-1))-(1<<(j-1))+(1<<(a-1))],f[s]+1);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 200005\nint n;\nint v[MN];\nint t[16];\nint dp[MN];\nint r[MN];\nint main(){\n\tread(n);\n\tfor(int i=1,x,y,z;i<n;++i){\n\t\tread(x);read(y);read(z);\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tfor(int i=0;i<n;++i)++t[v[i]];\n\tint res=0;\n\tint h=0;\n\tfor(int i=1;i<16;++i){\n\t\tres+=(t[i]+1)/2;t[i]%=2;h|=t[i]*(1<<i);\n\t}\n\tmemset(dp,-0x3f,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=0;i<h;++i){\n\t\tfor(int j=0;j<16;++j)if((1<<j)&i){\n\t\t\tr[i]^=j;\n\t\t}\n\t}\n\tfor(int i=0;i<h;++i)if(dp[i]>=0){\n\t\tint S=h-i;\n\t\tfor(int j=S;j;j=S&(j-1))if(r[j]==0){\n\t\t\tdp[i+j]=max(dp[i]+1,dp[i+j]);\n\t\t}\n\t}\n\tcout<<res-dp[h];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Int register int\n#define INF 0x3f3f3f3f\n#define MAXN 100005\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nint n,val[MAXN],tong[16],f[1 << 16];\n\nint count (int S){//ç»è®¡Sä¸­1çä¸ªæ°\n\tint sum = 0;\n\tfor (Int i = 0;(1 << i) <= S;++ i) sum += (S >> i & 1); \n\treturn sum;\n}\n\nint Sum (int S){\n\tint sum = 0;\n\tfor (Int i = 0;(1 << i) <= S;++ i) if (S >> i & 1) sum ^= i;\n\treturn sum;\n} \n\nsigned main(){\n\tread (n);\n\tfor (Int i = 2,u,v,w;i <= n;++ i) read (u,v,w),val[u] ^= w,val[v] ^= w;\n\tint tot = 0;\n\tfor (Int i = 0;i < n;++ i) tong[val[i]] ++;\n\tfor (Int i = 1;i <= 15;++ i) if (tong[i] & 1) tot += (tong[i] - 1) / 2,tong[i] = 1;else tot += tong[i] / 2,tong[i] = 0;\n\tint up = 1 << 16;\n\tfor (Int S = 1;S < up;++ S) f[S] = Sum (S) != 0 ? INF : count (S) - 1;\n\tfor (Int S = 1;S < up;++ S)\n\t\tfor (Int T = (S - 1) & S;T;T = (T - 1) & S)\n\t\t\tf[S] = min (f[S],f[T] + f[S ^ T]);\n\tint now = 0;\n\tfor (Int i = 1;i <= 15;++ i) if (tong[i]) now |= 1 << i;\n\twrite (f[now] + tot),putchar ('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     âââââââââââ\n//                                                                   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                                                                ââââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬âââ\n//                                            âââââââââââ       âââ¬â¬â¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬ââ\n//                                      ââââââââââ¬â¬â¬â¬â¬âââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬ââ\n//                               âââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬ââ\n//                             âââââ¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//                           ââââ¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬ââââ¬â¬â¬â¬â¬â¬â¬âââââ\n//                         ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââââââââ¬â¬â¬â¬â¬ââ\n//                       ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                     ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬ââ\n//                 âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬ââââ\n//     ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬ââââââ\n//   âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬ââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââ¬â¬â¬ââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬ââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââââ¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬â¬â¬âââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬âââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââ\n//   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//       ââââââââââââââ  âââââ¬â¬â¬â¬â¬â¬ââââââââââââââââââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ\n//                         âââââââ                           âââââ  âââââââââââââââââââ  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n,0);\n  REP(_,n-1){\n    int x,y,v;\n    cin >> x >> y >> v;\n    a[x] ^= v;\n    a[y] ^= v;\n  }\n  \n  vec b(16,0);\n  REP(i,n) b[a[i]]++;\n\n  int ans = 0;\n  REP(i,16){\n    if(i) ans += b[i]/2;\n  }\n\n  vec dp(1<<15,-INF); dp[0] = 0;\n  int mask = 0;\n  REP(i,15) if(b[i+1]&1) mask += (1<<i);\n  \n  REP(i,1<<15){\n    int x = mask & (~i);\n    for(;x;x--){\n      x &= mask; int cnt = 0;\n      REP(k,15) if(parity(x,k)) cnt ^= k+1;\n      if(!cnt) chmax(dp[i+x],dp[i]+1); \n    }\n  }\n\n  cout << ans - dp[mask] + pcnt(mask) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\nconst int MaxN=2e5+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[20], d[MaxN];\nbool xr[MaxN];\nint main()\n{\n    int n, ans=0, state=0; read(n);\n    for  (int i=1, x, y, z; i< n; ++i)  read(x, y, z), v[x]^=z, v[y]^=z;\n    for (int i=0; i< n; ++i) ++cnt[v[i]]; //è´ªå¿\n    for (int i=1; i<=15; ++i) ans+=cnt[i]/2, state|=(cnt[i]&1)<<(i-1);\n\n    for (int i=1; i< (1<<15); ++i) d[i]=d[i>>1]+(i&1);\n    for (int i=1; i< (1<<15); ++i) --d[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n    for (int i=1; i< (1<<15); ++i)\n        for (int j=0; j< 15; ++j)\n\t\t\tif ((i>>j)&1) xr[i]^=(j+1);//é¢å¤çéåçå¼æå\n\n    for (int i=1; i< (1<<15); ++i)//æä¸¾å­éè¿è¡è½¬ç§»\n    {\n        if (xr[i]!=0)continue;\n        for (int k=(i-1)&i; k; k=(k-1)&i)\n            if (xr[k]==0) chkMin(d[i], d[k]+d[i^k]);\n    }\n    write(ans+d[state], '\\n');\n    IO::flush();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2e6+1000;\nint n,a[N],f[N],cnt[N],as,st,S,x[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri t1=read()+1,t2=read()+1,z=read();a[t1]^=z;a[t2]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);\n\trp(i,1,S)--f[i];rp(i,1,S)rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200010\nint n,va[N],c[N],ans,s,f[N],ss[N],nm[N];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<N;i++){\n\t\tnm[i]=nm[i-(i&-i)]+1;\n\t\tnm[i]--;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tva[x]^=z;\n\t\tva[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[va[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]%2==1)s|=(1<<(i-1));\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))ss[i]^=(j+1);\n\tmemset(f,63,sizeof(f));\n\tfor(int i=1;i<(1<<15);i++)\n\t\tif(!ss[i])\n\t\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\t\tif(!ss[j]&&!ss[i-j])\n\t\t\t\t\tf[i]=min(f[i],f[i-j]+f[j]);\n\tcout<<ans+f[s];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\nbool book[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tn=1<<15;\n\trp(i,1,n-1)d[i]=d[i>>1]+(i&1);rp(i,1,n-1)d[i]-=1;\n\trp(i,1,n-1){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n\trp(i,1,n-1)\n\t{\n\t\tif(sxr[i]!=0)continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)if(!sxr[k])d[i]=min(d[i],d[k]+d[i^k]);\n\t}\n\tprintf(\"%d\",res+d[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int maxN = 1e5 + 10;\nint nodeN, tot;\nint val[maxN], cntHas[maxN], dp[1 << 16], num[20], xorSum[1 << 16];\n\nint main () {\n\tscanf(\"%d\", &nodeN);\n\tfor (int nodeI = 1; nodeI < nodeN; ++nodeI) {\n\t\tint n1, n2, len;\n\t\tscanf(\"%d%d%d\", &n1, &n2, &len);\n\t\t++n1, ++n2;\n\t\tval[n1] ^= len;\n\t\tval[n2] ^= len;\n\t}\n\tfor (int nodeI = 1; nodeI <= nodeN; ++nodeI) ++cntHas[val[nodeI]];\n\tint ans = 0;\n\tfor (int valI = 1; valI < 16; ++valI) {\n\t\tans += cntHas[valI] >> 1;\n\t\tcntHas[valI] &= 1;\n\t\tif (cntHas[valI] != 0) {\n\t\t\tnum[++tot] = valI;\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\txorSum[stI] ^= num[weiJ + 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] > 0) {\n\t\t\tdp[stI] = 0x3f3f3f3f;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\t++dp[stI];\n\t\t\t}\n\t\t}\n\t\t--dp[stI];\n\t}\n\tdp[0] = 0;\t//dp[0]è¦ç¹æ®å¤ç\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] != 0) continue;\t//è¿éå¼å§åæäº dp[stI]\n\t\tfor (int son = stI & (stI - 1); son; son = stI & (son - 1)) {\n\t\t\tif (xorSum[son] == 0) {\n\t\t\t\tdp[stI] = min(dp[stI], dp[stI ^ son] + dp[son]);\n\t\t\t}\n\t\t}\n\t}\n\tans += dp[(1 << tot) - 1];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> L >> R >> K;\n\t\tv[L] ^= K;\n\t\tv[R] ^= K;\n\t}\n\tvector<int>b(16);\n\tfor (auto i : v) {\n\t\tb[i]++;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tans += b[i] / 2;\n\t\tb[i] %= 2;\n\t}\n\tvector<int>dp(1 << 16, MOD);\n\tint cnt = 0;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tif (b[i]) {\n\t\t\tcnt |= 1 << i;\n\t\t}\n\t}\n\tdp[cnt] = 0;\n\t//cout << cnt << endl;\n\t//cout << ans << endl;\n\tfor (int i = (1 << 16) - 2; i > 0; i -= 2) {\n\t//\tcout << i << endl;\n\t\tfor (int j = 1; j < 16; j++) {\n\t\t\tfor (int k = j + 1; k < 16; k++) {\n\t\t\t\tif (i&(1 << j) && i & (1 << k)) {\n\t\t\t\t\tif (dp[i] != MOD) {\n\t\t\t\t\t//\tcout << i << \" \" << j << \" \" << k << endl;\n\t\t\t\t\t\tfor (int l = 1; l < 16; l++) {\n\t\t\t\t\t\t\tint box = j ^ l;\n\t\t\t\t\t\t\tint bag = k ^ l;\n\t\t\t\t\t\t\tint add = 1;\n\t\t\t\t\t\t\tint cbit = i - (1 << j) - (1 << k);\n\t\t\t\t\t\t\tif (cbit&(1 << box)) {\n\t\t\t\t\t\t\t\tcbit -= 1 << box;\n\t\t\t\t\t\t\t\tadd++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcbit += 1 << box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cbit&(1 << bag)) {\n\t\t\t\t\t\t\t\tcbit -= 1 << bag;\n\t\t\t\t\t\t\t\tadd++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcbit += 1 << bag;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t//\tcout << cbit << endl;\n\t\t\t\t\t\t\tdp[cbit] = min(dp[cbit], dp[i] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0] = min(dp[1], dp[0]);\n\tcout << ans + dp[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int NMAX = 1e5;\nint n;\nint b[NMAX + 5];\nint dp[NMAX + 5];\n\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i = 1;i < n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tx++;\n\t\ty++;\n\t\tb[x] ^= z;\n\t\tb[y] ^= z;\n\t}\n\t\n\tint ans = n;\n\tint mask = 0;\n\t\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(b[i] == 0){\n\t\t\tans--;\n\t\t}\n\t\telse if((mask >> (b[i] - 1)) & 1){\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t\tans--;\n\t\t}\n\t\telse{\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t}\n\t}\n\t\t\n\tdp[0] = 0;\n\t\n\tfor(int i = 1;i <= mask;i++){\n\t\tfor(int j = i;j;j = (j - 1) & i){\n\t\t\tint xo = 0;\n\t\t\t\n\t\t\tfor(int b = 0;b < 15;b++){\n\t\t\t\tif((j >> b) & 1){\n\t\t\t\t\txo ^= b;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(xo == 0){\n\t\t\t\tdp[i] = max(dp[i],1 + dp[i ^ j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans -= dp[mask];\n\t\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n \n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n \ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e5+10, maxm=5e6+10, lg=16, mod=998244353, inf=1e18;\n\nll n,tt[lg],x[maxn],ans,dp[1<<lg],xo[1<<lg];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u,a; cin>>v>>u>>a;\n\t\tx[v]^=a, x[u]^=a;\n\t}\n\tfor(int i=0;i<n;i++) tt[x[i]]++;\n\tvector<ll> a;\n\tans+=tt[0];\n\tfor(int i=1;i<lg;i++){\n\t\tans+=tt[i]/2;\n\t\tif(tt[i]%2) a.pb(i);\n\t}\n\tfor(int msk=1;msk<(1<<SZ(a));msk++){\n\t\tfor(int i=0;i<SZ(a);i++)if(msk>>i&1){ xo[msk]=xo[msk^(1<<i)]^a[i]; break; }\n\t\tfor(int sub=msk;sub;sub=(sub-1)&msk)if(xo[sub]==0) dp[msk]=max(dp[msk],1+dp[msk^sub]);\n\t}\n\tcout<<n-(ans+dp[(1<<SZ(a))-1]);\n\t\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <iterator>\n#include <functional>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <list>\n#include <sstream>\n#include <unordered_map>\n#include <complex>\n#include <stdio.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n\ntypedef double LD;\ntypedef unsigned long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LD, LD> PDD;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VCH;\ntypedef vector<LD> VLD;\ntypedef vector<string> VS;\ntypedef vector<VS> VSS;\ntypedef vector<VI> VVI;\ntypedef vector<VLL> VVLL;\ntypedef vector<VCH> VVCH;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<PDD> VPDD;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n#define next fake_next\n#define prev fake_prev\n#define left fake_left\n#define right fake_right\n\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LD PI = acos(-1.0);\nconst LD EPS = 1e-9;\nconst LL mod = 1000000007;\nconst LL INF = 1e9;\nconst LL LINF = 1e15;\nconst LL MAX = 2e5 + 7;\nconst LL MAXN = 1e5 + 1;\n\nint n;\nvector<vector<PII>> g;\nvector<pair<int, PII>> e;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"Out.txt\", \"w\", stdout);\n\t\n\tcin >> n;\ncout << n - 1;\n\treturn 0;\n\tg.resize(n);\n\tint u, v, w;\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> u >> v >> w;\n\t\tg[u].push_back({ v, w,});\n\t\tg[v].push_back({ u, w });\n\t\te.push_back(MP(w, MP(u, v)));\n\t}\n\n\tcout << n - 1;\n\treturn 0;\n\tint ans = 0;\n\n\n\n\n\n\n\n\n\tcout << ans;\n\tcin >> n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5,S=1<<16,inf=2e9;\nint v[N],cnt[16],dp[S];\ninline int dfs(ri s){\n\tif(dp[s]!=-1) return dp[s];\n\tif(__builtin_popcount(s)==1) return inf;\n\tri i,j,p,t,res=inf;\n\tfor(i=1;i<16;++i)\n\t\tif(s&1<<i)\n\t\t\tfor(j=i+1;j<16;++j)\n\t\t\t\tif(s&1<<j){\n\t\t\t\t\tp=i^j;\n\t\t\t\t\tt=s^1<<i^1<<j^1<<p;\n\t\t\t\t//\tprintf(\"next %d %d\\n\",__builtin_popcount(s),__builtin_popcount(t));\n\t\t\t\t\tif(t&1<<p)\n\t\t\t\t\t\tres=min(res,dfs(t)+1);\n\t\t\t\t\telse\n\t\t\t\t\t\tres=min(res,dfs(t)+2);\n\t\t\t\t}\n//\tprintf(\"dp %d %d\\n\",s,res);\n\treturn dp[s]=res;\n}\nint main(){\n\tri n,i,x,y,c,ans;\n\tgi(n);\n\tfor(i=1;i^n;++i) gi(x),gi(y),gi(c),v[x]^=c,v[y]^=c; \n\tfor(i=0;i<n;++i) ++cnt[v[i]];\n\tc=0;ans=0;\n\tfor(i=1;i<16;++i)\n\t\tans+=cnt[i]>>1,\n\t\tc|=(cnt[i]&1)<<i;\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0]=0;\n//\tprintf(\"c = %d\\n\",c);\n\tprintf(\"%d\\n\",ans+dfs(c));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar buf[1<<20],*fs,*ft;\ninline char getc()\n{return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))? 0 : *fs++;}\ninline long long read()\n{long long s=0,w=1;char ch=getchar();\nwhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\nwhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\nreturn s*w;}\nchar buf1[1<<21],a1[20];int p11,p12=-1;\ninline void flush()\n{fwrite (buf1,1,p12+1,stdout),p12=-1;}\ninline void print(int x)\n{if(p12>1<<20) flush();if(x<0) buf1[++p12]=45,x=-x;\ndo{a1[++p11]=x%10+48;}while(x/=10);\ndo{buf1[++p12]=a1[p11];}while(--p11);buf1[++p12]='\\n';}\nint n,val[100100],b[20],ans=0,stat=0;\nint sum[(1<<16)],xr[(1<<16)];\nint main()\n{\n\tmemset(b,0,sizeof(b));\n\tmemset(xr,0,sizeof(xr));\n\tmemset(val,0,sizeof(val));\n\tn=read();\n\tint i=1,j=1,k=1;\n\twhile(i<n)\n\t{\n\t\tint u,v,l;\n\t\tu=read();\n\t\tv=read();\n\t\tl=read();\n\t\t++u;\n\t\t++v;\n\t\tval[u]^=l;\n\t\tval[v]^=l;\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<=n)\n\t{\n\t\t++b[val[i]];\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<=15)\n\t{\n\t\tans+=b[i]/2;\n\t\tb[i]%=2;\n\t\tstat|=b[i]<<(i-1);\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\tsum[i]=sum[i>>1]+(i&1);\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\t--sum[i];\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\tj=1;\n\t\twhile(j<=15)\n\t\t{\n\t\t\tif(i&(1<<(j-1))) xr[i]^=j;\n\t\t\t++j;\n\t\t}\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\tif(!xr[i])\n\t\t{\n\t\t\tk=(i-1)&i;\n        \twhile(k)\n        \t{\n            \tif(xr[k]==0) sum[i]=min(sum[i],sum[k]+sum[i^k]);\n            \tk=(k-1)&i;\n            }\n        }\n\t\t++i;\n\t}\n\tprintf(\"%d\\n\",ans+sum[stat]);\n\treturn 0;\n}\n/*\nBZOJ 1833 ZJOI2010 Count\n??????\nHdu4734 f(x)\nCf 55D Beautiful Number\nCf 388D Fox and Perfect Sets\n2012 Multi-University Training Contest 6 ???????LIS???\nTopCoder Rainbow Graph\nTopCoder CheeseRolling\nAtCoder 058E Iroha and Haiku\nAtCoder XOR Tree\nCodeforces 165E\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n\nint n, cnt[16], ans, now, f[101000], g[77777];\nvector<pii>G[101000], vec;\nvoid U(int &x,int y){ x=min(x,y); }\n\nvoid dfs(int x,int fff,int lasv){\n  for (auto y:G[x]){\n    if (y.fi==fff) continue;\n    dfs(y.fi,x,y.se);\n  }\n  lasv^=f[x];\n  if (fff&&lasv){\n    ++cnt[lasv];\n    f[fff]^=lasv;\n  }\n}\n\nint main(){\n  memset(g,33,sizeof g); g[0]=0;\n  for (int i=2;i<(1<<16);i+=2){\n    int x=0, c=-1;\n    for (int j=1;j<16;++j)\n      if (i>>j&1)\n        x^=j, ++c;\n    if (!x) vec.push_back((pii){i,c});\n  }\n  for (int i=1;i<16;++i) vec.push_back((pii){1<<i,1});\n  \n  for (int i=0;i<16;++i)\n    for (int x=0;x<(1<<16);x+=2) if (g[x]==i){\n      for (auto o:vec)\n        U(g[x^o.fi],i+o.se);\n    }\n  \n  cin>>n;\n  int x, y, z;\n  for (int i=1;i<n;++i){\n    scanf(\"%d%d%d\",&x,&y,&z); ++x; ++y;\n    G[x].push_back((pii){y,z});\n    G[y].push_back((pii){x,z});\n  }\n  dfs(1,0,0);\n  for (int i=1;i<16;++i){\n    ans+=cnt[i]>>1;\n    now|=(cnt[i]&1)<<i;\n  }\n  cout<<ans+g[now];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define pb push_back\n#define ppb pop_back\n#define all(x) (x).begin(), (x).end()\n\ntemplate <typename T>\nusing pr = array <T, 2>;\n\ntemplate <typename T>\nusing ord_set = tree <T, null_type, less <T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1e5 + 123;\nint n, a[N], used[16], b[N], dp[1 << 15], f[1 << 15];\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\ta[x] ^= w, a[y] ^= w;\n\t}\n\tused[0] = 1;\n\tint m = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[a[i]]) {\n\t\t\tcontinue;\n\t\t}\n\t\tused[a[i]] = 1;\n\t\tb[m++] = a[i];\n\t}\n\tint res = m;\n\tfor (int i = 1; i < (1 << m); i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tf[i] ^= b[j];\n\t\t\t}\n\t\t}\n\t\tif (f[i] == 0) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\tdp[i] = max(dp[i], dp[j] + dp[i ^ j]);\n\t\t}\n\t}\n\tcout << res - dp[(1 << m) - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdio>\n\n/*\nhttps://atcoder.jp/contests/abc153/submissions/9767872\n*/\nconst int cm = 1 << 17;\nchar cn[cm], *ci = cn + cm, ct;\ninline char getcha() {\n  if (ci - cn == cm) {\n    fread_unlocked(cn, 1, cm, stdin);\n    ci = cn;\n  }\n  return *ci++;\n}\ninline int getint() {\n  int A = 0;\n  if (ci - cn + 16 > cm)\n    while ((ct = getcha()) >= '0')\n      A = A * 10 + ct - '0';\n  else\n    while ((ct = *ci++) >= '0')\n      A = A * 10 + ct - '0';\n  return A;\n}\n/*\nhttps://atcoder.jp/contests/abc153/submissions/9767872\n*/\n\ninline constexpr bool test(const int x, const int y) noexcept {\n  return x & 1 << y;\n}\n\nint main() {\n  const int n = getint();\n  std::array<int, 100000> v = {};\n  for (int i = 0; i != n - 1; i += 1) {\n    const int x = getint();\n    const int y = getint();\n    const int a = getint();\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n  int ans = n;\n  int b = 0;\n  for (int i = 0; i != n; i += 1) {\n    const int e = v[i];\n    if (e == 0) {\n      ans -= 1;\n    } else {\n      if (test(b, e))\n        ans -= 1;\n      b ^= 1 << e;\n    }\n  }\n\n  std::array<int, 65536 / 2> dp = {};\n  dp[b >> 1] = 1;\n  for (int s = b; s != 0; s -= 2) {\n    if (dp[s >> 1] == 0)\n      continue;\n    int i = 16;\n    while (i != 0) {\n      i -= 1;\n      if (test(s, i))\n        break;\n    }\n    for (int j = 0; j != i; j += 1) {\n      if (!test(s, j))\n        continue;\n      const int k = i ^ j;\n      if (k > j)\n        continue;\n      int &d = dp[(s ^ 1 << i ^ 1 << j ^ 1 << k) >> 1];\n      if (test(s, k))\n        d = std::max(d, dp[s >> 1] + 1);\n      else\n        d = std::max(d, dp[s >> 1]);\n    }\n  }\n  printf(\"%d\", ans - dp[0] + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nvector < pii > g[N];\nint ans = 0;\nint dfs(int node,int prev)\n{\n    int cnt = 0;\n    for (auto it : g[node])\n        if (it.fi != prev)\n        {\n            int v = dfs(it.fi,node);\n            int xr = it.se;\n            for (int k = 0;k < 16;++k)\n                if ((v >> k) & 1)\n                {\n                    if ((cnt >> k) & 1)\n                        ++ans;\n                    cnt ^= 1 << k;\n                    xr ^= k;\n                }\n            if (xr)\n            {\n                if ((cnt >> xr) & 1)\n                    ++ans;\n                cnt ^= 1 << xr;\n            }\n        }\n    if (cnt & 1)\n        cnt ^= 1;\n    return cnt;\n}\nint dp[N];\nint f(int mask)\n{\n    if (dp[mask] != -1)\n        return dp[mask];\n    int &ans = dp[mask];\n    ans = 1e9;\n    for (int i = 0;i < 16;++i)\n        for (int j = 0;j < 16;++j)\n            if (((mask >> i) & 1) && ((mask >> j) & 1))\n            {\n                int e = i ^ j;\n                smin(ans,f(mask ^ (1 << i) ^ (1 << j) ^ (1 << e)) + 1 + ((mask >> e) & 1));\n            }\n    for (int i = 0;i < 16;++i)\n        if ((mask >> i) & 1)\n            smin(ans,f(mask ^ (1 << i)) + 1);\n    return ans;\n}\nint main(void)\n{\n    int n;\n    cin>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b,c;\n        cin>>a>>b>>c;\n        ++a;++b;\n        g[a].pb(mp(b,c));\n        g[b].pb(mp(a,c));\n    }\n    const int MM = 16;\n    const int M = 1 << MM;\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n    int cnt = dfs(1,0);\n    ans += f(cnt);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: RainAir\n * Time: 2019-10-08 16:33:35\n */\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define U unsigned\n#define P std::pair\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 1e5 + 5;\nconst int MAXM = 15 + 1;\nint a[MAXN];\nint n,ans;\nint cnt[16];\nint f[(1<<MAXM)+3];\n\ninline int dfs(int S){\n    int &ans = f[S];\n    if(!S) return ans = 0;\n    if(ans != -1) return ans;\n    ans = 1e9;\n    FOR(i,1,15){\n        if(!(S&(1<<(i-1)))) continue;\n        FOR(j,1,15){\n            if(i == j) continue;\n            if(!(S&(1<<(j-1)))) continue;\n            int x = i^j,nS = S;\n            if(S&(1<<(x-1))){\n                nS ^= (1<<(i-1));\n                nS ^= (1<<(j-1));\n                nS ^= (1<<(x-1));\n                ans = std::min(ans,2+dfs(nS));\n            }\n            else{\n                nS |= (1<<(x-1));\n                nS ^= (1<<(i-1));\n                nS ^= (1<<(j-1));\n                ans = std::min(ans,1+dfs(nS));\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n-1){\n        int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n        ++u;++v;\n        a[u] ^= w;a[v] ^= w;\n    }\n    FOR(i,1,n) cnt[a[i]]++;\n    FOR(i,1,15) ans += cnt[i]/2,cnt[i] %= 2;\n    int S = 0;\n    FOR(i,1,15) if(cnt[i]) S |= (1<<(i-1));\n    CLR(f,-1);\n    ans += dfs(S);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint main() {\n    int n;\n    cin >> n;\n\n    VI x(n);\n    REP(i,n-1){\n        int p, q, a;\n        scanf(\"%d %d %d\", &p, &q, &a);\n        x[p] ^= a;\n        x[q] ^= a;\n    }\n\n    VI a, c(16);\n    REP(i,n){\n        c[x[i]]++;\n    }\n\n    int ans = 0;\n    FOR(i,1,15){\n        ans += c[i] / 2;\n        if (c[i] % 2) a.push_back(i);\n    }\n\n    int m = a.size();\n    // REP(i,m) cout << a[i]<< endl;\n\n\n    VI dp(1<<m, 0);\n    FOR(mask,1,(1<<m)-1){\n        int s = 0;\n        REP(i,m) if ((mask >> i) & 1) s ^= a[i];\n        // cout << s << endl;\n        if (s) continue;\n        dp[mask] = 1;\n        for (int i = mask; i > 0; i = (mask & (i - 1))){\n            if (i == mask) continue;\n            s = 0;\n            REP(j,m) if ((i >> j) & 1) s ^= a[j];\n            if (s == 0){\n                dp[mask] = max(dp[mask], dp[i] + dp[mask]);\n            }\n        }\n    }\n\n    // REP(i,1<<m) cout << dp[i] << endl;\n\n    ans += m - dp[(1<<m)-1];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define N 100010\n#define M 65540\n\nint n,s[N],x,ans,u,v,w;\nint f[M],inf,sum[20]; \n\nint dfs(int S) {\n    if(!S)return 0; \n    if(f[S]<inf)return f[S];\n    for(int i=0;i<16;i++)if((S>>i)&1)\n        for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1) {\n        int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n        if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n        else f[S]=min(f[S],dfs(x)+1);\n    }\n    return f[S];\n}\n\nint main() {\n    scanf(\"%d\",&n); \n    for(int i = 1 ; i < n ; i++) {\n        scanf(\"%d%d%d\", &u,&v,&w);\n        s[u] ^= w, s[v] ^= w; \n    }\n    for(int i = 0 ; i < n ; i++) sum[s[i]]++; \n    for(int i = 1 ; i < 16 ; i++) {\n        ans += (sum[i] >> 1);\n        x += (1 << i) * (sum[i] & 1); \n    }\n    memset(f, 127, sizeof(f)); \n    inf = f[0]; \n    printf(\"%d\\n\", ans + dfs(x)); \n    //system(\"pause\");\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nint N;\nvpint G[111111];\nint cnt[111111];\n\n/*\nvoid dfs(int v,int p,int a){\n    int x=0;\n    for(auto &e:G[v]){\n        if(e.fi==p)continue;\n        dfs(e.fi,v,e.se);\n        x^=e.\n    }\n\n}*/\n\nint dist[1<<16];\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int x,y,a;\n        cin>>x>>y>>a;\n        G[x].pb({y,a});\n        G[y].pb({x,a});\n    }\n\n    rep(i,N-1){\n        int x=0;\n        for(auto &e:G[i])x^=e.se;\n        if(x)cnt[x]++;\n    }\n\n    int ans=0;\n    int mask=0;\n    rep(i,16){\n        ans+=cnt[i]/2;\n        mask|=(cnt[i]%2)<<i;\n    }\n\n\n    fill_n(dist,1<<16,INF);\n    dist[mask]=0;\n    priority_queue<pint,vector<pint>,greater<pint>>que;\n    que.push({0,mask});\n    while(que.size()){\n        int c,b;\n        tie(c,b)=que.top();\n        que.pop();\n        if(dist[b]<c)continue;\n        rep(i,16)if(b>>i&1){\n            int bb=b^(1<<i);\n            if(dist[bb]>dist[b]+1){\n                dist[bb]=dist[b]+1;\n                que.push({dist[bb],bb});\n            }\n        }\n\n        rep(i,16)for(int j=i+1;j<16;j++){\n            if(!(b>>i)||!(b>>j))continue;\n            int cc=c;\n            int bb=b;\n            cc++;\n            bb^=(1<<i);\n            bb^=(1<<j);\n            int k=j^i;\n            if(bb>>k&1){\n                bb^=(1<<k);\n                cc++;\n            }\n            else{\n                bb|=1<<k;\n            }\n            if(dist[bb]>cc){\n                dist[bb]=cc;\n                que.push({cc,bb});\n            }\n        }\n    }\n\n    cout<<ans+dist[0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxl 100010\n#define inf 2000000001\n\nusing namespace std;\n\nint n,ans,res;\nint a[maxl],dp[maxl],cnt[16];\n\ninline void prework()\n{\n\tfor(int i=0;i<n;i++)\n\t\ta[i]=0,cnt[i]=0;\n\tint u,v,val;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&u,&v,&val);\n\t\ta[u]^=val;a[v]^=val;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[a[i]]++;\n\tres=0;ans=0;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tres|=(1<<i);\n\t}\t\t\n}\n\ninline int dfs(int s)\n{\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s])\n\t\treturn dp[s];\n\tdp[s]=inf;\n\tint t;\n\tfor(int i=1;i<=15;i++)\n\tif(s&(1<<i))\n\t{\n\t\tt=s^(1<<i);\n\t\tfor(int j=1;j<=15;j++)\n\t\tif(t&(1<<j))\n\t\t{\n\t\t\tint q=i^j;\n\t\t\tif(s&(1<<q))\n\t\t\t\tdp[s]=min(dp[s],dfs(t^(1<<j)^(1<<q))+2);\n\t\t\telse\n\t\t\t\tdp[s]=min(dp[s],dfs(t^(1<<j)^(1<<q))+1);\n\t\t}\n\t}\n}\n\ninline void mainwork()\n{\n\tans+=dfs(res);\n}\n\ninline void print()\n{\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\tprework();\n\t\tmainwork();\n\t\tprint();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll x,y,a;cin>>x>>y>>a;\n    g[x].PB(a);\n    g[y].PB(a);\n  }\n  ll sz=16;\n  vector<ll>v(sz);\n  rep(i,0,n){\n    ll k=0;\n    for(auto x:g[i])k^=x;\n    if(!k)continue;\n    if(v[k])res++;\n    v[k]^=1;\n  }\n  auto dp=vec(1<<sz,sz,INF);\n  ll start=0;\n  rep(i,0,sz)if(!v[i])start^=1<<i;\n  dp[start][0]=0;\n  rep(i,0,1<<sz){\n    rep(j,0,sz){\n      rep(o,0,sz){\n        if(i&1<<o)continue;\n        chmin(dp[i^1<<o][j^o],dp[i][j]+((j^o)!=0));\n      }\n    }\n  }\n  cout<<res+*min_element(ALL(dp[(1<<sz)-1]))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=j;i<=k;++i)\n#define Forr(i,j,k) for (int i=j;i>=k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T& a,T b) {return a<b?a=b,1:0;}\ntemplate<typename T>bool chkmin(T& a,T b) {return a>b?a=b,1:0;}\n\nconst int maxn=100000+100;\nstruct node {\n\tint to,dis,next;\n}e[maxn<<1];\nint n,tot=-1,ans;\nint head[maxn],cnt[maxn];\nqueue<int>q;\n\ninline void read(int &x) {\n\tx=0;\n\tint p=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)) {if (c=='-') p=-1; c=getchar();}\n\twhile (isdigit(c)) {x=(x<<1)+(x<<3)+(c-'0'); c=getchar();}\n\tx*=p;\n}\n\ninline void file() {\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n}\n\ninline void add(int from,int to,int dis) {\n\ttot++;\n\te[tot].to=to; e[tot].dis=dis; e[tot].next=head[from]; head[from]=tot;\n}\n\ninline bool check(int s,int a) {\n\tfor (int s0=s;s0;s0=(s0-1)&s) if (s0==a) return 1;\n\treturn 0;\n}\n\nvoid dfs(int u,int fa,int dis) {\n\tfor (int i=head[u];i!=0;i=e[i].next) {\n\t\tint v=e[i].to;\n\t\tif (v==fa) continue;\n\t\tif (check(e[i].dis,dis)) {\n\t\t\te[i].dis^=dis; e[i^1].dis^=dis;\n//\t\t\tcout << \"!\" << v << \" \" << e[i].dis << endl;\n\t\t\tdfs(v,u,dis);\n\t\t}\n\t}\n}\n\nint main() {\n//\tfile();\n\tread(n);\n\tFor (i,1,n-1) {\n\t\tint x,y,z; read(x); read(y); read(z);\n\t\tadd(x,y,z); add(y,x,z); cnt[x]++; cnt[y]++;\n\t}\n\tFor (i,0,n-1) if (cnt[i]==1) q.push(i);\n\twhile (!q.empty()) {\n\t\tint u=q.front(); q.pop();\n//\t\tcout << \"u=\" << u << endl;\n\t\tfor (int i=head[u];i!=0;i=e[i].next) {\n\t\t\tint v=e[i].to;\n\t\t\tif (e[i].dis) {\n//\t\t\t\tcout << v << \" \" << e[i].dis << endl;\n\t\t\t\tdfs(v,u,e[i].dis); e[i].dis=0; e[i^1].dis=0;\n\t\t\t\t++ans;\n\t\t\t}\n\t\t\tcnt[v]--; if (cnt[v]==1) q.push(v);\n\t\t}\n//\t\tcout << \"******\" << endl;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 200005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\nstring bins(int x, int n) {\n  string res;\n  rep(i,n) res += \"01\"[x&1], x >>= 1;\n  reverse(rng(res));\n  return res;\n}\n\nconst int n = 16;\nconst int n2 = 1<<n;\n\nint c[n];\nint dp[n2];\nint ok[n2];\n\nint main() {\n  int nn, xs = 0;\n  scanf(\"%d\",&nn);\n  rep(i,nn-1) {\n    int x;\n    scanf(\"%*d%*d%d\",&x);\n    if (x) c[x]++;\n    xs ^= x;\n  }\n  if (xs) c[xs]++;\n  int s = 0, ans = 0;\n  rep(i,n) {\n    ans += c[i]/2;\n    s |= (c[i]&1)<<i;\n  }\n  rep(i,n2) dp[i] = -INF;\n  dp[s] = 0;\n  rep(i,n2) {\n    int x = 0;\n    rep(j,n) if (i>>j&1) x ^= j;\n    ok[i] = !x;\n  }\n  drep(i,n2) {\n    if (dp[i] == INF) continue;\n    for (int j = i; j; j = (j-1)&i) {\n      if (ok[j]) maxs(dp[i^j], dp[i]+1);\n    }\n  }\n\n  ans += pcnt(s)-dp[0];\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#include<vector>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<17)+10],ans,sum;\nvector<int> a[21];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta++;\n\t\tb++;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t\tif(book[i]&1)\n\t\t\tsum++;\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[s]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tcnt++;\n\t\ta[cnt].push_back(i);\n\t}\n\tfor(int o=sum;o>=0;o--)\n\t\tfor(int p=0;p<a[o].size();p++)\n\t\t{\n\t\t\tif(p>s)\n\t\t\t\tcontinue;\n\t\t\tfor(int i=1;i<=15;i++)\n\t\t\t{\n\t\t\t\tif(!(p&(1<<i)))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=i+1;j<=15;j++)\n\t\t\t\t{\n\t\t\t\t\tif(!(p&(1<<j)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint k=i^j;\n\t\t\t\t\tint t=p^(1<<i)^(1<<j)^(1<<k);\n\t\t\t\t\tif(p&(1<<k))\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>bin[17];\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[25]={0},f[(1<<16)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint all=15,s=0,res=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=1;i<=all;i++){\n\t\tres+=v[i]/2,v[i]%=2;\n\t\tif(v[i])s|=(1<<(i-1));\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<all)-1;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=15;j++)\n\t\t\tif(i&(1<<j))cnt++;\n\t\tbin[cnt].push_back(i);\n\t}\n\tfor(int p=1;p<=15;p++)\n\t\tfor(int k=0;k<bin[p].size();k++){\n\t\t\tint i=bin[p][k];\n\t\t\tfor(int u=0;u<=14;u++)\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=14;v++)\n\t\t\t\tif(i&(1<<v)){\n\t\t\t\t\tint w=u^v;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10; \nconst int inf = 0x3f3f3f3f; \n\nint n, ans, state; \nint v[maxn], cnt[20], f[maxm]; \n\nint dp(int s) {\n\tif (!s) return 0; \n\tif (f[s] < inf) return f[s]; \n\tfor (int i = 0; i <= 15; ++i) {\n\t\tif (!(s & (1 << i))) continue; \n\t\tfor (int j = 0; j <= 15; ++j) {\n\t\t\tif (i == j || !(s & (1 << j))) continue; \n\t\t\tint x = i ^ j; \n\t\t\tint y = s ^ (1 << i) ^ (1 << j) ^ (1 << x); \n\t\t\tif (s & (1 << x)) f[s] = min(f[s], dp(y) + 2); \n\t\t\telse f[s] = min(f[s], dp(y) + 1); \n\t\t}\n\t}\n\treturn f[s]; \n}\n\nint main() {\n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z; \n\t\tscanf(\"%d%d%d\", &x, &y, &z); \n\t\tx += 1, y += 1; \n\t\tv[x] ^= z; v[y] ^= z; \n\t}\n\tfor (int i = 1; i <= 15; ++i) cnt[v[i]]++; \n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans += cnt[i] >> 1; \n\t\tstate += (cnt[i] & 1) * (1 << i); \n\t}\n\tmemset(f, 0x3f, sizeof(f)); \n\tprintf(\"%d\\n\", ans + dp(state)); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n \n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n \ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n \n/************************************************/\n#define MN 200005\nint n;\nint v[MN];\nint t[16];\nint dp[MN];\nint r[MN];\nint main(){\n\tread(n);\n\tfor(int i=1,x,y,z;i<n;++i){\n\t\tread(x);read(y);read(z);\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tfor(int i=0;i<n;++i)++t[v[i]];\n\tint res=0;\n\tint h=0;\n\tfor(int i=1;i<16;++i){\n\t\tres+=(t[i]+1)/2;t[i]%=2;h|=t[i]*(1<<i);\n\t}\n\tmemset(dp,-0x3f,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=0;i<h;++i){\n\t\tfor(int j=0;j<16;++j)if((1<<j)&i){\n\t\t\tr[i]^=j;\n\t\t}\n\t}\n\tfor(int i=0;i<h;++i)if(dp[i]>=0){\n\t\tint S=h-i;\n\t\tfor(int j=S;j;j=S&(j-1))if(r[j]==0){\n\t\t\tdp[i+j]=max(dp[i]+1,dp[i+j]);\n\t\t}\n\t}\n\tcout<<res-dp[h];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nint A[MAXN];\n\nint solve(vector <int> C, int mask)\n{\n\tif (mask == 0)\n\t\treturn 0;\n\tif (mask < 0)\n\t\treturn INF;\n\tint ans = C[mask] >> 1, d = INF;\n\tif (C[mask] & 1)\n\t{\n\t\tREP(j, 4)\n\t\t{\n\t\t\tif ((mask & (1 << j)) && (mask ^ (1 << j)))\n\t\t\t{\n\t\t\t\tvector <int> C1 = C;\n\t\t\t\t++C1[1 << j];\n\t\t\t\t++C1[mask ^ (1 << j)];\n\t\t\t\td = min(d, solve(C1, mask - 1));\n\t\t\t}\n\t\t}\n\t\tif (mask == 15)\n\t\t\tFOR(j, 1, 4)\n\t\t{\n\t\t\tvector <int> C1 = C;\n\t\t\t++C1[1 | (1 << j)];\n\t\t\t++C1[mask ^ 1 ^ (1 << j)];\n\t\t\td = min(d, solve(C1, mask - 1));\n\t\t}\n\t}\n\telse\n\t\td = solve(C, mask - 1);\n\treturn ans + d;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = INF;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tvector <int> C(16);\n\tREP(i, n)\n\t\t++C[A[i]];\n\tcout << solve(C, 15);\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar buf[1<<20],*fs,*ft;\ninline char getc()\n{return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))? 0 : *fs++;}\ninline long long read()\n{long long s=0,w=1;char ch=getchar();\nwhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\nwhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\nreturn s*w;}\nchar buf1[1<<21],a1[20];int p11,p12=-1;\ninline void flush()\n{fwrite (buf1,1,p12+1,stdout),p12=-1;}\ninline void print(int x)\n{if(p12>1<<20) flush();if(x<0) buf1[++p12]=45,x=-x;\ndo{a1[++p11]=x%10+48;}while(x/=10);\ndo{buf1[++p12]=a1[p11];}while(--p11);buf1[++p12]='\\n';}\nint n,val[100100],b[20],ans=0,stat=0;\nint sum[(1<<16)],xr[(1<<16)];\nint main()\n{\n\tmemset(b,0,sizeof(b));\n\tmemset(xr,0,sizeof(xr));\n\tmemset(val,0,sizeof(val));\n\tn=read();\n\tint i=1,j=1,k=1;\n\twhile(i<n)\n\t{\n\t\tint u,v,l;\n\t\tu=read();\n\t\tv=read();\n\t\tl=read();\n\t\t++u;\n\t\t++v;\n\t\tval[u]^=l;\n\t\tval[v]^=l;\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<=n)\n\t{\n\t\t++b[val[i]];\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<=15)\n\t{\n\t\tans+=b[i]/2;\n\t\tb[i]%=2;\n\t\tstat|=b[i]<<(i-1);\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\tsum[i]=sum[i>>1]+(i&1);\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\t--sum[i];\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\tj=1;\n\t\twhile(j<=15)\n\t\t{\n\t\t\tif(i&(1<<(j-1))) xr[i]^=j;\n\t\t\t++j;\n\t\t}\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<15))\n\t{\n\t\tif(xr[i])\n\t\t{\n\t\t\tk=(i-1)&i;\n        \twhile(k)\n        \t{\n            \tif(xr[k]==0) sum[i]=min(sum[i],sum[k]+sum[i^k]);\n            \tk=(k-1)&i;\n            }\n        }\n\t\t++i;\n\t}\n\tprintf(\"%d\\n\",ans+sum[stat]);\n\treturn 0;\n}\n/*\nBZOJ 1833 ZJOI2010 Count\n??????\nHdu4734 f(x)\nCf 55D Beautiful Number\nCf 388D Fox and Perfect Sets\n2012 Multi-University Training Contest 6 ???â???â?LIS???\nTopCoder Rainbow Graph\nTopCoder CheeseRolling\nAtCoder 058E Iroha and Haiku\nAtCoder XOR Tree\nCodeforces 165E\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\n\nint N;\nint val[MN];\nint num[16];\nint dp[1 << 15];\nint ret;\nbool zero[1 << 15];\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b, e;\n\t\tcin >> a >> b >> e;\n\t\tval[a] ^= e;\n\t\tval[b] ^= e;\n\t}\n\n\trep(i, N) num[val[i]]++;\n\t\n\tint f = 0;\n\n\tfor (int i = 1; i < 16; ++i) {\n\t\tret += num[i] / 2;\n\t\tnum[i] %= 2;\n\t\tf |= (num[i] << (i-1));\n\t}\n\n\trep(i, 1 << 15) {\n\t\tint xo = 0;\n\t\trep(j, 15) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\txo ^= (j + 1);\n\t\t\t}\n\t\t}\n\t\tzero[i] = (xo == 0);\n\t}\n\n\tfor (int i = 1; i < (1<<15); ++i) {\n\t\tfor (int j = i; j >= 0; --j) {\n\t\t\tj &= i;\n\t\t\tif (j == 0) break;\n\t\t\tif (zero[j]) {\n\t\t\t\tdp[i] = max(dp[i], dp[i^j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ret + __builtin_popcount(f) - dp[f] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define sub(T,S) for(int T=(S-1)&S;T;T=(T-1)&S)\nusing namespace std;\nconst int maxn=1e5+10;\nint n,a[maxn],d[maxn],chc[1<<15],dp[1<<15],ans,u,v,w,W;\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n-1) scanf(\"%d%d%d\",&u,&v,&w),a[u+1]^=w,a[v+1]^=w;\n    rep(i,1,n) ++d[a[i]];\n    rep(i,1,15) ans+=d[i]>>1,W|=(d[i]&1)<<(i-1);\n    rep(i,0,14) rep(S,0,(1<<15)-1) if(S&(1<<i)) chc[S]^=i+1,++dp[S];\n    rep(S,1,(1<<15)-1){\n        if(chc[S]) continue;--dp[S];\n        sub(T,S) if(!chc[T]) dp[S]=min(dp[S],dp[T]+dp[S^T]);\n    }\n    printf(\"%d\\n\",dp[W]+ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=100005;\nint val[N],cnt[N],sxr[1<<17];\nint a[17];\nint dp[1<<17];\ninline int read(){\n\tint x=0;char e=getchar();\n\tfor (;e<'0'||e>'9';e=getchar());\n\tfor (;e>='0'&&e<='9';e=getchar()) x=(x<<1)+(x<<3)+(e^48);\n\treturn x;\n}\ninline int Min(int a,int b){\n\treturn a<b?a:b;\n}\nint main (){\n\tint n=read();\n\tfor (int i=1;i<n;i++){\n\t\tint u=read()+1,v=read()+1,w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tint ans=0,to=0;\n\tfor (int i=1;i<16;i++){\n\t\tans+=(cnt[i]>>1);\n\t\tif (cnt[i]&1) to|=(1<<i);\n\t}\n\tfor (int i=0;i<(1<<16);i++)\n\t\tfor (int j=0;j<16;j++)\n\t\t\tif (i&(1<<j)) sxr[i]^=j;\n\tfor(int i=0;i<(1<<16);i++) dp[i]=dp[i>>1]+(i&1);\n    for(int i=1;i<(1<<16);i++) dp[i]--;\n\tfor (int i=0;i<(1<<16);i++){\n        if (sxr[i]) continue;\n        for (int k=(i-1)&i;k;k=(k-1)&i)\n            if (!sxr[k]) dp[i]=Min(dp[i],dp[k]+dp[i^k]);\n\t}\n\tprintf (\"%d\",dp[to]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 100001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nbool v[1 << 15];\nint cc[N], cnt[16], bin[16], f[1 << 15], one[1 << 15];\n\nint main() {\n\tint n = read();\n\tfor(int i = 1; i < n; i++) {\n\t\tint x = read(), y = read(), c = read();\n\t\tcc[x] ^= c, cc[y] ^= c;\n\t} for(int i = 0; i < n; i++) cnt[cc[i]]++;\n\tbin[0] = 1; for(int i = 1; i < 16; i++) bin[i] = bin[i - 1] << 1;\n\tint ans = 0, S = 0; for(int i = 1; i < 16; i++) ans += cnt[i] / 2, S += cnt[i] & 1 ? bin[i - 1] : 0;\n\tfor(int i = 0; i < bin[15]; i++) {\n\t\tint sum = 0;\n\t\tfor(int j = 0; j < 15; j++) if(i & bin[j]) sum ^= j + 1;\n\t\tif(!sum) v[i] = 1;\n\t} memset(f, 63, sizeof(f));\n\tf[0] = 0; for(int i = 1; i <= S; i++) {\n\t\tone[i] = one[i >> 1] + (i & 1);\n\t\tif(v[i]) {\n\t\t\tf[i] = one[i] - 1;\n\t\t\tfor(int j = (i - 1) & i; j; j = (j - 1) & i) if(v[j]) f[i] = _min(f[i], f[i ^ j] + f[j]);\n\t\t}\n\t} put(f[S] + ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Sasayego! Sasayego! Shinzou wo Sasageyo!\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <ctime>\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define lid (id << 1)\n#define rid (lid ^ 1)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll, ll> pll;\ntypedef pair <int, int> pii;\n\nconst int maxN = 1e5 + 5;\nconst int maxA = 15;\nconst int maxK = (1 << maxA) + 5;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nint a[maxN], cnt[16];\nint l = 0, b[maxN];\nint arumin[2][maxK];\n\nint main(){\n\ttime_t START = clock();\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++){\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\tfor (int i = 1; i < 16; i++){\n\t\tans += (cnt[i] >> 1);\n\t\tcnt[i] &= 1;\n\t\tif (cnt[i])\n\t\t\tb[l++] = i;\n\t}\n\tfor (int mask = 1; mask < (1 << l); mask++){\n\t\tint lb = __builtin_ctz(mask);\n\t\tarumin[0][mask] = b[lb] ^ arumin[0][mask ^ (1 << lb)];\n\t\tif (arumin[0][mask] == 0){\n\t\t\tarumin[1][mask] = __builtin_popcount(mask) - 1;\n\t\t\tfor (int sub = mask & (mask - 1); sub > 0; sub = (sub - 1) & mask)\n\t\t\t\tif (arumin[0][sub] == 0)\n\t\t\t\t\tarumin[1][mask] = max(arumin[1][mask], arumin[1][sub] + arumin[1][mask ^ sub]);\n\t\t}\n\t}\n\tans += arumin[1][(1 << l) - 1];\n\tprintf(\"%d\\n\", ans);\n\ttime_t FINISH = clock();\n\tcerr << \"Execution time: \" << (ld)(FINISH - START) / CLOCKS_PER_SEC * 1000.0 << \" milliseconds.\\n\";\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nclass edge {\npublic:\n\tint to, cost;\n\tedge() : to(-1), cost(0) {};\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<int> col(N);\n\tfunction<int(int, int, int)> set_col = [&](int pos, int pre, int pcol) {\n\t\tint res = 0;\n\t\tfor (edge e : G[pos]) {\n\t\t\tif (e.to == pre) continue;\n\t\t\tset_col(e.to, pos, e.cost);\n\t\t\tres ^= e.cost;\n\t\t}\n\t\tres ^= pcol;\n\t\tcol[pos] = res;\n\t\tres ^= col[pos];\n\t\treturn res;\n\t};\n\tset_col(0, -1, 0);\n\tvector<int> tbl(16);\n\tfor (int i = 0; i < N; ++i) {\n\t\t++tbl[col[i]];\n\t}\n\tint bit = 0, ans = 0;\n\tfor (int i = 1; i < 16; ++i) {\n\t\tans += (tbl[i] >> 1);\n\t\tbit |= (tbl[i] & 1) << i;\n\t}\n\tqueue<pair<int, int> > que;\n\tvector<int> dist(1 << 16, inf);\n\tque.push(make_pair(0, bit));\n\tdist[bit] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.front().second; que.pop();\n\t\tfor (int i = 1; i < 16; ++i) {\n\t\t\tif (!((u >> i) & 1)) continue;\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tif (!((u >> j) & 1)) continue;\n\t\t\t\tint b = u ^ (1 << i) ^ (1 << j);\n\t\t\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\t\t\tif ((i ^ j ^ k) == 0) continue;\n\t\t\t\t\tint tar = b ^ (1 << (i ^ k)) ^ (1 << (j ^ k)), cost = 1;\n\t\t\t\t\tif ((u >> (i ^ k)) & 1) ++cost;\n\t\t\t\t\tif ((u >> (j ^ k)) & 1) ++cost;\n\t\t\t\t\tif (dist[tar] > dist[u] + cost) {\n\t\t\t\t\t\tdist[tar] = dist[u] + cost;\n\t\t\t\t\t\tque.push(make_pair(-dist[tar], tar));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans += min(dist[0], dist[1]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int maxN = 1e5 + 10;\nint nodeN, tot;\nint val[maxN], cntHas[maxN], dp[1 << 16], num[20], xorSum[1 << 16];\n\nint main () {\n\tscanf(\"%d\", &nodeN);\n\tfor (int nodeI = 1; nodeI < nodeN; ++nodeI) {\n\t\tint n1, n2, len;\n\t\tscanf(\"%d%d%d\", &n1, &n2, &len);\n\t\t++n1, ++n2;\n\t\tval[n1] ^= len;\n\t\tval[n2] ^= len;\n\t}\n\tfor (int nodeI = 1; nodeI <= nodeN; ++nodeI) ++cntHas[val[nodeI]];\n\tint ans = 0;\n\tfor (int valI = 1; valI < 16; ++valI) {\n\t\tans += cntHas[valI] >> 1;\n\t\tcntHas[valI] &= 1;\n\t\tif (cntHas[valI] != 0) {\n\t\t\tnum[++tot] = valI;\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\txorSum[stI] ^= num[weiJ + 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] > 0) {\n\t\t\tdp[stI] = 0x3f3f3f3f;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\t++dp[stI];\n\t\t\t}\n\t\t}\n\t\t--dp[stI];\n\t}\n\tdp[0] = 0;\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] != 0) continue;\n\t\tfor (int son = stI & (stI - 1); son; son = stI & (son - 1)) {\n\t\t\tif (xorSum[son] == 0) {\n\t\t\t\tdp[stI] = min(dp[stI], dp[stI ^ son] + dp[son]);\n\t\t\t}\n\t\t}\n\t}\n\tans += dp[(1 << tot) - 1];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=1e5,M=(1<<15)+1000;\nint n,a[N],f[M],cnt[M],as,st,S,x[M];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\t//freopen(\"3913.in\",\"r\",stdin);freopen(\"3913.out\",\"w\",stdout);\n\tn=read();rp(i,1,n-1){ri x=read()+1,y=read()+1,z=read();a[x]^=z;a[y]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);rp(i,1,S)--f[i];rp(i,1,S)rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\\n\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define Rep(i,l,r) for (int i=l; i<=r; ++i)\n#define Per(i,r,l) for (int i=r; i>=l; --i)\n\nconst int Extra=5,Max_W=15,Max_N=1e5,INF=0X7FFFFFFF;\n\nint Read(){\n\tint x=0,f=0,ch=getchar();\n\twhile (!isdigit(ch)) f^=!(ch^'-'),ch=getchar();\n\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\tif (f) x=-x; return x;\n}\n\nvoid Check_Judge(){\n\tfreopen(\"data.in\",\"r\",stdin),freopen(\"data.out\",\"w\",stdout);\n}\n\nint n,ans,sum,vis[Max_W+Extra],a[Max_N+Extra],f[(1<<Max_W)+Extra];\n\nint DFS(int x){\n\tif (x==0)\n\t\treturn 0;\n\tif (f[x])\n\t\treturn f[x];\n\tf[x]=INF;\n\tRep(i,1,15){\n\t\tif (x==(1<<i)){\n\t\t\tf[x]=1;\n\t\t\treturn f[x];\n\t\t}\n\t\tif ((x&(1<<i))!=0)\n\t\t\tRep(j,1,15)\n\t\t\t\tif (i!=j&&(x&(1<<j))!=0){\n\t\t\t\t\tint to=x;\n\t\t\t\t\tto^=1<<i,to^=1<<j,to^=1<<(i^j);\n\t\t\t\t\tif ((to&(1<<(i^j)))==0)\n\t\t\t\t\t\tf[x]=std::min(f[x],DFS(to)+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tf[x]=std::min(f[x],DFS(to)+1);\n\t\t\t\t}\n\t}\n\treturn f[x];\n}\n\nint main(){\n\tCheck_Judge();\n\tn=Read();\n\tRep(i,2,n){\n\t\tint x=Read(),y=Read(),w=Read();\n\t\ta[x]^=w,a[y]^=w;\n\t}\n\tRep(i,1,n)\n\t\t++vis[a[i]];\n\tRep(i,1,15){\n\t\tans+=vis[i]>>1;\n\t\tif (vis[i]%2!=0)\n\t\t\tsum+=1<<i;\n\t}\n\tprintf(\"%d\",ans+DFS(sum));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\nconst int N=2e5;\nint ans,n,a[N],t,f[1<<20][20],q[N];\nint main()\n{\n\tn=read();\n\tint x,y,v;\n\tfor(int i=1;i<n;++i)x=read()+1,y=read()+1,v=read(),a[x]^=v,a[y]^=v;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)\n\tif(i<n&&a[i]==a[i+1]) a[i]!=0?ans++:0,i++;\n\telse q[++t]=a[i];\n\tmemset(f,0x3f,sizeof(f));\n\tfor(int i=1;i<=t;++i)f[1<<(i-1)][q[i]]=0;\n\tfor(int i=0;i<(1<<t);++i)\n\tfor(int j=0;j<16;++j)\n\tfor(int k=1;k<=t;++k)\n\tif(i&(1<<(k-1)))\n\tf[i][j]=min(f[i][j],f[i-(1<<(k-1))][j^q[k]]+1);\n\tprintf(\"%d\\n\",f[(1<<t)-1][0]+ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#define ll long long\n#define N 100010\n#define TOP (1<<15)\nusing namespace std;\n\nll n,t,ans,a[N],sum[N],f[N],Xor[N];\n\ninline ll read(){\n\tll x=0,tmp=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') tmp=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tx=(x<<3)+(x<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn tmp*x;\n}\n\nint main(){\n\tn=read();\n\tfor(ll i=1; i<n; i++){\n\t\tll x=read()+1,y=read()+1,z=read();\n\t\ta[x]^=z; a[y]^=z;\n\t}\n\tfor(ll i=1; i<=n; i++) sum[a[i]]++;\n\tfor(ll i=1; i<=15; i++){\n\t\tans+=sum[i]>>1;\n\t\tt|=(sum[i]&1)<<(i-1);\n\t}\n    for(ll i=1; i<TOP; i++) f[i]=f[i>>1]+(i&1);\n    for(ll i=1; i<TOP; i++){\n    \tf[i]--;\n    \tfor(ll j=0; j<15; j++){\n        \tif((i>>j)&1) Xor[i]^=j+1;\n\t\t}\n\t}\n    for(ll i=1; i<TOP; i++){\n        if(Xor[i]) continue;\n        for(ll j=(i-1)&i; j; j=(j-1)&i){\n        \tif(!Xor[j]) f[i]=min(f[i],f[j]+f[i^j]);\n\t\t}   \n    }\n\tcout<<ans+f[t]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxm], dp[1 << 16];\nll cnt[maxn];\nll ans;\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << (i - 1));\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[init] = 0;\n    for(int i = 15;i > 0;i--){\n        for(int S = 0;S < (1 << 15);S++){\n            ll cnt = 0;\n            for(int k = 0;k < 15;k++){\n                if((S >> k) & 1) cnt++;\n            }\n            if(cnt != i) continue;\n            // cout << cnt << \" \" << S << endl;\n            for(int k = 0;k < 15;k++){\n                if(!((S >> k) & 1)) continue;\n                for(int w = 0;w < 15;w++){\n                    if(k == w) continue;\n                    if(!((S >> w) & 1)) continue;\n                    ll newnum = ((k + 1) ^ (w + 1)) - 1;\n                    if(((S >> newnum) & 1) == 1){\n                        dp[(S ^ (1 << k) ^ (1 << w)) ^ (1 << newnum)] = \n                        min(dp[S ^ (1 << k) ^ (1 << w) ^ (1 << newnum)], dp[S] + 2);\n                    } else {\n                        dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)] = \n                        min(dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)], dp[S] + 1);\n                    }\n                }\n            }\n        }\n    }\n    ll mi = dp[0];\n    for(int i = 0;i < 15;i++){\n        mi = min(mi, dp[1 << i] + 1);\n    }\n    ans += mi;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint ans,a[N],xx,y,v,n,cc[17],c[N],q;\ninline int dfs(int x){\n\tcout<<x<<\"\\n\";\n\tif(!x)return 0;\n\tif(c[x])return c[x];\n\tc[x]=999999;\n\tint i,j,k,r1,r2,uu,y;\n\tfor(i=1;i<=15;++i){\n\t\tif((1<<i)&x){\n\t\t\tfor(j=i+1;j<=15;++j){\n\t\t\t\tif((1<<j)&x){\n\t\t\t\t\tfor(k=1;k<=3;++k){\n\t\t\t\t\t\tuu=1;y=x;\n\t\t\t\t\t\tr1=j^k;r2=i^k;\n\t\t\t\t\t\ty-=(1<<j);\n\t\t\t\t\t\ty-=(1<<i);\n\t\t\t\t\t\tif(r1>0){\n\t\t\t\t\t\tif(((1<<r1)&y)){\n\t\t\t\t\t\t\ty-=(1<<r1);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(r2>0){\n\t\t\t\t\t\tif(((1<<r2)&y)){\n\t\t\t\t\t\t\ty-=(1<<r2);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc[x]=min(c[x],dfs(y)+uu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c[x];\n}\nint i;\nint main(){\n\tcin>>n;\n\tfor(i=1;i<n;++i){\n\t\tcin>>xx>>y>>v;\n\t\ta[xx]^=v;\n\t\ta[y]^=v;\n\t}\n\tfor(i=0;i<n;++i)++cc[a[i]];\n\tfor(i=1;i<=15;++i){\n\t\tans+=cc[i]/2;\n\t\tq+=((cc[i]&1)<<i);\n\t}\n\tcout<<ans+dfs(q);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10; \nconst int inf = 0x3f3f3f3f; \n\nint n, ans, state; \nint v[maxn], cnt[20], f[maxm]; \n\nint dp(int s) {\n    if (!s) return 0; \n    if (f[s] < inf) return f[s]; \n    for (int i = 0; i <= 15; ++i) {\n        if (!(s & (1 << i))) continue; \n        for (int j = 0; j <= 15; ++j) {\n            if (i == j || !(s & (1 << j))) continue; \n            int x = i ^ j; \n            int y = s ^ (1 << i) ^ (1 << j) ^ (1 << x); \n            if (s & (1 << x)) f[s] = min(f[s], dp(y) + 2); \n            else f[s] = min(f[s], dp(y) + 1); \n        }\n    }\n    return f[s]; \n}\n\nint main() {\n    scanf(\"%d\", &n); \n    for (int i = 1; i < n; ++i) {\n        int x, y, z; \n        scanf(\"%d%d%d\", &x, &y, &z); \n        x += 1, y += 1; \n        v[x] ^= z; v[y] ^= z; \n    }\n    for (int i = 1; i <= n; ++i) cnt[v[i]]++; \n    for (int i = 1; i <= 15; ++i) {\n        ans += (cnt[i] >> 1); \n        state += (cnt[i] & 1) * (1 << i); \n    }\n    memset(f, 0x3f, sizeof(f)); \n    printf(\"%d\\n\", ans + dp(state)); \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i = (int)(a); i <= (int)(b); i++)\n#define NFOR(i,a,b) for(int i = (int)(a); i >= (int)(b); --i)\n#define endl \"\\n\"\n#define mp make_pair\n#define X first\n#define Y second\n#define inf 1e18\n#define mod 1000000007\n#define pb push_back\n#define Case cout<<\"Case #\"<<++cas<<\": \";\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define all(v) v.begin(),v.end()\n#define sz(x) int(x.size())\n// #define lli int\ntypedef long long int lli;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<lli,lli> pll;\ntypedef vector<lli> vl;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cerr << str << \" : \" << t << \"\\n\";}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cerr << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cerr << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cerr << \", \"; cerr << *i;} cerr << \"]\\n\";}\n\nconst int N = 100010;\n\nint val1[N];\nbool isPresent[N];\nint dp[(1<<16) + 1];\nbool good[(1<<16) + 1];\n\nint main() {\n\tint n; cin >> n;\n\tFOR(i, 1, n-1) {\n\t\tint a1, b1, c1; cin >> a1 >> b1 >> c1; a1++, b1++;\n\t\tval1[a1] ^= c1, val1[b1] ^= c1;\n\t}\n\tint answer1 = 0;\n\tint remain = 0;\n\tFOR(i, 1, n) {\n\t\tif (val1[i] == 0) {\n\t\t\tanswer1++; continue;\n\t\t}\n\t\tif (isPresent[val1[i]]) {\n\t\t\tanswer1++, good[val1[i]] = false;\n\t\t} else {\n\t\t\tisPresent[val1[i]] = true;\n\t\t}\n\t\tremain ^= (1<<val1[i]);\n\t}\n\tFOR(i, 0, (1<<16)-1) {\n\t\tint currentMask = 0;\n\t\tFOR(j, 0, 16) {\n\t\t\tif (i & (1<<j)) {\n\t\t\t\tcurrentMask ^= j;\n\t\t\t}\n\t\t}\n\t\tif (currentMask == 0) {\n\t\t\tgood[i] = true;\n\t\t}\n\t}\n\tFOR(i, 0, (1<<16)-1) {\n\t\tfor (int j = i; j > 0; j = (j -1) & i) {\n\t\t\tif (good[i ^ j]) {\n\t\t\t\tdp[i] = max(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << n - (answer1 + dp[remain]) << \"\\n\";\nreturn 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  vi d(n);\n  for (int i = 0; i < n-1; ++i) {\n    int a,b,c;\n    cin >> a >> b >> c;\n    d[a] ^= c;\n    d[b] ^= c;\n  }\n  vi c(16);\n  for (int i = 0; i < n; ++i) c[d[i]]++;\n  int s = 0;\n  vi a(1 << 16, 1e9);\n  a[0] = 0;\n  for (int i = 1; i < 16; ++i) {\n    if (c[i]) cerr << i << ' ' << c[i] << endl;\n    s += c[i] / 2;\n    if (c[i] % 2 == 0) continue;\n    vi na(a.size(), 1e9);\n    int B = 1 << i;\n    for (int mask = 0; mask < a.size(); ++mask) {\n      if (mask & B) {\n        na[mask ^ B] = min(na[mask ^ B], a[mask] + 1);\n      } else {\n        na[mask ^ B] = min(na[mask ^ B], a[mask]);\n      }\n      for (int b = 1; b < 16; ++b) if (mask & (1 << b)) {\n        int xr = (1 << (b ^ i));\n        int nmask = mask ^ (1 << b) ^ xr;\n        if (mask & xr) {\n          na[nmask] = min(na[nmask], a[mask] + 2);\n        } else {\n          na[nmask] = min(na[nmask], a[mask] + 1);\n        }\n//        if (nmask == 0 && a[mask] == 0) cerr << i << ' ' << b << ' ' << mask << ' ' << a[mask] << endl;\n      }\n    }\n    a.swap(na);\n    cerr << a[2] << ' ' << a[8] << ' ' << a[0] << endl;\n  }\n  cout << s + min(a[0], a[1]) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=100005;\n\nint dp[1<<16],V[MAXN],cnt[16];\n\nint DP(int s)\n{\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\tdp[s]=0x3FFFFFFF;\n\tfor(int i=1;i<16;i++)\n\t\tif(s&(1<<i))\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tif(s&(1<<j))\n\t\t\t\t{\n\t\t\t\t\tint ns=s^(1<<i)^(1<<j)^(1<<(i^j));\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t\tdp[s]=min(dp[s],DP(ns)+1+(((1<<(i^j))&s)==(1<<(i^j))));\n\t\t\t\t}\n\treturn dp[s];\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y,a;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&a);\n\t\tV[x]^=a;\n\t\tV[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(V[i])\n\t\t\tcnt[V[i]]++;\n\tint ans=0,st=0;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst^=(cnt[i]&1)<<i;\n\t}\n\tmemset(dp,-1,sizeof dp);\n\tans+=DP(st);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define N_ 101000\n#define pii pair<int,int>\nint w[N_], C[N_], D[1<<16], P[N_], cnt, CC[N_];\nint n;\npriority_queue<pii>PQ;\nvoid Put(int mask, int d) {\n\tif (D[mask] <= d)return;\n\tD[mask] = d;\n\tPQ.push(pii(-d, mask));\n}\nint main() {\n\tint i, a, b, c, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta++, b++;\n\t\tw[a] ^= c;\n\t\tw[b] ^= c;\n\t}\n\tint s = 0, res = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (w[i])C[w[i]]++, res++;\n\t}\n\tfor (i = 1; i <= 15; i++)if (C[i] & 1)s |= (1 << i);\n\tfor (i = 0; i < (1 << 16); i++) {\n\t\tD[i] = 1e9;\n\t\tfor (j = 0; j < 16; j++)if ((i >> j) & 1)CC[i]++;\n\t}\n\tPut(s, 0);\n\tfor (i = 2; i < (1 << 16); i += 2) {\n\t\tint t = 0;\n\t\tfor (j = 1; j <= 15; j++)if ((i >> j) & 1)t ^= j;\n\t\tif (t == 0)P[cnt++] = i;\n\t}\n\twhile (!PQ.empty()) {\n\t\tpii tp = PQ.top();\n\t\tPQ.pop();\n\t\tint x = tp.second;\n\t\tif (-tp.first != D[x])continue;\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tint y = P[i];\n\t\t\tif (!(x&y))continue;\n\t\t\tPut(y^x, D[x] + CC[y] - 2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (res + D[0])/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\nconst int maxn = 1e5 + 20;\nconst int maxs = (1 << 16) + 7;\n\nint n;\nint val[maxn], cnt[16], ans;\nint dp[maxs];\n\ntemplate<class TAT>void checkmin(TAT &x,const TAT &y)\n{\n\tif(y < x) x = y;\n}\nint dfs(int x)\n{\n\tif(dp[x] != -1) return dp[x];\n\t\n\tdp[x] = maxs;\n\t\n\tfor(int i = 0; i < 16; i++)\n\t\tfor(int j = 0; j < 16; j++)\n\t\t\tif(x != y && ((x >> i) & 1) && ((x >> j) & 1))\n\t\t\t{\n\t\t\t\tint tmp = x ^ (1 << i) ^ (1 << j);\n\t\t\t\tint modify = i ^ j;\n\t\t\t\t\n\t\t\t\tcheckmin(dp[x], tmp ^ (1 << modify) + 1 + ((tmp >> modify) & 1));\n\t\t\t}\n\t\n\treturn dp[x];\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, x, y, a; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\t++x, ++y;\n\t\tval[x] ^= a, val[y] ^= a;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(val[i])\n\t\t{\n\t\t\tans += cnt[val[i]];\n\t\t\tcnt[val[i]] ^= 1;\n\t\t}\n\t}\n\t\n\tint now = 0;\n\t\n\tfor(int i = 0; i < 16; i++) now |= (1 << i) * cnt[i];\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0] = 0;\n\tans += dfs(now);\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nvoid ckmin(int&x,const int&y)\n{\n\tx=x<y?x:y;\n}\nint n,m,a[100005],f[1<<15],ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z;a[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(a[i]--)\n\t\t\tans+=m>>a[i]&1,m^=1<<a[i];\n\tfor(int s=1;s<=m;++s)\n\t{\n\t\tint x=0;\n\t\tfor(int j=0;j<16;++j)if(s>>j&1)x^=j+1;\n\t\tif(x)f[s]=1e9;\n\t\telse{\n\t\t\tf[s]=__builtin_popcount(s)-1;\n\t\t\tfor(int t=(s-1)&s;t;t=(t-1)&s)ckmin(f[s],f[t]+f[s^t]);\n\t\t}\n\t}\n\tprintf(\"%d\",ans+f[m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nint Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)cnt[dian[i]]++;\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot|=(1<<(i-1));\n\tfor(int i=1;i<(1<<15);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<15);s++){\n\t\tfor(int i=1;i<=15;i++){\n\t\t\tif((s>>(i-1))&1)\n\t\t\tXor[s]^=i;\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<15);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(2e5 + 10);\nint n, val[maxn], f[maxn], cnt[20], ans, S, sum[maxn];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, a, b, c; i < n; i++)\n\t\tscanf(\"%d%d%d\", &a, &b, &c), val[a] ^= c, val[b] ^= c;\n\tfor (int i = 0; i < n; i++) ++cnt[val[i]];\n\tfor (int i = 1; i <= 15; i++) ans += (cnt[i] >> 1), S |= (cnt[i] & 1) << (i - 1);\n\tfor (int i = 1; i < (1 << 15); i++) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); i++) --f[i];\n\tfor (int i = 1; i < (1 << 15); i++)\n\t\tfor (int j = 0; j < 15; j++) if (i & (1 << j)) sum[i] ^= (j + 1);\n\tfor (int i = 1; i < (1 << 15); i++) if (!sum[i])\n\t\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\t\tif (!sum[j]) f[i] = std::min(f[i], f[j] + f[i ^ j]);\n\tprintf(\"%d\\n\", ans + f[S]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int N = 100005;\n\nint n, up[N], ans;\nbool can[16];\n\nvector<int> d[N], tmp;\nvector<pii> adj[N];\n\nbool elim (vector<int> &V, int X, int I = 0) {\n\tif(I == V.size()) {\n\t\tif(!X) {\n\t\t\ttmp.clear();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tif(elim(V, X^V[I], I+1)) return true;\n\tif(elim(V, X, I+1)) {\n\t\ttmp.push_back(V[I]);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid calc (int C, int P) {\n\tint X = 0;\n\tfor(auto &T : adj[C]) {\n\t\tint A, B;\n\t\ttie(A, B) = T;\n\t\tif(A == P) continue;\n\t\tup[A] = B;\n\t\tcalc(A, C);\n\t\tfor(auto &T : d[A]) {\n\t\t\tX ^= T;\n\t\t\tif(elim(d[C], T)) {\n\t\t\t\tswap(tmp, d[C]);\n\t\t\t\tans--;\n\t\t\t}\n\t\t\telse d[C].push_back(T);\n\t\t}\n\t}\n\tans++;\n\tif(elim(d[C], X^up[C])) {\n\t\tswap(tmp, d[C]);\n\t\tans--;\n\t}\n\telse d[C].push_back(X^up[C]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B, C;\n\t\tscanf(\"%d%d%d\",&A,&B,&C);\n\t\tadj[A].push_back({B, C});\n\t\tadj[B].push_back({A, C});\n\t}\n\tcalc(0, -1);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nint n,ans,k,t,b[100005],c[16],d[1<<16];\nvoid gao(int i){\n\tfor(int j=0;j<16;j++)\n\t\tif(i>>j&1)k^=j;\n\tif(!k){\n\t\td[i]=1;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i)\n\t\t\td[i]=max(d[i],d[j]+d[j^i]);\n\t}\n}\nvoid gg(int i){\n\tfor(int j=0;j<16;j++)\n\t\tfor(int p=0;p<16;p++)\n\t\t\tif(j&p>=i)k^=j&p;\n}\nint main(){\n\tn=read();\n\tfor(int i=0;i<n-1;i++){\n\t\tint x=read(),y=read(),a=read();\n\t\tb[x]^=a,b[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[b[i]]++;\n\tfor(int i=1;i<1<<16;i++){\n\t\tk=0;\n\t\tgao(i);\n\t}\n\tfor(int i=1;i<16;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]&1)t^=1<<i;\n\t}\n\tprintf(\"%d\",ans+__builtin_popcount(t)-d[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 03.02.2018 17:31:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> val(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, z;\n    scanf(\"%d %d %d\", &x, &y, &z);\n    val[x] ^= z;\n    val[y] ^= z;\n  }\n  vector<int> cnt(16);\n  for (int i = 0; i < n; i++) {\n    cnt[val[i]]++;\n  }\n  int ans = 0;\n  for (int i = 1; i < 16; i++) {\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n  }\n  int mask = 0;\n  for (int i = 1; i < 16; i++) {\n    if (cnt[i] == 1) {\n      mask |= (1 << i);\n    }\n  }\n  vector<int> good(1 << 16);\n  for (int t = 0; t < (1 << 16); t++) {\n    int x = 0;\n    for (int i = 0; i < 16; i++) {\n      if (t & (1 << i)) {\n        x ^= i;\n      }\n    }\n    good[t] = (x == 0);\n  }\n  vector<int> dp(1 << 16, 0);\n  for (int t = 0; t < (1 << 16); t++) {\n    if (t & 1) {\n      continue;\n    }\n    int u = t;\n    while (u > 0) {\n      if (good[u]) {\n        dp[t] = max(dp[t], dp[t ^ u] + 1);\n      }\n      u = (u - 1) & t;\n    }\n  }\n  printf(\"%d\\n\", ans + __builtin_popcount(mask) - dp[mask]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint val[N],w[N],sum[(1<<15)+5],f[(1<<15)+5];\ninline int count(int x){\n\tint cnt=0;while (x) x&=(x-1),cnt++;return cnt;\n}\nint main (){\n\tint n;scanf (\"%d\",&n);\n\tfor (int i=1,u,v,w;i<n;i++){\n\t\tscanf (\"%d%d%d\",&u,&v,&w);\n\t\t++u,++v,val[u]^=w,val[v]^=w;\n\t}\n\tfor (int i=1;i<=n;i++) w[val[i]]++;\n\tfor (int s=0;s<(1<<15);s++)\n\t\tfor (int i=1;i<=15;i++)\n\t\t\tif (s&(1<<(i-1))) sum[s]^=i;\n\tint ans=0,to=0;\n\tfor (int s=1;s<=15;s++) ans+=(w[s]>>1),w[s]&=1,to|=w[s]*(1<<(s-1));\n\tfor (int s=1;s<(1<<15);s++){\n\t\tif (sum[s]==0) f[s]=count(s)-1;\n\t\telse {f[s]=114514;continue;}\n\t\tfor (int t=s&(s-1);t;t=s&(t-1))\n\t\t\tif (sum[t]==0) f[s]=min(f[s],f[s^t]+f[t]);\n\t}\n\tprintf (\"%d\",ans+f[to]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cstdio>\n#include <utility>\n#include <vector>\n\nconst int N = 100000;\n\nint n, count[16], sum[1 << 16], dp[1 << 16];\nstd::vector<std::pair<int, int>> tree[N];\n\nint dfs(int p, int u)\n{\n    int result = 0;\n    for (auto it : tree[u]) {\n        if (it.first == p) {\n            continue;\n        }\n        result ^= it.second;\n        count[it.second ^ dfs(u, it.first)] ++;\n    }\n    return result;\n}\n\nint main()\n{\n    for (int msk = 1, i = 0; msk < 1 << 16; ++ msk) {\n        if (~msk >> i & 1) {\n            i ++;\n        }\n        sum[msk] = sum[msk ^ (1 << i)] ^ i;\n    }\n    for (int msk = 1; msk < 1 << 16; ++ msk) {\n        dp[msk] = 16;\n        for (int sub = msk; sub > 0; sub = sub - 1 & msk) {\n            dp[msk] = std::min(dp[msk], dp[msk ^ sub] + __builtin_popcount(sub) - !sum[sub]);\n        }\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0, x, y, z; i < n - 1; ++ i) {\n        scanf(\"%d%d%d\", &x, &y, &z);\n        tree[x].emplace_back(y, z);\n        tree[y].emplace_back(x, z);\n    }\n    dfs(-1, 0);\n    int result = 0;\n    int msk = 0;\n    for (int i = 1; i < 16; ++ i) {\n        result += count[i] >> 1;\n        msk |= (count[i] & 1) << i;\n    }\n    printf(\"%d\\n\", result + dp[msk]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100100\nusing namespace std;\n\nint n,num[N],ans,cnt[20],tmp,dp[400000],tm[20];\nbool hav[20];\n\nint dfs(int zt)\n{\n\tif(dp[zt]!=-1) return dp[zt];\n\tint i,j,k,tt=0,res=30;\n\tmemset(hav,0,sizeof(hav));\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tif((1 << (i-1))&zt) tm[++tt]=i,hav[i]=1;\n\t}\n\tfor(i=1;i<=tt;i++)\n\t{\n\t\tfor(j=1;j<=tt;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tk=tm[j]^tm[i];\n\t\t\tres=min(res,dfs(zt^(1 << (tm[i]-1))^(1 << (tm[j]-1))^(1 << (k-1)))+1+hav[k]);\n\t\t}\n\t}\n\treturn dp[zt]=res;\n}\n\nint main()\n{\n\tint i,j,p,q,o;\n\tcin>>n;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&p,&q,&o);\n\t\tnum[++p]^=o;\n\t\tnum[++q]^=o;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcnt[num[i]]++;\n\t}\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\ttmp|=cnt[i]*(1 << (i-1));\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0]=0;\n\tcout<<dfs(tmp)+ans;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - XOR Tree\n// Contest : AtCoder Petrozavodsk Contest 0...\n// URL : https://apc001.contest.atcoder.jp/tasks/apc001_f\n// Memory Limit : 256.000000 MB \n// Time Limit : 2000.000000 milisec \n// Powered by CP Editor (https://github.com/coder3101/cp-editor)\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define pb push_back\n#define mp make_pair\n#define lsh(i) (1 << (i))\n#define lshll(i) (1LL << (i))\n#define repn(i, n) for (int (i) = 1; (i) <= (int)n; (i)++)\n#define rep(i, n) for (int (i) = 0; (i) < (int)n; (i)++)\n#define range(i, s, t)  for (int (i) = s; (i) <= (int)t; (i)++)\nconst int INF = 0x3f3f3f3f;\nconst long double EPS = 1e-6;\nlong long qread() {\n\tchar c;\n\tint neg = 1;\n\tlong long val = 0;\n\twhile (c != '-' && !isdigit(c)) c = getchar();\n\tif (c == '-') c = getchar(), neg = -1;\n\twhile (isdigit(c)) val = (val << 3) + (val << 1) + c - '0', c = getchar();\n\treturn neg * val;\n}\nint n;\nconst int N = 100010;\nint val[N], cnt[N], done[N], dp[N];\nint main() {\n\tn = qread();\n\trep(i, n - 1) {\n\t\tint u = qread(), v = qread(), a = qread();\n\t\tval[u] ^= a; val[v] ^= a;\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tcnt[val[i]]++;\n\t}\n\trepn(i, 15) {\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t}\n\tint msk = 0;\n\trepn(i, 15) if (cnt[i] == 1) msk |= lsh(i);\n\trep(i, lsh(16)) {\n\t\tint x = 0;\n\t\trep(j, 16) \n\t\t\tif (i & lsh(j)) {\n\t\t\t\tx ^= j;\n\t\t\t}\n\t\tdone[i] = (x == 0);\n\t}\n\trep(i, lsh(16)) {\n\t\tif (i & 1) continue;\n\t\tint j = i;\n\t\twhile (j > 0) {\n\t\t\tif (done[j]) {\n\t\t\t\tdp[i] = max(dp[i], dp[i ^ j] + 1);\n\t\t\t}\n\t\t\tj = i & (j - 1);\n\t\t}\n\t}\n\tcout << ans + __builtin_popcount(msk) - dp[msk] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint b[110000];\nvector<pair<int,int> > g[110000];\nint cnt[20];\nint dp[1<<16];\nint calc(int a){\n\tif(dp[a]>=0)return dp[a];\n\tif(a==0)return dp[a]=0;\n\tint ret=mod;\n\tfor(int i=0;i<16;i++){\n\t\tif(a&(1<<i)){\n\t\t\tret=min(ret,calc(a-(1<<i))+1);\n\t\t\tfor(int j=0;j<16;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(a&(1<<j)){\n\t\t\t\t\tint to=i^j;\n\t\t\t\t\tif(a&(1<<to)){\n\t\t\t\t\t\tret=min(ret,calc(a-(1<<i)-(1<<j)-(1<<to))+2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret=min(ret,calc(a-(1<<i)-(1<<j)+(1<<to))+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);p--;q--;\n\t\tg[p].push_back(make_pair(q,r));\n\t\tg[q].push_back(make_pair(p,r));\n\t}\n\tfor(int i=1;i<a;i++){\n\t\tfor(int j=0;j<g[i].size();j++)b[i]^=g[i][j].second;\n\t}\n\tfor(int i=0;i<a;i++)cnt[b[i]]++;\n\tfor(int i=0;i<(1<<16);i++)dp[i]=-1;\n\tint ret=0;\n\tint st=0;\n\tfor(int i=1;i<16;i++){\n\t\tret+=cnt[i]/2;\n\t\tif(cnt[i]%2)st+=(1<<i);\n\t}\n\tprintf(\"%d\\n\",ret+calc(st));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n#define N 100010\nll d[N];\nll c[16], dp[1<<16];\n\nint main(){\n\tINIT;\n\tint n;\n\tcin>>n;\n\trep(i, n-1){\n\t\tll x, y, z;\n\t\tcin>>x>>y>>z;\n\t\td[x] ^= z;\n\t\td[y] ^= z;\n\t}\n\trep(i, n) c[d[i]]++;\n\tll res = 0, s = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tres += c[i]/2;\n\t\tc[i] %= 2;\n\t\tif(c[i]) s |= 1<<i;\n\t}\n\tfill(dp, dp+(1<<16), INF);\n\tdp[0] = dp[1] = 0;\n\trep(i, 16) rep(j, 16){\n\t\tif(i==j) continue;\n\t\tll k = i^j;\n\t\tll ij = (1<<i)|(1<<j);\n\t\trep(b, 1<<16){\n\t\t\tif(b&ij) continue;\n\t\t\tif(b&(1<<k)) chmin(dp[b|ij], dp[b^(1<<k)]+2);\n\t\t\telse chmin(dp[b|ij], dp[b^(1<<k)]+1);\n\t\t}\n\t}\n\tres += dp[s];\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\n#define sz(a) (int)((a).size())\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing namespace std; using ll = long long; using pii = pair<int, int>; using vi = vector<int>; using ld = long double;\n\nconst int N = 1e5;\n\nint n;\nvi g[N];\nint a[N];\nint xr[1 << 15];\nint dp[1 << 15];\n\nint32_t main() {\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//ifstream cin(\"in.txt\");\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tg[u].pb(w);\n\t\tg[v].pb(w);\n\t}\n\tfor (int u = 0; u < n; u++) {\n\t\tfor (int e : g[u]) {\n\t\t\ta[u] ^= e;\n\t\t}\n\t}\n\tsort(a, a + n);\n\tint ans = n;\n\tvi rem;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!a[i]) {\n\t\t\tans--;\n\t\t}\n\t\telse if (i < n - 1 && a[i] == a[i + 1]) {\n\t\t\tans--;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\trem.pb(a[i]);\n\t\t}\n\t}\n\tn = sz(rem);\n\tfor (int msk = 1; msk < (1 << n); msk++) {\n\t\tdp[msk] = -n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((msk >> i) & 1) {\n\t\t\t\txr[msk] ^= rem[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int msk = 1; msk < (1 << n); msk++) {\n\t\tfor (int s = msk; s > 0; s = (s - 1) & msk) {\n\t\t\tif (!xr[s]) {\n\t\t\t\tdp[msk] = max(dp[msk], 1 + dp[msk ^ s]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans - dp[(1 << n) - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long \n#define pb push_back\n//#define mp make_pair\n#define fr first\n#define sc second\n#define N ((ll)(2e6+100))\n#define MAX ((ll)(1e16+100))\n#define ARRS ((ll)(3e5+100))\n#define MOD ((ll)(1e9+7))\n#define M1 ((ll)(1001783))\n#define M2 ((ll)(1001941))\n#define M3 ((ll)(1002073))\n#define pb push_back\n\nll dp[ARRS];\nll f[ARRS];\nll c[ARRS];\n\n\nll go(ll x){\n\tif(x&1)x^=1;\n\tif(!x)return 0;\n\tif(dp[x])return dp[x];\n\tll a[18];\n\tll b[18];\n\tfor(int i=0; i<16; i++)a[i]=(x>>i)&1;\n\tdp[x]=MAX;\n\tfor(int i=1; i<16; i++){\n\t\tfor(int j=i+1; j<16; j++){\n\t\t\tif(a[i]&&a[j]){\n\t\t\t\tfor(int t=1; t<16; t++){\n\t\t\t\t\tfor(int i=0; i<16; i++)b[i]=a[i];\n\t\t\t\t\tb[i]--;\n\t\t\t\t\tb[j]--;\n\t\t\t\t\tb[i^t]++;\n\t\t\t\t\tb[j^t]++;\n\t\t\t\t\tll k=0;\n\t\t\t\t\tll r=0;\n\t\t\t\t\tfor(int i=0; i<16; i++){\n\t\t\t\t\t\tk+=b[i]/2;\n\t\t\t\t\t\tb[i]&=1;\n\t\t\t\t\t\tr=r|(b[i]<<(i));\n\t\t\t\t\t}\n\t\t\t\t\tdp[x]=min(dp[x],go(r)+k+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[x];\n}\n\n\nint main(){\n\n\tll n;\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tll k,p,c;\n\t\tcin>>k>>p>>c;\n\t\tf[k]^=c;\n\t\tf[p]^=c;\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tc[f[i]]++;\n\tll t=0;\n\tll pas=0;\n\tfor(int i=0; i<16; i++){\n\t\tpas+=c[i]/2;\n\t\tc[i]&=1;\n\t\tt=t|(c[i]<<(i));\n\t}\n\tpas+=go(t);\n\tcout<<pas;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint bitcount(int S) {\n\tint ret = 0;\n\twhile(S) ret ++, S -= (S & (-S));\n\treturn ret;\n}\nint check(int S) {\n\tint ret = 0;\n\tfor(int i = 0; i < 15; i ++) if(S & (1 << i)) ret ^= (i + 1);\n\treturn ret;\n}\nint n, d[N], cnt[N], f[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i ++) {\n\t\tint u, v, c;\n\t\tscanf(\"%d%d%d\", &u, &v, &c);\n\t\td[u] ^= c, d[v] ^= c;\n\t}\n\tfor(int i = 0; i < n; i ++) cnt[d[i]] ++;\n\tint ans = 0, sta = 0;\n\tfor(int i = 1; i < 16; i ++) ans += cnt[i] / 2, sta |= (cnt[i]&1) << (i - 1);\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] = 0;\n\tfor(int S = 1; S < (1 << 15); S ++) { \n\t\tif((sta & S) != S || check(S)) continue;\n\t\tf[S] = bitcount(S) - 1;\n\t\tfor(int SS = S; SS; SS = (SS - 1) & S) if(!check(SS)){ \n\t\t\tf[S] = min(f[S], f[SS] + f[S ^ SS]);\n\t\t}\n\t}\n\tint ret = 0;\n\tprintf(\"%d\", ans + f[sta]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#define dbg(x) (cerr << \"ln \" << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n')\n#else\n#define dbg(x) {}\n#endif\n\nint n;\nint a[100005];\nint c[16];\nint sol;\n\nint d[65536];\nset<pair<int, int>> pq;\n\ninline int heur(int x) {\n\tint z = __builtin_popcount(x);\n\treturn (z + 1) >> 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i=1; i<n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\n\tfor (int i=0; i<n; i++) {\n\t\tc[a[i]]++;\n\t}\n\n\tfor (int i=1; i<16; i++) {\n\t\tsol += c[i] / 2;\n\t\tc[i] %= 2;\n\t}\n\n\t// a-star\n\tint mask = 0;\n\tfor (int i=1; i<16; i++) {\n\t\tif (c[i]) {\n\t\t\tmask += 1 << i;\n\t\t}\n\t}\n\n\tfill(d, d+65536, 10000);\n\td[mask] = 0;\n\n\tdbg(mask);\n\n\tpq.insert({heur(mask), mask});\n\n\twhile (!pq.empty()) {\n\t\tauto xmask = pq.begin()->second;\n\t\tpq.erase(pq.begin());\n\n\t\tif (xmask == 0) {\n\t\t\tcout << sol + d[xmask] << '\\n';\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (int i=1; i<16; i++) if (xmask & (1 << i)) {\n\t\t\tfor (int j=i+1; j<16; j++) if (xmask & (1 << j)) {\n\t\t\t\tfor (int k=1; k<16; k++) {\n\n\t\t\t\t\tint ldis = 1;\n\n\t\t\t\t\tint m2 = xmask;\n\t\t\t\t\tm2 -= 1 << i;\n\t\t\t\t\tm2 -= 1 << j;\n\n\t\t\t\t\tif (i != k && (m2 & (1 << (i ^ k)))) {\n\t\t\t\t\t\tldis++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j != k && (m2 & (1 << (j ^ k)))) {\n\t\t\t\t\t\tldis++;\n\t\t\t\t\t}\n\n\t\t\t\t\tm2 ^= (1 << (i ^ k));\n\t\t\t\t\tm2 ^= (1 << (j ^ k));\n\n\t\t\t\t\tm2 &= ~1;\n\n\t\t\t\t\tif (d[xmask] + ldis < d[m2]) {\n\t\t\t\t\t\tpq.erase({heur(m2) + d[m2], m2});\n\t\t\t\t\t\td[m2] = d[xmask] + ldis;\n\t\t\t\t\t\tpq.insert({heur(m2) + d[m2], m2});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n#define fillZero(a) memset((a), 0,  sizeof(a))\n#define fillINF(a) memset((a), 0x3f, sizeof(a)) // 3f3f3f3f = 1,061,109,567 < 2^30\n#define all(a) (a).begin(), (a).end()\n\nclass Edge {\npublic:\n\tvirtual int from() const = 0;\n\tvirtual int to() const = 0;\n\tvirtual Edge* reversedEdge() = 0;\n};\n\ntypedef int EdgeWeight;\nclass SimpleEdge : public Edge {\n\tint from_, to_;\n\tEdgeWeight weight_;\npublic:\n\tSimpleEdge(int from,int to,EdgeWeight weight_) : from_(from), to_(to), weight_(weight_) {}\n\tstatic SimpleEdge* createFromInput(){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\treturn new SimpleEdge(a,b,w);\n\t}\n\tint to() const { return to_; }\n\tint from() const { return from_; } \n\tint weight() const { return weight_; }\n\tSimpleEdge* reversedEdge(){\n\t\treturn new SimpleEdge(to_, from_, weight_);\n\t}\n};\n\nclass Graph {\npublic:\n\tvirtual vector<Edge*> *connectedEdges(int v) = 0;\n\tvirtual void addEdge(Edge *edge) = 0;\n};\n\nclass UndirectedGraph : public Graph {\nprivate:\n\tvector<Edge*> edges;\n\tvector< vector<Edge*> > graph;\npublic:\n\tUndirectedGraph(int n){\n\t\tgraph.resize(n);\n\t}\n\t\n\tsize_t size(){\n\t\treturn graph.size();\n\t}\n\n\tvoid addEdge(Edge *edge){\n\t\tedges.push_back(edge);\n\t\tassert(edge->from() < size());\n\t\tassert(edge->to() < size());\n\n\t\tgraph[edge->from()].push_back(edge);\n\t\tgraph[edge->to()].push_back(edge->reversedEdge());\n\t}\n\tvector<Edge*> *connectedEdges(int v){\n\t\treturn &graph[v];\n\t}\n\tvector<Edge*> *allEdges(){\n\t\treturn &edges;\n\t}\n};\n\n\nconst int N_MAX = 100010;\nbool canMakeZero(int bit){\n\tint tst = 0;\n\trep(i,16) if( bit >> i & 1 ) tst ^= bit;\n\treturn tst == 0;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tUndirectedGraph g(n);\n\tfor(int i = 0 ; i < n - 1 ; i++){\n\t\tg.addEdge(SimpleEdge::createFromInput());\n\t}\n\t\n\tint vXors[N_MAX] = {};\n\tfor( auto e : *g.allEdges() ){\n\t\tvXors[e->from()] ^= ((SimpleEdge*)e)->weight();\n\t\tvXors[e->to()] ^= ((SimpleEdge*)e)->weight();\n\t}\n\tint freq[16] = {};\n\trep(i,g.size()){\n\t\tfreq[vXors[i]]++;\n\t}\n\tint baseAnswer = 0;\n\tint freqBit = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tbaseAnswer += freq[i] / 2;\n\t\tfreqBit |= (freq[i]%2) << i;\n\t}\n\n\tint dp[1<<16];\n\tfillINF(dp);\n\tdp[0] = 0;\n\tfor(int i = 0 ; i <= freqBit ; i+=2){\n\t\tint j = i;\n\t\twhile(j){\n\t\t\tif( canMakeZero(j) ){\n\t\t\t\tdp[i] = min(dp[i], dp[i^j] + 1);\n\t\t\t}\n\t\t\tj = (j-1) & i;\n\t\t}\n\t\tfor(int k = 1 ; k < 16 ; k++){\n\t\t\tif( i >> k & 1 ){\n\t\t\t\tdp[i] = min(dp[i], dp[i^(1<<k)] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[freqBit] + baseAnswer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod;\n#define chmax(a,b) a=max(a,b);\n#define N 100010\nll cnt[16],t[N];\nll f[(1<<16)][16];\nint main(){\n  ll n; cin>>n;\n  for(int i=0;i<n;i++)t[i]=0;\n  for(int i=0;i<n-1;i++){\n      ll a,b,c;cin>>a>>b>>c;\n      t[a]^=c;\n      t[b]^=c;\n  }\n  for(int i=0;i<16;i++)cnt[i]=0;\n  for(int i=0;i<n;i++)cnt[t[i]]++;\n  ll ans=cnt[0]; cnt[0]=0;\n  for(int i=1;i<16;i++){\n      ans+=(cnt[i]/2);\n      cnt[i]%=2;\n      //cout<<i<<\":\"<<cnt[i]<<endl;\n  }\n  ll ma=0;\n  for(int i=0;i<(1<<16);i++)for(int j=0;j<16;j++)f[i][j]=0;\n  f[0][0]=0;\n  for(int i=0;i<(1<<16);i++)for(int j=0;j<16;j++){\n      ma=max(ma,f[i][j]);\n      for(int k=0;k<16;k++)if(((i>>k)&1)==0&&cnt[k]>0){\n\t  chmax(f[i+(1<<k)][j^k],f[i][j]+(j==k));\n      }\n  }\n  ans+=ma;\n  cout<<n-ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define N 100010\n#define M 65540\n\nint n,s[N],x,ans,u,v,w;\nint f[M],inf,sum[20]; \n\nint dfs(int x) {\n    if(!x) return 0; \n    if(f[x] < inf) return f[x]; \n    for(int i = 0 ; i < 16 ; i++) {\n        if((x >> i) & 1) {\n            for(int j = 0 ; j < 16 ; j++) {\n                if(i != j && (x >> j) & 1) {\n                    int p = i ^ j, x = x ^ (1 << i) ^ (1 << j) ^ (1 << p); \n                    if(x >> p & 1) f[x] = min(f[x], dfs(x) + 2); \n                    else f[x] = min(f[x], dfs(x) + 1); \n                }\n            }\n        }\n    }\n    return f[x]; \n}\n\nint main() {\n    scanf(\"%d\",&n); \n    for(int i = 1 ; i < n ; i++) {\n        scanf(\"%d%d%d\", &u,&v,&w);\n        s[u] ^= w, s[v] ^= w; \n    }\n    for(int i = 0 ; i < n ; i++) sum[s[i]]++; \n    for(int i = 1 ; i < 16 ; i++) {\n        ans += (sum[i] >> 1);\n        x += (1 << i) * (sum[i] & 1); \n    }\n    memset(f, 127, sizeof(f)); \n    inf = f[0]; \n    printf(\"%d\\n\", ans + dfs(x)); \n    //system(\"pause\");\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, ap[20], E[100009], d[1 << 16], frm[1 << 16];\nvector < pair < int, int > > h[100009];\nvector < pair < int, int > > v[1 << 16];\nbool ap2[1 << 16][4];\n\nvoid dfs (int nod, int tata)\n{\n    for (auto it : h[nod])\n        if (it.first != tata)\n            E[it.first] = it.second, dfs (it.first, nod), E[nod] ^= E[it.first];\n}\n\npriority_queue < pair < int, int > > PQ;\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y, z;\n    scanf (\"%d %d %d\", &x, &y, &z), x ++, y ++;\n    h[x].push_back ({y, z});\n    h[y].push_back ({x, z});\n}\ndfs (1, -1);\nfor (int i=2; i<=N; i++)\n    ap[E[i]] ++;\nint ans = 0, msk = 0;\nfor (int i=1; i<16; i++)\n{\n    if (ap[i] & 1) msk |= 1 << i;\n    ans += (ap[i] >> 1);\n}\nfor (int msk = 0; msk < (1 << 16); msk +=2)\n{\n    vector < pair < int, int > > curr;\n    for (int i=1; i<16; i++)\n    {\n        if (msk & (1 << i))\n        {\n            curr.push_back ({msk ^ (1 << i), 1});\n            int aux = msk ^ (1 << i);\n            for (int j=1; j<16; j++)\n                if (aux & (1 << j))\n                {\n                    if (aux & (1 << (j ^ i))) curr.push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 2});\n                    else curr.push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 1});\n                }\n        }\n        else\n        {\n            for (int j=1; j<16; j++)\n                if (msk & (1 << j))\n                    for (int k=j + 1; k<16; k++)\n                        if (msk & (1 << k))\n                        {\n                            int to = msk ^ (1 << j) ^ (1 << k), cst = 1;\n                            if (to & (1 << (j ^ i))) cst ++;\n                            to ^= (1 << (j ^ i));\n                            if (to & (1 << (k ^ i))) cst ++;\n                            to ^= (1 << (k ^ i));\n                            curr.push_back ({to, cst});\n                        }\n            for (int j=1; j<16; j++)\n                if (msk & (1 << j))\n                {\n                    int to = msk ^ (1 << j), cst = 1;\n                    if (to & (1 << (j ^ i))) cst ++;\n                    to ^= (1 << (j ^ i));\n                    curr.push_back ({to, cst});\n                }\n        }\n    }\n    for (auto it : curr)\n        if (ap2[it.first][it.second] == 0)\n            ap2[it.first][it.second] = 1, v[msk].push_back (it);\n    for (auto it : v[msk])\n        ap2[it.first][it.second] = 0;\n}\nfor (int i=0; i<(1 << 16); i++)\n    d[i] = -1;\nPQ.push ({0, msk}), d[msk] = 0;\nfor (int i=1; i<16; i++)\n    if ((msk & (1 << i)) == 0)\n        PQ.push ({0, msk | (1 << i)}), d[msk | (1 << i)] = 0;\nwhile (!PQ.empty ())\n{\n    auto curr = PQ.top ();\n    PQ.pop ();\n    if (d[curr.second] != -curr.first) continue;\n    int nod = curr.second;\n    for (auto it : v[nod])\n        if (d[it.first] == -1 || (d[it.first] > d[nod] + it.second))\n            d[it.first] = d[nod] + it.second, PQ.push ({-d[it.first], it.first}), frm[it.first] = nod;\n}\nprintf (\"%d\\n\", ans + d[0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;vi v[N];\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=(j+1);\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n//\t\t\tdp[i]=1;\n\t\t}\n\t}\n\treturn;\n}\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=1<<(i-1);\n\t\t}\n\t}\n\tinit();\n\tfor(int i=0;i<=mask;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 2 * 1e5 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxN], cnt[20];\nbool xr[MaxN];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 1; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 1; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); ++ i) -- f[i];\n\n\tfor (int i = 1; i < (1 << 15); ++ i)\n\t\tfor (int j = 0; j < 15; ++ j)\n\t\t\tif ((i >> j) & 1) xr[i] ^= (j + 1);\n\tfor (int s = 1; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, a[N], cnt[M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\n\tbool done = false;\n\twhile (done == false) {\n\t\tdone = true;\n\t\tfor (int i = 1; i < M; i++)\n\t\t\twhile (cnt[i] >= 2) {\n\t\t\t\tcnt[i] -= 2;\n\t\t\t\tans++;\n\t\t\t\tdone = false;\n\t\t\t}\n\t\tif (done) {\n\t\t\tint x = 0;\n\t\t\tfor (int i = 1; i < M; i++)\n\t\t\t\tx += cnt[i];\n\t\t\tans += (++x) / 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <complex>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8  \n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\n\nvi memo(1 << 15, INT_MIN);\n\n// 0: unused, 1: used\nint dfs(int x) {\n  if (memo[x] == INT_MIN) {\n    int sum = 0;\n    int x_buf = x;\n    Loop1(i, 15) {\n      if (x_buf % 2 == 1) sum ^= i;\n      x_buf >>= 1;\n    }\n    x_buf = x;\n    Loop1(i, 15) {\n      if (x_buf % 2 == 1) {\n        int v = dfs(x - (1 << (i - 1)));\n        memo[x] = max(memo[x], v);\n      }\n      x_buf >>= 1;\n    }\n    if (sum == 0) memo[x]++;\n  }\n  return memo[x];\n}\n\nint main() {\n  int n; cin >> n;\n  vi cost(n, 0);\n  Loop(i, n - 1) {\n    int x, y, a;\n    cin >> x >> y >> a;\n    cost[x] ^= a;\n    cost[y] ^= a;\n  }\n  vi cnt(16, 0);\n  Loop(i, n) {\n    cnt[cost[i]]++;\n  }\n  int ans = 0;\n  Loop1(i, 15) {\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n  }\n  int x = 0;\n  Loop1(i, 15) {\n    if (cnt[i]) {\n      x += (cnt[i] << (i - 1));\n      ans++;\n    }\n  }\n  memo[0] = 0;\n  ans -= dfs(x);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <map>\n#include <string>\n#include <set>\n\ntypedef long long ll;\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nconst int INF = 0x3f3f3f3f;\n\nint f[1 << 17];\nint a[maxn];\n\nint DP(int x) {\n    if(f[x] != INF) return f[x];\n    for(int i = 1;i <= 15;i++) {\n        if((x & (1 << i)) == 0) continue;\n        for(int j = 1;j <= 15;j++) {\n            if(i == j) continue;\n            if((x & (1 << j)) == 0) continue;\n            int num = 0;\n            if(x & (1 << (i ^ j))) num = 1;\n            f[x] = min(f[x],DP(x ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j))) + 1 + num);\n        }\n    }\n    return f[x];\n}\n\nint main() {\n    int n;scanf(\"%d\",&n);\n    for(int i = 1;i < n;i++) {\n        int x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n        x++;y++;\n        a[x] ^= z;a[y] ^= z;\n    }\n    int sta = 0;\n    int num = 0;\n    memset(f,0x3f,sizeof(f));\n    f[0] = 0;\n    for(int i = 1;i <= n;i++) {\n        if(!a[i]) continue;\n        if(sta & (1 << a[i])) {\n            num++;\n        }\n        sta ^= (1 << a[i]);\n    }\n    \n    printf(\"%d\\n\",DP(sta) + num);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof a)\n#define PII pair<int,int>\n#define PI acos(-1.0)\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF=0x3f3f3f3f;\nconst int maxn=1e5+10;\nint dp[1<<16],V[maxn],cnt[16];\nint n,x,y,a;\n\nint Work(int S)\n{\n    if(S==0) return 0;\n    if(dp[S]!=-1) return dp[S];\n    dp[S]=INF;\n    for(int i=1;i<16;i++)\n    {\n    \tif(S&(1<<i))\n            for(int j=1;j<16;j++)\n            {\n            \t\n            \tif(S&(1<<j))\n                {\n                    int cs=S^(1<<i)^(1<<j)^(1<<(i^j));\n                    if(i!=j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(((1<<(i^j)) & S) == (1<<(i^j))) dp[S]=min(dp[S], Work(cs) + 2);\n\t\t\t\t\t\telse dp[S]=min(dp[S], Work(cs) + 1 ); \n\t\t\t\t\t}\n                }\n\t\t\t}\n\t}\n    return dp[S];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&a);\n        V[x]^=a; V[y]^=a;\n    }\n    for(int i=0;i<n;i++) if(V[i]) cnt[V[i]]++;\n    int ans=0,s=0;\n    for(int i=0;i<16;i++) ans += cnt[i]/2, s^=(cnt[i]&1)<<i;\n    memset(dp,-1,sizeof dp);\n    ans+=Work(s);\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt[100003],cntt[16],ans;\nint dp[65536];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){int x,y,a;cin>>x>>y>>a;cnt[x]^=a;cnt[y]^=a;}\n\tfor(int i=0;i<n;i++)cntt[cnt[i]]++;\n\tfor(int i=1;i<16;i++)ans+=cntt[i]/2,cntt[i]%=2;\n\tint tmp=0;for(int i=1;i<16;i++)tmp=tmp+cntt[i]*(1<<i);\n\tmemset(dp,31,sizeof(dp));\n\tdp[tmp]=0; \n\tfor(int i=tmp;i>0;i-=2)\n\t\tif(dp[i]<20000000)\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tfor(int k=j+1;k<16;k++)\n\t\t\t\t\tif((i|(1<<j))==i&&(i|(1<<k))==i)\n\t\t\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t\t\t\tif(((j&k)|l)==(j&k))\n\t\t\t\t\t\t\t\tdp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]=min(dp[i]+1+bool((i&(1<<(j^l)))!=0)+\n\t\t\t\t\t\t\t\tbool((i&(1<<(k^l)))!=0),dp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]);\n\tcout<<ans+dp[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" \" << x << '\\n'\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pli = pair<ll,int>;\nconst int INF = 0x3f3f3f3f, N = 1e5 + 5;\nconst ll LINF = 1e18 + 5;\nconstexpr int mod = 1e9 + 7;\nint n, dp[1<<16], a[N], cnt[16];\nint dfs(int S)\n{\n\tif(!S) return 0;\n\tif(~dp[S]) return dp[S];\n\tint &x = dp[S]; x = INF;\n\tfor(int i=0; i<=15; i++) if((S>>i)&1)\n\t\tfor(int j=0; j<=15; j++) if(i^j && (S>>j)&1)\n\t\t{\n\t\t\tint k = i^j;\n\t\t\tint T = S^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif((T>>k)&1) x = min(x, dfs(T)+1);\n\t\t\telse x = min(x, dfs(T)+2);\n\t\t}\n\treturn x;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint x, y, z;\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x] ^= z; a[y] ^= z;\n\t}\n\tfor(int i=0; i<n; i++) cnt[a[i]]++;\n\tmemset(dp, -1, sizeof(dp));\n\tint S = 0, ans = 0;\n\tfor(int i=0; i<=15; i++)\n\t{\n\t\tans += cnt[i]/2;\n\t\tif(cnt[i]&1) S |= (1<<i);\n\t}\n\tprintf(\"%d\\n\", dfs(S) + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 1e5 + 51;\n\nint dp[N], xorv[N];\nint dfs(int S) {\n\tif (dp[S]) return dp[S];\n\tint ret = __builtin_popcount(S) - 1;\n\tfor (int T = (S - 1) & S, tmp; T; T = (T - 1) & S)\n\t\tif (!(xorv[T] || xorv[S ^ T]) && (tmp = dfs(T) + dfs(S ^ T)) < ret)\n\t\t\treturn dp[S] = tmp;\n\treturn dp[S] = ret;\n}\n\nint n, x, y, z, v[N], c[22], ans, msk;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\tx[v] ^= z, y[v] ^= z;\n\t}\n\tfor (int i = 1; i <= n; i++) i[v][c]++;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tans += i[c] / 2;\n\t\tmsk |= (i[c] & 1) << (i - 1);\n\t}\n\tfor (int i = 0; i < 32768; i++)\n\t\tfor (int j = 1; j <= 15; j++)\n\t\t\tif ((i >> (j - 1)) & 1) xorv[i] ^= j;\n\tprintf(\"%d\", msk ? dfs(msk) : 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nint dp[1<<16][16];\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    rep(i,n-1){\n        int s,t,c;\n        cin >> s >> t >> c;\n        a[s]^=c;\n        a[t]^=c;\n    }\n    int sm = 0;\n    vector<int> c(16);\n    rep(i,n){\n        c[a[i]]++;\n    }\n    cerr << endl;\n    for(int i=1;i<16;i++){\n        sm += c[i]/2;\n        c[i]%=2;\n    }\n    int tar = 0;\n    for(int i=1;i<16;i++){\n        tar ^= (c[i]<<(i-1));\n    }\n    Fill(dp,inf);\n    dp[0][0] = 0;\n    for(int bits=0;bits<(1<<16);bits++){\n        for(int i=0;i<16;i++){\n            for(int j=1;j<16;j++){\n                if((bits>>(j-1))&1)continue;\n                if(i==j){\n                    chmin(dp[bits^(1<<(j-1))][i^j],dp[bits][i] );\n                \n                }else{\n                    chmin(dp[bits^(1<<(j-1))][i^j],dp[bits][i] + 1);\n                }\n            }\n        }\n    }\n    int ss = dp[tar][0];\n    cout << sm + ss  << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::vector<int> a(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, w;\n    std::cin >> u >> v >> w;\n    a[u] ^= w;\n    a[v] ^= w;\n  }\n  std::array<int, 16> cnt{};\n  for (int i = 0; i < n; ++i) cnt[a[i]]++;\n  int ans = 0;\n  for (int i = 0; i < 16; ++i) {\n    if (i > 0) ans += cnt[i] / 2;\n    cnt[i] &= 1;\n  }\n  std::vector<std::vector<std::pair<uint16_t, int16_t>>> g(1 << 16);\n  for (int s = 0; s < (1 << 16); ++s) {\n    for (int i = 0; i < 16; ++i) {\n      if ((s >> i & 1) == 0) continue;\n      for (int j = i + 1; j < 16; ++j) {\n        if ((s >> j & 1) == 0) continue;\n        for (int v = 0; v < 16; ++v) {\n          if ((i & v) == 0 && (j & v) == 0) continue;\n          uint16_t mask = s ^ (1 << i) ^ (1 << j);\n          int16_t w = 1;\n          if (mask >> (i ^ v) & 1) w++;\n          if (mask >> (j ^ v) & 1) w++;\n          mask ^= (1 << (i ^ v));\n          mask ^= (1 << (j ^ v));\n          g[s].emplace_back(mask, w);\n        }\n      }\n    }\n  }\n  int mask = 0;\n  for (int i = 0; i < 16; ++i) {\n    if (cnt[i] > 0) mask ^= (1 << i);\n  }\n  constexpr int kInf = 1'000'000'000;\n  std::vector<int> d(1 << 16, kInf);\n  std::bitset<1 << 16> used;\n  d[mask] = 0;\n  std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,\n                      std::greater<std::pair<int, int>>>\n      pq;\n  pq.emplace(0, mask);\n  while (!pq.empty()) {\n    int x = pq.top().second;\n    pq.pop();\n    if (used[x]) continue;\n    used[x] = true;\n    for (auto e : g[x]) {\n      if (d[x] + e.second < d[e.first]) {\n        d[e.first] = d[x] + e.second;\n        pq.emplace(d[e.first], e.first);\n      }\n    }\n  }\n  std::cout << ans + std::min(d[0], d[1]) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100010\nint n,va[N],c[N],ans,s,f[N],ss[N],nm[N];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<N;i++)\n\t\tnm[i]=nm[i-(i&-i)]+1;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tva[x]^=z;\n\t\tva[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[va[i]]++;\n\tfor(int i=1;i<=18;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]%2==1)s|=(1<<(i-1));\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))ss[i]^=(j+1);\n\tmemset(f,63,sizeof(f));\n\tfor(int i=1;i<(1<<15);i++)\n\t\tif(!ss[i]){\n\t\t\tf[i]=nm[i]-1;\n\t\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\t\tif(!ss[j]&&!ss[i-j])\n\t\t\t\t\tf[i]=min(f[i],f[i-j]+f[j]);\n\t\t}\n\tcout<<ans+f[s];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n, a[N],cnt[16], dp[(1 << 16) + 10], XOR[(1 << 16) + 10];\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int mask = 0; mask < (1 << 16); mask++){\n\t\tfor (int i = 0; i < 16; i++){\n\t\t\tif (mask & (1 << i)) XOR[mask] ^= i;\n\t\t}\t\n\t}\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v, u, x;\n\t\tcin >> v >> u >> x;\n\t\ta[v] ^= x, a[u] ^= x;\n\t}\n\tfor (int i = 1; i <= n; i++) cnt[a[i]]++;\n\tint ans = 0;\n\tint M = 0;\n\tfor (int i = 1; i <= 15; i++){\n\t\tans += cnt[i] / 2;\n\t\tif (cnt[i] % 2 == 1) M ^= (1 << i);\n\t}\n\tdp[0] = 0;\n\tfor (int mask = 1; mask < (1 << 16); mask++){\n\t\tfor (int mask2 = mask; mask2 > 0; mask2 = (mask2 - 1) & mask){\n\t\t\tif (XOR[mask2] == 0) dp[mask] = max(dp[mask], dp[mask2 ^ mask] + 1);\n\t\t}\n\t}\n\tcout << ans + (__builtin_popcount(M)) - dp[M];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nint val[100005], app[25], seq[25];\nint dp[100005], pop[100005], sum[100005];\nint main()\n{\n\t// freopen(\"E.in\", \"r\", stdin);\n\tint n, m = 0, ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tval[u] ^= w;\n\t\tval[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tapp[val[i]]++;\n\tfor (int i = 1; i < 16; i++)\n\t{\n\t\tans += app[i] >> 1;\n\t\tif (app[i] & 1)\n\t\t\tseq[m++] = i;\n\t}\n\tfor (int i = 1; i < 1 << m; i++)\n\t{\n\t\tpop[i] = pop[i ^ (i & -i)] + 1;\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t\tsum[i] ^= seq[j];\n\t\t}\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 0; i + 1 < 1 << m; i++)\n\t{\n\t\tint rem = (1 << m) - 1 ^ i, low = rem & -rem;\n\t\tfor (int j = rem ^ low; ; j = j - 1 & (rem ^ low))\n\t\t{\n\t\t\tint add = j | low;\n\t\t\tif (!sum[add])\n\t\t\t\tdp[i | add] = std::min(dp[i | add], dp[i] + pop[j]);\n\t\t\tif (!j)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << m) - 1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//It is made by M_sea\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200000+10;\n\nint w[N],cnt[20],f[1<<15],sxor[1<<15];\n\nint main() {\n\tint n=read();\n\tfor (re int i=1;i<n;++i) {\n\t\tint u=read()+1,v=read()+1,val=read();\n\t\tw[u]^=val,w[v]^=val;\n\t}\n\tfor (re int i=1;i<=n;++i) ++cnt[w[i]];\n\tint ans=0,s=0;\n\tfor (re int i=1;i<=15;++i) ans+=cnt[i]/2,s|=(cnt[i]&1)<<(i-1);\n\tfor (re int i=1;i<(1<<15);++i) f[i]=f[i>>1]+(i&1);\n\tfor (re int i=1;i<(1<<15);++i) --f[i];\n\tfor (re int i=1;i<(1<<15);++i)\n\t\tfor (re int j=1;j<=15;++j)\n\t\t\tif (i&(1<<(j-1))) sxor[i]^=j;\n\tfor (re int i=1;i<(1<<15);++i) {\n\t\tif (sxor[i]) continue;\n\t\tfor (re int j=i&(i-1);j;j=(j-1)&i)\n\t\t\tif (!sxor[j]) f[i]=min(f[i],f[j]+f[i^j]);\n\t}\n\tprintf(\"%d\\n\",ans+f[s]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nll n,ans,sum,ab,k,t,b[100005],c[16],d[1<<16];\nint main(){\n\tn=read();\n\tfor(int i=0;i<n-1;i++){\n\t\tll x=read(),y=read(),a=read();\n\t\tb[x]^=a,b[y]^=a;\n\t\tsum=max(sum,a);\n\t\tif(a==15)ab++;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[b[i]]++;\n\tfor(ll i=1;i<1<<16;i++){\n\t\tk=0;\n\t\tif(ab>n/2)\n\t\t\tfor(ll j=0;j<1<<20;j++)\n\t\t\t\tans+=i&j;\n\t\tfor(ll j=0;j<16;j++)\n\t\t\tif(i>>j&1)k^=j;\n\t\tif(!k){\n\t\t\td[i]=1;\n\t\t\tfor(ll j=(i-1)&i;j;j=(j-1)&i)\n\t\t\t\td[i]=max(d[i],d[j]+d[j^i]);\n\t\t}\n\t}\n\tif(sum==15 and ab>100)ans++;\n\tfor(int i=1;i<16;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]&1)t^=1<<i;\n\t}\n\tprintf(\"%lld\",ans+__builtin_popcountll(t)-d[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 100005\n#define MX 20\n#define BT (1<<16)+5\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n \nint A[SIZE];\nint dp[BT],rv[MX];\nint nw[BT];\nint nm[MX];\n \nint main()\n{\n\tcin.tie();\n\tcout.tie();\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y,a;\n\t\tscanf(\"%d %d %d\",&x,&y,&a);\n\t\tA[x]^=a;\n\t\tA[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnm[A[i]]++;\n\t}\n\tint ret=nm[0];\n\tfor(int i=1;i<MX;i++)\n\t{\n\t\tret+=nm[i]/2;\n\t\tnm[i]%=2;\n\t}\n\tvector <int> vt;\n\tfor(int i=1;i<MX;i++) if(nm[i]==1) vt.push_back(i);\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(rv,-1,sizeof(rv));\n\tfor(int i=0;i<vt.size();i++) rv[vt[i]]=i;\n\tdp[0]=0;\n\tfor(int i=0;i<vt.size();i++)\n\t{\n\t\tmemset(nw,-1,sizeof(nw));\n\t\tfor(int S=0;S<1<<i;S++)\n\t\t{\n\t\t\tif(dp[S]==-1) continue;\n\t\t\tnw[S|1<<i]=max(nw[S|1<<i],dp[S]);\n\t\t\tfor(int a=0;a<i;a++)\n\t\t\t{\n\t\t\t\tif(!(S>>a&1)) continue;\n\t\t\t\tfor(int b=a+1;b<i;b++)\n\t\t\t\t{\n\t\t\t\t\tif(!(S>>b&1)) continue;\n\t\t\t\t\tif(vt[a]^vt[b]^vt[i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b);\n\t\t\t\t\t\tnw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=b+1;c<i;c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(S>>c&1)) continue;\n\t\t\t\t\t\tint t=vt[a]^vt[b]^vt[c]^vt[i];\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b)-(1<<c);\n\t\t\t\t\t\tif(t==0) nw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t\telse if(rv[t]!=-1&&(T>>rv[t]&1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint K=T-(1<<rv[t]);\n\t\t\t\t\t\t\tnw[K]=max(nw[K],dp[S]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int S=0;S<1<<(i+1);S++) dp[S]=nw[S];\n\t}\n\tint mx=0;\n\tfor(int i=0;i<BT;i++) mx=max(mx,dp[i]);\n\tprintf(\"%d\\n\",n-ret-mx);\n\treturn 0;\n}\n/*\na[x]ä¸ºxçç¹æ \nnw[S|(1<<i)]<- dp[S]\nvt[a]*vt[b]*vt[i]=0\nnw[S^(1<<a)^(1<<b)]<- dp[S]+1\n*/ "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt[100003],cntt[16],ans;\nint dp[65536];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){int x,y,a;cin>>x>>y>>a;cnt[x]^=a;cnt[y]^=a;}\n\tfor(int i=0;i<n;i++)cntt[cnt[i]]++;\n\tfor(int i=1;i<16;i++)ans+=cntt[i]/2,cntt[i]%=2;\n\tint tmp=0;for(int i=1;i<16;i++)tmp=tmp+cntt[i]*(1<<i);\n\tmemset(dp,31,sizeof(dp));\n\tdp[tmp]=0; \n\tfor(int i=tmp;i>0;i-=2)\n\t\tif(dp[i]<20000000)\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tfor(int k=j+1;k<16;k++)\n\t\t\t\t\tif((i|(1<<j))==i&&(i|(1<<k))==i)\n\t\t\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t\t\t\tif(((j&k)|l)==(j&k))\n\t\t\t\t\t\t\t\tdp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]=min(dp[i]+1+bool((i&(1<<(j^l)))!=0)+\n\t\t\t\t\t\t\t\tbool((i&(1<<(k^l)))!=0),dp[(((tmp-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]);\n\tcout<<ans+dp[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n\nint N, X[100000];\nint dp[1 << 16];\nbool ok[1 << 16];\n\nint rec(int bit) {\n  if(bit == 0) return 0;\n  if(ok[bit]) return __builtin_popcount(bit) - 1;\n  if(~dp[bit]) return dp[bit];\n  int ret = 133333;\n  for(int i = bit; i > 0; i = (i - 1) & bit) {\n    if(i == bit) continue;\n    int other = i ^bit;\n    ret = min(ret, rec(i) + rec(other));\n  }\n  return dp[bit] = ret;\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    X[x] ^= z;\n    X[y] ^= z;\n  }\n  int bit = 0, ret = 0;\n  for(int i = 0; i < N; i++) {\n    if(X[i] == 0) continue;\n    if(bit & (1 << X[i])) ++ret;\n    bit ^= 1 << X[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  for(int i = 0; i < (1 << 16); i++) {\n    int v = 0;\n    for(int j = 0; j < 16; j++) {\n      if((i >> j) & 1) v ^= j;\n    }\n    ok[i] = v == 0;\n  }\n  cout << ret + rec(bit) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n\nconst int MAXN = 100 * 1000 + 23, MXLA = 4 + 1;\n\n\n\n\nint n;\nvector<int> g[MXLA][MAXN];\nset<pii> s;\nbitset<MAXN> mark[MXLA];\n\n\nint dfs(int x, int v, int p = -1) {\n    mark[x][v] = true;\n    vector<int> vec;\n    for (auto u : g[x][v])\n        if (u != p)\n            vec.push_back(dfs(x, u, v));\n    for (int i = 0; i + 1 < vec.size(); i += 2)\n        s.insert({min(vec[i], vec[i + 1]), max(vec[i], vec[i + 1])});\n    if (p == -1 && (vec.size() & 1))\n        return s.insert({min(vec.back(), v), max(vec.back(), v)}), -1;\n    if (vec.size() & 1)\n        return vec.back();\n    return v;\n}\n\n\n\n\n\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL), cout.tie(NULL);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        for (int j = 0; j < MXLA; j++)\n            if (w & (1 << j))\n                g[j][v].push_back(u), g[j][u].push_back(v);\n    }\n    for (int i = 0; i < MXLA; i++)\n        for (int j = 0; j < n; j++)\n            if (!mark[i][j])\n                dfs(i, j);\n    cout << s.size();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    for(int i=0; i<16; i++) ans+=cnt[i]>>1, cnt[i]=cnt[i]&1;\n    ans+=cnt[0];\n    cnt[0]=0;\n    dp[0]=0;\n    for(int mask=1; mask<(1<<16); mask++){\n        int nw=0;\n        for(int i=0; i<16; i++) if(((mask>>i)&1)&&cnt[i]) nw^=i;\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<16); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<16)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e5+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nint d[N];\nint bug[N];\nint main()\n{\n\tint n=gi(),i,a,b,c,ans=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi(),c=gi();\n\t\td[a]^=c,d[b]^=c;\t\n\t}\n\tfor (i=0;i<n;i++) ++bug[d[i]];\n\tfor (i=1;i<15;i++)\n\t\tans+=(bug[i]+1)/2;\n\tcout<<max(0,ans-1)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 200005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\nstring bins(int x, int n) {\n  string res;\n  rep(i,n) res += \"01\"[x&1], x >>= 1;\n  reverse(rng(res));\n  return res;\n}\n\nconst int n = 16;\nconst int n2 = 1<<n;\n\nint c[n];\nint dp[n2];\nint ok[n2];\n\nint main() {\n  int nn, xs = 0;\n  scanf(\"%d\",&nn);\n  rep(i,nn-1) {\n    int x;\n    scanf(\"%*d%*d%d\",&x);\n    if (x) c[x]++;\n    xs ^= x;\n  }\n  if (xs) c[xs]++;\n  int s = 0, ans = 0;\n  rep(i,n) {\n    ans += c[i]/2;\n    s |= (c[i]&1)<<i;\n  }\n  if (pcnt(s)%2 == 1) s ^= 1;\n  // cout<<ans<<\" \"<<bins(s,n)<<endl;\n  rep(i,n2) dp[i] = -INF;\n  dp[s] = 0;\n  rep(i,n2) {\n    int x = 0;\n    rep(j,n) if (i>>j&1) x ^= j;\n    ok[i] = !x;\n  }\n  drep(i,n2) {\n    if (dp[i] == INF) continue;\n    for (int j = i; j; j = (j-1)&i) {\n      if (ok[j]) maxs(dp[i^j], dp[i]+1);\n    }\n  }\n\n  ans += pcnt(s)-dp[0];\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=18;\n\nint n,ans;\nint a[N];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile(--n)\n\t{\n\t\tint x;\n\t\tscanf(\"%d%d%d\",&x,&x,&x);\n\t\ta[x]++;\n\t}\n\tfor(int i=1;i<=15;i++)\n\t\tans+=a[i]>>1,a[i]&=1;\n\tfor(int i=1;i<=15;i++) if(a[i])\n\tfor(int j=i+1;j<=15;j++) if(a[j])\n\t\tif(a[i^j]) a[i]=0,a[j]=0,a[i^j]=0,ans+=2;\n\tfor(int i=1;i<=15;i++) if(a[i])\n\tfor(int j=i+1;j<=15;j++) if(a[j])\n\tfor(int k=j+1;k<=15;k++) if(a[k])\n\t\tif(a[i^j^k]) a[i]=0,a[j]=0,a[k]=0,a[i^j^k]=0,ans+=3;\n\tfor(int i=1;i<=15;i++)\n\t\tif(a[i]) a[16]++;\n\tif(a[16]>=5) ans+=a[16]-1;\n\telse ans+=a[16];\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint n;\nint basis[4], ori[4], a[N];\nbool vis[N];\nvector<pair<int, int>> g[N];\n\nint ins(int x) {\n  int sv = x;\n  int res = 0;\n  for (int i = 0; i < 4; ++i)\n    if ((x >> i) & 1)\n      if (!basis[i]) {\n        basis[i] = x;\n        ori[i] = sv;\n        return -1;\n      } else {\n        x ^= basis[i];\n        res |= 1 << i;\n      }\n  return res;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int rep = 1; rep < n; ++rep) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    a[u] ^= w;\n    a[v] ^= w;\n  }\n  sort(a, a + n);\n  int ans = n;\n  for (int i = 0; i < n; ++i) {\n    int res = ins(a[i]);\n    if (res != -1) {\n      --ans;\n      vector<int> rest;\n      for (int j = 0; j < 4; ++j)\n        if (!((res >> j) & 1) && basis[j])\n          rest.push_back(ori[j]);\n      memset(basis, 0, sizeof(basis));\n      for (int v : rest)\n        ins(v);\n    }\n  }\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: Barry Wang\nLANG: C++11\nTASK: \n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/*---define tricks---*/\n#define ALL(v) v.begin(),v.end()\n#define UN(v) sort(ALL(v)),v.erase(unique(ALL(v)),v.end())\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define EACH(v,it) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define FIO ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define revsort(b,e) sort(b,e),reverse(b,e)\n#define X first\n#define Y second\n#define Chtolly return 0\n/*---define types---*/\ntypedef long long ll;\ntypedef list<int> li;\ntypedef queue<int> qi;\ntypedef deque<int> dqi;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef unsigned int uint;\n/*---define variables---*/\nconst int inf=(1<<29);\nint n;\nint x[100005],y[100005],v[100005];\nint val[100005];\nint cnt[100005];\nll ans;\nuint st;\nbool zero[1<<16];\nll dp[1<<16];\n/*---define function---*/\n\n/*---main code---*/\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>x[i]>>y[i]>>v[i];\n\t\tval[x[i]]^=v[i];val[y[i]]^=v[i];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tcnt[val[i]]++;\n\t}\n\tfor(int i=1;i<=15;++i){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]%2){\n\t\t\tst|=(1<<i);\n\t\t}\n\t}\n\tfor(int mask=0;mask<(1<<16);++mask){\n\t\tint V=0;\n\t\tfor(int i=0;i<16;++i){\n\t\t\tif(mask&(1<<i)){\n\t\t\t\tx^=i;\n\t\t\t}\n\t\t}\n\t\tif(x==0){\n\t\t\tzero[mask]=1;\n\t\t}\n\t}\n\tfor(int mask=0;mask<(1<<16);++mask){\n\t\tif(mask&1){\n\t\t\tcontinue;\n\t\t}\n\t\tint M=mask;\n\t\twhile(M>0){\n\t\t\tif(zero[M]){\n\t\t\t\tdp[mask]=max(dp[mask],dp[mask^M]+1);\n\t\t\t}\n\t\t\tM=(M-1)&mask;\n\t\t}\n\t}\n\tcout<<ans+__builtin_popcount(st)-dp[st]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=2e5+10, MaxM=2e5+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[20], f[MaxM];\nbool xr[MaxM];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[x]^=z, v[y]^=z;\n\tfor (int i=0; i< n; ++i) ++cnt[v[i]];//è´ªå¿\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) f[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int i=1; i< (1<<15); ++i)\n        for (int j=0; j<15; ++j)\n\t\t\tif ((i>>j)&1) xr[i]^=(j+1);//é¢å¤çéåçå¼æå\n    for (int i=1; i<(1<<15); ++i)//æä¸¾å­éè¿è¡è½¬ç§»\n    {\n        if (xr[i]!=0) continue;\n        for(int k=(i-1)&i; k; k=(k-1)&i)\n            if (xr[k]==0) chkMin(f[i], f[k]+f[i^k]);\n    }\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nint n, ans, a[N], val[N], S;\nint vis[N], f[N];\n\nint sol(int S) {\n    if(!S) return 0;\n    if(vis[S]) return f[S];\n    f[S] = 0x3f3f3f3f;\n    vis[S] = 1;\n    for(int i = 1 ; i <= 15 ; ++ i) {\n        if(S & (1 << i)) {\n            for(int j = 1 ; j <= 15 ; ++ j) {\n                if(i != j && (S & (1 << j))) {\n                    int t = i ^ j;\n                    if(S & (1 << t)) {\n                        f[S] = min(f[S], sol(S ^ (1 << i) ^ (1 << j) ^ (1 << t)) + 2);\n                    } else {\n                        f[S] = min(f[S], sol(S ^ (1 << i) ^ (1 << j) ^ (1 << t)) + 1);\n                    }\n                }\n            }\n        }\n    }\n    return f[S];\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1, u, v, w ; i < n ; ++ i) {\n        scanf(\"%d%d%d\", &u, &v, &w);\n        a[u] ^= w;\n        a[v] ^= w;\n    }\n    for(int i = 0 ; i < n ; ++ i) {\n        ++ val[a[i]];\n    }\n    for(int i = 1 ; i <= 15 ; ++ i) {\n        ans += val[i] / 2;\n        if(val[i] % 2 == 1) {\n            S ^= 1 << i;\n        }\n    }\n    printf(\"%d\\n\", ans + sol(S));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \n#define ld long double\nusing namespace std;\nconst ll INF = 1e18;\nconst ll MOD = 998244353;\n\n\nvector<string> vec_splitter(string s) {\n\t\ts += ',';\n\t\tvector<string> res;\n\t\twhile(!s.empty()) {\n\t\t\t\tres.push_back(s.substr(0, s.find(',')));\n\t\t\t\ts = s.substr(s.find(',') + 1);\n\t\t}\n\t\treturn res;\n}\nvoid debug_out(\nvector<string> __attribute__ ((unused)) args,\n__attribute__ ((unused)) int idx, \n__attribute__ ((unused)) int LINE_NUM) { cerr << endl; } \ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n\t\tif(idx > 0) cerr << \", \"; else cerr << \"Line(\" << LINE_NUM << \") \";\n\t\tstringstream ss; ss << H;\n\t\tcerr << args[idx] << \" = \" << ss.str();\n\t\tdebug_out(args, idx + 1, LINE_NUM, T...);\n}\n#ifdef XOX\n#define deb(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)\n#else\n#define deb(...) 42\n#endif\n\n\nint32_t main() {\n\tios::sync_with_stdio(!cin.tie(NULL));\n\n\tint n;\n\tcin >> n;\n\tint u, v, x;\n\tvector<int> xxor(n + 10, 0);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tcin >> x;\n\t\txxor[u] ^= x, xxor[v] ^= x;\n\t}\n\t\n\tint cnt[20 + 10];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor(int i = 0; i < n; i++) {\n\t\tcnt[xxor[i]]++;\n\t\tdeb(i, xxor[i]);\n\t}\n\tint res = 0;\n\tint now = 0;\n\tvector<int> cur;\n\tfor(int i = 1; i < 16; i++) {\n\t\tres += (cnt[i] / 2);\n\t\tcnt[i] &= 1;\n\t\tnow += cnt[i];\n\t\tif(cnt[i])\tcur.push_back(i);\n\t}\n\n\tvector<int> dp(1 << 17, 0);\n\t\n\tfor(int i = 0; i < (1 << now); i++) {\n\t\tfor(int j = 0; j < now; j++) {\n\t\t\tif(i&(1 << j))\tdp[i] ^= cur[j];\n\t\t}\n\t}\n\tdeb(dp[7], cnt[1], cnt[2], cnt[4]);\n\tvector<int> memo(1 << 16);\n\n\tfor(int mask = 1; mask < (1 << now); mask++) {\n\t\tif(dp[mask])\tcontinue;\n\t\tmemo[mask] = 1;\n\t\tfor(int sub = (mask - 1)&mask; sub;\tsub = (sub - 1)&mask) {\n\t\t\tif(dp[sub] == 0)\tmemo[mask] = max(memo[mask], memo[mask^sub] + 1);\n\t\t}\n\t\tdeb(mask, dp[mask]);\n\t}\n\tdeb(now, dp[(1 << now)], res);\n\tcout << res + (now - memo[(1 << now) - 1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 101010;\n\nint a[MAXN];\nint cnt[21];\nint f[1<<17];\nint n;\n\nint res[21];\nint cntr;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tint u, v, w;\n\tfor(int i = 1; i < n; ++i) {\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor(int i = 0; i < n; ++i)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\tfor(int i = 1; i <= 15; ++i) {\n\t\tans += cnt[i] >> 1;\n\t\tif(cnt[i] & 1) {\n\t\t\tres[cntr++] = i;\n\t\t}\n\t}\n\tf[0] = 0;\n\tfor(int i = 1; i < 1<<cntr; ++i) {\n\t\tint tmp = 0;\n\t\tfor(int j = 0; j < cntr; ++j) {\n\t\t\tif(i & (1<<j))\n\t\t\t\ttmp ^= res[j];\n\t\t}\n\t\ttmp = !tmp;\n\t\tfor(int j = 0; j < cntr; ++j) {\n\t\t\tif(i & (1<<j)) {\n\t\t\t\tf[i] = max(f[i], f[i ^ (1<<j)] + tmp);\n\t\t\t}\n\t\t}\n\t}\n\tans += cntr;\n\tans -= f[(1<<cntr) - 1];\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define LL long long\n#define INF 0x3f3f3f3f\n#define Inf 1000000000000000000LL\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\nusing namespace std;\nint n,a[233333],S,ans,f[66666],sum[20];\nint dfs(int S){\n\tif(!S)return 0;\n\tif(f[S]<INF)return f[S];\n\tfor(int i=0;i<16;i++)if((S>>i)&1)\n\t\tfor(int j=0;j<16;j++)if(i!=j&&(S>>j)&1){\n\t\t\tint p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n\t\t\tif(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n\t\t\telse f[S]=min(f[S],dfs(x)+1);\n\t\t}\n\treturn f[S];\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1,x,y,z;i<n;i++){\n\t\tcin>>x>>y>>z;\n\t\ta[x]^=z,a[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)sum[a[i]]++;\n\tfor(int i=1;i<16;i++){\n\t\tans+=(sum[i]>>1);\n\t\tS+=(1<<i)*(sum[i]&1);\n\t}\n\tmemset(f,0x3f,sizeof f);\n\tans+=dfs(S);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int& a, int b){\n    a = min(a, b);\n}\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nint main(){\n    int N;\n    int A[100000] = {0};\n    cin >> N;\n    for(int i=0; i<N-1; i++){\n        int x, y, a;\n        cin >> x >> y >> a;\n        A[x] ^= a;\n        A[y] ^= a;\n    }\n\n    int num[16] = {0};\n    for(int i=0; i<N; i++) num[A[i]]++;\n\n    int fix = 0;\n    vector<int> rest;\n    for(int i=1; i<16; i++){\n        fix += num[i] / 2;\n        if(num[i] % 2) rest.push_back(i);\n    }\n\n    int sz = rest.size();\n    int M = 1<<sz;\n    const int INF = 1e9;\n    static int dp[1<<15];\n    dp[0] = fix;\n    for(int i=1; i<M; i++) dp[i] = INF;\n\n    for(int i=1; i<M; i++){\n        for(int j=i; j>0; j=(j-1)&i){\n            int s = 0, c = 0;\n            for(int k=0; k<sz; k++) if(nth_bit(j, k)){\n                c++;\n                s ^= rest[k];\n            }\n            if(s == 0) chmin(dp[i], dp[i-j] + c-1);\n        }\n    }\n\n    cout << dp[M-1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 1e5 + 10, Limit = 1 << 15;\nint val[N], cnt[15], res[Limit], f[Limit];\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n;\n\tread(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y, z; read(x), read(y), read(z);\n\t\tx++; y++; val[x] ^= z; val[y] ^= z;\n\t}\n\tfor (int i = 1; i <= n; i++) cnt[val[i]]++;\n\tint ans = 0, S = 0;\n\tfor (int i = 1; i <= 15; i++)\n\t\tans += cnt[i] / 2, S |= (cnt[i] & 1) << (i - 1);\n\tfor (int i = 1, cnt; i < Limit; i++) {\n\t\tcnt = 0;\n\t\tfor (int j = 1; j <= 15; j++)\n\t\t\tif ((i >> (j - 1)) & 1) res[i] ^= j, cnt++;\n\t\tf[i] = cnt - 1;\n\t}\n\tfor (int i = 1; i < Limit; i++)\n\t\tif (!res[i])\n\t\t\tfor (int j = i; j; j = (j - 1) & i)\n\t\t\t\tif (!res[j]) f[i] = min(f[i], f[j] + f[i ^ j]);\n\tprintf(\"%d\\n\", ans + f[S]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int uint;\ntypedef pair <int, int> pii;\ntypedef unsigned long long uLL;\n\ntemplate <typename T> inline void Read(T &x) {\n  char c = getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n\ntemplate <typename T> inline bool CheckMax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n\ntemplate <typename T> inline bool CheckMin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n\nconst int N = 100005;\n\nint n, m, ans, a[N], b[N], c[N], f[N];\n\nint main() {\n#ifdef wxh010910\n  freopen(\"d.in\", \"r\", stdin);\n#endif\n  Read(n);\n  for (int i = 1, x, y, w; i < n; ++i) {\n    Read(x), Read(y), Read(w);\n    a[x] ^= w, a[y] ^= w;\n  }\n  for (int i = 0; i < n; ++i) {\n    ++c[a[i]];\n  }\n  for (int i = 1; i < 16; ++i) {\n    ans += c[i] >> 1;\n    if (c[i] & 1) {\n      b[m++] = i;\n    }\n  }\n  for (int i = 1; i < 1 << m; ++i) {\n    int s = 0;\n    for (int j = 0; j < m; ++j) {\n      if (i >> j & 1) {\n        s ^= b[j];\n      }\n    }\n    if (s) {\n      f[i] = m;\n    } else {\n      f[i] = __builtin_popcount(i) - 1;\n    }\n    for (int j = s = (1 << m - 1) ^ i; j; j = j - 1 & s) {\n      CheckMin(f[i], f[j] + f[i ^ j]);\n    }\n  }\n  printf(\"%d\\n\", ans + f[(1 << m) - 1]);\n#ifdef wxh010910\n  Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=n,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]){\n      ans--;\n      continue;\n    }\n    if((res>>cnt[i])&1) ans--;\n    res^=1<<cnt[i];\n  }\n  \n  vector<Int> dp(1<<16,-1),ok(1<<16,0);\n  for(Int i=0;i<(1<<16);i++){\n    Int tmp=0;\n    for(Int j=0;j<16;j++)\n      if((i>>j)&1) tmp^=j;\n    ok[i]=tmp==0;\n  }\n  \n  function<Int(Int)> dfs;\n  dfs=[&](Int b)->Int{\n\tif(!b) return 0;\n\tInt &v=dp[b];\n\tif(~v) return v;\n\tv=1;\n\tfor(Int i=b;i>0;i=(i-1)&b){\n\t  if(i==b) continue;\n\t  if(ok[i]) chmax(v,dfs(i)+dfs(b^i));\n\t}\n\treturn v;\n      };\n  \n  cout<<ans-dfs(res)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=100010;\nconst int all=1<<15;\nconst int base=65535;\nint f[50010];\nint a[maxn];\nint que[70010];\nbool in[50010];\nint n;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++;\n\t\ty++;\n\t\ta[x]^=z;\n\t\ta[y]^=z;\n\t}\n\tint ans=0;\n\tint now=0;\n\tfor (int i=1;i<=n;i++)\n\tif (a[i]!=0)\n\t{\n\t\tif (now&(1<<(a[i]-1)))\tans++;\n\t\tnow^=1<<(a[i]-1);\n\t}\n\tfor (int i=0;i<all;i++)\n\t\tf[i]=-1;\n\tf[now]=0;\n\tin[now]=true;\n\tint h=1,t=1;\n\tque[1]=now;\n\twhile (h<=t)\n\t{\n\t\tint u=que[h&base];\n\t\tin[u]=false;\n\t\th++;\n\t\tfor (int i=1;i<=15;i++)\n\t\tif (u&(1<<(i-1)))\n\t\t\tfor (int j=i+1;j<=15;j++)\n\t\t\tif (u&(1<<(j-1)))\n\t\t\t\tfor (int x=1;x<=15;x++)\n\t\t\t\t{\n\t\t\t\t\tint tmp1=i^x;\n\t\t\t\t\tint tmp2=j^x;\n\t\t\t\t\tint ha=1;\n\t\t\t\t\tint v=u^(1<<(i-1))^(1<<(j-1));\n\t\t\t\t\tif (tmp1!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (v&(1<<(tmp1-1)))\tha++;\n\t\t\t\t\t\tv^=1<<(tmp1-1);\n\t\t\t\t\t}\n\t\t\t\t\tif (tmp2!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (v&(1<<(tmp2-1)))\tha++;\n\t\t\t\t\t\tv^=1<<(tmp2-1);\n\t\t\t\t\t}\n\t\t\t\t\tif (f[v]==-1 || f[v]>f[u]+ha)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[v]=f[u]+ha;\n\t\t\t\t\t\tif (!in[v])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt++;\n\t\t\t\t\t\t\tque[t&base]=v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct edge_t {\n  int other, value;\n};\n\nconst int maxn = 1e5;\n\nvector<edge_t> adj[maxn];\nint many[16];\nint dp[1<<16], subsetxor[1<<16];\n\nint solve1(int v, int p) {\n  int acc = 0;\n  for (const edge_t &ed : adj[v])\n    if (ed.other != p) {\n      const int u = ed.other;\n      int res = solve1(u, v);\n      ++many[res ^ ed.value];\n      acc ^= ed.value;\n    }\n  return acc;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b, value;\n    scanf(\"%d %d %d\", &a, &b, &value);\n    adj[a].push_back({b, value});\n    adj[b].push_back({a, value});\n  }\n  solve1(0, -1);\n\n  int result = 0;\n\n  many[0] = 0;\n  for (int i = 1; i < 16; ++i) {\n    result += many[i] / 2;\n    many[i] %= 2;\n  }\n\n  subsetxor[0] = 0;\n  for (int s = 1; s < (1<<16); ++s) {\n    int b = __builtin_ctz(s);\n    subsetxor[s] = b ^ subsetxor[s ^ (1<<b)];\n  }\n\n  for (int s = 0; s < (1<<16); ++s) {\n    dp[s] = __builtin_popcount(s);\n    for (int submask = s; submask > 0; submask = ((submask - 1) & s))\n      if (subsetxor[submask] == 0)\n        dp[s] = min(dp[s], dp[s ^ submask] + (__builtin_popcount(submask) - 1));\n  }\n\n  int mask = 0;\n  for (int i = 0; i < 16; ++i)\n    if (many[i] == 1)\n      mask |= 1<<i;\n\n  result += dp[mask];\n  printf(\"%d\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nclass edge {\npublic:\n\tint to, cost;\n\tedge() : to(-1), cost(0) {};\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<int> col(N);\n\tfunction<int(int, int, int)> set_col = [&](int pos, int pre, int pcol) {\n\t\tint res = 0;\n\t\tfor (edge e : G[pos]) {\n\t\t\tif (e.to == pre) continue;\n\t\t\tset_col(e.to, pos, e.cost);\n\t\t\tres ^= e.cost;\n\t\t}\n\t\tres ^= pcol;\n\t\tcol[pos] = res;\n\t\tres ^= col[pos];\n\t\treturn res;\n\t};\n\tset_col(0, -1, 0);\n\tvector<int> tbl(16);\n\tfor (int i = 0; i < N; ++i) {\n\t\t++tbl[col[i]];\n\t}\n\tint bit = 0, ans = 0;\n\tfor (int i = 1; i < 16; ++i) {\n\t\tans += (tbl[i] >> 1);\n\t\tbit |= (tbl[i] & 1) << i;\n\t}\n\tqueue<pair<int, int> > que;\n\tvector<int> dist(1 << 16, inf);\n\tque.push(make_pair(0, bit));\n\tdist[bit] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.front().second; que.pop();\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\tif (!((u >> i) & 1)) continue;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (!((u >> j) & 1)) continue;\n\t\t\t\tint b = u ^ (1 << i) ^ (1 << j);\n\t\t\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\t\t\tint tar = b ^ (1 << (i ^ k)) ^ (1 << (j ^ k)), cost = 1;\n\t\t\t\t\tif ((u >> (i ^ k)) & 1) ++cost;\n\t\t\t\t\tif ((u >> (j ^ k)) & 1) ++cost;\n\t\t\t\t\tif (dist[tar] > dist[u] + cost) {\n\t\t\t\t\t\tdist[tar] = dist[u] + cost;\n\t\t\t\t\t\tque.push(make_pair(-dist[tar], tar));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans += min(dist[0], dist[1]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nusing edge = struct {int to, cost;};\nvector<edge> graph[limit];\n\nint group[1 << 16];\nint ans = 0;\n\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\nint dfs(int v, int p, int x) {\n\tint cx = 0, total = 0;\n\tvector<int> num(16, 0);\n\n\tfor (auto &e : graph[v]) {\n\t\tif (e.to == p) continue;\n\t\tdfs(e.to, v, e.cost);\n\t\tconst int val = e.cost;\n\t\tcx ^= e.cost;\n\t\tnum[val]++;\n\t\ttotal++;\n\t}\n\n\tif(total == 0) return 0;\n\tans += total;\n\tint cmask = 0;\n\trep(i, 16) {\n\t\tif (num[i] % 2 == 1) cmask |= (1 << i);\n\t\tans -= num[i] / 2;\n\t}\n\n\tans -= group[cmask];\n\t// error(v, group[cmask], ans);\n\t// error(x, cx);\n\tif (x != 0 and x != cx) ans++;\n\t//error(ans);\n\treturn 0;\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tgroup[0] = 0;\n\trep(mask, 1 << 16) {\n\t\tint cur = 0;\n\t\trep(i, 16) if (mask & (1 << i)) cur ^= i;\n\t\trep(i, 16) {\n\t\t\tif (mask & (1 << i)) continue;\n\t\t\tconst int nmask = mask | (1 << i);\n\t\t\tchmax(group[nmask], group[mask] + (cur == 0));\n\t\t}\n\t}\n\n\trep(i, n - 1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgraph[x].push_back({y, a});\n\t\tgraph[y].push_back({x, a});\n\t}\n\n\tdfs(0, -1, 0);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef int64_t LL;\ntypedef uint64_t ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\ntemplate<class T, class... U> void DEBUG(const T &head, const U &... tail) { \n#ifdef HOME\n    _W('#'); _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...);\n#endif\n}\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nint a[SIZE],N,dp[1<<16],bit_cnt[1<<16],xor_v[1<<16];\nint main(){\n    REP(i,1<<16){\n        bit_cnt[i]=bit_cnt[i>>1]+(i&1);\n        REP(j,16){\n            if((i>>j)&1)xor_v[i]^=j;\n        }\n    }\n    R(N);\n    REPP(i,1,N){\n        int x,y,v;R(x,y,v);\n        a[x]^=v;\n        a[y]^=v;\n    }\n    DEBUG(VI(a,a+N));\n    int cnt[16]={};\n    REP(i,N)cnt[a[i]]++;\n    int an=0;\n    int mask=0;\n    REPP(i,1,16){\n        an+=cnt[i]/2;\n        if(cnt[i]&1)mask|=1<<i;\n    }\n    if(mask){\n        for(int i=2;i<=mask;i+=2){\n            if((i&mask)!=i)continue;\n            if(xor_v[i])continue;\n            dp[i]=24;\n            for(int j=i;j;j=(j-2)&i){\n                if(xor_v[j]==0){\n                    dp[i]=min(dp[i],dp[i^j]+bit_cnt[j]-1);\n                }\n            }\n        }\n        an+=dp[mask];\n    }\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\nconst int maxn = 1e5 + 20;\nconst int maxs = (1 << 16) + 7;\n\nint n;\nint val[maxn], cnt[16], ans;\nint dp[maxs];\n\ntemplate<class TAT>void checkmin(TAT &x,const TAT &y)\n{\n\tif(y < x) x = y;\n}\nint dfs(int x)\n{\n\tif(dp[x] != -1) return dp[x];\n\t\n\tdp[x] = maxs;\n\t\n\tfor(int i = 0; i < 16; i++)\n\t\tfor(int j = 0; j < 16; j++)\n\t\t\tif(i != j && ((x >> i) & 1) && ((x >> j) & 1))\n\t\t\t{\n\t\t\t\tint tmp = x ^ (1 << i) ^ (1 << j);\n\t\t\t\tint modify = i ^ j;\n\t\t\t\t\n\t\t\t\tcheckmin(dp[x], dfs(tmp ^ (1 << modify)) + 1 + ((tmp >> modify) & 1));\n\t\t\t}\n\t\n\treturn dp[x];\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, x, y, a; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\t++x, ++y;\n\t\tval[x] ^= a, val[y] ^= a;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(val[i])\n\t\t{\n\t\t\tans += cnt[val[i]];\n\t\t\tcnt[val[i]] ^= 1;\n\t\t}\n\t}\n\t\n\tint now = 0;\n\t\n\tfor(int i = 0; i < 16; i++) now |= (1 << i) * cnt[i];\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0] = 0;\n\tans += dfs(now);\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nint Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot|=(1<<(i-1));\n\tfor(int i=1;i<(1<<15);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<15);s++){\n\t\tfor(int i=1;i<=15;i++){\n\t\t\tif((s>>(i-1))&1)\n\t\t\tXor[s]^=i;\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<15);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=100005;\nint val[N],cnt[N],sxr[1<<17];\nint a[17];\nint dp[1<<17];\ninline int read(){\n\tint x=0;char e=getchar();\n\tfor (;e<'0'||e>'9';e=getchar());\n\tfor (;e>='0'&&e<='9';e=getchar()) x=(x<<1)+(x<<3)+(e^48);\n\treturn x;\n}\ninline int Min(int a,int b){\n\treturn a<b?a:b;\n}\nint main (){\n\tint n=read();\n\tfor (int i=1;i<n;i++){\n\t\tint u=read()+1,v=read()+1,w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tint ans=0,to=0;\n\tfor (int i=0;i<16;i++){\n\t\tans+=(cnt[i]>>1);\n\t\tif (cnt[i]&1) to|=(1<<i);\n\t}\n\tfor (int i=0;i<(1<<16);i++)\n\t\tfor (int j=0;j<16;j++)\n\t\t\tif (i&(1<<j)) sxr[i]^=j;\n\tfor(int i=0;i<(1<<16);i++) dp[i]=dp[i>>1]+(i&1);\n    for(int i=0;i<(1<<16);i++) dp[i]--;\n\tfor (int i=0;i<(1<<16);i++){\n        if (sxr[i]) continue;\n        for (int k=(i-1)&i;k;k=(k-1)&i)\n            if (!sxr[k]) dp[i]=Min(dp[i],dp[k]+dp[i^k]);\n\t}\n\tprintf (\"%d\",dp[to]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define lson l,(l+r)/2,rt<<1\n#define rson (l+r)/2+1,r,rt<<1|1\n#define dbg(x) cout<<#x<<\" = \"<< (x)<< endl\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define sz(x) (int)(x).size()\nconst int mxn=1e5+10;\nint b[mxn];\nint cnt[16];\nint a[20];\nint sz=0;\nint dp[mxn];\nbool check(int mask){\n\tint x=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(mask &(1<<i))x^=a[i];\n\t}\n\treturn x==0;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\tb[u]^=w;\n\t\tb[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcnt[b[i]]++;\n\t}\n\tint component=cnt[0];\n\tfor(int i=1;i<16;i++){\n\t\tcomponent+=cnt[i]/2;\n\t\tif(cnt[i]%2)a[sz++]=i;\n\t}\n\tint up=(1<<sz)-1;\n\tfor(int i=1;i<=up;i++){\n\t\tfor(int x=i;x;x=((x-1)&i)){\n\t\t\tif(check(x))dp[i]=max(dp[i],1+dp[x^i]);\n\t\t}\n\t}\n\tcout<<n-component-dp[up];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, a[N], cnt[M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[--u] ^= w;\n\t\ta[--v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\n\tbool done = false;\n\twhile (done == false) {\n\t\tdone = true;\n\t\tfor (int i = 1; i < M; i++)\n\t\t\twhile (cnt[i] >= 2) {\n\t\t\t\tcnt[i] -= 2;\n\t\t\t\tans++;\n\t\t\t\tdone = false;\n\t\t\t}\n\t\tif (done) {\n\t\t\tint x = 0;\n\t\t\tfor (int i = 1; i < M; i++)\n\t\t\t\tx += cnt[i];\n\t\t\tans += max(0, x - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt[20],ok[1<<17],dp[1<<17],val[N];\ntypedef pair<int,int> pii;\nvector<pii> e[N];\nvoid dfs(int x,int fa){\n\tfor (auto i:e[x]){\n\t\tint v=i.first;\n\t\tif (v==fa) continue;\n\t\tval[v]=i.second;\n\t\tval[x]^=val[v];\n\t\tdfs(v,x);\n\t}\n}\nint main()\n{\n\tfreopen(\"a.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v,l;\n\t\tscanf(\"%d%d%d\",&u,&v,&l);u++;v++;\n\t\te[u].push_back(pii(v,l));\n\t\te[v].push_back(pii(u,l));\n\t}\n\tdfs(1,0);\n\tfor (int i=2;i<=n;i++) cnt[val[i]]++;\n\tint ans=0;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,cnt[i]%=2;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i];\n\tcnt[0]=0;\n\tint U=1<<16;\n\tfor (int i=0;i<U;i++){\n\t\tint s=0;\n\t\tfor (int j=0;j<16;j++)\n\t\tif (i>>j&1) s^=j;\n\t\tif (!s) ok[i]=1;\n\t}\n\tfor (int i=0;i<U;i++)\n\tfor (int j=i;j;j=(j-1)&i){\n\t\tif (ok[j]) dp[i]=max(dp[i],dp[i^j]+1);\n\t\tdp[i]=max(dp[i],dp[i^j]);\n\t}\n\tint tmp=0;\n\tfor (int i=0;i<16;i++) tmp^=cnt[i]<<i;\n\tprintf(\"%d\\n\",ans-dp[tmp]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nconst int bits = 15;\nconst int limit = 1 << bits;\n\nint n, i, x, y, z, ans;\nvector< pair<int, int> > list[maxN];\nint dp[limit];\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > H;\nint tp;\n\nvoid pre() {\n    int i, j, to, aux, cnt = 0;\n\n    for (i = 0; i < limit; i++) dp[i] = bits + 1;\n    dp[0] = 0;\n    H.push(mp(0, 0));\n\n    while (!H.empty()) {\n        int conf = H.top().second;\n        int cost = H.top().first;\n        H.pop();\n\n        if (dp[conf] != cost) continue;\n        cnt++;\n\n        for (i = 0; i < bits; i++) {\n            for (j = 0; j < bits; j++) {\n                if (i == j) continue;\n                to = conf ^ (1 << i) ^ (1 << j);\n\n                aux = 1 << (((i + 1) ^ (j + 1)) - 1);\n                if (conf & aux) continue;\n                to ^= aux;\n\n                if (dp[to] > dp[conf] + 1) {\n                    dp[to] = dp[conf] + 1;\n                    H.push(mp(dp[to], to));\n                }\n            }\n\n            to = conf ^ (1 << i);\n            if (dp[to] > dp[conf] + 1) {\n                dp[to] = dp[conf] + 1;\n                H.push(mp(dp[to], to));\n            }\n        }\n    }\n\n    //for (i = 0; i < 256; i++) cerr << dp[i] << ' ';\n    //cerr << '\\n';\n\n    cerr << limit - cnt << '\\n';\n}\n\nvoid dfs(int node, int root, int need) {\n    int act = 0;\n\n    for (auto to : list[node])\n        if (to.first != root)\n            dfs(to.first, node, to.second), act ^= to.second;\n\n    if (node != 1 && act != need)\n        tp ^= ((1 << (act ^ need)) >> 1), ans++;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    pre();\n    for (i = 1; i < n; i++) {\n        cin >> x >> y >> z;\n        x++; y++;\n        list[x].pb(mp(y, z));\n        list[y].pb(mp(x, z));\n    }\n\n    dfs(1, 0, 0);\n    ans += dp[tp];\n\n    if (ans % 1) cerr << \"Error\";\n    cout << ans / 2 << '\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#include<vector>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans,sum;\nvector<int> a[21];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta++;\n\t\tb++;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t\tif(book[i]&1)\n\t\t\tsum++;\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[s]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tcnt++;\n\t\ta[cnt].push_back(i);\n\t}\n\tfor(int o=sum;o>=0;o--)\n\t\tfor(int p=0;p<a[o].size();p++)\n\t\t{\n\t\t\tif(p>s)\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<=15;i++)\n\t\t\t{\n\t\t\t\tif(!(p&(1<<i)))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=0;j<=15;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j||!(p&(1<<j)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint k=i^j;\n\t\t\t\t\tint t=p^(1<<i)^(1<<j)^(1<<k);\n\t\t\t\t\tif(p&(1<<k))\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(S & (1 << a[i])) ans ++;\n\t\tS ^= (1 << a[i]);\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[1] = dp[0] = 0;\n\tfor (int now = 2; now < (1 << 15); ++now) {\n\t\tfor (int i = 0; i < 15; ++i) {\n//\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n//\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (i ^ j))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\nconst int N=100005;\n\nint ans,n,x,y,w,m,sz;\nint dp[N],b[N],a[N],cnt[N];\nbool tag[N];\n\nvoid init(){\n\tint s,i,ss;\n\tsz=(1<<m)-1;\n\tfor (s=0;s<=sz;s++){\n\t\tss=0;\n\t\tfor (i=1;i<=m;i++) if ((s>>i-1)&1) ss^=a[i];\n\t\tif (!ss) tag[s]=1;\n\t}\n}\n\nint main(){\n\tint i,s,ss,is;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&w); x++; y++;\n\t\tb[x]^=w; b[y]^=w;\n\t}\n\tfor (i=1;i<=n;i++) cnt[b[i]]++;\n\tans+=cnt[0];\n\tfor (i=1;i<=15;i++){\n\t\tans+=cnt[i]/2;\n\t\tif (cnt[i]&1) a[++m]=i;\n\t}\n\tinit();\n\tfor (s=0;s<=sz;s++){\n\t\tis=sz^s;\n\t\tfor (ss=is;ss;ss=(ss-1)&is)\n\t\t\tif (tag[ss]) dp[s|ss]=max(dp[s|ss],dp[s]+1);\n\t}\n\tprintf(\"%d\\n\",n-(ans+dp[sz]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cassert>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n\nconst int MAXN=1E5+10;\n\nint n,val[MAXN],S;\nint cnt[20],ans,f[1<<16];\nint stk[20],top,bin[20];\n\nint main()\n{\n    scanf(\"%d\",&n);memset(f,0x3f,sizeof f);\n    bin[0]=1;\n    for(int i=1;i<=15;i++) bin[i]=bin[i-1]<<1;\n    for(int i=1,u,v,w;i<n;i++)\n        scanf(\"%d%d%d\",&u,&v,&w),++u,++v,val[u]^=w,val[v]^=w;\n    for(int i=1;i<=n;i++) cnt[val[i]]++;\n    for(int i=1;i<=15;i++) ans+=cnt[i]>>1,S|=(cnt[i]&1)<<i;\n    f[0]=0;\n    for(int l=1;l<=15;l++)\n        for(int s=0;s<(1<<16);s++)\n            if(__builtin_popcount(s)==l&&(s&1)==0)\n                {\n                    top=0;\n                    for(int i=1;i<16;i++) if((s>>i)&1) stk[++top]=i;\n                    for(int i=1;i<=top;i++)\n                        for(int j=i+1;j<=top;j++)\n                            f[s]=min(f[s],f[s^bin[stk[i]]^bin[stk[j]]^bin[stk[i]^stk[j]]]+1+((s>>(i^j))&1));\n                }\n    printf(\"%d\\n\",f[S]+ans);\n    #ifdef LOCAL\n        system(\"pause\");\n    #endif\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],f[N],cnt[20],res,n,st,sxr[N],S;\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);rp(i,1,S-1)--f[i];\n\trp(i,1,S){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n\trp(i,1,S)\n\t{\n\t\tif(!sxr[i])for(int k=(i-1)&i;k;k=(k-1)&i)if(!sxr[k])f[i]=min(f[i],f[k]+f[i^k]);\n\t}\n\tprintf(\"%d\",res+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ninline int Min(int x,int y){return x<y?x:y;}\nint n,a[100000];\nint s[16],Ans,S;\nint f[1<<16];\nint main(){\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i) scanf(\"%d%d%d\",&x,&y,&z), a[x]^=z, a[y]^=z;\n\tfor(int i=0;i<n;++i) if(a[i]) Ans+=s[a[i]], s[a[i]]^=1;\n\tfor(int i=1;i<16;++i) S^=s[i]<<i;\n\tfor(int l=1;l<=15;++l) for(int i=1;i<1<<16;++i) if(__builtin_popcount(i)==l&&(i&1)==0){\n\t\tf[i]=(-1u)>>1;\n\t\tfor(int j=1;j<16;++j) if(i>>j&1)\n\t\t\tfor(int k=j+1;k<16;++k) if(i>>k&1)\n\t\t\t\tf[i]=Min(f[i],f[i^(1<<j)^(1<<k)^(1<<(j^k))]+1+(i>>(j^k)&1));\n\t}\n\tprintf(\"%d\",Ans+f[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 100000 \nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint head[MN+5],cnt=0,n,c[MN+5],f[MN+5][16],ans;\nstruct edge{int to,next,w;}e[MN*2+5];\ninline void ins(int f,int t,int w)\n{\n\te[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t],w};head[t]=cnt;\n}\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=e[i].next) if(e[i].to!=fa)\n\t{\n\t\tdfs(e[i].to,x);c[x]^=e[i].w;\n\t\t//cout<<e[i].to<<\" \"<<(e[i].w^c[e[i].to])<<endl; \n\t\tif(e[i].w^c[e[i].to]) ++ans,++f[e[i].to][e[i].w^c[e[i].to]];\n\t}\n}\nvoid Solve(int x,int fa)\n{\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)\n\t\t{\n\t\t\tSolve(e[i].to,x);\n\t\t\tfor(int j=1;j<16;++j) if(f[e[i].to][j]) \n\t\t\t{\n\t\t\t\tint del=0;\n\t\t\t\tfor(int k=1;k<16;++k) if(f[x][k]&&(j==k||f[x][j^k]))\n\t\t\t\t{\n\t\t\t\t\t--f[x][k];--f[x][j^k];del=1;--ans;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!del) ++f[x][j];\n\t\t\t}\n\t\t}\n}\nint main()\n{\t\n\tn=read();\n\tfor(int i=1,j,k;i<n;++i) j=read()+1,k=read()+1,ins(j,k,read());\n\tdfs(1,0);Solve(1,0);cout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<set>\n#define ll long long\n#define maxn 200005\n#define re register\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nint a[maxn],cnt[16],ans;\nint b[16],cnt1,sz[maxn],sz2[maxn],dp[maxn];\n\ninline int gs(int sta)\n{\n\tfor(int i=1;i<=cnt1;i++) if((sta&(1<<(i-1)))) sz[sta]^=b[i];\n}\n\nint main()\n{\n\tint n=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read(),w=read();\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(cnt[a[i]]) cnt[a[i]]=0,ans++;\n\t\telse cnt[a[i]]=1;\n\t}\n\tfor(int i=0;i<=15;i++) if(cnt[i]) b[++cnt1]=i;\n\tint ed=(1<<cnt1)-1;\n\t//for(int i=1;i<=cnt1;i++) cout<<b[i]<<\" \"; cout<<endl;\n\tfor(int i=1;i<=ed;i++) gs(i),sz2[i]=sz2[i>>1]+1;\n\tfor(int i=1;i<=ed;i++) dp[i]=sz2[i]-1;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<sz[i]<<\" \"<<sz2[i]<<endl;\n\tfor(int i=1;i<=ed;i++)\n\t{\n\t\tif(sz[i]!=0) continue;\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(sz[j]==0) dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t//else dp[i]=min(dp[i],sz2[j]+sz2[i^j]+1);\n\t\t}\n\t}\n\tcout<<dp[ed]+ans<<endl;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<dp[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[20],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    int x, y, a;\n    vec v(N, 0);\n    REP(i, N - 1){\n        cin >> x >> y >> a;\n        v[x] ^= a;\n        v[y] ^= a;\n    }\n    vec cnt(16, 0);\n    for(int i: v) cnt[i]++;\n    int ans = 0;\n    int X = 0;\n    REP(i, 15){\n        ans += cnt[i + 1] / 2;\n        if(cnt[i + 1] % 2) X ^= bit(i);\n    }\n\n    vec dp(bit(15), INF);\n    dp[0] = 0;\n    FOR(n, 1, 15 + 1){\n        int comb = bit(n) - 1;\n        while(comb < bit(15)){\n            int tmp = 0;\n            REP(i, 15) if((comb >> i) & 1) tmp ^= (i + 1);\n            if(tmp == 0){\n                REP(i, 15) REP(j, 15) if(i != j && ((comb >> i) & 1) && ((comb >> j) & 1)){\n                    int k = ((i + 1) ^ (j + 1)) - 1;\n                    if((comb >> k) & 1) Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 2);\n                    else Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 1);\n                }\n            }\n            x = comb & -comb, y = comb + x;\n            comb = ((comb & -y) / x >> 1) | y;\n        }\n    }\n    ans += dp[X];\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22],lg[66666];\nint f[66666],q[66666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tint ans=0;\n\tfor(register int i=2,j=1;i<65536;i<<=1,++j)lg[i]=j;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])++w;//w|=1<<i;\n\tf[w]=0;\n\t/*for(q[hq=1]=w,tq=2;hq!=tq;++hq)\n\t{\n\t\tint o=q[hq];\n\t\tint l=lg[o&-o];\n\t\tfor(register int i=l+1;i<16;++i)\n\t\t\tif(o&1<<i)\n\t}*/\n\tprintf(\"%d\\n\",ans+w-1); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(S & (1 << a[i])) ans ++;\n\t\tS ^= (1 << a[i]);\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[0] = 0;\n\tfor (int now = 1; now < (1 << 15); ++now) {\n\t\tfor (int i = 0; i < 15; ++i) {\n//\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n//\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (i ^ j))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S] + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define N 2001001\n#define MAX 2001\n#define re register\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst ll mod=1000000007; \ninline void read(re ll &ret)\n{\n    ret=0;re char c=getchar();re bool pd=false;\n    while(!isdigit(c)){pd|=c=='-';c=getchar();}\n    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}\n    ret=pd?-ret:ret;\n    return;\n}\nll n,x[N],y[N],a[N],w[N],cnt[N],ans,st,dp[N],sum[N];\nsigned main()\n{\n\tread(n);\n\tfor(re int i=1;i<n;i++)\n\t{\n\t\tread(x[i]);\n\t\tread(y[i]);\n\t\tread(a[i]);\n\t\tw[x[i]]^=a[i];\n\t\tw[y[i]]^=a[i];\n\t}\n\tfor(re int i=0;i<n;i++)\n\t\tcnt[w[i]]++;\n\tfor(re int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]>>1;\n\t\tst|=(cnt[i]&1)<<(i-1);\n\t}\n\tfor(re int i=1;i<(1<<15);i++)\n\t\tdp[i]=dp[i>>1]+(i&1);\n\tfor(re int i=1;i<(1<<15);i++)\n\t\tdp[i]--;\n\tfor(re int i=1;i<(1<<15);i++)\n\t\tfor(re int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tsum[i]^=j+1;\n\tfor(re int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sum[i])\n\t\t\tcontinue;\n\t\tfor(re int j=(i-1)&i;j;j=((j-1)&i))\n\t\t\tif(!sum[j])\n\t\t\t\tdp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tprintf(\"%lld\\n\",ans+dp[st]);\n\texit(0);\n}\n/*\n9 9\n9 8 7 6 2 4 5 3 1\n4 9 3 6\n2 9 1 8\n3 8 2 4\n3 9 2 7\n2 8 1 6\n1 9 1 9\n1 3 5 7\n2 3 3 3\n6 6 6 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint n;\nint basis[4], ori[4], a[N];\nbool vis[N];\nvector<pair<int, int>> g[N];\n\nint ins(int x) {\n  int sv = x;\n  int res = 0;\n  for (int i = 0; i < 4; ++i)\n    if ((x >> i) & 1)\n      if (!basis[i]) {\n        basis[i] = x;\n        ori[i] = sv;\n        return -1;\n      } else {\n        x ^= basis[i];\n        res |= 1 << i;\n      }\n  return res;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int rep = 1; rep < n; ++rep) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    a[u] ^= w;\n    a[v] ^= w;\n  }\n  int ans = n;\n  for (int i = 0; i < n; ++i) {\n    int res = ins(a[i]);\n    if (res != -1) {\n      --ans;\n      vector<int> rest;\n      for (int j = 0; j < 4; ++j)\n        if (!((res >> j) & 1) && basis[j])\n          rest.push_back(ori[j]);\n      memset(basis, 0, sizeof(basis));\n      for (int v : rest)\n        ins(v);\n    }\n  }\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long \n#define pb push_back\n//#define mp make_pair\n#define fr first\n#define sc second\n#define N ((ll)(2e6+100))\n#define MAX ((ll)(1e16+100))\n#define ARRS ((ll)(3e5+100))\n#define MOD ((ll)(1e9+7))\n#define M1 ((ll)(1001783))\n#define M2 ((ll)(1001941))\n#define M3 ((ll)(1002073))\n#define pb push_back\n\nll dp[ARRS];\nll f[ARRS];\nll c[ARRS];\n\n\nll go(ll x){\n\tif(x&1)x^=1;\n\tif(!x)return 0;\n\tif(dp[x])return dp[x];\n\tll a[18];\n\tll b[18];\n\tfor(int i=0; i<16; i++)a[i]=(x>>i)&1;\n\tdp[x]=MAX;\n\tfor(int i=1; i<16; i++){\n\t\tfor(int j=i+1; j<16; j++){\n\t\t\tif(a[i]&&a[j]){\n\t\t\t\tfor(int t=1; t<16; t++){\n\t\t\t\t\tfor(int i=0; i<16; i++)b[i]=a[i];\n\t\t\t\t\tb[i]--;\n\t\t\t\t\tb[j]--;\n\t\t\t\t\tb[i^t]++;\n\t\t\t\t\tb[j^t]++;\n\t\t\t\t\tll k=0;\n\t\t\t\t\tll r=0;\n\t\t\t\t\tfor(int i=0; i<16; i++){\n\t\t\t\t\t\tif(i)\n\t\t\t\t\t\tk+=b[i]/2;\n\t\t\t\t\t\tb[i]&=1;\n\t\t\t\t\t\tr=r|(b[i]<<i);\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<bitset<16>(x)<<endl;\n\t\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<t<<\" \"<<k<<endl;\n\t\t\t\t\t//cout<<bitset<16>(r)<<endl;\n\t\t\t\t\t//cout<<endl;\n\t\t\t\t\tif(x==r)continue;\n\t\t\t\t\tdp[x]=min(dp[x],go(r)+k+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[x];\n}\n\n\nint main(){\n\n\tll n;\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tll k,p,c;\n\t\tcin>>k>>p>>c;\n\t\tf[k]^=c;\n\t\tf[p]^=c;\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tc[f[i]]++;\n\n\tll t=0;\n\tll pas=0;\n\tfor(int i=0; i<16; i++){\n\t\tif(i)\n\t\tpas+=c[i]/2;\n\t\tc[i]&=1;\n\t\tt=t|(c[i]<<(i));\n\t}\n\n\tpas+=go(t);\n\n\tcout<<pas;\n}\n"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[33],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nconst int N=100000+10;\nconst int B=15;\nconst int S=(1<<B)-1;\n\nint _r;char _c;\n\nint read()\n{\n\twhile(!isdigit(_c=getchar()));\n\t_r=_c-48;\n\twhile(isdigit(_c=getchar()))\n\t\t_r=_r*10-48+_c;\n\treturn _r;\n}\n\nint n,b[N],ans,fl[B+1];\nint sum[S+1],dp[S+1];\n\nint count(int x)\n{\n\tint cnt(1);\n\twhile(!(x&1))\n\t{\n\t\t++cnt;\n\t\tx>>=1;\n\t}\n\treturn cnt;\n}\n\nint main()\n{\n\tans=n=read();\n\tint i,j,k,x,y,a;\n\tfor(i=1;i<n;++i)\n\t{\n\t\tx=read()+1;y=read()+1;\n\t\ta=read();\n\t\tb[x]^=a;\n\t\tb[y]^=a;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\t++fl[b[i]];\n\tans-=fl[0];\n\tfor(i=1;i<=B;++i)\n\t{\n\t\tans-=fl[i]>>1;\n\t\tfl[i]&=1;\n\t}\n\tfor(i=1;i<=S;++i)\n\t{\n\t\tk=count(j=i&(-i));\n\t\tsum[i]=sum[i^j]^k;\n\t}\n\tfor(i=0;i<=S;++i)\n\t{\n\t\tk=S^i;\n\t\tfor(j=k;j;(j-=1)&=k)if(!sum[j])\n\t\t\tdp[i^j]=max(dp[i^j],dp[i]+1);\n\t}\n\tfor(i=1,j=0;i<=B;++i)if(fl[i])\n\t\tj^=1<<(i-1);\n\tprintf(\"%d\",ans-dp[j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint f[133333],g[133333],a[133333],w[133333],p[133333];\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint n,i,x,y,l,j,cnt=0,ans=0;\n\tscanf(\"%d\",&n);\n//\tprintf(\"%d\\n\",n);\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&l);\n\t\tx++,y++;\n\t\tg[x]^=l,g[y]^=l; \n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(a[g[i]]&&g[i])\n\t\t\tans++;\n\t\ta[g[i]]^=1;\n\t}\n//\tprintf(\"%d\\n\",ans);\n\tfor(i=0;i<16;i++)\n\t\tif(a[i])\n\t\t\tp[++cnt]=i;\n//\tprintf(\"%d|\",cnt);\n\tfor(i=0;i<(1<<cnt);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(j=1;j<=cnt;j++)\n\t\t\tif((1<<j-1)&i)\n\t\t\t\tw[i]^=p[j],sum++;\n\t\tf[i]=sum-1;\n\t\tif(!w[i])\n\t\t{\n\t\t\tfor(j=i-1;j;j=(j-1)&i)\n\t\t\t{\n\t\t\t\tif(!w[j])\n\t\t\t\t\tf[i]=min(f[i],f[j]+f[i-j]);\n\t\t\t\telse\n\t\t\t\t\tf[i]=min(f[i],f[j]+f[i-j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[(1<<cnt)-1]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>bin[20];\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[20]={0},f[(1<<20)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint s=0,res=0,t=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tres+=v[i]/2,v[i]%=2;\n\t\tif(v[i]){\n\t\t\ts|=(1<<(i-1));\n\t\t\tt++;\n\t\t}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=14;j++)\n\t\t\tif(i&(1<<j))cnt++;\n\t\tbin[cnt].push_back(i);\n\t}\n\tfor(int p=2;p<=t;p++)\n\t\tfor(int k=0;k<bin[p].size();k++){\n\t\t\tint i=bin[p][k];\n\t\t\tfor(int u=0;u<=14;u++)\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=14;v++)\n\t\t\t\tif(i&(1<<v)&&(u!=v)){\n\t\t\t\t\tint w=(u+1)^(v+1)-1; \n\t\t\t\t\tif(u==w||v==w)continue;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int inf=0x3f3f3f3f;\nconst int U=1<<16;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=0;i<16;i++)if((S>>i)&1)\n\t\t\tfor(reg int j=0;j<16;j++)if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x3f,sizeof(f));\n\tfor(reg int i=1;i<n;i++){\n\t\treg int x=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[s[i]]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX],sum[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        sum[to.fi]=to.se;\n        \n        DFS(to.fi,u);\n        \n        A[u]^=to.se;\n        sum[u]^=sum[to.fi];\n        sum[u]^=A[u];\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(S & (1 << a[i])) ans ++;\n\t\tS ^= (1 << a[i]);\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[0] = 0;\n\tfor (int now = 1; now < (1 << 15); ++now) {\n\t\tfor (int i = 0; i < 15; ++i) {\n//\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n//\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (i ^ j))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, ans, a[N], cnt[M], dp[1 << M];\n\nbool ok(int mask) {\n\tint res = 0;\n\tfor (int i = 0; i < M; i++)\n\t\tif (mask & (1 << i))\n\t\t\tres ^= i;\n\treturn res == 0;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint mask = 0;\n\tfor (int i = 1; i < M; i++) {\n\t\tans += (cnt[i] >> 1);\n\t\tmask |= (cnt[i] &= 1) << i;\n\t\tans += cnt[i];\n\t}\n\tfor (int x = 1; x <= mask; x++) {\n\t\tdp[x] = ok(x);\n\t\tif ((mask & x) == x)\n\t\t\tfor (int y = x; y; y = (--y & x))\n\t\t\t\tif (y < x && ok(y))\n\t\t\t\t\tdp[x] = max(dp[x], dp[y] + dp[x ^ y]);\n\t}\n\tans -= dp[mask];\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n#include<set>\nusing namespace std;\nint cnt[16], val[100005], Xor[1<<15], num[1<<15], dp[1<<15];\n\ninline int read()\n{\n    int x=0,f=1; char ch=getchar();\n    for (; ch<'0' || ch>'9'; ch=getchar()) if (ch=='-') f=-1;\n    for (; ch>='0' && ch<='9'; ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\n\nint main()\n{\n    int n=read(), ans=0, sta=0;\n    for (int i=1, u, v, w; i<n; i++) \n        u=read(), v=read(), w=read(), val[u]^=w, val[v]^=w;\n    for (int i=0; i<n; i++) cnt[val[i]]++;\n    for (int i=1; i<=15; i++) ans+=cnt[i]/2, sta|=(cnt[i]&1)<<(i-1);\n    for (int i=1; i<(1<<15); i++) num[i]=num[i>>1]+(i&1);\n    for (int i=1; i<(1<<15); i++) dp[i]=num[i]-1;\n    for (int i=1; i<(1<<15); i++) \n        for (int j=1; j<=15; j++) if ((i>>(j-1))&1) Xor[i]^=j;\n    for (int i=1; i<(1<<15); i++)\n        if (!Xor[i])\n            for (int j=i; j; j=(j-1)&i)\n                if (!Xor[j]) dp[i]=min(dp[i], dp[j]+dp[i^j]);\n    ans+=dp[sta];\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint Res=0,f=1;char ch=getchar();\n\twhile (ch>'9'||ch<'0') f=(ch=='-'?-f:f),ch=getchar();\n\twhile (ch>='0'&&ch<='9') Res=Res*10+ch-'0',ch=getchar();\n\treturn Res*f;\n}\nint N,Ans,P,val[100005],F[32768];\nbool vis[100005];\nint dfs(int S){\n\tif (!S) return 0;\n\tif (F[S]) return F[S];\n\tint Res=1e9;\n\tfor (int i=1;i<=15;i++){\n\t\tif (!((S>>i-1)&1)) continue;\n\t\tfor (int j=1;j<=15;j++){\n\t\t\tif (!((S>>j-1)&1)) continue;\n\t\t\tif (i==j) continue;\n\t\t\tint Ns=S^(1<<i-1)^(1<<j-1)^(1<<(i^j)-1),add=1;\n\t\t\tif ((S>>(i^j)-1)&1) add++;\n\t\t\tRes=min(Res,dfs(Ns)+add);\n\t\t}\n\t}\n\treturn F[S]=Res;\n}\nint main()\n{\n\tN=read();\n\tfor (int i=1;i<N;i++){\n\t\tint x=read(),y=read(),z=read();\n\t\tval[x]^=z;val[y]^=z;\n\t}\n\tfor (int i=0;i<N;i++){if (vis[val[i]]&&val[i]) Ans++;vis[val[i]]^=1;}\n\tfor (int i=1;i<=15;i++) P|=(vis[i]<<i-1);\n\tprintf(\"%d\\n\",dfs(P)+Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][50][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 50) return 1e9;\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if(tmp < tcnt || (tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 65540\nusing namespace std;\nint n,s[N],S,ans,f[M],inf,sum[20];\n\nint dfs(int S)\n{\n  if(!S)return 0; \n  if(f[S]<inf)return f[S];\n  for(int i=0;i<16;i++)if((S>>i)&1)\n    for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1)\n    {\n      int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n      if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n      else f[S]=min(f[S],dfs(x)+1);\n      //æä¸¾æ¯æ¬¡å¼æçä¸¤ä¸ªèç¹i,j,iå¼ææj,jå¼ææj,è¿å©ä¸p=i^j\n      //å¦æpæ¬èº«å­å¨é£ä¸¤ä¸ªpç´æ¥æ¶æ \n    }\n  return f[S];\n}\n\nint main()\n{\n  int a,b,c;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d%d\",&a,&b,&c),s[a]^=c,s[b]^=c;\n  for(int i=0;i<n;i++)sum[s[i]]++;\n  for(int i=1;i<16;i++)\n    ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n  memset(f,127,sizeof(f));inf=f[0];\n  printf(\"%d\\n\",ans+dfs(S));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint res=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){res=(res<<3)+(res<<1)+ch-'0';ch=getchar();}\n\treturn res*f;\n}\nvoid write(int x){\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>9) write(x/10);\n\tputchar(x%10|'0');\n}\nconst int N=100005;\nint n,a[N],cnt[20],ans,st;\nint f[1<<16],xs[1<<16];\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++) {\n\t\tint u=read(),v=read(),w=read();\n\t\ta[u]^=w;a[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++) cnt[a[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=cnt[i]/2;st|=(cnt[i]&1)*(1<<(i-1));\n\t}\n\tint Lim=(1<<16)-1;\n\tfor(int i=1;i<=Lim;i++) f[i]=f[i>>1]+(i&1); \n\tfor(int i=1;i<=Lim;i++) f[i]--; \n\tfor(int i=1;i<=Lim;i++) \n\t\tfor(int j=1;j<=15;j++)\n\t\t\tif(i&(1<<(j-1))){\n\t\t\t\txs[i]=xs[i^(1<<(j-1))]^j;break;\n\t\t\t}\n\tfor(int i=1;i<=st;i++){\n\t\tif(xs[i]) continue;\n\t\tfor(int j=i&(i-1);j;j=(j-1)&i){\n\t\t\tif(xs[j]) continue;\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\t\t\n\t}\n\twrite(ans+f[st]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nint z[MC];\n\nint main(){\n\tcin >> N;\n\trepp(i,1,N){\n\t\tint x,y,a;\n\t\tcin >> x >> y >> a;\n\t\tz[x] ^= a;\n\t\tz[y] ^= a;\n\t}\n\tint ans = 0;\n\tfor(int k = 1 ; k < 16 ; k *= 2){\n\t\tint p = 0;\n\t\trepp(i,0,N) if(z[i]&k) ++p;\n\t\tans += p/2;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n;\nvector<pair<int,int> > g[N];\nvector<int> sons[N];\nint val[N];\nint used[N];\n\nvoid dfs(int v){\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i].first;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tint cost=g[v][i].second;\n\t\tsons[v].push_back(to);\n\t\tval[to]=val[v];\n\t\tval[to]^=cost;\n\t\tdfs(to);\n\t}\n\n\tfor (int i=0;i<sons[v].size();i++){\n\t\tint to=sons[v][i];\n\t\tval[v]^=val[to];\n\t}\n}\n\nint ans;\nint cnt[N];\nint pcount[N];\nint dp[N];\nint mem_xor[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(make_pair(b,c));\n\t\tg[b].push_back(make_pair(a,c));\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tpcount[i]=pcount[i/2]+i%2;\n\t}\n\n\tfor (int mask=0;mask<(1<<16);mask++){\n\t\tint here=0;\n\t\tfor (int i=0;i<16;i++){\n\t\t\tif (mask&(1<<i))\n\t\t\t\there^=i;\n\t\t}\n\t\tmem_xor[mask]=here;\n\t}\n\n\tdfs(0);\n\n\tfor (int i=1;i<n;i++){\n//\t\tcout<<val[i]<<endl;\n\t\tcnt[val[i]]++;\n\t}\n\n\tfor (int i=0;i<16;i++){\n\t\tif (i!=0)\n\t\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\n\tdp[0]=0;\n\n\tfor (int mask=1;mask<(1<<16);mask++){\n\t\tint smask=mask;\n\t\tdp[mask]=1e9;\n\t\twhile (true){\n\t\t\tif (smask==0)\n\t\t\t\tbreak;\n\t\t\tint here=pcount[smask];\n\t\t\tint is_good=mem_xor[smask];\n\t\t\tif (is_good==0)\n\t\t\t\there--;\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+here);\n\t\t\tsmask=(smask-1);\n\t\t\tsmask&=mask;\n\t\t}\n\t}\n\n\tint interesting=0;\n\tfor (int i=0;i<16;i++){\n\t\tif (cnt[i])\n\t\t\tinteresting|=(1<<i);\n\t}\n\tcout<<ans+dp[interesting]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define si(a) scanf(\"%d\",&a)\n#define f first\n#define s second\n#define mp(a,b) make_pair(a,b)\n#define MAX 100005\n\nvector<pair<int,int> > graph[MAX];\nint val_node[MAX][16],ans[MAX],allval[100005];\n\nint solve(int now,int from,int ed)\n{\n    if(graph[now].size()==1 && from!=-1){\n        if(ed){\n            val_node[now][ed]=1;\n            ans[now]=1;\n        }\n        return ans[now];\n    }\n    for(int i=0;i<graph[now].size();i++){\n        int to=graph[now][i].f,w=graph[now][i].s;\n        if(to==from)continue;\n        solve(to,now,w);\n        ans[now]+=ans[to];\n        for(int j=0;j<16;j++){\n            if(val_node[to][j]){\n                val_node[now][j]^=1;\n                if(!val_node[now][j])ans[now]--;\n            }\n        }\n    }\n    if(ed){\n        val_node[now][ed]^=1;\n        if(val_node[now][ed])ans[now]++;\n    }\n    return ans[now];\n}\n\nvoid precal(void)\n{\n    int tot=1<<16;\n    for(int msk=0;msk<tot;msk++){\n        for(int i=0;i<16;i++)if(msk&(1<<i))allval[msk]^=i;\n    }\n}\n\nint dp[100005];\n\nint calc(int msk)\n{\n    int &ret=dp[msk];\n    if(ret!=-1)return ret;\n    ret=0;\n    for(int submask=msk;submask>0;submask=(submask-1)&msk){\n        int xorval=allval[submask];\n        if((msk&(1<<xorval)) && !(submask&(1<<xorval))){\n            int tmp=msk^submask;\n            tmp^=(1<<xorval);\n            ret=max(ret,1+calc(tmp));\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int n,i;\n    si(n);\n    for(i=1;i<n;i++){\n        int u,v,w;\n        si(u);si(v);si(w);\n        graph[u].push_back(mp(v,w));\n        graph[v].push_back(mp(u,w));\n    }\n    precal();\n    int ans=solve(0,-1,0);\n    int msk=0;\n    for(i=0;i<16;i++)if(val_node[0][i])msk^=(1<<i);\n    memset(dp,-1,sizeof(dp));\n    cout<<ans-calc(msk)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    ans+=cnt[0];\n    for(int i=1; i<16; i++) ans+=cnt[i]>>1, cnt[i]%=2;\n    cnt[0]=0;\n    dp[0]=0;\n    for(int mask=1; mask<(1<<16); mask++){\n        int nw=0;\n        for(int i=0; i<16; i++) if(((mask>>i)&1)&&cnt[i]) nw^=i;\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<16); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<16)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nPROG: apc001f\nLANG: C++11\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long readi()\n{\n\tlong long input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = 10 * input + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\treturn input;\n}\nvoid printi(long long output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\nstring reads()\n{\n\tstring input = \"\";\n\tchar c = ' ';\n\twhile (c <= ' ')\n\t{\n\t\tc = getchar();\n\t}\n\twhile (c > ' ')\n\t{\n\t\tinput += c;\n\t\tc = getchar();\n\t}\n\treturn input;\n}\nint sgn(long long x)\n{\n\tif (x < 0) \n\t{\n\t\treturn -1;\n\t}\n\tif (x > 0) \n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nlong long randomize(long long mod)\n{\n\treturn ((1 << 30) * rand() + (1 << 15) * rand() + rand()) % mod;\n}\n\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-20;\n\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 100010\n\nlong long normalize(long long x, long long mod = INF)\n{\n\treturn (((x % mod) + mod) % mod);\n}\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\nint arr[MAXN];\nint mask;\nint ans;\nbool good[MAXN];\nint dp[MAXN];\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); \n\tsrand(time(0));\n\t//\tcout << fixed << setprecision(12);\t\n\t//\tcerr << fixed << setprecision(12);\n\tif (fopen(\"apc001f.in\", \"r\"))\n\t{\t\n\t\tfreopen (\"apc001f.in\", \"r\", stdin);\n\t\tfreopen (\"apc001f.out\", \"w\", stdout);\n\t}\n\tcin >> N;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tarr[u] ^= a;\n\t\tarr[v] ^= a;\n\t}\n\t//answer is N - # of cc's\n\t//maximize # of cc's\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tans++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mask & (1 << arr[i]))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t\tmask ^= (1 << arr[i]);\n\t}\n\tfor (int i = 0; i < (1 << 16); i++)\n\t{\n\t\tint val = 0;\n\t\tfor (int j = 0; j < 16; j++)\n\t\t{\n\t\t\tif (i & (1 << j))\n\t\t\t{\n\t\t\t\tval ^= j;\n\t\t\t}\n\t\t}\n\t\tif (val == 0)\n\t\t{\n\t\t\tgood[i] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << 16); i++)\n\t{\n\t\tfor (int j = i; j > 0; j = (j - 1) & i)\n\t\t{\n\t\t\tif (good[i ^ j])\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tans += dp[mask];\n\tcout << N - ans << '\\n';\n\t//\tcerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nbool used[MAXN], T[4][MAXN], T1[4][MAXN];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tREP(i, SZ(g[v]))\n\t{\n\t\tint to = g[v][i].first;\n\t\tif (!used[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tREP(j, 4)\n\t\t\t\tif (g[v][i].second & (1 << j))\n\t\t\t\t{\n\t\t\t\t\tT[j][v] ^= 1;\n\t\t\t\t\tT[j][to] ^= 1;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tsrand(time(NULL));\n\tint n, ans = INF, time0 = clock();\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tg[u].push_back(MP(v, a));\n\t\tg[v].push_back(MP(u, a));\n\t}\n\tdfs(0);\n\tif (clock() - time0 < 1.95 * CLOCKS_PER_SEC)\n\t{\n\t\tREP(j, 4)\n\t\t\tREP(i, n)\n\t\t\tT1[j][i] = T[j][i];\n\t\tint cur = 0;\n\t\tRFOR(mask, 16, 1)\n\t\t{\n\t\t\tvector <int> A;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tREP(j, 4)\n\t\t\t\t\tif ((mask & (1 << j)) && !T1[j][i])\n\t\t\t\t\t\tok = false;\n\t\t\t\tif (ok)\n\t\t\t\t\tA.push_back(i);\n\t\t\t}\n\t\t\tint p = -1;\n\t\t\tif (SZ(A) & 1)\n\t\t\t\tp = SZ(A) - 1;\n\t\t\tcur += SZ(A) >> 1;\n\t\t\tREP(i, SZ(A))\n\t\t\t{\n\t\t\t\tif (i == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tREP(j, 4)\n\t\t\t\tif (mask & (1 << j))\n\t\t\t\t\tT1[j][A[i]] = false;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cur);\n\t}\n\tcout << ans;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nconst int N=100010;\n\nvpii e[N];\nbool v[N];\nint s,a[N],d[1<<16],q[1<<16],b[16];\n\nvoid dfs(int k,int x)\n{\n\tv[k]=1;int t=x;a[k]=0;\n\tfor (vpii::iterator p=e[k].begin();p!=e[k].end();p++)\n\t\tif (!v[p->x])\n\t\t{\n\t\t\tdfs(p->x,p->y);t^=p->y;a[k]^=a[p->x];\n\t\t}\n\tif (t) {s++;a[k]^=(1<<(t-1));}\n}\n\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\te[x].pb(mp(y,z));e[y].pb(mp(x,z));\n\t}\n\tv[0]=1;s=0;a[0]=0;\n\tfor (vpii::iterator p=e[0].begin();p!=e[0].end();p++)\n\t{\n\t\tdfs(p->x,p->y);a[0]^=a[p->x];\n\t}\n\tint f=1,r=1;q[1]=a[0];\n\tfor (int i=0;i<(1<<15);i++) d[i]=16;d[a[0]]=0;\n\twhile (f<=r)\n\t{\n\t\tint x=q[f++],p=0;\n\t\tfor (int i=0;i<15;i++) if (x&(1<<i)) b[p++]=i;\n\t\tfor (int i=0;i<p;i++)\n\t\t{\n\t\t\tfor (int j=i+1;j<p;j++)\n\t\t\t\tif (d[x^(1<<b[i])^(1<<b[j])^(1<<(((b[i]+1)^(b[j]+1))-1))]==16)\n\t\t\t\t{\n\t\t\t\t\tq[++r]=x^(1<<b[i])^(1<<b[j])^(1<<(((b[i]+1)^(b[j]+1))-1));d[q[r]]=d[x]+1;\n\t\t\t\t}\n\t\t\tif (d[x^(1<<b[i])]==16)\n\t\t\t{\n\t\t\t\tq[++r]=x^(1<<b[i]);d[q[r]]=d[x]+1;\n\t\t\t}\n\t\t}\n\t}\n\tint t=0;\n\tfor (int i=0;i<15;i++) if (a[0]&(1<<i)) t++;\n\tprintf(\"%d\\n\",(s-t)/2+d[0]+(t-d[0])/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int N = 595959;\nconst int K = 16;\n\nint n, ans;\nint v[N];\nint cnt[N];\nvector<int> vec;\nint dp[1 << K];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        v[a] ^= c, v[b] ^= c;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cnt[v[i]]++;\n    }\n    ans += cnt[0];\n    cnt[0] = 0;\n    for (int i = 0; i < 16; i++)\n    {\n        ans += cnt[i] / 2;\n        if (cnt[i] % 2) vec.push_back(i);\n    }\n    //fill(dp, dp + (1 << vec.size()), N);\n    dp[0] = 0;\n    for (int mask = 1; mask < (1 << vec.size()); mask++)\n    {\n        for (int submask = mask; submask; submask = mask & (submask - 1))\n        {\n            int x = 0;\n            for (int i = 0; i < vec.size(); i++) if ((1 << i) & submask) x ^= vec[i];\n            if (x == 0) dp[mask] = max(dp[mask], dp[mask - submask] + 1);\n        }\n    }\n    cout << n - ans - dp[(1 << vec.size()) - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pll pair <ll , ll>\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n\n#define X first\n#define Y second\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n\nconst ll MAXN=1e5+10;\nconst ll MAXT=20;\nconst ll INF=1e9+10;\n\nvector <pll> vertex[MAXN];\n\nvector <pll> w;\n\nll a[MAXN];\n\nll dp[1<<MAXT];\n\nll e[MAXT];\n\nbool check[MAXN];\n\nvoid dfs(ll v)\n{\n    check[v]=true;\n\n    for(ll i=0;i<vertex[v].size();i++)\n    {\n        if (!check[vertex[v][i].X])\n        {\n            dfs(vertex[v][i].X);\n            a[v]^=vertex[v][i].Y;\n            a[vertex[v][i].X]^=vertex[v][i].Y;\n        }\n    }\n}\n\nint main()\n{\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n , x=0 , res=0;\n\tcin>>n;\n\n\tfor(ll i=0;i<(n-1);i++)\n    {\n        ll v , u , w;\n        cin>>v>>u>>w;\n\n        v++;\n        u++;\n\n        vertex[v].pb(mp(u , w));\n        vertex[u].pb(mp(v , w));\n    }\n\n    dfs(1);\n\n    for(ll i=1;i<=n;i++)\n    {\n        e[a[i]]++;\n    }\n\n    for(ll i=1;i<=15;i++)\n    {\n        res+=(e[i]/2);\n\n        if (e[i]&1)\n        {\n            x+=(1<<(i-1));\n        }\n    }\n\n    for(ll mask=1;mask<(1<<15);mask++)\n    {\n        w.pb(mp(__builtin_popcount(mask) , mask));\n    }\n\n    sort(w.begin() , w.end());\n\n    for(ll z=0;z<w.size();z++)\n    {\n        ll mask=w[z].Y;\n        dp[mask]=INF;\n\n        for(ll i=0;i<15;i++)\n        {\n            for(ll j=i+1;j<15;j++)\n            {\n                if (BIT(mask , i) && BIT(mask , j))\n                {\n                    ll w=((i+1)^(j+1))-1;\n                    dp[mask]=min(dp[mask] , dp[mask^(1<<i)^(1<<j)^(1<<w)]+BIT(mask , w)+1);\n                }\n            }\n        }\n    }\n\n    cout<<res+dp[x];\n}\n\n/*\n4\n0 1 1\n1 2 2\n2 3 4\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<stack>\n#include<cassert>\n#define F first\n#define S second\n#define mp make_pair\n#define pii pair<int,int>\n#define pb push_back\n#define mem(x,y) memset(x,y,sizeof x)\n#define sqr(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int INF=2e9;\nconst db eps=1e-8;\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0; int f=1; char ch=getchar();\n\twhile( (ch<'0' || ch>'9') && ch!='-') ch=getchar(); if(ch=='-') {f=-1; ch=getchar();}\n\twhile(ch>='0' && ch <='9') x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\n//==========================head template==========================\nconst int N=100010;\nint n;\nint head[N],nxt[N<<1],to[N<<1],co[N<<1],lst=1;\ninline void adde(int x,int y,int c) {\n\tnxt[++lst]=head[x]; to[lst]=y; co[lst]=c; head[x]=lst;\n}\nint fa[N],val[N];\nvoid Build(int u) {\n\tfor(int i=head[u];i;i=nxt[i]) {\n\t\tint v=to[i]; val[u]^=co[i];\n\t\tif(v==fa[u]) continue;\n\t\tfa[v]=u; Build(v);\n\t}\n}\nint num[N],ind=0;\nint ans=0;\nint f[1<<16];\ninline void DP() {\n\tint St=0;\n\tfor(int i=1;i<=ind;i++) St|=1<<num[i];\n\tmem(f,63); f[St]=0;\n\tfor(int i=St;i>=0;i--) \n\t\tfor(int p1=1;p1<16;p1++)\n\t\t\tif(i&(1<<p1))\n\t\t\t\tfor(int p2=1;p2<16;p2++)\n\t\t\t\t\tif(i&(1<<p2)){\n\t\t\t\t\t\tint sta=i^(1<<p1)^(1<<p2),v=1;\n\t\t\t\t\t\tif(sta&(1<<(p1^p2))) ++v;\n\t\t\t\t\t\tsta^=1<<(p1^p2);\n\t\t\t\t\t\tf[sta]=min(f[sta],f[i]+v);\n\t\t\t\t\t}\n\tans+=f[0];\n}\nsigned main()\n{\n\tread(n);\n\tfor(int i=1;i<n;i++) {\n\t\tint x,y,c; read(x); read(y); read(c);\n\t\t++x; ++y; adde(x,y,c); adde(y,x,c);\n\t}\n\tBuild(1);//good transfor: edge->point\n\tsort(val+1,val+n+1); val[n+1]=16;\n//\tfor(int i=1;i<=n;i++) printf(\"%d \",val[i]); puts(\"\");\n\tint cnt=1;\n\tfor(int i=2;i<=n+1;i++) {\n\t\tif(val[i]!=val[i-1]) {\n\t\t\tif(val[i-1]) {\n\t\t\t\tans+=cnt/2;\n\t\t\t\tif(cnt&1) num[++ind]=val[i-1];\n\t\t\t}\n\t\t\tcnt=1;\n\t\t} else ++cnt;\n\t}\n\tDP();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n7\n0 1 1\n0 2 3\n0 3 2\n1 4 2\n2 5 3\n3 6 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n\nint n, cnt[16], ans, now, f[101000], g[77777];\nvector<pii>G[101000], vec;\nvoid U(int &x,int y){ x=min(x,y); }\n\nvoid dfs(int x,int fff,int lasv){\n  for (auto y:G[x]){\n    if (y.fi==fff) continue;\n    dfs(y.fi,x,y.se);\n  }\n  lasv^=f[x];\n  if (fff&&lasv){\n    ++cnt[lasv];\n    f[fff]^=lasv;\n  }\n}\n\nint main(){\n  memset(g,33,sizeof g); g[0]=0;\n  for (int i=2;i<(1<<16);i+=2){\n    int x=0, c=-1;\n    for (int j=1;j<16;++j)\n      if (i>>j&1)\n        x^=j, ++c;\n    if (!x) vec.push_back((pii){i,c});\n  }\n  for (int i=1;i<16;++i) vec.push_back((pii){1<<i,1});\n  \n  for (int i=0;i<16;++i)\n    for (int x=0;x<(1<<16);x+=2) if (g[x]==i){\n      for (auto o:vec)\n        U(g[x^o.fi],i+o.se);\n    }\n  \n  cin>>n;\n  int x, y, z;\n  for (int i=1;i<n;++i){\n    scanf(\"%d%d%d\",&x,&y,&z); ++x; ++y;\n    G[x].push_back((pii){y,z});\n    G[y].push_back((pii){x,z});\n  }\n  srand(time(0)); dfs(rand()%n+1,0,0);\n  for (int i=1;i<16;++i){\n    ans+=cnt[i]>>1;\n    now|=(cnt[i]&1)<<i;\n  }\n  cout<<ans+g[now];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010,inf = 0x7ffffff;\nint n,du[maxn],tong[1 << 16],ans,limit,f[1 << 16];\n\nint prework(int sta)\n{\n    if (sta == 0)\n        return 0;\n    int res = 0,cnt = 0;\n    for (int i = 0; i <= 15; i++)\n        if (sta >> i & 1)\n        {\n            res ^= i;\n            cnt++;\n        }\n    if (res == 0)\n        return cnt - 1;\n    else\n        return inf;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i = 1; i < n; i++)\n    {\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        x++;\n        y++;\n        du[x] ^= z;\n        du[y] ^= z;\n    }\n    for (int i = 1; i <= n; i++)\n        tong[du[i]]++;\n    for (int i = 1; i <= 15; i++)\n    {\n        ans += tong[i] / 2;\n        tong[i] %= 2;\n        limit |= (tong[i] << i);\n    }\n    for (int i = 0; i <= limit; i++)\n        f[i] = prework(i);\n    for (int i = 0; i <= limit; i++)\n        for (int j = i;j;j = (j - 1) & i)\n            f[i] = min(f[i],f[j] + f[i ^ j]);\n    printf(\"%d\\n\",f[limit] + ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}\n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\t\n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++) \n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=25;\nconst int maxs=(1<<15)+1;\nconst int maxn=2e5+5;\nint n,ans,cnt;\nint sum[maxs],pw[maxs],F[maxs],G[maxs],B[maxs];\nint A[maxn],id[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;++i){\n\t\tint a=0,b=0,c=0;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tA[a+1]^=c,A[b+1]^=c;\n\t}\n\tfor(int i=1;i<=n;++i) ++sum[A[i]];\n\tfor(int i=1;i<=15;++i){\n\t\tans+=sum[i]/2;\n\t\tsum[i]%=2;\n\t\tif(sum[i]) B[++cnt]=i;\n\t}\n\tpw[0]=1;\n\tfor(int i=1;i<=cnt;++i) pw[i]=pw[i-1]<<1,id[pw[i]]=i;\n\tfor(int mask=1;mask<pw[cnt];++mask){\n\t\tF[mask]=10000;\n\t\tfor(int i=mask;i;i-=i&-i){\n\t\t\tint res=mask^(i&-i),s=id[i&-i];\n\t\t\tG[mask]=G[res]^B[s+1];\n\t\t\tif(!G[res]) F[mask]=min(F[mask],F[res]);\n\t\t\telse F[mask]=min(F[mask],F[res]+1);\n\t\t\t//cout<<mask<<\" \"<<res<<\" \"<<B[s+1]<<\" \"<<s<<\" \"<<F[mask]<<\" \"<<G[mask]<<endl;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+F[pw[cnt]-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint n;\nint a[N], c[16], v[16], dp[1 << 15];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int rep = 1; rep < n; ++rep) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    a[u] ^= w;\n    a[v] ^= w;\n  }\n  int ans = n;\n  for (int i = 0; i < n; ++i)\n    if (a[i])\n      ++c[a[i]];\n    else\n      --ans;\n  int m = 0;\n  for (int i = 1; i <= 15; ++i) {\n    ans -= c[i] >> 1;\n    c[i] &= 1;\n    if (c[i])\n      v[m++] = i;\n  }\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for (int s = 1; s < 1 << m; ++s) {\n    int xs = 0;\n    for (int i = 0; i < m; ++i)\n      if ((s >> i) & 1)\n        xs ^= v[i];\n    if (xs) continue;\n    int t = (s - 1) & s;\n    while (true) {\n      if (dp[t] != -1)\n        dp[s] = max(dp[s], dp[t] + 1);\n      if (!t)\n        break;\n      t = (t - 1) & s;\n    }\n  }\n  ans -= dp[(1 << m) - 1];\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n#define bit(a , b) (((a)>>(b))&1)\n\nconst int maxn = 1e5 + 20;\nconst int maxm = 16;\n\nint t[maxn] , a[maxm] , dp[1 << maxm];\n\nint And[1 << maxm];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b , c;\n\t\tcin >> a >> b >> c;\n\n\t\tt[a] ^= c;\n\t\tt[b] ^= c;\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[t[i]]++;\n\n\tint res = a[0] , mask = 0;\n\tfor(int i = 1; i < maxm; i++)\n\t{\n\t\tres += a[i] / 2;\n\t\ta[i] %= 2;\n\n\t\tmask += (1 << i) * a[i];\n\t}\n\n\tfor(int i = 0; i < maxm; i++)\n\t\tAnd[1 << i] = i;\n\n\tfor(int mask = 1; mask < (1 << maxm); mask++)\n\t{\n\t\tint lb = (mask&(-mask));\n\n\t\tif(lb == mask)\n\t\t\tcontinue;\n\n\t\tAnd[mask] = And[mask ^ lb] ^ And[lb];\n\t}\n\n\tfor(int mask = 1; mask < (1 << maxm); mask++)\n\t{\n\t\tif(And[mask] != 0)\n\t\t\tcontinue;\n\n\t\tdp[mask] = 1;\n\t\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask)\n\t\t\tif(submask != mask && And[submask] == 0)\n\t\t\t\tdp[mask] = max(dp[mask] , dp[submask] + 1);\n\t}\n\n\tcout << n - res - dp[mask] << endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct edge{\n\tint to,nxt,dis;\n}e[200101];\nint head[101010],tot,n;\ninline void made(int from,int to,ll dis){\n\te[++tot].to=to;e[tot].nxt=head[from];head[from]=tot,e[tot].dis=dis;\n}\nint a[101010],b[101010],f[201010],g[202020];\nvoid dfs(int u,int faa){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==faa) continue; \n\t\ta[v]=e[i].dis;\n\t\tdfs(v,u);\n\t\ta[u]^=a[v];\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tmade(x+1,y+1,z),made(y+1,x+1,z);\n\t}\n\tdfs(1,0);\n\tint all=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]) b[a[i]]^=1,all^=(1<<(a[i]-1));\n\t}\n\tfor (int zt=1;zt<=all;zt++){\n\t\tbool flag=0;\n\t\tfor (int i=0;i<15;i++){\n\t\t\tif ((1<<i)&zt&(!b[i+1])){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t\telse if ((1<<i)&zt) g[zt]^=i+1;\n\t\t}\n\t\tif (!flag){\n\t\t\tf[zt]=__builtin_popcount(zt)-1;\n\t\t\tfor (int i=zt&(zt-1);i;i=zt&(i-1)){\n\t\t\t\tif (g[zt^i]|g[i]){\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[all];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\næ°æ®ä¸æ¸ç©ºï¼çé¶ä¸¤è¡æ³ªã\nå¤æµä¸è¯»å®ï¼çé¶ä¸¤è¡æ³ªã\nè¾¹çä¸ç¹å¤ï¼çé¶ä¸¤è¡æ³ªã\nè´ªå¿ä¸è¯æï¼çé¶ä¸¤è¡æ³ªã\nD P é¡ºåºéï¼çé¶ä¸¤è¡æ³ªã\nå¤§å°å°ç­å·ï¼çé¶ä¸¤è¡æ³ªã\nåéä¸ç»ä¸ï¼çé¶ä¸¤è¡æ³ªã\nè¶çä¸å¤æ­ï¼çé¶ä¸¤è¡æ³ªã\nè°è¯ä¸æ³¨éï¼çé¶ä¸¤è¡æ³ªã\næº¢åºä¸ l lï¼çé¶ä¸¤è¡æ³ªã\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nconst int inf=0x3f3f3f3f;\nint lowbit(int x){return x&-x;}\nint ppc(int x){return __builtin_popcount(x);}\nconst int N=100000;\nint n;\nvector<pair<int,int> > nei[N+1];\nint buc[16];\nint dfs(int x=1,int fa=0){\n\tint xsm=0;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i].X,v=nei[x][i].Y;\n\t\tif(y==fa)continue;\n\t\tint tmp=dfs(y,x)^v;\n\t\txsm^=tmp;\n\t\tbuc[tmp]++;\n\t}\n\treturn xsm;\n}\nint dp[1<<15];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tx++;y++;\n\t\tnei[x].pb(mp(y,z));nei[y].pb(mp(x,z));\n\t}\n\tdfs();\n\tfor(int i=1;i<1<<15;i++){\n\t\tif(lowbit(i)==i){dp[i]=1;continue;}\n\t\tint xsm=0;\n\t\tfor(int j=1;j<=15;j++)if(i&1<<j-1)xsm^=j;\n\t\tif(!xsm){dp[i]=ppc(i)-1;continue;}\n\t\tdp[i]=inf;\n\t\tfor(int j=i-1&i;j;j=j-1&i)dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tint ans=0,msk=0;\n\tfor(int i=1;i<=15;i++)ans+=buc[i]>>1,msk|=(buc[i]&1)<<i-1;\n\tcout<<ans+dp[msk];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nconst int N=100010;\n\nvpii e[N];\nbool v[N];\nint s,a[N],d[1<<16],q[1<<16],b[16];\n\nvoid dfs(int k,int x)\n{\n\tv[k]=1;int t=x;a[k]=0;\n\tfor (vpii::iterator p=e[k].begin();p!=e[k].end();p++)\n\t\tif (!v[p->x])\n\t\t{\n\t\t\tdfs(p->x,p->y);t^=p->y;a[k]^=a[p->x];\n\t\t}\n\tif (t) {s++;a[k]^=(1<<(t-1));}\n}\n\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\te[x].pb(mp(y,z));e[y].pb(mp(x,z));\n\t}\n\tv[0]=1;s=0;a[0]=0;\n\tfor (vpii::iterator p=e[0].begin();p!=e[0].end();p++)\n\t{\n\t\tdfs(p->x,p->y);a[0]^=a[p->x];\n\t}\n\tint f=1,r=1;q[1]=a[0];\n\tfor (int i=0;i<(1<<15);i++) d[i]=16;d[a[0]]=0;\n\twhile (f<=r)\n\t{\n\t\tint x=q[f++],p=0;\n\t\tfor (int i=0;i<15;i++) if (x&(1<<i)) b[p++]=i;\n\t\tfor (int i=0;i<p;i++)\n\t\t{\n\t\t\tfor (int j=i+1;j<p;j++)\n\t\t\t\tif (d[x^(1<<b[i])^(1<<b[j])^(1<<(((b[i]+1)^(b[j]+1))-1))]==16)\n\t\t\t\t{\n\t\t\t\t\tq[++r]=x^(1<<b[i])^(1<<b[j])^(1<<((b[i]+1)^(b[j]+1)-1));d[q[r]]=d[x]+1;\n\t\t\t\t}\n\t\t\tif (d[x^(1<<b[i])]==16)\n\t\t\t{\n\t\t\t\tq[++r]=x^(1<<b[i]);d[q[r]]=d[x]+1;\n\t\t\t}\n\t\t}\n\t}\n\tint t=0;\n\tfor (int i=0;i<15;i++) if (a[0]&(1<<i)) t++;\n\tprintf(\"%d\\n\",(s-t)/2+d[0]+(t-d[0])/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    ans+=cnt[0];\n    for(int i=1; i<16; i++) ans+=cnt[i]>>1, cnt[i]%=2;\n    cnt[0]=0;\n    dp[0]=0;\n    vector<int> v;\n    for(int i=0; i<16; i++) if(cnt[i]) v.eb(i);\n    int m=v.size();\n    for(int mask=1; mask<(1<<m); mask++){\n        int nw=0;\n        for(int i=0; i<m; i++) if((mask>>i)&1) nw^=v[i];\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<m); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<m)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nstruct node{\n\tint sumy;\n\tint val;\n};\nint n;\nint hed[N],tal[N<<1],val[N<<1],nxt[N<<1],cnt=0;\nint nod[N];\nint bot[16];\nint sum=0;\nint q[16],t=0;\nnode s[1<<17];\nint f[1<<17];\nint bo[1<<17];\nvoid addege(int x,int y,int z){\n\tcnt++;\n\ttal[cnt]=y;\n\tval[cnt]=z;\n\tnxt[cnt]=hed[x];\n\thed[x]=cnt;\n} \nvoid dfs(int u,int fa){\n\tfor(int i=hed[u];i;i=nxt[i]){\n\t\tint v=tal[i];\n\t\tif(v==fa) continue;\n\t\tnod[v]^=val[i];\n\t\tdfs(v,u);\n\t\tnod[u]^=val[i];\n\t}\n}\nbool cmp(node x,node y){\n\treturn x.sumy>y.sumy;\n}\nint main(){\n\tmemset(f,127,sizeof(f));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++,y++;\n\t\taddege(x,y,z);\n\t\taddege(y,x,z);\n\t}\n\tdfs(1,1);\n\t//for(int i=1;i<=n;i++) cout<<nod[i]<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(nod[i]==0) continue;\n\t\tbot[nod[i]]++;\n\t\tif(bot[nod[i]]==2){\n\t\t\tbot[nod[i]]-=2;\n\t\t\tsum++;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=15;i++){\n\t\tif(bot[i]>0) q[++t]=i;\n\t}\n\t//cout<<\"**\"<<t<<endl;\n\tfor(int i=0;i<=(1<<t)-1;i++){\n\t\ts[i].val=i;\n\t\tif(i==0) s[i].sumy=0;\n\t\tfor(int j=1;j<=t;j++){\n\t\t\t//cout<<j<<\" \"<<t<<endl;\n\t\t\tif(i&(1<<(j-1))) continue;\n\t\t\ts[i|(1<<(j-1))].sumy=s[i].sumy+1;\n\t\t}\n\t}\n\tsort(s,s+(1<<t)-1+1,cmp);\n\tfor(int i=0;i<=(1<<t)-1;i++){\n\t\tbo[s[i].val]=i;\n\t}\n\tf[(1<<t)-1]=0;\n\tfor(int i=0;i<=(1<<t)-1;i++){\n\t\tint state=s[i].val;\n\t\tint x;\n\t\tif(s[i].sumy==1){\n\t\t\tf[0]=min(f[0],f[state]+1);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=1;j<=t;j++){\n\t\t\tif(!state&(1<<(j-1))) continue;\n\t\t\tx=j;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int y=1;y<=t;y++){\n\t\t\tif(!state&(1<<(q[y]-1))) continue;\n\t\t\tif(y==x) continue;\n\t\t\tint dx=(1<<(q[x]-1)),dy=(1<<(q[y]-1));\n\t\t\tint dz=(1<<((q[x]^q[y])-1));\n\t\t\tf[state-dx-dy+dz]=min(f[state-dx-dy+dz],f[state]+1);\n\t\t\tif((state-dx-dy)&dz){\n\t\t\t\tf[state-dx-dy-dz]=min(f[state-dx-dy-dz],f[state]+2);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[0]+sum<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//By Ralif Rakhmatullin\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cstring>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<valarray>\n#include<iterator>\n#include<list>\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define S second\n#define ld long double\n#define F first\n#define y1 LOL\n#define ld long double\n#define pb push_back\n#define len length\n#define sz size\n#define beg begin\nconst ll INF = (ll)1e18 + 123;\nconst int inf=(int)2e9 + 123; \nconst int mod=1e9+7;\nusing namespace std;\nint n;\nint a[100011], f[22];\nvector<int> v;\nint dp[(1 << 16) + 123];\nint ans = 0;\nint xr[(1 << 16) + 123], sum[(1 << 16) + 123];\nint main(){\n\tunsigned int FOR;\n \tasm(\"rdtsc\" : \"=A\"(FOR));\n  \tsrand(FOR);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout.tie(0);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin >> n;\n\tfor(int i = 1; i < n; i ++){\n\t\tint x, y, c;\n\t\tcin >> x >> y >> c;\n\t\tx ++;\n\t\ty ++;\n\t\ta[x] ^= c;\n\t\ta[y] ^= c;\n\t}\n\tfor(int i = 1; i <= n; i ++){\n\t\tf[a[i]] ++;\n\t}\n\tfor(int i = 1; i <= 15; i ++){\n\t\tans += f[i] / 2;\n\t\tif(f[i] % 2){\n\t\t\tv.pb(i);\n\t\t}\n\t}\n\tint sz = v.sz();   /*\n\tfor(int i = 0; i < v.sz(); i ++){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;    */\n\tfor(int mask = 1; mask < (1 << sz); mask ++){\n\t\tfor(int i = 0; i < sz; i ++){\n\t\t\tif(((1 << i) & mask) == 0)\n\t\t\t\tcontinue;\n\t\t\txr[mask] = xr[mask] ^ v[i];\n\t\t\tsum[mask] ++;\n\t\t}\n\t//\tcout << mask << \" \" << xr[mask] << \" \" << sum[mask] << endl;\n\t\tsum[mask] --;\n\t}                                                \n\tdp[0] = 0;\n\tfor(int mask = 1; mask < (1 << sz); mask ++){\n\t\tdp[mask] = inf;\n\t\tfor(int s = mask; s > 0; s = ((s - 1) & mask)){\n\t\t\tif(xr[s] > 0)\n\t\t\t\tcontinue;\n\t\t\tdp[mask] = min(dp[mask], dp[mask ^ s] + sum[s]);\n\t\t}\n\t}\n\tcout << dp[(1 << sz) - 1] + ans; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define lson l,(l+r)/2,rt<<1\n#define rson (l+r)/2+1,r,rt<<1|1\n#define dbg(x) cout<<#x<<\" = \"<< (x)<< endl\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define sz(x) (int)(x).size()\nconst int mxn=1e5+10;\nint b[mxn];\nint cnt[16];\nint a[20];\nint sz=0;\nint dp[mxn];\nbool flag[mxn];\ninline void check(int mask){\n\tint x=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(mask &(1<<i))x^=a[i];\n\t}\n\tflag[i]= (x==0);\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\tb[u]^=w;\n\t\tb[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcnt[b[i]]++;\n\t}\n\tint component=cnt[0];\n\tfor(int i=1;i<16;i++){\n\t\tcomponent+=cnt[i]/2;\n\t\tif(cnt[i]%2)a[sz++]=i;\n\t}\n\tint up=(1<<sz)-1;\n\tfor(int i=1;i<=up;i++){\n\t\tcheck(i);\n\t\tfor(int x=i;x;x=((x-1)&i)){\n\t\t\tif(flag[i])dp[i]=max(dp[i],1+dp[x^i]);\n\t\t}\n\t}\n\tcout<<n-component-dp[up];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { os << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\n}\n\nint main()\n{\n\tios_init();\n\tint n;\n\twhile(cin >> n) {\n\t\tvector<int> hoge(n);\n\t\tREP(i, n-1) {\n\t\t\tint x, y, a;\n\t\t\tcin  >> x >> y >> a;\n\t\t\thoge[x] = hoge[x]^a;\n\t\t\thoge[y] = hoge[y]^a;\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, n) {\n\t\t\tif(hoge[i] != 0) ans++;\n\t\t}\n\t\tcout << (ans+1)/2 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nusing edge = struct {int to, cost;};\nvector<edge> graph[limit];\n\nint group[1 << 16];\nint value[limit];\n\nvoid dfs(int v, int p, int x) {\n\tvalue[v] = x;\n\tfor (auto &e : graph[v]) {\n\t\tif (e.to == p) continue;\n\t\tdfs(e.to, v, x ^ e.cost);\n\t}\n\treturn;\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tgroup[0] = 0;\n\trep(mask, 1 << 16) {\n\t\trep(i, 1, 16) {\n\t\t\tif (mask & (1 << i)) continue;\n\t\t\tconst int nmask = mask | (1 << i);\n\t\t\tint cur = 0;\n\t\t\trep(j, 1, 16) if (nmask & (1 << j)) cur ^= j;\n\t\t\tchmax(group[nmask], group[mask] + (cur == 0));\n\t\t}\n\t}\n\n\trep(i, n - 1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgraph[x].push_back({y, a});\n\t\tgraph[y].push_back({x, a});\n\t}\n\n\tdfs(0, -1, 0);\n\n\tint ans = 1 << 30;\n\n\trep(k, 16) {\n\t\tvector<int> num(16, 0);\n\t\trep(i, n) {\n\t\t\tconst int x = value[i] ^ k;\n\t\t\tnum[x]++;\n\t\t}\n\n\t\tint cur = n - num[0], mask = 0;\n\t\trep(i, 1, 16) {\n\t\t\tmask |= ((num[i] % 2) << i);\n\t\t\tcur -= num[i] / 2;\n\t\t}\n\t\tcur -= group[mask];\n\t\tchmin(ans, cur);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans;\nint dp(int s)\n{\n\tif(!s)\n\t\treturn 0;\n\tif(f[s]<0x3f3f3f3f)\n\t\treturn f[s];\n\tfor(int i=0;i<=15;i++)\n\t{\n\t\tif(!(s&(1<<i)))\n\t\t\tcontinue;\n\t\tfor(int j=0;j<=15;j++)\n\t\t{\n\t\t\tif(i==j||!(s&(1<<j)))\n\t\t\t\tcontinue;\n\t\t\tint k=i^j;\n\t\t\tint t=s^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif(s&(1<<k))\n\t\t\t\tf[s]=min(f[s],dp(t)+2);\n\t\t\telse\n\t\t\t\tf[s]=min(f[s],dp(t)+1);\n\t\t}\n\t}\n\treturn f[s];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta++;\n\t\tb++;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tprintf(\"%d\",ans+dp(s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof a)\n#define PII pair<int,int>\n#define PI acos(-1.0)\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF=0x3f3f3f3f;\nconst int maxn=1e5+10;\nint dp[1<<16],V[maxn],cnt[16];\nint n,x,y,a;\ninline int Count(int x)\n{\n\tint ans=0;\n\tfor(int i=0;i<=15;++i) if(x&(1<<i)) ans++;\n\treturn ans;\n}\nint Work(int s)\n{\n    if(s==0) return 0;\n    if(dp[s]!=-1) return dp[s];\n    dp[s]=INF;\n    for(int i=1;i<16;i++)\n    {\n    \tif(s&(1<<i))\n            for(int j=1;j<16;j++)\n            {\n            \t\n            \tif(s&(1<<j))\n                {\n                    int cs=s^(1<<i)^(1<<j)^(1<<(i^j));\n                    if(Count(cs)<Count(s)) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(((1<<(i^j)) & s) == (1<<(i^j))) dp[s]=min(dp[s], Work(cs) + 2);\n\t\t\t\t\t\telse dp[s]=min(dp[s], Work(cs) + 1 ); \n\t\t\t\t\t}\n                }\n\t\t\t}\n\t}\n    return dp[s];\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&a);\n        V[x]^=a; V[y]^=a;\n    }\n    for(int i=0;i<n;i++) if(V[i]) cnt[V[i]]++;\n    int ans=0,s=0;\n    for(int i=0;i<16;i++) ans+=cnt[i]/2, s^=(cnt[i]&1)<<i;\n    memset(dp,-1,sizeof dp);\n    ans+=Work(s);\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>bin[20];\nconst int maxn=10000000;\nint n,d[maxn+4]={0},v[20]={0},f[(1<<20)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint s=0,res=0,t=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tres+=v[i]/2,v[i]%=2;\n\t\tif(v[i]){\n\t\t\ts|=(1<<(i-1));\n\t\t\tt++;\n\t\t}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=14;j++)\n\t\t\tif(i&(1<<j))cnt++;\n\t\tbin[cnt].push_back(i);\n\t}\n\tfor(int p=0;p<=15;p++)\n\t\tfor(int k=0;k<bin[p].size();k++){\n\t\t\tint i=bin[p][k];\n\t\t\tfor(int u=0;u<=15;u++)\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=15;v++)\n\t\t\t\tif(i&(1<<v)&&u!=v){\n\t\t\t\t\tint w=u^v; \n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint A[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tA[a] ^= c;\n\t\tA[b] ^= c;\n\t}\n\trep(i, 0, N) cnt[A[i]]++;\n\n\tint ans = 0, remain = 0;\n\trep(i, 1, 16) {\n\t\tans += cnt[i] / 2;\n\t\tremain += cnt[i] % 2;\n\t}\n\tans += max(remain - 1, 0);\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, a[N], cnt[M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[--u] ^= w;\n\t\ta[--v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\n\tbool done = false;\n\twhile (done == false) {\n\t\tdone = true;\n\t\tfor (int i = 1; i < M; i++)\n\t\t\twhile (cnt[i] >= 2) {\n\t\t\t\tcnt[i] -= 2;\n\t\t\t\tans++;\n\t\t\t\tdone = false;\n\t\t\t}\n\t\tif (done) {\n\t\t\tint x = 0;\n\t\t\tfor (int i = 1; i < M; i++)\n\t\t\t\tx += cnt[i];\n\t\t\tans += max(0, x - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, a[N], cnt[M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\n\tbool done = false;\n\twhile (done == false) {\n\t\tdone = true;\n\t\tfor (int i = 1; i < M && done; i++)\n\t\t\tfor (int j = i; j < M && done; j++)\n\t\t\t\tif ((i & j) && cnt[i] && cnt[j] && (i != j || cnt[i] >= 2)) {\n\t\t\t\t\tdone = false;\n\t\t\t\t\tcnt[i]--;\n\t\t\t\t\tcnt[j]--;\n\t\t\t\t\tcnt[i ^ (i & j)]++;\n\t\t\t\t\tcnt[j ^ (i & j)]++;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}//è´ªå¿ \n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç \n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);//é¢å¤çéåçå¼æå \n    for(int i=1;i<(1<<15);i++)//æä¸¾å­éè¿è¡è½¬ç§» \n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    ans+=cnt[0];\n    for(int i=1; i<16; i++) ans+=cnt[i]>>1, cnt[i]%=2;\n    cnt[0]=0;\n    dp[0]=0;\n    for(int mask=1; mask<(1<<16); mask++){\n        int nw=0;\n        for(int i=0; i<16; i++) if(((mask>>i)&1)&&cnt[i]) nw^=i;\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<16); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    int mask=0;\n    for(int i=0; i<16; i++) if(cnt[i]) mask|=1<<i;\n    ans+=dp[mask];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nconst int bits = 15;\nconst int limit = 1 << bits;\n\nint n, i, x, y, z, ans;\nvector< pair<int, int> > list[maxN];\nint dp[limit];\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > H;\nint tp;\n\nvoid pre() {\n    int i, j, to, aux;\n\n    for (i = 0; i < limit; i++) dp[i] = n;\n    dp[0] = 0;\n    H.push(mp(0, 0));\n\n    while (!H.empty()) {\n        int conf = H.top().second;\n        int cost = H.top().first;\n        H.pop();\n\n        if (dp[conf] != cost) continue;\n\n        for (i = 0; i < bits; i++) {\n            for (j = 0; j < bits; j++) {\n                if (i == j) continue;\n                to = conf ^ (1 << i) ^ (1 << j);\n\n                aux = 1 << (((i + 1) ^ (j + 1)) - 1);\n                if (conf & aux) continue;\n                to ^= aux;\n\n                if (dp[to] > dp[conf] + 1) {\n                    dp[to] = dp[conf] + 1;\n                    H.push(mp(dp[to], to));\n                }\n            }\n\n            if (conf & (1 << i)) continue;\n            to = conf ^ (1 << i);\n            if (dp[to] > dp[conf] + 1) {\n                dp[to] = dp[conf] + 1;\n                H.push(mp(dp[to], to));\n            }\n        }\n    }\n}\n\nvoid dfs(int node, int root, int need) {\n    int act = 0;\n\n    for (auto to : list[node])\n        if (to.first != root)\n            dfs(to.first, node, to.second), act ^= to.second;\n\n    if (node != 1 && act != need)\n        tp ^= (1 << (act ^ need)), ans++;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    pre();\n    for (i = 1; i < n; i++) {\n        cin >> x >> y >> z;\n        x++; y++;\n        list[x].pb(mp(y, z));\n        list[y].pb(mp(x, z));\n    }\n\n    dfs(1, 0, 0);\n    ans += dp[tp];\n\n    cout << ans / 2;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef  long long LL;\ntypedef  unsigned long long ULL;\ntypedef  double db;\ntypedef  long double ld;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define fuck(x) cout<<x<<endl\n#define fuck1(x,y) cout<<x<<\" \"<<y<<endl\n#define lson root<<1,l,mid\n#define rson root<<1|1,mid+1,r\n#define MP(a,b) make_pair(a,b)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\nconst int INF = 0x3f3f3f3f3f,mod = 1e9+7,maxn = 3e5+100;\nconst double eps  =1e-6,PI = acos(-1);\ntemplate<typename T> inline void read(T &x){\n    x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\nint N,val[maxn],cnt[20];\nint d[maxn],ss[maxn];\nint main(){\n    read(N);\n    for(int i = 0;i<N-1;i++){\n        int x,y,a;\n        read(x),read(y),read(a);\n        val[x]^=a;\n        val[y]^=a;\n    }\n    for(int i = 0;i<N;i++){\n        if(val[i])cnt[val[i]]++;\n    }\n    int ans = 0,st = 0;\n    for(int i = 0;i<16;i++){\n        ans+=cnt[i]/2;\n        if(cnt[i]&1)st = st|(1<<i);\n    }\n    for(int i = 1;i<=(1<<15);i++)d[i] = d[i>>1]+(i&1);\n    for(int i = 1;i<=(1<<15);i++)d[i]--;\n    for(int i = 1;i<=(1<<15);i++){\n        for(int j = 0;j<=15;j++){\n            if(i&(1<<j))ss[i]^=(j+1);\n        }\n    }\n    for(int i = 1;i<=(1<<15);i++){\n        if(ss[i]!=0)continue;\n        for(int k = (i-1)&i;k;k = (k-1)&i){\n            if(ss[k]==0)d[i] = min(d[i],d[k]+d[i^k]);\n        }\n    }\n    printf(\"%d\\n\",ans+d[st]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nbool used[MAXN], T[4][MAXN];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tREP(i, SZ(g[v]))\n\t{\n\t\tint to = g[v][i].first;\n\t\tif (!used[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tREP(j, 4)\n\t\t\t\tif (g[v][i].second & (1 << j))\n\t\t\t\t{\n\t\t\t\t\tT[j][v] ^= 1;\n\t\t\t\t\tT[j][to] ^= 1;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = 0;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tg[u].push_back(MP(v, a));\n\t\tg[v].push_back(MP(u, a));\n\t}\n\tdfs(0);\n\tRFOR(mask, 16, 1)\n\t{\n\t\tvector <int> A;\n\t\tREP(i, n)\n\t\t{\n\t\t\tbool ok = true;\n\t\t\tREP(j, 4)\n\t\t\t\tif ((mask & (1 << j)) && !T[j][i])\n\t\t\t\t\tok = false;\n\t\t\tif (ok)\n\t\t\t\tA.push_back(i);\n\t\t}\n\t\tif (SZ(A) & 1)\n\t\t\tA.pop_back();\n\t\tans += SZ(A) >> 1;\n\t\tREP(i, SZ(A))\n\t\t\tREP(j, 4)\n\t\t\tif (mask & (1 << j))\n\t\t\t\tT[j][A[i]] = false;\n\t}\n\tcout << ans;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, ap[20], E[100009], d[1 << 16], frm[1 << 16];\nvector < pair < int, int > > h[100009];\nvector < pair < int, int > > v[1 << 16];\n\nvoid dfs (int nod, int tata)\n{\n    for (auto it : h[nod])\n        if (it.first != tata)\n            E[it.first] = it.second, dfs (it.first, nod), E[nod] ^= E[it.first];\n}\n\npriority_queue < pair < int, int > > PQ;\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y, z;\n    scanf (\"%d %d %d\", &x, &y, &z), x ++, y ++;\n    h[x].push_back ({y, z});\n    h[y].push_back ({x, z});\n}\ndfs (1, -1);\nfor (int i=2; i<=N; i++)\n    ap[E[i]] ++;\nint ans = 0, msk = 0;\nfor (int i=1; i<16; i++)\n{\n    if (ap[i] & 1) msk |= 1 << i;\n    ans += (ap[i] >> 1);\n}\nfor (int msk = 0; msk < (1 << 16); msk +=2)\n    for (int i=1; i<16; i++)\n        if (msk & (1 << i))\n        {\n            v[msk].push_back ({msk ^ (1 << i), 1});\n            int aux = msk ^ (1 << i);\n            for (int j=1; j<16; j++)\n                if (aux & (1 << j))\n                {\n                    if (aux & (1 << (j ^ i))) v[msk].push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 2});\n                    else v[msk].push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 1});\n                }\n        }\nfor (int i=0; i<(1 << 16); i++)\n    d[i] = -1;\nPQ.push ({0, msk}), d[msk] = 0;\nwhile (!PQ.empty ())\n{\n    auto curr = PQ.top ();\n    PQ.pop ();\n    if (d[curr.second] != -curr.first) continue;\n    int nod = curr.second;\n    for (auto it : v[nod])\n        if (d[it.first] == -1 || (d[it.first] > d[nod] + it.second))\n            d[it.first] = d[nod] + it.second, PQ.push ({-d[it.first], it.first}), frm[it.first] = nod;\n}\nprintf (\"%d\\n\", ans + d[0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdio>\n\n/*\nhttps://atcoder.jp/contests/abc153/submissions/9767872\n*/\nconst int cm = 1 << 17;\nchar cn[cm], *ci = cn + cm, ct;\ninline char getcha() {\n  if (ci - cn == cm) {\n    fread_unlocked(cn, 1, cm, stdin);\n    ci = cn;\n  }\n  return *ci++;\n}\ninline int getint() {\n  int A = 0;\n  if (ci - cn + 16 > cm)\n    while ((ct = getcha()) >= '0')\n      A = A * 10 + ct - '0';\n  else\n    while ((ct = *ci++) >= '0')\n      A = A * 10 + ct - '0';\n  return A;\n}\n/*\nhttps://atcoder.jp/contests/abc153/submissions/9767872\n*/\n\ninline constexpr bool test(const int x, const int y) noexcept {\n  return x & 1 << y;\n}\n\nint main() {\n  const int n = getint();\n  std::array<int, 100000> v = {};\n  for (int i = 0; i != n - 1; i += 1) {\n    const int x = getint();\n    const int y = getint();\n    const int a = getint();\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n  int ans = n;\n  int b = 0;\n  for (int i = 0; i != n; i += 1) {\n    const int e = v[i];\n    if (e == 0) {\n      ans -= 1;\n    } else {\n      if (test(b, e))\n        ans -= 1;\n      b ^= 1 << e;\n    }\n  }\n\n  std::array<int, 65536> dp = {};\n  dp[b] = 1;\n  for (int s = b; s != 0; s -= 2) {\n    if (dp[s] == 0)\n      continue;\n    int i = 16;\n    while (i != 0) {\n      i -= 1;\n      if (test(s, i))\n        break;\n    }\n    for (int j = 0; j != i; j += 1) {\n      if (!test(s, j))\n        continue;\n      const int k = i ^ j;\n      if (k > j)\n        continue;\n      int &d = dp[s ^ 1 << i ^ 1 << j ^ 1 << k];\n      if (test(s, k))\n        d = std::max(d, dp[s] + 1);\n      else\n        d = std::max(d, dp[s]);\n    }\n  }\n  printf(\"%d\", ans - dp[0] + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define F(i,j,k) for(int i=(j);i<=(k);i++)\n#define DF(i,j,k) for(int i=(j);i>=(k);i--)\nusing namespace std;\ntemplate<typename T>inline void read(T &n){\n    T w=1;n=0;char ch=getchar();\n    while(!isdigit(ch)&&ch!=EOF){if(ch=='-')w=-1;ch=getchar();}\n    while(isdigit(ch)&&ch!=EOF){n=(n<<1)+(n<<3)+(ch^48);ch=getchar();}\n    n*=w;\n}\ntemplate<typename T>inline void write(T x){\n    ull y=0;\n    T l=0;\n    if(x<0){x=-x;putchar('-');}\n    if(!x){putchar(48);return;}\n    while(x){y=y*10+x%10;x/=10;l++;}\n    while(l){putchar(y%10+48);y/=10;l--;}\n}\ntemplate<typename T>inline void writeln(T x){\n    write(x);\n    puts(\"\");\n}\ntemplate<typename T>inline void writes(T x){\n    write(x);\n    putchar(' ');\n}\ntemplate<typename T>inline void checkmax(T &a,T b){a=a>b?a:b;}\ntemplate<typename T>inline void checkmin(T &a,T b){a=a<b?a:b;}\nint w[101000],h[22],dp[(1<<15)+1],s[(1<<15)+1],ans,st;\nint main(){\n \tint n;read(n);\n \tF(i,1,n-1){int x,y,a;read(x);read(y);read(a);w[x]^=a;w[y]^=a;}\n \tF(i,0,n-1)h[w[i]]++;\n \tF(i,1,15){ans+=h[i]/2;h[i]%=2;st^=(1<<(i-1))*h[i];}\n \tF(i,1,(1<<15))dp[i]=dp[i>>1]+(i&1);\n \tF(i,1,(1<<15))dp[i]--;\n \tF(i,1,(1<<15))\n \t\tF(j,0,14)\n \t\t\tif(i&(1<<j))s[i]^=j;\n \tF(i,1,(1<<15)){\n \t\tif(s[i])continue;\n \t\tfor(int k=(i-1)&i;k;k=(k-1)&i){if(!s[k])checkmin(dp[i],dp[k]+dp[i^k]);}\n \t}\n \twriteln(ans+dp[st]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,X[100100],C[1<<16],D[1<<16];\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y,c; scanf (\"%d %d %d\",&x,&y,&c);\n\t\tX[x] ^= c;\n\t\tX[y] ^= c;\n\t}\n\n\tfor (int i=0;i<N;i++) C[1<<X[i]]++;\n\tC[1] = 0;\n\n\tint ans = 0, emp = 1;\n\tfor (int i=1;i<16;i++){\n\t\tint &c = C[1<<i];\n\t\tans += c / 2 + c % 2;\n\t\tif (c % 2) emp = 0;\n\t\tc = c % 2 * i;\n\t}\n\tif (emp){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tint x = i & (-i);\n\t\tC[i] = C[i-x] ^ C[x];\n\n\t\tD[i] = -99999;\n\t\tif (C[i] == 0){\n\t\t\tD[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int j=i;j;j=(j-1)&i) if (C[j] == 0){\n\t\t\tif (D[i] < D[i-j] + 1)\n\t\t\t\tD[i] = D[i-j] + 1;\n\t\t}\n\t}\n\tans -= D[(1<<16)-1];\n\n\tprintf (\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<15+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[20], f[MaxM];\nbool xr[MaxM];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[x]^=z, v[y]^=z;\n\tfor (int i=0; i<n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=0; i< 15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=(i+1);\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<15;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[16], f[MaxM+10];\nbool xr[MaxM+10];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), ++x, ++y, v[x]^=z, v[y]^=z;\n\tfor (int i=1; i<=n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=0; i< 15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=(i+1);\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T> inline int chkmin(T &x, T y) { return x > y ? x = y, 1 : 0; }\n\nconst int MAXN = 1e5 + 1;\nconst int MAX = 16;\nconst int MX = 1 << MAX;\n\nint n, mask, val[MAXN], cnt[MAX];\nint ans = 0, rem, dp[MX], status[MX];\n\nint main() {\n    mask = (1 << 15) - 1;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        val[u] ^= w, val[v] ^= w;\n    }\n\n    for (int i = 0; i < n; ++i) ++cnt[val[i]];\n    for (int i = 1; i <= 15; ++i) ans += cnt[i] >> 1, rem |= (cnt[i] & 1) << i - 1;\n\n    // rem å³è¿å©ä¸å¤å°ç§æ°æ²¡æè¢«æ¶æ\n    // æ¥ä¸æ¥åç°å¯¹äºä¸ä¸ªéåï¼å¦æè¦ä»¤è¿ä¸ªéåå¨ä¸º 0ï¼é£ä¹å°±æå³çè¿ä¸ªéåéçæ°ååå¼æåä¸º 0ï¼æä½ä¸æ¹åéåçå¼æåï¼\n\n    for (int i = 1; i <= mask; ++i) dp[i] = __builtin_popcount(i) - 1;\n    for (int i = 1; i <= mask; ++i)\n        for (int j = 1; j <= 15; ++j)\n            if (i >> j - 1 & 1)\n                status[i] ^= j;\n    \n    for (int i = 1; i <= mask; ++i)\n        if (!status[i])\n            for (int j = i - 1; j; j = j - 1 & i)\n                if (!status[j])\n                    chkmin(dp[i], dp[j] + dp[i ^ j]);\n    \n    printf(\"%d\\n\", ans + dp[rem]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstd::vector<int> num;\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (; x; x /= 10) {\n\t\t\tnum.push_back(x % 10);\n\t\t}\n\t\twhile (!num.empty()) {\n\t\t\tputchar(num.back() ^ '0');\n\t\t\tnum.pop_back();\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 100005, INF = 0x3f3f3f3f;\n\nint n, a[N], cnt[15], xs[1 << 15], bitcnt[1 << 15], f[1 << 15];\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w);\n\t\ta[u] ^= w, a[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i]) {\n\t\t\t++cnt[a[i] - 1];\n\t\t}\n\t}\n\tint ans = 0, mask = 0;\n\tfor (int i = 0; i < 15; ++i) {\n\t\tans += cnt[i] >> 1;\n\t\tmask |= (cnt[i] & 1) << i;\n\t}\n\tfor (int S = 0; S < (1 << 15); ++S) {\n\t\txs[S] = bitcnt[S] = 0;\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tif (S >> i & 1) {\n\t\t\t\txs[S] ^= i + 1;\n\t\t\t\t++bitcnt[S];\n\t\t\t}\n\t\t}\n\t}\n\tf[0] = 0;\n\tfor (int S = 1; S < (1 << 15); ++S) {\n\t\tf[S] = INF;\n\t\tfor (int T = S; T; T = (T - 1) & S) {\n\t\t\tif (xs[T] == 0) {\n\t\t\t\tf[S] = std::min(f[S], f[S ^ T] + bitcnt[T] - 1);\n\t\t\t}\n\t\t}\n\t}\n\tprint(f[mask] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+1;\n\nint val[N];\nint n;\n\ninline int read(){\n   int out = 0;char ch;\n   for(ch = getchar();ch > '9' || ch < '0';ch = getchar());\n   for(;ch >= '0' && ch <= '9';ch = getchar())\n      out = (out<<3)+(out<<1)+(ch&15);\n   return out;\n}\nstruct edge{\n   int tail[N],to[N],nxt[N],tot;\n   inline void add_edge(int x,int y){\n      to[++tot] = y; nxt[tot] = tail[x]; tail[x] = tot;\n   }\n}e;\n\nint v[16],f[1<<17];\nint deg[N];\nint main(){\n   n = read();\n   for(int i = 1;i < n; ++i){\n      int u,v,w;\n      u = read(); v = read(); w = read();deg[u] ^= w; deg[v] ^= w;\n   }\n   for(int i = 0;i < n; ++i)v[deg[i]] += 1;\n   int ans = 0;\n   int ps = 0;\n   for(int i = 0;i < 16; ++i){\n      if(i)ans += v[i]/2; v[i] %= 2;\n      if(i)ps |= (1<<(i-1))*v[i];\n      //cerr << i <<' ' << v[i] << ' ' << deg[i] << endl;\n   }\n   //cerr << ps <<' ' << ans << endl;\n   memset(f,0x3f,sizeof f);\n   f[ps] = 0;\n\n   for(int i = (1<<16)-1;i > 0; --i){\n      if(f[i] == 0x3f3f3f3f)continue ;\n      for(int j = 0;j < 15; ++j)\n         for(int k = j+1;k < 15; ++k){\n            if(((1 << j) & i) && ((1<<k)&i)){\n               int pi = (i ^ (1<<(j))); pi ^= (1<<(k));\n               int w = ((j+1)^(k+1));\n               if(pi & (1<<(w-1)))f[pi^(1<<(w-1))] = min(f[pi^(1<<(w-1))],f[i]+2);\n               else f[pi^(1<<(w-1))] = min(f[pi^(1<<(w-1))],f[i]+1);\n            }\n         }\n   }\n   printf(\"%d\\n\",f[0]+ans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "ELF\u0002\u0001\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½>ï¿½\u0001ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½8ï¿½\tï¿½@ï¿½\u001eï¿½\u001dï¿½\u0006ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½8\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½\u0018\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0018=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018= ï¿½ï¿½ï¿½ï¿½ï¿½\u0018= ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½T\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½T\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½T\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½td\u0004ï¿½ï¿½ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½L\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½L\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Qï¿½td\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½td\u0004ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/lib64/ld-linux-x86-64.so.2ï¿½\u0004ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½GNUï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½GNUï¿½\\ï¿½ï¿½\u0012ï¿½vï¿½ï¿½\u001eï¿½%\u0015E?ï¿½iï¿½ï¿½0ï¿½\u0002ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0002\u0001ï¿½\u0004ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½\fCsï¿½\u0007\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Y\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001f\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001fï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½O\u0001ï¿½ï¿½\u0011ï¿½\u0019ï¿½ @ ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0016\u0001ï¿½ï¿½\u0011ï¿½\u0019ï¿½@A ï¿½ï¿½ï¿½ï¿½ï¿½\u0018\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½libstdc++.so.6ï¿½__gmon_start__ï¿½_ITM_deregisterTMCloneTableï¿½_ITM_registerTMCloneTableï¿½_ZNSt8ios_base4InitD1Evï¿½__gxx_personality_v0ï¿½_ZdlPvï¿½__cxa_begin_catchï¿½_ZSt20__throw_length_errorPKcï¿½_ZNSirsERiï¿½_ZNSirsERxï¿½__cxa_end_catchï¿½_ZSt17__throw_bad_allocvï¿½_ZNSt8ios_base4InitC1Evï¿½_Znwmï¿½_ZSt3cinï¿½__cxa_rethrowï¿½_ZNSt8ios_base15sync_with_stdioEbï¿½_ZSt4coutï¿½_ZNSt9basic_iosIcSt11char_traitsIcEE3tieEPSoï¿½_ZNSolsEiï¿½_ZNSolsExï¿½libgcc_s.so.1ï¿½_Unwind_Resumeï¿½libc.so.6ï¿½__stack_chk_failï¿½__cxa_atexitï¿½__cxa_finalizeï¿½memmoveï¿½__libc_start_mainï¿½GCC_3.0ï¿½GLIBC_2.4ï¿½GLIBC_2.2.5ï¿½CXXABI_1.3ï¿½GLIBCXX_3.4ï¿½ï¿½ï¿½ï¿½\u0002ï¿½\u0003ï¿½\u0002ï¿½\u0004ï¿½\u0002ï¿½\u0002ï¿½\u0002ï¿½\u0002ï¿½\u0004ï¿½\u0002ï¿½\u0002ï¿½\u0005ï¿½\u0002ï¿½\u0003ï¿½\u0002ï¿½\u0004ï¿½\u0003ï¿½\u0003ï¿½\u0002ï¿½ï¿½ï¿½\u0006ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½\u0002ï¿½\u0002ï¿½ï¿½ï¿½\u0001ï¿½\u0001ï¿½ï¿½\u0001ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½P&y\u000bï¿½ï¿½\u0006ï¿½\b\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0002ï¿½ï¿½\u0001ï¿½ï¿½\u0010ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½\u0014ii\nï¿½ï¿½\u0005ï¿½\u0010\u0002ï¿½ï¿½\u0010ï¿½ï¿½ï¿½u\u001ai\tï¿½ï¿½\u0004ï¿½\u001a\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0002ï¿½\u0001ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ó¯k\u0005ï¿½ï¿½\u0003ï¿½&\u0002ï¿½ï¿½\u0010ï¿½ï¿½ï¿½t)ï¿½\bï¿½ï¿½\u0002ï¿½1\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\b= ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010= ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\b@ ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\b@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010@ ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ @ ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@A ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½P? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½h? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½x? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0011ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0013ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½? ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0015ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½\bHï¿½\u0005ï¿½4 ï¿½Hï¿½ï¿½t\u0002ï¿½ï¿½Hï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½3 ï¿½ï¿½%ï¿½3 ï¿½\u000f\u001f@ï¿½ï¿½%ï¿½3 ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\u0007ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\bï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½%ï¿½3 ï¿½h\tï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½ï¿½%z3 ï¿½h\nï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½%r3 ï¿½h\u000bï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½%j3 ï¿½h\fï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½%b3 ï¿½h\nï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½%Z3 ï¿½h\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%R3 ï¿½h\u000fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%J3 ï¿½h\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%B3 ï¿½h\u0011ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½%:3 ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½Iï¿½ï¿½^Hï¿½ï¿½Hï¿½ï¿½ï¿½PTLï¿½\u0005ï¿½\u0017ï¿½ï¿½Hï¿½\nc\u0017ï¿½ï¿½Hï¿½=\u000f\u0006ï¿½ï¿½ï¿½\u0015\u00163 ï¿½ï¿½\u000f\u001fDï¿½ï¿½Hï¿½=A3 ï¿½UHï¿½\u000593 ï¿½H9ï¿½Hï¿½ï¿½t\u0019Hï¿½\u0005ï¿½2 ï¿½Hï¿½ï¿½t\n]ï¿½ï¿½f.\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½\u000f\u001f@ï¿½f.\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½=\u00013 ï¿½Hï¿½5ï¿½2 ï¿½UH)ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0003Hï¿½ï¿½Hï¿½ï¿½?H\u0001ï¿½Hï¿½ï¿½t\u0018Hï¿½\u0005ï¿½2 ï¿½Hï¿½ï¿½t\f]ï¿½ï¿½f\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½\u000f\u001f@ï¿½f.\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½4 ï¿½ï¿½u/Hï¿½=_2 ï¿½ï¿½UHï¿½ï¿½t\fHï¿½=ï¿½2 ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0005ï¿½4 ï¿½\u0001]ï¿½\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½f\u000f\u001fDï¿½ï¿½UHï¿½ï¿½]ï¿½fï¿½ï¿½ï¿½UHï¿½ï¿½}ï¿½uï¿½Uï¿½}ï¿½ï¿½u\nï¿½\u0001ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½;Eï¿½Oï¿½Eï¿½Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u00054 ï¿½Hï¿½\u0004\u0002ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005d4 ï¿½Hï¿½\u0014\u0002ï¿½Eï¿½Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005E4 ï¿½Hï¿½\u0014\u0001ï¿½Eï¿½\u0001ë©}ï¿½ï¿½u\u001fHï¿½\u0005.Üï¿½Hï¿½ï¿½\u0001Hï¿½\u0005#4 ï¿½Hï¿½\u0005 4 ï¿½\u0001ï¿½ï¿½ï¿½ï¿½9ï¿½Eï¿½;Eï¿½u\u0014Hï¿½\u0005\u0007Üï¿½Hï¿½ï¿½\u0001Hï¿½\u0005ï¿½3 ï¿½ï¿½\u001dHï¿½\u0005ï¿½Ûï¿½Hï¿½ï¿½\u0002Hï¿½\u0005ï¿½3 ï¿½Hï¿½\u0005ï¿½3 ï¿½\u0001ï¿½ï¿½ï¿½ï¿½Eï¿½\u0001ï¿½ï¿½ï¿½ï¿½Eï¿½;Eï¿½\u000fï¿½2\u0001ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½\u0001Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005ï¿½3 ï¿½Hï¿½\u0014\u0002ï¿½Eï¿½Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005ï¿½3 ï¿½Hï¿½\u0014\u0001Hï¿½\u0005ï¿½Ûï¿½Hï¿½Hï¿½ï¿½Eï¿½ï¿½ï¿½\u0001Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005ï¿½3 ï¿½Hï¿½\u0004\u0002H\u000fï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?Hï¿½ï¿½H)ï¿½Hiï¿½\u0001ï¿½ï¿½;Hï¿½ï¿½H)ï¿½Hï¿½\u0005;Ûï¿½Hï¿½Hï¿½ï¿½Eï¿½ï¿½ï¿½\u0001Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005!3 ï¿½Hï¿½\u0004\u0002H\u000fï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½Hï¿½\f\u0006Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ÈUï¿½Hcï¿½Hï¿½ï¿½Hï¿½ï¿½\u0005Hï¿½\u0015ï¿½2 ï¿½Hï¿½\u0004\u0011ï¿½Eï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½uhï¿½Eï¿½ï¿½\u0001Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005|2 ï¿½Hï¿½\u0014\u0002ï¿½Eï¿½ï¿½\u0001Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005j2 ï¿½Hï¿½\u0004\u0001Hï¿½\f\u0002Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½ï¿½\u001aï¿½Eï¿½ï¿½\u0001Hï¿½Hï¿½ï¿½\u0005Hï¿½ï¿½Hï¿½\u0005\u00142 ï¿½Hï¿½\u0004\u0002]ï¿½UHï¿½ï¿½SHï¿½ï¿½(Hï¿½}ï¿½Hï¿½Eï¿½\u0001ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½a\u0006ï¿½ï¿½ï¿½ï¿½t\nï¿½\u0001ï¿½ï¿½ï¿½ï¿½K\u0002ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½Hcï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0006ï¿½ï¿½H9ï¿½\u000fï¿½ï¿½ï¿½ï¿½\u000fï¿½3\u0001ï¿½ï¿½ï¿½Eï¿½Hcï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½\u000fï¿½\u0005\u0001ï¿½ï¿½ï¿½}ï¿½ï¿½uuï¿½Eï¿½Hcï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½o\u0006ï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½+Uï¿½ï¿½Jï¿½ï¿½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H\u000fï¿½Eï¿½Hï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½Hcï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½\u0018ï¿½Eï¿½Hcï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½+Uï¿½ï¿½Jï¿½ï¿½ÚÆï¿½ï¿½\u0019ï¿½ï¿½ï¿½H\u000fï¿½Eï¿½Hï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Eï¿½Eï¿½ï¿½Eï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½ugHï¿½Eï¿½Hï¿½ï¿½ï¿½D\u0005ï¿½ï¿½+Eï¿½ï¿½Hï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½ï¿½ï¿½ï¿½H\u000fï¿½Eï¿½Hï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½ï¿½yï¿½Eï¿½Hcï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\u0018Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½+Eï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Þï¿½ï¿½$ï¿½ï¿½ï¿½H\u000fï¿½Eï¿½Hï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½([]ï¿½UHï¿½ï¿½SHï¿½ï¿½8dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½=O. ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½=\u0016- ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½=\u001b. ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½5/×ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½9Eï¿½}PHï¿½Eï¿½Hï¿½ï¿½Hï¿½=ï¿½- ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½EÔï¿½ï¿½\u001f\u0001Ðï¿½\u0001)ï¿½Hcï¿½Hï¿½ï¿½H\u0001ï¿½H\u0001ï¿½Hï¿½ï¿½\u0003Hï¿½\u0015ï¿½×ï¿½H\u0001ï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½Eï¿½\u0001ï¿½ï¿½Eï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½\u0001\u000fï¿½\u0002\u0001ï¿½ï¿½ï¿½Eï¿½\u0001ï¿½ï¿½ï¿½ï¿½Eï¿½HcØEï¿½Hcï¿½Hï¿½ï¿½H\u0001ï¿½H\u0001ï¿½Hï¿½ï¿½\u0003Hï¿½\u0015ï¿½Öï¿½H\u0001ï¿½Hï¿½ï¿½ï¿½Y\u0003ï¿½ï¿½H9ï¿½\u000fï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½HcÈEï¿½Hcï¿½Hï¿½ï¿½H\u0001ï¿½H\u0001ï¿½Hï¿½ï¿½\u0003Hï¿½\u0015sÖï¿½H\u0001ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½C\u0003ï¿½ï¿½ï¿½\u0018ï¿½EÜï¿½\u0001HcÈEï¿½Hcï¿½Hï¿½ï¿½H\u0001ï¿½H\u0001ï¿½Hï¿½ï¿½\u0003Hï¿½\u0015@Öï¿½H\u0001ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0010\u0003ï¿½ï¿½ï¿½ï¿½9ï¿½u<ï¿½Eï¿½HcÈEï¿½Hcï¿½Hï¿½ï¿½H\u0001ï¿½H\u0001ï¿½Hï¿½ï¿½\u0003Hï¿½\u0015\fÖï¿½H\u0001ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0007ï¿½\u0001ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0004ï¿½Eï¿½\u0001ï¿½Eï¿½\u0001ï¿½\u000eï¿½ï¿½ï¿½ï¿½Eï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½t\u0018ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½=_+ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½tHï¿½=ï¿½Õï¿½ï¿½yï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½=ï¿½Õï¿½ï¿½jï¿½ï¿½ï¿½H\u000fï¿½ï¿½Hï¿½ï¿½Hï¿½1ï¿½w\u001d\u0002ï¿½&\u0002Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0017Hï¿½ï¿½Hï¿½ï¿½?H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hiï¿½\u0001ï¿½ï¿½;H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½=ï¿½* ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½]ï¿½dH3\u001c%(ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½8[]ï¿½UHï¿½ï¿½SHï¿½ï¿½\u0018Hï¿½}ï¿½Hï¿½\u001dpÕï¿½Hï¿½\u0005\tÕï¿½H9ï¿½t\u000eHï¿½ï¿½\u0018Hï¿½ï¿½ï¿½\b\u0001ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½\u0018[]ï¿½UHï¿½ï¿½ATSHï¿½ï¿½\u0010ï¿½}ï¿½uï¿½}ï¿½\u0001upï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ugHï¿½=(Õï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½\u0015D* ï¿½Hï¿½5\u0015Õï¿½Hï¿½\u0005&* ï¿½Hï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½Hï¿½\u0005ï¿½Ôï¿½ï¿½\u0003ï¿½ï¿½ï¿½Iï¿½ï¿½Hï¿½ï¿½x\u0012Lï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½Iï¿½ï¿½\u0018Hï¿½ï¿½\u0001ï¿½ï¿½Hï¿½\u0015\u0001* ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½=Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½\u0010[A\\]ï¿½UHï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½\\ï¿½ï¿½ï¿½]ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½\u0010Hï¿½Eï¿½Hï¿½ï¿½H9ï¿½s\u0006Hï¿½Eï¿½ï¿½\u0004Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½H\bHï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½a\u0001ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½0Hï¿½}ï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0013\u0002ï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0001ï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½@\u0002ï¿½ï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½@\bHï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½H)ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0002]ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½Uï¿½Hï¿½ï¿½\u0002H\u0001ï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½P\bHï¿½Eï¿½Hï¿½@\u0010H9ï¿½t1Hï¿½Eï¿½Hï¿½H\bHï¿½Eï¿½Hï¿½Uï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½Hï¿½Eï¿½Hï¿½@\bHï¿½P\u0004Hï¿½Eï¿½Hï¿½P\bï¿½\"Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0006\u0002ï¿½ï¿½Hï¿½ï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½<\u0002ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½@\u0010Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½H)ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0002Hï¿½ï¿½Hï¿½Eï¿½Hï¿½\bHï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½0Hï¿½}ï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½q\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½0Hï¿½}ï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Eï¿½Hï¿½@\bHï¿½Eï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u001c\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½SHï¿½ï¿½\u0018Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0003\u0004ï¿½ï¿½Hï¿½\u0018Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½Hï¿½ï¿½H9ï¿½\u000fï¿½ï¿½Hï¿½ï¿½\u0018[]ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Eï¿½Hï¿½P\bHï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0003ï¿½ï¿½Hï¿½Eï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½ATSHï¿½ï¿½PHï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Eï¿½Hï¿½\u0015ï¿½\nï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½\u0003ï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½^\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½\f\u0002Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½Hï¿½0Hï¿½Eï¿½Hï¿½ï¿½Hï¿½Uï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½\u0004Hï¿½Eï¿½Hï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½Iï¿½ï¿½Hï¿½Eï¿½Hï¿½X\bHï¿½Eï¿½Hï¿½ï¿½ï¿½G\u0004ï¿½ï¿½Hï¿½ï¿½Hï¿½Uï¿½Lï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½@\u0004ï¿½ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½H\bHï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½R\u0010Hï¿½ï¿½Hï¿½Uï¿½Hï¿½\u0012H)ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0002Hï¿½ï¿½Hï¿½Uï¿½Hï¿½\nHï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½7\u0001ï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½\u0010Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½P\bHï¿½Eï¿½Hï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½H\u0001ï¿½Hï¿½Eï¿½Hï¿½P\u0010ï¿½Hï¿½Eï¿½dH3\u0004%(ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½\\ï¿½ï¿½ï¿½Hï¿½}ï¿½ï¿½u$Hï¿½Eï¿½Hï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½H\u0001ï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½\"Hï¿½Eï¿½Hï¿½ï¿½ï¿½'ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u001fï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½Hï¿½ï¿½P[A\\]ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½`\u0003ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½@\bï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½@\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½>\u0003ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½}ï¿½ï¿½t\u0017Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0013\u0003ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u001b\u0003ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½\u0010Hï¿½Eï¿½Hï¿½\u0010ï¿½]ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½SHï¿½ï¿½(Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018Hï¿½Eï¿½Hï¿½Æ¿\u0004ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½Hï¿½ï¿½t\u0002ï¿½\u0018ï¿½Hï¿½ï¿½([]ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½\u0010Hï¿½Eï¿½Hï¿½\u0010ï¿½]ÃUHï¿½ï¿½SHï¿½ï¿½HHï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½h\u0002ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½H)ï¿½Hï¿½ï¿½Hï¿½Eï¿½H9ï¿½\u000fï¿½ï¿½ï¿½ï¿½t\fHï¿½Eï¿½Hï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½H\u0001ï¿½Hï¿½Eï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H9Eï¿½r\u0012Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½H9Eï¿½v\u000eHï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0004Hï¿½Eï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½9ï¿½ï¿½ï¿½Hï¿½ï¿½H[]ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½SHï¿½ï¿½\u0018Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½Iï¿½ï¿½ï¿½Hï¿½ï¿½H)ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0002Hï¿½ï¿½\u0018[]ÃUHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½uï¿½Hï¿½}ï¿½ï¿½t\u0015Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0018\u0001ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½SHï¿½ï¿½(Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u0005\u0001ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½%\u0001ï¿½ï¿½Hï¿½ï¿½([]ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½-\u0001ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\"\u0001ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½}ï¿½ï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\b\u0001ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Mï¿½Hï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½dHï¿½\u0004%(ï¿½ï¿½ï¿½Hï¿½Eï¿½1ï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½Mï¿½dH3\f%(ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½]ÃUHï¿½ï¿½Hï¿½}ï¿½ï¿½]ÃUHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½nï¿½ï¿½ï¿½H9Eï¿½\u000fï¿½ï¿½ï¿½ï¿½t\u0005ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½\u0002Hï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Eï¿½Hï¿½Uï¿½Hï¿½\u0010ï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½0Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½ï¿½Eï¿½\u0001Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?]ï¿½UHï¿½ï¿½Hï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½SHï¿½ï¿½(Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Hï¿½ï¿½([]ï¿½UHï¿½ï¿½Hï¿½ï¿½\u0010Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½cï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½ATSHï¿½ï¿½ Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½Iï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½Hï¿½ï¿½Hï¿½Eï¿½Hï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½Lï¿½ï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½Hï¿½ï¿½ [A\\]ÃUHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½Hï¿½ï¿½]ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½}ï¿½Hï¿½Eï¿½]ï¿½UHï¿½ï¿½Hï¿½ï¿½0Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½ï¿½Eï¿½\u0001Hï¿½Uï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½UHï¿½ï¿½Hï¿½ï¿½0Hï¿½}ï¿½Hï¿½uï¿½Hï¿½Uï¿½Hï¿½Uï¿½Hï¿½Eï¿½H)ï¿½Hï¿½ï¿½Hï¿½ï¿½\u0002Hï¿½Eï¿½Hï¿½}ï¿½ï¿½t\u001fHï¿½Eï¿½Hï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Mï¿½Hï¿½Eï¿½Hï¿½ï¿½Hï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½Hï¿½Eï¿½Hï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½Eï¿½H\u0001ï¿½ï¿½ï¿½f.\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000f\u001fDï¿½ï¿½AWAVIï¿½ï¿½AUATLï¿½%ï¿½\u0018 ï¿½UHï¿½-ï¿½\u0018 ï¿½SAï¿½ï¿½Iï¿½ï¿½L)ï¿½Hï¿½ï¿½\bHï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½t 1ï¿½\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½Lï¿½ï¿½Dï¿½ï¿½Aï¿½\u0014ï¿½Hï¿½ï¿½\u0001H9ï¿½uï¿½Hï¿½ï¿½\b[]A\\A]A^A_Ãf.\u000f\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½\bHï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@\n\u0003ï¿½\u0001ï¿½ï¿½;vector::_M_realloc_insertï¿½ï¿½ï¿½\u0001\u001b\u0003;H\u0002ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½,ï¿½ï¿½ï¿½d\u0002ï¿½ï¿½6ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014\u0003ï¿½ï¿½_ï¿½ï¿½ï¿½8\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ \u000bï¿½ï¿½\u001dï¿½ï¿½ï¿½@\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½d\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\\\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$\u0004ï¿½ï¿½\nï¿½ï¿½ï¿½D\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½d\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½Fï¿½ï¿½ï¿½\b\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H\u0005ï¿½ï¿½*ï¿½ï¿½ï¿½h\u0005ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½:ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½xï¿½ï¿½ï¿½\u0010\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½P\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p\u0006ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½jï¿½ï¿½ï¿½\u0014\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½T\u0007ï¿½ï¿½*ï¿½ï¿½ï¿½t\u0007ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018\bï¿½ï¿½\u0007ï¿½ï¿½ï¿½8\bï¿½ï¿½\u0016ï¿½ï¿½ï¿½X\bï¿½ï¿½8ï¿½ï¿½ï¿½x\bï¿½ï¿½bï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018\tï¿½ï¿½\u001bï¿½ï¿½ï¿½8\tï¿½ï¿½6ï¿½ï¿½ï¿½X\tï¿½ï¿½Dï¿½ï¿½ï¿½x\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½\u0013ï¿½ï¿½ï¿½\u0018\nï¿½ï¿½_ï¿½ï¿½ï¿½<\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\\\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001zRï¿½\u0001x\u0010\u0001\u001b\f\u0007\bï¿½\u0001\u0007\u0010\u0014ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001zRï¿½\u0001x\u0010\u0001\u001b\f\u0007\bï¿½\u0001ï¿½ï¿½$ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½0\u0001ï¿½ï¿½ï¿½\u000e\u0010F\u000e\u0018J\u000f\u000bw\bï¿½ï¿½?\u001a;*3$\"ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½\\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006M\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½:ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0003ï¿½\u0002\f\u0007\bï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003\u0003w\u0002\f\u0007\bï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001fï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003\u0003\u0002\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006f\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001zPLRï¿½\u0001x\u0010\u0007ï¿½\n\u0017 ï¿½\u001b\u001b\f\u0007\bï¿½\u0001ï¿½ï¿½ ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½\\ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½\u00047\bï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006V\f\u0007\bï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½\u0004\u0017\bï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½l\u0001ï¿½ï¿½tï¿½ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002_\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006a\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006[\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002v\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u001aï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006V\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½\f\u0002ï¿½ï¿½\u0016ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006V\f\u0007\bï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½,\u0001ï¿½ï¿½\u0012ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½\u00047\u0007ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002K\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½P\u0002ï¿½ï¿½>ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½p\u0002ï¿½ï¿½,ï¿½ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006e\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½6ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002N\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½jï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002O\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003r\f\u0007\b\u001cï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½\u0010\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006t\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½0\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002G\f\u0007\bï¿½ï¿½$ï¿½ï¿½ï¿½P\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|\u0002ï¿½ï¿½\u0004\u0017\u0006ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Gï¿½\u0003ï¿½\u0004\u0003p\u0002\f\u0007\b\u001cï¿½ï¿½ï¿½x\u0003ï¿½ï¿½Bï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006y\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½`ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006V\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½\\ï¿½ï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006p\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½qï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006a\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½xï¿½ï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006X\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½\u0018\u0004ï¿½ï¿½vï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½8\u0004ï¿½ï¿½dï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003y\f\u0007\b\u001cï¿½ï¿½ï¿½X\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006X\f\u0007\bï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½x\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003\u0002ï¿½\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½Nï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002C\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003y\f\u0007\b\u001cï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006n\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½\u001c\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003\u0002J\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½@\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006a\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½`\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006V\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006F\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006i\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006J\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006]\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006e\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ \u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002C\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½@\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006l\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½`\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006J\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006F\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006^\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006U\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006}\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ \u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006U\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½@\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006l\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½`\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006O\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006h\f\u0007\bï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003\u0002B\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½\u001bï¿½ï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006]\f\u0007\bï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½\u001dï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Gï¿½\u0003ï¿½\u0004\u0002L\f\u0007\bï¿½\u001cï¿½ï¿½ï¿½\b\bï¿½ï¿½Rï¿½ï¿½ï¿½\u0011ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006L\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½(\bï¿½ï¿½Cï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½H\bï¿½ï¿½1ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006I\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½h\bï¿½ï¿½\u001fï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006l\f\u0007\bï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½0ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006\u0002`\f\u0007\bï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Eï¿½\u0003k\f\u0007\b ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006Gï¿½\u0003ï¿½\u0004\u0002ï¿½\f\u0007\bï¿½\u001cï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½Bï¿½ï¿½ï¿½\u0015ï¿½ï¿½ï¿½ï¿½A\u000e\u0010ï¿½\u0002C\n\u0006P\f\u0007\bï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½\f\tï¿½ï¿½ ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½B\u000e\u0010ï¿½\u0002B\u000e\u0018ï¿½\u0003E\u000e ï¿½\u0004B\u000e(ï¿½\u0005H\u000e0ï¿½\u0006H\u000e8ï¿½\u0007M\u000e@r\u000e8A\u000e0A\u000e(B\u000e B\u000e\u0018B\u000e\u0010B\u000e\bï¿½\u0010ï¿½ï¿½ï¿½T\tï¿½ï¿½Hï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½%\u0001\u001a9Cï¿½ï¿½ï¿½\u0001Fï¿½\u0003\u0001ï¿½\u0002=ï¿½ï¿½ï¿½\u0004Eï¿½\u0004ï¿½ï¿½\u0004\u0005ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010= ï¿½ï¿½ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(? ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½v\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0016\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½6\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½F\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½V\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½f\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½v\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\b@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0001ï¿½8\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0002ï¿½T\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0003ï¿½t\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0004ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0005ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0006ï¿½`\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0007ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\bï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\tï¿½X\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\nï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u000bï¿½@\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\fï¿½`\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\nï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u000eï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u000fï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0011ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0012ï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0013ï¿½X1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0014ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0015ï¿½\u0010= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0016ï¿½\u0018= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0017ï¿½(? ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0018ï¿½ï¿½@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u0019ï¿½ @ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½\u0002ï¿½\u000eï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½\u0002ï¿½\u000eï¿½\u0010\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½ï¿½\u0002ï¿½\u000eï¿½`\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½\u0001ï¿½\u0019ï¿½XB ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½\u0001ï¿½\u0015ï¿½\u0010= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½\u0002ï¿½\u000eï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½\u0001ï¿½\u0014ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½I\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½h\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000f\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½R\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½z\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0003ï¿½ï¿½\u0001ï¿½\u0010ï¿½ï¿½%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001c\u0004ï¿½ï¿½\u0001ï¿½\u0010ï¿½\u0004%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½E\u0004ï¿½ï¿½\u0001ï¿½\u0010ï¿½\b%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½j\u0004ï¿½ï¿½\u0001ï¿½\u0010ï¿½\f%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½\u0001ï¿½\u0010ï¿½\u0010%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½\u0001ï¿½\u0010ï¿½\u0014%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½\u0001ï¿½\u0010ï¿½\u0018%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\n\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½\u001c%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½ %ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\\\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½$%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½(%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½,%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½0%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½\u0001ï¿½\u0010ï¿½4%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001d\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½8%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½C\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½<%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½m\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½@%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½D%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½H%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½P%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u0001ï¿½\u0010ï¿½T%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u0002ï¿½\u000eï¿½\\\u0015ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½\u0002ï¿½\u000eï¿½ï¿½\u0015ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*\u0007ï¿½ï¿½\u0002ï¿½\u000eï¿½\"\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<\u0007ï¿½ï¿½\u0001ï¿½\u0012ï¿½T1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½J\u0007ï¿½ï¿½ï¿½ï¿½\u0011ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]\u0007ï¿½ï¿½\u0001ï¿½\u0016ï¿½\u0018= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½f\u0007ï¿½ï¿½ï¿½ï¿½\u0014ï¿½\u0010= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w\u0007ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½\u0001ï¿½\u0017ï¿½(? ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½\"ï¿½\u000eï¿½j\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'\bï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½k\bï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½x\bï¿½ï¿½\"ï¿½\u000eï¿½B ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½\"ï¿½\u000eï¿½~\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-\tï¿½ï¿½\"ï¿½\u000eï¿½\u001e!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½x\tï¿½ï¿½\"ï¿½\u000eï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½\"ï¿½\u000eï¿½`!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½\"ï¿½\u000eï¿½{ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½\u0010ï¿½\u0018ï¿½\u0018@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\u0012ï¿½\u000eï¿½ï¿½\nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ ï¿½\u0018ï¿½ï¿½@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\u0011ï¿½\u0010ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\"ï¿½\u000eï¿½2\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½R\u000bï¿½ï¿½\"ï¿½\u000eï¿½&\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½\"ï¿½\u000eï¿½\u0016\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\n\fï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9\fï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½U\fï¿½ï¿½\"ï¿½\u000eï¿½^\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½n\fï¿½ï¿½\"ï¿½\u000eï¿½& ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{\fï¿½ï¿½\u0012ï¿½\u000eï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½\"ï¿½\u000eï¿½Z\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000f\nï¿½ï¿½\"ï¿½\u000eï¿½2\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/\nï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½F\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\nï¿½ï¿½\u0011\u0002\u0018ï¿½\b@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½\u0011ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½!\u0002\u0018ï¿½\u0010@ ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\nï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X\u0016ï¿½ï¿½\u0012ï¿½\u000fï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!\u000eï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<\u000eï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{\u000eï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½\"ï¿½\u000eï¿½\b\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002\u000fï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001b\u000fï¿½ï¿½\"ï¿½\u000eï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\u000fï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½\"ï¿½\u000eï¿½b\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\b\u0010ï¿½ï¿½\"ï¿½\u000eï¿½{#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½\u0012ï¿½\u000eï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3\u0010ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½F\u0010ï¿½ï¿½\"ï¿½\u000eï¿½d\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½\u0012ï¿½\u000bï¿½@\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½\"ï¿½\u000eï¿½& ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½\u0011\u0002\u0018ï¿½\u0018@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½\"ï¿½\u000eï¿½2\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000e\u0011ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&\u0011ï¿½ï¿½\"ï¿½\u000eï¿½N#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0011ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½G\u0011ï¿½ï¿½\u0011ï¿½\u0019ï¿½ @ ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^\u0011ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0011ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0011ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\t\u0012ï¿½ï¿½\"ï¿½\u000eï¿½d\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H\u0012ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0012ï¿½ï¿½\"ï¿½\u000eï¿½I\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½\u0010ï¿½\u0018ï¿½ï¿½@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\u0007ï¿½ï¿½\u0010ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½\"ï¿½\u000eï¿½=\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001\u0013ï¿½ï¿½\"ï¿½\u000eï¿½P!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1\u0013ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o\u0013ï¿½ï¿½\"ï¿½\u000eï¿½\u000e\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0013ï¿½ï¿½\"ï¿½\u000eï¿½F\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0013ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0013ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0013ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9\u0007ï¿½ï¿½\u0011ï¿½\u0019ï¿½`B ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½-\u0014ï¿½ï¿½\"ï¿½\u000eï¿½t\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½F\u0014ï¿½ï¿½\"ï¿½\u000eï¿½\u0016\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½f\u0014ï¿½ï¿½\u0010ï¿½\u0019ï¿½\u0018@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½r\u0014ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½\"ï¿½\u000eï¿½\u0014\"ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½\u0012ï¿½\u000eï¿½ $ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½\"ï¿½\u000eï¿½7\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0014ï¿½ï¿½\"ï¿½\u000eï¿½m#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\t\u0015ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001e\u0015ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:\u0015ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[\u0015ï¿½ï¿½\u0012ï¿½\u000eï¿½R\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½w\u0015ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u001dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015ï¿½ï¿½\"ï¿½\u000eï¿½t\u0016ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004\u0016ï¿½ï¿½\"ï¿½\u000eï¿½_#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ \u0016ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½N\u0016ï¿½ï¿½\u0012ï¿½\u000eï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^\u0016ï¿½ï¿½\u0011ï¿½\u0019ï¿½@A ï¿½ï¿½ï¿½ï¿½ï¿½\u0018\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0016ï¿½ï¿½\"ï¿½\u000eï¿½l!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5\u0001ï¿½ï¿½\u0011ï¿½\u0019ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0016ï¿½ï¿½\"ï¿½\u000eï¿½`!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0016ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0016ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0015\u0017ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$\u0017ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>\u0017ï¿½ï¿½\"ï¿½\u000eï¿½ï¿½\u0019ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0017ï¿½ï¿½\"ï¿½\u000eï¿½M ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0017ï¿½ï¿½\"ï¿½\u000eï¿½B ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0017ï¿½ï¿½\"ï¿½\u000eï¿½8\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0017ï¿½ï¿½\u0012ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½crtstuff.cï¿½deregister_tm_clonesï¿½__do_global_dtors_auxï¿½completed.7697ï¿½__do_global_dtors_aux_fini_array_entryï¿½frame_dummyï¿½__frame_dummy_init_array_entryï¿½sh.cppï¿½_ZStL19piecewise_constructï¿½_ZStL13allocator_argï¿½_ZStL6ignoreï¿½_ZStL8__ioinitï¿½_ZN9__gnu_cxxL21__default_lock_policyEï¿½_ZStL10defer_lockï¿½_ZStL11try_to_lockï¿½_ZStL10adopt_lockï¿½_ZNSt15regex_constantsL5icaseEï¿½_ZNSt15regex_constantsL6nosubsEï¿½_ZNSt15regex_constantsL8optimizeEï¿½_ZNSt15regex_constantsL7collateEï¿½_ZNSt15regex_constantsL10ECMAScriptEï¿½_ZNSt15regex_constantsL5basicEï¿½_ZNSt15regex_constantsL8extendedEï¿½_ZNSt15regex_constantsL3awkEï¿½_ZNSt15regex_constantsL4grepEï¿½_ZNSt15regex_constantsL5egrepEï¿½_ZNSt15regex_constantsL12__polynomialEï¿½_ZNSt15regex_constantsL13match_defaultEï¿½_ZNSt15regex_constantsL13match_not_bolEï¿½_ZNSt15regex_constantsL13match_not_eolEï¿½_ZNSt15regex_constantsL13match_not_bowEï¿½_ZNSt15regex_constantsL13match_not_eowEï¿½_ZNSt15regex_constantsL9match_anyEï¿½_ZNSt15regex_constantsL14match_not_nullEï¿½_ZNSt15regex_constantsL16match_continuousEï¿½_ZNSt15regex_constantsL16match_prev_availEï¿½_ZNSt15regex_constantsL14format_defaultEï¿½_ZNSt15regex_constantsL10format_sedEï¿½_ZNSt15regex_constantsL14format_no_copyEï¿½_ZNSt15regex_constantsL17format_first_onlyEï¿½_ZNSt15regex_constantsL13error_collateEï¿½_ZNSt15regex_constantsL11error_ctypeEï¿½_ZNSt15regex_constantsL12error_escapeEï¿½_ZNSt15regex_constantsL13error_backrefEï¿½_ZNSt15regex_constantsL11error_brackEï¿½_ZNSt15regex_constantsL11error_parenEï¿½_ZNSt15regex_constantsL11error_braceEï¿½_ZNSt15regex_constantsL14error_badbraceEï¿½_ZNSt15regex_constantsL11error_rangeEï¿½_ZNSt15regex_constantsL11error_spaceEï¿½_ZNSt15regex_constantsL15error_badrepeatEï¿½_ZNSt15regex_constantsL16error_complexityEï¿½_ZNSt15regex_constantsL11error_stackEï¿½_ZNSt8__detailL19_S_invalid_state_idEï¿½_ZL1Nï¿½_ZL3modï¿½__tcf_0ï¿½_Z41__static_initialization_and_destruction_0iiï¿½_GLOBAL__sub_I_dpï¿½__FRAME_END__ï¿½__GNU_EH_FRAME_HDRï¿½_DYNAMICï¿½__init_array_endï¿½__init_array_startï¿½_GLOBAL_OFFSET_TABLE_ï¿½_ZNSt12_Vector_baseIiSaIiEE12_Vector_implD2Evï¿½_ZNSt12_Vector_baseIiSaIiEE11_M_allocateEmï¿½_ZN9__gnu_cxx13new_allocatorIiE8allocateEmPKvï¿½_ZSt34__uninitialized_move_if_noexcept_aIPiS0_SaIiEET0_T_S3_S2_RT1_ï¿½_ZNSaIiED2Evï¿½_ZN9__gnu_cxx13new_allocatorIiED2Evï¿½_ZNSt12_Vector_baseIiSaIiEE12_Vector_implC2Evï¿½_ZNSt6vectorIiSaIiEE9push_backERKiï¿½_ZNSt16allocator_traitsISaIiEE9constructIiJRKiEEEvRS0_PT_DpOT0_ï¿½_ZSt22__uninitialized_copy_aISt13move_iteratorIPiES1_iET0_T_S4_S3_RSaIT1_Eï¿½_ZNSt16allocator_traitsISaIiEE7destroyIiEEvRS0_PT_ï¿½_ZN9__gnu_cxx13new_allocatorIiEC1Evï¿½_ZNSt12_Destroy_auxILb1EE9__destroyIPiEEvT_S3_ï¿½_edataï¿½_ZSt8_DestroyIPiiEvT_S1_RSaIT0_Eï¿½_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIiEEPT_PKS3_S6_S4_ï¿½_ZNSt6vectorIiSaIiEED1Evï¿½_Z6getAnsiiiï¿½_IO_stdin_usedï¿½_ZSt17__throw_bad_allocv@@GLIBCXX_3.4ï¿½_ZNSt13move_iteratorIPiEC2ES0_ï¿½_ZNSt6vectorIiSaIiEE17_M_realloc_insertIJRKiEEEvN9__gnu_cxx17__normal_iteratorIPiS1_EEDpOT_ï¿½_ZN9__gnu_cxxmiIPiSt6vectorIiSaIiEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_ï¿½__cxa_begin_catch@@CXXABI_1.3ï¿½_ZNSt12_Vector_baseIiSaIiEEC1Evï¿½_ZNSt6vectorIiSaIiEE5beginEvï¿½_ZNSt8ios_base15sync_with_stdioEb@@GLIBCXX_3.4ï¿½__cxa_finalize@@GLIBC_2.2.5ï¿½_ZNSt6vectorIiSaIiEEixEmï¿½_ZNSaIiEC2Evï¿½mainï¿½_ZNSt20__uninitialized_copyILb1EE13__uninit_copyISt13move_iteratorIPiES3_EET0_T_S6_S5_ï¿½_ZNSaIiED1Evï¿½_ZSt20__throw_length_errorPKc@@GLIBCXX_3.4ï¿½_ZNSt12_Vector_baseIiSaIiEED1Evï¿½_ZNSolsEx@@GLIBCXX_3.4ï¿½_ZNSt12_Vector_baseIiSaIiEE12_Vector_implC1Evï¿½__dso_handleï¿½_ZNSirsERi@@GLIBCXX_3.4ï¿½_ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEC2ERKS1_ï¿½DW.ref.__gxx_personality_v0ï¿½_ZNSt12_Vector_baseIiSaIiEE12_Vector_implD1Evï¿½_ZNSt6vectorIiSaIiEE3endEvï¿½_ZNK9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEE4baseEvï¿½_ZNSt9basic_iosIcSt11char_traitsIcEE3tieEPSo@@GLIBCXX_3.4ï¿½_ZNSt12_Vector_baseIiSaIiEE13_M_deallocateEPimï¿½_ZNKSt6vectorIiSaIiEE5emptyEvï¿½_ZNSt6vectorIiSaIiEED2Evï¿½_ZSt32__make_move_if_noexcept_iteratorIiSt13move_iteratorIPiEET0_PT_ï¿½_ZSt4copyISt13move_iteratorIPiES1_ET0_T_S4_S3_ï¿½__cxa_atexit@@GLIBC_2.2.5ï¿½_ZN9__gnu_cxxeqIPKiSt6vectorIiSaIiEEEEbRKNS_17__normal_iteratorIT_T0_EESB_ï¿½_ZdlPv@@GLIBCXX_3.4ï¿½_ZSt13__copy_move_aILb1EPiS0_ET1_T0_S2_S1_ï¿½_Znwm@@GLIBCXX_3.4ï¿½_ZN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEC2ERKS2_ï¿½__stack_chk_fail@@GLIBC_2.4ï¿½_ZNSaIiEC1Evï¿½__TMC_END__ï¿½_ZNSt12_Vector_baseIiSaIiEED2Evï¿½_ZNKSt12_Vector_baseIiSaIiEE19_M_get_Tp_allocatorEvï¿½_ZNSirsERx@@GLIBCXX_3.4ï¿½_ZNKSt13move_iteratorIPiE4baseEvï¿½_ZSt4cout@@GLIBCXX_3.4ï¿½_ZNKSt6vectorIiSaIiEE8max_sizeEvï¿½_ZN9__gnu_cxx13new_allocatorIiE9constructIiJRKiEEEvPT_DpOT0_ï¿½_ZSt12__miter_baseIPiEDTcl12__miter_basecldtfp_4baseEEESt13move_iteratorIT_Eï¿½_ZN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEC1ERKS2_ï¿½_ZSt14__copy_move_a2ILb1EPiS0_ET1_T0_S2_S1_ï¿½_ZSt3maxImERKT_S2_S2_ï¿½_ZNSt12_Vector_baseIiSaIiEE19_M_get_Tp_allocatorEvï¿½__data_startï¿½_ZNSt13move_iteratorIPiEC1ES0_ï¿½_ZSt8_DestroyIPiEvT_S1_ï¿½_ZN9__gnu_cxx13new_allocatorIiE7destroyIiEEvPT_ï¿½_ZNK9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEE4baseEvï¿½_ZNKSt6vectorIiSaIiEE3endEvï¿½_ZNK9__gnu_cxx13new_allocatorIiE8max_sizeEvï¿½_ZNKSt6vectorIiSaIiEE5beginEvï¿½__cxa_rethrow@@CXXABI_1.3ï¿½_ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEC1ERKS1_ï¿½_ZNSt6vectorIiSaIiEEC2Evï¿½_ZNSt12_Vector_baseIiSaIiEEC2Evï¿½__bss_startï¿½_ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4ï¿½_ZSt18uninitialized_copyISt13move_iteratorIPiES1_ET0_T_S4_S3_ï¿½__libc_csu_initï¿½_ZnwmPvï¿½_ZSt12__niter_baseIPiET_S1_ï¿½memmove@@GLIBC_2.2.5ï¿½__cxa_end_catch@@CXXABI_1.3ï¿½__gxx_personality_v0@@CXXABI_1.3ï¿½_Z6getRtrRSt6vectorIiSaIiEEï¿½_ZNKSt6vectorIiSaIiEE12_M_check_lenEmPKcï¿½_ZNSolsEi@@GLIBCXX_3.4ï¿½_ZNSt6vectorIiSaIiEEC1Evï¿½_ITM_deregisterTMCloneTableï¿½_Unwind_Resume@@GCC_3.0ï¿½_ZSt12__miter_baseIPiET_S1_ï¿½_ZNSt16allocator_traitsISaIiEE8allocateERS0_mï¿½__libc_csu_finiï¿½_ZSt3cin@@GLIBCXX_3.4ï¿½_ZN9__gnu_cxx13new_allocatorIiE10deallocateEPimï¿½_ZN9__gnu_cxx13new_allocatorIiEC2Evï¿½__libc_start_main@@GLIBC_2.2.5ï¿½_ZNSt16allocator_traitsISaIiEE8max_sizeERKS0_ï¿½__gmon_start__ï¿½_ITM_registerTMCloneTableï¿½_ZSt7forwardIRKiEOT_RNSt16remove_referenceIS2_E4typeEï¿½_ZNSt16allocator_traitsISaIiEE10deallocateERS0_Pimï¿½_ZN9__gnu_cxx13new_allocatorIiED1Evï¿½_ZNKSt6vectorIiSaIiEE4sizeEvï¿½_ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4ï¿½ï¿½.symtabï¿½.strtabï¿½.shstrtabï¿½.interpï¿½.note.ABI-tagï¿½.note.gnu.build-idï¿½.gnu.hashï¿½.dynsymï¿½.dynstrï¿½.gnu.versionï¿½.gnu.version_rï¿½.rela.dynï¿½.rela.pltï¿½.initï¿½.plt.gotï¿½.textï¿½.finiï¿½.rodataï¿½.eh_frame_hdrï¿½.eh_frameï¿½.gcc_except_tableï¿½.init_arrayï¿½.fini_arrayï¿½.dynamicï¿½.dataï¿½.bssï¿½.commentï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001bï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½T\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½T\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½\u000bï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0005ï¿½ï¿½ï¿½\u0017ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`\u000bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0017ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½t%ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½L\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0004ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000eï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½= ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u000fï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010= ï¿½ï¿½ï¿½ï¿½ï¿½\u0010=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018= ï¿½ï¿½ï¿½ï¿½ï¿½\u0018=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0006ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(? ï¿½ï¿½ï¿½ï¿½ï¿½(?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0002\u0001ï¿½ï¿½\bï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ @ ï¿½ï¿½ï¿½ï¿½ï¿½\u0018@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Èªaï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0007\u0001ï¿½ï¿½\u0001ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½\u0002ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@\u0014ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u001cï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½\bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\tï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\n\u0018ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0011ï¿½ï¿½ï¿½\u0003ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0010\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\u0001ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[25]={0},f[(1<<16)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint all=16,s=0,res=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=0;i<=all;i++)res+=v[i]/2,v[i]%=2,s|=(1<<v[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<all)-1;i++)\n\t\tfor(int u=0;u<=15;u++){\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=15;v++){\n\t\t\t\tif(i&(1<<v)){\n\t\t\t\t\tint w=u^v;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to, cost;\n};\n\nvector<edge> G[MAX_N];\nint val[MAX_N][4];\nint ans = 0;\n\nvoid dfs(int u, int p)\n{\n    int cnt[4] = {};\n    each(e,G[u]){\n        if(e.to != p){\n            dfs(e.to, u);\n            rep(i,4){\n                cnt[i] += (val[e.to][i]|((e.cost >> i) & 1));\n            }\n        }\n    }\n    rep(i,4){\n        ans += cnt[i]/2;\n        val[u][i] = cnt[i]%2;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int x,y,a;\n        cin >> x >> y >> a;\n        G[x].pb((edge){y,a}), G[y].pb((edge){x,a});\n    }\n    dfs(0, -1);\n    rep(i,4){\n        ans += val[0][i];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[25]={0},f[(1<<16)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint all=15,s=0,res=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=0;i<=all;i++)res+=v[i]/2,v[i]%=2,s|=(1<<v[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<all);i++)\n\t\tfor(int u=0;u<=15;u++){\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=15;v++){\n\t\t\t\tif(i&(1<<v)){\n\t\t\t\t\tint w=u^v;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    a[x] ^= z;\n    a[y] ^= z;\n  }\n  vector<int> cnt(16);\n  for (int i = 0; i < n; i++) {\n    ++cnt[a[i]];\n  }\n  int res = 0;\n  int have = 0;\n  for (int i = 1; i < 16; i++) {\n    res += cnt[i] / 2;\n    cnt[i] &= 1;\n    have |= (cnt[i] << i);\n  }\n  vector<bool> ok(1 << 16);\n  for (int mask = 0; mask < (1 << 16); mask++) {\n    int here = 0;\n    for (int i = 0; i < 16; i++) {\n      if ((mask >> i) & 1) {\n        here ^= i;\n      }\n    }\n    ok[mask] = (here == 0);\n  }\n  vector<int> dp(1 << 16);\n  for (int mask = 1; mask < (1 << 16); mask++) {\n    if (mask & 1) continue;\n    for (int smsk = mask; smsk > 0; smsk = (smsk - 1) & mask) {\n      if (ok[smsk]) {\n        dp[mask] = max(dp[mask], dp[mask ^ smsk] + 1);\n      }\n    }\n  }\n  cout << res + __builtin_popcount(have) - dp[have] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N,X[100100],C[1<<16],D[1<<16];\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y,c; scanf (\"%d %d %d\",&x,&y,&c);\n\t\tX[x] ^= c;\n\t\tX[y] ^= c;\n\t}\n\n\tfor (int i=0;i<N;i++) C[1<<X[i]]++;\n\tC[1] = 0;\n\n\tint ans = 0;\n\tfor (int i=1;i<16;i++){\n\t\tint &c = C[1<<i];\n\t\tans += c / 2 + c % 2;\n\t\tc = c % 2 * i;\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tint x = i & (-i);\n\t\tC[i] = C[i-x] ^ C[x];\n\n\t\tD[i] = -99999;\n\t\tif (C[i] == 0){\n\t\t\tD[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int j=i;j;j=(j-1)&i) if (C[j] == 0){\n\t\t\tif (D[i] < D[i-j] + 1)\n\t\t\t\tD[i] = D[i-j] + 1;\n\t\t}\n\t}\n\tans -= D[(1<<16)-1];\n\n\tprintf (\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;i++)\n#define dow(i,l,r) for(int i=r;i>=l;i--)\n#define rep0(i,r) for(int i=0,rr=(int)r;i<rr;i++)\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n\ntypedef long long LL;\n\ntypedef pair<LL,int> piir;\nconst int N=200200;\n\nint f[N],p[N],n,v[N],cnt[20];\n\nint bfs(int st)\n{\n    rep(i,0,1<<16) f[i]=n+1;\n    int h=1,t=1,k,nxt,now;\n    p[1]=st;\n    f[st]=0;\n    while (h<=t) {\n\t\tst=p[h++];\n\t\trep(i,1,15)\n\t\t\tif (st>>i&1) {\n\t\t\t\trep(j,1,15)\n\t\t\t\t\tif (i!=j && (st>>j&1)) {\n                        k=i^j;\n                        now=f[st]+1;\n                        if (st>>k&1) now++;\n                        nxt=st^((1<<i)|(1<<j)|(1<<k));\n                      //  printf(\"%d %d %d %d %d\\n\"\n\t\t\t\t\t\t//\t,st,nxt,i,j,k);\n                        if (f[nxt]==n+1) {\n\t\t\t\t\t\t\tif (!nxt) return now;\n\t\t\t\t\t\t\tp[++t]=nxt;\n\t\t\t\t\t\t\tf[nxt]=now;\n                        }\n\t\t\t\t\t}\n\t\t\t}\n    }\n}\n\nvoid solve()\n{\n    scanf(\"%d\",&n);\n\trep(i,1,n-1) {\n\t\tint j,k,l;\n\t\tscanf(\"%d %d %d\",&j,&k,&l);\n\t\tj++,k++;\n\t\tv[j]^=l;\n\t\tv[k]^=l;\n\t}\n\trep(i,1,n) cnt[v[i]]++;\n//\trep(i,1,n) printf(\"%d \",v[i]);puts(\"\");\n\tint ans=0,st=0;\n\trep(i,1,15) {\n\t\tans+=cnt[i]/2;\n\t\tst|=(cnt[i]%2)*(1<<i);\n\t}\n\t//printf(\"%d %d\\n\",ans,st);\n    printf(\"%d\\n\",bfs(st)+ans);\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mit map<int,int>::iterator\n#define sit set<int>::iterator\n#define itrm(g,x) for(mit g=x.begin();g!=x.end();g++)\n#define itrs(g,x) for(sit g=x.begin();g!=x.end();g++)\n#define ltype int\n#define rep(i,j,k) for(ltype(i)=(j);(i)<=(k);(i)++)\n#define rap(i,j,k) for(ltype(i)=(j);(i)<(k);(i)++)\n#define per(i,j,k) for(ltype(i)=(j);(i)>=(k);(i)--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mpr make_pair\n#define pb push_back\n#define fastio ios::sync_with_stdio(false)\nconst int inf=0x3f3f3f3f,mod=1000000007;\nconst double pi=3.1415926535897932,eps=1e-6;\nint n,v[100005],b[32777],dp[32777],fin,cn[17],ans;bool ok[32777];\nint main()\n{\n    scanf(\"%d\",&n);\n    rap(i,1,n){\n        int x,y,w;\n        scanf(\"%d%d%d\",&x,&y,&w);\n        v[x]^=w;v[y]^=w;\n    }\n    int lim=1<<15;\n    rap(i,0,16) cn[v[i]]++;\n    rap(i,0,lim) b[i]=__builtin_popcount(i);\n    rap(i,0,15) {\n        ans+=cn[i+1]/2;\n        if(cn[i+1]&1) fin|=(1<<i);\n    }\n    rap(i,0,lim){\n        int xr=0;\n        rap(j,0,15) if(i&(1<<j)) xr^=(j+1);\n        ok[i]=!xr;\n    }\n    rap(i,0,lim) dp[i]=inf;\n    dp[0]=0;\n    rap(i,0,lim){\n        int u=(lim-1)^i;\n        for(int ii=u;ii;ii=(ii-1)&u){\n            if(ok[ii])\n            dp[i^ii]=min(dp[i^ii],dp[i]+b[ii]-1);\n        }\n    }\n    printf(\"%d\\n\",ans+dp[fin]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<15;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[16], f[MaxM+10];\nbool xr[MaxM+10];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[++x]^=z, v[++y]^=z;\n\tfor (int i=1; i<=n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=0; i<15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=(i+1);\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  //cout<<ans<<\":\"<<res<<endl;\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    for(Int i=0;i<16;i++){\n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\tInt dif=bc[i&j]-1;\n\tInt nb=b^(1<<i)^(1<<j);\n\tif((nb>>(i^(i&j)))&1) dif+=max<Int>(0,bc[i^(i&j)]-1);\n\tif((nb>>(j^(i&j)))&1) dif+=max<Int>(0,bc[j^(i&j)]-1);\n\tnb^=1<<(i^(i&j));\n\tnb^=1<<(j^(i&j));\n\tif(dp[nb]>=dp[b]+dif) continue;\n\tdp[nb]=dp[b]+dif;\n\tpq.emplace(calc(nb),nb);\n      }\n    }\n  }\n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n\nusing namespace std;\n\nconst long long N = 2e5 + 5;\nconst long long M = 20;\n\nlong long n, m;\nlong long a[N];\nlong long ans;\nlong long cnt[M];\nlong long dp[1 << M];\nlong long dp2[1 << M];\nvector<long long> v;\n\nlong long main()\n{\n\tcin >> n;\n\tfor (long long i = 1; i < n; i++)\n\t{\n\t\tlong long u, v, x;\n\t\tcin >> v >> u >> x;\n\t\ta[u] = a[u] ^ x;\n\t\ta[v] = a[v] ^ x;\n\t}\n\tfor (long long i = 0; i < n; i++)\n\t{\n\t\tcnt[a[i]]++;\n\t}\n\tans = cnt[0];\n\tfor (long long i = 1; i < n; i++)\n\t{\n\t\tif (cnt[a[i]] % 2)\n\t\t{\n\t\t\tv.push_back(a[i]);\n\t\t}\n\t\tans += cnt[a[i]] / 2;\n\t}\n\tm = v.size();\n\tfor (long long i = 0; i < (1 << m); i++)\n\t{\n\t\tfor (long long j = 0; j < m; j++)\n\t\t{\n\t\t\tif ((i >> j) % 2 == 1)\n\t\t\t{\n\t\t\t\tdp2[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (long long mask = 1; mask < (1 << m); mask++)\n\t{\n\t\tif (dp2[mask] != 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdp[mask] = 1;\n\t\tlong long mask2 = mask;\n\t\twhile (mask2 > 0)\n\t\t{\n\t\t\tmask2 = (mask2 - 1) & mask;\n\t\t\tif (!dp2[mask2])\n\t\t\t{\n\t\t\t\tdp[mask] = max(dp[mask], dp[mask2] + dp[mask ^ mask2]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << max(n - ans - dp[(1 << m) - 1], 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 50010;\n\nint n, m, a[N], b[20];\n\nint st, dp[100010];\n\nint dfs(int x) {\n\tif (dp[x] != -1) return dp[x];\n\tint res = 1e9;\n\tfor (int i = 1; i < 16; i ++)\n\t\tif ((x >> i) & 1)\n\t\t\tfor (int j = i + 1; j < 16; j ++)\n\t\t\t\tif (((x >> j) & 1)) {\n\t\t\t\t\tint k = i ^ j;\n\t\t\t\t\tif ((x >> k) & 1) res = min(res, dfs(x ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 2);\n\t\t\t\t\telse res = min(res, dfs(x ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 1);\n\t\t\t\t}\n\treturn dp[x] = res;\n} \n\nint main() {\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int u, v, w, i = 1; i < n; i ++) {\n\t\tcin >> u >> v >> w, u ++, v ++;\n\t\ta[u] ^= w, a[v] ^= w;\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tb[a[i]] ++;\n\tfor (int i = 1; i < 16; i ++) {\n\t\tm += b[i] / 2;\n\t\tif (b[i] & 1) st |= 1 << i;\n\t}\n\t//cout << st << endl;\n\tfor (int i = 1, j = 1 << 16; i < j; i ++)\n\t\tdp[i] = -1;\n\tcout << m + dfs(st) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=100005;\nint val[N],cnt[N],sxr[1<<17];\nint a[17];\nint dp[1<<17];\ninline int read(){\n\tint x=0;char e=getchar();\n\tfor (;e<'0'||e>'9';e=getchar());\n\tfor (;e>='0'&&e<='9';e=getchar()) x=(x<<1)+(x<<3)+(e^48);\n\treturn x;\n}\ninline int Min(int a,int b){\n\treturn a<b?a:b;\n}\nint main (){\n\tint n=read();\n\tfor (int i=1;i<n;i++){\n\t\tint u=read()+1,v=read()+1,w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tint ans=0,to=0;\n\tfor (int i=1;i<16;i++){\n\t\tans+=(cnt[i]>>1);\n\t\tif (cnt[i]&1) to|=(1<<i);\n\t}\n\tfor (int i=0;i<(1<<16);i++)\n\t\tfor (int j=0;j<16;j++)\n\t\t\tif (i&(1<<j)) sxr[i]^=j;\n\tfor(int i=0;i<(1<<16);i++) dp[i]=dp[i>>1]+(i&1);\n    for(int i=0;i<(1<<16);i++) dp[i]--;\n\tfor (int i=0;i<(1<<16);i++){\n        if (sxr[i]) continue;\n        for (int k=(i-1)&i;k;k=(k-1)&i)\n            if (!sxr[k]) dp[i]=Min(dp[i],dp[k]+dp[i^k]);\n\t}\n\tprintf (\"%d\",dp[to]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nint a[MAXN];\nint cnt[16];\nint dp[(1<<15)];\nint solve(int mask)\n{\n    if(mask==0) return 0;\n    if(dp[mask]!=-1) return dp[mask];\n    int ans=INF;\n    assert(__builtin_popcount(mask)!=1);\n    for(int i=0;i<15;i++)\n    {\n        if(!(mask&(1<<i))) continue;\n        for(int j=i+1;j<15;j++)\n        {\n            if(!(mask&(1<<j))) continue;\n            int newmask=mask^(1<<i)^(1<<j);\n            int to=((i+1)^(j+1))-1;\n            if(mask&(1<<to)) ans=min(ans,solve(newmask^(1<<to))+2);\n            else ans=min(ans,solve(newmask^(1<<to))+1);\n        }\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);u++;v++;\n        a[u]^=w;a[v]^=w;\n    }\n    for(int i=1;i<=n;i++) cnt[a[i]]++;\n    int ans=0,mask=0;\n    for(int i=1;i<=15;i++)\n    {\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n        if(cnt[i]) mask+=1<<(i-1);\n    }\n    memset(dp,-1,sizeof(dp));\n    printf(\"%d\\n\",ans+solve(mask));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 1e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[32], p[20], dp[1 << 16], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tdp[0] = 0;\n\tfor(register int S = 1; S < 1 << tot; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,book[N],sxr[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();\n    rp(i,1,n){int u=read(),v=read(),va=read();w[u]^=va;w[v]^=va;}rp(i,0,n-1)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tn=1<<15;\n\trp(i,1,n-1)d[i]=d[i>>1]+(i&1);rp(i,1,n-1)d[i]-=1;rp(i,1,n-1){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n    rp(i,1,n-1)\n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)if(!sxr[k])d[i]=min(d[i],d[k]+d[i^k]);\n    }\n\tprintf(\"%d\",res+d[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, num[16], ret[1<<16];\nvpi adj[MX], ADJ[MX];\n\nint dfs(int x, int pre, int val) {\n    for (auto a: adj[x]) if (a.f != pre) {\n        dfs(a.f,x, a.s);\n        val ^= a.s;\n    }\n    if (x) num[val] ++;\n    return val;\n}\n\nvoid addEdge(int z, int i, int j) {\n    int Z = z; Z ^= 1<<i;\n    if (j == -1) {\n        ADJ[Z].pb({z,1});\n    } else {\n        Z ^= 1<<j;\n        if (Z & 1<<(i^j)) ADJ[Z^(1<<(i^j))].pb({z,2});\n        else ADJ[Z^(1<<(i^j))].pb({z,1});\n    }\n}\n\nvoid gen() {\n    F0R(z,1<<16) if (!(z&1)) {\n        F0R(i,16) if (z&(1<<i)) {\n            FOR(j,1,16) if (i != j && (z&(1<<j))) addEdge(z,i,j);\n            addEdge(z,i,-1);\n        }\n    }\n    \n    FOR(i,1,1<<16) ret[i] = MOD;\n    vi todo[17]; todo[0].pb(0); ret[0] = 0;\n    F0R(i,16) while (sz(todo[i])) {\n        int x = todo[i].back(); todo[i].pop_back();\n        if (ret[x] != i) continue;\n        for (auto a: ADJ[x]) if (i+a.s < ret[a.f]) {\n            ret[a.f] = i+a.s;\n            todo[ret[a.f]].pb(a.f);\n        }\n    } \n    /*cout << \"ZZ \" << ret[(1<<16)-2] << \"\\n\";\n    cout << \"ZZ \" << ret[(1<<3)^(1<<4)^(1<<7)] << \"\\n\";\n    cout << \"ZZ \" << ret[(1<<3)^(1<<4)] << \"\\n\";\n    exit(0);*/\n}\n\nint main() {\n    gen();\n    freopen(\"Input.txt\",\"r\",stdin);\n    // ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N-1) {\n        // int a = i,b = i+1,c = 13; \n        int a,b,c; cin >> a >> b >> c;\n        // cout << a << \" \" << b << \"\\n\";\n        adj[a].pb({b,c}), adj[b].pb({a,c});\n    }\n    dfs(0,-1,0); num[0] = 0;\n    int cur = 0, ans = 0;\n    F0R(i,16) {\n        ans += num[i]/2; \n        if (num[i]&1) cur ^= (1<<i);\n    }\n    cout << ans+ret[cur];\n    // F0R(i,16) cout << num[i] << \" \";\n    // cout << \"\\n\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n\nconst int kN = 100000 + 5;\nint n;\nint a[kN];\n\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; ++ i) {\n        int x, y, z;\n        scanf(\"%d%d%d\", &x, &y, &z);\n        a[x] ^= z;\n        a[y] ^= z;\n    }\n    std::vector<int> cnt(1 << 4);\n    for (int i = 0; i < n; ++ i)\n        cnt[a[i]] ++;\n    int groups = cnt[0];\n    cnt[0] = 0;\n    for (int i = 1; i <= 15; ++ i) {\n        groups += cnt[i] / 2;\n        cnt[i] %= 2;\n    }\n    std::vector<int> b;\n    for (int i = 1; i <= 15; ++ i)\n        if (cnt[i])\n            b.emplace_back(i);\n    std::vector<int> f(1 << b.size());\n\n    auto check = [&](int mask) {\n        int val = 0;\n        for (int i = 0; i < b.size(); ++ i)\n            if (mask >> i & 1)\n                val ^= b[i];\n        return val == 0;\n    };\n    for (int mask = 1; mask < 1 << b.size(); ++ mask) {\n        for (int t_mask = mask; t_mask; t_mask = t_mask - 1 & mask) {\n            if (check(t_mask))\n                f[mask] = std::max(f[mask], f[mask ^ t_mask] + 1);\n        }\n    }\n    int mx = 0;\n    for (int i = 0; i < 1 << b.size(); ++ i)\n        mx = std::max(mx, f[i]);\n    printf(\"%d\\n\", n - groups - mx);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint A[100000];\nint C[16];\nint D[1<<15];\nvector<int> Q[100010];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int u, v, a;\n    cin >> u >> v >> a;\n    A[u] ^= a;\n    A[v] ^= a;\n  }\n  rep(i, N) C[A[i]]++;\n  int sum = 0, st = 0;\n  for (int i=1; i<16; i++) {\n    sum += C[i]/2;\n    if (C[i]%2) st |= 1<<(i-1);\n  }\n  rep(i, 1<<15) D[i] = INF;\n  Q[0].pb(st);\n  D[st] = 0;\n  for (int v=0; v<=100000; v++) {\n    for (int S : Q[v]) {\n      if (D[S] < v) continue;\n      rep(i, 15) if ((S>>i)&1) {\n        rep(j, i) if ((S>>j)&1) {\n          int t = (i+1)^(j+1)-1;\n          int nS = S^(1<<i)^(1<<j)^(1<<t);\n          if ((S>>t)&1) {\n            if (D[nS] == INF) D[nS] = D[S]+2, Q[v+2].pb(nS);\n          }\n          else {\n            if (D[nS] > D[S]+1) D[nS] = D[S]+1, Q[v+1].pb(nS);\n          }\n        }\n      }\n    }\n    Q[v].clear();\n  }\n  cout << sum + D[0] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n\tint to;\n\tint cost;\n\tedge(int t, int c) : to(t), cost(c) {}\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tgraph G(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tG[x].emplace_back(y, a);\n\t\tG[y].emplace_back(x, a);\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tbool flag = false;\n\t\tvector<int> used(G[i].size());\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tbool ok = false;\n\t\t\tbool kaburi = false;\n\t\t\tfor (int k = 0; k < (int)G[i].size(); k++) {\n\t\t\t\tok ^= (G[i][k].cost >> j) & 1;\n\t\t\t\tif (G[i][k].cost & (1 << j)) {\n\t\t\t\t\tkaburi |= used[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tif (!kaburi) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < (int)G[i].size(); k++) {\n\t\t\t\t\tif (G[i][k].cost & (1 << j)) {\n\t\t\t\t\t\tused[k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (cnt + 1) / 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nstruct node{\n\tint sumy;\n\tint val;\n};\nint n;\nint hed[N],tal[N<<1],val[N<<1],nxt[N<<1],cnt=0;\nint nod[N];\nint bot[16];\nint sum=0;\nint q[16],t=0;\nnode s[1<<17];\nint f[1<<17];\nint bo[1<<17];\nvoid addege(int x,int y,int z){\n\tcnt++;\n\ttal[cnt]=y;\n\tval[cnt]=z;\n\tnxt[cnt]=hed[x];\n\thed[x]=cnt;\n} \nvoid dfs(int u,int fa){\n\tfor(int i=hed[u];i;i=nxt[i]){\n\t\tint v=tal[i];\n\t\tif(v==fa) continue;\n\t\tnod[v]^=val[i];\n\t\tdfs(v,u);\n\t\tnod[u]^=val[i];\n\t}\n}\nbool cmp(node x,node y){\n\treturn x.sumy>y.sumy;\n}\nint main(){\n\tmemset(f,127,sizeof(f));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++,y++;\n\t\taddege(x,y,z);\n\t\taddege(y,x,z);\n\t}\n\tdfs(1,1);\n\t//for(int i=1;i<=n;i++) cout<<nod[i]<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(nod[i]==0) continue;\n\t\tbot[nod[i]]++;\n\t\tif(bot[nod[i]]==2){\n\t\t\tbot[nod[i]]-=2;\n\t\t\tsum++;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=15;i++){\n\t\tif(bot[i]>0) q[++t]=i;\n\t}\n\t//cout<<\"**\"<<t<<endl;\n\tfor(int i=0;i<=(1<<t)-1;i++){\n\t\ts[i].val=i;\n\t\tif(i==0) s[i].sumy=0;\n\t\tfor(int j=1;j<=t;j++){\n\t\t\t//cout<<j<<\" \"<<t<<endl;\n\t\t\tif(i&(1<<(j-1))) continue;\n\t\t\ts[i|(1<<(j-1))].sumy=s[i].sumy+1;\n\t\t}\n\t}\n\tsort(s,s+(1<<t)-1+1,cmp);\n\tfor(int i=0;i<=(1<<t)-1;i++){\n\t\tbo[s[i].val]=i;\n\t}\n\tf[(1<<t)-1]=0;\n\tfor(int i=0;i<=(1<<t)-1;i++){\n\t\tint state=s[i].val;\n\t\tint x=0;\n\t\tif(s[i].sumy==1){\n\t\t\tf[0]=min(f[0],f[state]+1);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=1;j<=t;j++){\n\t\t\tif(!(state&(1<<(j-1)))) continue;\n\t\t\tx=j;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int y=1;y<=t;y++){\n\t\t\tif(!(state&(1<<(q[y]-1)))) continue;\n\t\t\tif(y==x) continue;\n\t\t\tint dx=(1<<(q[x]-1)),dy=(1<<(q[y]-1));\n\t\t\tint dz=(1<<((q[x]^q[y])-1));\n\t\t\tf[state-dx-dy+dz]=min(f[state-dx-dy+dz],f[state]+1);\n\t\t\tif((state-dx-dy)&dz){\n\t\t\t\tf[state-dx-dy-dz]=min(f[state-dx-dy-dz],f[state]+2);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[0]+sum<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5 + 2, M = 16;\n\nint A[N], C[M], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 1; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 1; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tfor (int i = 0; i < n; i++) C[A[i]]++;\n\tint x = 0, cnt = C[0];\n\tfor (int i = 1; i < M; i++) {\n\t\tcnt += C[i] >> 1;\n\t\tif (C[i] & 1) x ^= (1 << (i - 1));\n\t}\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename t>inline t min_(t a,t b){return a<=b?a:b;}\ntemplate<typename t>inline t max_(t a,t b){return a>=b?a:b;}\ntemplate<typename t>inline void chkmin(t&a,t b){if(a>b)a=b;}\ntemplate<typename t>inline void chkmax(t&a,t b){if(a<b)a=b;}\n\ntypedef long long ll;\nconst int maxn=1e5+10,maxa=16;\nint n,a[maxn],cnt[maxa],ans;\nint tot,x[maxa],dp[1<<maxa];\nbool vis[maxa];\n\nint main(){\n\tcin>>n;\n\tfor(int i=1,u,v,x;i<n;++i){\n\t\tcin>>u>>v>>x;\n\t\ta[u]^=x;a[v]^=x;\n\t}\n\tfor(int i=0;i<n;++i)\n\t\t++cnt[a[i]];\n\tfor(int i=1;i<maxa;++i)\n\t\tans+=cnt[i]/2,cnt[i]-=cnt[i]/2*2;\n\tfor(int i=1;i<maxa;++i)\n\t\tif(cnt[i])\n\t\t\tx[tot++]=i;\n\tmemset(dp,100,sizeof(dp));\n\tfor(int i=0;i<(1<<tot);++i){\n\t\tint xxx=0;\n\t\tfor(int j=0;j<tot;++j)\n\t\t\tif(i>>j&1)\n\t\t\t\txxx^=x[j];\n\t\tif(xxx==0)\n\t\t\tvis[i]=true;\n\t}\n\tdp[0]=0;\n\tfor(int i=0;i<(1<<tot);++i)\n\t\tfor(int j=(i+1)|i;j<(1<<tot);j=(j+1)|i)\n\t\t\tif(vis[i^j])\n\t\t\t\tchkmin(dp[j],dp[i]+__builtin_popcount(i^j)-1);\n\tprintf(\"%d\\n\",ans+dp[(1<<tot)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<ll, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<ldouble, ldouble> pdd;\n\nint n;\nvector <pii> E[100010];\nint A[100010];\nint B[16];\nint ans;\n\nvoid dfs(int x, int fa) {\n\tfor(pii e : E[x]) if(e.Se != fa) {\n\t\tdfs(e.Se, x);\n\t\tA[e.Se] ^= e.Fi;\n\t\tA[x] ^= e.Fi;\n\t}\n}\n\nint D[1<<16];\nint X[1<<16];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\trep(i, n-1) {\n\t\tint x, y, z; scanf(\"%d%d%d\", &x, &y, &z); ++x; ++ y;\n\t\tE[x].pb(pii(z, y));\n\t\tE[y].pb(pii(z, x));\n\t}\n\tdfs(1, -1);\n\tfor(int i=2;i<=n;i++) B[A[i]]++;\n\trep(i, 16) ans += B[i] / 2, B[i] &= 1;\n\tvector <int> v;\n\tint L = 0;\n\trep(i, 16) {\n\t\tif(B[i]) v.pb(i), L |= 1<<i;\n\t}\n\trep(b, 1<<16) {\n\t\trep(i, 16) if(1<<i & b) X[b] ^= i;\n\t}\n\trep(b, 1<<16) {\n\t\tfor(int i=b;i;i=(i-1)&b) {\n\t\t\tif(X[i] == 0) {\n\t\t\t\tD[b] = max(D[b], D[b^i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans + szz(v) - D[L]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\nusing namespace std;\n\nconst int maxn = 100005;\nconst int inf = 1e9;\nint a[maxn], c[16], f[1<<16], ins[1<<16];\nint n, x, y, z, ans, now;\n\nint solve(int s) {\n\tif (!(s >> 1)) return 0;\n\tif (ins[s]) return inf;\n\tif (f[s] != -1) return f[s];\n\tf[s] = inf; ins[s] = 1;\n\trep (i, 1, 15) if (s >> i & 1)\n\t\trep (j, 1, 15) if (i != j)\n\t\t\tf[s] = min(f[s], solve(s ^ (1 << i) ^ (1 << j)\n\t\t\t^ (1 << (i ^ j)) | 1) + 1 + ((s >> (i ^ j)) & 1));\n\tins[s] = 0;\n\t//printf(\"%d %d\\n\", s, f[s]);\n\treturn f[s];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 2, n) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x+1] ^= z; a[y+1] ^= z;\n\t}\n\trep (i, 1, n) c[a[i]]++;\n\trep (i, 1, 15) {\n\t\tans += c[i] / 2;\n\t\tc[i] &= 1;\n\t\tnow |= c[i] << i;\n\t}\n\tmemset(f, -1, sizeof f);\n\tprintf(\"%d\\n\", ans + solve(now | 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define si(a) scanf(\"%d\",&a)\n#define f first\n#define s second\n#define mp(a,b) make_pair(a,b)\n#define MAX 100005\n\nvector<pair<int,int> > graph[MAX];\nint val_node[MAX][16],ans[MAX],allval[100005];\n\nint solve(int now,int from,int ed)\n{\n    if(graph[now].size()==1 && from!=-1){\n        if(ed){\n            val_node[now][ed]=1;\n            ans[now]=1;\n        }\n        return ans[now];\n    }\n    for(int i=0;i<graph[now].size();i++){\n        int to=graph[now][i].f,w=graph[now][i].s;\n        if(to==from)continue;\n        solve(to,now,w);\n        ans[now]+=ans[to];\n        for(int j=0;j<16;j++){\n            if(val_node[to][j]){\n                val_node[now][j]^=1;\n                if(!val_node[now][j])ans[now]--;\n            }\n        }\n    }\n    int xorval=0;\n    for(int i=0;i<16;i++)xorval^=val_node[now][i];\n    xorval^=ed;\n    if(from!=-1 && xorval){\n        val_node[now][xorval]^=1;\n        if(val_node[now][xorval])ans[now]++;\n    }\n    return ans[now];\n}\n\nvoid precal(void)\n{\n    int tot=1<<16;\n    for(int msk=0;msk<tot;msk++){\n        for(int i=0;i<16;i++)if(msk&(1<<i))allval[msk]^=i;\n    }\n}\n\nint dp[100005];\n\nint calc(int msk)\n{\n    int &ret=dp[msk];\n    if(ret!=-1)return ret;\n    ret=0;\n    for(int submask=msk;submask>0;submask=(submask-1)&msk){\n        int xorval=allval[submask];\n        if((msk&(1<<xorval)) && !(submask&(1<<xorval))){\n            int tmp=msk^submask;\n            tmp^=(1<<xorval);\n            ret=max(ret,1+calc(tmp));\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int n,i;\n    si(n);\n    for(i=1;i<n;i++){\n        int u,v,w;\n        si(u);si(v);si(w);\n        graph[u].push_back(mp(v,w));\n        graph[v].push_back(mp(u,w));\n    }\n    precal();\n    int ans=solve(0,-1,0);\n    int msk=0;\n    for(i=0;i<16;i++)if(val_node[0][i])msk^=(1<<i);\n    memset(dp,-1,sizeof(dp));\n    cout<<ans-calc(msk)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, ap[20], E[100009], d[1 << 16], frm[1 << 16];\nvector < pair < int, int > > h[100009];\nvector < pair < int, int > > v[1 << 16];\nbool ap2[1 << 16][4];\n\nvoid dfs (int nod, int tata)\n{\n    for (auto it : h[nod])\n        if (it.first != tata)\n            E[it.first] = it.second, dfs (it.first, nod), E[nod] ^= it.second;\n}\n\npriority_queue < pair < int, int > > PQ;\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y, z;\n    scanf (\"%d %d %d\", &x, &y, &z), x ++, y ++;\n    h[x].push_back ({y, z});\n    h[y].push_back ({x, z});\n}\ndfs (1, -1);\nfor (int i=2; i<=N; i++)\n    ap[E[i]] ++;\nint ans = 0, msk = 0;\nfor (int i=1; i<16; i++)\n{\n    if (ap[i] & 1) msk |= 1 << i;\n    ans += (ap[i] >> 1);\n}\nfor (int msk = 0; msk < (1 << 16); msk +=2)\n{\n    vector < pair < int, int > > curr;\n    for (int i=1; i<16; i++)\n    {\n        if (msk & (1 << i))\n        {\n            curr.push_back ({msk ^ (1 << i), 1});\n            int aux = msk ^ (1 << i);\n            for (int j=1; j<16; j++)\n                if (aux & (1 << j))\n                {\n                    if (aux & (1 << (j ^ i))) curr.push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 2});\n                    else curr.push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 1});\n                }\n        }\n        else\n        {\n            for (int j=1; j<16; j++)\n                if (msk & (1 << j))\n                    for (int k=j + 1; k<16; k++)\n                        if (msk & (1 << k))\n                        {\n                            int to = msk ^ (1 << j) ^ (1 << k), cst = 1;\n                            if (to & (1 << (j ^ i))) cst ++;\n                            to ^= (1 << (j ^ i));\n                            if (to & (1 << (k ^ i))) cst ++;\n                            to ^= (1 << (k ^ i));\n                            curr.push_back ({to, cst});\n                        }\n            for (int j=1; j<16; j++)\n                if (msk & (1 << j))\n                {\n                    int to = msk ^ (1 << j), cst = 1;\n                    if (to & (1 << (j ^ i))) cst ++;\n                    to ^= (1 << (j ^ i));\n                    curr.push_back ({to, cst});\n                }\n        }\n    }\n    for (auto it : curr)\n        if (ap2[it.first][it.second] == 0)\n            ap2[it.first][it.second] = 1, v[msk].push_back (it);\n    for (auto it : v[msk])\n        ap2[it.first][it.second] = 0;\n}\nfor (int i=0; i<(1 << 16); i++)\n    d[i] = -1;\nPQ.push ({0, msk}), d[msk] = 0;\nfor (int i=1; i<16; i++)\n    if ((msk & (1 << i)) == 0)\n        PQ.push ({0, msk | (1 << i)}), d[msk | (1 << i)] = 0;\nwhile (!PQ.empty ())\n{\n    auto curr = PQ.top ();\n    PQ.pop ();\n    if (d[curr.second] != -curr.first) continue;\n    int nod = curr.second;\n    for (auto it : v[nod])\n        if (d[it.first] == -1 || (d[it.first] > d[nod] + it.second))\n            d[it.first] = d[nod] + it.second, PQ.push ({-d[it.first], it.first}), frm[it.first] = nod;\n}\nprintf (\"%d\\n\", ans + d[0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mit map<int,int>::iterator\n#define sit set<int>::iterator\n#define itrm(g,x) for(mit g=x.begin();g!=x.end();g++)\n#define itrs(g,x) for(sit g=x.begin();g!=x.end();g++)\n#define ltype int\n#define rep(i,j,k) for(ltype(i)=(j);(i)<=(k);(i)++)\n#define rap(i,j,k) for(ltype(i)=(j);(i)<(k);(i)++)\n#define per(i,j,k) for(ltype(i)=(j);(i)>=(k);(i)--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mpr make_pair\n#define pb push_back\n#define fastio ios::sync_with_stdio(false)\nconst int inf=0x3f3f3f3f,mod=1000000007;\nconst double pi=3.1415926535897932,eps=1e-6;\nint n,v[100005],b[32777],dp[32777],fin,cn[17],ans;bool ok[32777];\nint main()\n{\n    scanf(\"%d\",&n);\n    rap(i,1,n){\n        int x,y,w;\n        scanf(\"%d%d%d\",&x,&y,&w);\n        v[x]^=w;v[y]^=w;\n    }\n    int lim=1<<15;\n    rap(i,0,n) cn[v[i]]++;\n    rap(i,0,lim) b[i]=__builtin_popcount(i);\n    rap(i,0,15) {\n        ans+=cn[i+1]/2;\n        if(cn[i+1]&1) fin|=(1<<i);\n    }\n    rap(i,0,lim){\n        int xr=0;\n        rap(j,0,15) if(i&(1<<j)) xr^=(j+1);\n        ok[i]=!xr;\n    }\n    rap(i,0,lim) dp[i]=inf;\n    dp[0]=0;\n    rap(i,0,lim){\n        int u=(lim-1)^i;\n        for(int ii=u;ii;ii=(ii-1)&u){\n            if(ok[ii])\n            dp[i^ii]=min(dp[i^ii],dp[i]+b[ii]-1);\n        }\n    }\n    printf(\"%d\\n\",ans+dp[fin]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair <int, int> pii;\nint mem[1 << 15];\nint dep[100010];\nint cnt[20];\nint val[1 << 17];\n\n\nint dp(int mask) {\n\tif(mask == 0) return 0;\n\tif(mem[mask] != -1) return mem[mask];\n\tint ans = 0;\n\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\tif(val[submask] == 0) {\n\t\t\tans = max(ans, 1 + dp(mask ^ submask));\n\t\t}\n\t}\n\treturn mem[mask] = ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tmemset(mem, -1, sizeof mem);\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\t\tdep[p] ^= r;\n\t\tdep[q] ^= r;\n\t}\t\n\tvector <int> v;\n\tint comp = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tcnt[dep[i]] += 1;\n\t}\n\tfor(int i = 1; i < 16; i++) {\n\t\tif(cnt[i] & 1) {\n\t\t\tv.push_back(i);\n\t\t}\n\t\tcomp += cnt[i] >> 1;\n\t}\n\tcomp += cnt[0];\n\t// for(auto i : v) cout << i << endl;\n\tfor(int i = 0; i < (1 << v.size()); i++) {\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tif((i >> j) & 1) {\n\t\t\t\tval[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint check = 0;\n\tfor(auto i : v) {\n\t\tcheck ^= i;\n\t}\n\tassert(check == 0);\n\n\tcomp += dp((1 << v.size()) - 1);\n\tcout << n - comp << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    int x, y, a;\n    vec v(N, 0);\n    REP(i, N - 1){\n        cin >> x >> y >> a;\n        v[x] ^= a;\n        v[y] ^= a;\n    }\n    vec cnt(16, 0);\n    for(int i: v) cnt[i]++;\n    int ans = 0;\n    int X = 0;\n    REP(i, 15){\n        ans += cnt[i + 1] / 2;\n        if(cnt[i + 1] % 2) X ^= bit(i);\n    }\n\n    vec dp(bit(15), INF);\n    dp[0] = 0;\n    FOR(n, 1, 15 + 1){\n        int comb = bit(n) - 1;\n        while(comb < bit(15)){\n            int tmp = 0;\n            REP(i, 15) if((comb >> i) & 1) tmp ^= (i + 1);\n            if(tmp == 0){\n                REP(i, 15) REP(j, 15) if(i != j && bit_exist(comb, i) && bit_exist(comb, j)){\n                    int k = ((i + 1) ^ (j + 1)) - 1;\n                    if(bit_exist(comb, k)) Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 2);\n                    else Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 1);\n                }\n            }\n\n            x = comb & -comb, y = comb + x;\n            comb = ((comb & ~y) / x >> 1) | y;\n        }\n\n    }\n    ans += dp[X];\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\nconst long long MAXN = 2e5 + 21, LG = 20, inf = 0x3f3f3f3f, mod = 998244353;\n\nlong long n;\nlong long cnt[MAXN], v[MAXN];\nlong long dp[1 << 21];\nlong long ans, st;\n\nlong long dfs(int root) {\n\tif(root == 0) \n        return 0;\n\tif(dp[root] ^ -1) \n        return dp[root];\n\n\tdp[root] = inf;\n\t\n    for(int i = 0; i < 16; i++)\n\t\tif(root>>i&1) {\n\t\t\tfor(int j = 0; j < 16; j++)\n\t\t\t\tif(root>>j&1) {\n\t\t\t\t\tint x = j ^ i;\n\t\t\t\t\tint nxt = root ^ (1 << j) ^ (1 << i) ^ (1 << x);\n\t\t\t\t\tif(__builtin_popcount(nxt) < __builtin_popcount(root))\n\t\t\t\t\t    dp[root] = min(dp[root], dfs(nxt) + 1 + ((root & (1 << x)) == (1 << x)));\n\t\t\t\t}\n\t\t}\n\treturn dp[root];\n}\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n\t\tv[x] ^= z;\n\t\tv[y] ^= z; \n\t}\n\t\n    memset(dp, -1, sizeof dp);\n\n\tfor(int i = 0; i < n; i++)\n        if(v[i]) \n            cnt[v[i]]++;\n\t\n\tfor(int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tst |= (cnt[i] & 1) << i;\n\t}\n\t\n    ans += dfs(st);\n\tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005; \ntypedef pair <int, int> pii; \nvector <pii> edges [MAXN]; \nint cnt [16]; \nint dp [(1 << 16)]; \nint dfs (int node, int p = 0){\n\tint tot_xor = 0; \n\tfor (pii edge : edges[node]){\n\t\tif(edge.first==p) continue; \n\t\tint sub_xor = dfs(edge.first, node); \n\t\tcnt [sub_xor ^ edge.second]++; \n\t\t\n\t\ttot_xor ^= (sub_xor ^ edge.second); \n\t}\n\treturn tot_xor; \n}\nint main() {\n\tios_base::sync_with_stdio(0); \n\tint n; cin >> n; \n\tfor (int i=0; i<n-1; i++){\n\t\tint u, v, w; cin >> u >> v >> w; \n\t\tu++; v++; \n\t\t\n\t\tedges[u].push_back(pii(v, w)); \n\t\tedges[v].push_back(pii(u, w)); \n\t}\n\t\n\tdfs(1);\n\t\n\tcnt[0]=0; \n\t\n\tint ans=0; \n\tfor (int i=0; i<16; i++){\n\t\tans += cnt[i]/2; \n\t\tcnt[i]%=2; \n\t}\n\tint ans_msk=0; \n\tfor (int i=0;i<16; i++){\n\t\tif (cnt[i]) ans_msk |= (1 << i); \n\t}\n\tfor (int i=1; i<=ans_msk; i++){\n\t\tint cur_xor=0; \n\t\tfor (int j=0; j<16; j++){\n\t\t\tif (cnt[j]){\n\t\t\t\tif ((1 << j) & i) continue; \n\t\t\t\tcur_xor ^= j; \n\t\t\t}\n\t\t}\n\t\tif ((1 << cur_xor) & i){\n\t\t\tdp[i] = dp[i ^ (1 << cur_xor)]; \n\t\t}\n\t\telse{\n\t\t\tint an=1e9; \n\t\t\tfor (int j=0; j<16; j++){\n\t\t\t\tif ((1<<j) & i) an = min(an, 1 + dp[(1 << j) ^ i]); \n\t\t\t}\n\t\t\tdp[i] = an; \n\t\t}\n\t}\n\tcout << dp[ans_msk] << '\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long\t  ll;\ntypedef long double ld;\n\nconst int MAXN= 1e5+10;;\n\nint n;\n\nvector<pair<int,int>> adj[MAXN];\n\nint mem[MAXN];\n\nbool vis[MAXN];\nint dfs(int u, int bm, int p=-1) { //returns cost if we get i for free\n\tif (vis[u])  return mem[u];\n\tvis[u] = 1;\n\tint ans[16], nans[16];\n\tmemset(ans, 0x3f, sizeof ans);\n\tmemset(nans, 0x3f, sizeof nans);\n\tans[bm] = 0;\n\tfor(auto pp: adj[u]) {\n\t\tint v = pp.first;\n\t\tint c = pp.second;\n\t\tif (v==p) continue;\n\t\tdfs(v,c,u);\n\t}\n\tfor(auto pp: adj[u]) {\n\t\tint v = pp.first;\n\t\tint c = pp.second;\n\t\tif (v==p) continue;\n\t\t//cerr << \"@ \" << u << \" going to \" << v <<endl;\n\t\tfor(int ibm=0;ibm<16;ibm++) {\n\t\t\tnans[ibm] = min(nans[ibm], ans[ibm]+dfs(v, c, u)+(c>0));\n\t\t\tnans[ibm^c] = min(nans[ibm^c], ans[ibm^c]+dfs(v, c, u));\n\t\t}\n//\t\tfor(int ibm=0;ibm<16;ibm++) { cerr << nans[ibm] << \" \"; } cerr <<endl;\n\t\tswap(ans, nans);\n\t\tmemset(nans, 0x3f, sizeof nans);\n\t}\n\t//cerr << \"@ \" << u << \" : \"; for(int i=0;i<16;i++) cerr << ans[i]+(i>0) <<\" \"; cerr <<endl;\n\tmem[u] = ans[0];\n\tfor(int i=1;i<16;i++) {\n\t\tmem[u] = min(ans[i]+1, mem[u]);\n\t}\n\treturn mem[u];\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor(int i=0;i<n-1;i++) {\n\t\tint x, y, a;\n\t\tcin >> x >> y>> a;\n\t\tadj[x].push_back({y,a});\n\t\tadj[y].push_back({x,a});\n\t}\n\tint leaf=0;\n\tfor(int i=0;i<n;i++) {\n\t\tif (adj[i].size() == 1) {\n\t\t\tleaf = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ans = dfs(leaf,adj[leaf][0].second) + (adj[leaf][0].second>0);\n\n\tcout << ans/2 <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\nint dp[1<<15];\nint v[100005];\nint n,cnt[16];\nint solve(int mask){\n\tif(mask==0)return 0;\n\tif(~dp[mask])return dp[mask];\n\tint &ret=dp[mask];ret=inf;\n\tfor(int i=1;i<=15;i++){\n\t\tif(mask&(1<<i-1)){\n\t\t\tfor(int j=i+1;j<=15;j++){\n\t\t\t\tif(mask&(1<<j-1)){\n\t\t\t\t\tret=min(ret,solve((mask^(1<<i-1)^(1<<j-1))^(1<<(i^j)-1))+1+(mask&(1<<(i^j)-1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tmemset(dp,-1,sizeof dp);\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;cin>>x>>y>>z;x++;y++;\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tfor(int i=1;i<=n;i++)cnt[v[i]]++;\n\tint mask=0,ans;\n\tfor(int i=1;i<=15;i++){\n\t\tif(cnt[i]%2)mask|=(1ll<<i-1);\n\t\tans+=cnt[i]/2;\n\t}\n\tcout<<solve(mask)+ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans(0);\nint dp[1 << 16];\nint act[100010];\nint maskact;\n\nint mem(int mask)\n{\n    if (mask == 0 || dp[mask])\n        return dp[mask];\n    dp[mask] = 1e9;\n    for (int i(0); i <= 15; i++) {\n        if (!(mask & (1 << i)))\n            continue;\n        for (int j(0); j <= 15; j++) {\n            if (!(mask & (1 << j)) || i == j)\n                continue;\n            /// xorate i, j by i\n            int newmask = mask ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n            if (!(newmask & (1 << (i ^ j))))\n                dp[mask] = min(dp[mask], 2 + mem(newmask));\n            else\n                dp[mask] = min(dp[mask], 1 + mem(newmask));\n        }\n    }\n    return dp[mask];\n}\n\nint main()\n{\n    //cout << mem(2 + 4 + 8) << '\\n';\n    int n, a, b, c;\n    cin >> n;\n\n    for (int i(1); i < n; i++) {\n        cin >> a >> b >> c;\n        act[a] ^= c;\n        act[b] ^= c;\n    }\n    for (int i(0); i < n; i++) {\n        if (act[i] && (maskact & (1 << act[i])))\n            ans++, maskact ^= (1 << act[i]);\n        else\n            maskact ^= (1 << act[i]);\n    }\n\n    cout << mem(maskact) + ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nconst int N = 1e5 + 5;\nint deg[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  RE (i, n - 1) {\n    int a, b, c;\n    cin>>a>>b>>c;\n    a++;\n    b++;\n    deg[a] ^= c;\n    deg[b] ^= c;\n  }\n  VI cnt(16);\n  RE (i, n) {\n    cnt[deg[i]]++;\n  }\n  int res = 0;\n  int stmask = 0;\n  REP (m, 16) {\n    res += cnt[m] / 2;\n    cnt[m] %= 2;\n    if (cnt[m] && m) {\n      stmask += 1 << m;\n    }\n  }\n  debug(stmask);\n  VI dp(1 << 16, 22);\n  dp[0] = 0;\n  REP (mask, 1 << 16) {\n    if (mask == 0) { continue; }\n    int xorr = 0;\n    REP (bit, 16) {\n      if (mask & (1 << bit)) {\n        xorr ^= bit;\n      }\n    }\n    if (xorr == 0) {\n      REP (zium, 1 << 16) {\n        if (zium & mask) { continue; }\n        mini(dp[zium + mask], dp[zium] + __builtin_popcount(mask) - 1);\n      }\n    }\n  }\n  debug(res, dp[stmask]);\n  cout<<res + dp[stmask]<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxm], dp[1 << 16];\nll cnt[maxn];\nll ans;\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << (i - 1));\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[init] = 0;\n    for(int i = 15;i > 0;i--){\n        for(int S = 0;S < (1 << 15);S++){\n            ll cnt = 0;\n            for(int k = 0;k < 15;k++){\n                if((S >> k) & 1) cnt++;\n            }\n            if(cnt != i) continue;\n            // cout << cnt << \" \" << S << endl;\n            for(int k = 0;k < 15;k++){\n                if(!((S >> k) & 1)) continue;\n                for(int w = 0;w < 15;w++){\n                    if(k == w) continue;\n                    if(!((S >> w) & 1)) continue;\n                    ll newnum = ((k + 1) ^ (w + 1)) - 1;\n                    if(((S >> newnum) & 1) == 1){\n                        dp[S ^ (1 << k) ^ (1 << w) ^ (1 << newnum)] = \n                        min(dp[S ^ (1 << k) ^ (1 << w) ^ (1 << newnum)], dp[S] + 2);\n                    } else {\n                        dp[S ^ (1 << k) ^ (1 << w) | (1 << newnum)] = \n                        min(dp[S ^ (1 << k) ^ (1 << w) | (1 << newnum)], dp[S] + 1);\n                    }\n                }\n            }\n        }\n    }\n    ans += dp[0];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\nconst int maxn = 1e5 + 20;\nconst int maxs = (1 << 16) + 7;\n\nint n;\nint val[maxn], cnt[16], ans;\nint dp[maxs];\n\ntemplate<class TAT>void checkmin(TAT &x,const TAT &y)\n{\n\tif(y < x) x = y;\n}\nint dfs(int x)\n{\n\tif(dp[x] != -1) return dp[x];\n\t\n\tdp[x] = maxs;\n\t\n\tfor(int i = 0; i < 16; i++)\n\t\tfor(int j = 0; j < 16; j++)\n\t\t\tif(i != j && ((x >> i) & 1) && ((x >> j) & 1))\n\t\t\t{\n\t\t\t\tint tmp = x ^ (1 << i) ^ (1 << j);\n\t\t\t\tint modify = i ^ j;\n\t\t\t\t\n\t\t\t\tcheckmin(dp[x], tmp ^ (1 << modify) + 1 + ((tmp >> modify) & 1));\n\t\t\t}\n\t\n\treturn dp[x];\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, x, y, a; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\t++x, ++y;\n\t\tval[x] ^= a, val[y] ^= a;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(val[i])\n\t\t{\n\t\t\tans += cnt[val[i]];\n\t\t\tcnt[val[i]] ^= 1;\n\t\t}\n\t}\n\t\n\tint now = 0;\n\t\n\tfor(int i = 0; i < 16; i++) now |= (1 << i) * cnt[i];\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0] = 0;\n\tans += dfs(now);\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define MOD 1000000007\n#define PMOD 998244353\n#define pb(x) push_back(x)\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> plii;\ntypedef pair<int, pii> piii;\nconst int INF = 1e9+10;\nconst ll LINF = 1LL*INF*INF;\nconst int MAXN = 2e5+10;\nconst int MAXM = 5e3+10;\n\npriority_queue<int> pq;\nvector<vector<int> > graph;\nqueue<int> que;\n\nint A[MAXN];\nint cal[30];\nint dp[(1<<16)];\nint val[(1<<16)];\n\nint main()\n{\n    int n,m,k,a,b,x,y,q;\n    int sum = 0;\n    int cnt = 0;\n    int mx = 0;\n    int mn = INF;\n    int cur = 0, idx = -1;\n    int tc;\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin>>n;\n\n    for(int i=1;i<n;i++)\n    {\n        cin>>x>>y>>a;\n        A[x]^=a;\n        A[y]^=a;\n    }\n\n    for(int i=0;i<n;i++){\n        cal[A[i]]++;\n    }\n\n    int res = 0;\n    int vv = 0;\n\n    for(int i=1;i<=15;i++){\n        res+=(cal[i]>>1);\n        if(cal[i]&1)vv|=(1<<(i-1));\n    }\n\n    for(int i=1;i<(1<<15);i++)\n        dp[i] = dp[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)\n        dp[i]--;\n\n    for(int i=1;i<(1<<15);i++){\n        for(int j=0;j<15;j++){\n            if(i&(1<<j)){\n                val[i]^=(j+1);\n            }\n        }\n    }\n\n    for(int i=1;i<(1<<15);i++){\n        if(val[i])continue;\n\n        cur = i;\n\n        for(int j=(i-1)&i;j;j=(j-1)&i){\n            if(!val[j])dp[i] = min(dp[i],dp[j]+dp[i^j]);\n        }\n\n    }\n\n    res+=dp[vv];\n\n    cout<<res<<\"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define N_ 101000\nvector<int>E[N_], L[N_], Ch[N_];\nint D[N_][20], S[20], T[20];\nint n;\nvoid DFS(int a, int pp) {\n\tint i, j, x, k;\n\tfor (i = 0; i < E[a].size(); i++) {\n\t\tx = E[a][i];\n\t\tif (x == pp)continue;\n\t\tDFS(x, a);\n\t\tCh[a].push_back(x);\n\t}\n\tif (Ch[a].empty()) {\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++)D[a][i] = 1;\n\t\tD[a][0] = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 16; i++)S[i] = 0;\n\tfor (i = 0; i < Ch[a].size(); i++) {\n\t\tx = Ch[a][i];\n\t\tfor (j = 0; j < 16; j++)T[j] = 1e9;\n\t\tint d = L[a][i];\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tT[j^d] = min(S[j] + D[x][d], T[j^d]);\n\t\t}\n\t\tfor (j = 0; j < 16; j++)S[j] = T[j];\n\t}\n\tint Mn = 1e9;\n\tfor (j = 0; j < 16; j++)Mn = min(Mn, S[j]);\n\tfor (j = 0; j < 16; j++)D[a][j] = min(S[j], Mn + 1);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta++, b++;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t\tL[a].push_back(c);\n\t\tL[b].push_back(c);\n\t}\n\tDFS(1, 0);\n\tprintf(\"%d\\n\", D[1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <utility>\n#include <bitset>\n#include <queue>\n#include <stack>\n#define mod 998244353\n#define pb(x) push_back(x)\n#define N 300000\nusing namespace std;\nint gh[300000],tot;\nint a[300000],w[300000],cnt[50],dp[1<<17];\nstruct node\n{\n    int x,next,w;\n}edge[310000];\nvoid addedge(int x,int y,int w)\n{\n    edge[++tot].x=y;\n    edge[tot].next=gh[x];\n    edge[tot].w=w;\n    gh[x]=tot;\n}\nvoid dfs(int x,int pre)\n{\n    for(int p=gh[x];p!=-1;p=edge[p].next)\n        if(edge[p].x!=pre)\n        {\n            a[edge[p].x]=edge[p].w;\n            dfs(edge[p].x,x);\n        }\n    for(int p=gh[x];p!=-1;p=edge[p].next)\n        if(edge[p].x!=pre)w[x]^=w[edge[p].x];\n    a[x]^=w[x];\n    w[x]^=a[x];\n}\nint n;\nbool belong[1<<17];\nvoid prepare()\n{\n    cin>>n;\n    memset(gh,255,sizeof(gh)); tot=0;\n    for(int i=1;i<n;i++)\n    {\n        int x,y,w;\n        scanf(\"%d%d%d\",&x,&y,&w);\n        x++; y++;\n        addedge(x,y,w);\n        addedge(y,x,w);\n    }\n    a[1]=0;dfs(1,0);\n}\nvoid work()\n{\n    for(int i=0;i<1<<16;++i)dp[i]=-100;\n    dp[0]=0;\n    for(int i=0;i<1<<15;++i)\n    {\n        int tp=i,ts=1,now=0;\n        for(;tp;tp>>=1,ts++)if(tp&1)now^=ts;\n        if(now==0)belong[i]=1;else belong[i]=0;\n    }\n}\nint main()\n{\n    prepare();\n\n    for(int i=1;i<=n;i++)cnt[a[i]]++;\n    int ans=0;\n    cnt[0]=0;\n    for(int i=0;i<16;++i)\n    {\n        ans=ans+cnt[i]/2;\n        cnt[i]&=1;\n    }\n    for(int i=1;i<16;++i)if(cnt[i])ans++;\n\n\n    work();\n\n    int tmp=(1<<15)-1;\n    for(int i=1;i<=tmp;i++)\n    if(belong[i])\n    {\n        dp[i]=1;\n        for(int j=i;j;j=(j-1)&i)\n        if(belong[j])\n        {\n            int t;\n            if (dp[i]>dp[j]+dp[i^j])t=dp[i]; else t=dp[j]+dp[i^j];\n            dp[i]=t;\n        }\n    }\n    int tt=0;\n    for(int i=15;i;i--)tt=tt<<1|cnt[i];\n    ans-=dp[tt];\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e5 + 5, MAXS = ( 1 << 16 ) + 5;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MIN( const _T a, const _T b )\n{\n\treturn a < b ? a : b;\n}\n\nint f[MAXS];\nint w[MAXN];\nint N, cnt;\n\nbool chk( const int S, const int b ) { return S >> b & 1; }\n\nint DFS( const int S )\n{\n\tif( ! S ) return f[S] = 0;\n\tif( f[S] < INF ) return f[S];\n\tfor( int i = 1 ; i <= 15 ; i ++ )\n\t\tfor( int j = i + 1 ; j <= 15 ; j ++ )\n\t\t\tif( chk( S, i ) && chk( S, j ) )\n\t\t\t{\n\t\t\t\tint t = S ^ ( 1 << i - 1 ) ^ ( 1 << j - 1 );\n\t\t\t\tint v = i ^ j, nxt = t ^ ( 1 << v - 1 );\n\t\t\t\tf[S] = MIN( f[S], DFS( nxt ) + 1 + chk( t, v - 1 ) );\n\t\t\t}\n\treturn f[S];\n}\n\nint main()\n{\n\tread( N );\n\tfor( int i = 1, x, y, b ; i < N ; i ++ )\n\t\tread( x ), read( y ), read( b ),\n\t\tw[x + 1] ^= b, w[y + 1] ^= b;\n\tint sta = 0, tot = 0;\n\tfor( int i = 1 ; i <= N ; i ++ )\n\t\ttot += ( sta >> w[i] - 1 ) & 1, \n\t\tsta ^= 1 << w[i] - 1;\n\tmemset( f, 0x3f, sizeof f );\n\twrite( DFS( sta ) + tot ), putchar( '\\n' ); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        A[u]^=to.se;\n    }\n}\n\nint dp[1<<16];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=0;i<(1<<16);i++){\n        dp[i]=INF;\n    }\n    int rem=1;\n    for(int i=1;i<16;i++) if(!cnt[i]) rem^=(1<<i);\n    dp[rem]=0;\n    \n    for(int bit=0;bit<(1<<16);bit++){\n        if(dp[bit]==INF) continue;\n        int S=(1<<16)-1-bit;\n        for(int mask=S;;mask=(mask-1)&S){\n            if(mask==0) break;\n            int sum=0;\n            for(int i=0;i<16;i++){\n                if(mask&(1<<i)) sum^=i;\n            }\n            if(sum==0) chmin(dp[bit^sum],dp[bit]+__builtin_popcount(mask)-1);\n        }\n    }\n    \n    cout<<ans+dp[(1<<16)-1]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\nconst int MaxN=1e5+10, MaxM=1<<15+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint n, ans, state;\nint v[MaxN], cnt[20], f[MaxM];\nbool sxr[MaxM];\nint main()\n{\n\tread(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), ++x, ++y, v[x]^=z, v[y]^=z;\n\tfor (int i=1; i<=n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=(cnt[i]>>1), state+=(cnt[i]&1)*(1<<i);\n\tfor (int i=1; i< (1<<15); ++i)f[i]=f[i>>1]+(i&1);\n    for (int i=1;i< (1<<15); ++i)f[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n    for (int i=1;i< (1<<15); ++i)\n        for (int j=0;j<15;j++) if((i>>j)&1) sxr[i]^=(j+1);//é¢å¤çéåçå¼æå\n    for (int i=1;i< (1<<15); ++i)//æä¸¾å­éè¿è¡è½¬ç§»\n    {\n        if (sxr[i]!=0)continue;\n        for (int k=(i-1)&i; k; k=(k-1)&i)\n            if (sxr[k]==0) chkMin(f[i], f[k]+f[i^k]);\n    }\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nusing edge = struct {int to, cost;};\nvector<edge> graph[limit];\n\nint group[1 << 16];\nint ans = 0;\n\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\nint dfs(int v, int p, int x) {\n\tif (graph[v].size() == 1) return 0;\n\tint cx = 0, total = 0;\n\tvector<int> num(16, 0);\n\n\tfor (auto &e : graph[v]) {\n\t\tif (e.to == p) continue;\n\t\tdfs(e.to, v, e.cost);\n\t\tconst int val = e.cost;\n\t\tcx ^= e.cost;\n\t\tnum[val]++;\n\t\ttotal++;\n\t}\n\n\tans += total;\n\tint cmask = 0;\n\trep(i, 16) {\n\t\tif (num[i] % 2 == 1) cmask |= (1 << i);\n\t\tans -= num[i] / 2;\n\t}\n\n\tans -= group[cmask];\n\t// error(v, group[cmask], ans);\n\t// error(x, cx);\n\tif (p != -1 and x != cx) ans++;\n\t//error(ans);\n\treturn 0;\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tgroup[0] = 0;\n\trep(mask, 1 << 16) {\n\t\tint cur = 0;\n\t\trep(i, 16) if (mask & (1 << i)) cur ^= i;\n\t\trep(i, 16) {\n\t\t\tif (mask & (1 << i)) continue;\n\t\t\tconst int nmask = mask | (1 << i);\n\t\t\tchmax(group[nmask], group[mask] + (cur == 0));\n\t\t}\n\t}\n\n\trep(i, n - 1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgraph[x].push_back({y, a});\n\t\tgraph[y].push_back({x, a});\n\t}\n\n\tdfs(0, -1, 0);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<Bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+100;\nint cnt[N],v[N],dp[N];\nint dfs(int s)\n{\n\tif(s==0) return 0;\n\tif(dp[s]!=-1) return dp[s];\n\tdp[s]=0x3f3f3f3f;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tif(s>>i&1)\n\t\t{\n\t\t\tfor(int j=0;j<16;j++)\n\t\t\t{\n\t\t\t\tif(s>>j&1)\n\t\t\t\t{\n\t\t\t\t\tint x=i^j;int ns=s^(1<<i)^(1<<j)^(1<<x);\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t dp[s]=min(dp[s],dfs(ns)+1+((s&(1<<x))==(1<<x)));\n\t\t\t\t}\n\t\t\t} \n\t    }\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;\n\t\tv[y]^=z;\n\t}\n\tmemset(dp,-1,sizeof dp);\n\tfor(int i=0;i<n;i++)\n\t if(v[i]) cnt[v[i]]++;\n\tint st=0,ans=0;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst|=(cnt[i]&1)*(1<<i);\n\t} \n\tans+=dfs(st);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 1e5 + 10, MaxM = 1 << 15 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxM], cnt[20], xr[MaxM];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 1; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 1; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); ++ i) -- f[i];\n\tfor (int i = 1; i < (1 << 15); ++ i)\n\t\tfor (int j = 1; j <= 15; ++ j)\n\t\t\tif ((i >> (j - 1)) & 1) xr[i] ^= j;\n\tfor (int s = 1; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // ãããä½¿ããªãã°ãtieã¨ããæ¶ãã¦ï¼ï¼\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll n; cin >> n;\n    vll b(n);\n    vll c(16);\n    rep(i, n-1) {\n        ll x, y, a; cin >> x >> y >> a;\n        b[x] ^= a;\n        b[y] ^= a;\n    }\n    rep(i, n) {\n        c[b[i]]++;\n    }\n//    cout << c << endl;\n    ll ret = 0; c[0] = 0;\n    rep(i, 16) {\n        ret += c[i] / 2;\n        c[i] %= 2;\n    }\n//    cout << c << endl;\n//    cout << ret << endl;\n    ll state = 0;\n    rep(i, 15) {\n        if (c[i+1]) \n            state |= 1ll << i;\n    }\n//    cout << bitset<15>(state) <<endl;\n    ll maskn = 1<<15;\n    ll dp[maskn];\n    repi(mask, 1, maskn) {\n        ll tmp = 0;\n        rep(i, 15) if (mask & (1ll << i)) {\n            tmp ^= (i+1);\n        }\n        dp[mask] = tmp == 0;\n\n    }\n    rep(i, maskn) {\n        rep(j,n)for(int j=i;j>0;j=(j-1)&i) {\n            if (j != i && j != 0)\n                chmax(dp[i], dp[j] + dp[i^j]);\n        }\n    }\n    cout << ret + __builtin_popcountll(state) - dp[state] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\nint n;\nint a[Maxn];\nint dp[Maxn];\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v, w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    ++u, ++v;\n    a[u] ^= w, a[v] ^= w;\n  }\n  \n  int ans = 0;\n  int allmask = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] == 0) {\n      ++ans;\n    }\n    else if (allmask & (1 << a[i] - 1)) {\n      allmask ^= (1 << a[i] - 1);\n      ++ans;\n    }\n    else {\n      allmask ^= (1 << a[i] - 1);\n    }\n  }\n  \n  dp[0] = 0;\n  for (int mask = 1; mask < (1 << 15); ++mask) {\n    dp[mask] = -1;\n    int xorsum = 0;\n    for (int i = 0; i < 15; ++i) {\n      if (mask >> i & 1) {\n        xorsum ^= (i + 1);\n      }\n    }\n    if (xorsum != 0) {\n      continue;\n    }\n    \n    for (int smask = mask; smask; smask = (smask - 1) & mask) {\n      if (dp[smask] == -1) continue;\n      dp[mask] = max(dp[mask], dp[smask] + dp[mask ^ smask]);\n    }\n    dp[mask] = max(dp[mask], 1);\n  }\n  \n  printf(\"%d\\n\", n - (ans + dp[allmask]));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define si(a) scanf(\"%d\",&a)\n#define f first\n#define s second\n#define mp(a,b) make_pair(a,b)\n#define MAX 100005\n\nvector<pair<int,int> > graph[MAX];\nint val_node[MAX][16],ans[MAX],allval[100005];\n\nint solve(int now,int from,int ed)\n{\n    if(graph[now].size()==1 && from!=-1){\n        if(ed){\n            val_node[now][ed]=1;\n            ans[now]=1;\n        }\n        return ans[now];\n    }\n    for(int i=0;i<graph[now].size();i++){\n        int to=graph[now][i].f,w=graph[now][i].s;\n        if(to==from)continue;\n        solve(to,now,w);\n        ans[now]+=ans[to];\n        for(int j=0;j<16;j++){\n            if(val_node[to][j]){\n                val_node[now][j]^=1;\n                if(!val_node[now][j])ans[now]--;\n            }\n        }\n    }\n    int xorval=0;\n    for(int i=0;i<16;i++)if(val_node[now][i])xorval^=i;\n    xorval^=ed;\n    if(from!=-1 && xorval){\n        val_node[now][xorval]^=1;\n        if(val_node[now][xorval])ans[now]++;\n    }\n    return ans[now];\n}\n\nvoid precal(void)\n{\n    int tot=1<<16;\n    for(int msk=0;msk<tot;msk++){\n        for(int i=0;i<16;i++)if(msk&(1<<i))allval[msk]^=i;\n    }\n}\n\nint dp[100005];\n\nint calc(int msk)\n{\n    int &ret=dp[msk];\n    if(ret!=-1)return ret;\n    ret=0;\n    for(int submask=msk;submask>0;submask=(submask-1)&msk){\n        int xorval=allval[submask];\n        if(!xorval)ret=max(ret,1+calc(msk^submask));\n    }\n    return ret;\n}\n\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int n,i;\n    si(n);\n    for(i=1;i<n;i++){\n        int u,v,w;\n        si(u);si(v);si(w);\n        graph[u].push_back(mp(v,w));\n        graph[v].push_back(mp(u,w));\n    }\n    precal();\n    int ans=solve(0,-1,0);\n    int msk=0;\n    for(i=0;i<16;i++)if(val_node[0][i])msk^=(1<<i);\n    memset(dp,-1,sizeof(dp));\n    cout<<ans-calc(msk)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nconst int bits = 15;\nconst int limit = 1 << bits;\n\nint n, i, x, y, z, ans;\nvector< pair<int, int> > list[maxN];\nint dp[limit];\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > H;\nint tp;\n\nvoid pre() {\n    int i, j, to, aux, cnt = 0;\n\n    for (i = 0; i < limit; i++) dp[i] = bits + 1;\n    dp[0] = 0;\n    H.push(mp(0, 0));\n\n    while (!H.empty()) {\n        int conf = H.top().second;\n        int cost = H.top().first;\n        H.pop();\n\n        if (dp[conf] != cost) continue;\n        cnt++;\n\n        for (i = 0; i < bits; i++) {\n            for (j = 0; j < bits; j++) {\n                if (i == j) continue;\n                to = conf ^ (1 << i) ^ (1 << j);\n\n                aux = 1 << (((i + 1) ^ (j + 1)) - 1);\n                if (conf & aux) continue;\n                to ^= aux;\n\n                if (dp[to] > dp[conf] + 1) {\n                    dp[to] = dp[conf] + 1;\n                    H.push(mp(dp[to], to));\n                }\n            }\n\n            if (conf & (1 << i)) continue;\n            to = conf ^ (1 << i);\n            if (dp[to] > dp[conf] + 1) {\n                dp[to] = dp[conf] + 1;\n                H.push(mp(dp[to], to));\n            }\n        }\n    }\n\n    cerr << limit - cnt << '\\n';\n}\n\nvoid dfs(int node, int root, int need) {\n    int act = 0;\n\n    for (auto to : list[node])\n        if (to.first != root)\n            dfs(to.first, node, to.second), act ^= to.second;\n\n    if (node != 1 && act != need)\n        tp ^= (1 << (act ^ need)), ans++;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    pre();\n    for (i = 1; i < n; i++) {\n        cin >> x >> y >> z;\n        x++; y++;\n        list[x].pb(mp(y, z));\n        list[y].pb(mp(x, z));\n    }\n\n    dfs(1, 0, 0);\n    ans += dp[tp];\n\n    if (ans % 1) cerr << \"Error\";\n    cout << ans / 2;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int M=16;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,tot;\nint p[N];\nint w[N],c[M],a[M];\nint dp[N];\nint main()\n{\n\tint x,y,z;\n\tfile();\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y),read(z);\n\t\tx++,y++;\n\t\tw[x]^=z,w[y]^=z;\n\t}\n\tFor(i,1,n)c[w[i]]++;\n\tFor(i,1,15)\n\t{\n\t\tans+=(c[i]>>1)+(c[i]&1);\n\t\tif(c[i]&1)a[tot++]=i;\n\t}\n\tFor(i,1,(1<<tot)-1)\n\t{\n\t\tint ret=0;\n\t\tFor(j,0,tot)if((i>>j)&1)ret^=a[j];\n\t\tif(!ret)dp[i]=1;\n\t}\n\tFor(x,1,(1<<tot)-1)\n\t\tfor(int y=(x-1)&x;y;y=(y-1)&x)\n\t\t\tchkmax(dp[x],dp[y]+dp[x^y]);\n\tprintf(\"%d\\n\",ans-dp[(1<<tot)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;vi v[N];\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=(1<<j);\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n\t\t}\n\t}\n\treturn;\n}\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--,b--;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=1<<i;\n\t\t}\n\t}\n\tinit();\n\tfor(int i=0;i<=mask;i++)\n\t{\n\t\tif(i&1)continue;\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans(0);\nint dp[1 << 17];\nint act[100010];\nint maskact;\n\nint mem(int mask)\n{\n    if (mask == 0 || dp[mask])\n        return dp[mask];\n    dp[mask] = 1e9;\n    for (int i(0); i <= 15; i++) {\n        if (!(mask & (1 << i)))\n            continue;\n        for (int j(0); j <= 15; j++) {\n            if (!(mask & (1 << j)) || i == j)\n                continue;\n            /// xorate i, j by i\n            int newmask = mask ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n            if (!(newmask & (1 << (i ^ j))))\n                dp[mask] = min(dp[mask], 2 + mem(newmask));\n            else\n                dp[mask] = min(dp[mask], 1 + mem(newmask));\n        }\n    }\n    return dp[mask];\n}\n\nint main()\n{\n    //cout << mem(2 + 4 + 8) << '\\n';\n    int n, a, b, c;\n    cin >> n;\n\n    for (int i(1); i < n; i++) {\n        cin >> a >> b >> c;\n        act[a] ^= c;\n        act[b] ^= c;\n    }\n    for (int i(0); i < n; i++) {\n        if (act[i] && (maskact & (1 << act[i])))\n            ans++, maskact ^= (1 << act[i]);\n        else if (act[i])\n            maskact ^= (1 << act[i]);\n    }\n\n    cout << mem(maskact) + ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\nusing namespace std;\nint n,x,y,z,ans,val[1<<(N+1)],cnt[N*2],dp[1<<N];\nvector<int>G[N*2];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++;y++;\n\t\tval[x]^=z;val[y]^=z;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,val[i]=cnt[i]%2;\n\tint now=0,tot=0;\n\tfor (int i=1;i<=15;i++) if (val[i]) now|=(1<<i),tot++;\n\tmemset(dp,127,sizeof(dp));int inf=dp[now];dp[now]=0;\n\tfor (int i=0;i<(1<<16);i++) G[__builtin_popcount(i)].push_back(i);\n\t/*for (int i=tot;i;i--){\n\t\tfor (int j=0;j<(int)G[i].size();j++){\n\t\t\tint S=G[i][j];\n\t\t\tif (dp[S]==inf) continue;\n\t\t\tfor (int x=1;x<=15;x++){\n\t\t\t\tfor (int y=1;y<=15;y++){\n\t\t\t\t\tif (x==y||(!(S>>x&1))||(!(S>>y&1))) continue;\n\t\t\t\t\tint tmp=x^y;\n\t\t\t\t\tint S1=S^(1<<x)^(1<<y);\n\t\t\t\t\tif (S1&(1<<tmp)) dp[S1^(1<<tmp)]=min(dp[S1^(1<<tmp)],dp[S]+2);\n\t\t\t\t\telse dp[S1|(1<<tmp)]=min(dp[S1|(1<<tmp)],dp[S]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i=tot;i;i--){\n\t\tfor (int j=0;j<(int)G[i].size();j++){\n\t\t\tint S=G[i][j];\n\t\t\tif (dp[S]==inf) continue;\n\t\t\tx=__builtin_ctz(S);\n\t\t\t\tfor (int y=1;y<=15;y++){\n\t\t\t\t\tif (x==y||(!(S>>x&1))||(!(S>>y&1))) continue;\n\t\t\t\t\tint tmp=x^y;\n\t\t\t\t\tint S1=S^(1<<x)^(1<<y);\n\t\t\t\t\tif (S1&(1<<tmp)) dp[S1^(1<<tmp)]=min(dp[S1^(1<<tmp)],dp[S]+2);\n\t\t\t\t\telse dp[S1|(1<<tmp)]=min(dp[S1|(1<<tmp)],dp[S]+1);\n\t\t\t\t}\n\t\t}\n\t}\n\t//cerr<<inf<<endl;\n\tprintf(\"%d\\n\",min(dp[1],dp[0])+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 200007\n\nint n , num[20] , val[N] ;\nint C[N] , Cnt[N] ;\n\nint main()\n{\n    scanf(\"%d\" , &n ) ;\n    for(int i = 1 ; i <= n - 1 ; i++ ){ int u , v , w ; scanf(\"%d%d%d\" , &u , &v , &w ) ; val[u] ^= w , val[v] ^= w ;  }\n    for(int i = 0 ; i <= n - 1 ; i++ ) num[val[i]]++ ;\n    int ans = 0 , ed = 0 ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ){\n        for(int j = 0 ; j < 15 ; j++ ) if( ( i >> j ) & 1 ) C[i] = C[i] ^ ( j + 1 ) ;\n    }\n    for(int i = 1 ; i <= 15 ; i++ ) ans += num[i] / 2 ;\n    for(int i = 1 ; i <= 15 ; i++ ) if( num[i] & 1 ) ed |= ( 1 << ( i - 1 ) ) ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ) Cnt[i] = Cnt[i >> 1] + ( i & 1 ) ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ){\n        Cnt[i]-- ;\n        if( C[i] ) continue ;\n        for(int k = ( i - 1 ) & i ; k ; k = ( k - 1 ) & i ){\n            if( C[k] == 0 ) Cnt[i] = min( Cnt[i ^ k] + Cnt[k] , Cnt[i] ) ;\n        }\n    }\n    printf(\"%d\\n\" , ans + Cnt[ed] ) ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\nusing Edge = pair<int, long long>;\nusing Graph = vector<vector<Edge>>;\nint N;\nGraph G;\n\nlong long solve() {\n    long long res = 0;\n    for (int v = 0; v < N; ++v) {\n        set<long long> se;\n        for (auto e : G[v]) {\n            if (e.second == 0) continue;\n            se.insert(e.second);\n        }\n        res += se.size();\n    }\n    return (res + 1) / 2;\n}\n\nint main() {\n    while (cin >> N) {\n        G.assign(N, vector<Edge>());\n        for (int i = 0; i < N-1; ++i) {\n            int x, y; long long a; cin >> x >> y >> a;\n            --x, --y;\n            G[x].emplace_back(y, a);\n            G[y].emplace_back(x, a);\n        }\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N=100010,M=16;\nint s[N],cnt[M],ans,f[1000010];\nvoid chkmin(int &x,int y)\n{\n\tif(y<x)x=y;\n}\nint gi()\n{\n\tint f=0; char ch=getchar();\n\twhile(ch<'0' || ch>'9')ch=getchar();\n\twhile(ch>='0' && ch<='9')f=f*10+ch-48,ch=getchar();\n\treturn f;\n}\nint main()\n{\n\tn=gi();\n\tint u,v,w;\n\tfor(int i=1;i<n;i++)\n\t\tu=gi(),v=gi(),w=gi(),s[u]^=w,s[v]^=w;\n\tfor(int i=0;i<n;i++)\n\t\tcnt[s[i]]++;\n\tint now=0;\n\tfor(int i=1;i<16;i++)\n\t\tans+=cnt[i]/2,now+=((cnt[i]&1)<<i-1);\n\tmemset(f,127,sizeof(f)); f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<2000000000)\n\t\t{\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint l=j^k;\n\t\t\t\t\t\t\tif(i&(1<<l-1))\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<l-1)],f[i]+2);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<l-1)],f[i]+1);\n\t\t\t\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nbool used[MAXN], T[4][MAXN], T1[4][MAXN];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tREP(i, SZ(g[v]))\n\t{\n\t\tint to = g[v][i].first;\n\t\tif (!used[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tREP(j, 4)\n\t\t\t\tif (g[v][i].second & (1 << j))\n\t\t\t\t{\n\t\t\t\t\tT[j][v] ^= 1;\n\t\t\t\t\tT[j][to] ^= 1;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tsrand(time(NULL));\n\tint n, ans = INF, time0 = clock();\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tg[u].push_back(MP(v, a));\n\t\tg[v].push_back(MP(u, a));\n\t}\n\tdfs(0);\n\tif (clock() - time0 < 1.95 * CLOCKS_PER_SEC)\n\t{\n\t\tREP(j, 4)\n\t\t\tREP(i, n)\n\t\t\tT1[j][i] = T[j][i];\n\t\tint cur = 0;\n\t\tRFOR(mask, 16, 1)\n\t\t{\n\t\t\tvector <int> A;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tREP(j, 4)\n\t\t\t\t\tif ((mask & (1 << j)) && !T1[j][i])\n\t\t\t\t\t\tok = false;\n\t\t\t\tif (ok)\n\t\t\t\t\tA.push_back(i);\n\t\t\t}\n\t\t\tint p = -1;\n\t\t\tif (SZ(A) & 1)\n\t\t\t{\n\t\t\t\tcout << 1 / (n - n);\n\t\t\t\tp = SZ(A) - 1;\n\t\t\t}\n\t\t\tcur += SZ(A) >> 1;\n\t\t\tREP(i, SZ(A))\n\t\t\t{\n\t\t\t\tif (i == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tREP(j, 4)\n\t\t\t\tif (mask & (1 << j))\n\t\t\t\t\tT1[j][A[i]] = false;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cur);\n\t}\n\tcout << ans;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(ll i=a;i<b;i++)\n#define Ford(i,a,b) for(ll i=a;i>=b;i--)\n#define RET(x) { cout << x; exit(0); }\n#define smin(a,b) a=min(a,b)\n#define smax(a,b) a=max(a,b)\n#define SZ(x) ((ll)((x).size()))\n#define PB push_back\n#define ER(x) cout << #x << ' ' << x << '\\n';\n#define X first\n#define Y second\n\ntypedef long long int LL;\ntypedef LL ll;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n\nconst ll M=1e6+5,mod=924844033;\nll pw(ll x,ll y){ if (y==0) return 1; return pw(x*x%mod,y/2)*(y&1?x:1)%mod; }\n\n#define MOK(x) if (x>=mod) x-=mod;\n\n\nvll g[M];\nll uu[M],vv[M],ww[M];\nll n;\nll co[M];\n\nll nwbk[M],nw[M];\n\n\nll bu(){\n  ll res=0;\n  For(i,1,16){\n    if (nw[i]) res+=(1<<(i-1));\n  }\n  return res;\n}\n\nvoid backup(){\n  For(i,1,16) nwbk[i]=nw[i];\n}\n\nvoid unpack(){\n  For(i,1,16) nw[i]=nwbk[i];\n}\n\nll dfs(ll x,ll p){\n  ll s=0;\n  for (ll e:g[x]){\n    ll y=uu[e]^vv[e]^x;\n    if (y==p){\n      s^=ww[e];\n      continue;\n    }\n    s^=dfs(y,x);\n  }\n  co[s]++;\n  return s;\n}\n\nvector<pll> gd[M];\nll qu[M],qh,qt;\nll vis[M];\nll dp[M];\n\nvoid dpupd(){\n  For(i,0,1<<15){\n    For(j,1,16){\n      nw[j]=(i>>(j-1)&1);\n    }\n    For(j,1,16){\n      if (!nw[j]) continue;\n      nw[j]=0;\n      //ER(i);ER(bu());\n      gd[bu()].PB({i,1});\n      nw[j]=1;\n    }\n    For(a,1,16) For(b,a+1,16){\n      if (!nw[a] || !nw[b]) continue;\n      For(c,1,16){\n\tbackup();\n\tnw[a]=0;\n\tnw[b]=0;\n\tll ap=a^c;\n\tll bp=b^c;\n\tll r=1;\n\tif (nw[ap]){\n\t  r++;\n\t  nw[ap]=0;\n\t}\n\telse{\n\t  nw[ap]=1;\n\t}\n\tif (nw[bp]){\n\t  r++;\n\t  nw[bp]=0;\n\t}\n\telse{\n\t  nw[bp]=1;\n\t}\n\tgd[bu()].PB({i,r});\n\tunpack();\n      }\n    }\n  }\n  memset(dp,31,sizeof dp);\n  qu[0]=0;\n  dp[0]=0;\n  qh=0;\n  qt=1;\n  while (qh!=qt){\n    ll u=qu[qh++];\n    vis[u]=0;\n    for (pll e:gd[u]){\n      ll v=e.X;\n      ll rd=dp[u]+e.Y;\n      if (dp[v]<=rd) continue;\n      dp[v]=rd;\n      if (!vis[v]){\n\tvis[v]=1;\n\tqu[qt++]=v;\n      }\n    }\n  }\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin >> n;\n  For(i,1,n){\n    ll u,v,w;\n    cin >> u >> v >> w;\n    uu[i]=u;vv[i]=v;ww[i]=w;\n    g[u].PB(i);\n    g[v].PB(i);\n  }\n  co[dfs(0,0)]--;\n  ll res=0;\n  ll mymsk=0;\n  For(i,1,16){\n    //ER(i);ER(co[i]);\n    res+=co[i]/2;\n    co[i]=co[i]%2;\n    if (co[i])\n      mymsk+=1<<(i-1);\n  }\n  dpupd();\n  ER(mymsk);ER(dp[mymsk]);\n  res+=dp[mymsk];\n  RET(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct edge{\n\tint to,nxt,dis;\n}e[200101];\nint head[101010],tot,n;\ninline void made(int from,int to,ll dis){\n\te[++tot].to=to;e[tot].nxt=head[from];head[from]=tot;\n\te[tot].dis=dis;\n}\nint a[101010],b[100],f[201010],g[202020];\nvoid dfs(int u,int faa){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==faa) continue; \n\t\ta[v]=e[i].dis;\n\t\tdfs(v,u);\n\t\ta[u]^=a[v];\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tmade(x+1,y+1,z),made(y+1,x+1,z);\n\t}\n\tdfs(1,0); \n\tint all=0,ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]) b[a[i]-1]++,all^=(1<<(a[i]-1));\n\t}\n\tfor (int i=0;i<15;i++) ans+=b[i]/2,b[i]&=1;\n\tfor (int zt=1;zt<=all;zt++){\n\t\tbool flag=0;\n\t\tfor (int i=0;i<15;i++){\n\t\t\tif (((1<<i)&zt)&&(!b[i])){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t\telse if ((1<<i)&zt) g[zt]^=i+1;\n\t\t}\n\t\tif (!flag){\n\t\t\tf[zt]=__builtin_popcount(zt)-1;\n\t\t\tfor (int i=zt&(zt-1);i;i=zt&(i-1)){\n\t\t\t\tif (g[zt^i]*g[i]){\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[all]+ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\nconst int MaxN=1e5+10, MaxM=1<<15+10, inf=0x3f3f3f3f;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint n, ans, state;\nint v[MaxN], cnt[20], f[MaxM];\ninline int dp(int s)\n{\n\tif (!s) return 0;\n\tif (f[s]<inf) return f[s];\n\tfor (int i=0; i<=15; ++i) if (s&(1<<i))\n\t\tfor (int j=0; j<=15; ++j) if (i^j && (s&(1<<j)))\n\t\t{\n\t\t\tint x=i^j, y=s^(1<<i)^(1<<j)^(1<<x);\n\t\t\tif (s&(1<<x)) chkMin(f[s], dp(y)+2);\n\t\t\telse chkMin(f[s], dp(y)+1);\n\t\t}\n\treturn f[s];\n}\n\nint main()\n{\n\tread(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), ++x, ++y, v[x]^=z, v[y]^=z;\n\tfor (int i=1; i<=n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=(cnt[i]>>1), state+=(cnt[i]&1)*(1<<i);\n\tmemset(f, 0x3f, sizeof(f));\n\twrite(ans+dp(state), '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint v[100010]={};\n\tfor(int i=0; i<n-1; i++){\n\t\tint x, y, a;\n\t\tcin>>x>>y>>a;\n\t\tv[x]^=a;\n\t\tv[y]^=a;\n\t}\n\tint c[16]={};\n\tfor(int i=0; i<n; i++) c[v[i]]++;\n\tint ans=c[0], b=0;\n\tfor(int i=1; i<16; i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]&1) b^=(1<<(i-1));\n\t}\n\tbool ok[1<<15]={};\n\tfor(int i=0; i<(1<<15); i++){\n\t\tint s=0;\n\t\tfor(int j=0; j<15; j++){\n\t\t\tif(i&(1<<j)) s^=(j+1);\n\t\t}\n\t\tif(s==0) ok[i]=1;\n\t}\n\tint dp[1<<15]={};\n\tfor(int i=1; i<(1<<15); i++){\n\t\tif(!ok[i]) continue;\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tif(ok[j]) dp[i]=max(dp[i], dp[i-j]+1);\n\t\t}\n\t}\n\tans+=dp[b];\n\tans=n-ans;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef  long long LL;\ntypedef  unsigned long long ULL;\ntypedef  double db;\ntypedef  long double ld;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define fuck(x) cout<<x<<endl\n#define fuck1(x,y) cout<<x<<\" \"<<y<<endl\n#define lson root<<1,l,mid\n#define rson root<<1|1,mid+1,r\n#define MP(a,b) make_pair(a,b)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\nconst int INF = 0x3f3f3f3f3f,mod = 1e9+7,maxn = 3e5+100;\nconst double eps  =1e-6,PI = acos(-1);\ntemplate<typename T> inline void read(T &x){\n    x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\nint N,val[maxn],cnt[20];\nint d[maxn],ss[maxn];\nint main(){\n    read(N);\n    for(int i = 0;i<N-1;i++){\n        int x,y,a;\n        read(x),read(y),read(a);\n        val[x]^=a;\n        val[y]^=a;\n    }\n    for(int i = 0;i<N;i++){\n        if(val[i])cnt[val[i]]++;\n    }\n    int ans = 0,st = 0;\n    for(int i = 0;i<16;i++){\n        ans+=cnt[i]/2;\n        if(cnt[i]&1)st = st|(1<<i);\n    }\n    for(int i = 1;i<=(1<<16);i++)d[i] = d[i>>1]+(i&1);\n    for(int i = 1;i<=(1<<16);i++)d[i]--;\n    for(int i = 1;i<=(1<<16);i++){\n        for(int j = 0;j<=15;j++){\n            if(i&(1<<j))ss[i]^=(j);\n        }\n    }\n    for(int i = 1;i<=(1<<16);i++){\n        if(ss[i]!=0)continue;\n        for(int k = (i-1)&i;k;k = (k-1)&i){\n            if(ss[k]==0)d[i] = min(d[i],d[k]+d[i^k]);\n        }\n    }\n    printf(\"%d\\n\",ans+d[st]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!================================================================!//\n//!  888888ba  oo          oo                                      !//\n//!  88    '8b                                                     !//\n//!  88     88 dP dP   .dP dP .d8888b. .d8888b. 88d888b. .d8888b.  !//\n//!  88     88 88 88   d8' 88 Y8ooooo. 88'  '88 88'  '88 Y8ooooo.  !//\n//!  88    .8P 88 88 .88'  88       88 88.  .88 88             88  !//\n//!  8888888P  dP 8888P'   dP '88888P' '88888P' dP       '88888P'  !//\n//!================================================================!//\ntemplate <typename T>\nstd::vector<T> Divisors(const T n)\n{\n    std::vector<T> head, tail;\n    for (T i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            head.push_back(i);\n            if (i * i != n) { tail.push_back(n / i); }\n        }\n    }\n    for (auto it = tail.rbegin(); it != tail.rend(); it++) { head.push_back(*it); }\n    return head;\n}\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const ll N = read<ll>(), K = read<ll>();\n    auto D = Divisors(N);\n    std::map<ll, mint> dp;\n    mint ans = 0;\n    for (const ll d : D) {\n        dp[d] = mint(K) ^ ((d + 1) / 2);\n        for (const ll e : D) {\n            if (e < d and d % e == 0) { dp[d] -= dp[e]; }\n        }\n        ans += dp[d] * (d % 2 == 0 ? d / 2 : d);\n    }\n    SHOW(dp);\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint dp[1 << 16];\nvoid init() {\n\tfill(dp, dp + (1 << 16), mod);\n\tdp[0] = 0;\n\trep(i, (1 << 16)) {\n\t\tvector<int> r;\n\t\trep(j, 16) {\n\t\t\tif ((i&(1 << j)) == 0) {\n\t\t\t\tr.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint len = r.size();\n\t\trep1(j, (1 << len) - 1) {\n\t\t\tint s = 0; int tmp = 0;\n\t\t\trep(k, len) {\n\t\t\t\tif (j&(1 << k)) {\n\t\t\t\t\ts ^= r[k]; tmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s == 0) {\n\t\t\t\tdp[i + j] = min(dp[i + j], dp[i] + tmp - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + j] = min(dp[i + j], dp[i] + tmp);\n\t\t\t}\n\t\t}\n\t}\n\tper(i, (1 << 16)) {\n\t\tvector<int> r;\n\t\trep(j, 16) {\n\t\t\tif ((i&(1 << j)) == 0) {\n\t\t\t\tr.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint len = r.size();\n\t\trep(j, len) {\n\t\t\tint ni = i ^ (1 << r[j]);\n\t\t\tdp[i] = min({ dp[i],dp[ni] });\n\t\t}\n\t}\n}\n\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[1 << 17];\nint ans;\n\nvector<int> dfs(int v, int fr, int c) {\n\tvector<int> ret(16, 0);\n\trep(j, G[v].size()) {\n\t\tint to = G[v][j].to;\n\t\tint cost = G[v][j].cost;\n\t\tif (to == fr)continue;\n\t\tvector<int> nex = dfs(to, v, cost);\n\t\trep(i, 16) {\n\t\t\tif (ret[i] && nex[i]) {\n\t\t\t\tif (i>0)ans++; ret[i] = 0;\n\t\t\t}\n\t\t\telse if (nex[i])ret[i] = 1;\n\t\t}\n\t}\n\tif (v == 0)return ret;\n\tint s = 0;\n\trep(i, 16)if (ret[i])s ^= i; s ^= c;\n\tif (ret[s]) {\n\t\tif (s > 0)ans++; ret[s] = 0;\n\t}\n\telse {\n\t\tret[s] = true;\n\t}\n\treturn ret;\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint x, y, a; cin >> x >> y >> a;\n\t\tG[x].push_back({ y,a });\n\t\tG[y].push_back({ x,a });\n\t}\n\tvector<int> nex = dfs(0, -1, -1);\n\tint s = 0;\n\trep(i, 16) {\n\t\tif (nex[i]) {\n\t\t\ts += (1 << i);\n\t\t}\n\t}\n\tans += dp[s];\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing i64 = long long;\n\nstd::vector<std::vector<std::pair<int, int>>> g;\nint cnt[16];\n\nauto precalc() {\n    std::vector<int> ret(1 << 16);\n    for (int i = 1; i < (1 << 16); i++) {\n        int x = 0;\n        for (int j = 0; j < 16; j++) if (i & (1 << j)) x ^= j;\n        int max = !x;\n        for (int j = i; j > 0; j = (j - 1) & i) {\n            const int v = ret[j] + ret[j ^ i];\n            if (v > max) max = v;\n        }\n        ret[i] = max;\n    }\n    return ret;\n}\n\nint dfs(const int v, const int p, int x) {\n    for (const auto &edge : g[v]) {\n        if (edge.first == p) continue;\n        x ^= dfs(edge.first, v, edge.second);\n    }\n    if (p >= 0) cnt[x]++;\n    return x;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    g.resize(n);\n    for (int i = 1; i < n; i++) {\n        int u, v, a;\n        std::cin >> u >> v >> a;\n        g[u].emplace_back(v, a);\n        g[v].emplace_back(u, a);\n    }\n\n    const auto v = precalc();\n    dfs(0, -1, 0);\n\n    int ret = cnt[0], mask = 0;\n    for (int i = 1; i < 16; i++) {\n        ret += cnt[i] / 2;\n        if (cnt[i] & 1) mask |= 1 << i;\n    }\n\n    std::cout << n - 1 - ret - v[mask] << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N=100010,M=16;\nint s[N],cnt[M],ans,f[1000010];\nvoid chkmin(int &x,int y)\n{\n\tif(y<x)x=y;\n}\nint gi()\n{\n\tint f=0; char ch=getchar();\n\twhile(ch<'0' || ch>'9')ch=getchar();\n\twhile(ch>='0' && ch<='9')f=f*10+ch-48,ch=getchar();\n\treturn f;\n}\nint main()\n{\n\tn=gi();\n\tint u,v,w;\n\tfor(int i=1;i<n;i++)\n\t\tu=gi(),v=gi(),w=gi(),s[u]^=w,s[v]^=w;\n\tfor(int i=0;i<n;i++)\n\t\tcnt[s[i]]++;\n\tint now=0;\n\tfor(int i=1;i<16;i++)\n\t\tans+=cnt[i]/2,now+=((cnt[i]&1)<<i-1);\n\tmemset(f,127,sizeof(f)); f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<2000000000)\n\t\t{\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint l=j^k;\n\t\t\t\t\t\t\tif(i&(1<<l-1))\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<l-1)],f[i]+2);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<l-1)],f[i]+1);\n\t\t\t\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdint>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nqueue<int> Q;\nvector<int> a[200001];\nvector<int> b[200001];\nint sum[100001],deg[100001];\nint fax[100001];\nint fa[100001];\nbool v[100001];\nint ans;\ninline void dfs1(int d)\n{\n\tv[d]=true;\n\tint i;\n\tfor(i=0;i<a[d].size();i++)\n\t{\n\t\tint t=a[d][i];\n\t\tif(!v[t])\n\t\t{\n\t\t\tfa[t]=d;\n\t\t\tfax[t]=b[d][i];\n\t\t\tdfs1(t);\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s,t,x;\n\tint i;\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&s,&t,&x);\n\t\ts++;\n\t\tt++;\n\t\ta[s].push_back(t);\n\t\ta[t].push_back(s);\n\t\tb[t].push_back(x);\n\t\tb[s].push_back(x);\n\t}\n\tdfs1(1);\n\tfor(i=1;i<=n;i++)\n\t\tdeg[fa[i]]++;\n\tfor(i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint d=Q.front();\n\t\tQ.pop();\n\t\tdeg[fa[d]]--;\n\t\tif(fa[d]!=0&&deg[fa[d]]==0)\n\t\t\tQ.push(fa[d]);\n\t\tsum[fax[d]]++;\n\t\tfax[fa[d]]^=fax[d];\n\t\tfax[d]=0;\n\t}\n\tfor(i=1;i<=15;i++)\n\t\tans+=(sum[i]+1)/2;\n        ans--;\n        ans=max(ans,0);\n\tprintf(\"%d\\n\",ans/3*2+ans%3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define mpr make_pair\n#define pii pair<int,int>\n\ntypedef long long ll;\nconst int maxn = 1e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, s;\nint cnt[maxn], a[maxn], dp[maxn];\n\nsigned main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    for(int i = 1, u, v, w; i < n; i++)\n    {\n        cin>> u >> v >> w; u++; v++;\n        (a[v] ^= w);\n        (a[u] ^= w);\n    }\n\n    for(int v = 1; v <= n; v++) cnt[a[v]]++;\n    int ans = 0, num = 0;\n    for(int i = 0; i < 15; i++)\n    {\n        if(i == 0) ans += cnt[i];\n        else ans += cnt[i]/2;\n        (cnt[i] &= 1);\n        cnt[0] = 0;\n        num += cnt[i];\n    }\n\n    /// dp = maximum tedad daste\n    for(int msk = 0; msk < (1<<15); msk++)\n    {\n        dp[msk] = -inf;\n        int X = 0, id, is = 0;\n        for(int i = 0; i < 15; i++)\n            if((1<<i) & msk)\n            {\n                if(cnt[i]&1) (X ^= i);\n                if(cnt[i]) is = 1;\n                id = i;\n            }\n\n        if(X == 0 && msk > 0)\n        {\n            if(!is)\n            {\n                dp[msk] = 0;\n                continue;\n            }\n\n            if(__builtin_popcount(msk) == 1)\n            {\n                dp[msk] = cnt[id]/2;\n                if(id == 0) dp[msk] = cnt[id];\n            }\n            else\n            {\n                dp[msk] = 1;\n                for(int s = ((msk-1)&msk); s; s = ((s-1)&msk))\n                    dp[msk] = max(dp[msk], dp[s] + dp[msk^s]);\n            }\n        }\n    }\n\n    int msk = (1<<15)-1;\n    cout<< ans + num - dp[msk];\n}\n\n/*\n2\nT 30\nW 1\n3\nT 1\nW 1\nT 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n \nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n \n \nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\nint bp[(1 << A) + 5];\nint get(int x, int y) {\n\treturn (x >> y) & 1;\n}\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n \n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}*/\n\tfor (int mask = 0; mask < 1 << A; mask++) {\n\t\tbp[mask] = __builtin_popcount(mask);\n\t}\n\tfor (int k = 0; k < A; k++) {\n\t\tfor (int mask = 0; mask < 1 << A; mask++) {\n\t\t\tfor (int i = 0; i < A; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tint mask2 = mask;\n\t\t\t\t\tint x = 0;\n\t\t\t\t\tint y = 0;\n\t\t\t\t\tif (get(mask, i)) {\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (get(mask, j)) {\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (get(mask, ((i + 1) ^ (j + 1)) - 1)) {\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (x == 3) {\n\t\t\t\t\t\ty = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ty = 1;\n\t\t\t\t\t}\n\t\t\t\t\tmask2 ^= 1 << i;\n\t\t\t\t\tmask2 ^= 1 << j;\n\t\t\t\t\tmask2 ^= 1 << (((i + 1) ^ (j + 1)) - 1);\n\t\t\t\t//\tif (mask == 19) {\n\t\t\t\t//\t\tcout << \"48 \" << mask << \" \" << mask2 << \" \" << i << \" \" << j << \" \" << bp[mask2] << endl;\n\t\t\t\t//\t}\n\t\t\t\t\tbp[mask] = min(bp[mask], bp[mask2] + y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int mask = 0; mask < 1 << A; mask++) {\n//\t\t\n//\t\tcout << mask << \" \" << bp[mask] << endl;\n//\t}\n\tint mask = 0;\n\tfor (int i = 1; i <= A; i++) {\n\t\tif (dp[1][i]) {\n\t\t\tmask += 1 << (i - 1);\n\t\t}\n\t}\n\tcout << ans + bp[mask] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n//char buf[1<<24],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nint a[N],b[N];\nint f[(1<<16)+10],s[(1<<16)+10];\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tint n; sc(n);\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tint x,y,w; sc(x),sc(y),sc(w); ++x,++y;\n\t\ta[x]^=w,a[y]^=w;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\t++b[a[i]];\n\tint ans=0; n=0;\n\tfor (int i=1; i<=15; i++)\n\t{\n\t\tans+=b[i]>>1;\n\t\tif (b[i]&1) a[++n]=i;\n\t}\n\tint S=(1<<n)-1;\n\tfor (int s=1; s<=S; s++)\n\t{\n\t\tf[s]=f[s>>1]+(s&1);\n\t\tfor (int i=1; i<=n; i++) if (s>>(i-1)&1)\n\t\t\t::s[s]^=a[i];\n\t}\n\tfor (int i=1; i<=S; i++)\n\t\tf[i]=s[i]?1e9:f[i]-1;\n\tfor (int s=1; s<=S; s++) if (!::s[s])\n\t{\n\t\tfor (int s1=s; s1; s1=(s1-1)&s)\n\t\t\tf[s]=min (f[s],f[s1]+f[s-s1]);\n\t}\n\tpr(ans+f[S]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Maxn = 100010;\nconst int inf = 0x7fffffff;\nint po[Maxn];\nint f[1<<14], bit[1<<14], n;\nvector <int> vec[20];\nvoid down(int &x, int y) { if(x > y) x = y; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; i++){\n\t\tint x, y, d;\n\t\tscanf(\"%d%d%d\", &x, &y, &d);\n\t\tpo[x] ^= d; po[y] ^= d;\n\t}\n\tfor(i = 1; i < 1<<14; i++){ bit[i] = bit[i>>1]+(i&1); vec[bit[i]].push_back(i); }\n\tint p = 0, ans = 0;\n\tfor(i = 0; i < 1<<14; i++) f[i] = inf;\n\tfor(i = 0; i < n; i++){\n\t\tif(!po[i]) continue;\n\t\tif(p&(1<<po[i]-1)) ans++;\n\t\tp ^= (1<<po[i]-1);\n\t}\n\tf[p] = 0;\n\tfor(i = 14; i >= 1; i--){\n\t\tfor(j = 0; j < vec[i].size(); j++){\n\t\t\tint x = vec[i][j];\n\t\t\tif(f[x] == inf) continue;\n\t\t\tfor(k = 0; k < 15; k++){\n\t\t\t\tif(x&(1<<k)){\n\t\t\t\t\tfor(int u = 0; u < 15; u++){\n\t\t\t\t\t\tif(k != u && x&(1<<u)){\n\t\t\t\t\t\t\tint t = (k+1)^(u+1);\n\t\t\t\t\t\t\tif(x&(1<<t-1)) down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+2);\n\t\t\t\t\t\t\telse down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j < vec[i].size(); j++){\n\t\t\tint x = vec[i][j];\n\t\t\tif(f[x] == inf) continue;\n\t\t\tfor(k = 0; k < 15; k++){\n\t\t\t\tif(x&(1<<k)){\n\t\t\t\t\tfor(int u = 0; u < 15; u++){\n\t\t\t\t\t\tif(k != u && x&(1<<u)){\n\t\t\t\t\t\t\tint t = (k+1)^(u+1);\n\t\t\t\t\t\t\tif(x&(1<<t-1)) down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+2);\n\t\t\t\t\t\t\telse down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region revive\n#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define inl inline\n#define re register int\n#define fa(x) t[x].fa\n#define son(x, y) t[x].child[y]\n#define ls(x) t[x].child[0]\n#define rs(x) t[x].child[1]\n#define ll long long\n#define ull unsigned long long\nconst int inf = 0x3f3f3f3f;\n#define lowbit(x) ((x) & (-x))\nusing namespace std;\n//#ifndef _DEBUG\n//#define getchar() (*(IOB.in.p++))\n//#define putchar(c) (*(IOB.out.p++) = (c))\n//#define io_eof() (IOB.in.p >= IOB.in.pend)\n//struct IOBUF {\n//\tstruct {\n//\t\tchar buff[1 << 27], *p, *pend;\n//\t} in;\n//\tstruct {\n//\t\tchar buff[1 << 27], *p;\n//\t} out;\n//\tIOBUF() {\n//\t\tin.p = in.buff;\n//\t\tout.p = out.buff;\n//\t\tin.pend = in.buff + fread(in.buff, 1, 1 << 27, stdin);\n//\t}\n//\t~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); }\n//} IOB;\n//#endif\ntemplate <typename IO>\ninl void write(IO x) {\n\tif (x == 0) return (void)putchar('0');\n\tif (x < 0) putchar('-'), x = -x;\n\tstatic char buf[30];\n\tchar *p = buf;\n\twhile (x) {\n\t\t*(p++) = x % 10 + '0';\n\t\tx /= 10;\n\t}\n\twhile (p > buf)\n\t\tputchar(*(--p));\n}\ninl void writestr(const char *s) {\n\twhile (*s != 0)\n\t\tputchar(*(s++));\n}\ntemplate <typename IO>\ninl void writeln(IO x) { write(x), putchar('\\n'); }\ntemplate <typename IO>\ninl void writesp(IO x) { write(x), putchar(' '); }\ninl int readstr(char *s) {\n\tchar *begin = s, c = getchar();\n\twhile (c < 33 || c > 127) {\n\t\tc = getchar();\n\t}\n\twhile (c >= 33 && c <= 127) {\n\t\t*(s++) = c;\n\t\tc = getchar();\n\t}\n\t*s = 0;\n\treturn s - begin;\n}\ntemplate <typename IO>\ninl IO read() {\n\tIO x = 0;\n\tregister bool w = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn w ? -x : x;\n}\ntemplate <>\ninl double read<double>() {\n\tdouble x = 0;\n\tint w = 0, y = 0;\n\tll z = 1;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9' || c == '.') {\n\t\tif (c == '.') {\n\t\t\ty = 1, c = getchar();\n\t\t\tcontinue;\n\t\t}\n\t\tx = x * 10 + (c ^ 48);\n\t\tif (y) z *= 10;\n\t\tc = getchar();\n\t}\n\treturn (w ? -x : x) / z;\n}\n#pragma endregion\nint n, b[1 << 16], f[1 << 16], s;\nint a[100001], o[16], ans, num[1 << 16];\ninl bool cmp(int x, int y) { return num[x] < num[y]; }\ninl int dp(int i) {\n\tif (f[i] < inf) return f[i];\n\tfor (re x = 1; x <= 15; x++) {\n\t\tif (((1 << x) & i) == 0) continue;\n\t\tfor (re y = 1; y <= 15; y++) {\n\t\t\tif (x == y) continue;\n\t\t\tif (((1 << y) & i) == 0) continue;\n\t\t\tre z = x ^ y, p = (((i ^ (1 << z)) ^ (1 << x)) ^ (1 << y));\n\t\t\tif ((1 << z) & i)\n\t\t\t\tf[i] = min(f[i], dp(p) + 2);\n\t\t\telse\n\t\t\t\tf[i] = min(f[i], dp(p) + 1);\n\t\t}\n\t}\n\treturn f[i];\n}\nsigned main() {\n\tn = read<int>();\n\tfor (re x, y, z, i = 1; i < n; i++) {\n\t\tx = read<int>(), y = read<int>(), z = read<int>();\n\t\ta[x] ^= z, a[y] ^= z;\n\t}\n\tfor (re i = 1; i <= n; i++) o[a[i]]++;\n\tfor (re i = 1; i <= 15; i++) {\n\t\tif (o[i] >= 2) {\n\t\t\tans += o[i] / 2;\n\t\t\to[i] = o[i] & 1;\n\t\t}\n\t\tif (o[i]) s |= (1 << i);\n\t}\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] = 0;\n\twriteln(ans + dp(s));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N=100010,M=16;\nint s[N],cnt[M],ans,f[1000010];\nvoid chkmin(int &x,int y)\n{\n\tif(y<x)x=y;\n}\nint gi()\n{\n\tint f=0; char ch=getchar();\n\twhile(ch<'0' || ch>'9')ch=getchar();\n\twhile(ch>='0' && ch<='9')f=f*10+ch-48,ch=getchar();\n\treturn f;\n}\nint main()\n{\n\tn=gi();\n\tint u,v,w;\n\tfor(int i=1;i<n;i++)\n\t\tu=gi(),v=gi(),w=gi(),s[u]^=w,s[v]^=w;\n\tfor(int i=0;i<n;i++)\n\t\tcnt[s[i]]++;\n\tint now=0;\n\tfor(int i=1;i<16;i++)\n\t\tans+=cnt[i]/2,now+=((cnt[i]&1)<<i-1);\n\tmemset(f,127,sizeof(f)); f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<2000000000)\n\t\t{\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint l=j^k;\n\t\t\t\t\t\t\tif(i&(1<<l-1))\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<l-1)],f[i]+2);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<l-1)],f[i]+1);\n\t\t\t\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nvector<int> two[MAX];\nint A[MAX],sum[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        A[to.fi]^=to.se;\n        DFS(to.fi,u);\n        sum[u]^=sum[to.fi];\n    }\n    A[u]^=sum[u];\n    sum[u]^=A[u];\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    //for(int i=1;i<N;i++) cout<<A[i]<<endl;\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\n\nvector<pair<int, int>> E[MAX];\n\nint a[MAX];\n\nvoid Dfs(int x, int prev, int dad) {\n  a[x] = prev;\n  for (auto& p: E[x]) {\n    int y = p.first;\n    int w = p.second;\n    if (y != dad) {\n      Dfs(y, w, x);\n      a[x] ^= a[y];\n    }\n  }\n}\n\nconst int MAXB = 1<<16;\n\nint f[MAXB];\n\nint Solve(int mask) {\n  if (f[mask] != -1) return f[mask];\n  if (mask == 0) return f[mask] = 0;\n\n  f[mask] = 100000;\n  REP(x, 16) {\n    if (mask & (1<<x)) {\n      f[mask] = min(f[mask], Solve(mask ^ (1<<x)) + 1);\n      REP(y, 16) {\n        if (x != y && (mask & (1<<y))) {\n          int nmask = mask ^ (1<<x) ^ (1<<y);\n          int cost = 1;\n          int z = x ^ y;\n          if (nmask & (1<<z)) cost++;\n          nmask ^= 1<<z;\n          f[mask] = min(f[mask], cost + Solve(nmask));\n        }\n      }\n    }\n  }\n\n  return f[mask];\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N-1) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    E[a].push_back({b, c});\n    E[b].push_back({a, c});\n  }\n\n  Dfs(0, 0, -1);\n\n  int mask = 0;\n  int ret = 0;\n  FOR(i, 1, N) {\n    if (a[i] == 0) continue;\n    if (mask & (1<<a[i])) {\n      ret++;\n    }\n    mask ^= 1 << a[i];\n  }\n  memset(f, -1, sizeof(f));\n  ret += Solve(mask);\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nint main()\n{\n\tmemset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot+=(1<<i);\n\tf[0]=0;\n\tfor(int s=1;s<=tot;s++){\n\t\tfor(int i=1;i<=15;i++)if(s>>i&1){\n\t\t\tfor(int j=1;j<=15;j++)if((s>>j&1) && (i!=j)){\n\t\t\t\tif(!(i^j)&s)f[s]=min(f[s],f[s-(1<<i)+(1<<(i^j))]+1);\n\t\t\t\telse{\n\t\t\t\t\tf[s]=min(f[s],f[s-(1<<i)-(1<<j)-(1<<i^j)]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint DP(int now) {\n\tif(now == 0) return 0;\n\tif(dp[now] != -1) return dp[now];\n\tdp[now] = 1e9;\n\tfor (int i = 0; i < 15; ++i) {\n\t\tif(!(now & (1 << i))) continue;\n\t\tfor (int j = i + 1; j < 15; ++j) {\n\t\t\tif(!(now & (1 << j))) continue;\n\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n//\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n\t\t\tint f;\n\t\t\tif(((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1)))) f = 1;\n\t\t\telse f = 0;\n\t\t\tdp[now] = min(dp[now] , DP(nnow) + 1 + f);\n\t\t}\n\t}\n\treturn dp[now];\t\n}\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\" , a[i]);\n\t\tif(!a[i]) continue;\n\t\tif(S & (1 << (a[i] - 1))) ans ++;\n\t\tS ^= (1 << (a[i] - 1));\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , -1 , sizeof dp);\n\tdp[0] = 0;\n\tans += DP(S);\n//\tfor (int now = 1; now < (1 << 15); ++now) {\n//\t\tfor (int i = 0; i < 15; ++i) {\n////\t\t\tif(!(now & (1 << i))) continue;\n//\t\t\tfor (int j = i + 1; j < 15; ++j) {\n////\t\t\t\tif(!(now & (1 << j))) continue;\n//\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n////\t\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n//\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1))));\n//\t\t\t}\n//\t\t}\n//\t}\n\tprintf(\"%d\" , ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[16][1 << 15][8];\nint dp2(int idx, int mask, int tidx, int tcnt) {\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask);\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(idx, mask, tidx + 1, tcnt);\n\n    if(cc2[idx][mask][tidx].find(tcnt) != cc2[idx][mask][tidx].end()) return cc2[idx][mask][tidx][tcnt];\n    int &ret = cc2[idx][mask][tidx][tcnt];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(idx, mask, tidx + 1, tcnt));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(idx, mask ^ (1 << tidx) ^ (1 << didx), tidx + 1, tcnt + 1));\n    return ret;\n}\n\nint cc1[16][1 << 15];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(idx, mask, 1, 0);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22],lg[66666];\nint f[66666],q[66666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tint ans=0;\n\tfor(register int i=2,j=1;i<65536;i<<=1,++j)lg[i]=j;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])++w;//w|=1<<i;\n\tf[w]=0;\n\tfor(q[hq=1]=w,tq=2;hq!=tq;++hq)\n\t{\n\t\tint o=q[hq];\n\t\tint l=lg[o&-o];\n\t\tfor(register int i=l+1;i<16;++i)\n\t\t\tif(o&1<<i)\n\t\t\t{\n\t\t\t\tint t=o^1<<l^1<<i^1<<(l^i);\n\t\t\t\tt&=~1;\n\t\t\t\tif(f[t]==0)f[t]=f[o]+1,q[tq++]=t;\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[0]); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint DP(int now) {\n\tif(now == 0) return 0;\n\tif(dp[now] != -1) return dp[now];\n\tdp[now] = 1e9;\n\tfor (int i = 0; i < 15; ++i) {\n\t\tif(!(now & (1 << i))) continue;\n\t\tfor (int j = i + 1; j < 15; ++j) {\n\t\t\tif(!(now & (1 << j))) continue;\n\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n\t\t\tint f;\n\t\t\tif(((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1)))) f = 1;\n\t\t\telse f = 0;\n\t\t\tdp[now] = min(dp[now] , DP(nnow) + 1 + f);\n\t\t}\n\t}\n\treturn dp[now];\t\n}\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(!a[i]) continue;\n\t\tif(S & (1 << (a[i] - 1))) ans ++;\n\t\tS ^= (1 << (a[i] - 1));\n\t} \n\tmemset(dp , -1 , sizeof dp);\n\tdp[0] = 0;\n\tans += DP(S);\n\tprintf(\"%d\" , ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint cc[20][1 << 16];\nint dp(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc[idx][mask];\n    if(ret != -1) return ret;\n\n    ret = 1e9;\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n\n    for(int nmask = 0; nmask < (1 << (idx - 1)); nmask++) {\n        int diff = mask ^ nmask;\n\n        int tcnt = 0;\n        for(int i = 0; i < 16; i++) if(diff & (1 << i)) tcnt++;\n        for(int i = 0; i < 16; i++) if((diff & (1 << i)) && (diff & (1 << (idx ^ i)))) tcnt--;\n\n        if(tmp < tcnt) continue;\n\n        ret = min(ret, tmp + tcnt + dp(idx - 1, nmask));\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc, -1, sizeof(cc));\n    printf(\"%d\", (dp(15, 0) + 1) / 2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=16;\nint n,a[M];\nvvp g;\n\nint dfs(int v,int pre){\n\tint res=0;\n\tfor(auto p:g[v]){\n\t\tint u=p.first,c=p.second;\n\t\tif(pre!=u){\n\t\t\tint t=c^dfs(u,v);\n\t\t\tif(t) a[t]++;\n\t\t\tres^=t;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvp(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tg[u].push_back({v,c});\n\t\tg[v].push_back({u,c});\n\t}\n\tdfs(0,-1);\n\tint t=0;\n\tvi b,c,dp;\n\tfor(int i=1;i<M;i++){\n\t\tt+=a[i]/2;\n\t\tif(a[i]%2==1) b.push_back(i);\n\t}\n\tn=b.size();\n\tint N=1<<n;\n\tc=dp=vi(N);\n\tfor(int i=0;i<N;i++) for(int j=0;j<n;j++) if(i&1<<j) c[i]^=b[j];\n\tfor(int i=1;i<N;i++){\n\t\tint j=i;\n\t\tdo{\n\t\t\tdp[i]=max(dp[i],dp[i-j]+(c[j]?0:1));\n\t\t\tj=(j-1)&i;\n\t\t}while(j);\n\t}\n\tcout<<t+n-dp[N-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, B, w, x[100005], c[16], ans, p3[20];\nshort dp[15000000];\nvector<int> r;\ninline bool val(int B){\n    int C=0;\n    bool f=0;\n    fox(l, m){\n        if (B/p3[l]%3==1){\n            C^=r[l];\n            f=1;\n        }\n    }\n    return f && C==0;\n}\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            if (dp[l]<0) continue;\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                }\n            }\n            if (val(l)){\n                B=l;\n                fox(l, m){\n                    if (B/p3[l]%3==1) B+=p3[l];\n                }\n                //cout << \"*\";\n                dp[B]=max(dp[B], short(dp[l]+1));\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    os << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<pair<int,int>>> G(N);\n    for (int i=0;i<N-1;++i){\n        int x,y,a; cin >> x >> y >> a;\n        G[x].emplace_back(y,a);\n        G[y].emplace_back(x,a);\n    }\n    vector<int> cnt(16,0);\n    auto dfs=[&](auto self,int v,int p,int a)->void{\n        for (auto e:G[v]){\n            int u=e.first;\n            if (u==p) continue;\n            self(self,u,v,e.second);\n            a^=e.second;\n        }\n        ++cnt[a];\n    };\n    dfs(dfs,0,-1,0);\n    int bit=0,ans=0;\n    for (int i=1;i<16;++i){\n        ans+=(cnt[i]>>1)+(cnt[i]&1);\n        bit|=(cnt[i]&1)<<(i-1);\n    }\n    vector<int> dp(1<<15,0);\n    for (int mask=1;mask<(1<<15);++mask){\n        int XOR=0;\n        for (int i=0;i<15;++i){\n            if (mask&1<<i){\n                XOR^=i+1;\n            }\n        }\n        if (XOR) continue;\n        dp[mask]=1;\n        for (int sub=mask;;sub=(sub-1)&mask){\n            dp[mask]=max(dp[mask],dp[sub]+dp[mask^sub]);\n            if (!sub) break;\n        }\n    }\n    cout << ans-dp[bit] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint f[133333],g[133333],a[133333],w[133333],p[133333];\nint main()\n{\n\tint n,i,x,y,l,j,cnt=0,ans=0;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&l);\n\t\tx++,y++;\n\t\tg[x]^=l,g[y]^=l; \n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(a[g[i]])\n\t\t\tans++;\n\t\ta[g[i]]^=1;\n\t}\n\tfor(i=0;i<16;i++)\n\t\tif(a[i])\n\t\t\tp[++cnt]=i;\n//\tprintf(\"%d|\",cnt);\n\tfor(i=0;i<(1<<cnt);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(j=1;j<=cnt;j++)\n\t\t\tif((1<<j-1)&i)\n\t\t\t\tw[i]^=p[j],sum++;\n\t\tf[i]=sum-1;\n\t\tif(!w[i])\n\t\t{\n\t\t\tfor(j=i-1;j;j=(j-1)&i)\n\t\t\t{\n\t\t\t\tif(!w[j])\n\t\t\t\t\tf[i]=min(f[i],f[j]+f[i-j]);\n\t\t\t\telse\n\t\t\t\t\tf[i]=min(f[i],f[j]+f[i-j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[(1<<cnt)-1]+ans);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Set(a,b) memset(a,b,sizeof(a))\ntemplate<class T>inline void init(T&x){\n\tx=0;char ch=getchar();bool t=0;\n\tfor(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);\n\tif(t) x=-x;return;\n}typedef long long ll;\nconst int N=1e5+10;\nstruct edge{\n\tint to,next,w;\n}a[N<<1];\nint head[N],cnt=0;\ninline void add(int x,int y,int w){a[++cnt]=(edge){y,head[x],w};head[x]=cnt;}\nint ans=0,n;\nint bac[20];\nint dfs(int u,int fa,int fr){\n\tfor(int v,i=head[u];i;i=a[i].next) {v=a[i].to;if(v==fa) continue;fr^=dfs(v,u,a[i].w);}\n\tif(fr&&fa) ++bac[fr];return 0;\n}\nint dp[1<<16];\ninline int DP(int s){\n\tif(~dp[s]) return dp[s];\n\tdp[s]=1e9;\n\tfor(int i=1;i<16;++i) {\n\t\tif(s&(1<<i)) {\n\t\t\tdp[s]=min(dp[s],DP(s^(1<<i))+1);\n\t\t\tfor(int j=i+1;j<16;++j) {\n\t\t\t\tif(s&(1<<j)) {\n\t\t\t\t\tint t=s^(1<<i)^(1<<j);\n\t\t\t\t\tint k=i^j;int f=1;\n\t\t\t\t\tif(t&(1<<k)) t^=1<<k,++f;\n\t\t\t\t\telse t|=1<<k;\n\t\t\t\t\tf+=DP(t);dp[s]=min(dp[s],f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tinit(n);Set(dp,-1);\n\tfor(int i=1;i<n;++i) {\n\t\tint u,v,w;init(u),init(v),init(w);\n\t\t++u,++v;add(u,v,w),add(v,u,w);\n\t}dfs(1,0,0);\n\tint ans=0;int s=0;\n\tdp[0]=0;\n\tfor(int i=1;i<16;++i) {ans+=bac[i]>>1;bac[i]&=1;if(bac[i]) s|=1<<i;}\n\tans+=DP(s);cout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint u, v;\n\tint cost;\n\tedge(){}\n\tedge(int a, int b, int c){\n\t\tu = a, v = b, cost = c;\n\t}\n\tint get(int a)\n\t{\n\t\tif(u == a) return v;\n\t\telse return u;\n\t}\n};\n\nint N;\nvector<int> G[100005];\nedge E[100005];\nint cnt[16];\n\nint V = 1 << 16, S;\nint dist[1<<16];\n\nvoid bfs(){\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(make_pair(0, S));\n\tint d, v, nv;\n\twhile(Q.size()){\n\t\tv = Q.top().second;\n\t\td = Q.top().first;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tif(v == 0) break;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif((v & (1<<i)) == 0) continue;\n\t\t\tfor(int j = 1; j < 16; j++){\n\t\t\t\tif((v & (1<<j)) == 0) continue;\n\t\t\t\tif(i == j) continue;\n\t\t\t\tnv = v;\n\t\t\t\tnv &= ~(1<<i);\n\t\t\t\tnv &= ~(1<<j);\n\t\t\t\tnv ^= 1<<(i^j);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t\tif((nv & 1<<(i^j)) == 0) dist[nv]++;\n\t\t\t\tQ.push(make_pair(dist[nv], nv));\n\t\t\t\t//cout << i << \" \" << j << \" \" << v << \" \" << nv << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int prev)\n{\n\tint val = 0;\n\tfor(int i = 0; i < G[v].size(); i++) val ^= E[G[v][i]].cost;\n\tcnt[val]++;\n\t\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(E[G[v][i]].get(v) == prev) continue;\n\t\tdfs(E[G[v][i]].get(v), v);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint x, y, a;\n\tfor(int i = 0; i < N-1; i++){\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(i);\n\t\tG[y].push_back(i);\n\t\tE[i] = edge(x, y, a);\n\t}\n\t\n\tdfs(0, -1);\n\t//for(int i = 0; i < 16; i++) cout << cnt[i] << \" \"; cout << endl;\n\t\n\tint ans = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t}\n\tcnt[0] = 0;\n\tfor(int i = 0; i < 16; i++) if(cnt[i]) S += (1<<i);\n\t\n\tbfs();\n\tans += dist[0];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005; \ntypedef pair <int, int> pii; \nvector <pii> edges [MAXN]; \nint cnt [16]; \nint dp [(1 << 16)]; \nint dfs (int node, int p = 0){\n\tint tot_xor = 0; \n\tfor (pii edge : edges[node]){\n\t\tif(edge.first==p) continue; \n\t\tint sub_xor = dfs(edge.first, node); \n\t\tcnt [sub_xor ^ edge.second]++; \n\t\t\n\t\ttot_xor ^= (edge.second); \n\t}\n\treturn tot_xor; \n}\nint main() {\n\tios_base::sync_with_stdio(0); \n\tint n; cin >> n; \n\tfor (int i=0; i<n-1; i++){\n\t\tint u, v, w; cin >> u >> v >> w; \n\t\tu++; v++; \n\t\t\n\t\tedges[u].push_back(pii(v, w)); \n\t\tedges[v].push_back(pii(u, w)); \n\t}\n\t\n\tdfs(1);\n\t\n\tcnt[0]=0; \n\t\n\tint ans=0; \n\tfor (int i=0; i<16; i++){\n\t\tans += cnt[i]/2; \n\t\tcnt[i]%=2; \n\t}\n\tint ans_msk=0; \n\tfor (int i=0;i<16; i++){\n\t\tif (cnt[i]) ans_msk |= (1 << i); \n\t}\n\tfor (int i=1; i<=ans_msk; i++){\n\t\tint cur_xor=0; \n\t\tfor (int j=0; j<16; j++){\n\t\t\tif (cnt[j]){\n\t\t\t\tif ((1 << j) & i) continue; \n\t\t\t\tcur_xor ^= j; \n\t\t\t}\n\t\t}\n\t\tif ((1 << cur_xor) & i){\n\t\t\tdp[i] = dp[i ^ (1 << cur_xor)]; \n\t\t}\n\t\telse{\n\t\t\tint an=1e9; \n\t\t\tfor (int j=0; j<16; j++){\n\t\t\t\tif ((1<<j) & i) an = min(an, 1 + dp[(1 << j) ^ i]); \n\t\t\t}\n\t\t\tdp[i] = an; \n\t\t}\n\t}\n\tcout << ans + dp[ans_msk] << '\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <unordered_map>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T> struct CVECTOR {\n\tstd::vector<T> cumsum;\n\tCVECTOR(const std::vector<T>& a) : cumsum(a.size() + 1, 0) {\n\t\tfor (size_t i = 0; i < a.size(); ++i) cumsum[i + 1] = cumsum[i] + a[i];\n\t}\n\tT operator[](int idx) { return cumsum[idx + 1]; }\n};\ntemplate<class T> CVECTOR<T> make_cvector(const std::vector<T>& a) {\n\treturn CVECTOR<T>(a);\n}\n// ------------>8------------------------------------->8------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y, a);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\tg[x[i]].emplace_back(y[i]);\n\t\tg[y[i]].emplace_back(x[i]);\n\t}\n\tstd::vector<std::vector<PAIR>> G(n);\n\tREP(i, n - 1) {\n\t\tG[x[i]].emplace_back(PAIR(y[i], a[i]));\n\t\tG[y[i]].emplace_back(PAIR(x[i], a[i]));\n\t}\n\n\tstd::vector<int> b(n, 0);\n\t{\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (e.first == par) continue;\n\t\t\t\tb[e.first] = e.second;\n\t\t\t\tdfs(e.first, v);\n\t\t\t}\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\n\tstd::vector<int> dp2(1 << 15, INFINT);\n\tdp2[0] = 0;\n\tREP(i, 15) {\n\t\tdp2[1 << i] = 1;\n\t}\n\tstd::function<int(int)> calc = [&](int bit) {\n\t\tif (dp2.at(bit) != INFINT) return dp2.at(bit);\n\n\t\tstd::vector<int> bitv;\n\t\tREP(j, 15) {\n\t\t\tif ((bit >> j) & 1) bitv.emplace_back(j);\n\t\t}\n\t\tREP(j, bitv.size()) FOR(k, j + 1, bitv.size()) {\n\t\t\tint mask = bit;\n\t\t\tmask &= ~(1 << bitv.at(j));\n\t\t\tmask &= ~(1 << bitv.at(k));\n\t\t\tint pos = ((bitv.at(j) + 1) ^ (bitv.at(k) + 1)) - 1;\n\t\t\tif (!IN(0, pos, 15)) {\n\t\t\t\tVAR(int, x);\n\t\t\t}\n\t\t\tif (mask & (1 << pos)) {\n\t\t\t\tCHMIN(dp2.at(bit), calc(mask ^ (1 << pos)) + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCHMIN(dp2.at(bit), calc(mask ^ (1 << pos)) + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp2.at(bit);\n\t};\n\tFOR(i, 3, 1 << 15) {\n\t\tcalc(i);\n\t}\n\n\tstd::vector<PAIR> dp(n, PAIR(0, 0));\n\t{\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\tbool chi = true;\n\t\t\tint mask = b[v], mask2 = 0;\n\t\t\tint cnt = 0;\n\t\t\tstd::set<int> set;\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (to == par) continue;\n\t\t\t\tchi = false;\n\t\t\t\tdfs(to, v);\n\t\t\t\tPAIR p = dp[to];\n\t\t\t\tmask ^= p.first;\n\t\t\t\tif (p.first != 0) {\n\t\t\t\t\tif (set.count(p.first)) {\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\tset.erase(p.first);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tset.insert(p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt += p.second;\n\t\t\t}\n\t\t\tif (chi) {\n\t\t\t\tdp[v] = PAIR(mask, cnt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (auto& x : set) {\n\t\t\t\tmask2 |= 1 << (x - 1);\n\t\t\t}\n\t\t\tcnt += dp2[mask2];\n\t\t\tdp[v] = PAIR(mask, cnt);\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\tOUT(dp[0].second)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint a[maxn];\nint n;\nmap<int,int> mmap;\nint dp[1<<15];\nbool f[1<<15];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n;\n    for(int i = 1 ; i < n ; ++i){\n        int u , v , c;cin >> u >> v >> c;\n        a[u] ^= c;a[v] ^= c;\n    }\n    vector<int> val;\n    for(int i = 0 ; i < n ; ++i){\n        mmap[a[i]]++;\n    }\n    for(int i = 1 ; i < 16 ; ++i){\n        if(mmap[i] & 1)val.pb(i);\n        n -= mmap[i] / 2;\n    }\n    n -= mmap[0];\n    memset(dp,-123,sizeof dp);dp[0] = 0;\n    for(int i = 0 ; i < (1 << val.size()) ; ++i){\n        int cur = 0;\n        for(int j = 0 ; j < val.size() ; ++j){\n            if(i & (1 << j)){\n                cur ^= val[j];\n            }\n        }\n        if(cur == 0)f[i] = 1;\n        for(int j = i ; j > 0 ; j = (j - 1) & i){\n            if(f[j])dp[i] = max(dp[i],dp[i ^ j]+1);\n        }\n    }\n    cout << n  - dp[(1<<val.size())-1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n) - 1; i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << ' ';\\\n    cerr << '\\n'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 1000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nconst int N = 1e5 + 10, S = 16;\nvector<pair<int, int>> e[N];\nint par[N], val[N], tmp[S];\nvector<int> ch[N];\n\nint dp[N][S];\n\nvoid dfs1(int u, int p) {\n    for (auto q : e[u]) {\n        int v = q.fs, a = q.sn;\n        if (v == p) continue;\n        par[v] = u;\n        ch[u].eb(v);\n        val[v] = a;\n        dfs1(v, u);\n    }\n}\n\nvoid dfs2(int u) {\n    dp[u][0] = 0;\n    for (int v : ch[u]) {\n        dfs2(v);\n        forn(i, 0, S) tmp[i] = INF;\n        forn(i, 0, S) forn(j, 0, S) {\n            setmin(tmp[i ^ j], dp[u][i] + dp[v][j]);\n            setmin(tmp[i], dp[u][i] + dp[v][j]);\n            setmin(tmp[j], dp[u][i] + dp[v][j]);\n            setmin(tmp[0], dp[u][i] + dp[v][j]);\n        }\n        //if (tmp[0]) --tmp[0];\n        //forn(i, 0, S) forn(j, 0, S)\n        //    setmin(tmp[j], dp[u][i] + dp[v][j] + 1);\n        forn(i, 0, S) dp[u][i] = tmp[i];\n    }\n    forn(i, 0, S) tmp[i] = INF;\n    forn(i, 0, S) setmin(tmp[i], dp[u][i] + (i != val[u]));\n    forn(i, 0, S) setmin(tmp[val[u]], dp[u][i] + 1);\n    forn(i, 0, S) setmin(tmp[i ^ val[u]], dp[u][i] + 1);\n    forn(i, 0, S) setmin(tmp[0], dp[u][i] + 1);\n    forn(i, 0, S) dp[u][i] = tmp[i];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); \n    srand((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());\n    int n;\n    cin >> n;\n    forn(i, 1, n) {\n        int u, v, a;\n        cin >> u >> v >> a;\n        e[u].eb(v, a);\n        e[v].eb(u, a);\n    }\n    dfs1(0, -1);\n    forn(i, 0, n) forn(j, 0, S) dp[i][j] = INF;\n    dfs2(0);\n    forn(i, 0, n) {\n        //forn(j, 0, S) cout << dp[i][j] << ' ';\n        //cout << '\\n';\n    }\n    int ans = dp[0][0] - 1;\n    forn(i, 1, S) setmin(ans, dp[0][i]);\n    setmax(ans, 0);\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\nusing namespace std;\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 100000;\nint const sigma = 16;\nint v[1 + nmax];\nint dp[1 + (1 << sigma)];\n\nint _add(int &mask, int bit){\n  if(bit == 0)\n    return 0;\n  int cost = 0;\n  if(mask & (1 << bit))\n    cost = 1;\n  mask ^= (1 << bit);\n  return cost;\n}\n\nvector<pair<int,int>> g[1 + (1 << sigma)];\n\nvoid computedp(){\n  for(int mask = 0; mask < (1 << sigma); mask += 2)\n    for(int i = 1; i < sigma; i++)\n      for(int j = i + 1; j < sigma; j++)\n        if((mask & (1 << i)) && (mask & (1 << j)))\n          for(int h = 1; h < sigma; h++){\n            int mask2 = mask ^ (1 << i) ^ (1 << j);\n            int cost = _add(mask2, i ^ h) + _add(mask2, j ^ h) + 1;\n            g[mask2].push_back({mask, cost});\n          }\n\n  for(int mask = 0; mask < (1 << sigma); mask++)\n    dp[mask] = nmax;\n  dp[0] = 0;\n\n  queue<int> q;\n  q.push(0);\n\n  while(0 < q.size()){\n    int node = q.front();\n    q.pop();\n    for(int h = 0; h < g[node].size(); h++){\n      int to = g[node][h].first;\n      int cost = g[node][h].second;\n      if(dp[node] + cost < dp[to]) {\n        dp[to] = dp[node] + cost;\n        q.push(to);\n      }\n    }\n  }\n}\n\nint main()\n{\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  for(int i = 1; i < n; i++){\n    int x, y, cost;\n    cin >> x >> y >> cost;\n    ++x;\n    ++y;\n    v[x] ^= cost;\n    v[y] ^= cost;\n  }\n  int mask = 0;\n  int result = 0;\n\n  for(int i = 1; i <= n; i++){\n    if(v[i] == 0)\n      continue;\n    int bit = (1 << v[i]);\n    if(mask & bit)\n      result++;\n    mask ^= bit;\n  }\n  computedp();\n\n  cout << result + dp[mask];\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n\nconst int MAXN = 100 * 1000 + 23, MXLA = 4 + 1;\n\n\n\n\nint n;\nvector<int> g[MXLA][MAXN];\nset<pii> s;\nbitset<MAXN> mark[MXLA];\n\n\nint dfs(int x, int v, int p = -1) {\n    vector<int> vec;\n    for (auto u : g[x][v])\n        if (u != p)\n            vec.push_back(dfs(x, u, v)); \n    for (int i = 0; i + 1 < vec.size(); i += 2)\n        s.insert({min(vec[i], vec[i + 1]), max(vec[i], vec[i + 1])});\n    if (vec.size() & 1)\n        return vec.back();\n    return v;\n}\n\n\n\n\n\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL), cout.tie(NULL);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        for (int i = 0; i < MXLA; i++)\n            if (w & (1 << i))\n                g[i][v].push_back(u), g[i][u].push_back(v);\n    }\n    for (int i = 0; i < MXLA; i++)\n        for (int j = 0; j < n; j++)\n            if (!mark[i][j])\n                dfs(i, j);\n    cout << s.size();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n#define N 100008\n#define INF 0x3f3f3f3f\n\nint n;\nint dp[N], v[N], p[N];\n\nint dfs(int s)\n{\n    if (!s) return 0;\n    if (dp[s] != INF) return dp[s];\n    for (int i = 0; i <= 15; i++)\n    {\n        for (int j = 0; j <= 15; j++)\n        {\n            if (i == j) continue;\n            if ((s & p[i]) && (s & p[j]))\n            {\n                int temp = i ^ j;\n                if (p[temp] & s)\n                    dp[s] = min(dp[s], dfs(s^p[temp]^p[i]^p[j])+2);\n                else\n                    dp[s] = min(dp[s], dfs(s^p[temp]^p[i]^p[j])+1);\n            }\n        }\n    }\n    return dp[s];\n}\n\nint main()\n{\n    int x, y, z;\n    p[0] = 1;\n    for (int i = 1; i <= 20; i++)\n        p[i] = p[i-1] * 2;\n    while (~scanf(\"%d\", &n))\n    {\n        memset(v, 0, sizeof(v));\n        memset(dp, 0x3f, sizeof(dp));\n        for (int i = 1; i < n; i++)\n        {\n            scanf(\"%d%d%d\", &x, &y, &z);\n            v[x+1] ^= z;\n            v[y+1] ^= z;\n        }\n        int start = 0, ans = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (v[i] == 0) continue;\n            if (start & p[v[i]])\n                ans++;\n            start ^= p[v[i]];                \n        }\n        ans += dfs(start);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nint a[100010];\nint c[16];\nint dp[1<<16];\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint x, y, z;\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x] ^= z;\n\t\ta[y] ^= z;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tc[a[i]]++;\n\t}\n\tvector<int> v;\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += c[i] / 2;\n\t\tif (c[i] & 1) {\n\t\t       v.push_back(i);\n\t\t}\n\t}\n\tint m = v.size();\n\tdp[0] = 0;\n\tfor (int i = 1; i < 1 << m; i++) {\n\t\tint k = 0, x = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tx ^= v[j];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tif (x) {\n\t\t\tdp[i] = 100;\n\t\t} else {\n\t\t\tdp[i] = k - 1;\n\t\t}\n\t\tfor (int j = i; j; j = i & (j - 1)) {\n\t\t\tif (dp[i] > dp[j] + dp[i^j]) {\n\t\t\t\tdp[i] = dp[j] + dp[i^j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1<<m)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 2e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[50], p[50], dp[1 << 18], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 32; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << 16; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint va[N];\nint num[20];\nint a[20],sz,b[1001000];\nint dp[1001000];\nint solve(int s)\n{\n\tif(dp[s]) return dp[s];\n\tdp[s]=1;\n\tfor(int i=s;i;)\n\t{\n\t\ti=(i-1)&s;\n\t\tif(i==0) continue;\n        if(b[i]==0) dp[s]=max(dp[s],solve(i)+solve(s^i));\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tva[u]^=w; va[v]^=w;\n\t}\n\tfor(int i=0;i<n;++i) ++num[va[i]];\n\tint cnt=num[0];\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tcnt+=num[i]/2;\n\t\tif(num[i]&1) a[sz++]=i;\n\t}\n\tfor(int s=0;s<(1<<sz);++s)\n\t\tfor(int i=0;i<sz;++i)\n\t\t\tif(s>>i&1)\n\t\t\t\tb[s]^=a[i];\n\tif(sz)cnt+=solve((1<<sz)-1);\n\tprintf(\"%d\\n\",n-cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nint scan() {\n  int r = 0, c;\n  while ((c = getchar_unlocked()) >= '0')\n    r = r * 10 + c - '0';\n  return r;\n}\n\ninline bool test(const int x, const int y) noexcept { return x & 1 << y; }\n\nint main() {\n  const int n = scan();\n  std::vector<int> v(n, 0);\n  for (int i = 0; i != n - 1; i += 1) {\n    const int x = scan();\n    const int y = scan();\n    const int a = scan();\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n  int ans = n;\n  int b = 0;\n  for (const int e : v) {\n    if (e == 0) {\n      ans -= 1;\n      continue;\n    }\n    if (test(b, e))\n      ans -= 1;\n    b ^= 1 << e;\n  }\n  std::vector<int> dp(b / 2 + 1, -1);\n  dp[b / 2] = 0;\n  for (int s = b; s != 0; s -= 2) {\n    if (dp[s >> 1] == -1)\n      continue;\n    int i = 16;\n    while (i != 0) {\n      i -= 1;\n      if (test(s, i))\n        break;\n    }\n    for (int j = 0; j != i; j += 1) {\n      if (!test(s, j))\n        continue;\n      const int k = i ^ j;\n      if (k > j)\n        continue;\n      int &d = dp[(s ^ 1 << i ^ 1 << j ^ 1 << k) >> 1];\n      if (test(s, k))\n        d = std::max(d, dp[s >> 1] + 1);\n      else\n        d = std::max(d, dp[s >> 1]);\n    }\n  }\n  printf(\"%d\", ans - dp[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar buf[1<<20],*fs,*ft;\ninline char getc()\n{return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))? 0 : *fs++;}\ninline long long read()\n{long long s=0,w=1;char ch=getchar();\nwhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\nwhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\nreturn s*w;}\nchar buf1[1<<21],a1[20];int p11,p12=-1;\ninline void flush()\n{fwrite (buf1,1,p12+1,stdout),p12=-1;}\ninline void print(int x)\n{if(p12>1<<20) flush();if(x<0) buf1[++p12]=45,x=-x;\ndo{a1[++p11]=x%10+48;}while(x/=10);\ndo{buf1[++p12]=a1[p11];}while(--p11);buf1[++p12]='\\n';}\nint n,val[100100],b[20],ans=0,stat=0;\nint sum[(1<<17)],xr[(1<<17)];\nint main()\n{\n\tmemset(b,0,sizeof(b));\n\tmemset(xr,0,sizeof(xr));\n\tmemset(val,0,sizeof(val));\n\tn=read();\n\tint i=1,j=1,k=1;\n\twhile(i<n)\n\t{\n\t\tint u,v,l;\n\t\tu=read();\n\t\tv=read();\n\t\tl=read();\n\t\t++u;\n\t\t++v;\n\t\tval[u]^=l;\n\t\tval[v]^=l;\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<=n)\n\t{\n\t\t++b[val[i]];\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<=15)\n\t{\n\t\tans+=b[i]/2;\n\t\tb[i]%=2;\n\t\tstat|=b[i]<<(i-1);\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<16))\n\t{\n\t\tsum[i]=sum[i>>1]+(i&1);\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<16))\n\t{\n\t\t--sum[i];\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<16))\n\t{\n\t\tj=1;\n\t\twhile(j<=15)\n\t\t{\n\t\t\tif(i&(1<<(j-1))) xr[i]^=j;\n\t\t\t++j;\n\t\t}\n\t\t++i;\n\t}\n\ti=1;\n\twhile(i<(1<<16))\n\t{\n\t\tif(xr[i])\n\t\t{\n\t\t\tk=(i-1)&i;\n        \twhile(k)\n        \t{\n            \tif(xr[k]==0) sum[i]=min(sum[i],sum[k]+sum[i^k]);\n            \tk=(k-1)&i;\n            }\n        }\n\t\t++i;\n\t}\n\tprintf(\"%d\\n\",ans+sum[stat]);\n\treturn 0;\n}\n/*\nBZOJ 1833 ZJOI2010 Count\n??????\nHdu4734 f(x)\nCf 55D Beautiful Number\nCf 388D Fox and Perfect Sets\n2012 Multi-University Training Contest 6 ???â???â?LIS???\nTopCoder Rainbow Graph\nTopCoder CheeseRolling\nAtCoder 058E Iroha and Haiku\nAtCoder XOR Tree\nCodeforces 165E\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstring> \n#include <algorithm> \n#include <cmath> \n\nusing namespace std; \n\n#define N 100010\n#define M 65540\n\nint n, s[N], x, ans, u, v, w; \nint f[M], inf, sum[20]; \n\nint dfs(int S) {\n    if(!S)return 0; \n    if(f[S] < inf) return f[S]; \n    for(int i = 0; i < 16; i++) {\n        if ((S >> i) & 1) {\n            for(int j = 0; j < 16; j++) {\n                if (i != j && (S >> j) & 1) {\n                    int p = i^j, x = S^(1 << i)^(1 << j)^(1 << p); \n                    if (S >> p & 1)f[S] = min(f[S], dfs(x) + 2); \n                    else f[S] = min(f[S], dfs(x) + 1); \n                }\n            }\n        }\n    }   \n    return f[S]; \n}\n\nint main() {\n    scanf(\"%d\",&n); \n    for(int i = 1 ; i < n ; i++) {\n        scanf(\"%d%d%d\",  & u,  & v,  & w); \n        s[u] ^= w, s[v] ^= w; \n    }\n    for(int i = 0 ; i < n ; i++) sum[s[i]]++; \n    for(int i = 1 ; i < 16 ; i++) {\n        ans += (sum[i] >> 1); \n        x += (1 << i) * (sum[i] & 1); \n    }\n    memset(f, 127, sizeof(f)); \n    inf = f[0]; \n    printf(\"%d\\n\", ans + dfs(x)); \n    //system(\"pause\");\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<stack>\n#include<cassert>\n#define F first\n#define S second\n#define mp make_pair\n#define pii pair<int,int>\n#define pb push_back\n#define mem(x,y) memset(x,y,sizeof x)\n#define sqr(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int INF=2e9;\nconst db eps=1e-8;\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0; int f=1; char ch=getchar();\n\twhile( (ch<'0' || ch>'9') && ch!='-') ch=getchar(); if(ch=='-') {f=-1; ch=getchar();}\n\twhile(ch>='0' && ch <='9') x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\n//==========================head template==========================\nconst int N=100010;\nint n;\nint head[N],nxt[N<<1],to[N<<1],co[N<<1],lst=1;\ninline void adde(int x,int y,int c) {\n\tnxt[++lst]=head[x]; to[lst]=y; co[lst]=c; head[x]=lst;\n}\nint fa[N],val[N];\nvoid Build(int u) {\n\tfor(int i=head[u];i;i=nxt[i]) {\n\t\tint v=to[i]; val[u]^=co[i];\n\t\tif(v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tBuild(v);\n\t}\n}\nint num[N],ind=0;\nint ans=0;\nsigned main()\n{\n\tread(n);\n\tfor(int i=1;i<n;i++) {\n\t\tint x,y,c; read(x); read(y); read(c);\n\t\t++x; ++y; adde(x,y,c); adde(y,x,c);\n\t}\n\tBuild(1);//good transfor: edge->point\n\tsort(val+1,val+n+1); val[n+1]=16;\n\tint cnt=1;\n\tfor(int i=2;i<=n+1;i++) {\n\t\tif(val[i]!=val[i-1]) {\n\t\t\tif(val[i-1]) {\n\t\t\t\tans+=cnt/2;\n\t\t\t\tif(cnt&1) num[++ind]=val[i-1];\n\t\t\t}\n\t\t\tcnt=1;\n\t\t} else ++cnt;\n\t}\n\tfor(int i=1;i<ind;i++) {\n\t\tif(num[i] && num[i+1]) {\n\t\t\tnum[i+1]^=num[i]; ++ans;\n\t\t} else {\n\t\t\tif(num[i+1]) swap(num[i],num[i+1]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+(num[ind]!=0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n2\n1 0 0\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxm = 16;\nconst int maxn = 100005;\n\nint read() {\n\tint x = 0, c = getchar();\n\tfor(; !(c > 47 && c < 58); c = getchar());\n\tfor(; (c > 47 && c < 58); c = getchar()) x = x * 10 + c - 48;\n\treturn x;\n}\n\nint n;\nint b[maxn];\nint mark[maxm];\nint f[1 << maxm];\nint g[1 << maxm];\n\nint main(){\n\tn = read();\n\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint u = read(), v = read(), w = read();\n\t\tb[u] ^= w, b[v] ^= w;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tif(b[i] == 0) {\n\t\t\t++ ans; continue;\n\t\t}\n\t\tif(mark[b[i]]) {\n\t\t\tmark[b[i]] = 0;\n\t\t\t++ ans; continue;\n\t\t}\n\t\tmark[b[i]] = 1;\n\t}\n\n\n\tvector<int> v;\n\tfor(int i = 0; i < maxm; ++ i) if(mark[i]) {\n\t\tv.emplace_back(i);\n\t\tf[1 << ((int)v.size() - 1)] = i;\n\t}\n\n\tint m = (int)v.size();\n\tfor(int mask = 1; mask < (1 << m); ++ mask) {\n\t\tint bit = __builtin_ctz(mask);\n\t\tf[mask] = f[mask ^ (1 << bit)] ^ f[1 << bit];\n\t}\n\n\tmemset(g, -69, sizeof g), g[0] = 0;\n\tfor(int mask = 1; mask < (1 << m); ++ mask)\n\t\tfor(int s = mask; s > 0; s = (s - 1) & mask)\n\t\t\tif(f[s] == 0) g[mask] = max(g[mask], g[mask ^ s] + 1);\n\n\tcout << n - g[(1 << m) - 1] - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint d[N],n,ct[20],Ans,F[N],S[N];\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tfor(int i=1;i<(1<<16);i++)\n\t\tF[i]=F[i-(i&-i)]^(__builtin_popcount((i&-i)-1));\n\t// for(int i=0;i<=10;i++) printf(\"%d\\n\",F[i]);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read()+1, v=read()+1, w=read();\n\t\td[u]^=w; d[v]^=w;\n\t}\n\t// for(int i=1;i<=n;i++) printf(\"%d \",d[i]); puts(\"\");\n\tfor(int i=1;i<=n;i++) ct[d[i]]++;\n\t// for(int i=1;i<16;i++) printf(\"%d \",ct[i]); puts(\"\");\n\tfor(int i=1;i<16;i++) Ans+=ct[i]/2,ct[i]&=1;\n\t// memset(S,0x3f,sizeof S); S[0]=0;\n\tfor(int i=1;i<(1<<16);i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\tif(!F[j]) S[i]=max(S[i],S[i^j]+1);\n\t}\n\tint Ret=0; for(int i=1;i<16;i++) Ret|=(ct[i]<<i);\n\t// cout << Ret << endl;\n\tcout << Ans+__builtin_popcount(Ret)-S[Ret] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int N = 1e5 + 5, M = (1 << 15);\nint val[N], cnt[N], sum[M], f[M];\nint main() {\n\tint n; scanf(\"%d\", &n); \n    for (int i = 1; i < n; ++i) {\n        int x, y, z; scanf(\"%d%d%d\", &x, &y, &z); \n        val[++x] ^= z, val[++y] ^= z; \n    }\n    for (int i = 1; i <= n; ++i) cnt[val[i]]++; \n    int ans = n - cnt[0], mask = 0;\n    for (int i = 1; i <= 15; ++i) {\n        ans -= cnt[i] / 2 ; \n        mask |= (cnt[i] & 1) << (i - 1); \n    }\n    for (int i = 0; i < (1 << 15); ++i) \n        for (int j = 1; j <= 15; ++j) \n            if (i & (1 << (j - 1))) sum[i] ^= j; \n    for (int i = 1; i < (1 << 15); ++i) \n        for (int j = i; j; j = (j - 1) & i) \n            if (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1); \n    printf(\"%d\\n\", ans - f[mask]); \n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nvector<int> gay;\n\nint Dfs(int msk) {\n  if (!msk) return 0;\n  assert((msk & -msk) != msk);\n  int &res = gay[msk];\n  if (res) return res;\n  res = 2233;\n  for (int i = 0; i < 16; ++i) {\n    if (msk >> i & 1) {\n      for (int j = i + 1; j < 16; ++j) {\n        if (msk >> j & 1) {\n          int g = i ^ j;\n          res = min(res, 1 + (msk >> g & 1) + Dfs(msk ^ (1 << i) ^ (1 << j) ^ (1 << g)));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n;\n  cin >> n;\n  Vec w(n), cnt(16);\n  \n  for (int i = 1, x, y, z; i < n; ++i) {\n    cin >> x >> y >> z;\n    w[x] ^= z;\n    w[y] ^= z;\n  }\n  for (int i = 0; i < n; ++i) {\n    ++cnt[w[i]];\n  }\n\n  int ans = 0, msk = 0;\n  for (int i = 1; i < 16; ++i) {\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n    msk |= cnt[i] << i;\n  }\n\n  gay.resize(1 << 16);\n  cout << ans + Dfs(msk) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;vi v[N];\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=(j+1);\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n\t\t}\n\t}\n\treturn;\n}\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=1<<(i-1);\n\t\t}\n\t}\n\tinit();\n\tfor(int i=0;i<=mask;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9,mod=1e9+7;\ntypedef long long ll;\nint read() {\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n\treturn x*f;\n}\nusing namespace std;\nint val[1000001],f[1000001],cnt[20],vis[1000001],js,x,y,z,ans,n,len=(1<<15);\nint main() {\n\tn=read(),len=(1<<15);\n\tfor(int i=1; i<n; i++)\n\t\tx=read(),y=read(),z=read(),val[x]^=z,val[y]^=z;\n\tfor(int i=0; i<n; i++)\n\t\tcnt[val[i]]++;\n\tfor(int i=1; i<=15; i++)\n\t\tans+=cnt[i]/2,js|=(cnt[i]&1)<<(i-1);\n\tfor(int i=1; i<len; i++)\n\t\tf[i]=f[i>>1]+(i&1);\n\tfor(int i=1; i<len; i++)\n\t\tf[i]--;\n\tfor(int i=1; i<len; i++)\n\t\tfor(int j=0; j<15; j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tvis[i]^=(j+1);\n\tfor(int i=1; i<len; i++) {\n\t\tif(vis[i]) continue;\n\t\tfor(int k=(i-1)&i; k; k=(k-1)&i)\n\t\t\tif(!vis[k])\n\t\t\t\tf[i]=min(f[i],f[k]+f[i^k]);\n\t}\n\tprintf(\"%d\",ans+f[js]);\n\treturn 0;\n}//da"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<int>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005,M=1<<16|2;\nint ans,a[N],dp[M],ycl[M];\nvector<PI> v[N];\nint dfs(int p,int fa){\n\tint sum=0; \n\tint zt=0;\n\tfor(auto i:v[p])if(i.fi!=fa){\n\t\tint t=dfs(i.fi,p);\n\t\tt^=i.se; sum^=t;\n\t\tif(zt>>t&1)ans--; zt^=1<<t;\n\t}\n\t//cout<<p<<\" \"<<zt<<\" \"<<dp[zt]<<endl;\n\tans-=dp[zt];\n\treturn sum;\n}\nint main(){\n\tint n=ans=read(); ans--;\n\tFor(i,1,n-1){\n\t\tint x=read(),y=read(),t=read();\n\t\tv[x].pb(mp(y,t)); v[y].pb(mp(x,t));\n\t}\n\tFor(i,0,(1<<16)-1){\n\t\tFor(j,0,15)if(i>>j&1)ycl[i]^=j;\n\t}\n\tFor(i,1,(1<<16)-1){\n\t\tfor(int j=i;j;j=(j-1)&i)if(!ycl[j])dp[i]=max(dp[i^j]+1,dp[i]);\n\t}\n\tdfs(0,0);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    for(Int i=0;i<16;i++){\n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\tInt dif=bc[i&j]-1;\n\tInt nb=b^(1<<i)^(1<<j);\n\tauto fix=\n\t  [&](Int y){\n\t    nb^=1<<y;\n\t    if((nb>>y)&1) return;\n\t    dif+=max<Int>(0,bc[y]-1);\n\t  };\n\tfix(i^(i&j));\n\tfix(j^(i&j));\n\tassert(calc(nb)<calc(b));\n\tif(dp[nb]>=dp[b]+dif) continue;\n\tdp[nb]=dp[b]+dif;\n\tpq.emplace(calc(nb),nb);\n      }\n    }\n  }\n  \n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n\n#define MP std::make_pair\n#define rep(i, l, r) for (int i = (l); i <= (r); ++ i)\n#define per(i, r, l) for (int i = (r); i >= (l); -- i)\n#define PE(x, a) for (int x = head[a]; x;x = edge[x].next)\n#define pb push_back\n#define CL(a, b) memset(a, b, sizeof a)\n#define PII std::pair<int, int>\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 7;\nconst int INF = 0x7f7f7f7f;\n\nint cnt[20];\nint head[MAXN], n, sum[MAXN];\nint f[(1 << 18) + 7];\n\nstruct Edge {\n\tint w, t, next;\n} edge[MAXN << 1];\n\ninline void add(int u, int v, int w) {\n\tstatic int cnt = 0;\n\tedge[++cnt] = (Edge){w, v, head[u]}; head[u] = cnt;\n}\n\nvoid init(int u, int pre) {\n\tPE(e, u) {\n\t\tint v = edge[e].t;\n\t\tif (v == pre) continue;\n\t\tsum[v] ^= edge[e].w;\n\t\tsum[u] ^= edge[e].w;\n\t\tinit(v, u);\n\t}\n\tcnt[sum[u]]++;\n}\n\nint dfs(int s) {\n\tif (f[s] != INF) return f[s];\n\tint &ret = f[s];\n\trep(i, 1, 15) if (s & (1 << i))\n\trep(j, 1, 15) if (i != j && (s & (1 << j))) {\n\t\tif (s & (1 << (i ^ j))) ret = std::min(ret, 2 + dfs(s ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j))));\n\t\telse ret = std::min(ret, 1 + dfs(s ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j))));\n\t}\n\treturn f[s];\n}\n\nint main() {\n\tCL(f, 0x7f);\n\tscanf(\"%d\", &n);\n\tint u, v, w;\n\trep(i, 1, n - 1) scanf(\"%d %d %d\", &u, &v, &w), u++, v++, add(u, v, w), add(v, u, w);\n\tinit(1, 0);\n//\trep(i, 1, n) {\n//\t\tprintf(\"sum[%d] = %d\\n\", i, sum[i]);\n//\t}\n\t\n\tint st = 0, ans = 0;\n\trep(i, 1, 15) {\n\t\tans += (cnt[i] / 2);\n\t\tcnt[i] &= 1;\n\t\tif (cnt[i]) st |= (1 << i);\n\t}\n\tf[0] = 0;\n\tprintf(\"%d\\n\", ans + dfs(st));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#define Rand() ((rand() << 15) + rand())\n#else\n#define LLFORMAT \"ll\"\n#define Rand() (rand())\n#endif\n\nusing namespace std;\n\nconst int maxn = 1e5 + 10, maxm = (1 << 16) | 10;\n\nint n, ans;\nint dp[maxm], cnt[20], a[maxn];\n\nvoid upd(int &x, int y) {\n\tx = x < y ? x : y;\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\t++u;\n\t\t++v;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\t++cnt[a[i]];\n\t}\n\tmemset(dp, 0x3f, sizeof dp);\n\tint s = 0;\n\tfor (int x = 1; x < 16; ++x) {\n\t\tdebug(\"cnt[%d] = %d\\n\", x, cnt[x]);\n\t\tans += cnt[x] >> 1;\n\t\ts |= (cnt[x] & 1) << x;\n\t}\n\tdp[s] = ans;\n\tfor (int t; s; --s) {\n\t\tif((t = dp[s]) <= n) {\n\t\t\tdebug(\"dp[%d] = %d\\n\", s, t);\n\t\t\tfor (int x = 1; x < 16; ++x) {\n\t\t\t\tif((s >> x) & 1) {\n\t\t\t\t\tfor (int y = 1; y < x; ++y) {\n\t\t\t\t\t\tif((s >> y) & 1) {\n\t\t\t\t\t\t\tupd(dp[s ^ ((1 << x) | (1 << y) | (1 << (y ^ x)))], t + 1 + ((s >> (y ^ x)) & 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[0]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[32768];\nint gg[32768];\n\nint root = 0;\nint p[100001];\nint x[100001];\n\n\nvector< pair<int, int> > g[100001];\nint cnt[16];\n\nvoid dfs(int me){\n    for(auto &nxt: g[me]){\n        if(nxt.first == p[me]) continue;\n        p[nxt.first] = me;\n        x[nxt.first] = nxt.second;\n        dfs(nxt.first);\n        x[me] ^= x[nxt.first];\n    }\n    if(me > 0) cnt[x[me]]++;\n}\n\nint rec(int now){\n    if(~dp[now]) return dp[now];\n    int bst = 0;\n    for(int i=1;i<=15;i++){\n        if(now & (1 << (i-1))){\n            for(int j=1;j<=15;j++){\n                if(i == j) continue;\n                int nxt = now - (1 << (i-1));\n                nxt ^= (1 << (j-1));\n                nxt ^= (1 << ((i^j)-1));\n                if(gg[nxt] < gg[now]){\n                    if(gg[now] - gg[nxt] == 3){\n                        bst = max(bst, 1 + rec(nxt));\n                    }else{\n                        bst = max(bst, rec(nxt));\n                    }\n                }\n            }\n        }\n    }\n    dp[now] = bst;\n    //printf(\"%d %d\\n\", now, bst);\n    return bst;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        int aa, bb, cc;\n        scanf(\"%d%d%d\",&aa,&bb,&cc);\n        g[aa].push_back({bb, cc});\n        g[bb].push_back({aa, cc});\n    }\n    p[0] = 0;\n    dfs(0);\n    int ans = 0;\n    for(int i=0;i<32768;i++){\n        dp[i] = -1;\n        for(int j=0;j<15;j++){\n            if(i &(1 << j)) gg[i]++;\n        }\n    }\n    for(int i=1;i<16;i++){\n        ans += cnt[i] / 2;\n        root += (1 << (i-1)) * (cnt[i] % 2);\n    }\n    //printf(\"%d\\n\", root);\n    printf(\"%d\\n\", ans + gg[root] - rec(root));\n}\n"
  },
  {
    "language": "C++",
    "code": "///****In the name of Allah, most Gracious, most Compassionate****//\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\n#define ALL(a) a.begin(), a.end()\n#define FastIO ios::sync_with_stdio(false); cin.tie(nullptr);cout.tie(nullptr)\n#define IN freopen(\"input.txt\",\"r+\",stdin)\n#define OUT freopen(\"output.txt\",\"w+\",stdout)\n\n#define DBG(a) cout<< #a <<\" --> \"<<(a)<<endl\n#define NL cout<<\"\\n\"\n\ntemplate < class T1,class T2>\nostream &operator <<(ostream &os,const pair < T1,T2 > &p)\n{\n    os<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return os;\n}\n\nconst int N=3e5+5;\nconst int oo=1e9+7;\n\nint cnt[N];\nint val[N];\nint dp[1<<16];\nint rec(int mask)\n{\n    if(mask==0) return 0;\n    if(dp[mask]!=-1) return dp[mask];\n    int &ret = dp[mask]  = oo;\n    for(int j=1; j<=15; j++)\n    {\n        if(mask & (1<<j) == 0) continue;\n        for(int k=j+1; k<=15; k++)\n        {\n            if(mask &(1<<k)  )\n            {\n//                DBG(mask & (1<<k));\n                int to = j^k;\n                int tomask = mask^(1<<j)^(1<<k);\n\n\n                bool jog =tomask&(1<<to);\n                tomask = tomask^(1<<to);\n//                DBG(mask);\n//                DBG(tomask);\n//\n//                DBG(j);\n//                DBG(k);\n//                DBG(to);\n//                DBG(bitset<16> (mask));\n//                DBG(bitset<16> (tomask));\n//                NL;\n//                assert(__builtin_popcount(mask)> __builtin_popcount(tomask));\n                ret = min(ret, 1 + rec(tomask) + jog);\n            }\n        }\n    }\n    return ret;\n}\nint32_t main()\n{\n    FastIO;\n    int n;\n    cin>>n;\n    for(int i=1; i<=n-1; i++)\n    {\n        int u,v,a;\n        cin>>u>>v>>a;\n        val[u]^=a;\n        val[v]^=a;\n    }\n//    for(int i=0; i<n; i++) cout<<val[i]<<\" \";\n//    NL;\n    for(int i=0; i<n; i++)\n        cnt[val[i]]++;\n\n    int ans  = 0, mask = 0, jor = 0;\n    for(int i=1; i<=15; i++)\n    {\n        ans+=cnt[i]/2;\n        cnt[i]%=2;\n        if(cnt[i])\n            mask|=(1<<i), jor^=i;\n    }\n    memset(dp ,  -1 , sizeof dp);\n    ans+=rec(mask);\n    cout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nint z[MC];\nint c[MC];\nint dp[1<<16];\n\nint solve(int s){\n\tif(~dp[s]) return dp[s];\n\tdp[s] = 123456789;\n\trepp(i,2,16) if(s&(1<<i)){\n\t\trepp(j,1,i) if(s&(1<<j)){\n\t\t\trepp(k,1,16){\n\t\t\t\tint w = 1;\n\t\t\t\tif(s&(1<<(i^k))) ++w;\n\t\t\t\tif(s&(1<<(j^k))) ++w;\n\t\t\t\tint t = s ^ (1<<i) ^ (1<<j) ^ (1<<(i^k)) ^ (1<<(j^k));\n\t\t\t\tif(s>t) dp[s] = min(dp[s],solve(t)+w);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s];\n}\n\nint main(){\n\tcin >> N;\n\trepp(i,1,N){\n\t\tint x,y,a;\n\t\tcin >> x >> y >> a;\n\t\tz[x] ^= a;\n\t\tz[y] ^= a;\n\t}\n\trepp(i,0,N) ++c[z[i]];\n\tint ans = 0;\n\tint s = 0;\n\trepp(i,1,16){\n\t\tans += c[i]/2;\n\t\tif(c[i]%2==1) s |= (1<<i);\n\t}\n\tfill(dp,dp+(1<<16),-1);\n\tdp[0] = dp[1] = 0;\n\tcout << ans + solve(s) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint a[N],c[N];\nint n,m,v[20];\nint f[N],ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z; a[y]^=z;\n\t}\n\tfor (int i=0;i<n;i++)\n\t\tc[a[i]]++;\n\tfor (int i=1;i<16;i++){\n\t\tans+=c[i]/2;\n\t\tif (c[i]&1) v[m++]=i;\n\t}\n\tf[0]=0;\n\tfor (int i=1;i<1<<m;i++){\n\t\tint k=0,x=0;\n\t\tfor (int j=0;j<m;j++)\n\t\t\tif ((i>>j)&1){\n\t\t\t\tx^=v[j];\n\t\t\t\tk++;\n\t\t\t}\n\t\tf[i]=(x?100:k-1);\n\t\tfor (int p=i-(i&(-i)),j=p;;j=(j-1)&p){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t\tif (!j) break; \n\t\t}\n\t}\n\tprintf(\"%d\",ans+f[(1<<m)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1000000007;\nconst int N=200005,E=524288;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nint n,m,i,j,k,u,v,w,f[250005],g[250005],d[250005],num[250005],s,ans,pp[250005],p[250005],t;\nbool cmp(int a,int b)\n{\n\treturn pp[a]<pp[b];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\t++u,++v;\n\t\td[u]^=w,d[v]^=w;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\t++num[d[i]];\n\tfor(i=0;i<16;++i)\n\t{\n\t\tif(i!=0)\n\t\t\tans+=num[i]/2;\n\t\tnum[i]&=1;\n\t\ts|=num[i]<<i;\n\t}\n\tfor(i=0;i<(1<<16);++i)\n\t{\n\t\tp[i]=i;\n\t\tfor(j=0;j<16;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\t++pp[i];\n\t}\n\tsort(p,p+(1<<16));\n\tfor(t=0;t<(1<<16);++t)\n\t{\n\t\ti=p[t];\n\t\tif(i==0||i==1)\n\t\t{\n\t\t\tf[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tf[i]=1000000007;\n\t\tfor(j=1;j<16;++j)\n\t\t\tfor(k=1;k<16;++k)\n\t\t\t\tif(j!=k)\n\t\t\t\t\tif(((i>>j)&1)&&((i>>k)&1))\n\t\t\t\t\t\tf[i]=min(f[i],f[i^(1<<j)^(1<<k)^(1<<(j^k))]+1+((i>>(j^k))&1));\n\t}\n\tcout<<ans+f[s];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    os << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<pair<int,int>>> G(N);\n    for (int i=0;i<N-1;++i){\n        int x,y,a; cin >> x >> y >> a;\n        G[x].emplace_back(y,a);\n        G[y].emplace_back(x,a);\n    }\n    vector<int> cnt(16,0);\n    auto dfs=[&](auto self,int v,int p,int a)->void{\n        for (auto e:G[v]){\n            int u=e.first;\n            if (u==p) continue;\n            self(self,u,v,e.second);\n            a^=e.second;\n        }\n        ++cnt[a];\n    };\n    dfs(dfs,0,-1,0);\n    int bit=0,ans=0;\n    for (int i=1;i<16;++i){\n        ans+=cnt[i]>>1;\n        bit|=(cnt[i]&1)<<i;\n    }\n    vector<int> dp(1<<16,20);\n    dp[0]=0;\n    for (int mask=1;mask<(1<<16);++mask){\n        int XOR=0;\n        for (int i=0;i<16;++i){\n            if (mask&1<<i) XOR^=i;\n        }\n        if (XOR) continue;\n        for (int i=1;i<16;++i){\n            for (int j=i+1;j<16;++j){\n                if (!(mask&1<<i)||!(mask&1<<j)) continue;\n                for (int k=1;k<16;++k){\n                    int nmask=mask,pre=1;\n                    nmask^=1<<i; nmask^=1<<j;\n                    if (nmask&1<<(i^k)) ++pre;\n                    nmask^=1<<(i^k);\n                    if (nmask&1<<(j^k)) ++pre;\n                    nmask^=1<<(j^k);\n                    if (nmask&1) nmask^=1;\n                    if (nmask>mask) continue;\n                    dp[mask]=min(dp[mask],dp[nmask]+pre);\n                }\n            }\n        }\n    }\n    cout << ans+dp[bit] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 100100;\n\nvector<pair<int, int>> E[MAX];\n\nint a[MAX];\n\nvoid Dfs(int x, int prev, int dad) {\n  a[x] = prev;\n  for (auto& p: E[x]) {\n    int y = p.first;\n    int w = p.second;\n    if (y != dad) {\n      Dfs(y, w, x);\n      a[x] ^= a[y];\n    }\n  }\n}\n\nconst int MAXB = 1<<16;\n\nint f[MAXB];\n\nint Solve(int mask) {\n  if (f[mask] != -1) return f[mask];\n  if (mask == 0) return f[mask] = 0;\n\n  f[mask] = 100000;\n  REP(x, 16) {\n    if (mask & (1<<x)) {\n      f[mask] = min(f[mask], Solve(mask ^ (1<<x)) + 1);\n      REP(y, x) {\n        if (mask & (1<<y)) {\n          int nmask = mask ^ (1<<x) ^ (1<<y);\n          int cost = 1;\n          int z = x ^ y;\n          if (nmask & (1<<z)) cost++;\n          nmask ^= 1<<z;\n          f[mask] = min(f[mask], cost + Solve(nmask));\n        }\n      }\n    }\n  }\n\n  return f[mask];\n}\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N-1) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    E[a].push_back({b, c});\n    E[b].push_back({a, c});\n  }\n\n  Dfs(0, 0, -1);\n\n  int mask = 0;\n  int ret = 0;\n  FOR(i, 1, N) {\n    if (a[i] == 0) continue;\n    if (mask & (1<<a[i])) {\n      ret++;\n    }\n    mask ^= 1 << a[i];\n  }\n  memset(f, -1, sizeof(f));\n  ret += Solve(mask);\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for ( int i=1; i<=int(n); i++ )  \n#define MP make_pair\n#define PB push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n#define X first\n#define Y second\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef long double LD;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <class T>  \ninline bool RD(T &ret) {  \n        char c; int sgn;  \n        if (c = getchar(), c == EOF) return 0;  \n        while (c != '-' && (c<'0' || c>'9')) c = getchar();  \n        sgn = (c == '-') ? -1 : 1 , ret = (c == '-') ? 0 : (c - '0');  \n        while (c = getchar(), c >= '0'&&c <= '9') ret = ret * 10 + (c - '0');  \n        ret *= sgn;  \n        return 1;  \n}  \ntemplate <class T>  \ninline void PT(T x) {  \n        if (x < 0) putchar('-') ,x = -x;  \n        if (x > 9) PT(x / 10);  \n        putchar(x % 10 + '0');  \n}\n\nconst int N = 1e5 + 100;\n\nvector<int> G[N];\nint val[N];\nint cnt[20];\nint dp[1 << 20];\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i < n; i ++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u ++, v ++;\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n\n    int ans = n;\n    for(int i = 1; i <= n; i ++) cnt[val[i]] ++;\n\n    vector<int> v;\n    v.clear();\n    for(int i = 0; i <= 15; i ++) {\n        if(! i) ans -= cnt[i];\n        else {\n            ans -= cnt[i] / 2;\n            if(cnt[i] % 2) v.push_back(i);\n        }\n    }\n\n    int sz = SZ(v);\n    dp[0] = 0;\n    for(int mask = 1; mask < (1 << sz); mask ++) {\n        for(int sub = mask; sub; sub = (sub - 1) & mask) {\n            int cur = 0;\n            for(int i = 0; i < sz; i ++) {\n                if((sub >> i) & 1) cur ^= v[i];\n            }\n            if(cur == 0) dp[mask] = max(dp[mask], dp[sub] + 1);\n        }\n    }\n    ans -= dp[(1 << sz) - 1];\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int uint;\ntypedef pair <int, int> pii;\ntypedef unsigned long long uLL;\n\ntemplate <typename T> inline void Read(T &x) {\n  char c = getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n\ntemplate <typename T> inline bool CheckMax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n\ntemplate <typename T> inline bool CheckMin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n\nconst int N = 100005;\n\nint n, m, ans, a[N], b[N], c[N], f[N];\n\nint main() {\n#ifdef wxh010910\n  freopen(\"d.in\", \"r\", stdin);\n#endif\n  Read(n);\n  for (int i = 1, x, y, w; i < n; ++i) {\n    Read(x), Read(y), Read(w);\n    a[x] ^= w, a[y] ^= w;\n  }\n  for (int i = 0; i < n; ++i) {\n    ++c[a[i]];\n  }\n  for (int i = 1; i < 16; ++i) {\n    ans += c[i] >> 1;\n    if (c[i] & 1) {\n      b[m++] = i;\n    }\n  }\n  for (int i = 1; i < 1 << m; ++i) {\n    int s = 0;\n    for (int j = 0; j < m; ++j) {\n      if (i >> j & 1) {\n        s ^= b[j];\n      }\n    }\n    if (s) {\n      f[i] = m;\n    } else {\n      f[i] = __builtin_popcount(i) - 1;\n    }\n    for (int j = s = (1 << m) - 1 ^ i; j; j = j - 1 & s) {\n      CheckMin(f[i], f[j] + f[i ^ j]);\n    }\n  }\n  printf(\"%d\\n\", ans + f[(1 << m) - 1]);\n#ifdef wxh010910\n  Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e5 + 10;\n\nint n;\nint p[MAXN];\nint mask[MAXN];\nint cnt[MAXN][16];\nvector <pair <int, int>> adj[MAXN];\n\nvoid dfs(int u, int parent) {\n    p[u] = parent;\n    for (auto v : adj[u]) {\n        if (v.first != parent)\n            dfs(v.first, u);\n        else\n            mask[u] = v.second;\n    }\n}\n\nvoid calc(int u) {\n    int val = 0;\n    for (auto v : adj[u]) {\n        if (v.first == p[u])\n            continue;\n        calc(v.first);\n        val ^= v.second;\n        for (int i = 1; i < 16; i++)\n            cnt[u][i] += cnt[v.first][i];\n    }\n    cnt[u][mask[u] ^ val]++;\n\n    /*\n    cout << u << \":\";\n    for (int i = 1; i < 16; i++)\n        cout << \" \" << cnt[u][i];\n    cout << endl;\n    */\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, a;\n        cin >> u >> v >> a;\n        adj[u].push_back({v, a});\n        adj[v].push_back({u, a});\n    }\n\n    int root = 0;\n    while (root < n && adj[root].size() > 1)\n        root++;\n    dfs(root, -1);\n    calc(root);\n    // cout << \"r: \" << root << endl;\n\n    int total = 0;\n    // matched\n    for (int i = 1; i < 16; i++) {\n        // cout << i << \": \" << cnt[root][i] << endl;\n        total += cnt[root][i] / 2;\n        cnt[root][i] %= 2;\n    }\n\n    // merge\n    while (true) {\n        bool found = false;\n        for (int i = 1; i < 16; i++)\n            for (int j = i + 1; j < 16; j++)\n                if (cnt[root][i] > 0 && cnt[root][j] > 0) {\n                    total += 1;\n                    cnt[root][i]--;\n                    cnt[root][j]--;\n                    cnt[root][i ^ j]++;\n                    found = true;\n                }\n        if (!found)\n            break;\n    }\n\n    // leftover\n    for (int i = 1; i < 16; i++)\n        if (cnt[root][i] > 0) {\n            total++;\n            cnt[root][i]--;\n        }\n\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, x, y, z, ans, f[1 << 15], a[100100], c[20];\nvector<int> o;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x] ^= z, a[y] ^= z;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tc[a[i]]++;\n\tfor(int i = 1; i <= 15; i++) {\n\t\tans += c[i] / 2;\n//\t\tprintf(\"%d %d\\n\", i, c[i]);\n\t\tif(c[i] & 1) o.push_back(i);\n\t}\n\tf[0] = 0;\n\tfor(int i = 1; i < (1 << o.size()); i++) {\n\t\tint x = 0, k = 0;\n\t\tfor(int j = 0; j < o.size(); j++)\n\t\t\tif(i & (1 << j)) x ^= o[j], k++;\n\t\tf[i] = x ? 19260817 : k - 1;\n//\t\tif(i == 7) printf(\"%d\\n\", (1 << o.size()) - 1);\n\t\tfor(int j = i - (i & -i); j; j = (i - (i & -i)) & (j - 1))\n\t\t\tf[i] = min(f[i], f[j] + f[j ^ i]);\n\t}\n\tprintf(\"%d\\n\", f[(1 << o.size()) - 1] + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans;\nint dp(int s)\n{\n\tif(!s)\n\t\treturn 0;\n\tif(f[s]<0x3f3f3f3f)\n\t\treturn f[s];\n\tfor(int i=0;i<=15;i++)\n\t{\n\t\tif(!(s&(1<<i)))\n\t\t\tcontinue;\n\t\tfor(int j=0;j<=15;j++)\n\t\t{\n\t\t\tif(i==j||!(s&(1<<j)))\n\t\t\t\tcontinue;\n\t\t\tint k=i^j;\n\t\t\tint t=s^(1<<i)^(1<<j)^(1<<k);\n\t\t\tif(s&(1<<k))\n\t\t\t\tf[s]=min(f[s],dp(t)+2);\n\t\t\telse\n\t\t\t\tf[s]=min(f[s],dp(t)+1);\n\t\t}\n\t}\n\treturn f[s];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tprintf(\"%d\",ans+dp(s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\n#define N 200007\n\nint n , num[20] , val[N] ;\nint C[N] , Cnt[N] ;\n\nint main()\n{\n    scanf(\"%d\" , &n ) ;\n    for(int i = 1 ; i <= n - 1 ; i++ ){ int u , v , w ; scanf(\"%d%d%d\" , &u , &v , &w ) ; val[u] ^= w , val[v] ^= w ;  }\n    for(int i = 0 ; i <= n - 1 ; i++ ) num[val[i]]++ ;\n    int ans = 0 , ed = 0 ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ){\n        for(int j = 0 ; j < 15 ; j++ ) if( i & ( 1 << j ) ) C[i] = C[i] | ( j + 1 ) ;\n    }\n    for(int i = 1 ; i <= 15 ; i++ ) ans += num[i] / 2 ;\n    for(int i = 1 ; i <= 15 ; i++ ) if( num[i] & 1 ) ed |= ( 1 << ( i - 1 ) ) ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ) Cnt[i] = Cnt[i >> 1] + ( i & 1 ) ;\n    for(int i = 1 ; i < ( 1 << 15 ) ; i++ ){\n        Cnt[i]-- ;\n        if( C[i] ) continue ;\n        for(int k = ( i - 1 ) & i ; k ; k = ( k - 1 ) & i ){\n            if( C[k] == 0 ) Cnt[i] = min( Cnt[i ^ k] + Cnt[k] , Cnt[i] ) ;\n        }\n    }\n    printf(\"%d\\n\" , ans + Cnt[ed] ) ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5, M = 15;\n\nint A[N], C[M + 1], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 0; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 0; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tint x = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) C[A[i]] ^= A[i], cnt += !C[A[i]];\n\tfor (int i = 1; i <= M; i++) if (C[i]) x ^= (1 << (i - 1));\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//apc_1f\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint val[100504],bot[25];\nint f[32770];\nint getone(int k){\n\tint res=0;\n\twhile(k)res+=(k&1),k>>=1;\n\treturn res;\n}\n#define maxS 32768\n#define pii pair<int,int>\n#define fst first\n#define sec second\npii s[32770];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,a;\n\t\tscanf(\"%d%d%d\",&x,&y,&a);\n\t\tval[x]^=a,val[y]^=a;\n\t}\n\t//for(int i=0;i<n;i++)cout<<val[i]<<' ';cout<<endl;\n\t\n\tfor(int i=0;i<n;i++)bot[val[i]]++;\n\tint ans=0;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=bot[i]/2;\n\t\tbot[i]=(bot[i]&1);\n\t}\n\tint st=0;\n\tfor(int i=1;i<=15;i++)st|=(bot[i]<<(i-1));\n\t\n\tmemset(f,0x3f,sizeof(f));\n\tf[st]=0;\n\tfor(int i=0;i<=st;i++)s[i].fst=getone(i),s[i].sec=i;\n\tsort(s,s+st+1,greater<pii>());\n\t//for(int i=0;i<=st;i++)cout<<s[i].sec<<' ';cout<<endl;\n\t//cout<<st<<endl;\n\t\n\tfor(int i=0;i<=st;i++){\n\t\tint e=s[i].sec;\n\t\tfor(int j=1,_j=1;j<=e;j<<=1,_j++){\n\t\t\tfor(int k=1,_k=1;k<=e;k<<=1,_k++){\n\t\t\t\tif(j==k||(e&j)==0||(e&k)==0)continue;\n\t\t\t\tint a=(e^j^k),b=(1<<((_j^_k)-1) );\n\t\t\t\tif(!(a&b))f[a|b]=min(f[a|b],f[e]+1);\n\t\t\t\telse f[a^b]=min(f[a^b],f[e]+2);\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<=st;i++)cout<<f[i]<<' ';cout<<endl;\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstring> \n#include <algorithm> \n#include <cmath> \n\nusing namespace std; \n\n#define N 100010\n#define M 65540\n\nint n, s[N], x, ans, u, v, w; \nint f[M], inf, sum[20]; \n\nint dfs(int S) {\n    if(!S)return 0; \n    if(f[S] < inf) return f[S]; \n    for(int i = 0; i < 16; i++) {\n        if ((S >> i) & 1) {\n            for(int j = 0; j < 16; j++) {\n                if (i != j && (S >> j) & 1) {\n                    int p = i^j, x = S^(1 << i)^(1 << j)^(1 << p); \n                    if (S >> p & 1)f[S] = min(f[S], dfs(x) + 2); \n                    else f[S] = min(f[S], dfs(x) + 1); \n                }\n            }\n        }\n    }   \n    return f[S]; \n}\n\nint main() {\n    scanf(\"%d\",&n); \n    for(int i = 1 ; i < n ; i++) {\n        scanf(\"%d%d%d\",  & u,  & v,  & w); \n        s[u] ^= w, s[v] ^= w; \n    }\n    for(int i = 0 ; i < n ; i++) sum[s[i]]++; \n    for(int i = 1 ; i < 16 ; i++) {\n        ans + = (sum[i] >> 1); \n        x + = (1 << i) * (sum[i] & 1); \n    }\n    memset(f, 127, sizeof(f)); \n    inf = f[0]; \n    printf(\"%d\\n\", ans + dfs(x)); \n    //system(\"pause\");\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nint A[MAXN], C[16], DP[1 << 16];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = 0;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tREP(i, n)\n\t\t++C[A[i]];\n\tFOR(i, 1, 16)\n\t{\n\t\tans += C[i] >> 1;\n\t\tC[i] &= 1;\n\t}\n\tFOR(i, 1, 1 << 16)\n\t\tDP[i] = INF;\n\tDP[0] = 0;\n\tFOR(mask, 1, 1 << 16)\n\t{\n\t\tRFOR(pos, 16, 1)\n\t\t{\n\t\t\tif (mask & (1 << pos))\n\t\t\t\tFOR(submask, 1, pos)\n\t\t\t{\n\t\t\t\tif ((pos | submask) == pos)\n\t\t\t\t{\n\t\t\t\t\tint cur = bool(mask & (1 << submask));\n\t\t\t\t\tcur += bool(mask & (1 << (pos ^ submask)));\n\t\t\t\t\tDP[mask] = min(DP[mask],\n\t\t\t\t\t\tcur + DP[mask ^ (1 << pos) ^ (1 << submask) ^ (1 << (pos ^ submask))]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint mask = 0;\n\tREP(i, 16)\n\t\tif (C[i] & 1)\n\t\t\tmask |= (1 << i);\n\tcout << ans + DP[mask];\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[s[i]]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define chmin(a,b) if(a>b)a=b\nconst int N=1e5+5;\nconst int M=16;\n\nint n,ans;\nint a[N],cnt[M];\nbool ok[1<<M];\nint dp[1<<M];\n\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[a[i]]++;\n\tint mask=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]>>1;\n\t\tif(cnt[i]&1) mask|=1<<i;\n\t}\n\tfor(int i=1;i<=15;i++)\n\t\tdp[1<<i]=1;\n\tfor(int i=0;i<mask;i+=2)\n\t{\n\t\tint X=0;\n\t\tfor(int j=1;j<=15;j++)\n\t\t\tif(i>>j&1) X^=j;\n\t\tif(!X) ok[i]=1;\n\t}\n\tmemset(dp,60,sizeof(dp));\n\tdp[0]=0;\n\tfor(int i=1;i<=15;i++)\n\t\tdp[1<<i]=1;\n\tfor(int i=0;i<=mask;i+=2)\n\tfor(int j=i;j;j=(j-1)&i)\n\t\tif(ok[j]) chmin(dp[i],dp[i-j]+__builtin_popcount(j)-1);\n\tprintf(\"%d\\n\",ans+dp[mask]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n;\nvector<vector<int> > data, money;\nint ans;\nvoid dfs(int vertex, int last, int bit, int reb){\n    int pol = 0;\n    for (int i=0; i < data[vertex].size(); i++){\n        int to = data[vertex][i];\n        if (to==last) continue;\n        int ba = (1LL<<bit)&money[vertex][i];\n        if (ba == 0){\n            dfs(to, vertex, bit, 0);\n        }\n        else{\n            dfs(to, vertex, bit, 1);\n            pol++;\n        }\n    }\n    ans -= pol / 2;\n    if (pol%2==0&&reb)ans++;\n}\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    for (int i=0; i < n; i++){\n        vector<int> h1, h2;\n        data.push_back(h1);\n        money.push_back(h2);\n    }\n    for (int i=0; i < n-1; i++){\n        int a, b, c;\n        cin >> a >> b >> c;\n        data[a].push_back(b);\n        data[b].push_back(a);\n        money[a].push_back(c);\n        money[b].push_back(c);\n    }\n    ans = 0;\n    for (int bit=0; bit < 4; bit++){\n        dfs(0, -1, bit, 0);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int inf = 1e9,maxn=3e5+5,maxs=(1<<16) + 5;\n\nint n,cnt[maxn],w[maxn],ans;\nint goodst[maxs], dp[maxs];\n\nint main(){\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\tw[x] ^= z;w[y] ^= z;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)++cnt[w[i]];\n\tfor(int i=1;i<=n;i++)\n\t\tans += cnt[i]/2, cnt[i]%=2;\n\tint lim=0;for(int i=0;i<=15;i++)lim |= (cnt[i] == 0?0:(1<<i)), ans += (cnt[i]!=0);\n\tfor(int S=0;S<=(1<<16)-1;S++){\n\t\tint x=0;\n\t\tfor(int i=0;i<=15;i++)\n\t\t\tif(S&(1<<i))x^=i;\n\t\tgoodst[S] = 0;if(x==0)goodst[S] = 1;\n\t}\n\t\n\tfor(int S=0;S<=(1<<16)-1;S++){\n\t\tif(S&1)continue;\n\t\tfor(int T=S;T;T=(T-1)&S){\n\t\t\tif(goodst[T])\n\t\t\t\tdp[S] = max(dp[S], dp[S^T]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans-dp[lim]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, a[N], cnt[M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\n\tbool done = false;\n\twhile (done == false) {\n\t\tdone = true;\n\t\tfor (int i = 1; i < M; i++)\n\t\t\tfor (int j = i; j < M; j++)\n\t\t\t\tif ((i & j) && cnt[i] && cnt[j] && (i != j || cnt[i] >= 2)) {\n\t\t\t\t\tdone = false;\n\t\t\t\t\tcnt[i]--;\n\t\t\t\t\tcnt[j]--;\n\t\t\t\t\tcnt[i ^ (i & j)]++;\n\t\t\t\t\tcnt[j ^ (i & j)]++;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10;  \n\nint n, ans, state, tot; \nint val[maxn], cnt[20], f[maxm], s[maxn], sum[maxm]; \n// sumè¡¨ç¤ºæ¯ä¸ªéåçå¼æå¼\nint main() {\n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z; \n\t\tscanf(\"%d%d%d\", &x, &y, &z); \n\t\tx++, y++; \n\t\tval[x] ^= z, val[y] ^= z; \n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[val[i]]++; \n\tans = n; ans -= cnt[0]; \n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans -= cnt[i] / 2 ; \n\t\tstate |= (cnt[i] & 1) << (i - 1); \n\t}\n\ttot = 1 << 15; \n\tfor (int i = 0; i < tot; ++i) {\n\t\tint tmp = 0; \t\n\t\tfor (int j = 1; j <= 15; ++j) {\n\t\t\tif ((i >> (j - 1)) & 1) tmp ^= j; \n\t\t}\n\t\tsum[i] = tmp; \n\t}\n\tfor (int i = 1; i < tot; ++i) {\n\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\tif (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1); \n\t\t}\n\t}\n\tans -= f[state]; \n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\nconst int maxn=100005;\nint N,A[maxn],G[16],opt,F[65536],Ans;\ninline void read(int &Res){\n\tchar ch=getchar();\n\tfor (Res=0;!isdigit(ch);ch=getchar());\n\tfor (;isdigit(ch);ch=getchar()) Res=(Res<<3)+(Res<<1)+ch-48;\n}\nvoid DFS(int o,int w){\n\tif (w>=F[o]) return;\n\tF[o]=w;\n\tfor (int i=1;i<16;++i) if ((o>>i)&1)\n\t\tfor (int j=1;j<16;++j) if ((i^j)&&((o>>j)&1)) DFS(o^(1<<i)^(1<<j)^1^(1<<(i^j)),w+1+((o>>(i^j))&1));\n}\nint main(){\n\tread(N),memset(F,63,sizeof F);\n\tfor (int i=1,x,y,z;i<N;++i) read(x),read(y),read(z),A[x]^=z,A[y]^=z;\n\tfor (int i=0;i<N;++i) ++G[A[i]];\n\tfor (int i=1;i<16;++i) Ans+=G[i]>>1,opt|=(G[i]&1)<<i;\n\treturn DFS(opt,0),printf(\"%d\",Ans+(*F<F[1]?*F:F[1])),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n#define pi acos(-1.0)\n#define maxd 1000000007\ntypedef long long ll;\nint n,dp[1001000],xo[1001000],cnt[1001000],ans=0,w[1001000];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n\twhile ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n\treturn x*f;\n}\n\nint main()\n{\n\tn=read();memset(w,0,sizeof(w));int i,j;\n\tfor (i=1;i<n;i++) \n\t{\n\t\tint u=read(),v=read(),w1=read();\n\t\tw[u]^=w1;w[v]^=w1;\n\t}\n\tfor (i=0;i<n;i++) cnt[w[i]]++;\n\tint ans=0,now=0;\n\tfor (i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;now|=(cnt[i]&1)<<(i-1);\n\t}\n\tint all=(1<<15)-1;\n\tfor (i=1;i<=all;i++) dp[i]=dp[i>>1]+(i&1);\n\tfor (i=1;i<=all;i++) dp[i]--;\n\tfor (i=0;i<=all;i++)\n\t{\n\t\txo[i]=0;\n\t\tfor (j=1;j<=15;j++)\n\t\t{\n\t\t\tif ((i>>(j-1))&1) xo[i]^=j;\n\t\t}\n\t}\n\tfor (i=1;i<=all;i++)\n\t{\n\t    if (xo[i]) continue;\n\t\tfor (j=i;j;j=(j-1)&i)\n\t\t{\n\t\t    if (!xo[j]) dp[i]=min(dp[i],dp[j]+dp[j^i]);\n\t\t}\n\t}\n\tans+=dp[now];\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define lson l,(l+r)/2,rt<<1\n#define rson (l+r)/2+1,r,rt<<1|1\n#define dbg(x) cout<<#x<<\" = \"<< (x)<< endl\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define sz(x) (int)(x).size()\nconst int mxn=1e5+10;\nint b[mxn];\nint cnt[16];\nint a[20];\nint sz=0;\nint dp[mxn];\nbool check(int mask){\n\tint x=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(mask &(1<<i))x^=a[i];\n\t}\n\treturn x==0;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\tb[u]^=w;\n\t\tb[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcnt[b[i]]++;\n\t}\n\tint component=cnt[0];\n\tfor(int i=1;i<16;i++){\n\t\tcomponent+=cnt[i]/2;\n\t\tif(cnt[i]%2)a[sz++]=i;\n\t}\n\tint up=(1<<sz)-1;\n\tfor(int i=1;i<=up;i++){\n\t\tif(check(i))dp[i]=dp[i^up]+1;\n\t}\n\tcout<<n-component-dp[up];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int maxN = 1e5 + 10;\nint nodeN, tot;\nint val[maxN], cntHas[maxN], dp[1 << 16], num[20], xorSum[1 << 16];\n\nint main () {\n\tscanf(\"%d\", &nodeN);\n\tfor (int nodeI = 1; nodeI < nodeN; ++nodeI) {\n\t\tint n1, n2, len;\n\t\tscanf(\"%d%d%d\", &n1, &n2, &len);\n\t\t++n1, ++n2;\n\t\tval[n1] ^= len;\n\t\tval[n2] ^= len;\n\t}\n\tfor (int nodeI = 1; nodeI <= nodeN; ++nodeI) ++cntHas[val[nodeI]];\n\tint ans = 0;\n\tfor (int valI = 1; valI < 16; ++valI) {\n\t\tans += cntHas[valI] >> 1;\n\t\tcntHas[valI] &= 1;\n\t\tif (cntHas[valI] != 0) {\n\t\t\tnum[++tot] = valI;\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\txorSum[stI] ^= num[weiJ + 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] > 0) {\n\t\t\tdp[stI] = 0x3f3f3f3f;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int weiJ = 0; weiJ < tot; ++weiJ) {\n\t\t\tif ((stI & (1 << weiJ)) != 0) {\n\t\t\t\t++dp[stI];\n\t\t\t}\n\t\t}\n\t\t--dp[stI];\n\t}\n\tfor (int stI = 0; stI < (1 << tot); ++stI) {\n\t\tif (xorSum[stI] != 0) continue;\n\t\tfor (int son = stI & (stI - 1); son; son = stI & (son - 1)) {\n\t\t\tif (xorSum[son] == 0) {\n\t\t\t\tdp[stI] = min(dp[stI], dp[stI ^ son] + dp[son]);\n\t\t\t}\n\t\t}\n\t}\n\tans += dp[(1 << tot) - 1];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef  long long LL;\ntypedef  unsigned long long ULL;\ntypedef  double db;\ntypedef  long double ld;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define fuck(x) cout<<x<<endl\n#define fuck1(x,y) cout<<x<<\" \"<<y<<endl\n#define lson root<<1,l,mid\n#define rson root<<1|1,mid+1,r\n#define MP(a,b) make_pair(a,b)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\nconst int INF = 0x3f3f3f3f3f,mod = 1e9+7,maxn = 3e5+100;\nconst double eps  =1e-6,PI = acos(-1);\ntemplate<typename T> inline void read(T &x){\n    x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\nint N,val[maxn],cnt[20];\nint d[maxn],ss[maxn];\nint main(){\n    read(N);\n    for(int i = 0;i<N-1;i++){\n        int x,y,a;\n        read(x),read(y),read(a);\n        val[x]^=a;\n        val[y]^=a;\n    }\n    for(int i = 0;i<N;i++){\n        if(val[i])cnt[val[i]]++;\n    }\n    int ans = 0,st = 0;\n    for(int i = 0;i<16;i++){\n        ans+=cnt[i]/2;\n        if(cnt[i]&1)st = st|(1<<i);\n    }\n    for(int i = 1;i<=(1<<15);i++)d[i] = d[i>>1]+(i&1);\n    for(int i = 1;i<=(1<<15);i++)d[i]--;\n    for(int i = 1;i<=(1<<15);i++){\n        for(int j = 1;j<=15;j++){\n            if(i&(1<<j))ss[i]^=(j);\n        }\n    }\n    for(int i = 1;i<=(1<<15);i++){\n        if(ss[i]!=0)continue;\n        for(int k = (i-1)&i;k;k = (k-1)&i){\n            if(ss[k]==0)d[i] = min(d[i],d[k]+d[i^k]);\n        }\n    }\n    printf(\"%d\\n\",ans+d[st]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint ans,a[N],xx,y,v,n,cc[17],c[N],q;\ninline int dfs(int x){\n\tif(!x)return 0;\n\tif(c[x])return c[x];\n\tc[x]=999999;\n\tint i,j,k,r1,r2,uu=0,y;\n\tfor(i=1;i<=15;++i){\n\t\tuu+=((1<<i)&x)>0;\n\t}\n\tif(uu==1){\n\t\tc[x]=1;\n\t\treturn 1;\n\t}\n\tfor(i=1;i<=15;++i){\n\t\tif((1<<i)&x){\n\t\t\tfor(j=i+1;j<=15;++j){\n\t\t\t\tif((1<<j)&x){\n\t\t\t\t\tfor(k=1;k<=3;++k){\n\t\t\t\t\t\tuu=1;y=x;\n\t\t\t\t\t\tr1=j^k;r2=i^k;\n\t\t\t\t\t\ty-=(1<<j);\n\t\t\t\t\t\ty-=(1<<i);\n\t\t\t\t\t\tif(r1>0){\n\t\t\t\t\t\tif(((1<<r1)&y)){\n\t\t\t\t\t\t\ty-=(1<<r1);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(r2>0){\n\t\t\t\t\t\tif(((1<<r2)&y)){\n\t\t\t\t\t\t\ty-=(1<<r2);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc[x]=min(c[x],dfs(y)+uu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c[x];\n}\nint i;\nint main(){\n\tcin>>n;\n\tfor(i=1;i<n;++i){\n\t\tcin>>xx>>y>>v;\n\t\ta[xx]^=v;\n\t\ta[y]^=v;\n\t}\n\tfor(i=0;i<n;++i)++cc[a[i]];\n\tfor(i=1;i<=15;++i){\n\t\tans+=cc[i]/2;\n\t\tq+=((cc[i]&1)<<i);\n\t}\n\tcout<<ans+dfs(q);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n#define eps 1e-8\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 + c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nstruct node {\n    int to,next,val;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nint C[MAXN],cnt[25],f[(1 << 15) + 5],siz[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].val = c;\n    head[u] = sumE;\n}\nvoid dfs(int u,int fa) {\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            C[v] ^= E[i].val;\n            dfs(v,u);\n            siz[u] ^= siz[v];\n        }\n    }\n    C[u] ^= siz[u];\n    siz[u] ^= C[u];\n}\nvoid Solve() {\n    read(N);\n    int x,y,a;\n    for(int i = 1 ; i < N ; ++i) {\n        read(x);read(y);read(a);\n        add(x,y,a);add(y,x,a);\n    }\n    dfs(0,-1);\n    for(int i = 1 ; i < N ; ++i) {\n        cnt[C[i]]++;\n    }\n    int ans = 0,q = 0;\n    for(int i = 1 ; i <= 15 ; ++i) {\n        ans += cnt[i] / 2;\n        cnt[i] %= 2;\n        if(cnt[i]) q |= 1 << (i - 1);\n    }\n    for(int i = 1 ; i < (1 << 15) ; ++i) {\n        int a = 0,c = 0;\n        for(int j = 1 ; j <= 15 ; ++j) {\n            if(i >> (j - 1) & 1) {\n                a ^= j;\n                ++c;\n            }\n        }\n        if(!a) f[i] = c - 1;\n        else f[i] = c;\n    }\n    for(int S = 1 ; S < (1 << 15) ; ++S) {\n        for(int T = (S - 1) & S ; T ; T = (T - 1) & S) {\n            f[S] = min(f[S],f[T] + f[S ^ T]);\n        }\n    }\n    ans += f[q];\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nint N;\nmap<int, vector<pint>> edges;\n\nvector<int> xors;\n\nint next_combination(int comb)\n{\n    int x = comb & -comb, y = comb + x;\n    return ((comb & ~y) / x >> 1) | y;\n}\n\nconstexpr int D = 15;\n\nint main()\n{\n    cin >> N;\n    REP(i, N - 1)\n    {\n        int x, y, a;\n        cin >> x >> y >> a;\n        edges[x].emplace_back(y, a);\n        edges[y].emplace_back(x, a);\n    }\n    xors.resize(N);\n    REP(i, N) for (auto e : edges[i]) xors[i] ^= e.second;\n\n    vector<int> cou(D);\n    for (auto v : xors) if (v) cou[v - 1]++;\n\n    vector<int> dp(POW2(D), 100);\n    dp[0] = 0;\n\n    FOR(npop, 3, D + 1)\n    {\n        int S = POW2(npop) - 1;\n        while (S < POW2(D))\n        {\n            int d1 = __builtin_ffs(S);\n            REP(d, D) if (S & POW2(d)) if (d != d1)\n            {\n                int new_a = ((d + 1) xor (d1 + 1)) - 1;\n                if (S & POW2(new_a)) mmin(dp[S], dp[S xor POW2(d) xor POW2(d1) xor POW2(new_a)] + 2);\n                else mmin(dp[S], dp[S xor POW2(d) xor POW2(d1) xor POW2(new_a)] + 1);\n            }\n            S = next_combination(S);\n        }\n    }\n    int ans = 0;\n    int S = 0;\n    REP(i, D)\n    {\n        ans += cou[i] / 2;\n        S += POW2(i) * (cou[i] % 2);\n    }\n    cout << ans + dp[S] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define MOD 1000000007\n#define PMOD 998244353\n#define pb(x) push_back(x)\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> plii;\ntypedef pair<int, pii> piii;\nconst int INF = 1e9+10;\nconst ll LINF = 1LL*INF*INF;\nconst int MAXN = 2e5+10;\nconst int MAXM = 5e3+10;\n\npriority_queue<int> pq;\nvector<vector<int> > graph;\nqueue<int> que;\n\nint A[MAXN];\nint cal[30];\nint dp[(1<<16)];\nint val[(1<<16)];\n\nint main()\n{\n    int n,m,k,a,b,x,y,q;\n    int sum = 0;\n    int cnt = 0;\n    int mx = 0;\n    int mn = INF;\n    int cur = 0, idx = -1;\n    int tc;\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin>>n;\n\n    for(int i=1;i<n;i++)\n    {\n        cin>>x>>y>>a;\n        A[x]^=a;\n        A[y]^=a;\n    }\n\n    for(int i=0;i<n;i++){\n        cal[A[i]]++;\n    }\n\n    int res = 0;\n    int vv = 0;\n\n    for(int i=1;i<=15;i++){\n        res+=(cal[i]>>1);\n        if(cal[i]&1)vv|=(1<<(i-1));\n    }\n\n    for(int i=1;i<(1<<15);i++)\n        dp[i] = dp[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)\n        dp[i]--;\n\n    for(int i=1;i<(1<<15);i++){\n        for(int j=0;j<15;j++){\n            if(i&(1<<j)){\n                val[i]^=(j+1);\n            }\n        }\n    }\n\n    for(int i=1;i<(1<<15);i++){\n        if(val[i])continue;\n\n        cur = i;\n\n        for(int j=0;j<15;j++){\n            if(i&(1<<j)){\n                cur^=(1<<j);\n                if(!val[cur]){\n                    dp[i] = min(dp[i],dp[cur]+dp[cur^i]);\n                }\n            }\n        }\n\n    }\n\n    res+=dp[vv];\n\n    cout<<res<<\"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nint N;\nvector<int> x, y, a;\nmap<int, vector<pint>> edges;\n\nvector<int> dp;\nint dfs(int now, int prv, int val = 0)\n{\n    dp[now] = val;\n    for (auto nxt : edges[now]) if (nxt.first != prv)\n    {\n        dp[now] = dp[now] xor dfs(nxt.first, now, nxt.second);\n    }\n    return dp[now];\n}\n\n// Solve ax+by=gcd(a, b)\nlint extgcd(lint a, lint b, lint &x, lint &y)\n{\n    lint d = a;\n    if (b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    else x = 1, y = 0;\n    return d;\n}\n// Calc a^(-1) (MOD m)\nlint mod_inverse(lint a, lint m)\n{\n    lint x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\nvector<vector<lint>> gauss_jordan(vector<vector<lint>> mtr, lint mod)\n{\n    // Gauss-Jordan elimination è¡åºæ¬å¤å½¢ã®ã¿ãç¨ããã¬ã¦ã¹æ¶å»æ³\n    int H = mtr.size(), W = mtr[0].size(), c = 0;\n    REP(h, H)\n    {\n        if (c == W) break;\n        int piv = -1;\n        FOR(j, h, H) if (mtr[j][c])\n        {\n            if (piv == -1 or abs(mtr[j][c]) > abs(mtr[piv][c])) piv = j;\n        }\n        if (piv == -1) { c++; h--; continue; }\n        swap(mtr[piv], mtr[h]);\n        if (h != piv) REP(w, W) mtr[piv][w] = mtr[piv][w] ? mod - mtr[piv][w] : 0; // è¡åå¼ç¬¦å·ä¸å¤\n        lint pivinv = mod_inverse(mtr[h][c], mod);\n        FOR(hh, h + 1, H) IFOR(w, c, W) mtr[hh][w] = (mtr[hh][w] - mtr[h][w] * mtr[hh][c] % mod * pivinv % mod + mod) % mod;\n        c++;\n    }\n    return mtr;\n}\n\n\nint main()\n{\n    cin >> N;\n    x.resize(N - 1);\n    y.resize(N - 1);\n    a.resize(N - 1);\n    dp.resize(N);\n    REP(i, N - 1)\n    {\n        cin >> x[i] >> y[i] >> a[i];\n        edges[x[i]].emplace_back(y[i], a[i]);\n        edges[y[i]].emplace_back(x[i], a[i]);\n    }\n    dfs(0, -1);\n    vector<int> cou(16);\n    for (auto v : dp) cou[v]++;\n    int ans = 0;\n    cou[0] = 0;\n    for (auto &c : cou)\n    {\n        ans += c / 2;\n        c %= 2;\n    }\n\n    vector<vector<lint>> mat(cou.size(), vector<lint>(4));\n    int nok = 0;\n    REP(i, cou.size()) if (cou[i])\n    {\n        nok++;\n        REP(d, 4) mat[i][d] = ((POW2(d) & i) != 0);\n    }\n\n    auto mat2 = gauss_jordan(mat, 2);\n    int rank = 0;\n    REP(h, mat2.size()) for (auto v : mat2[h]) if (v) mmax(rank, h + 1);\n    ans += rank - 1 + (nok - rank + 2) / 2;\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXBITS=4;\nvoid printmask(int mask) { printf(\"[\"); bool fst=true; FOR(j,1,1<<MAXBITS) if(mask&(1<<j)) { if(fst) fst=false; else printf(\",\"); printf(\"%d\",j); } printf(\"]\"); }\n\nint n;\nvector<pair<int,int> > adj[MAXN];\n\npair<int,int> solve(int at,int par) {\n\tpair<int,int> ret=MP(0,0);\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i].first; if(to==par) continue;\n\t\tpair<int,int> cur=solve(to,at);\n\t\tret.first+=cur.first;\n\t\tint sum=adj[at][i].second;\n\t\tFOR(j,1,1<<MAXBITS) if(cur.second&(1<<j)) {\n\t\t\tsum^=j;\n\t\t\tif(ret.second&(1<<j)) ++ret.first;\n\t\t\tret.second^=1<<j;\n\t\t}\n\t\tif(sum!=0) {\n\t\t\tif(ret.second&(1<<sum)) ++ret.first;\n\t\t\tret.second^=1<<sum;\n\t\t}\n\t}\n\t//printf(\"%d: %d,\",at,ret.first); printmask(ret.second); puts(\"\");\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n-1) { int a,b,c; scanf(\"%d%d%d\",&a,&b,&c); adj[a].PB(MP(b,c)); adj[b].PB(MP(a,c)); }\n\n\tpair<int,int> res=solve(0,-1);\n\tint ans=res.first,mask=res.second;\n\tREP(i,MAXBITS) {\n\t\tint fst=-1;\n\t\tFOR(j,1,1<<MAXBITS) if(mask&(1<<j)) if(j&(1<<i)) { if(fst==-1) fst=j; else mask^=(1<<j),mask|=1<<(j^fst); }\n\t\tif(fst!=-1) ++ans,mask^=1<<fst;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,num[100010],tot[100010],ok[100010],dp[100010];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;num[b]^=c;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(num[i]==0) cnt++;\n\t\telse tot[num[i]]++;\n\t}\n\tvector<int> v;\n\tfor(int i=1;i<=15;i++){\n\t\tcnt+=tot[i]/2;\n\t\tif(tot[i]%2==1){\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tif(v.empty()){\n\t\tcout<<n-cnt<<endl;\n\t\treturn 0;\n\t}\n\tint len=v.size();\n\tfor(int i=0;i<(1<<len);i++){\n\t\tint sum=0;\n\t\tfor(int j=1;j<=len;j++) if(i&(1<<(j-1))){\n\t\t\tsum^=v[j-1];\n\t\t}\n\t\tif(sum==0) ok[i]=1;\n\t}\n\tfor(int i=0;i<(1<<len)-1;i++){\n\t\tint mask=((1<<len)-1)^i;\n\t\tfor(int j=mask;j>0;j=(j-1)&mask) if(ok[j]){\n\t\t\tdp[i|j]=max(dp[i|j],dp[i]+1);\n\t\t}\n\t}\n\tcout<<n-cnt-dp[(1<<len)-1]<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10; \nconst int inf = 0x3f3f3f3f; \n\nint n, ans, state; \nint v[maxn], cnt[20], f[maxm]; \n\nint dp(int s) {\n\tif (!s) return 0; \n\tif (f[s] < inf) return f[s]; \n\tfor (int i = 0; i <= 15; ++i) {\n\t\tif (!(s & (1 << i))) continue; \n\t\tfor (int j = 0; j <= 15; ++j) {\n\t\t\tif (i == j || !(s & (1 << j))) continue; \n\t\t\tint x = i ^ j; \n\t\t\tint y = s ^ (1 << i) ^ (1 << j) ^ (1 << x); \n\t\t\tif (s & (1 << x)) f[s] = min(f[s], dp(y) + 2); \n\t\t\telse f[s] = min(f[s], dp(y) + 1); \n\t\t}\n\t}\n\treturn f[s]; \n}\n\nint main() {\n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z; \n\t\tscanf(\"%d%d%d\", &x, &y, &z); \n\t\tx += 1, y += 1; \n\t\tv[x] ^= z; v[y] ^= z; \n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[v[i]]++; \n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans += (cnt[i] >> 1); \n\t\tstate += (cnt[i] & 1) * (1 << i); \n\t}\n\tmemset(f, 0x3f, sizeof(f)); \n\tprintf(\"%d\\n\", ans + dp(state)); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define lson l,(l+r)/2,rt<<1\n#define rson (l+r)/2+1,r,rt<<1|1\n#define dbg(x) cout<<#x<<\" = \"<< (x)<< endl\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define sz(x) (int)(x).size()\nconst int mxn=1e5+10;\nint b[mxn];\nint cnt[16];\nint a[20];\nint sz=0;\nint dp[mxn];\nbool flag[mxn];\ninline void check(int mask){\n\tint x=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(mask &(1<<i))x^=a[i];\n\t}\n\tflag[x]= (x==0);\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\tb[u]^=w;\n\t\tb[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcnt[b[i]]++;\n\t}\n\tint component=cnt[0];\n\tfor(int i=1;i<16;i++){\n\t\tcomponent+=cnt[i]/2;\n\t\tif(cnt[i]%2)a[sz++]=i;\n\t}\n\tint up=(1<<sz)-1;\n\tfor(int i=1;i<=up;i++){\n\t\tcheck(i);\n\t\tfor(int x=i;x;x=((x-1)&i)){\n\t\t\tif(flag[i])dp[i]=max(dp[i],1+dp[x^i]);\n\t\t}\n\t}\n\tcout<<n-component-dp[up];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int inf=1010101010;\nstruct Edge{\n\tint to,next,val;\n}e[2020202];\nint head[1010101],cnt=0;\nvoid add(int u,int v,int w)\n{\n\tcnt++;\n\te[cnt].to=v;\n\te[cnt].next=head[u];\n\te[cnt].val=w;\n\thead[u]=cnt;\n}\nint cal[22];\nint dfs(int x,int fa)\n{\n\tint ret=0;\n\tfor(int i=head[x];i!=0;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=fa)\n\t\t{\n\t\t\tint tmp=dfs(to,x);\n\t\t\tcal[e[i].val^tmp]++;\n\t\t\tret^=e[i].val;\n\t\t}\n\t}\n\treturn ret;\n}\nint dp[1010101],p[33];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tu++;\n\t\tv++;\n\t\tadd(u,v,w);\n\t\tadd(v,u,w);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cal[i]/2;\n\t\tcal[i]%=2;\n\t}\n\tint nn=0;\n\tfor(int i=1;i<=15;i++)\n\tif(cal[i]==1)\n\t{\n\t\tnn++;\n\t\tp[nn]=i;\n\t}\n\tfor(int i=0;i<(1<<nn);i++)\n\t\tdp[i]=inf;\n\tdp[0]=0;\n\tfor(int i=0;i<(1<<nn);i++)\n\t{\n\t\tint tmp=0;\n\t\tfor(int j=1;j<=nn;j++)\n\t\tif((i&(1<<(j-1)))!=0)\n\t\t\ttmp^=p[j];\n\t\tfor(int j=1;j<=nn;j++)\n\t\tif((i&(1<<(j-1)))==0)\n\t\t{\n\t\t\tif((tmp^p[j])==0)\n\t\t\t\tdp[(i|(1<<(j-1)))]=min(dp[(i|(1<<(j-1)))],dp[i]);\n\t\t\telse\n\t\t\t\tdp[(i|(1<<(j-1)))]=min(dp[(i|(1<<(j-1)))],dp[i]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+dp[(1<<nn)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[20],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 1e5 + 20;\n\nint t[maxn];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b , c;\n\t\tcin >> a >> b >> c;\n\n\t\tt[a] ^= c;\n\t\tt[b] ^= c;\n\t}\n\n\tvector<pair<int , int> > shit;\n\n\tfor(int mask = 1; mask < 16; mask++)\n\t\tshit.pb({__builtin_popcount(mask) , mask});\n\n\tsort(shit.begin() , shit.end());\n\treverse(shit.begin() , shit.end());\n\n\tint res = 0;\n\tfor(auto ind : shit)\n\t{\n\t\tint mask = ind.second;\n\t\tint last = -1;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif((mask&t[i]) == mask)\n\t\t\t{\n\t\t\t\tif(last == -1)\n\t\t\t\t\tlast = i;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tres++;\n\t\t\t\t\tt[last] ^= mask;\n\t\t\t\t\tt[i] ^= mask;\n\t\t\t\t\tlast = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int NMAX = 1e5;\nint n;\nint b[NMAX + 5];\nint dp[(1 << 15)];\n\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i = 1;i < n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tx++;\n\t\ty++;\n\t\tb[x] ^= z;\n\t\tb[y] ^= z;\n\t}\n\t\n\tint ans = n;\n\tint mask = 0;\n\t\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(b[i] == 0){\n\t\t\tans--;\n\t\t}\n\t\telse if((mask >> (b[i] - 1)) & 1){\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t\tans--;\n\t\t}\n\t\telse{\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t}\n\t}\n\t\t\n\tdp[0] = 0;\n\t\n\tfor(int i = 1;i <= mask;i++){\n\t\tdp[i] = -(1 << 28);\n\t\tfor(int j = i;j;j = (j - 1) & i){\n\t\t\tint xo = 0;\n\t\t\t\n\t\t\tfor(int b = 0;b < 15;b++){\n\t\t\t\tif((j >> b) & 1){\n\t\t\t\t\txo ^= b;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(xo == 0){\n\t\t\t\tdp[i] = max(dp[i],1 + dp[i ^ j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans -= dp[mask];\n\t\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint DP(int now) {\n\tif(dp[now] != -1) return dp[now];\n\tdp[now] = 1e9;\n\tfor (int i = 0; i < 15; ++i) {\n//\t\tif(!(now & (1 << i))) continue;\n\t\tfor (int j = i + 1; j < 15; ++j) {\n//\t\t\tif(!(now & (1 << j))) continue;\n\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n//\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n\t\t\tint f;\n\t\t\tif(((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1)))) f = 1;\n\t\t\telse f = 0;\n\t\t\tdp[now] = min(dp[now] , DP(nnow) + 1 + f);\n\t\t}\n\t}\n\treturn dp[now];\t\n}\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\" , a[i]);\n\t\tif(!a[i]) continue;\n\t\tif(S & (1 << (a[i] - 1))) ans ++;\n\t\tS ^= (1 << (a[i] - 1));\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , -1 , sizeof dp);\n\tdp[0] = 0;\n\tans += DP(S);\n//\tfor (int now = 1; now < (1 << 15); ++now) {\n//\t\tfor (int i = 0; i < 15; ++i) {\n////\t\t\tif(!(now & (1 << i))) continue;\n//\t\t\tfor (int j = i + 1; j < 15; ++j) {\n////\t\t\t\tif(!(now & (1 << j))) continue;\n//\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n////\t\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n//\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1))));\n//\t\t\t}\n//\t\t}\n//\t}\n\tprintf(\"%d\" , ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\nbool book[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tn=1<<15;\n\trp(i,1,n-1)d[i]=d[i>>1]+(i&1);rp(i,1,n-1)d[i]-=1;\n\trp(i,1,n-1){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n\tfor(int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sxr[i]!=0)continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t\tif(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n\t}\n\tprintf(\"%d\",res+d[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\nint i, dp[1<<15], j, x, y, z, n, m, xr, val[Nmax], cnt[20], ans;\nvector<int> v;\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> n;\n    for(i=1; i<n; ++i)\n    {\n        cin >> x >> y >> z;\n        val[x] ^= z; val[y] ^= z;\n    }\n\n    for(i=0; i<n; ++i) cnt[val[i]]++;\n    ans = cnt[0];\n    for(i=1; i<=15; ++i)\n    {\n        ans += cnt[i] / 2;\n        if(cnt[i] & 1) v.push_back(i);\n    }\n\n    m = v.size();\n    if(m)\n    {\n        for(i=0; i<(1<<m); ++i)\n        {\n            xr = 0;\n            for(j=0; j<m; ++j)\n                if(i&(1<<j)) xr ^= v[j];\n\n            if(!xr) dp[i] = 1;\n                else\n                {\n                    dp[i] = -1e9;\n                    continue;\n                }\n\n            for(j=i&(i-1); j; j = i&(j-1))\n                dp[i] = max(dp[i], dp[j] + dp[i^j]);\n        }\n        ans += dp[i-1];\n    }\n\n    ans = n - ans;\n    cout << ans << '\\n';;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define MIN(x,y) x=min(x,y)\nusing namespace std;\n\nconst int N=100005;\nconst int inf=1000000000;\n\nint n,a[N],bin[20],cnt[70005],f[70005],w[20];\nvector<int> vec[20];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid dp(int S)\n{\n\tfor (int i=0;i<bin[16];i++) cnt[i]=cnt[i>>1]+(i&1),vec[cnt[i]].push_back(i),f[i]=inf;\n\tf[S]=0;\n\tfor (int i=16;i>0;i--)\n\t\tfor (int j=0;j<vec[i].size();j++)\n\t\t{\n\t\t\tint s=vec[i][j];\n\t\t\tif (f[s]==inf) continue;\n\t\t\tfor (int x=0;x<16;x++)\n\t\t\t\tfor (int y=0;y<16;y++)\n\t\t\t\t{\n\t\t\t\t\tif (!(s&bin[x])||!(s&bin[y])||x==y) continue;\n\t\t\t\t\tMIN(f[s^bin[x]^bin[x^y]^bin[y]],f[s]+1+((s&bin[x^y])>0));\n\t\t\t\t}\n\t\t}\n}\n\nint main()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=16;i++) bin[i]=bin[i-1]*2;\n\tn=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read(),z=read();\n\t\ta[x+1]^=z;a[y+1]^=z;\n\t}\n\tfor (int i=1;i<=n;i++) w[a[i]]++;\n\tint S=0,ans=0;\n\tfor (int i=1;i<=15;i++) ans+=w[i]/2,w[i]%=2,S+=bin[i]*w[i];\n\tdp(S);\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, ans = 0;\nvector < int > v[100009];\n\nbool dfs (int nod, int tata)\n{\n    int cnt = 0, isBamboo = 0;\n    for (auto it : v[nod])\n        if (it != tata)\n        {\n            int curr = (dfs (it, nod) == 1);\n            cnt += curr, isBamboo += curr + 1;\n        }\n    if (cnt > 1)\n        ans += cnt - 1;\n    return (isBamboo <= 1);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nif (N == 1)\n{\n    printf (\"0\\n\");\n    return 0;\n}\nfor (int i=1; i<N; i++)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y), x ++, y ++;\n    v[x].push_back (y);\n    v[y].push_back (x);\n}\nint root = -1;\nfor (int i=1; i<=N; i++)\n    if (v[i].size () >= 3)\n        root = i;\nif (root == -1)\n{\n    printf (\"1\\n\");\n    return 0;\n}\ndfs (root, -1);\nprintf (\"%d\\n\", 1 + ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    ans+=cnt[0];\n    for(int i=1; i<16; i++) ans+=cnt[i]>>1, cnt[i]%=2;\n    cnt[0]=0;\n    dp[0]=0;\n    vector<int> v;\n    for(int i=0; i<16; i++) if(cnt[i]) v.eb(i);\n    int m=v.size();\n    for(int mask=1; mask<(1<<m); mask++){\n        int nw=0;\n        for(int i=0; i<m; i++) if((mask>>i)&1) nw^=v[i];\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<m); mask++){\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=max(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<m)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef  long long LL;\ntypedef  unsigned long long ULL;\ntypedef  double db;\ntypedef  long double ld;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define fuck(x) cout<<x<<endl\n#define fuck1(x,y) cout<<x<<\" \"<<y<<endl\n#define lson root<<1,l,mid\n#define rson root<<1|1,mid+1,r\n#define MP(a,b) make_pair(a,b)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\nconst int INF = 0x3f3f3f3f3f,mod = 1e9+7,maxn = 3e5+100;\nconst double eps  =1e-6,PI = acos(-1);\ntemplate<typename T> inline void read(T &x){\n    x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\nint N,val[maxn],cnt[20];\nint d[maxn],ss[maxn];\nint main(){\n    read(N);\n    for(int i = 0;i<N-1;i++){\n        int x,y,a;\n        read(x),read(y),read(a);\n        val[x]^=a;\n        val[y]^=a;\n    }\n    for(int i = 0;i<N;i++){\n        if(val[i])cnt[val[i]]++;\n    }\n    int ans = 0,st = 0;\n    for(int i = 0;i<16;i++){\n        ans+=cnt[i]/2;\n        if(cnt[i]&1)st = st|(1<<i);\n    }\n    for(int i = 1;i<=(1<<16);i++)d[i] = d[i>>1]+(i&1);\n    for(int i = 1;i<=(1<<16);i++)d[i]--;\n    for(int i = 1;i<=(1<<16);i++){\n        for(int j = 0;j<=15;j++){\n            if(i&(1<<j))ss[i]^=(j);\n        }\n    }\n    for(int i = 1;i<=(1<<16);i++){\n        if(ss[i]!=0)continue;\n        for(int k = (i-1)&i;k;k = (k-1)&i){\n            if(ss[k]==0)d[i] = min(d[i],d[k]+d[i^k]);\n        }\n    }\n    printf(\"%d\\n\",ans+d[st]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define mpr make_pair\n#define pii pair<int,int>\n\ntypedef long long ll;\nconst int maxn = 1e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, s;\nint cnt[maxn], a[maxn], dp[maxn];\n\nsigned main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    for(int i = 1, u, v, w; i < n; i++)\n    {\n        cin>> u >> v >> w; u++; v++;\n        (a[v] ^= w);\n        (a[u] ^= w);\n    }\n\n    for(int v = 1; v <= n; v++) cnt[a[v]]++;\n    int ans = 0;\n    for(int i = 0; i < 16; i++)\n    {\n        if(i == 0) ans += cnt[i];\n        else ans += cnt[i]/2;\n        (cnt[i] &= 1);\n        cnt[0] = 0;\n    }\n\n    /// dp = maximum tedad daste\n    for(int msk = 0; msk < (1<<16); msk++)\n    {\n        dp[msk] = -inf;\n        int X = 0, id, is = 0;\n        for(int i = 0; i < 16; i++)\n            if((1<<i) & msk)\n            {\n                if(cnt[i]&1) (X ^= i);\n                if(cnt[i]) is = 1;\n                id = i;\n            }\n\n        if(X == 0 && msk > 0)\n        {\n            if(!is)\n            {\n                dp[msk] = 0;\n                continue;\n            }\n\n            if(__builtin_popcount(msk) == 1)\n            {\n                dp[msk] = cnt[id]/2;\n                if(id == 0) dp[msk] = cnt[id];\n            }\n            else\n            {\n                dp[msk] = 1;\n                for(int s = ((msk-1)&msk); s; s = ((s-1)&msk))\n                    dp[msk] = max(dp[msk], dp[s] + dp[msk^s]);\n            }\n        }\n    }\n\n    int msk = (1<<16)-1;\n    cout<< n-(dp[msk]+ans);\n}\n\n/*\n2\nT 30\nW 1\n3\nT 1\nW 1\nT 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl;\n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define SUB(s,s0) for (REG int s=s0;s;s=(s-1)&s0)\n\n#define MAXN 210000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\nint n;\nint s;\nint dp[10000000];\nint node[MAXN];\nint count(int cur)\n{\n\tint ans=0;\n\tRPT(i,0,16)\n\t\tif (cur & (1<<i))\n\t\t\tans++;\n\treturn ans;\n}\n\nint xo(int cur)\n{\n\tint ans=0;\n\tRPT(i,0,16)\n\t\tif (cur & (1<<i))\n\t\t\tans^=(i+1);\n\treturn ans;\n}\n\nint dfs(int cur)\n{\n\t//WRT(cur);\n\tif (dp[cur]!=0)\n\t\treturn dp[cur];\n\tdp[cur]=count(cur)-1;\n\tSUB(s,cur)\n\t\tif (xo(s)==0 && s!=cur)\n\t\t{\n\t\t\t//cout<<s<<' '<<xo(s)<<endl;\n\t\t\tdp[cur]=min(dp[cur],dfs(s)+dfs(cur^s));\n\t\t}\n\treturn dp[cur];\n}\n\nLL ans;\nint main()\n{\n\tcin>>n;\n\tint x,y,z;\n\tRPT(i,0,n-1)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tnode[x]^=z;\n\t\tnode[y]^=z;\n\t}\n\tRPT(i,0,n)\n\t{\n\t\t//WRT(x);\n\t\tx=node[i];\n\t\tif (x==0)\n\t\t\tcontinue;\n\t\tif ((s&(1<<(x-1)))!=0)\n\t\t\tans++;\n\t\ts^=(1<<(x-1));\n\t}\n\t//WRT(ans);\n\t//WRT(s);\n\t//WRT(xo(s));\n\tcout<<ans+dfs(s);\n\treturn ~~(0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100000;\nint n,d[maxn+4]={0},v[16]={0},f[(1<<16)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint all=15,s=0,res=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=0;i<=all;i++)res+=v[i]/2,v[i]%=2,s|=(1<<v[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<all);i++)\n\t\tfor(int u=0;u<=15;u++){\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=15;v++){\n\t\t\t\tif(i&(1<<v)){\n\t\t\t\t\tint w=u^v;\n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n \nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n \n \nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\nint bp[(1 << A) + 5];\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n \n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}*/\n\tfor (int mask = 0; mask < 1 << A; mask++) {\n\t\tbp[mask] = __builtin_popcount(mask);\n\t}\n\tfor (int k = 0; k < A; k++) {\n\t\tfor (int mask = 0; mask < 1 << A; mask++) {\n\t\t\tfor (int i = 0; i < A; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tint mask2 = mask;\n\t\t\t\t\tmask2 ^= 1 << i;\n\t\t\t\t\tmask2 ^= 1 << j;\n\t\t\t\t\tmask2 ^= 1 << (((i + 1) ^ (j + 1)) - 1);\n\t\t\t\t//\tif (mask == 19) {\n\t\t\t\t//\t\tcout << \"48 \" << mask << \" \" << mask2 << \" \" << i << \" \" << j << \" \" << bp[mask2] << endl;\n\t\t\t\t//\t}\n\t\t\t\t\tbp[mask] = min(bp[mask], bp[mask2] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int mask = 0; mask < 1 << A; mask++) {\n//\t\t\n//\t\tcout << mask << \" \" << bp[mask] << endl;\n//\t}\n\tint mask = 0;\n\tfor (int i = 1; i <= A; i++) {\n\t\tif (dp[1][i]) {\n\t\t\tmask += 1 << (i - 1);\n\t\t}\n\t}\n\tcout << ans + bp[mask] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n \n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n \ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e5+10, maxm=5e6+10, lg=16, mod=998244353, inf=1e18;\n\nll n,tt[lg],x[maxn],ans,dp[1<<lg],xo[1<<lg];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u,a; cin>>v>>u>>a;\n\t\tx[v]^=a, x[u]^=a;\n\t}\n\tfor(int i=0;i<n;i++) tt[x[i]]++;\n\tvector<ll> a;\n\tans+=tt[0];\n\tfor(int i=1;i<lg;i++){\n\t\tans+=tt[i]/2;\n\t\tif(tt[i]%2) a.pb(i);\n\t}\n\tmemset(dp,69,sizeof(dp)); dp[0]=0;\n\tfor(int msk=1;msk<(1<<SZ(a));msk++){\n\t\tfor(int i=0;i<SZ(a);i++)if(msk>>i&1){ xo[msk]=xo[msk^(1<<i)]^a[i]; break; }\n\t\tfor(int sub=msk;sub;sub=(sub-1)&msk)if(xo[sub]==0) dp[msk]=min(dp[msk],1+dp[msk^sub]);\n\t}\n\tcout<<n-(ans+dp[(1<<SZ(a))-1]);\n\t\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define sub(T,S) for(int T=(S-1)&S;T;T=(T-1)&S)\nusing namespace std;\nconst int maxn=1e5+10;\nint n,a[maxn],d[maxn],chc[1<<15],dp[1<<15],ans,u,v,w,W;\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n-1) scanf(\"%d%d%d\",&u,&v,&w),a[u+1]^=w,a[v+1]^=w;\n    rep(i,1,n) ++d[a[i]];\n    rep(i,0,15) ans+=d[i]>>1,W|=(d[i]&1)<<i;\n    rep(i,0,15) rep(S,0,(1<<15)-1) if(S&(1<<i)) chc[S]^=i,++dp[S];\n    rep(S,0,(1<<15)-1){\n        if(chc[S]) continue;--dp[S];\n        sub(T,S) if(!chc[T]) dp[S]=min(dp[S],dp[T]+dp[S^T]);\n    }\n    printf(\"%d\\n\",dp[W]+ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<pair<int,int>> E[101010];\n\nint pat[1<<15];\nvector<int> V[16];\nint dp[1<<16];\n\n\nint dfs(int cur,int pre) {\n\tint x=0;\n\t\n\tFORR(e,E[cur]) if(e.first!=pre) {\n\t\tint y=dfs(e.first,cur);\n\t\te.second^=y;\n\t\tFORR(e2,E[e.first]) if(e2.first==cur) e2.second=e.second;\n\t\tx^=y^e.second;\n\t}\n\treturn x;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y>>j;\n\t\tE[x].push_back({y,j});\n\t\tE[y].push_back({x,j});\n\t}\n\tdfs(0,-1);\n\t\n\t\n\tFOR(i,1<<16) dp[i]=1010;\n\tint mask=0;\n\tfor(mask=0;mask<1<<15;mask++) {\n\t\tdp[mask]=__builtin_popcount(mask);\n\t\tFOR(y,15) if(mask&(1<<y)) {\n\t\t\tdp[mask]=min(dp[mask],dp[mask^(1<<y)]+1);\n\t\t\tFOR(x,y) if(mask&(1<<x)) {\n\t\t\t\tj=(x+1)^(y+1);\n\t\t\t\tif(mask&(1<<(j-1))) {\n\t\t\t\t\tdp[mask]=min(dp[mask],dp[mask^(1<<y)^(1<<x)^(1<<(j-1))]+2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[mask]=min(dp[mask],dp[mask^(1<<y)^(1<<x)^(1<<(j-1))]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint cnt[16]={};\n\tFOR(i,N) FORR(e,E[i]) if(e.first<i) cnt[e.second]++;\n\tint tot=0;\n\tmask=0;\n\tfor(i=1;i<=15;i++) {\n\t\ttot+=cnt[i]/2;\n\t\tif(cnt[i]%2) mask |= 1<<(i-1);\n\t}\n\tcout<<tot+dp[mask]<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 1e5 + 10, Limit = 1 << 15;\nint val[N], cnt[15], res[Limit], f[Limit];\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n;\n\tread(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y, z; read(x), read(y), read(z);\n\t\tx++; y++; val[x] ^= z; val[y] ^= z;\n\t}\n\tfor (int i = 1; i <= n; i++) cnt[val[i]]++;\n\tint ans = 0, S = 0;\n\tfor (int i = 1; i <= 15; i++)\n\t\tans += cnt[i] / 2, S |= (cnt[i] & 1) << (i - 1);\n\tfor (int i = 1, cnt; i < Limit; i++) {\n\t\tcnt = 0;\n\t\tfor (int j = 1; j <= 15; j++)\n\t\t\tif ((i >> (j - 1)) & 1) res[i] ^= j, cnt++;\n\t\tf[i] = cnt - 1;\n\t}\n\tfor (int i = 1; i < Limit; i++)\n\t\tif (!res[i])\n\t\t\tfor (int j = i; j; j = (j - 1) & i)\n\t\t\t\tif (!res[j]) f[i] = min(f[i], f[j] + f[i ^ j]);\n\tprintf(\"%d\\n\", ans + f[S]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Int register int\n#define INF 0x7f7f7f7f \n#define MAXN 100005\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nint n,val[MAXN],tong[16],f[1 << 16];\n\nint count (int S){//ç»è®¡Sä¸­1çä¸ªæ°\n\tint sum = 0;\n\tfor (Int i = 0;(1 << i) <= S;++ i) sum += (S >> i & 1); \n\treturn sum;\n}\n\nint Sum (int S){\n\tint sum = 0;\n\tfor (Int i = 0;(1 << i) <= S;++ i) if (S >> i & 1) sum ^= i;\n\treturn sum;\n} \n\nsigned main(){\n\tread (n);\n\tfor (Int i = 2,u,v,w;i <= n;++ i) read (u,v,w),val[u] ^= w,val[v] ^= w;\n\tint tot = 0;\n\tfor (Int i = 0;i < n;++ i) tong[val[i]] ++;\n\tfor (Int i = 1;i <= 15;++ i) if (tong[i] & 1) tot += (tong[i] - 1) / 2,tong[i] = 1;else tot += tong[i] / 2,tong[i] = 0;\n\tint up = 1 << 16;\n\tfor (Int S = 1;S < up;++ S) f[S] = Sum (S) != 0 ? INF : count (S) - 1;\n\tfor (Int S = 1;S < up;++ S)\n\t\tfor (Int T = (S - 1) & S;T;T = (T - 1) & S)\n\t\t\tf[S] = min (f[S],f[T] + f[S ^ T]);\n\tint now = 0;\n\tfor (Int i = 1;i <= 15;++ i) if (tong[i]) now |= 1 << i;\n\twrite (f[now] + tot),putchar ('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010,inf = 0x7ffffff;\nint n,du[maxn],tong[1 << 16],ans,limit,f[1 << 16];\n\nint prework(int sta)\n{\n    if (sta == 0)\n        return 0;\n    int res = 0,cnt = 0;\n    for (int i = 0; i <= 15; i++)\n        if (sta >> i & 1)\n        {\n            res ^= i;\n            cnt++;\n        }\n    if (res == 0)\n        return cnt - 1;\n    else\n        return inf;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i = 1; i < n; i++)\n    {\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        x++;\n        y++;\n        du[x] ^= z;\n        du[y] ^= z;\n    }\n    for (int i = 1; i <= n; i++)\n        tong[du[i]]++;\n    for (int i = 1; i <= 15; i++)\n    {\n        ans += tong[i] / 2;\n        tong[i] %= 2;\n        limit |= (tong[i] << i);\n    }\n    for (int i = 0; i <= limit; i++)\n        f[i] = prework(i);\n    for (int i = 0; i <= limit; i++)\n        for (int j = i;j;j = (j - 1) & i)\n            f[i] = min(f[i],f[j] + f[i ^ j]);\n    printf(\"%d\\n\",f[limit] + ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    int x, y, a;\n    vec v(N, 0);\n    REP(i, N - 1){\n        cin >> x >> y >> a;\n        v[x] ^= a;\n        v[y] ^= a;\n    }\n    vec cnt(16, 0);\n    for(int i: v) cnt[i]++;\n    int ans = 0;\n    int X = 0;\n    REP(i, 15){\n        ans += cnt[i + 1] / 2;\n        if(cnt[i + 1] % 2) X ^= bit(i);\n    }\n\n    vec dp(bit(15), INF);\n    dp[0] = 0;\n    FOR(n, 1, 15 + 1){\n        int comb = bit(n) - 1;\n        while(comb < bit(15)){\n            int tmp = 0;\n            REP(i, 15) if((comb >> i) & 1) tmp ^= (i + 1);\n            if(tmp == 0){\n                REP(i, 15) REP(j, 15) if(i != j && ((comb >> i) & 1) && ((comb >> j) & 1)){\n                    int k = ((i + 1) ^ (j + 1)) - 1;\n                    if((comb >> k) & 1) Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 2);\n                    else Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 1);\n                }\n            }\n\n            x = comb & -comb, y = comb + x;\n            comb = ((comb & ~y) / x >> 1) | y;\n        }\n\n    }\n    ans += dp[X];\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\næ°æ®ä¸æ¸ç©ºï¼çé¶ä¸¤è¡æ³ªã\nå¤æµä¸è¯»å®ï¼çé¶ä¸¤è¡æ³ªã\nè¾¹çä¸ç¹å¤ï¼çé¶ä¸¤è¡æ³ªã\nè´ªå¿ä¸è¯æï¼çé¶ä¸¤è¡æ³ªã\nD P é¡ºåºéï¼çé¶ä¸¤è¡æ³ªã\nå¤§å°å°ç­å·ï¼çé¶ä¸¤è¡æ³ªã\nåéä¸ç»ä¸ï¼çé¶ä¸¤è¡æ³ªã\nè¶çä¸å¤æ­ï¼çé¶ä¸¤è¡æ³ªã\nè°è¯ä¸æ³¨éï¼çé¶ä¸¤è¡æ³ªã\næº¢åºä¸ l lï¼çé¶ä¸¤è¡æ³ªã\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nconst int inf=0x3f3f3f3f;\nint lowbit(int x){return x&-x;}\nint ppc(int x){return __builtin_popcount(x);}\nconst int N=100000;\nint n;\nvector<pair<int,int> > nei[N+1];\nint buc[16];\nint dfs(int x=1,int fa=0){\n\tint xsm=0;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i].X,v=nei[x][i].Y;\n\t\tif(y==fa)continue;\n\t\tint tmp=dfs(y,x)^v;\n\t\txsm^=tmp;\n\t\tbuc[tmp]++;\n\t}\n\treturn xsm;\n}\nint dp[1<<15];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tx++;y++;\n\t\tnei[x].pb(mp(y,z));nei[y].pb(mp(x,z));\n\t}\n\tdfs();\n\tfor(int i=1;i<1<<15;i++){\n\t\tdp[i]=ppc(i);\n\t\tint xsm=0;\n\t\tfor(int j=1;j<=15;j++)if(i&1<<j-1)xsm^=j;\n\t\tif(!xsm)dp[i]=ppc(i)-1;\n\t\tfor(int j=i-1&i;j;j=j-1&i)dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tint ans=0,msk=0;\n\tfor(int i=1;i<=15;i++)ans+=buc[i]>>1,msk|=(buc[i]&1)<<i-1;\n\tcout<<ans+dp[msk];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5 + 2, M = 15;\n\nint A[N], C[M + 1], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 1; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 1; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tfor (int i = 0; i < n; i++) C[A[i]]++;\n\tint x = 0, cnt = C[0];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcnt += C[i] >> 1;\n\t\tif (C[i] & 1) x ^= (1 << (i - 1));\n\t}\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int BUFFER_SIZE = 1 << 20;\nchar rb[BUFFER_SIZE], *rp = rb, *rt = rb;\ninline char read_char() {\n    return rp == rt ? (rt = rb + fread(rb, 1, BUFFER_SIZE, stdin), rp = rb, *rp ++) : *rp ++;\n}\ninline int read_int() {\n    int x = 0;\n    char ch = read_char(), flag = 0;\n    while (ch != '-' && (ch < '0' || ch > '9')) {\n        ch = read_char();\n    }\n    if (ch == '-') {\n        flag = 1;\n        ch = read_char();\n    }\n    for (x = 0; ch >= '0' && ch <= '9'; ch = read_char()) {\n        x = x * 10 + (ch - '0');\n    }\n    return flag ? -x : x;\n}\n\nconst int MAX_N = 100000 + 5;\nconst int MAX_S = 1 << 15 | 5;\nconst int INF32 = 999;\n\nint N, ans, a[MAX_N];\nint c[20], n, b[20], fs[MAX_N], f[MAX_S];\n\nint main() {\n    N = read_int();\n    for (int i = 1; i < N; i ++) {\n        int x = read_int() + 1;\n        int y = read_int() + 1;\n        int z = read_int();\n        a[x] ^= z;\n        a[y] ^= z;\n    }\n    for (int i = 1; i <= N; i ++) {\n        if (a[i]) {\n            ans += c[a[i]];\n            c[a[i]] ^= 1;\n        }\n    }\n    for (int i = 1; i <= 15; i ++) {\n        if (c[i]) {\n            b[n ++] = i;\n        }\n    }\n    for (int S = 1; S < 1 << n; S ++) {\n        for (int i = 0; i < n; i ++) {\n            if (S >> i & 1) {\n                f[S] ++;\n                fs[S] ^= b[i];\n            }\n        }\n        if (fs[S]) {\n            f[S] = INF32;\n        } else {\n            f[S] --;\n            for (int T = S - 1 & S; T > S - T; T = T - 1 & S) {\n                if (!fs[T] && f[S] > f[T] + f[S ^ T]) {\n                    f[S] = f[T] + f[S ^ T];\n                }\n            }\n        }\n    }\n    ans += f[(1 << n) - 1];\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pll pair <ll , ll>\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n\n#define X first\n#define Y second\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n\nconst ll MAXN=1e5+10;\nconst ll MAXT=20;\nconst ll INF=1e9+10;\n\nvector <pll> vertex[MAXN];\n\nll a[MAXN];\n\nll dp[1<<MAXT];\n\nll e[MAXT];\n\nbool check[MAXN];\n\nvoid dfs(ll v)\n{\n    check[v]=true;\n\n    for(ll i=0;i<vertex[v].size();i++)\n    {\n        if (!check[vertex[v][i].X])\n        {\n            dfs(vertex[v][i].X);\n            a[v]^=vertex[v][i].Y;\n            a[vertex[v][i].X]^=vertex[v][i].Y;\n        }\n    }\n}\n\nint main()\n{\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n , x=0 , res=0;\n\tcin>>n;\n\n\tfor(ll i=0;i<(n-1);i++)\n    {\n        ll v , u , w;\n        cin>>v>>u>>w;\n\n        v++;\n        u++;\n\n        vertex[v].pb(mp(u , w));\n        vertex[u].pb(mp(v , w));\n    }\n\n    dfs(1);\n\n    for(ll i=1;i<=n;i++)\n    {\n        e[a[i]]++;\n    }\n\n    for(ll i=1;i<=15;i++)\n    {\n        res+=(e[i]/2);\n\n        if (e[i]&1)\n        {\n            x+=(1<<(i-1));\n        }\n    }\n\n    for(ll mask=1;mask<(1<<15);mask++)\n    {\n        dp[mask]=INF;\n\n        for(ll i=0;i<15;i++)\n        {\n            for(ll j=i+1;j<15;j++)\n            {\n                if (BIT(mask , i) && BIT(mask , j))\n                {\n                    ll w=((i+1)^(j+1))-1;\n                    dp[mask]=min(dp[mask] , dp[mask^(1<<i)^(1<<j)^(1<<w)]+BIT(mask , w)+1);\n                }\n            }\n        }\n    }\n\n    cout<<res+dp[x];\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define lb(i) i&(-i);\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int maxn =1e5+5;\nint n,a[maxn],xr[maxn],dp[(1<<16)],cal[maxn],re;\nbool ok[16];\nvector<int> v;\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n;\n    rep(i,1,n)\n    {\n        int x,y,w;\n        cin>>x>>y>>w;\n        xr[x]^=w;\n        xr[y]^=w;\n    }\n    rep(i,0,n)\n    {\n        if(xr[i]==0)\n        {\n            re++;\n        }\n        else if(ok[xr[i]])\n        {\n            ok[xr[i]]=0;\n            re++;\n        }\n        else\n        {\n            ok[xr[i]]=1;\n        }\n    }\n    rep(i,1,16)if(ok[i])\n    {\n        v.pb(i);\n        //cout<<v.back()<<' ';\n    }\n    //cout<<endl;\n    int l=v.size();\n    rep(i,1,(1<<l))\n    {\n        int j=0;\n        while(!(i&(1<<j)))j++;\n        cal[i]=cal[i^(1<<j)]^v[j];\n    }\n    rep(i,1,(1<<l))if(cal[i]==0)\n    {\n        dp[i]=1;\n        for(int sub=i;sub>0;sub=(sub-1)&i)if(cal[sub]==0)\n        {\n            dp[i]=max(dp[i],dp[i^sub]+1);\n        }\n    }\n    re+=dp[(1<<l)-1];\n    cout<<n-re;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define removeDuplicate(a) sort(a.begin(), a.end()); a.resize(distance(a.begin(), unique(a.begin(), a.end())));\n\n\nconst int N = 1e5 + 10; \nconst int MAXVALUE = 16;  \nstruct TEdge { \n\tint foo, bar, value; \n\tTEdge (int foo = 0, int bar = 0, int value = 0) : foo(foo), bar(bar), value(value) {}\n\tint findOther (int u) { return (foo == u) ? bar : foo; }\n} e[N]; \n\nint n; \nvector<int> g[N]; \nint a[N]; \nint countOccur[MAXVALUE]; \nint dp[(1 << MAXVALUE)]; \nbool isZero[(1 << MAXVALUE)]; \nint main() {\n    #define file \"F\"\n    //freopen(file\".inp\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n\n    ios :: sync_with_stdio(false); \n    cin >> n; \n    for (int iE = 1; iE < n; iE++) { \n    \tint foo, bar, value; \n    \tcin >> foo >> bar >> value;\n    \tfoo++; bar++;  \n    \te[iE] = TEdge(foo, bar, value); \n    \tg[foo].push_back(iE); \n    \tg[bar].push_back(iE); \n    }\n    for (int foo = 1; foo <= n; foo++) { \n    \tfor (int iE : g[foo]) { \n    \t\ta[foo] ^= e[iE].value; \n    \t}\n    \tcountOccur[a[foo]]++; \n    }\n    for (int mask = 0; mask < (1 << MAXVALUE); mask++) { \n    \tint xorValue = 0; \n    \tfor (int i = 0; i < MAXVALUE; i++) { \n    \t\tif ((mask >> i) & 1) { \n    \t\t\txorValue ^= i; \n    \t\t}\n    \t\tisZero[mask] = (xorValue == 0); \n    \t}\n    }\n    for (int mask = 0; mask < (1 << MAXVALUE); mask++) { \n    \tfor (int subMask = mask; subMask; subMask = (subMask - 1) & mask) if (isZero[subMask]) {\n    \t\tdp[mask] = max(dp[mask], dp[mask ^ subMask] + 1);  \n    \t}\n    }\n    int ret = 0; \n    int remainMask = 0;\n    ret += countOccur[0];  \n    for (int value = 1; value < MAXVALUE; value++) { \n    \tif (countOccur[value] & 1) remainMask ^= (1 << value);\n    \tret += countOccur[value] / 2; \n    }\n    ret += dp[remainMask];\n    ret = n - ret; \n    cout << ret;  \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005; \ntypedef pair <int, int> pii; \nvector <pii> edges [MAXN]; \nint cnt [16]; \nint dp [(1 << 16)]; \nint dfs (int node, int p = 0){\n\tint tot_xor = 0; \n\tfor (pii edge : edges[node]){\n\t\tif(edge.first==p) continue; \n\t\tint sub_xor = dfs(edge.first, node); \n\t\tcnt [sub_xor ^ edge.second]++; \n\t\t\n\t\ttot_xor ^= (sub_xor ^ edge.second); \n\t}\n\treturn tot_xor; \n}\nint main() {\n\tios_base::sync_with_stdio(0); \n\tint n; cin >> n; \n\tfor (int i=0; i<n-1; i++){\n\t\tint u, v, w; cin >> u >> v >> w; \n\t\tu++; v++; \n\t\t\n\t\tedges[u].push_back(pii(v, w)); \n\t\tedges[v].push_back(pii(u, w)); \n\t}\n\t\n\tdfs(1);\n\t\n\tcnt[0]=0; \n\t\n\tint ans=0; \n\tfor (int i=0; i<16; i++){\n\t\tans += cnt[i]/2; \n\t\tcnt[i]%=2; \n\t}\n\tint ans_msk=0; \n\tfor (int i=0;i<16; i++){\n\t\tif (cnt[i]) ans_msk |= (1 << i); \n\t}\n\tfor (int i=1; i<=ans_msk; i++){\n\t\tint cur_xor=0; \n\t\tfor (int j=0; j<16; j++){\n\t\t\tif (cnt[j]){\n\t\t\t\tif ((1 << j) & i) continue; \n\t\t\t\tcur_xor ^= j; \n\t\t\t}\n\t\t}\n\t\tif ((1 << cur_xor) & i){\n\t\t\tdp[i] = dp[i ^ (1 << cur_xor)]; \n\t\t}\n\t\telse{\n\t\t\tint an=1e9; \n\t\t\tfor (int j=0; j<16; j++){\n\t\t\t\tif ((1<<j) & i) an = min(an, 1 + dp[(1 << j) ^ i]); \n\t\t\t}\n\t\t\tdp[i] = an; \n\t\t}\n\t}\n\tcout << ans + dp[ans_msk] << '\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e5 + 10;\n\nint n;\nint p[MAXN];\nint mask[MAXN];\nint cnt[MAXN][16];\nvector <pair <int, int>> adj[MAXN];\n\nvoid dfs(int u, int parent) {\n    p[u] = parent;\n    for (auto v : adj[u]) {\n        if (v.first != parent)\n            dfs(v.first, u);\n        else\n            mask[u] = v.second;\n    }\n}\n\nvoid calc(int u) {\n    int val = 0;\n    for (auto v : adj[u]) {\n        if (v.first == p[u])\n            continue;\n        calc(v.first);\n        val ^= v.second;\n        for (int i = 1; i < 16; i++)\n            cnt[u][i] += cnt[v.first][i];\n    }\n    cnt[u][mask[u] ^ val]++;\n\n    /*\n    cout << u << \":\";\n    for (int i = 1; i < 16; i++)\n        cout << \" \" << cnt[u][i];\n    cout << endl;\n    */\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, a;\n        cin >> u >> v >> a;\n        adj[u].push_back({v, a});\n        adj[v].push_back({u, a});\n    }\n\n    int root = 0;\n    while (root < n && adj[root].size() > 1)\n        root++;\n    dfs(root, -1);\n    calc(root);\n    // cout << \"r: \" << root << endl;\n\n    int total = 0;\n    int left = 0;\n    // matched\n    for (int i = 1; i < 16; i++) {\n        // cout << i << \": \" << cnt[root][i] << endl;\n        total += cnt[root][i] / 2;\n        cnt[root][i] %= 2;\n        if (cnt[root][i] == 1) {\n            total++;\n            left ^= (1 << i);\n        }\n    }\n\n    // merge\n    vector <vector <int>> masks(17);\n    for (int m = 0; m < (1 << 16); m++) {\n        int bits = 0;\n        int val = 0;\n        for (int i = 0; i < 16; i++)\n            if (m & (1 << i)) {\n                bits++;\n                val ^= i;\n            }\n        if (bits > 1 && val == 0)\n            masks[bits].push_back(m);\n    }\n    for (int bits = 3; bits <= 16; bits++) {\n        for (int m : masks[bits]) {\n            if ((left & m) == m) {\n                left ^= m;\n                total--;\n            }\n        }\n    }\n\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n \n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n \ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e5+10, maxm=5e6+10, lg=16, mod=998244353, inf=1e18;\n\nll n,tt[lg],x[maxn],ans,dp[1<<lg],xo[1<<lg];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u,a; cin>>v>>u>>a;\n\t\tx[v]^=a, x[u]^=a;\n\t}\n\tfor(int i=0;i<n;i++) tt[x[i]]++;\n\tvector<ll> a;\n\tans+=tt[0];\n\tfor(int i=1;i<lg;i++){\n\t\tans+=tt[i]/2;\n\t\tif(tt[i]%2) a.pb(i);\n\t}\n\tmemset(dp,69,sizeof(dp)); dp[0]=0;\n\tfor(int msk=1;msk<(1<<SZ(a));msk++){\n\t\tfor(int i=0;i<SZ(a);i++)if(msk>>i&1){ xo[msk]=xo[msk^(1<<i)]^a[i]; break; }\n\t\tfor(int sub=msk;sub;sub=(sub-1)&msk)if(xo[sub]==0) dp[msk]=min(dp[msk],1+dp[msk^sub]);\n\t}\n\tcout<<n-(ans+dp[(1<<SZ(a))-1]);\n\t\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(ll i=a;i<b;i++)\n#define Ford(i,a,b) for(ll i=a;i>=b;i--)\n#define RET(x) { cout << x; exit(0); }\n#define smin(a,b) a=min(a,b)\n#define smax(a,b) a=max(a,b)\n#define SZ(x) ((ll)((x).size()))\n#define PB push_back\n#define ER(x) cout << #x << ' ' << x << '\\n';\n#define X first\n#define Y second\n\ntypedef long long int LL;\ntypedef LL ll;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n\nconst ll M=1e5+5,LG=30,mod=924844033;\nll pw(ll x,ll y){ if (y==0) return 1; return pw(x*x%mod,y/2)*(y&1?x:1)%mod; }\n\n#define MOK(x) if (x>=mod) x-=mod;\n\n\nvll g[M];\nll uu[M],vv[M],ww[M];\nll n;\nll co[LG];\n\nll nwbk[LG],nw[LG];\n\n\nll bu(){\n  ll res=0;\n  For(i,1,16){\n    if (nw[i]) res+=(1<<(i-1));\n  }\n  return res;\n}\n\nvoid backup(){\n  For(i,1,16) nwbk[i]=nw[i];\n}\n\nvoid unpack(){\n  For(i,1,16) nw[i]=nwbk[i];\n}\n\nll dfs(ll x,ll p){\n  ll s=0;\n  for (ll e:g[x]){\n    ll y=uu[e]^vv[e]^x;\n    if (y==p){\n      s^=ww[e];\n      continue;\n    }\n    s^=dfs(y,x);\n  }\n  co[s]++;\n  return s;\n}\n\nvector<pll> gd[M];\nll qu[M],qh,qt;\nll vis[M];\nll dp[M];\n\nvoid dpupd(){\n  For(i,0,1<<15){\n    For(j,1,16){\n      nw[j]=(i>>(j-1)&1);\n    }\n    For(j,1,16){\n      if (!nw[j]) continue;\n      nw[j]=0;\n      //ER(i);ER(bu());\n      gd[bu()].PB({i,1});\n      nw[j]=1;\n      break;\n    }\n    For(a,1,16){\n      if (!nw[a]) continue;\n      For(b,a+1,16){\n\tif (!nw[a] || !nw[b]) continue;\n\tFor(c,1,16){\n\t  backup();\n\t  nw[a]=0;\n\t  nw[b]=0;\n\t  ll ap=a^c;\n\t  ll bp=b^c;\n\t  ll r=1;\n\t  if (nw[ap]){\n\t    r++;\n\t    nw[ap]=0;\n\t  }\n\t  else{\n\t    nw[ap]=1;\n\t  }\n\t  if (nw[bp]){\n\t    r++;\n\t    nw[bp]=0;\n\t  }\n\t  else{\n\t    nw[bp]=1;\n\t  }\n\t  gd[bu()].PB({i,r});\n\t  unpack();\n\t}\n      }\n      break;\n    }\n  }\n  memset(dp,31,sizeof dp);\n  qu[0]=0;\n  dp[0]=0;\n  qh=0;\n  qt=1;\n  while (qh!=qt){\n    ll u=qu[qh++];\n    vis[u]=0;\n    for (pll e:gd[u]){\n      ll v=e.X;\n      ll rd=dp[u]+e.Y;\n      if (dp[v]<=rd) continue;\n      dp[v]=rd;\n      if (!vis[v]){\n\tvis[v]=1;\n\tqu[qt++]=v;\n      }\n    }\n  }\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin >> n;\n  For(i,1,n){\n    ll u,v,w;\n    cin >> u >> v >> w;\n    uu[i]=u;vv[i]=v;ww[i]=w;\n    g[u].PB(i);\n    g[v].PB(i);\n  }\n  co[dfs(0,0)]--;\n  ll res=0;\n  ll mymsk=0;\n  For(i,1,16){\n    //ER(i);ER(co[i]);\n    res+=co[i]/2;\n    co[i]=co[i]%2;\n    if (co[i])\n      mymsk+=1<<(i-1);\n  }\n  dpupd();\n  //ER(mymsk);ER(dp[mymsk]);\n  res+=dp[mymsk];\n  RET(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define D(i) ( 1 << (i) )\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 1e5 + 5 ;\nconst int M = 16 ;\nint n, ans, w[N], cnt[M], dp[1 << M], R[1 << M] ;\nsigned main()\n{\n\tn = gi() ; int x, y, z, Sta ; \n\trep( i, 2, n ) x = gi() + 1,  y = gi() + 1, \n\tz = gi(), w[x] ^= z, w[y] ^= z ; \n\trep( i, 1, n ) ++ cnt[w[i]] ;\n\trep( i, 1, 15 ) ans += cnt[i] / 2, Sta |= ( ( cnt[i] & 1 ) << ( i - 1 ) ) ;\n\tint maxm = ( 1 << 15 ) - 1 ;\n\trep( i, 1, maxm ) {\n\t\trep( j, 1, 15 ) if( D(j - 1) & i ) R[i] ^= j, ++ dp[i] ;\n\t\t-- dp[i] ;\n\t}\n\trep( i, 1, maxm ) {\n\t\tif( R[i] != 0 ) continue ;\n\t\tfor( re int j = i; j; j = ( j - 1 ) & i )\n\t\tif( R[j] == 0 ) dp[i] = min( dp[i], dp[j] + dp[i ^ j] ) ;\n\t}\n\tprintf(\"%d\\n\", ans + dp[Sta] ) ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1e9+7;\nconst llint big=(llint)44e15;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nstatic int dp[65536]={0};\n//vector<vector<pair<int,int>>>ko;\narray<int,16>use;\n/*void solve(int ter,int oya,int uex){\n\t//è¿ãæ¹åã®xor\n\t\n\tfor(auto it:ko[ter]){\n\t\tif(it.fir==oya){continue;}\n\t\tsolve(it.fir,ter,uex^it.sec);\n\t}\n\tif(oya!=-1){use[uex]++;cerr<<uex<<endl;}\n}*/\nint main(void){\n\tint n,ans,i,j;\n\t//i åbitãæã£ã¦ãã\n\tfor(i=1;i<65536;i++){//xorã0ã«ãªããããªçµã¿åããããã¾ããã¨è¦ã¤ãã\n\t\tint bi=0;\n\t\tfor(j=1;j<16;j++){\n\t\t\tif(((1<<j)&i)!=0){bi^=j;}\n\t\t}\n\t\tif(bi==0){maxeq(dp[i],1);}\n\t\t\n\t\tfor(j=1;j<65536;){\n\t\t\tif(((65535-i)&j)!=0){j+=(65535-i)&j;continue;}\n\t\t\tmaxeq(dp[i],dp[j]+dp[i-j]);\n\t\t\tj++;\n\t\t}\n\t}\n\tcin>>n;ans=n;\n\t//ko.res(n);\n\tvector<int>hzi(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint x,y,a;cin>>x>>y>>a;\n\t\thzi[x]^=a;\n\t\thzi[y]^=a;\n\t\t//ko[x].pub(mp(y,a));\n\t\t//ko[y].pub(mp(x,a));\n\t}\n\tfor(i=0;i<n;i++){use[hzi[i]]++;}\n\t//solve(0,-1,0);\n\tans-=use[0];use[0]=0;\n\tfor(i=1;i<16;i++){ans-=use[i]/2;use[i]%=2;}\n\tint bi=0;for(i=0;i<16;i++){if(use[i]==1){bi+=(1<<i);}}\n\t//cout<<bi<<\" \"<<dp[bi]<<endl;\n\tans-=dp[bi];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt[20],ok[1<<17],dp[1<<17];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint v;\n\t\tscanf(\"%*d%*d%d\",&v);\n\t\tcnt[v]++;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,cnt[i]%=2;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i];\n\tcnt[0]=0;\n\tint U=1<<16;\n\tfor (int i=0;i<U;i++){\n\t\tint s=0;\n\t\tfor (int j=0;j<16;j++)\n\t\tif (i>>j&1) s^=j;\n\t\tif (!s) ok[i]=1;\n\t}\n\tfor (int i=0;i<U;i++)\n\tfor (int j=i;j;j=(j-1)&i){\n\t\tif (ok[j]) dp[i]=max(dp[i],dp[i^j]+1);\n\t\tdp[i]=max(dp[i],dp[i^j]);\n\t}\n\tint tmp=0;\n\tfor (int i=0;i<16;i++) tmp^=cnt[i]<<i;\n\tprintf(\"%d\\n\",ans-dp[tmp]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\" , a[i]);\n\t\tif(!a[i]) continue;\n\t\tif(S & (1 << (a[i] - 1))) ans ++;\n\t\tS ^= (1 << (a[i] - 1));\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[0] = 0;\n\tfor (int now = 1; now < (1 << 15); ++now) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n//\t\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S] + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <climits>\n#include <functional>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <time.h>\n#include <utility>\n#include <vector>\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\n\nstruct edge {\n\tuint32 to;\n\tuint32 a;\n};\n\nint main(void) {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tuint32 n;\n\tstd::cin >> n;\n\tstd::vector<std::vector<edge>> G(n);\n\tuint32 tx, ty, ta;\n\tfor (uint32 i = 1;i < n;++i) {\n\t\tstd::cin >> tx >> ty >> ta;\n\t\tG[tx].push_back({ ty,ta });\n\t\tG[ty].push_back({ tx,ta });\n\t}\n\tstd::vector<uint32[15]> dp(n);\n\tstd::vector<uint32> D(n);\n\tfor (uint32 i = 0;i < n;++i) {\n\t\tfor (uint32 j = 0;j < 16;++j) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tuint32 m;\n\tstd::function<void(uint32, uint32)> dfs = [&](uint32 node, uint32 prev) {\n\t\tfor (uint32 i = 0;i < 16;++i) {\n\t\t\tdp[node][i] = 0;\n\t\t}\n\t\tD[node] = 0;\n\t\tuint32 count = 0,temp;\n\t\tfor (uint32 i = 0;i < G[node].size();++i) {\n\t\t\tuint32 e = G[node][i].to;\n\t\t\tif (e == prev) continue;\n\t\t\tdfs(e, node);\n\t\t\tcount += D[e];\n\t\t\ttemp = G[node][i].a;\n\t\t\tfor (uint32 j = 0;j < 16;++j) {\n\t\t\t\tif (dp[e][j]) {\n\t\t\t\t\tif (dp[node][j]) {\n\t\t\t\t\t\tdp[node][j] = 0;\n\t\t\t\t\t\t--count;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[node][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp == m) continue;\n\t\t\tif (dp[node][temp^m]) {\n\t\t\t\tdp[node][temp^m] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[node][temp^m] = 1;\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\tD[node] = count;\n\t\treturn;\n\t};\n\tuint32 ans = UINT32_MAX;\n\tfor (uint32 i = 0;i < 16;++i) {\n\t\tm = i;\n\t\tdfs(0, n);\n\t\tans = std::min(ans, D[0]);\n\t}\n\tstd::cout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DBG1\n  #define LOCAL\n#endif\n\n#ifdef LOCAL\n  #define _GLIBCXX_DEBUG\n#endif\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#ifdef DBG1\n    #define dbg(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dbg(...)\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\n\nstruct Edge {\n  int v, w;\n};\n\nbool solve() {\n  int n;\n  if (scanf(\"%d\", &n) != 1) { return false; }\n  vector <vector<Edge>> ed(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    ed[u].push_back(Edge({v, w}));\n    ed[v].push_back(Edge({u, w}));\n    dbg(\"%d %d %d\\n\", u, v, w);\n  }\n\n  vector <int> xor_sum(n, 0);\n  for (int i = 0; i < n; ++i) {\n    for (auto & e : ed[i]) {\n      xor_sum[i] ^= e.w;\n    }\n  }\n  vector <int> cnt(16, 0);\n  for (int i = 0; i < n; ++i) {\n    if (xor_sum[i]) {\n      cnt[xor_sum[i]] += 1;\n    }\n  }\n  int mask = 0;\n  int ans = 0;\n  for (int i = 0; i < 16; ++i) {\n    dbg(\"cnt[%d] = %d\\n\", i, cnt[i]);\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n    mask |= (cnt[i] << i);\n  }\n  vector <int> dp(1 << 16, -1);\n  vector <int> q[3];\n  q[0].push_back(mask);\n  dp[mask] = 0;\n  int cntQ = 1;\n  while (cntQ) {\n    while (q[0].empty()) {\n      q[0].swap(q[1]);\n      q[1].swap(q[2]);\n    }\n\n    --cntQ;\n    int v = q[0].back();\n    q[0].pop_back();\n    dbg(\"dp[%d] = %d\\n\", v, dp[v]);\n    \n    for (int j = 0; j < 16; ++j) {\n      if (!(v & (1 << j))) { continue; }\n      for (int k = 0; k < 16; ++k) {\n        if (!(v & (1 << k)) || j == k) { continue; }\n\n        int u = v ^ (1 << j) ^ (1 << k) ^ (1 << (k ^ j));\n        int d = 1;\n        if (v & (1 << (j ^ k))) {\n          d += 1;\n        }\n        if (dp[u] == -1 || dp[u] > dp[v] + d) {\n          dp[u] = dp[v] + d;\n          q[d].push_back(u);\n          ++cntQ;\n        }\n      }\n    }\n  }\n  dbg(\"ans %d dp[%d^0] = %d\\n\", ans, mask, dp[0]);\n  printf(\"%d\\n\", ans + dp[0]);\n  return true;\n}\n\nint main() {\n  while (solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=200010,M=20,Inf=2e9;\nint n,a[N],cnt[M],ans,f[1<<M];\nvoid chkmin(int &x,int y){x=min(x,y);}\nint main(){\n\tn=gi();\n\tfor(int i=1;i<n;i++){\n\t\tint u=gi()+1,v=gi()+1,w=gi();\n\t\ta[u]^=w;a[v]^=w;\n\t}\n\tint now=0;\n\tfor(int i=1;i<=n;i++)cnt[a[i]]++;\n\tfor(int i=1;i<=15;i++){ans+=cnt[i]/2;cnt[i]&=1;now+=cnt[i]<<(i-1);}\n\tmemset(f,127,sizeof(f));f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<Inf)\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k){\n\t\t\t\t\t\t\tint x=j^k;\n\t\t\t\t\t\t\tif(i&(1<<x-1))chkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<x-1)],f[i]+2);\n\t\t\t\t\t\t\telse chkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<x-1)],f[i]+1);\n\t\t\t\t\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nint solve(int n, const vector<int> & x, const vector<int> & y, const vector<int> & a) {\n    constexpr int MAX_A = 0xf;\n    assert (*max_element(ALL(a)) <= MAX_A);\n\n    // make the adjacent list\n    vector<vector<int> > g(n);\n    REP (i, n - 1) {\n        g[x[i]].push_back(y[i]);\n        g[y[i]].push_back(x[i]);\n    }\n\n    // fix a root\n    vector<int> parent(n, -1);\n    function<void (int)> go = [&](int i) {\n        for (int j : g[i]) if (j != parent[i]) {\n            parent[j] = i;\n            go(j);\n        }\n    };\n    constexpr int root = 0;\n    go(root);\n\n    // move labels to nodes\n    vector<int> b(n, -1);\n    REP (i, n - 1) {\n        if (parent[x[i]] == y[i]) {\n            b[x[i]] = a[i];\n        } else if (x[i] == parent[y[i]]) {\n            b[y[i]] = a[i];\n        } else {\n            assert (false);\n        }\n    }\n\n    // tree dp\n    int removed = 0;\n    function<array<bool, MAX_A + 1> (int)> dp = [&](int i) {\n        array<bool, MAX_A + 1> cnt1 = {};\n\n        // recur\n        int k = b[i];\n        for (int j : g[i]) if (j != parent[i]) {\n            array<bool, MAX_A + 1> cnt2 = dp(j);\n            REP (i, MAX_A + 1) if (cnt2[i]) {\n                if (k != -1) {\n                    k ^= i;\n                }\n                removed += cnt1[i];\n                cnt1[i] ^= 1;\n            }\n        }\n        if (k >= 1) {\n            removed += cnt1[k];\n            cnt1[k] ^= 1;\n        }\n\n        // finialize\n        REP (i, MAX_A + 1) if (cnt1[i]) {\n            REP (j, i) if (cnt1[j]) {\n                if (cnt1[i ^ j]) {\n                    cnt1[i] = false;\n                    cnt1[j] = false;\n                    cnt1[i ^ j] = false;\n                    removed += 2;\n                    break;\n                }\n            }\n        }\n\n        return cnt1;\n    };\n    array<bool, MAX_A + 1> cnt = dp(root);\n    return removed + accumulate(ALL(cnt), 0);\n}\n\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> x(n - 1), y(n - 1), a(n - 1);\n    REP (i, n - 1) {\n        cin >> x[i] >> y[i] >> a[i];\n    }\n\n    // solve\n    int answer = solve(n, x, y, a);\n\n    // output\n    cout << answer << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nint A[MAXN], C[16], DP[1 << 16];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = 0;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tREP(i, n)\n\t\t++C[A[i]];\n\tFOR(i, 1, 16)\n\t{\n\t\tans += C[i] >> 1;\n\t\tC[i] &= 1;\n\t}\n\tFOR(i, 1, 1 << 16)\n\t\tDP[i] = INF;\n\tDP[0] = DP[1] = 0;\n\tFOR(mask, 1, 1 << 16)\n\t{\n\t\tRFOR(pos, 16, 1)\n\t\t{\n\t\t\tif (mask & (1 << pos))\n\t\t\t\tFOR(submask, 1, pos)\n\t\t\t{\n\t\t\t\tif ((pos | submask) == pos)\n\t\t\t\t{\n\t\t\t\t\tint cur = bool(mask & (1 << submask));\n\t\t\t\t\tcur += bool(mask & (1 << (pos ^ submask)));\n\t\t\t\t\tDP[mask] = min(DP[mask],\n\t\t\t\t\t\tcur + DP[mask ^ (1 << pos) ^ (1 << submask) ^ (1 << (pos ^ submask))]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint mask = 0;\n\tREP(i, 16)\n\t\tif (C[i] & 1)\n\t\t\tmask |= (1 << i);\n\tcout << ans + DP[mask];\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    int x, y, a;\n    vec v(N, 0);\n    REP(i, N - 1){\n        cin >> x >> y >> a;\n        v[x] ^= a;\n        v[y] ^= a;\n    }\n    vec cnt(16, 0);\n    for(int i: v) cnt[i]++;\n    int ans = 0;\n    int X = 0;\n    REP(i, 15){\n        ans += cnt[i + 1] / 2;\n        if(cnt[i + 1] % 2) X ^= bit(i);\n    }\n\n    vec dp(bit(15), INF);\n    dp[0] = 0;\n    FOR(n, 1, 15 + 1){\n        int comb = bit(n) - 1;\n        while(comb < bit(15)){\n            int tmp = 0;\n            REP(i, 15) if((comb >> i) & 1) tmp ^= (i + 1);\n            if(tmp == 0){\n                REP(i, 15) REP(j, 15) if(i != j && ((comb >> i) & 1) && ((comb >> j) & 1)){\n                    int k = ((i + 1) ^ (j + 1)) - 1;\n                    if((comb >> k) & 1) Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 2);\n                    else Min(dp[comb], dp[comb ^ bit(i) ^ bit(j) ^ bit(k)] + 1);\n                }\n            }\n            x = comb & -comb, y = comb + x;\n            comb = ((comb & ~y) / x >> 1) | y;\n        }\n    }\n    //vdebug(dp);\n    ans += dp[X];\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=100004;\nint n,m,a[N],f[N],ans;\nint main()\n{\n\tf[7]=2,f[25]=2,f[30]=3,f[42]=2,f[45]=3,f[51]=3,f[52]=2,f[75]=3,f[76]=2,f[82]=2,f[85]=3,f[97]=2,f[102]=3,f[120]=3,f[127]=5,f[385]=2,f[390]=3,f[408]=3,f[415]=5,f[427]=4,f[428]=4,f[434]=4,f[437]=4,f[458]=4,f[461]=4,f[467]=4,f[468]=4,f[480]=3,f[487]=5,f[505]=5,f[510]=6,f[642]=2,f[645]=3,f[667]=4,f[668]=4,f[680]=3,f[687]=5,f[689]=4,f[694]=4,f[713]=4,f[718]=4,f[720]=3,f[727]=5,f[739]=4,f[740]=4,f[762]=5,f[765]=6,f[771]=3,f[772]=2,f[794]=4,f[797]=4,f[809]=4,f[814]=4,f[816]=3,f[823]=5,f[840]=3,f[847]=5,f[849]=4,f[854]=4,f[866]=4,f[869]=4,f[891]=6,f[892]=5,f[1155]=3,f[1156]=2,f[1178]=4,f[1181]=4,f[1193]=4,f[1198]=4,f[1200]=3,f[1207]=5,f[1224]=3,f[1231]=5,f[1233]=4,f[1238]=4,f[1250]=4,f[1253]=4,f[1275]=6,f[1276]=5,f[1282]=2,f[1285]=3,f[1307]=4,f[1308]=4,f[1320]=3,f[1327]=5,f[1329]=4,f[1334]=4,f[1353]=4,f[1358]=4,f[1360]=3,f[1367]=5,f[1379]=4,f[1380]=4,f[1402]=5,f[1405]=6,f[1537]=2,f[1542]=3,f[1560]=3,f[1567]=5,f[1579]=4,f[1580]=4,f[1586]=4,f[1589]=4,f[1610]=4,f[1613]=4,f[1619]=4,f[1620]=4,f[1632]=3,f[1639]=5,f[1657]=5,f[1662]=6,f[1920]=3,f[1927]=5,f[1945]=5,f[1950]=6,f[1962]=5,f[1965]=6,f[1971]=6,f[1972]=5,f[1995]=6,f[1996]=5,f[2002]=5,f[2005]=6,f[2017]=5,f[2022]=6,f[2040]=6,f[2047]=8,f[2184]=2,f[2191]=4,f[2193]=3,f[2198]=4,f[2210]=3,f[2213]=4,f[2235]=5,f[2236]=4,f[2243]=4,f[2244]=3,f[2266]=4,f[2269]=5,f[2281]=4,f[2286]=5,f[2288]=4,f[2295]=6,f[2313]=3,f[2318]=4,f[2320]=2,f[2327]=4,f[2339]=4,f[2340]=3,f[2362]=4,f[2365]=5,f[2370]=3,f[2373]=4,f[2395]=5,f[2396]=4,f[2408]=4,f[2415]=6,f[2417]=4,f[2422]=5,f[2570]=3,f[2573]=4,f[2579]=4,f[2580]=3,f[2592]=2,f[2599]=4,f[2617]=4,f[2622]=5,f[2625]=3,f[2630]=4,f[2648]=4,f[2655]=6,f[2667]=5,f[2668]=4,f[2674]=4,f[2677]=5,f[2955]=5,f[2956]=4,f[2962]=4,f[2965]=5,f[2977]=4,f[2982]=5,f[3000]=5,f[3007]=7,f[3008]=4,f[3015]=6,f[3033]=6,f[3038]=6,f[3050]=6,f[3053]=6,f[3059]=6,f[3060]=6,f[3083]=4,f[3084]=3,f[3090]=3,f[3093]=4,f[3105]=3,f[3110]=4,f[3128]=4,f[3135]=6,f[3136]=2,f[3143]=4,f[3161]=4,f[3166]=5,f[3178]=4,f[3181]=5,f[3187]=5,f[3188]=4,f[3466]=4,f[3469]=5,f[3475]=5,f[3476]=4,f[3488]=4,f[3495]=6,f[3513]=6,f[3518]=6,f[3521]=4,f[3526]=5,f[3544]=5,f[3551]=7,f[3563]=6,f[3564]=6,f[3570]=6,f[3573]=6,f[3721]=4,f[3726]=5,f[3728]=4,f[3735]=6,f[3747]=5,f[3748]=4,f[3770]=6,f[3773]=6,f[3778]=4,f[3781]=5,f[3803]=6,f[3804]=6,f[3816]=5,f[3823]=7,f[3825]=6,f[3830]=6,f[3848]=4,f[3855]=6,f[3857]=4,f[3862]=5,f[3874]=4,f[3877]=5,f[3899]=6,f[3900]=6,f[3907]=5,f[3908]=4,f[3930]=6,f[3933]=6,f[3945]=6,f[3950]=6,f[3952]=5,f[3959]=7,f[4233]=3,f[4238]=4,f[4240]=2,f[4247]=4,f[4259]=4,f[4260]=3,f[4282]=4,f[4285]=5,f[4290]=3,f[4293]=4,f[4315]=5,f[4316]=4,f[4328]=4,f[4335]=6,f[4337]=4,f[4342]=5,f[4360]=2,f[4367]=4,f[4369]=3,f[4374]=4,f[4386]=3,f[4389]=4,f[4411]=5,f[4412]=4,f[4419]=4,f[4420]=3,f[4442]=4,f[4445]=5,f[4457]=4,f[4462]=5,f[4464]=4,f[4471]=6,f[4619]=4,f[4620]=3,f[4626]=3,f[4629]=4,f[4641]=3,f[4646]=4,f[4664]=4,f[4671]=6,f[4672]=2,f[4679]=4,f[4697]=4,f[4702]=5,f[4714]=4,f[4717]=5,f[4723]=5,f[4724]=4,f[5002]=4,f[5005]=5,f[5011]=5,f[5012]=4,f[5024]=4,f[5031]=6,f[5049]=6,f[5054]=6,f[5057]=4,f[5062]=5,f[5080]=5,f[5087]=7,f[5099]=6,f[5100]=6,f[5106]=6,f[5109]=6,f[5130]=3,f[5133]=4,f[5139]=4,f[5140]=3,f[5152]=2,f[5159]=4,f[5177]=4,f[5182]=5,f[5185]=3,f[5190]=4,f[5208]=4,f[5215]=6,f[5227]=5,f[5228]=4,f[5234]=4,f[5237]=5,f[5515]=5,f[5516]=4,f[5522]=4,f[5525]=5,f[5537]=4,f[5542]=5,f[5560]=5,f[5567]=7,f[5568]=4,f[5575]=6,f[5593]=6,f[5598]=6,f[5610]=6,f[5613]=6,f[5619]=6,f[5620]=6,f[5768]=4,f[5775]=6,f[5777]=4,f[5782]=5,f[5794]=4,f[5797]=5,f[5819]=6,f[5820]=6,f[5827]=5,f[5828]=4,f[5850]=6,f[5853]=6,f[5865]=6,f[5870]=6,f[5872]=5,f[5879]=7,f[5897]=4,f[5902]=5,f[5904]=4,f[5911]=6,f[5923]=5,f[5924]=4,f[5946]=6,f[5949]=6,f[5954]=4,f[5957]=5,f[5979]=6,f[5980]=6,f[5992]=5,f[5999]=7,f[6001]=6,f[6006]=6,f[6145]=2,f[6150]=3,f[6168]=3,f[6175]=5,f[6187]=4,f[6188]=4,f[6194]=4,f[6197]=4,f[6218]=4,f[6221]=4,f[6227]=4,f[6228]=4,f[6240]=3,f[6247]=5,f[6265]=5,f[6270]=6,f[6528]=3,f[6535]=5,f[6553]=5,f[6558]=6,f[6570]=5,f[6573]=6,f[6579]=6,f[6580]=5,f[6603]=6,f[6604]=5,f[6610]=5,f[6613]=6,f[6625]=5,f[6630]=6,f[6648]=6,f[6655]=8,f[6787]=4,f[6788]=4,f[6810]=5,f[6813]=6,f[6825]=5,f[6830]=6,f[6832]=4,f[6839]=6,f[6856]=4,f[6863]=6,f[6865]=5,f[6870]=6,f[6882]=5,f[6885]=6,f[6907]=7,f[6908]=6,f[6914]=4,f[6917]=4,f[6939]=6,f[6940]=5,f[6952]=4,f[6959]=6,f[6961]=5,f[6966]=6,f[6985]=5,f[6990]=6,f[6992]=4,f[6999]=6,f[7011]=6,f[7012]=5,f[7034]=6,f[7037]=7,f[7298]=4,f[7301]=4,f[7323]=6,f[7324]=5,f[7336]=4,f[7343]=6,f[7345]=5,f[7350]=6,f[7369]=5,f[7374]=6,f[7376]=4,f[7383]=6,f[7395]=6,f[7396]=5,f[7418]=6,f[7421]=7,f[7427]=4,f[7428]=4,f[7450]=5,f[7453]=6,f[7465]=5,f[7470]=6,f[7472]=4,f[7479]=6,f[7496]=4,f[7503]=6,f[7505]=5,f[7510]=6,f[7522]=5,f[7525]=6,f[7547]=7,f[7548]=6,f[7680]=3,f[7687]=5,f[7705]=5,f[7710]=6,f[7722]=5,f[7725]=6,f[7731]=6,f[7732]=5,f[7755]=6,f[7756]=5,f[7762]=5,f[7765]=6,f[7777]=5,f[7782]=6,f[7800]=6,f[7807]=8,f[8065]=5,f[8070]=6,f[8088]=6,f[8095]=8,f[8107]=7,f[8108]=6,f[8114]=6,f[8117]=7,f[8138]=6,f[8141]=7,f[8147]=7,f[8148]=6,f[8160]=6,f[8167]=8,f[8185]=8,f[8190]=8,f[8330]=3,f[8333]=4,f[8339]=4,f[8340]=3,f[8352]=2,f[8359]=4,f[8377]=4,f[8382]=5,f[8385]=3,f[8390]=4,f[8408]=4,f[8415]=6,f[8427]=5,f[8428]=4,f[8434]=4,f[8437]=5,f[8459]=4,f[8460]=3,f[8466]=3,f[8469]=4,f[8481]=3,f[8486]=4,f[8504]=4,f[8511]=6,f[8512]=2,f[8519]=4,f[8537]=4,f[8542]=5,f[8554]=4,f[8557]=5,f[8563]=5,f[8564]=4,f[8712]=2,f[8719]=4,f[8721]=3,f[8726]=4,f[8738]=3,f[8741]=4,f[8763]=5,f[8764]=4,f[8771]=4,f[8772]=3,f[8794]=4,f[8797]=5,f[8809]=4,f[8814]=5,f[8816]=4,f[8823]=6,f[9097]=4,f[9102]=5,f[9104]=4,f[9111]=6,f[9123]=5,f[9124]=4,f[9146]=6,f[9149]=6,f[9154]=4,f[9157]=5,f[9179]=6,f[9180]=6,f[9192]=5,f[9199]=7,f[9201]=6,f[9206]=6,f[9225]=3,f[9230]=4,f[9232]=2,f[9239]=4,f[9251]=4,f[9252]=3,f[9274]=4,f[9277]=5,f[9282]=3,f[9285]=4,f[9307]=5,f[9308]=4,f[9320]=4,f[9327]=6,f[9329]=4,f[9334]=5,f[9608]=4,f[9615]=6,f[9617]=4,f[9622]=5,f[9634]=4,f[9637]=5,f[9659]=6,f[9660]=6,f[9667]=5,f[9668]=4,f[9690]=6,f[9693]=6,f[9705]=6,f[9710]=6,f[9712]=5,f[9719]=7,f[9867]=5,f[9868]=4,f[9874]=4,f[9877]=5,f[9889]=4,f[9894]=5,f[9912]=5,f[9919]=7,f[9920]=4,f[9927]=6,f[9945]=6,f[9950]=6,f[9962]=6,f[9965]=6,f[9971]=6,f[9972]=6,f[9994]=4,f[9997]=5,f[10003]=5,f[10004]=4,f[10016]=4,f[10023]=6,f[10041]=6,f[10046]=6,f[10049]=4,f[10054]=5,f[10072]=5,f[10079]=7,f[10091]=6,f[10092]=6,f[10098]=6,f[10101]=6,f[10242]=2,f[10245]=3,f[10267]=4,f[10268]=4,f[10280]=3,f[10287]=5,f[10289]=4,f[10294]=4,f[10313]=4,f[10318]=4,f[10320]=3,f[10327]=5,f[10339]=4,f[10340]=4,f[10362]=5,f[10365]=6,f[10627]=4,f[10628]=4,f[10650]=5,f[10653]=6,f[10665]=5,f[10670]=6,f[10672]=4,f[10679]=6,f[10696]=4,f[10703]=6,f[10705]=5,f[10710]=6,f[10722]=5,f[10725]=6,f[10747]=7,f[10748]=6,f[10880]=3,f[10887]=5,f[10905]=5,f[10910]=6,f[10922]=5,f[10925]=6,f[10931]=6,f[10932]=5,f[10955]=6,f[10956]=5,f[10962]=5,f[10965]=6,f[10977]=5,f[10982]=6,f[11000]=6,f[11007]=8,f[11009]=4,f[11014]=4,f[11032]=4,f[11039]=6,f[11051]=6,f[11052]=5,f[11058]=5,f[11061]=6,f[11082]=5,f[11085]=6,f[11091]=6,f[11092]=5,f[11104]=4,f[11111]=6,f[11129]=6,f[11134]=7,f[11393]=4,f[11398]=4,f[11416]=4,f[11423]=6,f[11435]=6,f[11436]=5,f[11442]=5,f[11445]=6,f[11466]=5,f[11469]=6,f[11475]=6,f[11476]=5,f[11488]=4,f[11495]=6,f[11513]=6,f[11518]=7,f[11520]=3,f[11527]=5,f[11545]=5,f[11550]=6,f[11562]=5,f[11565]=6,f[11571]=6,f[11572]=5,f[11595]=6,f[11596]=5,f[11602]=5,f[11605]=6,f[11617]=5,f[11622]=6,f[11640]=6,f[11647]=8,f[11779]=4,f[11780]=4,f[11802]=5,f[11805]=6,f[11817]=5,f[11822]=6,f[11824]=4,f[11831]=6,f[11848]=4,f[11855]=6,f[11857]=5,f[11862]=6,f[11874]=5,f[11877]=6,f[11899]=7,f[11900]=6,f[12162]=5,f[12165]=6,f[12187]=7,f[12188]=6,f[12200]=6,f[12207]=8,f[12209]=6,f[12214]=7,f[12233]=6,f[12238]=7,f[12240]=6,f[12247]=8,f[12259]=7,f[12260]=6,f[12282]=8,f[12285]=8,f[12291]=3,f[12292]=2,f[12314]=4,f[12317]=4,f[12329]=4,f[12334]=4,f[12336]=3,f[12343]=5,f[12360]=3,f[12367]=5,f[12369]=4,f[12374]=4,f[12386]=4,f[12389]=4,f[12411]=6,f[12412]=5,f[12674]=4,f[12677]=4,f[12699]=6,f[12700]=5,f[12712]=4,f[12719]=6,f[12721]=5,f[12726]=6,f[12745]=5,f[12750]=6,f[12752]=4,f[12759]=6,f[12771]=6,f[12772]=5,f[12794]=6,f[12797]=7,f[12929]=4,f[12934]=4,f[12952]=4,f[12959]=6,f[12971]=6,f[12972]=5,f[12978]=5,f[12981]=6,f[13002]=5,f[13005]=6,f[13011]=6,f[13012]=5,f[13024]=4,f[13031]=6,f[13049]=6,f[13054]=7,f[13056]=3,f[13063]=5,f[13081]=5,f[13086]=6,f[13098]=5,f[13101]=6,f[13107]=6,f[13108]=5,f[13131]=6,f[13132]=5,f[13138]=5,f[13141]=6,f[13153]=5,f[13158]=6,f[13176]=6,f[13183]=8,f[13440]=3,f[13447]=5,f[13465]=5,f[13470]=6,f[13482]=5,f[13485]=6,f[13491]=6,f[13492]=5,f[13515]=6,f[13516]=5,f[13522]=5,f[13525]=6,f[13537]=5,f[13542]=6,f[13560]=6,f[13567]=8,f[13569]=4,f[13574]=4,f[13592]=4,f[13599]=6,f[13611]=6,f[13612]=5,f[13618]=5,f[13621]=6,f[13642]=5,f[13645]=6,f[13651]=6,f[13652]=5,f[13664]=4,f[13671]=6,f[13689]=6,f[13694]=7,f[13826]=4,f[13829]=4,f[13851]=6,f[13852]=5,f[13864]=4,f[13871]=6,f[13873]=5,f[13878]=6,f[13897]=5,f[13902]=6,f[13904]=4,f[13911]=6,f[13923]=6,f[13924]=5,f[13946]=6,f[13949]=7,f[14211]=6,f[14212]=5,f[14234]=6,f[14237]=7,f[14249]=6,f[14254]=7,f[14256]=6,f[14263]=8,f[14280]=6,f[14287]=8,f[14289]=6,f[14294]=7,f[14306]=6,f[14309]=7,f[14331]=8,f[14332]=8,f[14475]=5,f[14476]=4,f[14482]=4,f[14485]=5,f[14497]=4,f[14502]=5,f[14520]=5,f[14527]=7,f[14528]=4,f[14535]=6,f[14553]=6,f[14558]=6,f[14570]=6,f[14573]=6,f[14579]=6,f[14580]=6,f[14602]=4,f[14605]=5,f[14611]=5,f[14612]=4,f[14624]=4,f[14631]=6,f[14649]=6,f[14654]=6,f[14657]=4,f[14662]=5,f[14680]=5,f[14687]=7,f[14699]=6,f[14700]=6,f[14706]=6,f[14709]=6,f[14857]=4,f[14862]=5,f[14864]=4,f[14871]=6,f[14883]=5,f[14884]=4,f[14906]=6,f[14909]=6,f[14914]=4,f[14917]=5,f[14939]=6,f[14940]=6,f[14952]=5,f[14959]=7,f[14961]=6,f[14966]=6,f[15240]=5,f[15247]=7,f[15249]=6,f[15254]=6,f[15266]=6,f[15269]=6,f[15291]=8,f[15292]=7,f[15299]=6,f[15300]=6,f[15322]=7,f[15325]=8,f[15337]=7,f[15342]=8,f[15344]=6,f[15351]=8,f[15368]=4,f[15375]=6,f[15377]=4,f[15382]=5,f[15394]=4,f[15397]=5,f[15419]=6,f[15420]=6,f[15427]=5,f[15428]=4,f[15450]=6,f[15453]=6,f[15465]=6,f[15470]=6,f[15472]=5,f[15479]=7,f[15753]=6,f[15758]=6,f[15760]=5,f[15767]=7,f[15779]=6,f[15780]=6,f[15802]=7,f[15805]=8,f[15810]=6,f[15813]=6,f[15835]=8,f[15836]=7,f[15848]=6,f[15855]=8,f[15857]=7,f[15862]=8,f[16010]=6,f[16013]=6,f[16019]=6,f[16020]=6,f[16032]=5,f[16039]=7,f[16057]=7,f[16062]=8,f[16065]=6,f[16070]=6,f[16088]=6,f[16095]=8,f[16107]=8,f[16108]=7,f[16114]=7,f[16117]=8,f[16139]=6,f[16140]=6,f[16146]=6,f[16149]=6,f[16161]=6,f[16166]=6,f[16184]=6,f[16191]=8,f[16192]=5,f[16199]=7,f[16217]=7,f[16222]=8,f[16234]=7,f[16237]=8,f[16243]=8,f[16244]=7,f[16523]=4,f[16524]=3,f[16530]=3,f[16533]=4,f[16545]=3,f[16550]=4,f[16568]=4,f[16575]=6,f[16576]=2,f[16583]=4,f[16601]=4,f[16606]=5,f[16618]=4,f[16621]=5,f[16627]=5,f[16628]=4,f[16650]=3,f[16653]=4,f[16659]=4,f[16660]=3,f[16672]=2,f[16679]=4,f[16697]=4,f[16702]=5,f[16705]=3,f[16710]=4,f[16728]=4,f[16735]=6,f[16747]=5,f[16748]=4,f[16754]=4,f[16757]=5,f[16905]=3,f[16910]=4,f[16912]=2,f[16919]=4,f[16931]=4,f[16932]=3,f[16954]=4,f[16957]=5,f[16962]=3,f[16965]=4,f[16987]=5,f[16988]=4,f[17000]=4,f[17007]=6,f[17009]=4,f[17014]=5,f[17288]=4,f[17295]=6,f[17297]=4,f[17302]=5,f[17314]=4,f[17317]=5,f[17339]=6,f[17340]=6,f[17347]=5,f[17348]=4,f[17370]=6,f[17373]=6,f[17385]=6,f[17390]=6,f[17392]=5,f[17399]=7,f[17416]=2,f[17423]=4,f[17425]=3,f[17430]=4,f[17442]=3,f[17445]=4,f[17467]=5,f[17468]=4,f[17475]=4,f[17476]=3,f[17498]=4,f[17501]=5,f[17513]=4,f[17518]=5,f[17520]=4,f[17527]=6,f[17801]=4,f[17806]=5,f[17808]=4,f[17815]=6,f[17827]=5,f[17828]=4,f[17850]=6,f[17853]=6,f[17858]=4,f[17861]=5,f[17883]=6,f[17884]=6,f[17896]=5,f[17903]=7,f[17905]=6,f[17910]=6,f[18058]=4,f[18061]=5,f[18067]=5,f[18068]=4,f[18080]=4,f[18087]=6,f[18105]=6,f[18110]=6,f[18113]=4,f[18118]=5,f[18136]=5,f[18143]=7,f[18155]=6,f[18156]=6,f[18162]=6,f[18165]=6,f[18187]=5,f[18188]=4,f[18194]=4,f[18197]=5,f[18209]=4,f[18214]=5,f[18232]=5,f[18239]=7,f[18240]=4,f[18247]=6,f[18265]=6,f[18270]=6,f[18282]=6,f[18285]=6,f[18291]=6,f[18292]=6,f[18435]=3,f[18436]=2,f[18458]=4,f[18461]=4,f[18473]=4,f[18478]=4,f[18480]=3,f[18487]=5,f[18504]=3,f[18511]=5,f[18513]=4,f[18518]=4,f[18530]=4,f[18533]=4,f[18555]=6,f[18556]=5,f[18818]=4,f[18821]=4,f[18843]=6,f[18844]=5,f[18856]=4,f[18863]=6,f[18865]=5,f[18870]=6,f[18889]=5,f[18894]=6,f[18896]=4,f[18903]=6,f[18915]=6,f[18916]=5,f[18938]=6,f[18941]=7,f[19073]=4,f[19078]=4,f[19096]=4,f[19103]=6,f[19115]=6,f[19116]=5,f[19122]=5,f[19125]=6,f[19146]=5,f[19149]=6,f[19155]=6,f[19156]=5,f[19168]=4,f[19175]=6,f[19193]=6,f[19198]=7,f[19200]=3,f[19207]=5,f[19225]=5,f[19230]=6,f[19242]=5,f[19245]=6,f[19251]=6,f[19252]=5,f[19275]=6,f[19276]=5,f[19282]=5,f[19285]=6,f[19297]=5,f[19302]=6,f[19320]=6,f[19327]=8,f[19584]=3,f[19591]=5,f[19609]=5,f[19614]=6,f[19626]=5,f[19629]=6,f[19635]=6,f[19636]=5,f[19659]=6,f[19660]=5,f[19666]=5,f[19669]=6,f[19681]=5,f[19686]=6,f[19704]=6,f[19711]=8,f[19713]=4,f[19718]=4,f[19736]=4,f[19743]=6,f[19755]=6,f[19756]=5,f[19762]=5,f[19765]=6,f[19786]=5,f[19789]=6,f[19795]=6,f[19796]=5,f[19808]=4,f[19815]=6,f[19833]=6,f[19838]=7,f[19970]=4,f[19973]=4,f[19995]=6,f[19996]=5,f[20008]=4,f[20015]=6,f[20017]=5,f[20022]=6,f[20041]=5,f[20046]=6,f[20048]=4,f[20055]=6,f[20067]=6,f[20068]=5,f[20090]=6,f[20093]=7,f[20355]=6,f[20356]=5,f[20378]=6,f[20381]=7,f[20393]=6,f[20398]=7,f[20400]=6,f[20407]=8,f[20424]=6,f[20431]=8,f[20433]=6,f[20438]=7,f[20450]=6,f[20453]=7,f[20475]=8,f[20476]=8,f[20482]=2,f[20485]=3,f[20507]=4,f[20508]=4,f[20520]=3,f[20527]=5,f[20529]=4,f[20534]=4,f[20553]=4,f[20558]=4,f[20560]=3,f[20567]=5,f[20579]=4,f[20580]=4,f[20602]=5,f[20605]=6,f[20867]=4,f[20868]=4,f[20890]=5,f[20893]=6,f[20905]=5,f[20910]=6,f[20912]=4,f[20919]=6,f[20936]=4,f[20943]=6,f[20945]=5,f[20950]=6,f[20962]=5,f[20965]=6,f[20987]=7,f[20988]=6,f[21120]=3,f[21127]=5,f[21145]=5,f[21150]=6,f[21162]=5,f[21165]=6,f[21171]=6,f[21172]=5,f[21195]=6,f[21196]=5,f[21202]=5,f[21205]=6,f[21217]=5,f[21222]=6,f[21240]=6,f[21247]=8,f[21249]=4,f[21254]=4,f[21272]=4,f[21279]=6,f[21291]=6,f[21292]=5,f[21298]=5,f[21301]=6,f[21322]=5,f[21325]=6,f[21331]=6,f[21332]=5,f[21344]=4,f[21351]=6,f[21369]=6,f[21374]=7,f[21633]=4,f[21638]=4,f[21656]=4,f[21663]=6,f[21675]=6,f[21676]=5,f[21682]=5,f[21685]=6,f[21706]=5,f[21709]=6,f[21715]=6,f[21716]=5,f[21728]=4,f[21735]=6,f[21753]=6,f[21758]=7,f[21760]=3,f[21767]=5,f[21785]=5,f[21790]=6,f[21802]=5,f[21805]=6,f[21811]=6,f[21812]=5,f[21835]=6,f[21836]=5,f[21842]=5,f[21845]=6,f[21857]=5,f[21862]=6,f[21880]=6,f[21887]=8,f[22019]=4,f[22020]=4,f[22042]=5,f[22045]=6,f[22057]=5,f[22062]=6,f[22064]=4,f[22071]=6,f[22088]=4,f[22095]=6,f[22097]=5,f[22102]=6,f[22114]=5,f[22117]=6,f[22139]=7,f[22140]=6,f[22402]=5,f[22405]=6,f[22427]=7,f[22428]=6,f[22440]=6,f[22447]=8,f[22449]=6,f[22454]=7,f[22473]=6,f[22478]=7,f[22480]=6,f[22487]=8,f[22499]=7,f[22500]=6,f[22522]=8,f[22525]=8,f[22666]=4,f[22669]=5,f[22675]=5,f[22676]=4,f[22688]=4,f[22695]=6,f[22713]=6,f[22718]=6,f[22721]=4,f[22726]=5,f[22744]=5,f[22751]=7,f[22763]=6,f[22764]=6,f[22770]=6,f[22773]=6,f[22795]=5,f[22796]=4,f[22802]=4,f[22805]=5,f[22817]=4,f[22822]=5,f[22840]=5,f[22847]=7,f[22848]=4,f[22855]=6,f[22873]=6,f[22878]=6,f[22890]=6,f[22893]=6,f[22899]=6,f[22900]=6,f[23048]=4,f[23055]=6,f[23057]=4,f[23062]=5,f[23074]=4,f[23077]=5,f[23099]=6,f[23100]=6,f[23107]=5,f[23108]=4,f[23130]=6,f[23133]=6,f[23145]=6,f[23150]=6,f[23152]=5,f[23159]=7,f[23433]=6,f[23438]=6,f[23440]=5,f[23447]=7,f[23459]=6,f[23460]=6,f[23482]=7,f[23485]=8,f[23490]=6,f[23493]=6,f[23515]=8,f[23516]=7,f[23528]=6,f[23535]=8,f[23537]=7,f[23542]=8,f[23561]=4,f[23566]=5,f[23568]=4,f[23575]=6,f[23587]=5,f[23588]=4,f[23610]=6,f[23613]=6,f[23618]=4,f[23621]=5,f[23643]=6,f[23644]=6,f[23656]=5,f[23663]=7,f[23665]=6,f[23670]=6,f[23944]=5,f[23951]=7,f[23953]=6,f[23958]=6,f[23970]=6,f[23973]=6,f[23995]=8,f[23996]=7,f[24003]=6,f[24004]=6,f[24026]=7,f[24029]=8,f[24041]=7,f[24046]=8,f[24048]=6,f[24055]=8,f[24203]=6,f[24204]=6,f[24210]=6,f[24213]=6,f[24225]=6,f[24230]=6,f[24248]=6,f[24255]=8,f[24256]=5,f[24263]=7,f[24281]=7,f[24286]=8,f[24298]=7,f[24301]=8,f[24307]=8,f[24308]=7,f[24330]=6,f[24333]=6,f[24339]=6,f[24340]=6,f[24352]=5,f[24359]=7,f[24377]=7,f[24382]=8,f[24385]=6,f[24390]=6,f[24408]=6,f[24415]=8,f[24427]=8,f[24428]=7,f[24434]=7,f[24437]=8,f[24577]=2,f[24582]=3,f[24600]=3,f[24607]=5,f[24619]=4,f[24620]=4,f[24626]=4,f[24629]=4,f[24650]=4,f[24653]=4,f[24659]=4,f[24660]=4,f[24672]=3,f[24679]=5,f[24697]=5,f[24702]=6,f[24960]=3,f[24967]=5,f[24985]=5,f[24990]=6,f[25002]=5,f[25005]=6,f[25011]=6,f[25012]=5,f[25035]=6,f[25036]=5,f[25042]=5,f[25045]=6,f[25057]=5,f[25062]=6,f[25080]=6,f[25087]=8,f[25219]=4,f[25220]=4,f[25242]=5,f[25245]=6,f[25257]=5,f[25262]=6,f[25264]=4,f[25271]=6,f[25288]=4,f[25295]=6,f[25297]=5,f[25302]=6,f[25314]=5,f[25317]=6,f[25339]=7,f[25340]=6,f[25346]=4,f[25349]=4,f[25371]=6,f[25372]=5,f[25384]=4,f[25391]=6,f[25393]=5,f[25398]=6,f[25417]=5,f[25422]=6,f[25424]=4,f[25431]=6,f[25443]=6,f[25444]=5,f[25466]=6,f[25469]=7,f[25730]=4,f[25733]=4,f[25755]=6,f[25756]=5,f[25768]=4,f[25775]=6,f[25777]=5,f[25782]=6,f[25801]=5,f[25806]=6,f[25808]=4,f[25815]=6,f[25827]=6,f[25828]=5,f[25850]=6,f[25853]=7,f[25859]=4,f[25860]=4,f[25882]=5,f[25885]=6,f[25897]=5,f[25902]=6,f[25904]=4,f[25911]=6,f[25928]=4,f[25935]=6,f[25937]=5,f[25942]=6,f[25954]=5,f[25957]=6,f[25979]=7,f[25980]=6,f[26112]=3,f[26119]=5,f[26137]=5,f[26142]=6,f[26154]=5,f[26157]=6,f[26163]=6,f[26164]=5,f[26187]=6,f[26188]=5,f[26194]=5,f[26197]=6,f[26209]=5,f[26214]=6,f[26232]=6,f[26239]=8,f[26497]=5,f[26502]=6,f[26520]=6,f[26527]=8,f[26539]=7,f[26540]=6,f[26546]=6,f[26549]=7,f[26570]=6,f[26573]=7,f[26579]=7,f[26580]=6,f[26592]=6,f[26599]=8,f[26617]=8,f[26622]=8,f[26761]=4,f[26766]=5,f[26768]=4,f[26775]=6,f[26787]=5,f[26788]=4,f[26810]=6,f[26813]=6,f[26818]=4,f[26821]=5,f[26843]=6,f[26844]=6,f[26856]=5,f[26863]=7,f[26865]=6,f[26870]=6,f[26888]=4,f[26895]=6,f[26897]=4,f[26902]=5,f[26914]=4,f[26917]=5,f[26939]=6,f[26940]=6,f[26947]=5,f[26948]=4,f[26970]=6,f[26973]=6,f[26985]=6,f[26990]=6,f[26992]=5,f[26999]=7,f[27147]=5,f[27148]=4,f[27154]=4,f[27157]=5,f[27169]=4,f[27174]=5,f[27192]=5,f[27199]=7,f[27200]=4,f[27207]=6,f[27225]=6,f[27230]=6,f[27242]=6,f[27245]=6,f[27251]=6,f[27252]=6,f[27530]=6,f[27533]=6,f[27539]=6,f[27540]=6,f[27552]=5,f[27559]=7,f[27577]=7,f[27582]=8,f[27585]=6,f[27590]=6,f[27608]=6,f[27615]=8,f[27627]=8,f[27628]=7,f[27634]=7,f[27637]=8,f[27658]=4,f[27661]=5,f[27667]=5,f[27668]=4,f[27680]=4,f[27687]=6,f[27705]=6,f[27710]=6,f[27713]=4,f[27718]=5,f[27736]=5,f[27743]=7,f[27755]=6,f[27756]=6,f[27762]=6,f[27765]=6,f[28043]=6,f[28044]=6,f[28050]=6,f[28053]=6,f[28065]=6,f[28070]=6,f[28088]=6,f[28095]=8,f[28096]=5,f[28103]=7,f[28121]=7,f[28126]=8,f[28138]=7,f[28141]=8,f[28147]=8,f[28148]=7,f[28296]=5,f[28303]=7,f[28305]=6,f[28310]=6,f[28322]=6,f[28325]=6,f[28347]=8,f[28348]=7,f[28355]=6,f[28356]=6,f[28378]=7,f[28381]=8,f[28393]=7,f[28398]=8,f[28400]=6,f[28407]=8,f[28425]=6,f[28430]=6,f[28432]=5,f[28439]=7,f[28451]=6,f[28452]=6,f[28474]=7,f[28477]=8,f[28482]=6,f[28485]=6,f[28507]=8,f[28508]=7,f[28520]=6,f[28527]=8,f[28529]=7,f[28534]=8,f[28808]=4,f[28815]=6,f[28817]=4,f[28822]=5,f[28834]=4,f[28837]=5,f[28859]=6,f[28860]=6,f[28867]=5,f[28868]=4,f[28890]=6,f[28893]=6,f[28905]=6,f[28910]=6,f[28912]=5,f[28919]=7,f[28937]=4,f[28942]=5,f[28944]=4,f[28951]=6,f[28963]=5,f[28964]=4,f[28986]=6,f[28989]=6,f[28994]=4,f[28997]=5,f[29019]=6,f[29020]=6,f[29032]=5,f[29039]=7,f[29041]=6,f[29046]=6,f[29194]=4,f[29197]=5,f[29203]=5,f[29204]=4,f[29216]=4,f[29223]=6,f[29241]=6,f[29246]=6,f[29249]=4,f[29254]=5,f[29272]=5,f[29279]=7,f[29291]=6,f[29292]=6,f[29298]=6,f[29301]=6,f[29579]=6,f[29580]=6,f[29586]=6,f[29589]=6,f[29601]=6,f[29606]=6,f[29624]=6,f[29631]=8,f[29632]=5,f[29639]=7,f[29657]=7,f[29662]=8,f[29674]=7,f[29677]=8,f[29683]=8,f[29684]=7,f[29707]=5,f[29708]=4,f[29714]=4,f[29717]=5,f[29729]=4,f[29734]=5,f[29752]=5,f[29759]=7,f[29760]=4,f[29767]=6,f[29785]=6,f[29790]=6,f[29802]=6,f[29805]=6,f[29811]=6,f[29812]=6,f[30090]=6,f[30093]=6,f[30099]=6,f[30100]=6,f[30112]=5,f[30119]=7,f[30137]=7,f[30142]=8,f[30145]=6,f[30150]=6,f[30168]=6,f[30175]=8,f[30187]=8,f[30188]=7,f[30194]=7,f[30197]=8,f[30345]=6,f[30350]=6,f[30352]=5,f[30359]=7,f[30371]=6,f[30372]=6,f[30394]=7,f[30397]=8,f[30402]=6,f[30405]=6,f[30427]=8,f[30428]=7,f[30440]=6,f[30447]=8,f[30449]=7,f[30454]=8,f[30472]=5,f[30479]=7,f[30481]=6,f[30486]=6,f[30498]=6,f[30501]=6,f[30523]=8,f[30524]=7,f[30531]=6,f[30532]=6,f[30554]=7,f[30557]=8,f[30569]=7,f[30574]=8,f[30576]=6,f[30583]=8,f[30720]=3,f[30727]=5,f[30745]=5,f[30750]=6,f[30762]=5,f[30765]=6,f[30771]=6,f[30772]=5,f[30795]=6,f[30796]=5,f[30802]=5,f[30805]=6,f[30817]=5,f[30822]=6,f[30840]=6,f[30847]=8,f[31105]=5,f[31110]=6,f[31128]=6,f[31135]=8,f[31147]=7,f[31148]=6,f[31154]=6,f[31157]=7,f[31178]=6,f[31181]=7,f[31187]=7,f[31188]=6,f[31200]=6,f[31207]=8,f[31225]=8,f[31230]=8,f[31362]=5,f[31365]=6,f[31387]=7,f[31388]=6,f[31400]=6,f[31407]=8,f[31409]=6,f[31414]=7,f[31433]=6,f[31438]=7,f[31440]=6,f[31447]=8,f[31459]=7,f[31460]=6,f[31482]=8,f[31485]=8,f[31491]=6,f[31492]=5,f[31514]=6,f[31517]=7,f[31529]=6,f[31534]=7,f[31536]=6,f[31543]=8,f[31560]=6,f[31567]=8,f[31569]=6,f[31574]=7,f[31586]=6,f[31589]=7,f[31611]=8,f[31612]=8,f[31875]=6,f[31876]=5,f[31898]=6,f[31901]=7,f[31913]=6,f[31918]=7,f[31920]=6,f[31927]=8,f[31944]=6,f[31951]=8,f[31953]=6,f[31958]=7,f[31970]=6,f[31973]=7,f[31995]=8,f[31996]=8,f[32002]=5,f[32005]=6,f[32027]=7,f[32028]=6,f[32040]=6,f[32047]=8,f[32049]=6,f[32054]=7,f[32073]=6,f[32078]=7,f[32080]=6,f[32087]=8,f[32099]=7,f[32100]=6,f[32122]=8,f[32125]=8,f[32257]=5,f[32262]=6,f[32280]=6,f[32287]=8,f[32299]=7,f[32300]=6,f[32306]=6,f[32309]=7,f[32330]=6,f[32333]=7,f[32339]=7,f[32340]=6,f[32352]=6,f[32359]=8,f[32377]=8,f[32382]=8,f[32640]=6,f[32647]=8,f[32665]=8,f[32670]=8,f[32682]=8,f[32685]=8,f[32691]=8,f[32692]=8,f[32715]=8,f[32716]=8,f[32722]=8,f[32725]=8,f[32737]=8,f[32742]=8,f[32760]=8,f[32767]=10;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z;a[y]^=z;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i])\n\t\t{\n\t\t\tif((m>>a[i]-1)&1)ans++;\n\t\t\tm^=(1<<a[i]-1);\n\t\t}\n\tprintf(\"%d\",ans+f[m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std ;\nconst int MAXN = 1e5 + 10 ;\nint n , a[MAXN] , cnt[MAXN] , sum[1 << 16] , f[1 << 16] , ans , t ;\nint min (int a , int b) {\n\treturn a < b ? a : b ;\n}\nint main () {\n\tscanf (\"%d\" , &n) ;\n\tfor (int i = 1 ; i < n ; i++) {\n\t\tint u , v , w ;\n\t\tscanf (\"%d %d %d\" , &u , &v , &w) ;\n\t\ta[u] ^= w ; a[v] ^= w ;\n\t}\n\tfor (int i = 0 ; i < n ; i++) cnt[a[i]]++ ;\n\tfor (int i = 1 ; i < 16 ; i++) {\n\t\tans += (cnt[i] >> 1) ;\n\t\tif (cnt[i] & 1) t |= (1 << (i - 1)) ;\n\t}\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tf[i] = f[i >> 1] + (i & 1) ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++) f[i]-- ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tfor (int j = 0 ; j < 15 ; j++)\n\t\t\tif (i & (1 << j)) \n\t\t\t\tsum[i] ^= (j + 1) ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tif (!sum[i])\n\t\t\tfor (int j = (i - 1) & i ; j ; j = (j - 1) & i)\n\t\t\t\tif (!sum[j])\n\t\t\t\t\tf[i] = min (f[i] , f[j] + f[i ^ j]) ;\n\tprintf (\"%d\\n\" , ans + f[t]) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef int64_t LL;\ntypedef uint64_t ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\ntemplate<class T, class... U> void DEBUG(const T &head, const U &... tail) { \n#ifdef HOME\n    _W('#'); _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...);\n#endif\n}\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nint a[SIZE],N,dp[1<<16],bit_cnt[1<<16],xor_v[1<<16];\nint main(){\n    REP(i,1<<16){\n        bit_cnt[i]=bit_cnt[i>>1]+(i&1);\n        REP(j,16){\n            if((i>>j)&1)xor_v[i]^=j;\n        }\n    }\n    R(N);\n    REPP(i,1,N){\n        int x,y,v;R(x,y,v);\n        a[x]^=v;\n        a[y]^=v;\n    }\n    int cnt[16]={};\n    REP(i,N)cnt[a[i]]++;\n    int an=0;\n    int mask=0;\n    REPP(i,1,16){\n        an+=cnt[i]/2;\n        if(cnt[i]&1)mask|=1<<i;\n    }\n    if(mask){\n        for(int i=2;i<=mask;i+=2){\n            if((i&mask)!=i)continue;\n            if(xor_v[i])continue;\n            dp[i]=24;\n            for(int j=i;j;j=(j-1)&mask){\n                if(xor_v[j]==0){\n                    dp[i]=min(dp[i],dp[i^j]+bit_cnt[j]-1);\n                }\n            }\n        }\n        an+=dp[mask];\n    }\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<16;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[16], f[MaxM];\nbool xr[MaxM];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[x]^=z, v[y]^=z;\n\tfor (int i=0; i<n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=0; i< 15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=(i+1);\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint n;\nint ps[100000];\nint cnt[16];\nint dp[1 << 16];\n\nint bitcount(int x) {\n    int ret = 0;\n    while (x) {\n        ret += (x & 1);\n        x >>= 1;\n    }\n    return ret;\n}\n\nint xorbit(int x) {\n    int ret = 0;\n    for (int i = 0; i < 16; ++i) {\n        if ((x >> i) & 1) ret ^= i;\n    }\n    return ret;\n}\nvector<int> bc[16];\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n        int x, y, a;\n        cin >> x >> y >> a;\n        ps[x] ^= a;\n        ps[y] ^= a;\n\t}\n\tfor (int i = 0; i < n; ++i) ++cnt[ps[i]];\n\tint ans = cnt[0];\n\tint val = 0;\n\tfor (int i = 1; i < 16; ++i) {\n        ans += (cnt[i] >> 1);\n        if (cnt[i] & 1) val ^= (1 << i);\n\t}\n\tfor (int i = 0; i < (1 << 16); i += 2) {\n        if (xorbit(i)) continue;\n        bc[bitcount(i)].push_back(i);\n\t}\n\t\n\tfor (int it = 2; it < 16; ++it) {\n        for (int i : bc[it]) {\n            for (int j = 1; j < 16; ++j) {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = 1; k < j; ++k) {\n                    if (((i >> k) & 1) == 0) continue;\n                    dp[i] = max(dp[i], dp[i ^ (1 << j) ^ (1 << k) ^ (1 << (j ^ k))] + ((i >> (j ^ k)) & 1));\n                }\n            }\n        }\n\t}\n\t\n\tans += dp[val];\n\tprintf(\"%d\\n\", n - ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint in[N],n,ans,is,msk,to = 1<<26,from;\nvector<int>v;\nshort dp[1<<26];\nvoid val(int msk){\n\tv.clear();\n\twhile(msk)\n\t\tv.push_back(msk%3),\n\t\tmsk/=3;\n\twhile(v.size() < 16)v.push_back(0);\n}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1,a,b,c;i < n;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tin[a]^=c;\n\t\tin[b]^=c;\n\t}\n\tfor(int i = 0;i < n;i++)\n\t\tans+=!!(is&(1<<in[i])) && in[i],\n\t\tis^=1<<in[i];\n\tis&=(~0) + 1;\n\tfor(int i = 0;i < to;i++)dp[i] = 17;\n \tfor(int i = 15;i+ 1;i--)msk = msk*3 + (!(is&(1<<i)) ? 2 : 0);\n\tdp[msk] = 0;\n\tfor(int i = 0;i < to;i++)\n\t\tif(dp[i] < 17){\n\t\t\tval(i);\n\t\t\tint three = 1, freq = 0,temp = 0;\n\t\t\tfrom = 0;\n\t\t\tfor(int j = 0;j < v.size();j++,three*=3){\n\t\t\t\tif(!v[j])dp[i + three] = min(dp[i + three],dp[i]);\n\t\t\t\tif(v[j] == 1)temp^=j,freq++;\n\t\t\t\tfrom = from*3 + (v[j] ? 2 : 0);\n\t\t\t}\n\t\t\tshort lol = dp[i] + freq - (freq > 1);\n\t\t\tif(!temp)dp[from] = min(dp[from],lol);\n\t\t}\n\tfrom = 0;\n\tfor(int i = 0;i < 16;i++)from = from*3 + 2;\n\tcout << ans + dp[from] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxn=100005;\nint n,x[maxn],a[16],dp[1<<16],s,mask[1<<16];\nvector<int> v;\nvector<pii> G[maxn];\nvoid dfs(int u,int fa) {\n    for (int i=0;i<(int)G[u].size();++i) {\n        int v=G[u][i].first,w=G[u][i].second;\n        if (v==fa)\n            continue;\n        x[v]=w^x[u];\n        dfs(v,u);\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=0;i<n-1;++i) {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        x[u]^=w;\n        x[v]^=w;\n        G[u].push_back(pii(v,w));\n        G[v].push_back(pii(u,w));\n    }\n    //dfs(0,-1);\n    for (int i=0;i<n;++i)\n        ++a[x[i]];\n    int res=n-a[0];\n    for (int i=1;i<16;++i) {\n        if (a[i]%2==1)\n            v.push_back(i);\n        res-=a[i]/2;\n    }\n    if (!v.size())\n        return 0*printf(\"%d\\n\",res);\n    s=1<<v.size();\n    for (int i=0;i<s;++i)\n        for (int j=0;j<(int)v.size();++j)\n            if (i&(1<<j))\n                mask[i]^=v[j];\n    for (int i=0;i<s;++i)\n        for (int j=0;j<(int)v.size();++j)\n            if (i&(1<<j))\n                dp[i]=max(dp[i],dp[i^(1<<j)]+(mask[i]==0));\n    printf(\"res=%d dp=%d\\n\",res,res-dp[s-1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[33],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<17;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nvector <pair <int, int> > G[100005];\nint V[100005], Ap[100005];\nint DP[(1 << 16) + 5];\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y, c;\n        cin >> x >> y >> c;\n        ++x;\n        ++y;\n        G[x].push_back(make_pair(y, c));\n        G[y].push_back(make_pair(x, c));\n    }\n}\n\nvoid precalcV()\n{\n    for(int i = 1; i <= N; i++)\n    {\n        for(int j = 0; j < G[i].size(); j++)\n        {\n            int neighb = G[i][j].first;\n            V[i] ^= G[i][j].second;\n        }\n    }\n}\n\nvoid precalcDP()\n{\n    for(int conf = 1; conf < (1 << 16); conf++)\n    {\n        vector <int> Aux;\n        DP[conf] = -1;\n        for(int j = 0; j < 16; j++)\n            if((conf & (1 << j)))\n            {\n                Aux.push_back(j);\n            }\n        int sz = Aux.size();\n        for(int k = 1; k < (1 << sz); k++)\n        {\n            int sum = 0, c = 0;\n            for(int j = 0; j < sz; j++)\n                if((k & (1 << j)))\n                    sum ^= Aux[j], c += (1 << Aux[j]);\n            if(sum == 0 && DP[conf ^ c] != -1)\n                DP[conf] = max(DP[conf], DP[conf ^ c] + 1);\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= N; i++)\n    {\n        Ap[V[i]]++;\n    }\n    ans += Ap[0];\n    int c = 0;\n    for(int i = 1; i <= 15; i++)\n    {\n        ans += Ap[i] / 2;\n        Ap[i] %= 2;\n        if(Ap[i] == 1)\n            c += (1 << i);\n    }\n    if(DP[c] != -1)\n        ans += DP[c];\n    cout << N - ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    precalcV();\n    precalcDP();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nvector<int> subset[1 << 16];\nint Xor[1 << 16];\n\nint cc[1 << 16];\nint dp(int mask) {\n    if(mask == 0) return 0;\n    int &ret = cc[mask];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    for(int i = 0; i < subset[mask].size(); i++) {\n        if(Xor[ subset[mask][i] ] == 0) {\n            ret = max(ret, 1 + dp(mask ^ subset[mask][i]));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    subset[0].push_back(0);\n    for(int i = 1; i < (1 << 16); i++) {\n        for(int j = 0; j < subset[ i - (i & -i) ].size(); j++) {\n            subset[i].push_back(subset[ i - (i & -i) ][j]);\n            subset[i].push_back(subset[ i - (i & -i) ][j] + (i & -i));\n        }\n    }\n\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    int ans = cnt[0];\n    int mask = 0;\n    for(int i = 1; i <= 15; i++) {\n        ans += cnt[i] / 2;\n        if(cnt[i] % 2) mask ^= (1 << i);\n    }\n\n    for(int i = 0; i < (1 << 16); i++) {\n        Xor[i] = 0;\n        for(int j = 0; j < 16; j++) {\n            if(i & (1 << j)) Xor[i] ^= j;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n    ans += dp(mask);\n    printf(\"%d\", N - ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n#define bit(a , b) (((a)>>(b))&1)\n\nconst int maxn = 1e5 + 20;\nconst int maxm = 16;\n\nint t[maxn] , a[maxm] , dp[1 << maxm];\n\nint And[1 << maxm];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b , c;\n\t\tcin >> a >> b >> c;\n\n\t\tt[a] ^= c;\n\t\tt[b] ^= c;\n\t}\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[t[i]]++;\n\n\tint res = a[0] , mask = 0;\n\tfor(int i = 1; i < maxm; i++)\n\t{\n\t\tres += a[i] / 2;\n\t\ta[i] %= 2;\n\n\t\tmask += (1 << i) * a[i];\n\t}\n\n\tfor(int i = 0; i < maxm; i++)\n\t\tAnd[1 << i] = i;\n\n\tfor(int mask = 1; mask < (1 << maxm); mask++)\n\t{\n\t\tint lb = (mask&(-mask));\n\n\t\tif(lb == mask)\n\t\t\tcontinue;\n\n\t\tAnd[mask] = And[mask ^ lb] ^ And[lb];\n\t}\n\n\tfor(int mask = 1; mask < (1 << maxm); mask++)\n\t{\n\t\tif(And[mask] != 0)\n\t\t\tcontinue;\n\n\t\tdp[mask] = 1;\n\t\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask)\n\t\t\tif(submask != mask && And[submask] == 0)\n\t\t\t\tdp[mask] = max(dp[mask] , dp[submask] + 1);\n\t}\n\n\tcout << n - res - dp[mask] << endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, sum[100005], cnt[16], dp[1 << 15];\nvector<pair<int, int>> g[100005];\n\nvoid dfs(int u, int fa) {\n\tfor (const auto &e : g[u]) {\n\t\tint v = e.first, w = e.second;\n\t\tif (v != fa) ++cnt[sum[v] = sum[u] ^ w], dfs(v, u);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v, c; i < n; ++i) {\n\t\tscanf(\"%d%d%d\", &u, &v, &c);\n\t\tg[u].emplace_back(v, c);\n\t\tg[v].emplace_back(u, c);\n\t}\n\tdfs(0, -1);\n\tint ans = 0, buc = 0;\n\tfor (int i = 1; i < 16; ++i) ans += cnt[i] >> 1, buc |= (cnt[i] & 1) << i - 1;\n\tfor (int s = 1; s <= buc; ++s) {\n\t\tint t = 0;\n\t\tfor (int i = 0; i < 15; ++i)\n\t\t\tif (s >> i & 1) ++dp[s], t ^= i + 1;\n\t\tdp[s] -= !t;\n\t\tfor (int t = s - 1 & s; t; t = t - 1 & s)\n\t\t\tdp[s] = min(dp[s], dp[t] + dp[s ^ t]);\n\t}\n\tprintf(\"%d\\n\", ans + dp[buc]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        A[u]^=A[to.fi];\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+1);\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+1);\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<20;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n        }\n        else{\n            dp[n][(val^i)]=temp[i]+1;\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nint dp[1 << 16];\nint f[100005];\nint g[1 << 16];\nint main(){\n    for(int i = 1; i < (1 << 16); i++)\n    for(int j = 0; j < 16; j++) if(i >> j & 1) g[i] ^= j;\n    for(int i = 1; i < (1 << 16); i++){\n        dp[i] = 1 << 29;\n        for(int mask = i; mask; mask = (mask - 1) & i)\n            dp[i] = min(dp[i], (g[mask] == 0 ? __builtin_popcount(mask) - 1 : (1 << 29)) + dp[i ^ mask]);\n    }\n    int n; sd(n);\n    for(int i = 0; i < n - 1; i++){\n        int u, v, a; sd(u); sd(v); sd(a);\n        f[u] ^= a;\n        f[v] ^= a;\n    }\n    int mask = 0, ans = 0;\n    vector<int> cnt(16);\n    for(int i = 0; i < n; i++) cnt[f[i]]++;\n    for(int i = 1; i < 16; i++){\n        ans += cnt[i] / 2;\n        if(cnt[i] & 1) mask |= 1 << i;\n    }\n    ans += dp[mask];\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 100000, T = 14348907;\nint n, fr[N][16], an, dp[T];\nvector<pair<int, int> > tr[N];\n\nvoid go(int v = 0, int p = -1, int c = 0){\n\tf(i, 0, tr[v].size()){\n\t\tint u = tr[v][i].first;\n\t\tif (u == p)continue;\n\t\tgo(u, v, tr[v][i].second);\n\t\tf(j, 1, 16)fr[v][j] += fr[u][j];\n\t}\n\tf(i, 1, 16)an += fr[v][i] >> 1, fr[v][i] &= 1;\n\tint x = 0;\n\tf(i, 1, 16)if (fr[v][i])x ^= i;\n\tif (v)++fr[v][x ^ c];\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tf(i, 1, n){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ttr[a].push_back(make_pair(b, c));\n\t\ttr[b].push_back(make_pair(a, c));\n\t}\n\tgo();\n\tf(i, 0, T){\n\t\tint old = 0, nw = 0, x = 0, t = i, j = 1, th = 2;\n\t\tbool br = false;\n\t\twhile (t){\n\t\t\tint z = t % 3;\n\t\t\tif (z == 1 && fr[0][j] == 0) { br = true; break; }\n\t\t\tif (z == 1)x ^= j;\n\t\t\t++j;\n\t\t\tt /= 3;\n\t\t\told += (z > 1) * th;\n\t\t\tnw += (z > 0) * th;\n\t\t\tth *= 3;\n\t\t}\n\t\tif (br || x || old == nw)continue;\n\t\tdp[nw] = max(dp[nw], dp[old] + 1);\n\t}\n\tint z = dp[T - 1], ff = 0;\n\tf(i, 1, 16)if (fr[0][i])++ff;\n\tan += ff - z;\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> L >> R >> K;\n\t\tv[L] ^= K;\n\t\tv[R] ^= K;\n\t}\n\tvector<int>b(16);\n\tfor (auto i : v) {\n\t\tb[i]++;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tans += b[i] / 2;\n\t\tb[i] %= 2;\n\t}\n\tvector<int>dp(1 << 16, MOD);\n\tint cnt = 0;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tif (b[i]) {\n\t\t\tcnt |= 1 << i;\n\t\t}\n\t}\n\tdp[cnt] = 0;\n\t//cout << cnt << endl;\n\t//cout << ans << endl;\n\tfor (int i = (1 << 16) - 2; i > 0; i -= 2) {\n\t//\tcout << i << endl;\n\t\tfor (int j = 1; j < 16; j++) {\n\t\t\tfor (int k = j + 1; k < 16; k++) {\n\t\t\t\tif (i&(1 << j) && i & (1 << k)) {\n\t\t\t\t\tif (dp[i] != MOD) {\n\t\t\t\t\t//\tcout << i << \" \" << j << \" \" << k << endl;\n\t\t\t\t\t\tfor (int l = 1; l < 16; l++) {\n\t\t\t\t\t\t\tint box = j ^ l;\n\t\t\t\t\t\t\tint bag = k ^ l;\n\t\t\t\t\t\t\tint add = 1;\n\t\t\t\t\t\t\tint cbit = i - (1 << j) - (1 << k);\n\t\t\t\t\t\t\tif (box) {\n\t\t\t\t\t\t\t\tif (cbit&(1 << box)) {\n\t\t\t\t\t\t\t\t\tcbit -= 1 << box;\n\t\t\t\t\t\t\t\t\tadd++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcbit += 1 << box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bag) {\n\t\t\t\t\t\t\t\tif (cbit&(1 << bag)) {\n\t\t\t\t\t\t\t\t\tcbit -= 1 << bag;\n\t\t\t\t\t\t\t\t\tadd++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcbit += 1 << bag;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t//\tcout << cbit << endl;\n\t\t\t\t\t\t\tdp[cbit] = min(dp[cbit], dp[i] + add);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans + dp[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rgt register\n#define rint rgt int\n#define LL long long\n#define rll rgt LL\n#define inf 0x7f7f7f7f\n#define N 100007\nusing namespace std;\nconst int T=1<<15;\ntemplate<class K>inline bool cmax(K&a,const K&b){return(a<b)?a=b,1:0;}\ntemplate<class K>inline bool cmin(K&a,const K&b){return(a>b)?a=b,1:0;}\ninline int read() {\n\trint s=0;\n\trgt char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();\n\treturn s;\n}\nint n,t,d[N],sum[19],f[T+3],st,ans,p[T+3];\nint main()\n{\n\trint i,j,x,y,val;n=read();\n\tfor(i=1;i<n;i++)\n\t\tx=read()+1,y=read()+1,val=read(),d[x]^=val,d[y]^=val;\n\tfor(i=1;i<=n;i++) ++sum[d[i]];\n\tfor(i=1;i<16;i++) ans+=sum[i]>>1,st|=(sum[i]&1)<<(i-1);\n\tfor(i=1;i<T;i++) f[i]=f[i>>1]+(i&1);\n\tfor(i=1;i<T;i++) --f[i];\n\tfor(i=0;i<T;i++)\n\t\tfor(j=0;j<15;j++)\n\t\t\tif((i>>j)&1) p[i]^=(j+1);\n\tfor(i=0;i<T;i++) {\n\t\tif(p[i]) continue;\n\t\tfor(j=(i-1)&i;j;j=(j-1)&i)\n\t\t\tif(!p[j]) f[i]=min(f[i],f[j]+f[i^j]);\n\t}printf(\"%d\",ans+f[st]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<Bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+100;\nint cnt[N],v[N],dp[N];\nint dfs(int s)\n{\n\tif(s==0) return 0;\n\tif(dp[s]!=-1) return dp[s];\n\tdp[s]=0x3f3f3f3f;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tif(s>>i&1)\n\t\t{\n\t\t\tfor(int j=0;j<16;j++)\n\t\t\t{\n\t\t\t\tif(s>>j&1)\n\t\t\t\t{\n\t\t\t\t\tint x=i^j;int ns=s^(1<<i)^(1<<j)^(1<<x);\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t dp[s]=min(dp[s],dfs(ns)+1+((s&(1<<x))==(1<<x)));\n\t\t\t\t}\n\t\t\t} \n\t    }\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;\n\t\tv[y]^=z;\n\t}\n\tmemset(dp,-1,sizeof dp);\n\tfor(int i=0;i<n;i++)\n\t if(v[i]) cnt[v[i]]++;\n\tint st=0,ans=0;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst|=(cnt[i]&1)*(1<<i);\n\t} \n\tans+=dfs(st);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nint w[N] , d[N] , cnt[20] , res , n , st , book[N] , sxr[N];\nint main()\n{\n    scanf(\"%d\" , &n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}\n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1; \n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++)\n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\n\nint solve(int n, const vector<int> & x, const vector<int> & y, const vector<int> & a) {\n    constexpr int MAX_A = 0xf;\n    assert (*max_element(ALL(a)) <= MAX_A);\n\n    // make the adjacent list\n    vector<vector<int> > g(n);\n    REP (i, n - 1) {\n        g[x[i]].push_back(y[i]);\n        g[y[i]].push_back(x[i]);\n    }\n\n    // fix a root\n    vector<int> parent(n, -1);\n    constexpr int root = 0; {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (j != parent[i]) {\n                parent[j] = i;\n                go(j);\n            }\n        };\n        go(root);\n    }\n\n    // move labels to nodes\n    vector<int> b(n, -1);\n    REP (i, n - 1) {\n        if (parent[x[i]] == y[i]) {\n            b[x[i]] = a[i];\n        } else if (x[i] == parent[y[i]]) {\n            b[y[i]] = a[i];\n        } else {\n            assert (false);\n        }\n    }\n\n    // tree dp\n    int removed = 0;\n    function<int (int)> go = [&](int i) {\n        int cnt1 = 0;\n        for (int j : g[i]) if (j != parent[i]) {\n            int cnt2 = go(j);\n            REP (x, MAX_A + 1) if (cnt2 & (1 << x)) {\n                removed += (bool)(cnt1 & (1 << x));\n                cnt1 ^= 1 << x;\n            }\n        }\n        int k = b[i];\n        if (k != -1) {\n            REP (x, MAX_A + 1) if (cnt1 & (1 << x)) {\n                k ^= x;\n            }\n            if (k != 0) {\n                removed += (bool)(cnt1 & (1 << k));\n                cnt1 ^= 1 << k;\n            }\n        }\n        return cnt1;\n    };\n    int cnt = go(root);\n\n    // finialize\n    constexpr int INF = 1e9 + 7;\n    vector<int> dp(1 << (MAX_A + 1), INF);\n    dp[0] = 0;\n    REP (s, 1 << (MAX_A + 1)) if ((s | cnt) == cnt) {\n        for (int t = 0; t != s; t = (t - s) & s) {  // t is a proper subset of s\n            if (__builtin_popcount(s ^ t) == 1) {\n                chmin(dp[s], dp[t] + 1);\n            } else {\n                int acc = 0;\n                REP (x, MAX_A + 1) if ((s ^ t) & (1 << x)) {\n                    acc ^= x;\n                }\n                if (acc == 0) {\n                    chmin(dp[s], dp[t] + __builtin_popcount(s ^ t) - 1);\n                }\n            }\n        }\n    }\n    return removed + dp[cnt];\n}\n\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> x(n - 1), y(n - 1), a(n - 1);\n    REP (i, n - 1) {\n        cin >> x[i] >> y[i] >> a[i];\n    }\n\n    // solve\n    int answer = solve(n, x, y, a);\n\n    // output\n    cout << answer << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tvvi G(n);\n\trep(i,n-1){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tG[a].pb(c);\n\t\tG[b].pb(c);\n\t}\n\tmap<int,int>ma;\n\trep(i,n){\n\t\tint x=0;\n\t\trep(j,G[i].size())x^=G[i][j];\n\t\tif(x)ma[x]++;\n\t}\n\tint m=0,out=0;\n\tFOR(a,ma){\n\t\tout+=a.second/2;\n\t\tif(a.second%2)m+=1<<a.first;\n\t}\n\tvi dp(1<<15,inf);\n\tdp[0]=0;\n\tm/=2;\n\trep(i,1<<15){\n\t\trep(j,15)if((i&1<<j)==0)cmin(dp[i|1<<j],dp[i]+1);\n\t\tint t=1<<15;\n\t\tt-=1+i;\n\t\tfor(int j=t;j>0;j=(j-1)&t){\n\t\t\tint x=0,c=0;\n\t\t\trep(k,15)if(j&1<<k)x^=1+k,c++;\n\t\t\tif(x)continue;\n\t\t\tcmin(dp[i|j],dp[i]+c-1);\n\t\t}\n\t}\n\tcout<<out+dp[m]<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22],lg[66666];\nint f[66666],q[66666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tint ans=0;\n\tfor(register int i=2,j=1;i<65536;i<<=1,++j)lg[i]=j;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])++w;//w|=1<<i;\n\tf[w]=0;\n\t/*for(q[hq=1]=w,tq=2;hq!=tq;++hq)\n\t{\n\t\tint o=q[hq];\n\t\tint l=lg[o&-o];\n\t\tfor(register int i=l+1;i<16;++i)\n\t\t\tif(o&1<<i)\n\t}*/\n\tprintf(\"%d\\n\",ans+dmax(w-1,0)); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=100004;\nint n,m,a[N],f[N],ans;\nint main()\n{\n\tf[7]=2,f[25]=2,f[30]=3,f[42]=2,f[45]=3,f[51]=3,f[52]=2,f[75]=3,f[76]=2,f[82]=2,f[85]=3,f[97]=2,f[102]=3,f[120]=3,f[127]=5,f[385]=2,f[390]=3,f[408]=3,f[415]=5,f[427]=4,f[428]=4,f[434]=4,f[437]=4,f[458]=4,f[461]=4,f[467]=4,f[468]=4,f[480]=3,f[487]=5,f[505]=5,f[510]=6,f[642]=2,f[645]=3,f[667]=4,f[668]=4,f[680]=3,f[687]=5,f[689]=4,f[694]=4,f[713]=4,f[718]=4,f[720]=3,f[727]=5,f[739]=4,f[740]=4,f[762]=5,f[765]=6,f[771]=3,f[772]=2,f[794]=4,f[797]=4,f[809]=4,f[814]=4,f[816]=3,f[823]=5,f[840]=3,f[847]=5,f[849]=4,f[854]=4,f[866]=4,f[869]=4,f[891]=6,f[892]=5,f[1155]=3,f[1156]=2,f[1178]=4,f[1181]=4,f[1193]=4,f[1198]=4,f[1200]=3,f[1207]=5,f[1224]=3,f[1231]=5,f[1233]=4,f[1238]=4,f[1250]=4,f[1253]=4,f[1275]=6,f[1276]=5,f[1282]=2,f[1285]=3,f[1307]=4,f[1308]=4,f[1320]=3,f[1327]=5,f[1329]=4,f[1334]=4,f[1353]=4,f[1358]=4,f[1360]=3,f[1367]=5,f[1379]=4,f[1380]=4,f[1402]=5,f[1405]=6,f[1537]=2,f[1542]=3,f[1560]=3,f[1567]=5,f[1579]=4,f[1580]=4,f[1586]=4,f[1589]=4,f[1610]=4,f[1613]=4,f[1619]=4,f[1620]=4,f[1632]=3,f[1639]=5,f[1657]=5,f[1662]=6,f[1920]=3,f[1927]=5,f[1945]=5,f[1950]=6,f[1962]=5,f[1965]=6,f[1971]=6,f[1972]=5,f[1995]=6,f[1996]=5,f[2002]=5,f[2005]=6,f[2017]=5,f[2022]=6,f[2040]=6,f[2047]=8,f[2184]=2,f[2191]=4,f[2193]=3,f[2198]=4,f[2210]=3,f[2213]=4,f[2235]=5,f[2236]=4,f[2243]=4,f[2244]=3,f[2266]=4,f[2269]=5,f[2281]=4,f[2286]=5,f[2288]=4,f[2295]=6,f[2313]=3,f[2318]=4,f[2320]=2,f[2327]=4,f[2339]=4,f[2340]=3,f[2362]=4,f[2365]=5,f[2370]=3,f[2373]=4,f[2395]=5,f[2396]=4,f[2408]=4,f[2415]=6,f[2417]=4,f[2422]=5,f[2570]=3,f[2573]=4,f[2579]=4,f[2580]=3,f[2592]=2,f[2599]=4,f[2617]=4,f[2622]=5,f[2625]=3,f[2630]=4,f[2648]=4,f[2655]=6,f[2667]=5,f[2668]=4,f[2674]=4,f[2677]=5,f[2955]=5,f[2956]=4,f[2962]=4,f[2965]=5,f[2977]=4,f[2982]=5,f[3000]=5,f[3007]=7,f[3008]=4,f[3015]=6,f[3033]=6,f[3038]=6,f[3050]=6,f[3053]=6,f[3059]=6,f[3060]=6,f[3083]=4,f[3084]=3,f[3090]=3,f[3093]=4,f[3105]=3,f[3110]=4,f[3128]=4,f[3135]=6,f[3136]=2,f[3143]=4,f[3161]=4,f[3166]=5,f[3178]=4,f[3181]=5,f[3187]=5,f[3188]=4,f[3466]=4,f[3469]=5,f[3475]=5,f[3476]=4,f[3488]=4,f[3495]=6,f[3513]=6,f[3518]=6,f[3521]=4,f[3526]=5,f[3544]=5,f[3551]=7,f[3563]=6,f[3564]=6,f[3570]=6,f[3573]=6,f[3721]=4,f[3726]=5,f[3728]=4,f[3735]=6,f[3747]=5,f[3748]=4,f[3770]=6,f[3773]=6,f[3778]=4,f[3781]=5,f[3803]=6,f[3804]=6,f[3816]=5,f[3823]=7,f[3825]=6,f[3830]=6,f[3848]=4,f[3855]=6,f[3857]=4,f[3862]=5,f[3874]=4,f[3877]=5,f[3899]=6,f[3900]=6,f[3907]=5,f[3908]=4,f[3930]=6,f[3933]=6,f[3945]=6,f[3950]=6,f[3952]=5,f[3959]=7,f[4233]=3,f[4238]=4,f[4240]=2,f[4247]=4,f[4259]=4,f[4260]=3,f[4282]=4,f[4285]=5,f[4290]=3,f[4293]=4,f[4315]=5,f[4316]=4,f[4328]=4,f[4335]=6,f[4337]=4,f[4342]=5,f[4360]=2,f[4367]=4,f[4369]=3,f[4374]=4,f[4386]=3,f[4389]=4,f[4411]=5,f[4412]=4,f[4419]=4,f[4420]=3,f[4442]=4,f[4445]=5,f[4457]=4,f[4462]=5,f[4464]=4,f[4471]=6,f[4619]=4,f[4620]=3,f[4626]=3,f[4629]=4,f[4641]=3,f[4646]=4,f[4664]=4,f[4671]=6,f[4672]=2,f[4679]=4,f[4697]=4,f[4702]=5,f[4714]=4,f[4717]=5,f[4723]=5,f[4724]=4,f[5002]=4,f[5005]=5,f[5011]=5,f[5012]=4,f[5024]=4,f[5031]=6,f[5049]=6,f[5054]=6,f[5057]=4,f[5062]=5,f[5080]=5,f[5087]=7,f[5099]=6,f[5100]=6,f[5106]=6,f[5109]=6,f[5130]=3,f[5133]=4,f[5139]=4,f[5140]=3,f[5152]=2,f[5159]=4,f[5177]=4,f[5182]=5,f[5185]=3,f[5190]=4,f[5208]=4,f[5215]=6,f[5227]=5,f[5228]=4,f[5234]=4,f[5237]=5,f[5515]=5,f[5516]=4,f[5522]=4,f[5525]=5,f[5537]=4,f[5542]=5,f[5560]=5,f[5567]=7,f[5568]=4,f[5575]=6,f[5593]=6,f[5598]=6,f[5610]=6,f[5613]=6,f[5619]=6,f[5620]=6,f[5768]=4,f[5775]=6,f[5777]=4,f[5782]=5,f[5794]=4,f[5797]=5,f[5819]=6,f[5820]=6,f[5827]=5,f[5828]=4,f[5850]=6,f[5853]=6,f[5865]=6,f[5870]=6,f[5872]=5,f[5879]=7,f[5897]=4,f[5902]=5,f[5904]=4,f[5911]=6,f[5923]=5,f[5924]=4,f[5946]=6,f[5949]=6,f[5954]=4,f[5957]=5,f[5979]=6,f[5980]=6,f[5992]=5,f[5999]=7,f[6001]=6,f[6006]=6,f[6145]=2,f[6150]=3,f[6168]=3,f[6175]=5,f[6187]=4,f[6188]=4,f[6194]=4,f[6197]=4,f[6218]=4,f[6221]=4,f[6227]=4,f[6228]=4,f[6240]=3,f[6247]=5,f[6265]=5,f[6270]=6,f[6528]=3,f[6535]=5,f[6553]=5,f[6558]=6,f[6570]=5,f[6573]=6,f[6579]=6,f[6580]=5,f[6603]=6,f[6604]=5,f[6610]=5,f[6613]=6,f[6625]=5,f[6630]=6,f[6648]=6,f[6655]=8,f[6787]=4,f[6788]=4,f[6810]=5,f[6813]=6,f[6825]=5,f[6830]=6,f[6832]=4,f[6839]=6,f[6856]=4,f[6863]=6,f[6865]=5,f[6870]=6,f[6882]=5,f[6885]=6,f[6907]=7,f[6908]=6,f[6914]=4,f[6917]=4,f[6939]=6,f[6940]=5,f[6952]=4,f[6959]=6,f[6961]=5,f[6966]=6,f[6985]=5,f[6990]=6,f[6992]=4,f[6999]=6,f[7011]=6,f[7012]=5,f[7034]=6,f[7037]=7,f[7298]=4,f[7301]=4,f[7323]=6,f[7324]=5,f[7336]=4,f[7343]=6,f[7345]=5,f[7350]=6,f[7369]=5,f[7374]=6,f[7376]=4,f[7383]=6,f[7395]=6,f[7396]=5,f[7418]=6,f[7421]=7,f[7427]=4,f[7428]=4,f[7450]=5,f[7453]=6,f[7465]=5,f[7470]=6,f[7472]=4,f[7479]=6,f[7496]=4,f[7503]=6,f[7505]=5,f[7510]=6,f[7522]=5,f[7525]=6,f[7547]=7,f[7548]=6,f[7680]=3,f[7687]=5,f[7705]=5,f[7710]=6,f[7722]=5,f[7725]=6,f[7731]=6,f[7732]=5,f[7755]=6,f[7756]=5,f[7762]=5,f[7765]=6,f[7777]=5,f[7782]=6,f[7800]=6,f[7807]=8,f[8065]=5,f[8070]=6,f[8088]=6,f[8095]=8,f[8107]=7,f[8108]=6,f[8114]=6,f[8117]=7,f[8138]=6,f[8141]=7,f[8147]=7,f[8148]=6,f[8160]=6,f[8167]=8,f[8185]=8,f[8190]=8,f[8330]=3,f[8333]=4,f[8339]=4,f[8340]=3,f[8352]=2,f[8359]=4,f[8377]=4,f[8382]=5,f[8385]=3,f[8390]=4,f[8408]=4,f[8415]=6,f[8427]=5,f[8428]=4,f[8434]=4,f[8437]=5,f[8459]=4,f[8460]=3,f[8466]=3,f[8469]=4,f[8481]=3,f[8486]=4,f[8504]=4,f[8511]=6,f[8512]=2,f[8519]=4,f[8537]=4,f[8542]=5,f[8554]=4,f[8557]=5,f[8563]=5,f[8564]=4,f[8712]=2,f[8719]=4,f[8721]=3,f[8726]=4,f[8738]=3,f[8741]=4,f[8763]=5,f[8764]=4,f[8771]=4,f[8772]=3,f[8794]=4,f[8797]=5,f[8809]=4,f[8814]=5,f[8816]=4,f[8823]=6,f[9097]=4,f[9102]=5,f[9104]=4,f[9111]=6,f[9123]=5,f[9124]=4,f[9146]=6,f[9149]=6,f[9154]=4,f[9157]=5,f[9179]=6,f[9180]=6,f[9192]=5,f[9199]=7,f[9201]=6,f[9206]=6,f[9225]=3,f[9230]=4,f[9232]=2,f[9239]=4,f[9251]=4,f[9252]=3,f[9274]=4,f[9277]=5,f[9282]=3,f[9285]=4,f[9307]=5,f[9308]=4,f[9320]=4,f[9327]=6,f[9329]=4,f[9334]=5,f[9608]=4,f[9615]=6,f[9617]=4,f[9622]=5,f[9634]=4,f[9637]=5,f[9659]=6,f[9660]=6,f[9667]=5,f[9668]=4,f[9690]=6,f[9693]=6,f[9705]=6,f[9710]=6,f[9712]=5,f[9719]=7,f[9867]=5,f[9868]=4,f[9874]=4,f[9877]=5,f[9889]=4,f[9894]=5,f[9912]=5,f[9919]=7,f[9920]=4,f[9927]=6,f[9945]=6,f[9950]=6,f[9962]=6,f[9965]=6,f[9971]=6,f[9972]=6,f[9994]=4,f[9997]=5,f[10003]=5,f[10004]=4,f[10016]=4,f[10023]=6,f[10041]=6,f[10046]=6,f[10049]=4,f[10054]=5,f[10072]=5,f[10079]=7,f[10091]=6,f[10092]=6,f[10098]=6,f[10101]=6,f[10242]=2,f[10245]=3,f[10267]=4,f[10268]=4,f[10280]=3,f[10287]=5,f[10289]=4,f[10294]=4,f[10313]=4,f[10318]=4,f[10320]=3,f[10327]=5,f[10339]=4,f[10340]=4,f[10362]=5,f[10365]=6,f[10627]=4,f[10628]=4,f[10650]=5,f[10653]=6,f[10665]=5,f[10670]=6,f[10672]=4,f[10679]=6,f[10696]=4,f[10703]=6,f[10705]=5,f[10710]=6,f[10722]=5,f[10725]=6,f[10747]=7,f[10748]=6,f[10880]=3,f[10887]=5,f[10905]=5,f[10910]=6,f[10922]=5,f[10925]=6,f[10931]=6,f[10932]=5,f[10955]=6,f[10956]=5,f[10962]=5,f[10965]=6,f[10977]=5,f[10982]=6,f[11000]=6,f[11007]=8,f[11009]=4,f[11014]=4,f[11032]=4,f[11039]=6,f[11051]=6,f[11052]=5,f[11058]=5,f[11061]=6,f[11082]=5,f[11085]=6,f[11091]=6,f[11092]=5,f[11104]=4,f[11111]=6,f[11129]=6,f[11134]=7,f[11393]=4,f[11398]=4,f[11416]=4,f[11423]=6,f[11435]=6,f[11436]=5,f[11442]=5,f[11445]=6,f[11466]=5,f[11469]=6,f[11475]=6,f[11476]=5,f[11488]=4,f[11495]=6,f[11513]=6,f[11518]=7,f[11520]=3,f[11527]=5,f[11545]=5,f[11550]=6,f[11562]=5,f[11565]=6,f[11571]=6,f[11572]=5,f[11595]=6,f[11596]=5,f[11602]=5,f[11605]=6,f[11617]=5,f[11622]=6,f[11640]=6,f[11647]=8,f[11779]=4,f[11780]=4,f[11802]=5,f[11805]=6,f[11817]=5,f[11822]=6,f[11824]=4,f[11831]=6,f[11848]=4,f[11855]=6,f[11857]=5,f[11862]=6,f[11874]=5,f[11877]=6,f[11899]=7,f[11900]=6,f[12162]=5,f[12165]=6,f[12187]=7,f[12188]=6,f[12200]=6,f[12207]=8,f[12209]=6,f[12214]=7,f[12233]=6,f[12238]=7,f[12240]=6,f[12247]=8,f[12259]=7,f[12260]=6,f[12282]=8,f[12285]=8,f[12291]=3,f[12292]=2,f[12314]=4,f[12317]=4,f[12329]=4,f[12334]=4,f[12336]=3,f[12343]=5,f[12360]=3,f[12367]=5,f[12369]=4,f[12374]=4,f[12386]=4,f[12389]=4,f[12411]=6,f[12412]=5,f[12674]=4,f[12677]=4,f[12699]=6,f[12700]=5,f[12712]=4,f[12719]=6,f[12721]=5,f[12726]=6,f[12745]=5,f[12750]=6,f[12752]=4,f[12759]=6,f[12771]=6,f[12772]=5,f[12794]=6,f[12797]=7,f[12929]=4,f[12934]=4,f[12952]=4,f[12959]=6,f[12971]=6,f[12972]=5,f[12978]=5,f[12981]=6,f[13002]=5,f[13005]=6,f[13011]=6,f[13012]=5,f[13024]=4,f[13031]=6,f[13049]=6,f[13054]=7,f[13056]=3,f[13063]=5,f[13081]=5,f[13086]=6,f[13098]=5,f[13101]=6,f[13107]=6,f[13108]=5,f[13131]=6,f[13132]=5,f[13138]=5,f[13141]=6,f[13153]=5,f[13158]=6,f[13176]=6,f[13183]=8,f[13440]=3,f[13447]=5,f[13465]=5,f[13470]=6,f[13482]=5,f[13485]=6,f[13491]=6,f[13492]=5,f[13515]=6,f[13516]=5,f[13522]=5,f[13525]=6,f[13537]=5,f[13542]=6,f[13560]=6,f[13567]=8,f[13569]=4,f[13574]=4,f[13592]=4,f[13599]=6,f[13611]=6,f[13612]=5,f[13618]=5,f[13621]=6,f[13642]=5,f[13645]=6,f[13651]=6,f[13652]=5,f[13664]=4,f[13671]=6,f[13689]=6,f[13694]=7,f[13826]=4,f[13829]=4,f[13851]=6,f[13852]=5,f[13864]=4,f[13871]=6,f[13873]=5,f[13878]=6,f[13897]=5,f[13902]=6,f[13904]=4,f[13911]=6,f[13923]=6,f[13924]=5,f[13946]=6,f[13949]=7,f[14211]=6,f[14212]=5,f[14234]=6,f[14237]=7,f[14249]=6,f[14254]=7,f[14256]=6,f[14263]=8,f[14280]=6,f[14287]=8,f[14289]=6,f[14294]=7,f[14306]=6,f[14309]=7,f[14331]=8,f[14332]=8,f[14475]=5,f[14476]=4,f[14482]=4,f[14485]=5,f[14497]=4,f[14502]=5,f[14520]=5,f[14527]=7,f[14528]=4,f[14535]=6,f[14553]=6,f[14558]=6,f[14570]=6,f[14573]=6,f[14579]=6,f[14580]=6,f[14602]=4,f[14605]=5,f[14611]=5,f[14612]=4,f[14624]=4,f[14631]=6,f[14649]=6,f[14654]=6,f[14657]=4,f[14662]=5,f[14680]=5,f[14687]=7,f[14699]=6,f[14700]=6,f[14706]=6,f[14709]=6,f[14857]=4,f[14862]=5,f[14864]=4,f[14871]=6,f[14883]=5,f[14884]=4,f[14906]=6,f[14909]=6,f[14914]=4,f[14917]=5,f[14939]=6,f[14940]=6,f[14952]=5,f[14959]=7,f[14961]=6,f[14966]=6,f[15240]=5,f[15247]=7,f[15249]=6,f[15254]=6,f[15266]=6,f[15269]=6,f[15291]=8,f[15292]=7,f[15299]=6,f[15300]=6,f[15322]=7,f[15325]=8,f[15337]=7,f[15342]=8,f[15344]=6,f[15351]=8,f[15368]=4,f[15375]=6,f[15377]=4,f[15382]=5,f[15394]=4,f[15397]=5,f[15419]=6,f[15420]=6,f[15427]=5,f[15428]=4,f[15450]=6,f[15453]=6,f[15465]=6,f[15470]=6,f[15472]=5,f[15479]=7,f[15753]=6,f[15758]=6,f[15760]=5,f[15767]=7,f[15779]=6,f[15780]=6,f[15802]=7,f[15805]=8,f[15810]=6,f[15813]=6,f[15835]=8,f[15836]=7,f[15848]=6,f[15855]=8,f[15857]=7,f[15862]=8,f[16010]=6,f[16013]=6,f[16019]=6,f[16020]=6,f[16032]=5,f[16039]=7,f[16057]=7,f[16062]=8,f[16065]=6,f[16070]=6,f[16088]=6,f[16095]=8,f[16107]=8,f[16108]=7,f[16114]=7,f[16117]=8,f[16139]=6,f[16140]=6,f[16146]=6,f[16149]=6,f[16161]=6,f[16166]=6,f[16184]=6,f[16191]=8,f[16192]=5,f[16199]=7,f[16217]=7,f[16222]=8,f[16234]=7,f[16237]=8,f[16243]=8,f[16244]=7,f[16523]=4,f[16524]=3,f[16530]=3,f[16533]=4,f[16545]=3,f[16550]=4,f[16568]=4,f[16575]=6,f[16576]=2,f[16583]=4,f[16601]=4,f[16606]=5,f[16618]=4,f[16621]=5,f[16627]=5,f[16628]=4,f[16650]=3,f[16653]=4,f[16659]=4,f[16660]=3,f[16672]=2,f[16679]=4,f[16697]=4,f[16702]=5,f[16705]=3,f[16710]=4,f[16728]=4,f[16735]=6,f[16747]=5,f[16748]=4,f[16754]=4,f[16757]=5,f[16905]=3,f[16910]=4,f[16912]=2,f[16919]=4,f[16931]=4,f[16932]=3,f[16954]=4,f[16957]=5,f[16962]=3,f[16965]=4,f[16987]=5,f[16988]=4,f[17000]=4,f[17007]=6,f[17009]=4,f[17014]=5,f[17288]=4,f[17295]=6,f[17297]=4,f[17302]=5,f[17314]=4,f[17317]=5,f[17339]=6,f[17340]=6,f[17347]=5,f[17348]=4,f[17370]=6,f[17373]=6,f[17385]=6,f[17390]=6,f[17392]=5,f[17399]=7,f[17416]=2,f[17423]=4,f[17425]=3,f[17430]=4,f[17442]=3,f[17445]=4,f[17467]=5,f[17468]=4,f[17475]=4,f[17476]=3,f[17498]=4,f[17501]=5,f[17513]=4,f[17518]=5,f[17520]=4,f[17527]=6,f[17801]=4,f[17806]=5,f[17808]=4,f[17815]=6,f[17827]=5,f[17828]=4,f[17850]=6,f[17853]=6,f[17858]=4,f[17861]=5,f[17883]=6,f[17884]=6,f[17896]=5,f[17903]=7,f[17905]=6,f[17910]=6,f[18058]=4,f[18061]=5,f[18067]=5,f[18068]=4,f[18080]=4,f[18087]=6,f[18105]=6,f[18110]=6,f[18113]=4,f[18118]=5,f[18136]=5,f[18143]=7,f[18155]=6,f[18156]=6,f[18162]=6,f[18165]=6,f[18187]=5,f[18188]=4,f[18194]=4,f[18197]=5,f[18209]=4,f[18214]=5,f[18232]=5,f[18239]=7,f[18240]=4,f[18247]=6,f[18265]=6,f[18270]=6,f[18282]=6,f[18285]=6,f[18291]=6,f[18292]=6,f[18435]=3,f[18436]=2,f[18458]=4,f[18461]=4,f[18473]=4,f[18478]=4,f[18480]=3,f[18487]=5,f[18504]=3,f[18511]=5,f[18513]=4,f[18518]=4,f[18530]=4,f[18533]=4,f[18555]=6,f[18556]=5,f[18818]=4,f[18821]=4,f[18843]=6,f[18844]=5,f[18856]=4,f[18863]=6,f[18865]=5,f[18870]=6,f[18889]=5,f[18894]=6,f[18896]=4,f[18903]=6,f[18915]=6,f[18916]=5,f[18938]=6,f[18941]=7,f[19073]=4,f[19078]=4,f[19096]=4,f[19103]=6,f[19115]=6,f[19116]=5,f[19122]=5,f[19125]=6,f[19146]=5,f[19149]=6,f[19155]=6,f[19156]=5,f[19168]=4,f[19175]=6,f[19193]=6,f[19198]=7,f[19200]=3,f[19207]=5,f[19225]=5,f[19230]=6,f[19242]=5,f[19245]=6,f[19251]=6,f[19252]=5,f[19275]=6,f[19276]=5,f[19282]=5,f[19285]=6,f[19297]=5,f[19302]=6,f[19320]=6,f[19327]=8,f[19584]=3,f[19591]=5,f[19609]=5,f[19614]=6,f[19626]=5,f[19629]=6,f[19635]=6,f[19636]=5,f[19659]=6,f[19660]=5,f[19666]=5,f[19669]=6,f[19681]=5,f[19686]=6,f[19704]=6,f[19711]=8,f[19713]=4,f[19718]=4,f[19736]=4,f[19743]=6,f[19755]=6,f[19756]=5,f[19762]=5,f[19765]=6,f[19786]=5,f[19789]=6,f[19795]=6,f[19796]=5,f[19808]=4,f[19815]=6,f[19833]=6,f[19838]=7,f[19970]=4,f[19973]=4,f[19995]=6,f[19996]=5,f[20008]=4,f[20015]=6,f[20017]=5,f[20022]=6,f[20041]=5,f[20046]=6,f[20048]=4,f[20055]=6,f[20067]=6,f[20068]=5,f[20090]=6,f[20093]=7,f[20355]=6,f[20356]=5,f[20378]=6,f[20381]=7,f[20393]=6,f[20398]=7,f[20400]=6,f[20407]=8,f[20424]=6,f[20431]=8,f[20433]=6,f[20438]=7,f[20450]=6,f[20453]=7,f[20475]=8,f[20476]=8,f[20482]=2,f[20485]=3,f[20507]=4,f[20508]=4,f[20520]=3,f[20527]=5,f[20529]=4,f[20534]=4,f[20553]=4,f[20558]=4,f[20560]=3,f[20567]=5,f[20579]=4,f[20580]=4,f[20602]=5,f[20605]=6,f[20867]=4,f[20868]=4,f[20890]=5,f[20893]=6,f[20905]=5,f[20910]=6,f[20912]=4,f[20919]=6,f[20936]=4,f[20943]=6,f[20945]=5,f[20950]=6,f[20962]=5,f[20965]=6,f[20987]=7,f[20988]=6,f[21120]=3,f[21127]=5,f[21145]=5,f[21150]=6,f[21162]=5,f[21165]=6,f[21171]=6,f[21172]=5,f[21195]=6,f[21196]=5,f[21202]=5,f[21205]=6,f[21217]=5,f[21222]=6,f[21240]=6,f[21247]=8,f[21249]=4,f[21254]=4,f[21272]=4,f[21279]=6,f[21291]=6,f[21292]=5,f[21298]=5,f[21301]=6,f[21322]=5,f[21325]=6,f[21331]=6,f[21332]=5,f[21344]=4,f[21351]=6,f[21369]=6,f[21374]=7,f[21633]=4,f[21638]=4,f[21656]=4,f[21663]=6,f[21675]=6,f[21676]=5,f[21682]=5,f[21685]=6,f[21706]=5,f[21709]=6,f[21715]=6,f[21716]=5,f[21728]=4,f[21735]=6,f[21753]=6,f[21758]=7,f[21760]=3,f[21767]=5,f[21785]=5,f[21790]=6,f[21802]=5,f[21805]=6,f[21811]=6,f[21812]=5,f[21835]=6,f[21836]=5,f[21842]=5,f[21845]=6,f[21857]=5,f[21862]=6,f[21880]=6,f[21887]=8,f[22019]=4,f[22020]=4,f[22042]=5,f[22045]=6,f[22057]=5,f[22062]=6,f[22064]=4,f[22071]=6,f[22088]=4,f[22095]=6,f[22097]=5,f[22102]=6,f[22114]=5,f[22117]=6,f[22139]=7,f[22140]=6,f[22402]=5,f[22405]=6,f[22427]=7,f[22428]=6,f[22440]=6,f[22447]=8,f[22449]=6,f[22454]=7,f[22473]=6,f[22478]=7,f[22480]=6,f[22487]=8,f[22499]=7,f[22500]=6,f[22522]=8,f[22525]=8,f[22666]=4,f[22669]=5,f[22675]=5,f[22676]=4,f[22688]=4,f[22695]=6,f[22713]=6,f[22718]=6,f[22721]=4,f[22726]=5,f[22744]=5,f[22751]=7,f[22763]=6,f[22764]=6,f[22770]=6,f[22773]=6,f[22795]=5,f[22796]=4,f[22802]=4,f[22805]=5,f[22817]=4,f[22822]=5,f[22840]=5,f[22847]=7,f[22848]=4,f[22855]=6,f[22873]=6,f[22878]=6,f[22890]=6,f[22893]=6,f[22899]=6,f[22900]=6,f[23048]=4,f[23055]=6,f[23057]=4,f[23062]=5,f[23074]=4,f[23077]=5,f[23099]=6,f[23100]=6,f[23107]=5,f[23108]=4,f[23130]=6,f[23133]=6,f[23145]=6,f[23150]=6,f[23152]=5,f[23159]=7,f[23433]=6,f[23438]=6,f[23440]=5,f[23447]=7,f[23459]=6,f[23460]=6,f[23482]=7,f[23485]=8,f[23490]=6,f[23493]=6,f[23515]=8,f[23516]=7,f[23528]=6,f[23535]=8,f[23537]=7,f[23542]=8,f[23561]=4,f[23566]=5,f[23568]=4,f[23575]=6,f[23587]=5,f[23588]=4,f[23610]=6,f[23613]=6,f[23618]=4,f[23621]=5,f[23643]=6,f[23644]=6,f[23656]=5,f[23663]=7,f[23665]=6,f[23670]=6,f[23944]=5,f[23951]=7,f[23953]=6,f[23958]=6,f[23970]=6,f[23973]=6,f[23995]=8,f[23996]=7,f[24003]=6,f[24004]=6,f[24026]=7,f[24029]=8,f[24041]=7,f[24046]=8,f[24048]=6,f[24055]=8,f[24203]=6,f[24204]=6,f[24210]=6,f[24213]=6,f[24225]=6,f[24230]=6,f[24248]=6,f[24255]=8,f[24256]=5,f[24263]=7,f[24281]=7,f[24286]=8,f[24298]=7,f[24301]=8,f[24307]=8,f[24308]=7,f[24330]=6,f[24333]=6,f[24339]=6,f[24340]=6,f[24352]=5,f[24359]=7,f[24377]=7,f[24382]=8,f[24385]=6,f[24390]=6,f[24408]=6,f[24415]=8,f[24427]=8,f[24428]=7,f[24434]=7,f[24437]=8,f[24577]=2,f[24582]=3,f[24600]=3,f[24607]=5,f[24619]=4,f[24620]=4,f[24626]=4,f[24629]=4,f[24650]=4,f[24653]=4,f[24659]=4,f[24660]=4,f[24672]=3,f[24679]=5,f[24697]=5,f[24702]=6,f[24960]=3,f[24967]=5,f[24985]=5,f[24990]=6,f[25002]=5,f[25005]=6,f[25011]=6,f[25012]=5,f[25035]=6,f[25036]=5,f[25042]=5,f[25045]=6,f[25057]=5,f[25062]=6,f[25080]=6,f[25087]=8,f[25219]=4,f[25220]=4,f[25242]=5,f[25245]=6,f[25257]=5,f[25262]=6,f[25264]=4,f[25271]=6,f[25288]=4,f[25295]=6,f[25297]=5,f[25302]=6,f[25314]=5,f[25317]=6,f[25339]=7,f[25340]=6,f[25346]=4,f[25349]=4,f[25371]=6,f[25372]=5,f[25384]=4,f[25391]=6,f[25393]=5,f[25398]=6,f[25417]=5,f[25422]=6,f[25424]=4,f[25431]=6,f[25443]=6,f[25444]=5,f[25466]=6,f[25469]=7,f[25730]=4,f[25733]=4,f[25755]=6,f[25756]=5,f[25768]=4,f[25775]=6,f[25777]=5,f[25782]=6,f[25801]=5,f[25806]=6,f[25808]=4,f[25815]=6,f[25827]=6,f[25828]=5,f[25850]=6,f[25853]=7,f[25859]=4,f[25860]=4,f[25882]=5,f[25885]=6,f[25897]=5,f[25902]=6,f[25904]=4,f[25911]=6,f[25928]=4,f[25935]=6,f[25937]=5,f[25942]=6,f[25954]=5,f[25957]=6,f[25979]=7,f[25980]=6,f[26112]=3,f[26119]=5,f[26137]=5,f[26142]=6,f[26154]=5,f[26157]=6,f[26163]=6,f[26164]=5,f[26187]=6,f[26188]=5,f[26194]=5,f[26197]=6,f[26209]=5,f[26214]=6,f[26232]=6,f[26239]=8,f[26497]=5,f[26502]=6,f[26520]=6,f[26527]=8,f[26539]=7,f[26540]=6,f[26546]=6,f[26549]=7,f[26570]=6,f[26573]=7,f[26579]=7,f[26580]=6,f[26592]=6,f[26599]=8,f[26617]=8,f[26622]=8,f[26761]=4,f[26766]=5,f[26768]=4,f[26775]=6,f[26787]=5,f[26788]=4,f[26810]=6,f[26813]=6,f[26818]=4,f[26821]=5,f[26843]=6,f[26844]=6,f[26856]=5,f[26863]=7,f[26865]=6,f[26870]=6,f[26888]=4,f[26895]=6,f[26897]=4,f[26902]=5,f[26914]=4,f[26917]=5,f[26939]=6,f[26940]=6,f[26947]=5,f[26948]=4,f[26970]=6,f[26973]=6,f[26985]=6,f[26990]=6,f[26992]=5,f[26999]=7,f[27147]=5,f[27148]=4,f[27154]=4,f[27157]=5,f[27169]=4,f[27174]=5,f[27192]=5,f[27199]=7,f[27200]=4,f[27207]=6,f[27225]=6,f[27230]=6,f[27242]=6,f[27245]=6,f[27251]=6,f[27252]=6,f[27530]=6,f[27533]=6,f[27539]=6,f[27540]=6,f[27552]=5,f[27559]=7,f[27577]=7,f[27582]=8,f[27585]=6,f[27590]=6,f[27608]=6,f[27615]=8,f[27627]=8,f[27628]=7,f[27634]=7,f[27637]=8,f[27658]=4,f[27661]=5,f[27667]=5,f[27668]=4,f[27680]=4,f[27687]=6,f[27705]=6,f[27710]=6,f[27713]=4,f[27718]=5,f[27736]=5,f[27743]=7,f[27755]=6,f[27756]=6,f[27762]=6,f[27765]=6,f[28043]=6,f[28044]=6,f[28050]=6,f[28053]=6,f[28065]=6,f[28070]=6,f[28088]=6,f[28095]=8,f[28096]=5,f[28103]=7,f[28121]=7,f[28126]=8,f[28138]=7,f[28141]=8,f[28147]=8,f[28148]=7,f[28296]=5,f[28303]=7,f[28305]=6,f[28310]=6,f[28322]=6,f[28325]=6,f[28347]=8,f[28348]=7,f[28355]=6,f[28356]=6,f[28378]=7,f[28381]=8,f[28393]=7,f[28398]=8,f[28400]=6,f[28407]=8,f[28425]=6,f[28430]=6,f[28432]=5,f[28439]=7,f[28451]=6,f[28452]=6,f[28474]=7,f[28477]=8,f[28482]=6,f[28485]=6,f[28507]=8,f[28508]=7,f[28520]=6,f[28527]=8,f[28529]=7,f[28534]=8,f[28808]=4,f[28815]=6,f[28817]=4,f[28822]=5,f[28834]=4,f[28837]=5,f[28859]=6,f[28860]=6,f[28867]=5,f[28868]=4,f[28890]=6,f[28893]=6,f[28905]=6,f[28910]=6,f[28912]=5,f[28919]=7,f[28937]=4,f[28942]=5,f[28944]=4,f[28951]=6,f[28963]=5,f[28964]=4,f[28986]=6,f[28989]=6,f[28994]=4,f[28997]=5,f[29019]=6,f[29020]=6,f[29032]=5,f[29039]=7,f[29041]=6,f[29046]=6,f[29194]=4,f[29197]=5,f[29203]=5,f[29204]=4,f[29216]=4,f[29223]=6,f[29241]=6,f[29246]=6,f[29249]=4,f[29254]=5,f[29272]=5,f[29279]=7,f[29291]=6,f[29292]=6,f[29298]=6,f[29301]=6,f[29579]=6,f[29580]=6,f[29586]=6,f[29589]=6,f[29601]=6,f[29606]=6,f[29624]=6,f[29631]=8,f[29632]=5,f[29639]=7,f[29657]=7,f[29662]=8,f[29674]=7,f[29677]=8,f[29683]=8,f[29684]=7,f[29707]=5,f[29708]=4,f[29714]=4,f[29717]=5,f[29729]=4,f[29734]=5,f[29752]=5,f[29759]=7,f[29760]=4,f[29767]=6,f[29785]=6,f[29790]=6,f[29802]=6,f[29805]=6,f[29811]=6,f[29812]=6,f[30090]=6,f[30093]=6,f[30099]=6,f[30100]=6,f[30112]=5,f[30119]=7,f[30137]=7,f[30142]=8,f[30145]=6,f[30150]=6,f[30168]=6,f[30175]=8,f[30187]=8,f[30188]=7,f[30194]=7,f[30197]=8,f[30345]=6,f[30350]=6,f[30352]=5,f[30359]=7,f[30371]=6,f[30372]=6,f[30394]=7,f[30397]=8,f[30402]=6,f[30405]=6,f[30427]=8,f[30428]=7,f[30440]=6,f[30447]=8,f[30449]=7,f[30454]=8,f[30472]=5,f[30479]=7,f[30481]=6,f[30486]=6,f[30498]=6,f[30501]=6,f[30523]=8,f[30524]=7,f[30531]=6,f[30532]=6,f[30554]=7,f[30557]=8,f[30569]=7,f[30574]=8,f[30576]=6,f[30583]=8,f[30720]=3,f[30727]=5,f[30745]=5,f[30750]=6,f[30762]=5,f[30765]=6,f[30771]=6,f[30772]=5,f[30795]=6,f[30796]=5,f[30802]=5,f[30805]=6,f[30817]=5,f[30822]=6,f[30840]=6,f[30847]=8,f[31105]=5,f[31110]=6,f[31128]=6,f[31135]=8,f[31147]=7,f[31148]=6,f[31154]=6,f[31157]=7,f[31178]=6,f[31181]=7,f[31187]=7,f[31188]=6,f[31200]=6,f[31207]=8,f[31225]=8,f[31230]=8,f[31362]=5,f[31365]=6,f[31387]=7,f[31388]=6,f[31400]=6,f[31407]=8,f[31409]=6,f[31414]=7,f[31433]=6,f[31438]=7,f[31440]=6,f[31447]=8,f[31459]=7,f[31460]=6,f[31482]=8,f[31485]=8,f[31491]=6,f[31492]=5,f[31514]=6,f[31517]=7,f[31529]=6,f[31534]=7,f[31536]=6,f[31543]=8,f[31560]=6,f[31567]=8,f[31569]=6,f[31574]=7,f[31586]=6,f[31589]=7,f[31611]=8,f[31612]=8,f[31875]=6,f[31876]=5,f[31898]=6,f[31901]=7,f[31913]=6,f[31918]=7,f[31920]=6,f[31927]=8,f[31944]=6,f[31951]=8,f[31953]=6,f[31958]=7,f[31970]=6,f[31973]=7,f[31995]=8,f[31996]=8,f[32002]=5,f[32005]=6,f[32027]=7,f[32028]=6,f[32040]=6,f[32047]=8,f[32049]=6,f[32054]=7,f[32073]=6,f[32078]=7,f[32080]=6,f[32087]=8,f[32099]=7,f[32100]=6,f[32122]=8,f[32125]=8,f[32257]=5,f[32262]=6,f[32280]=6,f[32287]=8,f[32299]=7,f[32300]=6,f[32306]=6,f[32309]=7,f[32330]=6,f[32333]=7,f[32339]=7,f[32340]=6,f[32352]=6,f[32359]=8,f[32377]=8,f[32382]=8,f[32640]=6,f[32647]=8,f[32665]=8,f[32670]=8,f[32682]=8,f[32685]=8,f[32691]=8,f[32692]=8,f[32715]=8,f[32716]=8,f[32722]=8,f[32725]=8,f[32737]=8,f[32742]=8,f[32760]=8,f[32767]=10;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);++x,++y;\n\t\ta[x]^=z;a[y]^=z;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i])\n\t\t{\n\t\t\tif((m>>a[i]-1)&1)ans++;\n\t\t\tm^=(1<<a[i]-1);\n\t\t}\n\tprintf(\"%d\",ans+f[m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define MIN(x,y) x=min(x,y)\nusing namespace std;\n\nconst int N=100005;\nconst int inf=1000000000;\n\nint n,a[N],bin[20],cnt[70005],f[70005],w[20];\nvector<int> vec[16];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid dp(int S)\n{\n\tfor (int i=0;i<bin[16];i++) cnt[i]=cnt[i>>1]+(i&1),vec[cnt[i]].push_back(i),f[i]=inf;\n\tf[S]=0;\n\tfor (int i=16;i>0;i--)\n\t\tfor (int j=0;j<vec[i].size();j++)\n\t\t{\n\t\t\tint s=vec[i][j];\n\t\t\tif (f[s]==inf) continue;\n\t\t\tfor (int x=0;x<16;x++)\n\t\t\t\tfor (int y=0;y<16;y++)\n\t\t\t\t{\n\t\t\t\t\tif (!(s&bin[x])||!(s&bin[y])||x==y) continue;\n\t\t\t\t\tMIN(f[s^bin[x]^bin[x^y]^bin[y]],f[s]+1+((s&bin[x^y])>0));\n\t\t\t\t}\n\t\t}\n}\n\nint main()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=16;i++) bin[i]=bin[i-1]*2;\n\tn=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read(),z=read();\n\t\ta[x+1]^=z;a[y+1]^=z;\n\t}\n\tfor (int i=1;i<=n;i++) w[a[i]]++;\n\tint S=0,ans=0;\n\tfor (int i=1;i<=15;i++) ans+=w[i]/2,w[i]%=2,S+=bin[i]*w[i];\n\tdp(S);\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nconst int N = 205100;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; char c = getchar();\n    while (!isdigit(c)) c=getchar();\n    for (;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);\n}\n\nint x, y, n, res, st;\nint d[N], sum[N], u[N], cnt[N];\ninline int to(int x) {return 1 << x;}\nint main() {\n    read(n);\n    for (int i = 1;i < n; i++) {\n        int x, y, a; read(x), read(y), read(a);\n        u[x] ^= a, u[y] ^= a;\n    }\n    for (int i = 0;i < n; i++) cnt[u[i]]++;\n    int all = to(15);\n    for (int i = 1;i < all; i++) d[i] = d[i>>1] + (i & 1);\n    for (int i = 1;i < all; i++) d[i]--;\n    for (int i = 1;i <= 15; i++) res += cnt[i] / 2, st |= (cnt[i] & 1) << (i-1);\n    for (int i = 1;i < all; i++) \n        for (int j = 0;j < 15; j++) \n            if (i & to(j)) sum[i] ^= (j + 1);\n    for (int i = 1;i < all; i++) {\n        if (sum[i] != 0) continue;\n        for (int j = (i - 1) & i; j; j = (j - 1) & i) \n            if (sum[j] == 0) d[i] = min(d[i], d[j] + d[i ^ j]);\n    }\n    cout << res + d[st] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(S & (1 << a[i])) ans ++;\n\t\tS ^= (1 << a[i]);\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[0] = 0;\n\tfor (int now = 1; now < (1 << 15); ++now) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (i ^ j))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint const N = 1234567;\nint const INF = 1 << 30;\n \nint deg[N];\nint was[42];\n\nint dp[1 << 15];\n \nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u, w;\n\t\tcin >> v >> u >> w;\n\t\tdeg[v] ^= w;\n\t\tdeg[u] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (deg[i] == 0) continue;\n\t\tif (was[deg[i]]) {\n\t\t\t++ans;\n\t\t\twas[deg[i]] = false;\n\t\t} else {\n\t\t\twas[deg[i]] = true;\n\t\t}\n\t}\n\tint mask = 0;\n\tfor (int i = 0; i < 15; i++) {\n\t\tif (was[i]) mask |= 1 << i;\n\t}\n\tfor (int i = 0; i < 1 << 15; i++) dp[i] = INF;\n\tdp[mask] = 0;\n\tfor (int i = mask; i >= 1; i--) {\n\t\tif (dp[i] == INF) continue;\n\t\tif ((i & (i - 1)) == 0) continue;\n\t\tfor (int j = 1; j < 15; j++) {\n\t\t\tif (((i >> j) & 1) == 0) continue;\n\t\t\tfor (int k = j + 1; k < 15; k++) {\n\t\t\t\tif (((i >> k) & 1) == 0) continue;\n\t\t\t\tif ((j & k) == 0) continue;\n\t\t\t\t// cerr << i << ' ' << j << ' ' << k << endl;\n\t\t\t\tint got = j & k;\n\t\t\t\tint nj = j ^ got;\n\t\t\t\tint nk = k ^ got;\n\t\t\t\tint nmask = i ^ (1 << j) ^ (1 << k);\n\t\t\t\tint cost = 1;\n\t\t\t\tif (nj > 0) {\n\t\t\t\t\tif (((nmask >> nj) & 1) == 1) {\n\t\t\t\t\t\tcost++;\n\t\t\t\t\t}\n\t\t\t\t\tnmask ^= 1 << nj;\n\t\t\t\t}\n\t\t\t\tif (nk > 0) {\n\t\t\t\t\tif (((nmask >> nk) & 1) == 1) {\n\t\t\t\t\t\tcost++;\n\t\t\t\t\t}\n\t\t\t\t\tnmask ^= 1 << nk;\n\t\t\t\t}\n\t\t\t\t// cout << \"nmask = \" << nmask << endl;\n\t\t\t\tdp[nmask] = std::min(dp[nmask], dp[i] + cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0] + ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i, a, b) for (int i = a; i <= b; i++)\n#define DFor(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\ntypedef long long LL;\ntemplate <typename T> inline void read(T &x)\n{\n    int f = 1; x = 0; char c = getchar();\n    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;\n    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);\n    x *= f;\n}\n\nconst int N = 1e5 + 5;\nconst int M = 16;\nint n, w[N];\n\nint cnt[M], ans, F[1 << M], sxor[1 << M];\nint num[M], tot;\nint main()\n{\n    read(n);\n    For (i, 1, n - 1)\n    {\n        int x, y, z;\n        read(x); read(y); read(z);\n        x++; y++;\n        w[x] ^= z; w[y] ^= z;\n    }\n    For (i, 1, n) cnt[w[i]]++;\n    \n    For (i, 1, M - 1)\n    {\n        ans += cnt[i] / 2;\n        if (cnt[i] & 1) num[++tot] = i;\n    }\n   \n    For (i, 1, (1 << tot) - 1)\n    {\n        int cnt = 0;\n        For (j, 0, tot - 1) if (i >> j & 1) { sxor[i] ^= num[j + 1]; cnt++; }\n        if (!sxor[i]) F[i] = cnt - 1;\n        else F[i] = 0x3f3f3f3f;\n    }\n    \n    For (i, 1, (1 << tot) - 1)\n    {\n        if (sxor[i]) continue;\n        for (int j = i; j; j = (j - 1) & i) \n        if (!sxor[j]) F[i] = min(F[i], F[j] + F[i ^ j]);\n    }\n    \n    printf (\"%d\\n\", ans + F[(1 << tot) - 1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 100005\n#define reg register\n#define inl inline\nusing namespace std;\nint n,a[MAXN],f[MAXN],sum[MAXN],ans,_[25];\nint Dfs(reg int x)\n{\n    if(!x) return 0;\n    if(f[x]!=-1) return f[x];\n    f[x]=2e9;\n    for(reg int i=0;i<16;i++)\n    {\n        if(x&_[i])\n        {\n            for(reg int j=0;j<16;j++)\n            {\n                if((x&_[j]) && i!=j)\n                {\n                    reg int y=i^j,nxt=x^_[i]^_[j]^_[y];\n                    if(x&_[y]) f[x]=min(f[x],Dfs(nxt)+2);\n                    else f[x]=min(f[x],Dfs(nxt)+1);\n                }\n            }\n        }\n    }\n    return f[x];\n}\nint main()\n{\n    memset(f,-1,sizeof(f));\n    scanf(\"%d\",&n);\n    for(reg int i=1;i<n;i++)\n    {\n        reg int x,y,z;\n        scanf(\"%d %d %d\",&x,&y,&z);\n        x++;\n        y++;\n        a[x]^=z;\n        a[y]^=z;\n    }\n    for(reg int i=1;i<=n;i++) sum[a[i]]++;\n    _[0]=1;\n    reg int t=0;\n    for(reg int i=1;i<=16;i++) _[i]=_[i-1]<<1;\n    for(reg int i=1;i<16;i++)\n    {\n        ans+=sum[i]>>1;\n        t+=_[i]*(sum[i]&1);\n    }\n    ans+=Dfs(t);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, w, x[100005], c[16], dp[15000000], ans, p3[20];\nvector<pii> v[100005];\nvector<int> r;\nbool val(int B){\n    int C=0;\n    bool f=0;\n    fox(l, m){\n        if (B/p3[l]%3==1){\n            C^=r[l];\n            f=1;\n        }\n    }\n    return f && C==0;\n}\nint nxt(int B){\n    fox(l, m){\n        if (B/p3[l]%3==1) B+=p3[l];\n    }\n    return B;\n}\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                }\n            }\n            if (val(l)){\n                //cout << \"*\";\n                dp[nxt(l)]=max(dp[nxt(l)], dp[l]+1);\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nbool Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot+=(1<<i);\n\tfor(int i=1;i<(1<<N);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<N);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<N);s++){\n\t\tfor(int i=0;i<=15;i++){\n\t\t\tif((1<<i)&s)Xor[s]^=(i+1);\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<N);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int U=1<<16;\nconst int inf=0x7f7f7f7f;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=1;i<16;i++)\n\t    if((S>>i)&1)for(reg int j=i+1;j<16;j++)\n\t\t\t    if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x7f,sizeof(f));\n\tfor(reg int i=1,x,y,c;i<n;i++){\n\t\tx=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[s[i]]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int MAX = 1 << 16;\nconst int inf = 1e9;\n\nint n, a[N];\nint cnt[16];\nint dp[MAX];\nint fxor[MAX];\nint ans;\nvector<int> rem;\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v, w; cin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\n\tfor (int i = 0; i < n; ++i) cnt[a[i]]++;\n\n\tfor (int i = 1; i < 16; ++i) {\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t\tif (cnt[i]) rem.push_back(i);\n\t}\n\n\tint sz = rem.size();\n\tfor (int mask = 0; mask < (1 << sz); ++mask) {\n\t\tfor (int i = 0; i < sz; ++i) if (mask >> i & 1) fxor[mask] ^= rem[i];\n\t}\n\t\n\tfor (int mask = 0; mask < (1 << sz); ++mask) dp[mask] = inf;\n\tdp[0] = 0;\n\tfor (int mask = 1; mask < (1 << sz); ++mask) {\n\t\tfor (int submask = mask; submask > 0; submask = mask & (submask - 1)) {\n\t\t\tif (fxor[submask] == 0) {\n\t\t\t\tdp[mask] = min(dp[mask], dp[mask ^ submask] + __builtin_popcount(submask) - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans + dp[(1 << sz) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; --i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++i)\nconst int maxN = 1e5 + 7;\nconst int maxS = (1 << 15) + 3;\n\ntemplate<class T> T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return f ? x : -x;\n}\n\nint n, m;\nint a[maxN];\nbool ok[maxS];\nint f[maxS];\n\nint main() {\n\n\tm = n = ri();\n\tFor (i, 1, n) {\n\t\tint x = ri() + 1, y = ri() + 1, d = ri();\n\t\ta[x] ^= d;\n\t\ta[y] ^= d;\n\t}\n\n\tsort(a+1, a+n+1, greater<int>());\n\tint res = 0, mask = 0;\n\tfor (; n > 0 && a[n] == 0; --n) ++res;\n\twhile (n > 0) {\n\t\tfor (; n >= 2 && a[n] == a[n-1]; n -= 2) ++res;\n\t\tif (n > 1) mask |= 1 << (a[n--] - 1);\n\t}\n\n\tfor (int s = mask; s; (--s) &= mask) {\n\t\tint tp = 0;\n\t\trep (i, 1, 15) if (s >> (i-1) & 1) tp ^= i;\n\t\tok[s] = tp == 0;\n\t}\n\tok[0] = true;\n\trep (s, 1, mask) if ((mask & s) == s && ok[s]){\n\t\tfor (int t = s; t; (--t) &= s) if (ok[t] && ok[s^t]) {\n\t\t\tf[s] = max(f[s], f[s ^ t] + 1);\n\t\t}\n\t}\n\tres += f[mask];\n\tprintf(\"%d\\n\", m - res);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     âââââââââââ\n//                                                                   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                                                                ââââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬âââ\n//                                            âââââââââââ       âââ¬â¬â¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬ââ\n//                                      ââââââââââ¬â¬â¬â¬â¬âââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬ââ\n//                               âââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬ââ\n//                             âââââ¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//                           ââââ¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬ââââ¬â¬â¬â¬â¬â¬â¬âââââ\n//                         ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââââââââ¬â¬â¬â¬â¬ââ\n//                       ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                     ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬ââ\n//                 âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬ââââ\n//     ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬ââââââ\n//   âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬ââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââ¬â¬â¬ââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬ââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââââ¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬â¬â¬âââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬âââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââ\n//   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//       ââââââââââââââ  âââââ¬â¬â¬â¬â¬â¬ââââââââââââââââââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ\n//                         âââââââ                           âââââ  âââââââââââââââââââ  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n,0);\n  REP(_,n-1){\n    int x,y,v;\n    cin >> x >> y >> v;\n    a[x] ^= v;\n    a[y] ^= v;\n  }\n  \n  vec b(16,0);\n  REP(i,n) b[a[i]]++;\n\n  int ans = 0;\n  REP(i,16){\n    if(i) ans += b[i]/2;\n  }\n\n  vec dp(1<<15,-INF); dp[0] = 0;\n  int mask = 0;\n  REP(i,15) if(b[i+1]&1) mask += (1<<i);\n  \n  REP(i,1<<15){\n    int x = mask & (~i);\n    assert(x+i==mask);\n    for(;x;x--){\n      x &= mask; int cnt = 0;\n      REP(k,15) if(parity(x,k)) cnt ^= k+1;\n      if(!cnt) chmax(dp[i+x],dp[i]+1); \n    }\n  }\n\n  cout << ans - dp[mask] + pcnt(mask) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\n// const int na = 1<<11;\n// int A[na];\n\nlli f(lli bs) {\n  // vector<unordered_map<int,int>> G(1<<16);\n  // FOR(m,1<<16) FOR(i,16) if(i&&(m&(1<<i))) FOR(j,16) if(i<j&&j&&(m&(1<<j))) FOR(l,16) if(l) {\n  //       lli co = 1;\n  //       lli i2 = i^l;\n  //       lli j2 = j^l;\n  //       lli m2 = m^(1<<i)^(1<<j);\n  //       if(i2) {\n  //         if(m2&(1<<i2)) co++;\n  //         m2^=(1<<i2);\n  //       }\n  //       if(j2){\n  //         if(m2&(1<<j2)) co++;\n  //         m2^=(1<<j2);\n  //       }\n  //       if(G[m2].count(m)) { G[m2][m] = min<int>(G[m2][m],co); }\n  //       else G[m2][m] = co;\n  //     }\n  min_queue<pii> Q; vi D(1<<16,1ll<<60);\n  Q.push(mt(0,0)); D[0] = 0;\n  while(!Q.empty()) {\n    lli d,m; tie(d,m) = Q.top(); Q.pop();\n    if(D[m] != d) continue;\n    if(m == bs) return d;\n    FOR(i,16) if(i) FOR(j,16) if(i<j&&j) FOR(l,16) if(l && (l!=(i^j))) {\n          int i2 = i^l;\n          int j2 = j^l;\n          int m2 = m;\n          int co = 1;\n          assert(i2!=j2);\n          if(i2) {m2 ^= (1<<i2);\n            if(m2&(1<<i2)) co++;\n          }\n          if(j2) {m2 ^= (1<<j2);\n            if(m2&(1<<j2)) co++;\n          }\n          m2 ^= (1<<i);\n          m2 ^= (1<<j);\n          if(d+co < D[m2]) { D[m2] = d+co; Q.push(mt(D[m2],m2)); }\n        }\n    // for(auto e : G[m]) {\n    //   lli dd,m2; tie(m2,dd) = e;\n    //   dd += d;\n    //   if(dd < D[m2]) { D[m2] = dd; Q.push(mt(dd,m2)); }\n    // }\n  }\n  assert(0);\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n; cin>>n;\n  vi D(n);\n  FOR(i,n-1) {\n    lli u,v,e; cin>>u>>v>>e;\n    D[u] ^= e; D[v] ^= e;\n  }\n  vi C(16); FOR(i,n) C[D[i]]++;\n  lli ans=0;\n  lli bs = 0;\n  FOR(i,16) if(i) {\n    ans += C[i]/2;\n    C[i] %= 2;\n    if(C[i]) bs |= (1<<i);\n  }\n  cout << ans+f(bs) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#include<vector>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans,sum;\nvector<int> a[21];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta++;\n\t\tb++;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t\tif(book[i]&1)\n\t\t\tsum++;\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[s]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tcnt++;\n\t\ta[cnt].push_back(i);\n\t}\n\tfor(int o=sum;o>=0;o--)\n\t\tfor(int p=0;p<a[o].size();p++)\n\t\t\tfor(int i=0;i<=15;i++)\n\t\t\t{\n\t\t\t\tif(!(p&(1<<i)))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=0;j<=15;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j||!(p&(1<<j)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint k=i^j;\n\t\t\t\t\tint t=p^(1<<i)^(1<<j)^(1<<k);\n\t\t\t\t\tif(p&(1<<k))\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+1);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1000000007;\nconst int N=200005,E=524288;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nint n,m,i,j,k,u,v,w,f[250005],g[250005],d[250005],num[250005],s,ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\t++u,++v;\n\t\td[u]^=w,d[v]^=w;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\t++num[d[i]];\n\tfor(i=0;i<16;++i)\n\t{\n\t\tif(i!=0)\n\t\t\tans+=num[i]/2;\n\t\tnum[i]&=1;\n\t\ts|=num[i]<<i;\n\t}\n\tfor(i=0;i<(1<<16);++i)\n\t{\n\t\tif(i==0||i==1)\n\t\t{\n\t\t\tf[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tf[i]=1000000007;\n\t\tfor(j=1;j<16;++j)\n\t\t\tfor(k=1;k<16;++k)\n\t\t\t\tif(j!=k)\n\t\t\t\t\tif(((i>>j)&1)&&((i>>k)&1))\n\t\t\t\t\t\tf[i]=min(f[i],f[i^(1<<j)^(1<<k)^(1<<(j^k))]+1+((i>>(j^k))&1));\n\t}\n\tcout<<ans+f[s];\n}\n"
  },
  {
    "language": "C++",
    "code": "/*********************\n*  Author: xuziyuan  * \n*********************/\n \n#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define LL long long\n#define pii pair <int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mpr make_pair\n \nusing namespace std;\n \nconst LL MOD=1e9+7;\n\nint n,x,y,z,val,num[100010],all,good[70000],dp[70000],ans=0;\nvector <int> g[100010];\n\nint main()\n{\n\tcin>>n;\n\trep(i,n-1)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tg[x].pb(z);\n\t\tg[y].pb(z);\n\t}\n\trep(i,n)\n\t{\n\t\tval=0;\n\t\trep(j,g[i].size()) val^=g[i][j];\n\t\tnum[val]++;\n\t}\n\trepn(i,15)\n\t{\n\t\tans+=num[i]/2;\n\t\tif(num[i]%2==1) all|=(1<<i);\n\t}\n\trep(i,1<<16)\n\t{\n\t\tint tmp=0;\n\t\trep(j,16) if((i&(1<<j))>0) tmp^=j;\n\t\tif(tmp==0) good[i]=true;\n\t}\n\trep(i,1<<16)\n\t{\n\t\tif(!good[i]) continue;\n\t\tfor(int j=i;j>0;j=(j-1)&i) if(good[j]) dp[i]=max(dp[i],dp[i^j]+1);\n\t}\n\tcout<<ans+__builtin_popcount(all)-dp[all]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class I>\ninline void rd(I &x) {\n\tint f = 1;\n\tchar c;\n\tfor(c = getchar(); c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;\n\tfor(x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = getchar());\n\tx *= f;\n}\nconst int N = 1e5 + 10;\nint n;\nint tot = 0;\nint d[N], cnt[32], p[20];\nint f[(1 << 16) + 10], ans;\ninline bool check(int x, int w) {\n\treturn (x & w) == w;\n}\ninline int g(int x) {\n\tint now = 0, res = 0, size = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], size++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? size : size - 1;\n}\nint main() {\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\trd(n);\n\tfor(int i = 1; i < n; i++) {\n\t\tint x, y, z;\n\t\trd(x), rd(y), rd(z);\n\t\td[x] ^= z;\n\t\td[y] ^= z;\n\t}\n\tfor(int i = 1; i <= n; i++) cnt[d[i]]++;\n\tfor(int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1) p[tot++] = i;\n\t}\n\tfor(int S = 1; S < (1 << 16); S++) {\n\t\tf[S] = g(S);\n\t\tfor(int tmp = S; tmp; tmp = (tmp - 1) & S) {\n\t\t\tf[S] = min(f[S], f[tmp] + f[S ^ tmp]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + f[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint DP(int now) {\n\tif(dp[now] != -1) return dp[now];\n\tdp[now] = 1e9;\n\tfor (int i = 0; i < 15; ++i) {\n//\t\tif(!(now & (1 << i))) continue;\n\t\tfor (int j = i + 1; j < 15; ++j) {\n//\t\t\tif(!(now & (1 << j))) continue;\n\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n//\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n\t\t\tint f;\n\t\t\tif(((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1)))) f = 1;\n\t\t\telse f = 0;\n\t\t\tdp[now] = min(dp[now] , DP(nnow) + 1 + f);\n\t\t}\n\t}\n\treturn dp[now];\t\n}\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\" , a[i]);\n\t\tif(!a[i]) continue;\n\t\tif(S & (1 << (a[i] - 1))) ans ++;\n\t\tS ^= (1 << (a[i] - 1));\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , -1 , sizeof dp);\n\tdp[0] = 0;\n\tans += DP(S);\n//\tfor (int now = 1; now < (1 << 15); ++now) {\n//\t\tfor (int i = 0; i < 15; ++i) {\n////\t\t\tif(!(now & (1 << i))) continue;\n//\t\t\tfor (int j = i + 1; j < 15; ++j) {\n////\t\t\t\tif(!(now & (1 << j))) continue;\n//\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n////\t\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n//\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1))));\n//\t\t\t}\n//\t\t}\n//\t}\n\tprintf(\"%d\" , ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}//è´ªå¿\n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);//é¢å¤çéåçå¼æå\n    for(int i=1;i<(1<<15);i++)//æä¸¾å­éè¿è¡è½¬ç§»\n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=1e5,M=(1<<16)+1000;\nint n,a[N],f[M],cnt[M],as,st,S,x[M];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\t//freopen(\"3913.in\",\"r\",stdin);freopen(\"3913.out\",\"w\",stdout);\n\tn=read();rp(i,1,n-1){ri x=read()+1,y=read()+1,z=read();a[x]^=z;a[y]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,16)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);rp(i,1,S)--f[i];rp(i,1,S)rp(j,0,15)if(i&(1<<j))x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\\n\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 100010, N=15;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN];\nint cnt[MAXN];\nint dp[1<<N], xo[1<<N];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tcin>>u>>v>>x;\n\t\tA[u]^=x;\n\t\tA[v]^=x;\n\t}\n\tfor (int i=1; i<=n; i++) cnt[A[i]]++;\n\tans=cnt[0];\n\tcnt[0]=1;\n\tfor (int i=1; i<N; i++) ans+=cnt[i]/2, cnt[i]%=2;\n\tfor (int mask=1; mask<(1<<N); mask++){\n\t\tint bit=__builtin_ctz(mask);\n\t\txo[mask]=xo[mask^(1<<bit)]^(bit+1);\n\t}\n\tfor (int mask=1; mask<(1<<N); mask++)\n\t\tfor (int submask=mask; submask; submask=(submask-1)&mask)\n\t\t\tif (!xo[submask]) dp[mask]=max(dp[mask], dp[mask^submask] + 1);\n\t\n\tint mask=0;\n\tfor (int i=0; i<N; i++) if (cnt[i+1]) mask|=(1<<i);\n\tans+=dp[mask];\n\tcout<<n-ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\nconst int N = 15;\n\nstruct edge\n{\n    int to, cost;\n};\n\nvector<edge> G[MAX_N];\nint dp[1 << N];\nint ans;\n\ninline int trans(int val)\n{\n    return (val == 0)?(0):(1 << (val-1));\n}\n\nint dfs(int u, int p)\n{\n    vi vec;\n    int res = 0;\n    each(e,G[u]){\n        if(e.to != p){\n            int num = dfs(e.to,u);\n            int val = 0;\n            rep(i,N){\n                if((num >> i) & 1){\n                    val ^= i+1;\n                }\n            }\n            if(num & trans(e.cost^val)){\n                ans++;\n            }\n            vec.pb(num^trans(e.cost^val));\n        }\n    }\n    rep(i,N){\n        int cnt = 0;\n        rep(j,len(vec)){\n            if((vec[j] >> i) & 1){\n                cnt++;\n            }\n        }\n        ans += cnt/2;\n        res += ((cnt%2) << i);\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int x,y,a;\n        cin >> x >> y >> a;\n        G[x].pb((edge){y,a}), G[y].pb((edge){x,a});\n    }\n    srep(i,1,(1 << N)){\n        int val = 0;\n        rep(j,N){\n            if((i >> j) & 1){\n                val ^= (j+1);\n            }\n        }\n        if(val){\n            dp[i] = __builtin_popcount(i);\n        }else{\n            dp[i] = __builtin_popcount(i)-1;\n        }\n        for(int j=i;j>0;j=(j-1)&i){\n            cmn(dp[i],dp[j]+dp[i^j]);\n        }\n    }\n    int res = dfs(0, -1);\n    cout << ans + dp[res] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \n#define ld long double\nusing namespace std;\nconst ll INF = 1e18;\nconst ll MOD = 998244353;\n\n\nvector<string> vec_splitter(string s) {\n\t\ts += ',';\n\t\tvector<string> res;\n\t\twhile(!s.empty()) {\n\t\t\t\tres.push_back(s.substr(0, s.find(',')));\n\t\t\t\ts = s.substr(s.find(',') + 1);\n\t\t}\n\t\treturn res;\n}\nvoid debug_out(\nvector<string> __attribute__ ((unused)) args,\n__attribute__ ((unused)) int idx, \n__attribute__ ((unused)) int LINE_NUM) { cerr << endl; } \ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n\t\tif(idx > 0) cerr << \", \"; else cerr << \"Line(\" << LINE_NUM << \") \";\n\t\tstringstream ss; ss << H;\n\t\tcerr << args[idx] << \" = \" << ss.str();\n\t\tdebug_out(args, idx + 1, LINE_NUM, T...);\n}\n#ifdef XOX\n#define deb(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)\n#else\n#define deb(...) 42\n#endif\n\n\nint32_t main() {\n\tios::sync_with_stdio(!cin.tie(NULL));\n\n\tint n;\n\tcin >> n;\n\tint u, v, x;\n\tvector<int> xxor(n + 10, 0);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tcin >> x;\n\t\txxor[u] ^= x, xxor[v] ^= x;\n\t}\n\t\n\tint cnt[20 + 10];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor(int i = 0; i < n; i++) {\n\t\tcnt[xxor[i]]++;\n\t\tdeb(i, xxor[i]);\n\t}\n\tint res = 0;\n\tint now = 0;\n\tvector<int> cur;\n\tfor(int i = 1; i < 16; i++) {\n\t\tres += (cnt[i] / 2);\n\t\tcnt[i] &= 1;\n\t\tnow += cnt[i];\n\t\tif(cnt[i])\tcur.push_back(i);\n\t}\n\n\tvector<int> dp(1 << 17, 0);\n\t\n\tfor(int i = 0; i < (1 << now); i++) {\n\t\tfor(int j = 0; j < now; j++) {\n\t\t\tif(i&(1 << j))\tdp[i] ^= cnt[cur[j]] * cur[j];\n\t\t}\n\n\t}\n\tdeb(dp[7], cnt[1], cnt[2], cnt[4]);\n\n\tfor(int mask = 1; mask < (1 << now); mask++) {\n\t\tif(dp[mask])\tcontinue;\n\t\tdp[mask] = 1;\n\t\tfor(int sub = (mask - 1)&mask; sub;\tsub = (sub - 1)&mask) {\n\t\t\tif(dp[sub] == 0)\tdp[mask] = max(dp[mask], dp[mask^sub] + 1);\n\t\t}\n\t\tdeb(mask, dp[mask]);\n\t}\n\tdeb(now, dp[(1 << now)], res);\n\tcout << res + (now - dp[(1 << now) - 1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\n\nint N;\nvector<pii> gg[MN], g[MN];\nint ret;\n\nvoid pre(int v, int p)\n{\n\tfor (pii e : gg[v]) if (e.fi != p) {\n\t\tg[v].eb(e);\n\t\tpre(e.fi, v);\n\t}\t\n}\n\nint dfs(int v)\n{\n\tvi cnt(16);\n\n\tfor (pii e : g[v]) {\n\t\tint res = dfs(e.fi);\n\t\t++cnt[res ^ e.se];\n\t}\n\n\tint xo = 0;\n\n\trep(i, 16) {\n\t\tret += cnt[i] / 2;\n\t\tif (cnt[i] & 1) {\n\t\t\txo ^= i;\n\t\t}\n\t}\n\n\tif (v == 0) {\n\t\trep(i, 16) ret += cnt[i] & 1;\n\t}\n\n\treturn xo;\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgg[x].eb(y, a);\n\t\tgg[y].eb(x, a);\n\t}\n\n\tpre(0, -1);\n\tdfs(0);\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nint A[MAXN];\n\nint solve(vector <int> C, int mask)\n{\n\tif (mask == 0)\n\t\treturn 0;\n\tif (mask < 0)\n\t\treturn INF;\n\tint ans = C[mask] >> 1, d = INF;\n\tif (C[mask] & 1)\n\t{\n\t\tREP(j, 4)\n\t\t{\n\t\t\tif (mask & (1 << j))\n\t\t\t{\n\t\t\t\tvector <int> C1 = C;\n\t\t\t\t++C1[1 << j];\n\t\t\t\t++C1[mask ^ (1 << j)];\n\t\t\t\td = min(d, solve(C1, mask - 1));\n\t\t\t}\n\t\t}\n\t\tif (mask == 15)\n\t\t\tFOR(j, 1, 4)\n\t\t{\n\t\t\tvector <int> C1 = C;\n\t\t\t++C1[1 | (1 << j)];\n\t\t\t++C1[mask ^ 1 ^ (1 << j)];\n\t\t\td = min(d, solve(C1, mask - 1));\n\t\t}\n\t}\n\telse\n\t\td = solve(C, mask - 1);\n\treturn ans + d;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = INF;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tvector <int> C(16);\n\tREP(i, n)\n\t\t++C[A[i]];\n\tcout << solve(C, 15);\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100100\nusing namespace std;\n\nint n,num[N],ans,cnt[20],tmp,dp[400000],tm[20];\nbool hav[20];\n\nint dfs(int zt)\n{\n\tif(dp[zt]!=-1) return dp[zt];\n\tint i,j,k,tt=0,res=30;\n\tmemset(hav,0,sizeof(hav));\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tif((1 << (i-1))&zt) tm[++tt]=i,hav[i]=1;\n\t}\n\tfor(i=1;i<=tt;i++)\n\t{\n\t\tfor(j=1;j<=tt;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tk=tm[j]^tm[i];\n\t\t\tres=min(res,dfs(zt^(1 << (tm[i]-1))^(1 << (tm[j]-1))^(1 << (k-1)))+1+hav[k]);\n\t\t}\n\t}\n\treturn dp[zt]=res;\n}\n\nint main()\n{\n\tint i,j,p,q,o;\n\tcin>>n;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&p,&q,&o);\n\t\tnum[++p]^=o;\n\t\tnum[++q]^=o;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcnt[num[i]]++;\n\t}\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\ttmp|=cnt[i]*(1 << (i-1));\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0]=0;\n\tcout<<dfs(tmp)+ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nbool used[MAXN], T[4][MAXN], T1[4][MAXN];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tREP(i, SZ(g[v]))\n\t{\n\t\tint to = g[v][i].first;\n\t\tif (!used[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tREP(j, 4)\n\t\t\t\tif (g[v][i].second & (1 << j))\n\t\t\t\t{\n\t\t\t\t\tT[j][v] ^= 1;\n\t\t\t\t\tT[j][to] ^= 1;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tsrand(time(NULL));\n\tint n, ans = INF, time0 = clock();\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tg[u].push_back(MP(v, a));\n\t\tg[v].push_back(MP(u, a));\n\t}\n\tdfs(0);\n\twhile (clock() - time0 < 1950)\n\t{\n\t\tREP(j, 4)\n\t\t\tREP(i, n)\n\t\t\tT1[j][i] = T[j][i];\n\t\tint cur = 0;\n\t\tRFOR(mask, 16, 1)\n\t\t{\n\t\t\tvector <int> A;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tREP(j, 4)\n\t\t\t\t\tif ((mask & (1 << j)) && !T1[j][i])\n\t\t\t\t\t\tok = false;\n\t\t\t\tif (ok)\n\t\t\t\t\tA.push_back(i);\n\t\t\t}\n\t\t\tint p = -1;\n\t\t\tif (SZ(A) & 1)\n\t\t\t\tp = rand() % SZ(A);\n\t\t\tcur += SZ(A) >> 1;\n\t\t\tREP(i, SZ(A))\n\t\t\t{\n\t\t\t\tif (i == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tREP(j, 4)\n\t\t\t\tif (mask & (1 << j))\n\t\t\t\t\tT1[j][A[i]] = false;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cur);\n\t}\n\tcout << ans;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100005;\n\nvector<int> KV[16];\nint dp[1<<15];\n\nint B[16];\nint A[MAXN];\n\nint N, Ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tfor(int i = 1, a, b, c; i < N; i++) {\n\t\tcin >> a >> b >> c;\n\t\ta++; b++;\n\t\tA[a] ^= c;\n\t\tA[b] ^= c;\n\t}\n\tfor(int i = 1; i <= N; i++) B[A[i]]++;\n\n\tAns = B[0]; B[0] = 0;\n\tfor(int i = 1; i <= 15; i++) {\n\t\tAns += B[i]/2;\n\t\tB[i] &= 1;\n\t}\n\n\tfor(int key = 1; key < (1<<15); key++) {\n\t\tint mxbit = 0, sum = 0;\n\t\tfor(int i = 0; i < 15; i++) if(key & (1<<i)) {\n\t\t\tmxbit = i;\n\t\t\tsum ^= i+1;\n\t\t}\n\t\tif(sum) continue;\n\t\tKV[mxbit].eb(key);\n\t}\n\n\tint master = 0;\n\tfor(int i = 0; i < 15; i++) B[i] = B[i+1];\n\tfor(int i = 0; i < 15; i++) if(B[i]) master |= 1<<i;\n\n\tdp[0] = 1;\n\tfor(int i = 0; i < 15; i++) if(master & (1<<i)) {\n\t\tfor(int key = 0; key < (1<<i); key++) {\n\t\t\tint ret = dp[key];\n\t\t\tif(!ret) continue;\n\t\t\tif(key != (master & key)) continue;\n\t\t\tfor(int v : KV[i]) {\n\t\t\t\tif((key & v) || v != (master & v)) continue;\n\t\t\t\tupmax(dp[key | v], ret + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tAns += dp[master] - 1;\n\n\tcout << (N - Ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=100010, inf=2e9;\n\nint n, A[MX];\nint cnt[16];\n\nint B[1<<16];\nint D[1<<16];\n\nint d(int mask){\n    int &res=D[mask];\n    if(res<inf) return res;\n    for(int i=mask; i>0; i=(i-1)&mask)\n        if(B[i]>=0) res=min(res, d(mask^i)+B[i]-1);\n    return res;\n}\n\nbool valid(int s){\n    int res=0;\n    for(int i=0; i<16; i++) if(s&(1<<i)) res^=i;\n    return res==0;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for(int i=1; i<n; i++){\n        int u,v,c; cin>>u>>v>>c;\n        A[u]^=c, A[v]^=c;\n    }\n\n    for(int i=0; i<n; i++) cnt[A[i]]++;\n    int ans=0, mask=0;\n    for(int i=1; i<16; i++) ans+=cnt[i]/2, cnt[i]%=2;\n    for(int i=1; i<16; i++) if(cnt[i]) mask|=(1<<i);\n\n    for(int i=0; i<(1<<16); i++){\n        if(valid(i)) B[i]=__builtin_popcount(i);\n        else B[i]=-1;\n    }\n\n    for(int i=0; i<(1<<16); i++) D[i]=inf;\n    D[0]=0;\n\n    ans+=d(mask);\n\n    cout<<ans<<'\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nvector<pa> G[100020];\n\nint dp[1<<16]={};\nint sumi[1<<16]={};\nint dfs(int r){\n\tif(r==0) return 0;\n\tif(sumi[r])return dp[r];\n\tint g=0;\n\tfor(int i=0;i<16;i++)if(r&(1<<i)){\n\t\tg^=i;\n\t}\n\tif(g){\n\tsumi[r]=1;\n\t\tdp[r]=inf;\n\t\treturn inf;\n\t}\n\tint f;\n\tfor(f=0;;f++)if(r&(1<<f)){\n\t\tbreak;\n\t}\n\tint ans=inf;\n\tfor(int i=f+1;i<16;i++)if(r&(1<<i)){\n\t\tint y=i^f;\n\t\tint ima;\n\t\tif(r&(1<<y))ima=2+dfs(r^(1<<f)^(1<<y)^(1<<i));\n\t\telse ima=1+dfs(r^(1<<f)^(1<<y)^(1<<i));\n\t\tans=min(ans,ima);\n\t}\nsumi[r]=1;\n\tdp[r]=ans;\n\treturn ans;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\nint n;\n \tcin>>n;\n \tfor(int i=0;i<n-1;i++){\n \tint y,yy,yyy;\n \t\tcin>>y>>yy>>yyy;\n \t\t\tG[y].pb({yy,yyy});\n \t\t\tG[yy].pb({y,yyy});\n \t}\n \tint a[16]={};\n \tfor(int i=0;i<n;i++){\n \tint wa=0;\n \t\tfor(auto v:G[i])wa^=v.second;\n \t\n \ta[wa]++;\n \t}\n \t\n \tint ans=0;\n \tfor(int i=1;i<16;i++){\n \tans+=a[i]/2;\n \t\ta[i]&=1;\n \t}\n \tint t=0;\n \tint g=0;\n \tfor(int i=1;i<16;i++){\n \t\tif(a[i]){\n \t\t\tt+=(1<<i);\n \t\t\tg^=i;\n \t\t}\n \t}\n \tassert(g==0);\n \tcout<<ans+dfs(t)<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 100000;\nconst int S = 1 << 16;\n\nint n;\nint val[N + 5];\nbool can[S + 5];\nint dp[S + 5], cnt[16];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; ++i) {\n        static int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        ++ cnt[val[i]];\n    }\n\n    int ans = 0, mask = 0;\n    for(int i = 1; i < 16; ++i) {\n        ans += cnt[i] / 2;\n        if(cnt[i] &= 1) mask |= 1 << i;\n    }\n\n    for(int i = 0; i < S; ++i) {\n        int res = 0;\n        for(int j = 0; j < 16; ++j) if(i >> j & 1) res ^= j;\n        if(res == 0) can[i] = true;\n    }\n\n    for(int i = 0; i < S; ++i) {\n        for(int j = i; j; j = (j - 1) & i) \n            if(can[j]) { chkmax(dp[i], dp[i ^ j] + 1); }\n    }\n\n    printf(\"%d\\n\", ans + __builtin_popcount(mask) - dp[mask]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\n\nint n,ans;\nint t[N],a[18];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tt[x]^=z;\n\t\tt[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\ta[t[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t\tans+=a[i]>>1,a[i]&=1;\n\tfor(int i=1;i<=15;i++) if(a[i])\n\tfor(int j=i+1;j<=15;j++) if(a[j])\n\t\tif(a[i^j]) a[i]=0,a[j]=0,a[i^j]=0,ans+=2;\n\tfor(int i=1;i<=15;i++) if(a[i])\n\tfor(int j=i+1;j<=15;j++) if(a[j])\n\tfor(int k=j+1;k<=15;k++) if(a[k])\n\t\tif(a[i^j^k]) a[i]=0,a[j]=0,a[k]=0,a[i^j^k]=0,ans+=3;\n\tfor(int i=1;i<=15;i++)\n\t\tif(a[i]) a[16]++;\n\tif(a[16]>=5) ans+=a[16]-1;\n\telse ans+=a[16];\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<15;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[16], f[MaxM+10];\nbool xr[MaxM+10];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[++x]^=z, v[++y]^=z;\n\tfor (int i=1; i<=n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=1; i<=15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=i;\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1e9+7;\nconst llint big=(llint)44e15;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nstatic int dp[65536]={0};\nvector<vector<pair<int,int>>>ko;\narray<int,16>use;\nvoid solve(int ter,int oya,int uex){\n\t//è¿ãæ¹åã®xor\n\tif(oya!=-1){use[uex]++;}\n\tfor(auto it:ko[ter]){\n\t\tif(it.fir==oya){continue;}\n\t\tsolve(it.fir,ter,uex^it.sec);\n\t}\n}\nint main(void){\n\tint n,ans,i,j;\n\t//i åbitãæã£ã¦ãã\n\tfor(i=1;i<65536;i++){//xorã0ã«ãªããããªçµã¿åããããã¾ããã¨è¦ã¤ãã\n\t\tint bi=0;\n\t\tfor(j=1;j<16;j++){\n\t\t\tif(((1<<j)&i)!=0){bi^=j;}\n\t\t}\n\t\tif(bi==0){maxeq(dp[i],1);}\n\t\t\n\t\tfor(j=1;j<65536;){\n\t\t\tif(((65535-i)&j)!=0){j+=(65535-i)&j;continue;}\n\t\t\tmaxeq(dp[i],dp[j]+dp[i-j]);\n\t\t\tj++;\n\t\t}\n\t}\n\tcin>>n;ans=n-1;\n\tko.res(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint x,y,a;cin>>x>>y>>a;\n\t\tko[x].pub(mp(y,a));\n\t\tko[y].pub(mp(x,a));\n\t}\n\tsolve(0,-1,0);\n\tans-=use[0];use[0]=0;\n\tfor(i=1;i<16;i++){ans-=use[i]/2;use[i]%=2;}\n\tint bi=0;for(i=0;i<16;i++){if(use[i]==1){bi+=(1<<i);}}\n\t//cout<<bi<<\" \"<<dp[bi]<<endl;\n\tans-=dp[bi];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int N = 100005;\nconst int R = 16;\nconst int _R = 1 << R;\nint n, head[N], cnt[R], dp[_R], tot, x, y, z, ans;\nstruct edge { int to, nxt, cost; } e[N << 1];\nvoid addedge(int x, int y, int z) {\n\te[++tot] = (edge) { y, head[x], z }; head[x] = tot;\n\te[++tot] = (edge) { x, head[y], z }; head[y] = tot;\n}\nvoid dfs(int x, int f = -1) {\n\tint v = 0; for (int i = head[x]; i; i = e[i].nxt) v ^= e[i].cost; cnt[v]++;\n\tfor (int i = head[x]; i; i = e[i].nxt) if (e[i].to != f) dfs(e[i].to, x);\n}\nint main() {\n\tstd::scanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) std::scanf(\"%d%d%d\", &x, &y, &z), addedge(x, y, z); \n\tdfs(0);\n\tint v = 0;\n\tfor (int i = 1; i < R; i++) ans += cnt[i] >> 1, cnt[i] &= 1, v |= cnt[i] << i;\n\tstd::memset(dp, 0x3f, sizeof dp);\n\tdp[0] = 0;\n\tfor (int i = 2; i < _R; i += 2) {\n\t\tint v = 0; for (int t = 0; t < 16; t++) if (i >> t & 1) v ^= t;\n\t\tif (v) continue;\n\t\tdp[i] = __builtin_popcount(i) - 1;\n\t\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\t\tdp[i] = std::min(dp[i], dp[j] + dp[i - j]);\n\t}\n\tstd::printf(\"%d\\n\", dp[v] + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<int> > ed;\nvector<vector<int> > w;\nvector<int > V;\nvector<int> X(16, 0);\nvector<int> dp(1 << 16, -1);\nint dfs(int a, int p) {\n\tint x = 0;\n\tfor (int i = 0; i < ed[a].size(); i++) {\n\t\tif (ed[a][i] != p) {\n\t\t\t//cerr << \"a\" << endl;\n\t\t\tdfs(ed[a][i], a);\n\t\t\tX[V[ed[a][i]] ^ w[a][i]]++;\n\t\t\tx ^= w[a][i];\n\t\t}\n\t}\n\tV[a] = x;\n\treturn V[a];\n}\nint rec(int a) {\n\tif (dp[a] != -1) {\n\t\treturn dp[a];\n\t}\n\tvector<int> T;\n\tint b = a;\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (b % 2 == 1) {\n\t\t\tT.push_back(i);\n\t\t}\n\t\tb /= 2;\n\t}\n\tdp[a] = 1000000000;\n\tint aa = 0;\n\tint p;\n\tfor (int i = 0; i < (int)T.size() - 1; i++) {\n\t\tfor (int j = i + 1; j < (int)T.size(); j++) {\n\t\t\taa = a ^ ((1 << T[i]) | (1 << T[j]));\n\t\t\tp = 1;\n\t\t\tif ((a & (1 << (T[i] ^ T[j]))) != 0) {\n\t\t\t\tp = 2;\n\t\t\t}\n\t\t\tdp[a] = min(dp[a], p + rec((a ^ ((1 << T[i]) | (1 << T[j]))) ^ (1 << (T[i]^T[j]))));\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)T.size(); i++) {\n\t\tdp[a] = min(dp[a], 1 + rec(a ^ (1 << T[i])));\n\t}\n\treturn dp[a];\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\ted.resize(N);\n\tw.resize(N);\n\tV.resize(N, 0);\n\tint a, b, c;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> a >> b >> c;\n\t\ted[a].push_back(b);\n\t\tw[a].push_back(c);\n\t\ted[b].push_back(a);\n\t\tw[b].push_back(c);\n\t}\n\tdfs(0, -1);\n\tint s = 0;\n\tint res = 0;\n\tfor (int i = 1; i < 16; i++) {\n\t\t//cerr << X[i] << endl;\n\t\tres += X[i] / 2;\n\t\tX[i] = X[i] % 2;\n\t\ts += (1 << i)*X[i];\n\t}\n\t//cerr << s << endl;\n\tdp[0] = 0;\n\trec(s);\n\t//rec((1 << 16) - 1);\n\tcout << res + dp[s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,x,y,z,now,ans,a[120000],cnt[16],f[1<<15];\nvector<int> vec;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z; a[y]^=z;\n\t}\n\tfor (int i=0;i<n;++i) ++cnt[a[i]];\n\tfor (int i=1;i<=15;++i){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tnow|=cnt[i]<<(i-1);\n\t}\n\tmemset(f,-1,sizeof f);\n\tf[now]=ans; vec.push_back(now);\n\tfor (int i=0;i<(int)vec.size();++i){\n\t\tint S=vec[i];\n\t\tfor (int j1=1;j1<=15;++j1)\n\t\t\tif (1<<(j1-1)&S){\n\t\t\t\tfor (int j2=j1+1;j2<=15;++j2)\n\t\t\t\t\tif (1<<(j2-1)&S){\n\t\t\t\t\t\tfor (int k=1;k<=15;++k){\n\t\t\t\t\t\t\tint t1=j1^k,t2=j2^k,T=S,tmp=1;\n\t\t\t\t\t\t\tT^=1<<(j1-1); T^=1<<(j2-1);\n\t\t\t\t\t\t\tif (1<<(t1-1)&T) ++tmp;\n\t\t\t\t\t\t\tif (1<<(t2-1)&T) ++tmp;\n\t\t\t\t\t\t\tif (t1) T^=1<<(t1-1); if (t2) T^=1<<(t2-1);\n\t\t\t\t\t\t\tif (f[T]==-1||f[S]+tmp<f[T]){\n\t\t\t\t\t\t\t\tf[T]=f[S]+tmp;\n\t\t\t\t\t\t\t\tvec.push_back(T);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof a)\n#define PII pair<int,int>\n#define PI acos(-1.0)\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF=0x3f3f3f3f;\nconst int maxn=1e5+10;\nint dp[1<<16],V[maxn],cnt[16];\nint n,x,y,a;\ninline int Count(int x)\n{\n\tint ans=0;\n\tfor(int i=0;i<=15;++i) if(x&(1<<i)) ans++;\n\treturn ans;\n}\nint Work(int S)\n{\n    if(S==0) return 0;\n    if(dp[S]!=-1) return dp[S];\n    dp[S]=INF;\n    for(int i=1;i<16;i++)\n    {\n    \tif(S&(1<<i))\n            for(int j=1;j<16;j++)\n            {\n            \t\n            \tif(S&(1<<j))\n                {\n                    int cs=S^(1<<i)^(1<<j)^(1<<(i^j));\n                    if(Count(cs)<Count(S)) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(((1<<(i^j)) & S) == (1<<(i^j))) dp[S]=min(dp[S], Work(cs) + 2);\n\t\t\t\t\t\telse dp[S]=min(dp[S], Work(cs) + 1 ); \n\t\t\t\t\t}\n                }\n\t\t\t}\n\t}\n    return dp[S];\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&a);\n        V[x]^=a; V[y]^=a;\n    }\n    for(int i=0;i<n;i++) if(V[i]) cnt[V[i]]++;\n    int ans=0,s=0;\n    for(int i=0;i<16;i++) ans+=cnt[i]/2, s^=(cnt[i]&1)<<i;\n    memset(dp,-1,sizeof dp);\n    ans+=Work(s);\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=__builtin_popcount(cnt[i]);\n    if((res>>cnt[i])&1)\n      ans-=(__builtin_popcount(cnt[i])-1)*2;\n    res^=1<<cnt[i];\n  }\n  //cout<<ans<<\":\"<<res<<endl;\n  ans/=2;\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  dp[res]=0;\n  for(Int b=(1<<16)-1;b>0;b--){\n    for(Int i=0;i<16;i++){\n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\tInt dif=__builtin_popcount(i&j)-1;\n\tchmax(dp[b^(1<<i)^(1<<j)],dp[b]+dif);\n      }\n    }\n  }\n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint n;\nint a[N], c[16], v[16], dp[1 << 15];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int rep = 1; rep < n; ++rep) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    a[u] ^= w;\n    a[v] ^= w;\n  }\n  int ans = n;\n  for (int i = 0; i < n; ++i)\n    if (a[i])\n      ++c[a[i]];\n    else\n      --ans;\n  int m = 0;\n  for (int i = 1; i <= 15; ++i) {\n    ans -= c[i] >> 1;\n    c[i] &= 1;\n    if (c[i])\n      v[m++] = i;\n  }\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for (int s = 1; s < 1 << m; ++s) {\n    int xs = 0;\n    for (int i = 0; i < m; ++i)\n      if ((s >> i) & 1)\n        xs ^= v[i];\n    if (xs) continue;\n    int t = (s - 1) & s;\n    dp[s] = m + 1;\n    while (true) {\n      if (dp[t] != -1)\n        dp[s] = min(dp[s], dp[t] + 1);\n      if (!t)\n        break;\n      t = (t - 1) & s;\n    }\n  }\n  ans -= dp[(1 << m) - 1];\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\nconst long long MAXN = 2e5 + 21, LG = 20, inf = 1e18, mod = 998244353;\n\nint n;\nint cnt[MAXN], v[MAXN];\nint dp[1 << 21];\nlong long ans, st;\n\nint dfs(int root) {\n\tif(root == 0) \n        return 0;\n\tif(dp[root] ^ -1) \n        return dp[root];\n\n\tdp[root] = inf;\n\t\n    for(int i = 0; i < 16; i++)\n\t\tif(root>>i&1) {\n\t\t\tfor(int j = 0; j < 16; j++)\n\t\t\t\tif(root>>j&1) {\n\t\t\t\t\tint x = j ^ i;\n\t\t\t\t\tint nxt = root ^ (1 << j) ^ (1 << i) ^ (1 << x);\n\t\t\t\t\tif(__builtin_popcount(nxt) < __builtin_popcount(root))\n\t\t\t\t\t    dp[root] = min(dp[root], dfs(nxt) + 1 + ((root & (1 << x)) == (1 << x)));\n\t\t\t\t}\n\t\t}\n\treturn dp[root];\n}\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n\t\tv[x] ^= z;\n\t\tv[y] ^= z; \n\t}\n\t\n    memset(dp, -1, sizeof dp);\n\n\tfor(int i = 0; i < n; i++)\n        if(v[i]) \n            cnt[v[i]]++;\n\t\n\tfor(int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tst |= ((cnt[i] & 1) << i);\n\t}\n\t\n    ans += dfs(st);\n\tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nconst int N = 205100;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; char c = getchar();\n    while (!isdigit(c)) c=getchar();\n    for (;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);\n}\n\nint x, y, n, res, st;\nint d[N], sum[N], u[N], cnt[N];\ninline int to(int x) {return 1 << x;}\nint main() {\n    read(n);\n    for (int i = 1;i < n; i++) {\n        int x, y, a; read(x), read(y), read(a);\n        u[x] ^= a, u[y] ^= a;\n    }\n    for (int i = 0;i < n; i++) cnt[u[i]]++;\n    int all = to(15);\n    for (int i = 1;i < all; i++) d[i] = d[i>>1] + (i & 1);\n    for (int i = 1;i < all; i++) d[i]--;\n    for (int i = 1;i <= 15; i++) res += cnt[i] / 2, st |= (cnt[i] & 1) << (i-1);\n    for (int i = 1;i < all; i++) \n        for (int j = 0;j < 15; j++) \n            if (i & to(j)) sum[i] ^= (j + 1);\n    for (int i = 1;i < all; i++) {\n        if (sum[i] != 0) continue;\n        for (int j = (i - 1) & i; j; j = (j - 1) & j) \n            if (sum[j] == 0) d[i] = min(d[i], d[j] + d[i ^ j]);\n    }\n    cout << res + d[st] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2e6+1000;\nint n,a[N],f[N],cnt[N],as,st,S,x[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri t1=read()+1,t2=read()+1,z=read();a[t1]^=z;a[t2]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);\n\trp(i,1,S)--f[i];rp(i,1,S)rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops\")\n#include<bits/stdc++.h>\n#define ll long long\n#define F first\n#define S second\n#define P pair\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define rep(i,a,b) for(int i=a;i<b;i++) \n#define V vector\n#define RE return\n#define ALL(a) a.begin(),a.end()\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define FILL(a,b) memset(a,b,sizeof(a))\nusing namespace std;\nint c[16],n,v[200005],dp[1<<16];\nint dfs(int x){\n\tif(dp[x]!=-1)RE dp[x];\n\tint re=1000000000;\n\trep(i,1,16){\n\t\tif(x&(1<<i)){\n\t\t\trep(j,i+1,16){\n\t\t\t\tif(x&(1<<j)){\n\t\t\t\t\tre=min(re,dfs(x^(1<<i)^(1<<j)^(1<<(i^j)))+1+((x&(1<<(i^j)))?1:0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tRE dp[x]=re;\n}\nint main(){\n\tios::sync_with_stdio(0);\n    cin.tie(0);\n\tcin>>n;\n\tint x,y,z;\n\trep(i,1,n){\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tint ans=0;\n\trep(i,0,n){\n\t\tc[v[i]]++;\n\t}\n\tFOR(i,1,15){\n\t\tans+=c[i]/2;\n\t\tc[i]&=1;\n\t}\n\tint get=0;\n\tFILL(dp,-1);dp[0]=0;\n\tFOR(i,1,15)if(c[i])get^=(1<<i);\n\tcout<<dfs(get)+ans;\n\tRE 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\nconst int N=2e5;\nint ans,n,a[N],t,f[1<<20],q[N],d[N];\nint main()\n{\n\tn=read();\n\tint x,y,v;\n\tfor(int i=1;i<n;++i)x=read()+1,y=read()+1,v=read(),a[x]^=v,a[y]^=v;\n\tsort(a+1,a+n+1);//for(int i=1;i<=n;++i)printf(\"%d \",a[i]);printf(\"\\n\");\n\tfor(int i=1;i<=n;++i)\n\tif(i<n&&a[i]==a[i+1]) a[i]!=0?ans++:0,i++;\n\telse q[++t]=a[i];\n\tfor(int i=2;i<(1<<t);++i)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<t);++i)\n\tfor(int j=1;j<=t;++j)\n\tif(i&(1<<(j-1)))\n\td[i]^=q[j];\n\tfor(int i=1;i<(1<<t);++i)\n\tif(!d[i])\n\tfor(int j=(i-1)&i;j;j=(j-1)&i)\n\tif(!d[j])\n\tf[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\\n\",f[(1<<t)-1]+ans);\n}"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int inf = 1e9,maxn=3e5+5,maxs=(1<<16) + 5;\n\nint n,cnt[maxn],w[maxn],ans;\nint goodst[maxs], dp[maxs];\n\nint main(){\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\t++x;++y;\n\t\tw[x] ^= z;w[y] ^= z;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)++cnt[w[i]];\n\tfor(int i=1;i<=15;i++)\n\t\tans += cnt[i]/2, cnt[i]%=2;\n\tint lim=0;for(int i=1;i<=15;i++)lim |= (cnt[i] == 0?0:(1<<i)), ans += (cnt[i]!=0);\n\tfor(int S=0;S<=(1<<16)-1;S++){\n\t\tint x=0;\n\t\tfor(int i=0;i<=15;i++)\n\t\t\tif(S&(1<<i))x^=i;\n\t\tgoodst[S] = 0;if(x==0)goodst[S] = 1;\n\t}\n\t\n\tfor(int S=0;S<=(1<<16)-1;S++){\n\t\tif(S&1)continue;\n\t\tfor(int T=S;T;T=(T-1)&S){\n\t\t\tif(goodst[T])\n\t\t\t\tdp[S] = max(dp[S], dp[S^T]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans-dp[lim]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint dp[100010];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) dp[u] = 1;\n        }\n    }\n\n    int cnt = 0;\n    for(int i = 0; i < N; i++) if(dp[i]) cnt++;\n    printf(\"%d\", (cnt + 1) / 2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<lint, int> pi;\ntypedef long long lint;\nconst int MAXN = 100005;\n \nint n;\nint cnt[16], arr[MAXN];\nint dp[MAXN];\n \nint bfs(int msk){\n\tfor(int i=1; i<(1<<16); i++){\n\t\tint ans = 0;\n\t\tdp[i] = -1e9;\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif((i >> j) & 1) ans ^= j;\n\t\t}\n\t\tif(ans == 0) dp[i] = 1;\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tdp[i] = max(dp[j] + dp[i^j], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<16; i++) if((msk >> i) & 1) ans++;\n\treturn  dp[msk];\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e, x;\n\t\tscanf(\"%d %d %d\",&s,&e,&x);\n\t\tarr[s] ^= x;\n\t\tarr[e] ^= x;\n\t}\n\tfor(int i=0; i<n; i++) cnt[arr[i]]++;// printf(\"%d\\n\", arr[i]);\n\tint msk = 0, ans = 0;\n\tfor(int i=1; i<16; i++){\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1) msk |= (1 << i);\n\t}\n\tcout << ans + bfs(msk) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint n,x,y,a,s[100005],sum[16],ans,q,dp[1<<16];\nint dfs(int cnt)\n{\n\tif(!cnt)\n\t\treturn 0;\n\tif(dp[cnt] != -1)\n\t\treturn dp[cnt];\n\tfor(int i = 1;i <= 15;++i)\n\t{\n\t\tif(cnt & (1<<i))\n\t\t{\n\t\t\tfor(int j = 1;j <= 15;++j)\n\t\t\t{\n\t\t\t\tif(j != i && (cnt & (1<<j)))\n\t\t\t\t{\n\t\t\t\t\tint temp = cnt-(1<<i)-(1<<j),kk;\n\t\t\t\t\tif((1<<(i^j)) & temp)\n\t\t\t\t\t{\n\t\t\t\t\t\tkk = 2+dfs(temp-((1<<(i^j))));\n\t\t\t\t\t\tif(dp[cnt] != -1)\n\t\t\t\t\t\t\tdp[cnt] = min(dp[cnt],kk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[cnt] = kk;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tkk = 1+dfs(temp+((1<<(i^j))));\n\t\t\t\t\t\tif(dp[cnt] != -1)\n\t\t\t\t\t\t\tdp[cnt] = min(dp[cnt],kk);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[cnt] = kk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[cnt];\n}\nint main()\n{\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\tmemset(s,0,sizeof(int)*(n+1));\n\t\tmemset(sum,0,sizeof(sum));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i = 1;i < n;++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&a);\n\t\t\ts[x] ^= a;\n\t\t\ts[y] ^= a;\n\t\t}\n\t\tfor(int i = 0;i < n;++i)\n\t\t\t++sum[s[i]];\n\t\tans = q = 0;\n\t\tfor(int i = 1;i <= 15;++i)\n\t\t{\n\t\t\tans += sum[i] >> 1;\n\t\t\tsum[i] &= 1;\n\t\t\tq += sum[i] * (1<<i);\n\t\t}\n\t\tans += dfs(q);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt[20],ok[1<<17],dp[1<<17],val[N];\ntypedef pair<int,int> pii;\nvector<pii> e[N];\nvoid dfs(int x,int fa){\n\tfor (auto i:e[x]){\n\t\tint v=i.first;\n\t\tif (v==fa) continue;\n\t\tval[v]=i.second;\n\t\tval[x]^=val[v];\n\t\tdfs(v,x);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v,l;\n\t\tscanf(\"%d%d%d\",&u,&v,&l);u++;v++;\n\t\te[u].push_back(pii(v,l));\n\t\te[v].push_back(pii(u,l));\n\t}\n\tdfs(1,0);\n\tfor (int i=2;i<=n;i++) cnt[val[i]]++;\n\tint ans=0;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,cnt[i]%=2;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i];\n\tcnt[0]=0;\n\tint U=1<<16;\n\tfor (int i=0;i<U;i++){\n\t\tint s=0;\n\t\tfor (int j=0;j<16;j++)\n\t\tif (i>>j&1) s^=j;\n\t\tif (!s) ok[i]=1;\n\t}\n\tfor (int i=0;i<U;i++)\n\tfor (int j=i;j;j=(j-1)&i){\n\t\tif (ok[j]) dp[i]=max(dp[i],dp[i^j]+1);\n\t\tdp[i]=max(dp[i],dp[i^j]);\n\t}\n\tint tmp=0;\n\tfor (int i=0;i<16;i++) tmp^=cnt[i]<<i;\n\tprintf(\"%d\\n\",ans-dp[tmp]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint D[101010], P[101010];\nint T[101010], K[16];\nint n, k, ans, s;\n\nint main()\n{\n\tint i, j, t, a, b, c;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor(i=1; i<n; i++){\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tP[a] ^= c;\n\t\tP[b] ^= c;\n\t}\n\t\n\tfor(i=0; i<n; i++){\n\t\tK[P[i]] ++;\n\t}\n\t\n\tfor(i=0; i<15; i++){\n\t\tans += K[i + 1] >> 1;\n\t\tk |= (1 << i) * (K[i + 1] & 1);\n\t\ts += (K[i + 1] & 1);\n\t}\n\t\n\tD[0] = 0;\n\t\n\tfor(i=1; i<(1<<15); i++){\n\t\tfor(j=t=0; j<15; j++){\n\t\t\tif(i & (1 << j)) t ^= (j + 1);\n\t\t}\n\t\tif(t == 0) T[i] = 1;\n\t\t\n\t\tD[i] = 0;\n\t\t\n\t\tfor(j=i; j; j=j-1&i){\n\t\t\tif(T[j]) D[i] = max(D[i], D[i - j] + 1);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans + s - D[k]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100000;\n\nint f[MX], cnt[16], dp[1 << 16];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\tfor (int i = 1, u, v, a; i < n; i++) {\n\t\tignore = scanf(\"%d %d %d\", &u, &v, &a);\n\t\tf[u] ^= a;\n\t\tf[v] ^= a;\n\t}\n\t\n\tfor (int i = 0; i < n; i++) cnt[f[i]]++;\n\t\n\tint ans = 0, mask = 0;\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tmask |= (cnt[i] & 1) << i;\n\t}\n\t\n\tdp[0] = ans;\n\tfor (int i = 1; i <= mask; i++) {\n\t\tint j = 0;\n\t\twhile ((i >> j) % 2 == 0) j++;\n\t\tdp[i] = 42;\n\t\tfor (int k = j + 1; (1 << k) <= i; k++)\n\t\t\tif ((i >> k) % 2 == 1) {\n\t\t\t\tint val = dp[i ^ (1 << j) ^ (1 << k) ^ (1 << (k - j))] + 1;\n\t\t\t\tif ((i >> (k - j)) % 2 == 1) val++;\n\t\t\t\tdp[i] = min(dp[i], val);\n\t\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[mask]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100100;\nint  n , deg[N] , cnt[16];\nint ans , dp[1<<16] , msk;\nint ok[1<<16];\n\nint main(){\n\nscanf(\"%d\",&n);\nfor(int i=1;i<n;i++){\n    int u,v,c;\n    scanf(\"%d %d %d\",&u,&v,&c);\n    deg[u] ^= c;\n    deg[v] ^= c;\n}\n\nfor(int i=0;i<n;i++)cnt[deg[i]]++;\nfor(int i=1;i<16;i++){\n    ans += (cnt[i]>>1);\n    if( cnt[i]&1 )\n        msk |= (1<<i);\n}\n\nfor(int i=0;i<(1<<16);i++){\n    int x =0;\n    for(int j=0;j<16;j++)\n        if( i&(1<<j) )\n         x ^= j;\n    ok[i]=(x==0);\n}\n\nfor(int i=0;i<(1<<16);i++){\n    int j = i ;\n    while( j ){\n        if( ok[j] )\n            dp[i] = max( dp[i] , 1+dp[i^j] );\n        j=(j-1)&i;\n    }\n}\n\nprintf(\"%d\\n\",ans+__builtin_popcount(msk)-dp[msk]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 100, M = 16;\n\nint n, ans, a[N], cnt[M], dp[1 << M];\n\nbool ok(int mask) {\n\tint res = 0;\n\tfor (int i = 0; i < M; i++)\n\t\tif (mask & (1 << i))\n\t\t\tres ^= i;\n\treturn res == 0;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tfor (int i = 1; i < M; i++) {\n\t\tans += (cnt[i] >> 1);\n\t\tcnt[i] &= 1;\n\t}\n\tint mask = 0;\n\tfor (int i = 1; i < M; i++)\n\t\tif (cnt[i])\n\t\t\tmask |= 1 << i;\n\tans += __builtin_popcount(mask);\n\tfor (int x = 1; x <= mask; x++) {\n\t\tdp[x] = ok(x);\n\t\tif ((mask & x) == x)\n\t\t\tfor (int y = x; y; y = (--y & x))\n\t\t\t\tif (y < x && ok(y))\n\t\t\t\t\tdp[x] = max(dp[x], dp[y] + dp[x ^ y]);\n\t}\n\tans -= dp[mask];\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 100000;\nconst int S = 1 << 16;\n\nint n;\nint val[N + 5];\nbool can[S + 5];\nint dp[S + 5], cnt[16];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        static int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        ++ cnt[val[i]];\n    }\n\n    int ans = 0, mask = 0;\n    for(int i = 1; i < 16; ++i) {\n        ans += cnt[i] / 2;\n        if(cnt[i] &= 1) mask |= 1 << i;\n    }\n\n    for(int i = 0; i < S; ++i) {\n        int res = 0;\n        for(int j = 0; j < 16; ++j) if(i >> j & 1) res ^= i;\n        if(res == 0) can[i] = true;\n    }\n\n    for(int i = 0; i < S; ++i) {\n        for(int j = i; j; j = (j - 1) & i) \n            if(can[j]) { chkmax(dp[i], dp[i ^ j] + 1); }\n    }\n\n    printf(\"%d\\n\", ans + __builtin_popcount(mask) - dp[mask]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\nbool book[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tn=1<<15;\n\tfor(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)d[i]-=1;\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n\tfor(int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sxr[i]!=0)continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t\tif(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n\t}printf(\"%d\",res+d[st]);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n#define eps 1e-8\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 + c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nstruct node {\n    int to,next,val;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nint C[MAXN],cnt[25],f[(1 << 15) + 5];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].val = c;\n    head[u] = sumE;\n}\nvoid dfs(int u,int fa) {\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            C[v] ^= E[i].val;\n            dfs(v,u);\n            C[u] ^= C[v];\n        }\n    }\n}\nvoid Solve() {\n    read(N);\n    int x,y,a;\n    for(int i = 1 ; i < N ; ++i) {\n        read(x);read(y);read(a);\n        add(x,y,a);add(y,x,a);\n    }\n    dfs(0,-1);\n    for(int i = 1 ; i < N ; ++i) {\n        cnt[C[i]]++;\n    }\n    int ans = 0,q = 0;\n    for(int i = 1 ; i <= 15 ; ++i) {\n        if(cnt[i]) ans += cnt[i] / 2;\n        cnt[i] %= 2;\n        if(cnt[i]) q |= 1 << (i - 1);\n    }\n    for(int i = 1 ; i < (1 << 15) ; ++i) {\n        int a = 0,c = 0;\n        for(int j = 1 ; j <= 15 ; ++j) {\n            if(i >> (j - 1) & 1) {\n                a ^= j;\n                ++c;\n            }\n        }\n        if(!a) f[i] = c - 1;\n        else f[i] = c;\n    }\n    for(int S = 1 ; S < (1 << 15) ; ++S) {\n        for(int T = (S - 1) & S ; T ; T = (T - 1) & S) {\n            f[S] = min(f[S],f[T] + f[S ^ T]);\n        }\n    }\n    ans += f[q];\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read()\n{int x=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') c=getchar();\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nreturn x;\n}\nint x[100005],num[17],o[17],cnt=0;\nint dp[32769],f[32769],p[32769];\ninline int max(int a,int b)\n{return a>b?a:b;}\nint main (){\n\tint a,b,c,i,maxn=0,n,j;\n\tn=read();\n\tfor (i=1;i<n;i++)\n\t{a=read()+1;b=read()+1;c=read();\n\tx[a]^=c;x[b]^=c;\n\t}\n\tfor (i=1;i<=n;i++)\n\t{num[x[i]]++;}\n\tmaxn=num[0];\n\tfor (i=1;i<=15;i++)\n\t{maxn+=(num[i]>>1);\n\tif (num[i]&1) {o[cnt++]=i;}\n\t}\n\tfor (i=0;i<cnt;i++) p[(1<<i)]=i;\n\tfor (i=1;i<(1<<cnt);i++)\n\t{f[i]=f[i-(i&(-i))]^o[p[i&(-i)]];}\n\tfor (i=1;i<(1<<cnt);i++)\n\t{for (j=i;j;j=(j-1)&i)\n\t{if (f[j]) continue;\n\tdp[i]=max(dp[i],dp[i^j]+1);\n\t}\n\t}\n\tmaxn+=dp[(1<<cnt)-1];\n\tprintf (\"%d\\n\",n-maxn);\n\treturn 0;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "/****** BISMILLAH HIR RAHMANIR RAHIM ******/\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<string,string> mss;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef map <int, vector<string> > mvis;\ntypedef map <string, vector<int> > mvsi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define INF 2000000000\n#define pb push_back\n#define MAX 100002\n#define debug cout<<\"A\"<<\"\\n\"\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=b; i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define ClearQ(x); while(!x.empty()) x.pop()\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n, u, v, k, d[MAX], cnt[20];\nvi rest;\nint dp[1<<17];\n\nint go(int mask)\n{\n\t// prnt(mask);\n\tif(mask&1) mask^=1;\n\tif(mask==0) return 0;\n\tif(dp[mask]!=-1) return dp[mask];\n\n\tint ret=16;\n\n\tfor(int i=1; i<=16; i++)\n\t{\n\t\tfor(int j=1; j<=16; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif((mask&(1<<i)) && (mask&(1<<j)))\n\t\t\t{\n\t\t\t\tint nxtmask=mask^(1<<i);\n\t\t\t\tnxtmask^=(1<<j);\n\t\t\t\tnxtmask^=(1<<(i^j));\n\n\t\t\t\tint add=1;\n\n\t\t\t\tif(mask&(1<<(i^j)))\n\t\t\t\t{\n\t\t\t\t\tadd++;\n\t\t\t\t}\n\n\n\t\t\t\tret=min(ret,add+go(nxtmask));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[mask]=ret;\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    scanf(\"%d\", &n);\n\n    FOR(i,0,n-1)\n    {\n    \tscanf(\"%d%d%d\", &u, &v, &k);\n\n    \td[u]^=k;\n    \td[v]^=k;\n    }\n\n    FOR(i,0,n)\n    {\n    \tif(d[i]) \n    \t{\n    \t\t// prnt(d[i]);\n    \t\tcnt[d[i]]++;\n    \t}\n    }\n\n    int ans=0, mask=0;\n\n    FOR(i,1,17)\n    {\n    \tans+=cnt[i]/2;\n    \tif(cnt[i]%2) rest.pb(i), mask|=(1<<i);\n    }\n\n    // debug;\n    // VecPrnt(rest);\n    // prnt(mask);\n\n    // prnt(ans);\n    ms(dp,-1);\n    prnt(ans+go(mask));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int NMAX = 1e5;\nint n;\nint b[NMAX + 5];\nint dp[(1 << 15)];\n\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i = 1;i < n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tx++;\n\t\ty++;\n\t\tb[x] ^= z;\n\t\tb[y] ^= z;\n\t}\n\t\n\tint ans = n;\n\tint mask = 0;\n\t\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(b[i] == 0){\n\t\t\tans--;\n\t\t}\n\t\telse if((mask >> (b[i] - 1)) & 1){\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t\tans--;\n\t\t}\n\t\telse{\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t}\n\t}\n\t\t\n\tdp[0] = 0;\n\t\n\tfor(int i = 1;i <= mask;i++){\n\t\tdp[i] = -(1 << 28);\n\t\tfor(int j = i;j;j = (j - 1) & i){\n\t\t\tint xo = 0;\n\t\t\t\n\t\t\tfor(int b = 0;b < 15;b++){\n\t\t\t\tif((j >> b) & 1){\n\t\t\t\t\txo ^= (b + 1);///cause i subtracted 1 before to make them in [0,15) range\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(xo == 0){\n\t\t\t\tdp[i] = max(dp[i],1 + dp[i ^ j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans -= dp[mask];\n\t\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 100100;\nconst int maxj = 17;\n \nint n,res,mask,nn,a[maxn],cnt[maxn],dp[(int)1<<maxj],good[(int)1<<maxj];\n \nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        a[x]^=z;\n        a[y]^=z;\n    }\n    for (int i=0;i<n;i++) cnt[a[i]]++;\n    for (int i=1;i<=maxj;i++) {\n        res+=cnt[i]/2;\n        cnt[i]%=2;\n    }\n    for (int i=1;i<=maxj;i++)\n        if (cnt[i]!=0) {\n            mask|=(1<<i);\n            nn++;\n        }\n    for (int tt=0;tt<(1<<maxj);tt++) {\n        int x=0;\n        for (int i=0;i<maxj;i++)\n            if (tt&(1<<i)) x^=i;\n        good[tt] = (x==0);\n    }\n    for (int tt=0;tt<(1<<maxj);tt++) {\n        if (tt&1) continue;\n        int u=tt;\n        while (u>0) {\n            if (good[u]) dp[tt] = max(dp[tt],dp[tt^u] + 1);\n            u = (u-1)&tt;\n        }\n    }\n    cout<<res+nn-dp[mask];\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n;\nvector<pair<int,int> > g[N];\nvector<int> sons[N];\nint val[N];\nint used[N];\n\nvoid dfs(int v){\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i].first;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tint cost=g[v][i].second;\n\t\tsons[v].push_back(to);\n\t\tval[to]=val[v];\n\t\tval[to]^=cost;\n\t\tdfs(to);\n\t}\n\n\tfor (int i=0;i<sons[v].size();i++){\n\t\tint to=sons[v][i];\n\t\tval[v]^=val[to];\n\t}\n}\n\nint ans;\nint cnt[N];\nint pcount[N];\nint dp[N];\nint mem_xor[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(make_pair(b,c));\n\t\tg[b].push_back(make_pair(a,c));\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tpcount[i]=pcount[i/2]+i%2;\n\t}\n\n\tfor (int mask=0;mask<(1<<16);mask++){\n\t\tint here=0;\n\t\tfor (int i=0;i<16;i++){\n\t\t\tif (mask&(1<<i))\n\t\t\t\there^=i;\n\t\t}\n\t\tmem_xor[mask]=here;\n\t}\n\n\tdfs(0);\n\n\tfor (int i=1;i<n;i++){\n//\t\tcout<<val[i]<<endl;\n\t\tcnt[val[i]]++;\n\t}\n\n\tfor (int i=0;i<16;i++){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\n\tdp[0]=0;\n\n\tfor (int mask=1;mask<(1<<16);mask++){\n\t\tint smask=mask;\n\t\tdp[mask]=1e9;\n\t\twhile (true){\n\t\t\tif (smask==0)\n\t\t\t\tbreak;\n\t\t\tint here=pcount[smask];\n\t\t\tint is_good=mem_xor[smask];\n\t\t\tif (is_good==0)\n\t\t\t\there--;\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+here);\n\t\t\tsmask=(smask-1);\n\t\t\tsmask&=mask;\n\t\t}\n\t}\n\n\tint interesting=0;\n\tfor (int i=0;i<16;i++){\n\t\tif (cnt[i])\n\t\t\tinteresting|=(1<<i);\n\t}\n\tcout<<ans+dp[interesting]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    //cout<<b<<\":\"<<dp[b]<<endl;\n    for(Int i=0;i<16;i++){      \n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\t//cout<<i<<\"@\"<<j<<endl;\n\tif(i&j){\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^(i&j));\n\t  fix(j^(i&j));\n\t  //if(calc(nb)>=calc(b)) continue;\n\t  assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" ::: \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n\tif(1){\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^j);\n\t  fix(0);\n\t  //if(calc(nb)>=calc(b)) continue;\n\t  assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" *** \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n      }\n    }\n  }\n  \n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     âââââââââââ\n//                                                                   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                                                                ââââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬âââ\n//                                            âââââââââââ       âââ¬â¬â¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬ââ\n//                                      ââââââââââ¬â¬â¬â¬â¬âââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬ââ\n//                               âââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬ââ\n//                             âââââ¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//                           ââââ¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬ââââ¬â¬â¬â¬â¬â¬â¬âââââ\n//                         ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââââââââ¬â¬â¬â¬â¬ââ\n//                       ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                     ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬ââ\n//                 âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬ââââ\n//     ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬ââââââ\n//   âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬ââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââ¬â¬â¬ââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬ââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââââ¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬â¬â¬âââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬âââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââ\n//   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//       ââââââââââââââ  âââââ¬â¬â¬â¬â¬â¬ââââââââââââââââââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ\n//                         âââââââ                           âââââ  âââââââââââââââââââ  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n,0);\n  REP(_,n-1){\n    int x,y,v;\n    cin >> x >> y >> v;\n    a[x] ^= v;\n    a[y] ^= v;\n  }\n  \n  vec b(16,0);\n  REP(i,n) b[a[i]]++;\n\n  int ans = 0;\n  REP(i,16){\n    if(i) ans += b[i]/2;\n  }\n\n  vec dp(1<<15,-INF); dp[0] = 0;\n  int mask = 0;\n  REP(i,15) if(b[i+1]&1) mask += (1<<i);\n\n  REP(i,1<<15){\n    int x = ((1<<15)-1) & (~i), y = x;\n    assert(i+x==(1<<15)-1);\n    for(;;x--){\n      x &= y; int cnt = 0;\n      if(!x) break;\n      REP(k,15) if(parity(x,k)) cnt ^= k+1;\n      if(!cnt) chmax(dp[i+x],dp[i]+1); \n    }\n  }\n\n  cout << ans - dp[mask] + pcnt(mask) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#define ll long long\n#define maxn 100005\n#define ll long long\n#define re(i,a,b) for(int i=a;i<=b;i++)\n#define for_edge(x) for(int i=head[x];i;i=e[i].nxt)\nusing namespace std;\ninline int read(){char c=getchar();int f=1;int ans = 0;while(c>'9'||c<'0'){if(c=='-')f=-f;c=getchar();}while(c<='9'&&c>='0'){ans =ans*10+c-'0';c=getchar();}return ans*f;}\n//______________________________________________________________________________________\nint n;\nint v[maxn]; \nint cnt[16];\nbool bo[1<<15];\nint dp[1<<15];\nint main()\n{\n\t//freopen(\"0.in\",\"r\",stdin);\n\tn = read();\n\tre(i,1,n-1)\n\t{\n\t\tint x = read() ,y =read(), k=read();\n\t\tv[x] ^=k; v[y] ^= k;\n\t}\n\tre(i,0,n-1)\t\n\t\tcnt[ v[i] ]++;\n\tll ans = 0,s=0;;\n\tre(i,1,15)\n\t{\n\t\tans += cnt[i] /2 ;\n\t\t//printf(\"%d \",cnt[i]);\n\t\ts|=(cnt[i]&1)<<i-1;\n\t}\n\t//printf(\"%\\d\",s);\n\tre(i,0,(1<<15)-1)\n\t{\n\t\tint sum = 0;\n\t\tre(j,1,15)\n\t\t\tif((i>>j-1)&1)\n\t\t\t\tsum^=j;\n\t\tif(!sum) bo[i] = 1;\n\t}\n\tre(i,1,(1<<15)-1)\n\t\tif(bo[i])\n\t\t{\n\t\t\t\n\t\t\tfor(int j=i;j;j-=j&-j,dp[i]++);dp[i]--;\n\t\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\t\tif(bo[j])\n\t\t\t\t\tdp[i] = min( dp[i] , dp[j] + dp[j^i] );\n\t\t\t//for(int j=15;j;j--) \n\t\t\t//printf(\"%d\",(i>>j-1)&1);printf(\" %d\\n\",dp[i]);\n\t\t}\n\tprintf(\"%\\d\",ans+dp[s]);\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\n#ifdef DEBUG\nstruct Timestamper {\n  string msg;\n  clock_t start;\n\n  Timestamper(const string &_msg) : msg(_msg), start(clock()) {}\n  ~Timestamper() {\n    eprintf(\"[ %s ] Time=%.3lfs\\n\", msg.c_str(), (clock() - start) * 1.0 / CLOCKS_PER_SEC);\n  }\n} __timestamper(\"end\");\n#else\nstruct Timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nconst int inf = 1e9;\n\nint solve(int msk) {\n  vi ts;\n  forn (i, 16) if (msk & (1 << i)) ts.pb(i);\n  int r = 0;\n  forn (x, 4) {\n    if (r >= sz(ts)) break;\n    for (int i = r; i < sz(ts); i++) \n      if (ts[i] & (1 << x)) {\n        swap(ts[r], ts[i]);\n        break;\n      }\n    if (!(ts[r] & (1 << x))) continue;\n    for (int i = r + 1; i < sz(ts); i++)\n      if (ts[i] & (1 << x))\n        ts[i] ^= ts[r];\n    r++;\n  }\n  eprintf(\"r=%d\\n\", r);\n  return r;\n}\n\nvector<vector<pii>> es;\nvi cnts;\n\nvoid dfs(int v, int par = -1) {\n  int tails = 0;\n  for (pii e : es[v])\n    if (e.first == par) {\n      tails ^= e.second;\n    } else {\n      dfs(e.first, v);\n      tails ^= e.second;\n    }\n//  eprintf(\"v=%d, tails=%d\\n\", v, tails);\n  cnts[tails]++;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    es = vector<vector<pii>>(n);\n    forn (i, n - 1) {\n      int a, b, w;\n      scanf(\"%d%d%d\", &a, &b, &w);\n      es[a].eb(b, w);\n      es[b].eb(a, w);\n    }\n    cnts = vi(16, 0);\n    dfs(0);\n    cnts[0] = 0;\n    eprintf(\"cnts:\\n\");\n//    forn (i, 16)\n//      eprintf(\"  [%d]=%d\\n\", i, cnts[i]);\n    int ans = 0;\n    int msk = 0;\n    forn (i, 16) {\n      ans += cnts[i] / 2;\n      if (cnts[i] & 1) {\n        msk |= 1 << i;\n      }\n    }\n    eprintf(\"preans=%d\\n\", ans);\n    ans += solve(msk);\n    printf(\"%d\\n\", ans);\n    eprintf(\"=====\\n\");\n    fflush(stdout);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<int> v(n,0);\n\tREP(i,n-1)\n\t{\n\t\tint a,b,c;cin >> a >> b >> c;\n\t\tv[a] ^= c;\n\t\tv[b] ^= c;\n\t}\n\tvector<int> cou(16,0);\n\tll ans = 0;\n\t\n\tREP(i,n)\n\t{\n\t\tcou[v[i]]++;\n\t}\n\t\n\tfor(int i = 1;i < 16;i++)\n\t{\n\t\tans += cou[i] / 2;\n\t\tcou[i] %= 2;\n\t}\n\t\n\tint mask = 0;\n\tREP(i,16)\n\t{\n\t\tif(cou[i] == 1)\n\t\t{\n\t\t\tmask += (1<<i);\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tvector<int> dat(1<<16,0);\n\t\n\tREP(i,1<<16)\n\t{\n\t\tREP(j,16)\n\t\t{\n\t\t\tif(i & 1 << j)dat[i] ^= j;\n\t\t}\n\t}\n\t\n\tvector<int> dp(1<<16,0);\n\t\n\tREP(i,1<<16)\n\t{\n\t\tint u = i;\n\t\twhile(u > 0)\n\t\t{\n\t\t\tif(dat[u] == 0)\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i],dp[i^u]+1);\n\t\t\t}\n\t\t\tu = (u-1) & i;\n\t\t}\n\t}\n\t\n\tcout << ans - dp[mask] << endl;\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=100000 +10, oo= 1<<29;\n\nint b[MAXN], n,m, f[MAXN], cnt[17];\nbool vis[MAXN];\n\nint DP(int s);\n\nint main(){\n//\tfreopen(\"input.txt\",\"rt\",stdin);\n//\tfreopen(\"output.txt\",\"wt\",stdout);\n\tscanf(\"%d\", &n );\n\tfor (int i=1, u,v,a; i<n; i++){\n\t\tscanf(\"%d%d%d\", &u, &v, &a);\n\t\tb[u] ^= a;\n\t\tb[v] ^= a;\n\t}\n\tfor (int i=0; i<n; i++) cnt[b[i]]++;\n\tint ans=0, inista=0;\n\tfor(int i=1; i<16; i++){\n\t\t\t\n\t\tans += cnt[i]/ 2;\n\t\tcnt[i] %= 2;\n\t\tinista |= cnt[i]*(1<<i);\n\t\t#ifdef che\n\t\tif ( cnt[i]) debug(\"cnt[%d] = %d\\n\", i, cnt[i]);\n\t\t#endif\n\t}\n\t#ifdef che\n\tdebug(\"same contrad ans= %d\\tinitial state =%d\\n\", ans,inista);\n\t#endif\n\tans += DP(inista);\n\tprintf(\"%d\\n\" , ans);\n\treturn 0;\n}\n\nint DP(int s){\n\tif ( s==0) return 0;\n\tif ( vis[s]) return f[s];\n\tvis[s]= true; f[s] = oo;\n\tfor (int i=0; i<16; i++)\n\t\tfor (int j=i+1; j<16 ;j++)\n\t\t\tif ( s&(1<<i) && s&(1<<j) ){\n\t\t\t\tint rst= s^(1<<i)^(1<<j), nw= 1<<(i^j);\n\t\t\t\tif ( rst&nw) f[s]= min( f[s], DP(rst^nw)+2);\n\t\t\t\t\telse f[s]= min(f[s], DP(rst^nw)+1);\n\t\t\t}\n\t\n\treturn f[s];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int inf=10101010;\nstruct Edge{\n\tint to,next,val;\n}e[202020];\nint head[101010],cnt=0;\nvoid add(int u,int v,int w)\n{\n\tcnt++;\n\te[cnt].to=v;\n\te[cnt].next=head[u];\n\te[cnt].val=w;\n\thead[u]=cnt;\n}\nint cal[22];\nint dfs(int x,int fa)\n{\n\tint ret=0;\n\tfor(int i=head[x];i!=0;i=e[i].next)\n\t{\n\t\tint to=e[i].to;\n\t\tif(to!=fa)\n\t\t{\n\t\t\tint tmp=dfs(to,x);\n\t\t\tcal[e[i].val^tmp]++;\n\t\t\tret^=tmp;\n\t\t}\n\t}\n\treturn ret;\n}\nint dp[1010101],p[33];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tu++;\n\t\tv++;\n\t\tadd(u,v,w);\n\t\tadd(v,u,w);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cal[i]/2;\n\t\tcal[i]%=2;\n\t}\n\tint nn=0;\n\tfor(int i=1;i<=15;i++)\n\tif(cal[i]==1)\n\t{\n\t\tnn++;\n\t\tp[nn]=i;\n\t}\n\tfor(int i=0;i<(1<<nn);i++)\n\t\tdp[i]=inf;\n\tdp[0]=0;\n\tfor(int i=0;i<(1<<nn);i++)\n\t{\n\t\tint tmp=0;\n\t\tfor(int j=1;j<=nn;j++)\n\t\tif((i&(1<<(j-1)))!=0)\n\t\t\ttmp^=p[j];\n\t\tfor(int j=1;j<=nn;j++)\n\t\tif((i&(1<<(j-1)))==0)\n\t\t{\n\t\t\tif((tmp^p[j])==0)\n\t\t\t\tdp[(i|(1<<(j-1)))]=min(dp[(i|(1<<(j-1)))],dp[i]);\n\t\t\telse\n\t\t\t\tdp[(i|(1<<(j-1)))]=min(dp[(i|(1<<(j-1)))],dp[i]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+dp[(1<<nn)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int maxn(2e5 + 10);\nint n, val[maxn], f[maxn], cnt[20], ans, S, sum[maxn];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, a, b, c; i < n; i++)\n\t\tscanf(\"%d%d%d\", &a, &b, &c), val[a] ^= c, val[b] ^= c;\n\tfor (int i = 0; i < n; i++) ++cnt[val[i]];\n\tfor (int i = 1; i <= 15; i++) ans += (cnt[i] >> 1), S |= (cnt[i] & 1) << (i - 1);\n\tfor (int i = 1; i < (1 << 15); i++) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); i++) --f[i];\n\tfor (int i = 1; i < (1 << 15); i++)\n\t\tfor (int j = 0; j < 15; j++) if (i & (1 << j)) sum[i] ^= (j + 1);\n\tfor (int i = 1; i < (1 << 15); i++) if (!sum[i])\n\t\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\t\tif (!sum[j]) f[i] = std::min(f[i], f[j] + f[i ^ j]);\n\tprintf(\"%d\\n\", ans + f[S]);\n\treturn 0;\n}\n//"
  },
  {
    "language": "C++",
    "code": "/****** BISMILLAH HIR RAHMANIR RAHIM ******/\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<string,string> mss;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef map <int, vector<string> > mvis;\ntypedef map <string, vector<int> > mvsi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define INF 2000000000\n#define pb push_back\n#define MAX 100002\n#define debug cout<<\"A\"<<\"\\n\"\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=b; i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define ClearQ(x); while(!x.empty()) x.pop()\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n, u, v, k, d[MAX], cnt[20];\nvi rest;\nint dp[1<<17];\n\nint go(int mask)\n{\n\t// prnt(mask);\n\tif(mask&1) mask^=1;\n\tif(mask==0) return 0;\n\tif(dp[mask]!=-1) return dp[mask];\n\n\tint ret=1e3;\n\n\tfor(int i=1; i<=16; i++)\n\t{\n\t\tfor(int j=1; j<=16; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif((mask&(1<<i)) && (mask&(1<<j)))\n\t\t\t{\n\t\t\t\tint nxtmask=mask^(1<<i);\n\t\t\t\tnxtmask^=(1<<j);\n\n\t\t\t\tint add=1;\n\n\t\t\t\tif(mask&(1<<(i^j)))\n\t\t\t\t{\n\t\t\t\t\tnxtmask^=(1<<(i^j));\n\t\t\t\t\tadd++;\n\t\t\t\t}\n\n\t\t\t\tret=min(ret,add+go(nxtmask));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[mask]=ret;\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    scanf(\"%d\", &n);\n\n    FOR(i,0,n-1)\n    {\n    \tscanf(\"%d%d%d\", &u, &v, &k);\n\n    \td[u]^=k;\n    \td[v]^=k;\n    }\n\n    FOR(i,0,n)\n    {\n    \tif(d[i]) \n    \t{\n    \t\t// prnt(d[i]);\n    \t\tcnt[d[i]]++;\n    \t}\n    }\n\n    int ans=0, mask=0;\n\n    FOR(i,1,17)\n    {\n    \tans+=cnt[i]/2;\n    \tif(cnt[i]%2) rest.pb(i), mask|=(1<<i);\n    }\n\n    // debug;\n    // VecPrnt(rest);\n    // prnt(mask);\n\n    // prnt(ans);\n    ms(dp,-1);\n    prnt(ans+go(mask));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>bin[20];\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[20]={0},f[(1<<20)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint s=0,res=0,t=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tres+=v[i]/2,v[i]%=2;\n\t\tif(v[i]){\n\t\t\ts|=(1<<(i-1));\n\t\t\tt++;\n\t\t}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=14;j++)\n\t\t\tif(i&(1<<j))cnt++;\n\t\tbin[cnt].push_back(i);\n\t}\n\tfor(int p=2;p<=t;p++)\n\t\tfor(int k=0;k<bin[p].size();k++){\n\t\t\tint i=bin[p][k];\n\t\t\tfor(int u=1;u<=15;u++)\n\t\t\tif(i&(1<<(u-1)))\n\t\t\tfor(int v=1;v<=15;v++)\n\t\t\t\tif((i&(1<<(v-1)))&&(u!=v)){\n\t\t\t\t\tint w=u^v; \n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<(w-1))-(1<<(u-1))-(1<<(v-1))]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<(u-1))-(1<<(v-1))+(1<<(w-1))]+1);\n\t\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define chmax(a,b) if(a<b)a=b\nconst int N=1e5+5;\nconst int M=16;\n\nint n,ans;\nint a[N],cnt[M];\nbool ok[1<<M];\nint dp[1<<M];\n\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[a[i]]++;\n\tint mask=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]>>1;\n\t\tif(cnt[i]&1) mask|=1<<i;\n\t}\n\tfor(int i=0;i<=mask;i+=2)\n\t{\n\t\tint X=0;\n\t\tfor(int j=1;j<=15;j++)\n\t\t\tif((i>>j)&1) X^=j;\n\t\tif(!X) ok[i]=1;\n\t}\n\tfor(int i=0;i<=mask;i+=2)\n\tfor(int j=i;j;j=(j-1)&i)\n\t\tif(ok[j]) chmax(dp[i],dp[i-j]+1);\n\tprintf(\"%d\\n\",ans+__builtin_popcount(mask)-dp[mask]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=200010,M=20,Inf=2e9;\nint n,a[N],cnt[M],ans,f[1<<M];\nvoid chkmin(int &x,int y){x=min(x,y);}\nint main(){\n\tn=gi();\n\tfor(int i=1;i<n;i++){\n\t\tint u=gi()+1,v=gi()+1,w=gi();\n\t\ta[u]^=w;a[v]^=w;\n\t}\n\tint now=0;\n\tfor(int i=1;i<=n;i++)cnt[a[i]]++;\n\tfor(int i=1;i<=15;i++){ans+=cnt[i]/2;cnt[i]&=1;now+=cnt[i]<<(i-1);}\n\tmemset(f,127,sizeof(f));f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<Inf)\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k){\n\t\t\t\t\t\t\tint x=j^k;\n\t\t\t\t\t\t\tif(i&(1<<x-1))chkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<x-1)],f[i]+2);\n\t\t\t\t\t\t\telse chkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<x-1)],f[i]+1);\n\t\t\t\t\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<> a(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, x; cin >> u >> v >> x;\n    a[u] ^= x;\n    a[v] ^= x;\n  }\n  V<> c(16);\n  for (int i = 0; i < n; ++i) {\n    ++c[a[i]];\n  }\n  c[0] = 0;\n  int res = 0;\n  for (int i = 0; i < 16; ++i) {\n    res += c[i] >> 1;\n    c[i] &= 1;\n  }\n  while (accumulate(begin(c), end(c), 0)) {\n    int k = count_if(begin(c), end(c), [](int x) { return x; });\n    if (k < 3) {\n      assert(k == 2);\n      ++res;\n      break;\n    }\n    [&] {\n      for (int i = 0; i < 16; ++i) if (c[i]) {\n        for (int j = i + 1; j < 16; ++j) if (c[j]) {\n          if (c[i ^ j]) {\n            c[i] = c[j] = c[i ^ j] = 0;\n            res += 2;\n            return;\n          }\n        }\n      }\n      for (int i = 0; i < 16; ++i) if (c[i]) {\n        for (int j = i + 1; j < 16; ++j) if (c[j]) {\n          c[i] = c[j] = 0;\n          ++c[i ^ j];\n          ++res;\n          return;\n        }\n      }\n    }();\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl;\n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define SUB(s,s0) for (REG int s=s0;s;s=(s-1)&s0)\n\n#define MAXN 210000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\nint n;\nint s;\nint dp[10000000];\nint node[MAXN];\nint count(int cur)\n{\n\tint ans=0;\n\tRPT(i,0,16)\n\t\tif (cur & (1<<i))\n\t\t\tans++;\n\treturn ans;\n}\n\nint xo(int cur)\n{\n\tint ans=0;\n\tRPT(i,0,16)\n\t\tif (cur & (1<<i))\n\t\t\tans^=(i+1);\n\treturn ans;\n}\n\nint dfs(int cur)\n{\n\t//WRT(cur);\n\tif (dp[cur]!=0)\n\t\treturn dp[cur];\n\tdp[cur]=count(cur)-1;\n\tif (dp[cur]==-1)\n\t{\n\t\tdp[cur]=0;\n\t\treturn 0;\n\t}\n\tSUB(s,cur)\n\t\tif (xo(s)==0 && s!=cur)\n\t\t{\n\t\t\t//cout<<s<<' '<<xo(s)<<endl;\n\t\t\tdp[cur]=min(dp[cur],dfs(s)+dfs(cur^s));\n\t\t}\n\treturn dp[cur];\n}\n\nLL ans;\nint main()\n{\n\tcin>>n;\n\tint x,y,z;\n\tRPT(i,0,n-1)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tnode[x]^=z;\n\t\tnode[y]^=z;\n\t}\n\tRPT(i,0,n)\n\t{\n\t\t//WRT(x);\n\t\tx=node[i];\n\t\tif (x==0)\n\t\t\tcontinue;\n\t\tif ((s&(1<<(x-1)))!=0)\n\t\t\tans++;\n\t\ts^=(1<<(x-1));\n\t}\n\t//WRT(ans);\n\t//WRT(s);\n\t//WRT(xo(s));\n\tcout<<ans+dfs(s);\n\treturn ~~(0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 65540\nusing namespace std;\nint n,s[N],S,ans,f[M],inf,sum[20];\n\nint dfs(int S)\n{\n  if(!S)return 0; \n  if(f[S]<inf)return f[S];\n  for(int i=0;i<16;i++)if((S>>i)&1)\n    for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1)\n    {\n      int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n      if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n      else f[S]=min(f[S],dfs(x)+1);\n      //æä¸¾æ¯æ¬¡å¼æçä¸¤ä¸ªèç¹i,j,iå¼ææj,jå¼ææj,è¿å©ä¸p=i^j\n      //å¦æpæ¬èº«å­å¨é£ä¸¤ä¸ªpç´æ¥æ¶æ \n    }\n  return f[S];\n}\n\nint main()\n{\n  int a,b,c;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d%d\",&a,&b,&c),s[a]^=c,s[b]^=c;\n  for(int i=0;i<n;i++)sum[s[i]]++;\n  for(int i=1;i<16;i++)\n    ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n  memset(f,127,sizeof(f));inf=f[0];\n  printf(\"%d\\n\",ans+dfs(S));\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F(i, s, t) for (int i = (s), _ = (t); i <= _; i ++)\nint rd() {\n\tint x = 0; char c;\n\tdo { c = getchar(); } while (!isdigit(c));\n\tdo { x = x*10+c-'0', c = getchar(); } while (isdigit(c));\n\treturn x;\n}\nconst int N = 100005;\nint n;\nstruct Edge {\n\tint v, a, nx;\n}mp[N << 1];\nint tot, hd[N];\nint a[N], cnt;\nvoid Dp(int x, int par) {\n\tfor (int k = hd[x]; k; k = mp[k].nx) {\n\t\tint v = mp[k].v;\n\t\tif (v != par) {\n\t\t\ta[x] ^= mp[k].a;\n\t\t\ta[v] ^= mp[k].a;\n\t\t\tDp(v, x);\n\t\t}\n\t}\n}\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"f.in\", \"r\", stdin);\n\t#endif\n\tn = rd();\n\tF(i, 1, n-1) {\n\t\tint x = rd(), y = rd(), a = rd();\n\t\tx ++, y ++;\n\t\tmp[++ tot] = (Edge){y, a, hd[x]}, hd[x] = tot;\n\t\tmp[++ tot] = (Edge){x, a, hd[y]}, hd[y] = tot;\n\t}\n\tDp(1, 0);\n\tF(i, 1, n) cnt += (a[i] > 0);\n\tcout << (cnt + 1 >> 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        A[u]^=A[to.fi];\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=i+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=i+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200010\nint n,va[N],c[N],ans,s,f[N],ss[N],nm[N];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<N;i++)\n\t\tnm[i]=nm[i-(i&-i)]+1;\n\tfor(int i=1;i<N;i++)nm[i]--;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tva[x]^=z;\n\t\tva[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[va[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]%2==1)s|=(1<<(i-1));\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))ss[i]^=(j+1);\n\tfor(int i=1;i<(1<<15);i++)\n\t\tif(!ss[i])\n\t\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\t\tif(!ss[j]&&!ss[i-j])\n\t\t\t\t\tnm[i]=min(nm[i],nm[i-j]+nm[j]);\n\tcout<<ans+nm[s];\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5 + 2, M = 16;\n\nint A[N], C[M], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 1; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 1; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tfor (int i = 0; i < n; i++) C[A[i]]++;\n\tint x = 0, cnt = C[0];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcnt += C[i] >> 1;\n\t\tif (C[i] & 1) x ^= (1 << (i - 1));\n\t}\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=100005;\nconst int p=1e9+7;\nint n,a[N];\nint tot[16];\n\ntemplate<class T> void read(T &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nvoid Add(int &x,int y){\n\tx+=y;\n\twhile(x>=p) x-=p;\n}\n\nint f[1<<16],sum[1<<16];\nint main(){\n\tread(n);\n\tint x,y,w;\n\tfr(i,2,n){\n\t\tread(x);read(y);read(w);\n\t\ta[x]^=w;a[y]^=w;\n\t}\n\tfr(i,1,n) tot[a[i]]++;\n\tint ans=0,all=0;\n\tfr(i,1,15) ans+=tot[i]/2,all^=(tot[i]&1)<<i;\n\tfr(i,0,all)\n\t if ((i&all)==i){\n\t \tif ((i&(-i))==i){ f[i]=1;continue; }\n\t \tsum[i]=0;\n\t \tfr(j,0,15) if (i&(1<<j)) sum[i]^=j,f[i]++;\n\t \tif (sum[i]) continue;\n\t \tf[i]--;\n\t \tfor(int j=i;j;j=(j-1)&i)\n\t \t if (sum[j]==0) f[i]=min(f[i],f[j]+f[i^j]);\n\t }\n\tcout<<ans+f[all]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 1e5 + 20;\n\nint t[maxn];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b , c;\n\t\tcin >> a >> b >> c;\n\n\t\tt[a] ^= c;\n\t\tt[b] ^= c;\n\t}\n\n\tvector<pair<int , int> > shit;\n\n\tfor(int mask = 1; mask < 16; mask++)\n\t\tshit.pb({__builtin_popcount(mask) , mask});\n\n\tsort(shit.begin() , shit.end());\n\treverse(shit.begin() , shit.end());\n\n\tint res = 0;\n\tfor(auto ind : shit)\n\t{\n\t\tint mask = ind.second;\n\t\tint last = -1;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif((mask&t[i]) == mask)\n\t\t\t{\n\t\t\t\tif(last == -1)\n\t\t\t\t\tlast = i;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tres++;\n\t\t\t\t\tt[last] ^= mask;\n\t\t\t\t\tt[i] ^= mask;\n\t\t\t\t\tlast = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tvvp G(n);\n\trep(i,n-1){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tG[a].pb({b,c});\n\t\tG[b].pb({a,c});\n\t}\n\tmap<int,int>ma;\n\trep(i,n){\n\t\tint x=0;\n\t\trep(j,G[i].size())x^=G[i][j].second;\n\t\tif(x)ma[x]++;\n\t}\n\tint m=0,out=0;\n\tFOR(a,ma){\n\t\tout+=a.second/2;\n\t\tif(a.second%2)m+=1<<a.first;\n\t}\n\tm/=2;\n\tvi dp(1<<15,-inf);\n\tdp[0]=0;\n\trep(i,1<<15){\n\t\trep(j,15)if((i&1<<j)==0)cmax(dp[i|1<<j],dp[i]);\n\t\tint t=1<<15;\n\t\tt-=1+i;\n\t\tfor(int j=t;j>0;j=(j-1)&t){\n\t\t\tint x=0,c=0;\n\t\t\trep(k,15)if(j&1<<k)x^=1+k,c++;\n\t\t\tif(x)continue;\n\t\t\tcmax(dp[i|j],dp[i]+c-1);\n\t\t}\n\t}\n\tcout<<out+dp[m]<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nvector<vector<pair<LL, LL>>> edge(100000);\nvector<LL> a(100000, -1);\nvector<LL> parent(100000, -1);\nvector<vector<LL>> children(100000);\nvector<int> nodexor(100000, 0);\n\nvoid make_graph(LL start, LL weight) {\n\ta[start] = weight;\n\tREP(i, edge[start].size()) {\n\t\tif (a[edge[start][i].first] == -1) {\n\t\t\tparent[edge[start][i].first] = start;\n\t\t\tchildren[start].push_back(edge[start][i].first);\n\t\t\tmake_graph(edge[start][i].first, edge[start][i].second);\n\t\t}\n\t}\n}\n\nint find_ans(LL start) {\n\tint xor_sum = a[start];\n\tREP(i, children[start].size()) {\n\t\tint xor_num = find_ans(children[start][i]);\n\t\txor_sum = xor_sum ^ xor_num;\n\t}\n\tnodexor[start] = xor_sum & 15;\n\treturn nodexor[start];\n}\n\nint main() {\n\tLL N;\n\tcin >> N;\n\n\tREP(i, N - 1) {\n\t\tLL x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tedge[x].push_back(make_pair(y, a));\n\t\tedge[y].push_back(make_pair(x, a));\n\t}\n\n\tmake_graph(0, -2);\n\n\tfind_ans(0);\n\n\t/*\n\tvector<LL> num(4, 0);\n\tFOR(i,1, nodexor.size()) {\n\tnum[0] += (nodexor[i] & 1) / 1;\n\tnum[1] += (nodexor[i] & 2) / 2;\n\tnum[2] += (nodexor[i] & 4) / 4;\n\tnum[3] += (nodexor[i] & 8) / 8;\n\t}\n\n\tLL sum = 0;\n\tREP(i, num.size()) {\n\tsum += (num[i] + 1) / 2;\n\t}\n\n\tcout << sum << endl;\n\n\tvector<LL> num(16, 0);\n\tFOR(i, 1, nodexor.size()) {\n\t\tFOR(j, 1, num.size()) {\n\t\t\tnum[j] += (nodexor[i] & j) / j;\n\t\t}\n\t}\n\n\tLL sum = 0;\n\tsum += (num[1] + 1) / 2;\n\tsum += (num[2] + 1) / 2;\n\tsum += (num[4] + 1) / 2;\n\tsum += (num[8] + 1) / 2;\n\n\tsum -= (num[3]) / 2;\n\tsum -= (num[5]) / 2;\n\tsum -= (num[6]) / 2;\n\tsum -= (num[9]) / 2;\n\tsum -= (num[10]) / 2;\n\tsum -= (num[12]) / 2;\n\n\tsum += (num[7]) / 2;\n\tsum += (num[11]) / 2;\n\tsum += (num[13]) / 2;\n\tsum += (num[14]) / 2;\n\n\tsum -= (num[15]) / 2;\n\n\tcout << sum << endl;\n\t*/\n\n\tvector<LL> num(16, 0);\n\tqueue<LL> num1;\n\tvector<LL> numed(16, 0);\n\tFOR(i, 1, nodexor.size()) {\n\t\tnum[nodexor[i]&15] ++;\n\t}\n\n\tLL sum = 0;\n\n\tFOR(i, 1, num.size()) {\n\t\tif (num[i] % 2 == 0) {\n\t\t\tsum += num[i] / 2;\n\t\t\tnum[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tsum += num[i] / 2;\n\t\t\tnum[i] = 1;\n\t\t\tnum1.push(i);\n\t\t}\n\t}\n\n\twhile (num1.size()>=1) {\n\t\tif (num1.size() == 1) {\n\t\t\tif (num1.front() == 0) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tLL a = num1.front();\n\t\tnum1.pop();\n\t\tLL b = num1.front();\n\t\tnum1.pop();\n\t\tif (numed[a] >= 1) {\n\t\t\tnumed[a] --;\n\t\t\ta = 0;\n\t\t}\n\t\tif (numed[b] >= 1) {\n\t\t\tnumed[b] --;\n\t\t\tb = 0;\n\t\t}\n\t\tif (a != 0 && b != 0) {\n\t\t\tnum[a]--;\n\t\t\tnum[b]--;\n\t\t\tnum[a^b]++;\n\t\t\tsum++;\n\t\t\tnum1.push(a^b);\n\t\t}\n\t\tFOR(i, 1, num.size()) {\n\t\t\tif (num[i] % 2 == 0) {\n\t\t\t\tnum[i] = 0;\n\t\t\t\tnumed[i] +=2;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int N = 100005;\n\nint n, up[N], ans;\nbool can[16];\n\nvector<int> d[N], tmp;\nvector<pii> adj[N];\n\nbool elim (vector<int> &V, int X, int I = 0) {\n\tif(I == (int)V.size()) {\n\t\tif(!X) {\n\t\t\ttmp.clear();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tif(elim(V, X^V[I], I+1)) return true;\n\tif(elim(V, X, I+1)) {\n\t\ttmp.push_back(V[I]);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid calc (int C, int P) {\n\tint X = 0;\n\tfor(auto &T : adj[C]) {\n\t\tint A, B;\n\t\ttie(A, B) = T;\n\t\tif(A == P) continue;\n\t\tup[A] = B;\n\t\tcalc(A, C);\n\t\tfor(auto &T : d[A]) {\n\t\t\tX ^= T;\n\t\t\tif(elim(d[C], T)) {\n\t\t\t\tswap(tmp, d[C]);\n\t\t\t\tans--;\n\t\t\t}\n\t\t\telse d[C].push_back(T);\n\t\t}\n\t}\n\tif(C) {\n\t\tans++;\n\t\tif(elim(d[C], X^up[C])) {\n\t\t\tswap(tmp, d[C]);\n\t\t\tans--;\n\t\t}\n\t\telse d[C].push_back(X^up[C]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B, C;\n\t\tscanf(\"%d%d%d\",&A,&B,&C);\n\t\tadj[A].push_back({B, C});\n\t\tadj[B].push_back({A, C});\n\t}\n\tcalc(0, -1);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nvector<ll> dickstra(int from) {\n  const ll infl = 4e18;\n  const int n = 1 << 16;\n\n  vector<ll> dist(n, infl);\n  using Elem = pair<ll, int>;\n  priority_queue<Elem, vector<Elem>, greater<Elem>> o;\n  dist[from] = 0;\n  o.emplace(dist[from], from);\n  while (!o.empty()) {\n    int u;\n    ll cdist;\n    tie(cdist, u) = o.top();\n    o.pop();\n    //cerr << bitset<16>(u) << ' ' << cdist << '\\n';\n    if (cdist != dist[u])\n      continue;\n    for (int x = 0; x < 16; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        for (int z = 0; z < y; ++z) {\n          if (!(u & (1 << y)) || !(u & (1 << z))) {\n            continue;\n          }\n          int v = u ^ (1 << y) ^ (1 << z);\n          int yy = x ^ y, zz = x ^ z;\n          int w = 1;\n          if (v & (1 << yy)) {\n            ++w;\n          }\n          if (v & (1 << zz)) {\n            ++w;\n          }\n          v ^= (1 << yy) ^ (1 << zz);\n          if (v & 1) {\n            v ^= 1;\n          }\n          assert(v < n);\n\n          ll ndist = dist[u] + w;\n          if (ndist >= dist[v])\n            continue;\n          dist[v] = ndist;\n          o.emplace(dist[v], v);\n\n        }\n      }\n    }\n  }\n  return dist;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"f.in\", \"r\", stdin));\n#endif\n  int n;\n  cin >> n;\n  vector<int> xx(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    xx[u] ^= w;\n    xx[v] ^= w;\n  }\n  int mask = 0;\n  int res = 0;\n  for (int x : xx) {\n    if (mask & (1 << x)) {\n      ++res;\n    }\n    mask ^= 1 << x;\n  }\n  //cerr << bitset<16>(mask) << '\\n';\n  res += dickstra(mask)[0];\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn=1e5+10;\nconst int maxt=(1<<16)+10;\nint n,ans;\nint val[maxn],cnt[20],pos[20];\nint dp[2][maxt];\nvector<int> all;\ninline void update(int &a,int b)\n{\n\tif(b>a)a=b;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v,a;\n\t\tscanf(\"%d%d%d\",&u,&v,&a);\n\t\tval[u]^=a;\n\t\tval[v]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(val[i]==0)continue;\n\t\tcnt[val[i]]^=1;\n\t\tif(!cnt[val[i]])ans++;\n\t}\n\tmemset(pos,-1,sizeof(pos));\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tpos[i]=all.size();\n\t\t\tall.push_back(i);\n\t\t//\tcout<<i<<endl;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tint p=0,q=1;\n\tdp[p][0]=0;\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tmemset(dp[q],-1,sizeof(dp[q]));\n\t\tfor(int msk=0;msk<(1<<i);msk++)\n\t\t{\n\t\t\tif(dp[p][msk]==-1)continue;\n\t\t\tupdate(dp[q][msk|(1<<i)],dp[p][msk]);\n\t\t\tfor(int a=0;a<i;a++)if(msk>>a&1)\n\t\t\tfor(int b=a+1;b<i;b++)if(msk>>b&1)\n\t\t\t{\n\t\t\t\tif(all[a]^all[b]^all[i]==0)\n\t\t\t\t{\n\t\t\t\t\tupdate(dp[q][msk^(1<<a)^(1<<b)],dp[p][msk]+1);\n\t\t\t\t//\tcout<<\"2 \"<<a<<\" \"<<b<<\" \"<<i<<endl;\n\t\t\t\t}\n\t\t\t\tfor(int c=b+1;c<i;c++)if(msk>>c&1)\n\t\t\t\t{\n\t\t\t\t\tint t=all[a]^all[b]^all[c]^all[i];\n\t\t\t\t\tif(t==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate(dp[q][msk^(1<<a)^(1<<b)^(1<<c)],dp[p][msk]+1);\n\t\t\t\t\t//\tcout<<\"3 \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<i<<endl;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint d=pos[t];\n\t\t\t\t\t\tif(d!=-1&&d!=a&&d!=b&&d!=c&&(msk>>d&1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t//\tcout<<\"4 \"<<a<<' '<<b<<\" \"<<c<<\" \"<<d<<\" \"<<i<<endl;\n\t\t\t\t\t\t\tupdate(dp[q][msk^(1<<a)^(1<<b)^(1<<c)^(1<<d)],dp[p][msk]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(p,q);\n\t}\n\tint res=0;\n\tfor(int i=0;i<(1<<16);i++)update(res,dp[p][i]);\n//\tcout<<res<<\" \"<<ans<<endl;\n\tprintf(\"%d\\n\",ans-res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,ans;\nint f[100005];\nint v[16],cnt,dp[1<<15],x[1<<15];\n\nint main(){\n\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        f[a]^=c;\n        f[b]^=c;\n    }\n    for(int i=0;i<n;i++){\n        if(!f[i])ans++;\n        else v[f[i]]++;\n    }\n    for(int i=1;i<=15;i++){\n        ans+=v[i]>>1;\n        v[i]&=1;\n        if(v[i])v[cnt++]=i;\n    }\n    for(int s=0;s<1<<cnt;s++){\n        for(int i=0;i<cnt;i++){\n            if(s>>i&1)x[s]^=v[i];\n        }\n    }\n    for(int s=0;s<1<<cnt;s++){\n        int rs=s^((1<<cnt)-1);\n        for(int t=rs;t;t=(t-1)&rs){\n            if(!x[t])dp[s|t]=max(dp[s|t],dp[s]+1);\n        }\n    }\n    ans+=dp[(1<<cnt)-1];\n    cout<<n-ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct edge{\n\tint to,nxt,dis;\n}e[200101];\nint head[101010],tot,n;\ninline void made(int from,int to,ll dis){\n\te[++tot].to=to;e[tot].nxt=head[from];head[from]=tot;\n\te[tot].dis=dis;\n}\nint a[101010],b[100],f[201010],g[202020];\nvoid dfs(int u,int faa){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==faa) continue; \n\t\ta[u]^=e[i].dis,a[v]^=e[i].dis;\n\t\tdfs(v,u);\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tmade(x+1,y+1,z),made(y+1,x+1,z);\n\t}\n\tdfs(1,0); \n\tint all=0,ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]) b[a[i]-1]++,all^=(1<<(a[i]-1));\n\t}\n\tfor (int i=0;i<15;i++) ans+=b[i]/2,b[i]&=1;\n\tfor (int zt=1;zt<=all;zt++){\n\t\tbool flag=0;\n\t\tfor (int i=0;i<15;i++){\n\t\t\tif (((1<<i)&zt)&&(!b[i])){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t\telse if ((1<<i)&zt) g[zt]^=i+1;\n\t\t}\n\t\tif (!flag){\n\t\t\tf[zt]=__builtin_popcount(zt)-1;\n\t\t\tfor (int i=zt&(zt-1);i;i=zt&(i-1)){\n\t\t\t\tif (g[zt^i]*g[i]){\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[all]+ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint n;\nint basis[4], ori[4], a[N];\nbool vis[N];\nvector<pair<int, int>> g[N];\n\nvoid dfs(int u) {\n  vis[u] = true;\n  for (const auto& pr : g[u]) {\n    int v, w;\n    tie(v, w) = pr;\n    if (!vis[v]) {\n      a[v] = w;\n      a[u] ^= w;\n      dfs(v);\n    }\n  }\n}\n\nint ins(int x) {\n  int sv = x;\n  int res = 0;\n  for (int i = 0; i < 4; ++i)\n    if ((x >> i) & 1)\n      if (!basis[i]) {\n        basis[i] = x;\n        ori[i] = sv;\n        return -1;\n      } else {\n        x ^= basis[i];\n        res |= 1 << i;\n      }\n  return res;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int rep = 1; rep < n; ++rep) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    g[u].emplace_back(v, w);\n    g[v].emplace_back(u, w);\n  }\n  dfs(1);\n  int ans = n;\n  for (int i = 1; i <= n; ++i) {\n    int res = ins(a[i]);\n    if (res != -1) {\n      --ans;\n      vector<int> rest;\n      for (int i = 0; i < 4; ++i)\n        if (!((res >> i) & 1) && basis[i])\n          rest.push_back(ori[i]);\n      memset(basis, 0, sizeof(basis));\n      for (int v : rest)\n        ins(v);\n    }\n  }\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];\nstruct data{int v;int cf;};int sxr[N];int srt[N];\ninline bool cmp(int a,int b){return d[a]<d[b];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n\tfor(int i=0;i<n;i++){cnt[w[i]]++;}\n\tfor(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\t\n\tfor(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)d[i]-=1;\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n\tfor(int i=1;i<(1<<15);i++)srt[i]=i;sort(srt+1,srt+(1<<15));\n\tfor(int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sxr[srt[i]]!=0)continue;\n\t\tfor(int k=(srt[i]-1)&srt[i];k;k=(k-1)&srt[i])\n\t\t\tif(sxr[k]==0)d[srt[i]]=min(d[srt[i]],d[k]+d[srt[i]^k]);\n\t}printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Maxn = 100010;\nconst int inf = 0x7fffffff;\nint po[Maxn];\nint f[1<<14], bit[1<<14], n;\nvector <int> vec[20];\nvoid down(int &x, int y) { if(x > y) x = y; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; i++){\n\t\tint x, y, d;\n\t\tscanf(\"%d%d%d\", &x, &y, &d);\n\t\tpo[x] ^= d; po[y] ^= d;\n\t}\n\tfor(i = 1; i < 1<<14; i++){ bit[i] = bit[i>>1]+(i&1); vec[bit[i]].push_back(i); }\n\tint p = 0, ans = 0;\n\tfor(i = 0; i < 1<<14; i++) f[i] = inf;\n\tfor(i = 0; i < n; i++){\n\t\tif(!po[i]) continue;\n\t\tif(p&(1<<po[i]-1)) ans++;\n\t\tp ^= (1<<po[i]-1);\n\t}\n\tf[p] = 0;\n\tfor(i = 14; i >= 1; i--){\n\t\tfor(j = 0; j < vec[i].size(); j++){\n\t\t\tint x = vec[i][j];\n\t\t\tif(f[x] == inf) continue;\n\t\t\tfor(k = 0; k < 15; k++){\n\t\t\t\tif(x&(1<<k)){\n\t\t\t\t\tfor(int u = 0; u < 15; u++){\n\t\t\t\t\t\tif(k != u && x&(1<<u)){\n\t\t\t\t\t\t\tint t = (k+1)^(u+1);\n\t\t\t\t\t\t\tif(x&(1<<t-1)) down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+2);\n\t\t\t\t\t\t\telse down(f[x^(1<<k)^(1<<u)^(1<<(t-1))], f[x]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvi w(n);\n\trep(_,n-1){\n\t\tint x,y,a;cin>>x>>y>>a;\n\t\t//x--;y--;\n\t\tw[x]^=a;\n\t\tw[y]^=a;\n\t}\n\t\n\tconst int v=16;\n\tint cnt[v]{};\n\trep(i,n)cnt[w[i]]++;\n\t\n\tint ans=0;\n\tint has=0;\n\trng(i,1,v){\n\t\tans+=cnt[i]/2;\n\t\thas|=cnt[i]%2<<i;\n\t}\n\t\n\tvc<int> dp(1<<v);\n\t\n\trng(bit,1,1<<v){\n\t\trep(i,v)if(bit&1<<i)\n\t\t\tchmax(dp[bit],dp[bit^1<<i]);\n\t\tif((bit&has)==bit){\n\t\t\tint c=0;\n\t\t\trep(i,v)if(bit&1<<i)\n\t\t\t\tc^=i;\n\t\t\tif(c==0)dp[bit]++;\n\t\t}\n\t}\n\t\n\tcout<<ans+popcount(has)-dp[has]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int NMAX = 1e5;\nint n;\nint b[NMAX + 5];\nint dp[(1 << 15)];\n\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i = 1;i < n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tx++;\n\t\ty++;\n\t\tb[x] ^= z;\n\t\tb[y] ^= z;\n\t}\n\t\n\tint ans = n;\n\tint mask = 0;\n\t\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(b[i] == 0){\n\t\t\tans--;\n\t\t}\n\t\telse if((mask >> (b[i] - 1)) & 1){\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t\tans--;\n\t\t}\n\t\telse{\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t}\n\t}\n\t\t\n\tdp[0] = 0;\n\t\n\tfor(int i = 1;i <= mask;i++){\n\t\tfor(int j = i;j;j = (j - 1) & i){\n\t\t\tint xo = 0;\n\t\t\t\n\t\t\tfor(int b = 0;b < 15;b++){\n\t\t\t\tif((j >> b) & 1){\n\t\t\t\t\txo ^= b;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(xo == 0){\n\t\t\t\tdp[i] = max(dp[i],1 + dp[i ^ j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans -= dp[mask];\n\t\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nvector<vector<pair<LL, LL>>> edge(100000);\nvector<LL> a(100000, -1);\nvector<LL> parent(100000, -1);\nvector<vector<LL>> children(100000);\nvector<int> nodexor(100000, 0);\n\nvoid make_graph(LL start, LL weight) {\n\ta[start] = weight;\n\tREP(i, edge[start].size()) {\n\t\tif (a[edge[start][i].first] == -1) {\n\t\t\tparent[edge[start][i].first] = start;\n\t\t\tchildren[start].push_back(edge[start][i].first);\n\t\t\tmake_graph(edge[start][i].first, edge[start][i].second);\n\t\t}\n\t}\n}\n\nint find_ans(LL start) {\n\tint xor_sum = a[start];\n\tREP(i, children[start].size()) {\n\t\tint xor_num = find_ans(children[start][i]);\n\t\txor_sum = xor_sum ^ xor_num;\n\t}\n\tnodexor[start] = xor_sum & 15;\n\treturn nodexor[start];\n}\n\nint main() {\n\tLL N;\n\tcin >> N;\n\n\tREP(i, N - 1) {\n\t\tLL x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tedge[x].push_back(make_pair(y, a));\n\t\tedge[y].push_back(make_pair(x, a));\n\t}\n\n\tmake_graph(0, -2);\n\n\tfind_ans(0);\n\n\t/*\n\tvector<LL> num(4, 0);\n\tFOR(i,1, nodexor.size()) {\n\tnum[0] += (nodexor[i] & 1) / 1;\n\tnum[1] += (nodexor[i] & 2) / 2;\n\tnum[2] += (nodexor[i] & 4) / 4;\n\tnum[3] += (nodexor[i] & 8) / 8;\n\t}\n\n\tLL sum = 0;\n\tREP(i, num.size()) {\n\tsum += (num[i] + 1) / 2;\n\t}\n\n\tcout << sum << endl;\n\n\tvector<LL> num(16, 0);\n\tFOR(i, 1, nodexor.size()) {\n\t\tFOR(j, 1, num.size()) {\n\t\t\tnum[j] += (nodexor[i] & j) / j;\n\t\t}\n\t}\n\n\tLL sum = 0;\n\tsum += (num[1] + 1) / 2;\n\tsum += (num[2] + 1) / 2;\n\tsum += (num[4] + 1) / 2;\n\tsum += (num[8] + 1) / 2;\n\n\tsum -= (num[3]) / 2;\n\tsum -= (num[5]) / 2;\n\tsum -= (num[6]) / 2;\n\tsum -= (num[9]) / 2;\n\tsum -= (num[10]) / 2;\n\tsum -= (num[12]) / 2;\n\n\tsum += (num[7]) / 2;\n\tsum += (num[11]) / 2;\n\tsum += (num[13]) / 2;\n\tsum += (num[14]) / 2;\n\n\tsum -= (num[15]) / 2;\n\n\tcout << sum << endl;\n\t*/\n\n\tvector<LL> num(16, 0);\n\tqueue<LL> num1;\n\tvector<LL> numed(16, 0);\n\tFOR(i, 1, nodexor.size()) {\n\t\tnum[nodexor[i]&15] ++;\n\t}\n\n\tLL sum = 0;\n\n\tFOR(i, 1, num.size()) {\n\t\tif (num[i] % 2 == 0) {\n\t\t\tsum += num[i] / 2;\n\t\t\tnum[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tsum += num[i] / 2;\n\t\t\tnum[i] = 1;\n\t\t\tnum1.push(i);\n\t\t}\n\t}\n\n\twhile (num1.size()>=1) {\n\t\tif (num1.size() == 1) {\n\t\t\tif (num1.front() == 0) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tLL a = num1.front();\n\t\tnum1.pop();\n\t\tLL b = num1.front();\n\t\tnum1.pop();\n\t\tif (numed[a] >= 1) {\n\t\t\tnumed[a] --;\n\t\t\ta = 0;\n\t\t}\n\t\tif (numed[b] >= 1) {\n\t\t\tnumed[b] --;\n\t\t\tb = 0;\n\t\t}\n\t\tif (a != 0 && b != 0) {\n\t\t\tnum[a]--;\n\t\t\tnum[b]--;\n\t\t\tnum[a^b]++;\n\t\t\tsum++;\n\t\t}\n\t\tnum1.push(a^b);\n\t\tFOR(i, 1, num.size()) {\n\t\t\tif (num[i] % 2 == 0&& num[i]>0) {\n\t\t\t\tnum[i] = 0;\n\t\t\t\tnumed[i] +=2;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nconst int bits = 15;\nconst int limit = 1 << bits;\n\nint n, i, x, y, z, ans;\nvector< pair<int, int> > list[maxN];\nint dp[limit];\npriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > H;\nint tp;\n\nvoid pre() {\n    int i, j, to, aux, cnt = 0;\n\n    for (i = 0; i < limit; i++) dp[i] = bits + 1;\n    dp[0] = 0;\n    H.push(mp(0, 0));\n\n    while (!H.empty()) {\n        int conf = H.top().second;\n        int cost = H.top().first;\n        H.pop();\n\n        if (dp[conf] != cost) continue;\n        cnt++;\n\n        for (i = 0; i < bits; i++) {\n            for (j = 0; j < bits; j++) {\n                if (i == j) continue;\n                to = conf ^ (1 << i) ^ (1 << j);\n\n                aux = 1 << (((i + 1) ^ (j + 1)) - 1);\n                //if (conf & aux) continue;\n                to ^= aux;\n\n                if (dp[to] > dp[conf] + 1) {\n                    dp[to] = dp[conf] + 1;\n                    H.push(mp(dp[to], to));\n                }\n            }\n\n            to = conf ^ (1 << i);\n            if (dp[to] > dp[conf] + 1) {\n                dp[to] = dp[conf] + 1;\n                H.push(mp(dp[to], to));\n            }\n        }\n    }\n\n    //for (i = 0; i < 256; i++) cerr << dp[i] << ' ';\n    //cerr << '\\n';\n\n    cerr << limit - cnt << '\\n';\n}\n\nvoid dfs(int node, int root, int need) {\n    int act = 0;\n\n    for (auto to : list[node])\n        if (to.first != root)\n            dfs(to.first, node, to.second), act ^= to.second;\n\n    if (node != 1 && act != need)\n        tp ^= ((1 << (act ^ need)) >> 1), ans++;\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    pre();\n    for (i = 1; i < n; i++) {\n        cin >> x >> y >> z;\n        x++; y++;\n        list[x].pb(mp(y, z));\n        list[y].pb(mp(x, z));\n    }\n\n    dfs(1, 0, 0);\n    ans += dp[tp];\n\n    if (ans % 1) cerr << \"Error\";\n    cout << ans / 2 << '\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint c[101000],ok[10000000];\nint h[101000],nxt[201000],K=0,to[201000],cost[201000];int cnt[16],ans=0;\nvoid ins(int u,int v,int c){nxt[++K]=h[u];h[u]=K;to[K]=v;cost[K]=c;}\nvoid dfs(int x,int f,int val)\n{\n\tint k=0;\n\tfor(int i=h[x];i;i=nxt[i])\n\t{\n\t\tif(to[i]==f)continue;\n\t\tk^=cost[i];dfs(to[i],x,cost[i]);\n\t}\n\tif(x)cnt[val^k]++;\n}\nint a[18],tot=0,dp[1<<15];\nint DP(int S)\n{\n\t\n\tif(dp[S]!=-1)return dp[S];dp[S]=2000000000;\n\tfor(int i=0;i<15;i++)\n\tfor(int j=i+1;j<15;j++)\n\t{\n\t\tif(((S>>i)&1)&&((S>>j)&1))\n\t\t{\n\t\t\tint k=(i+1)^(j+1);\n\t\t\tdp[S]=min(dp[S],DP(S^(1<<(k-1))^(1<<j)^(1<<i))+2);\n\t\t}\n\t}\n\tfor(int i=0;i<15;i++)\n\t\tif((S>>i)&1)\n\t\t\tdp[S]=min(dp[S],DP(S^(1<<i))+1);\n\treturn dp[S];\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){int x,y,c;scanf(\"%d%d%d\",&x,&y,&c);ins(x,y,c);ins(y,x,c);}\n\tdfs(0,-1,0);\n\tint S=0;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)S|=1<<(i-1);\n\t}\n\tmemset(dp,-1,sizeof(dp));dp[0]=0;\n\tprintf(\"%d\",DP(S)+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define reg register\nusing namespace std;\nconst int N=1e5+5;\nint n,w[N],cnt[20],ans,st,f[1<<15],sum[1<<15];\ninline int read()\n{\n\tint x=0,w=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)&&c!='-') c=getchar();\n\tif (c=='-') c=getchar(),w=-1;\n\twhile (isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*w;\n}\nint main()\n{\n\tn=read();\n\tfor (reg int i=1;i<n;i++)\n\t{\n\t\tint x=read()+1,y=read()+1,z=read();\n\t\tw[x]^=z; w[y]^=z;\n\t}\n\tfor (reg int i=1;i<=n;i++) ++cnt[w[i]];\n\tfor (reg int i=1;i<=15;i++) ans+=cnt[i]/2,st|=((cnt[i]&1)<<(i-1));\n\tfor (reg int i=1;i<(1<<15);i++) f[i]=f[i>>1]+(i&1);\n\tfor (reg int i=1;i<(1<<15);i++) --f[i];\n\tfor (reg int i=1;i<(1<<15);i++)\n\t  for (reg int j=1;j<=15;j++)\n\t    if ((i>>j-1)&1) sum[i]^=j;\n\tfor (reg int i=1;i<(1<<15);i++)\n\t{\n\t\tif (sum[i]) continue;\n\t\tfor (reg int j=i&(i-1);j;j=i&(j-1))\n\t\t  if (!sum[j]) f[i]=min(f[i],f[j]+f[i^j]);\n\t}\n\tprintf(\"%d\\n\",ans+f[st]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, M;\nint A[MAX_N];\nint cnt[20];\n\nint dp[(1 << 16)];\nint ok[(1 << 16)];\nvector<int> vec;\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tA[a] ^= c;\n\t\tA[b] ^= c;\n\t}\n\trep(i, 0, N) cnt[A[i]]++;\n\t// debug(vi(A, A + N));\n\t// debug(vi(cnt, cnt + 16));\n\n\tint ans = 0;\n\trep(i, 1, 16) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] % 2) vec.pb(i);\n\t}\n\n\tM = sz(vec);\n\n\trep(bit, 1, (1 << M)) {\n\t\tint tmp = 0, res = 0;\n\t\trep(i, 0, M) {\n\t\t\tif(!(bit & (1 << i))) continue;\n\t\t\ttmp ^= vec[i];\n\t\t\tres++;\n\t\t}\n\t\tif(tmp == 0) ok[bit] = res - 1;\n\t\telse ok[bit] = M;\n\t}\n\tfill(dp, dp + (1 << M), M);\n\tdp[0] = 0;\n\trep(bit, 0, (1 << M)) {\n\t\tvector<int> vt;\n\t\trep(i, 0, M) {\n\t\t\tif(!(bit & (1 << i))) vt.pb(i);\n\t\t}\n\t\trep(bit2, 1, (1 << sz(vt))) {\n\t\t\tint to = 0;\n\t\t\trep(i, 0, sz(vt)) {\n\t\t\t\tif(bit2 & (1 << i)) to |= (1 << vt[i]);\n\t\t\t}\n\t\t\tMIN(dp[bit | to], dp[bit] + ok[to]);\n\t\t}\n\t}\n\tcout << ans + dp[(1 << M) - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 200005\nint n;\nint v[MN];\nint t[16];\nint dp[MN];\nint r[MN];\nint main(){\n\tread(n);\n\tfor(int i=1,x,y,z;i<n;++i){\n\t\tread(x);read(y);read(z);\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tfor(int i=0;i<n;++i)++t[v[i]];\n\tint res=0;\n\tint h=0;\n\tfor(int i=1;i<16;++i){\n\t\tres+=(t[i]+1)/2;t[i]%=2;h|=t[i]*(1<<i);\n\t}\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=0;i<h;++i){\n\t\tfor(int j=0;j<16;++j)if((1<<j)&i){\n\t\t\tr[i]^=j;\n\t\t}\n\t}\n\tfor(int i=0;i<h;++i)if(dp[i]<0x3f3f3f3f){\n\t\tint S=h-i;\n\t\tfor(int j=S;j;j=S&(j-1))if(r[j]==0){\n\t\t\tdp[i+j]=min(dp[i]+1,dp[i+j]);\n\t\t}\n\t}\n\tcout<<res-dp[h];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    int ans = 0;\n    for(int i = 1; i <= 15; i++) {\n        if((i & 3) && (i & 12)) {\n            ans += cnt[i] / 2;\n            if(cnt[i] % 2) {\n                cnt[ i & 3 ]++;\n                cnt[ i & 12 ]++;\n            }\n            cnt[i] = 0;\n        }\n    }\n    int acnt = 0;\n    int bcnt = 0;\n    for(int i = 1; i <= 15; i++) {\n        if((i | 3) == 3) {\n            acnt += cnt[i];\n        }\n        else bcnt += cnt[i];\n    }\n    ans += (acnt + 1) / 2;\n    ans += (bcnt + 1) / 2;\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <iterator>\n#include <functional>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <list>\n#include <sstream>\n#include <unordered_map>\n#include <complex>\n#include <stdio.h>\nusing namespace std;\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\n\ntypedef double LD;\ntypedef unsigned long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LD, LD> PDD;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef vector<char> VCH;\ntypedef vector<LD> VLD;\ntypedef vector<string> VS;\ntypedef vector<VS> VSS;\ntypedef vector<VI> VVI;\ntypedef vector<VLL> VVLL;\ntypedef vector<VCH> VVCH;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<PDD> VPDD;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n#define next fake_next\n#define prev fake_prev\n#define left fake_left\n#define right fake_right\n\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LD PI = acos(-1.0);\nconst LD EPS = 1e-9;\nconst LL mod = 1000000007;\nconst LL INF = 1e9;\nconst LL LINF = 1e15;\nconst LL MAX = 2e5 + 7;\nconst LL MAXN = 1e5 + 1;\n\nint n;\nstruct sumizhna\n{\n\tint v;\n\tint w;\n\tint index;\n\n};\n\nvector<vector<sumizhna>> g;\nvector<pair<int, PII>> e;\nset<int> used;\n\nvoid dfs(PII edge, int bit, int index)\n{\n\tused.insert(index);\n\tint x = edge.X;\n\tfor (auto i : g[x])\n\t\tif (i.w & (1 << bit))\n\t\t{\n\t\t\tif (used.count(i.index))\n\t\t\t\tcontinue;\n\n\t\t\tdfs(MP(x, i.v), bit, i.index);\n\t\t}\n\n\tx = edge.Y;\n\tfor (auto i : g[x])\n\t\tif (i.w & (1 << bit))\n\t\t{\n\t\t\tif (used.count(i.index))\n\t\t\t\tcontinue;\n\n\t\t\tdfs(MP(x, i.v), bit, i.index);\n\t\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"Out.txt\", \"w\", stdout);\n\t\n\tcin >> n;\n\tg.resize(n);\n\tint u, v, w;\n\tFOR(i, 0, n - 1)\n\t{\n\t\tcin >> u >> v >> w;\n\t\tg[u].push_back({ v, w, i });\n\t\tg[v].push_back({ u, w, i });\n\t\te.push_back(MP(w, MP(u, v)));\n\t}\n\n\tint ans = 0;\n\tFOR(i, 0, 4)\n\t{\n\t\tused.clear();\n\t\tFOR(j, 0, n - 1)\n\t\t\tif (!used.count(j) && (e[j].X & (1 << i)))\n\t\t\t\t++ans, dfs(e[j].Y, i, j);\n\t}\n\n\tcout << ans;\n\tcin >> n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst int M = 20;\n\nint n, m;\nint a[N];\nint ans;\nint cnt[M];\nint dp[1 << M];\nint dp2[1 << M];\nvector<int> v;\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v, x;\n\t\tcin >> v >> u >> x;\n\t\ta[u] = a[u] ^ x;\n\t\ta[v] = a[v] ^ x;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcnt[a[i]]++;\n\t}\n\tans = cnt[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (cnt[a[i]] % 2)\n\t\t{\n\t\t\tv.push_back(a[i]);\n\t\t}\n\t\tans += cnt[a[i]] / 2;\n\t}\n\tm = v.size();\n\tfor (int i = 0; i < (1 << m); i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif ((i >> j) % 2 == 1)\n\t\t\t{\n\t\t\t\tdp2[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int mask = 1; mask < (1 << m); mask++)\n\t{\n\t\tif (dp2[mask] != 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdp[mask] = 1;\n\t\tint mask2 = mask;\n\t\twhile (mask2 > 0)\n\t\t{\n\t\t\tmask2 = (mask2 - 1) & mask;\n\t\t\tif (!dp2[mask2])\n\t\t\t{\n\t\t\t\tdp[mask] = max(dp[mask], dp[mask2] + dp[mask ^ mask2]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << max(n - ans - dp[(1 << m) - 1], 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops\")\n#include<bits/stdc++.h>\n#define ll long long\n#define F first\n#define S second\n#define P pair\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define rep(i,a,b) for(int i=a;i<b;i++) \n#define V vector\n#define RE return\n#define ALL(a) a.begin(),a.end()\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define FILL(a,b) memset(a,b,sizeof(a))\nusing namespace std;\nint c[16],n,v[200005],dp[1<<16];\nint dfs(int x){\n\tif(dp[x]!=-1)RE dp[x];\n\tint re=1000000000;\n\trep(i,1,16){\n\t\tif(x&(1<<i)){\n\t\t\trep(j,i+1,16){\n\t\t\t\tif(x&(1<<j)){\n\t\t\t\t\tre=min(re,dfs(x^(1<<i)^(1<<j)^(1<<(i^j)))+((x&(1<<(i^j)))?2:1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tRE dp[x]=re;\n}\nint main(){\n\tios::sync_with_stdio(0);\n    cin.tie(0);\n\tcin>>n;\n\tint x,y,z;\n\trep(i,1,n){\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;v[y]^=z;\n\t}\n\tint ans=0;\n\trep(i,0,n){\n\t\tc[v[i]]++;\n\t}\n\tFOR(i,1,15){\n\t\tans+=c[i]/2;\n\t\tc[i]&=1;\n\t}\n\tint get=0;\n\tFILL(dp,-1);dp[0]=0;\n\tFOR(i,1,15)if(c[i])get^=(1<<i);\n\tcout<<dfs(get)+ans;\n\tRE 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}//è´ªå¿ \n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\t\n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç \n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);//é¢å¤çéåçå¼æå \n    for(int i=1;i<(1<<15);i++)//æä¸¾å­éè¿è¡è½¬ç§» \n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(ll i=a;i<b;i++)\n#define Ford(i,a,b) for(ll i=a;i>=b;i--)\n#define RET(x) { cout << x; exit(0); }\n#define smin(a,b) a=min(a,b)\n#define smax(a,b) a=max(a,b)\n#define SZ(x) ((ll)((x).size()))\n#define PB push_back\n#define ER(x) cout << #x << ' ' << x << '\\n';\n#define X first\n#define Y second\n\ntypedef long long int LL;\ntypedef LL ll;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> pll;\n\nconst ll M=1e5+5,LG=30,mod=924844033;\nll pw(ll x,ll y){ if (y==0) return 1; return pw(x*x%mod,y/2)*(y&1?x:1)%mod; }\n\n#define MOK(x) if (x>=mod) x-=mod;\n\n\nvll g[M];\nll uu[M],vv[M],ww[M];\nll n;\nll co[LG];\n\nll nwbk[LG],nw[LG];\n\n\nll bu(){\n  ll res=0;\n  For(i,1,16){\n    if (nw[i]) res+=(1<<(i-1));\n  }\n  return res;\n}\n\nvoid backup(){\n  For(i,1,16) nwbk[i]=nw[i];\n}\n\nvoid unpack(){\n  For(i,1,16) nw[i]=nwbk[i];\n}\n\nll dfs(ll x,ll p){\n  ll s=0,ebab=0;\n  for (ll e:g[x]){\n    ll y=uu[e]^vv[e]^x;\n    if (y==p){\n      ebab=ww[e];\n      continue;\n    }\n    s^=dfs(y,x);\n  }\n  //ER(x);ER(p);ER(s);\n  co[s^ebab]++;\n  return ebab;\n}\n\nvector<pll> gd[M];\nll qu[M],qh,qt;\nll vis[M];\nll dp[M];\n\nvoid dpupd(){\n  For(i,0,1<<15){\n    For(j,1,16){\n      nw[j]=(i>>(j-1)&1);\n    }\n    For(j,1,16){\n      if (!nw[j]) continue;\n      nw[j]=0;\n      //ER(i);ER(bu());\n      gd[bu()].PB({i,1});\n      nw[j]=1;\n      break;\n    }\n    For(a,1,16){\n      if (!nw[a]) continue;\n      For(b,a+1,16){\n\tif (!nw[a] || !nw[b]) continue;\n\tFor(c,1,16){\n\t  backup();\n\t  nw[a]=0;\n\t  nw[b]=0;\n\t  ll ap=a^c;\n\t  ll bp=b^c;\n\t  ll r=1;\n\t  if (nw[ap]){\n\t    r++;\n\t    nw[ap]=0;\n\t  }\n\t  else{\n\t    nw[ap]=1;\n\t  }\n\t  if (nw[bp]){\n\t    r++;\n\t    nw[bp]=0;\n\t  }\n\t  else{\n\t    nw[bp]=1;\n\t  }\n\t  gd[bu()].PB({i,r});\n\t  unpack();\n\t}\n      }\n      break;\n    }\n  }\n  memset(dp,31,sizeof dp);\n  qu[0]=0;\n  dp[0]=0;\n  qh=0;\n  qt=1;\n  while (qh!=qt){\n    ll u=qu[qh++];\n    vis[u]=0;\n    for (pll e:gd[u]){\n      ll v=e.X;\n      ll rd=dp[u]+e.Y;\n      if (dp[v]<=rd) continue;\n      dp[v]=rd;\n      if (!vis[v]){\n\tvis[v]=1;\n\tqu[qt++]=v;\n      }\n    }\n  }\n  /*For(i,1,(1<<15)){\n    if (dp[i]>__builtin_popcount(i)){\n      ER(i);ER(dp[i]);\n    }\n    }*/\n  //ER(qh);\n}\n\nint main(){\n  ios::sync_with_stdio(0);\n  cin >> n;\n  For(i,1,n){\n    ll u,v,w;\n    cin >> u >> v >> w;\n    uu[i]=u;vv[i]=v;ww[i]=w;\n    g[u].PB(i);\n    g[v].PB(i);\n  }\n  co[dfs(0,0)]--;\n  ll res=0;\n  ll mymsk=0;\n  For(i,1,16){\n    //ER(i);ER(co[i]);\n    res+=co[i]/2;\n    co[i]=co[i]%2;\n    if (co[i])\n      mymsk+=1<<(i-1);\n  }\n  dpupd();\n  //ER(mymsk);ER(dp[mymsk]);\n  res+=dp[mymsk];\n  RET(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 65540\nusing namespace std;\nint n,s[N],S,ans,f[M],inf,sum[20];\n\nint dfs(int S)\n{\n  if(!S)return 0; \n  if(f[S]<inf)return f[S];\n  for(int i=0;i<16;i++)if((S>>i)&1)\n    for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1)\n    {\n      int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n      if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n      else f[S]=min(f[S],dfs(x)+1);\n      //æä¸¾æ¯æ¬¡å¼æçä¸¤ä¸ªèç¹i,j,iå¼ææj,jå¼ææj,è¿å©ä¸p=i^j\n      //å¦æpæ¬èº«å­å¨é£ä¸¤ä¸ªpç´æ¥æ¶æ \n    }\n  return f[S];\n}\n\nint main()\n{\n  int a,b,c;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d%d\",&a,&b,&c),s[a]^=c,s[b]^=c;\n  for(int i=0;i<n;i++)sum[s[i]]++;\n  for(int i=1;i<16;i++)\n    ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n  memset(f,127,sizeof(f));inf=f[0];\n  printf(\"%d\\n\",ans+dfs(S));\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int maxn = 1e5 + 100;\nmap<int, int> nr_ops;\n\nconst int inf=1e9;\nstruct heap\n{\n    int nod,c;\n    bool operator <(const heap &aux) const\n    {\n        return c>aux.c;\n    }\n};\nvector<heap> g[1<<16];\npriority_queue<heap> h;\nint d[1<<16];\n\nint stupid_subproblem(vector<int>& v)\n{\n    int lim=1<<15;\n    for(int mask=1;mask<lim;mask++)\n    {\n        int s=0;\n        for(int i=0;i<15;i++)\n            if(mask&(1<<i)) s^=(i+1);\n        if(s!=0) continue;\n        for(int i=0;i<15;i++)\n            if(mask&(1<<i))\n                for(int j=i+1;j<15;j++)\n                    if(mask&(1<<j))\n                        for(int x=1;x<16;x++)\n                        {\n                            int a=(i+1)^x;\n                            int b=(j+1)^x;\n                            int s=1;\n                            if(a!=0 && mask&(1<<(a-1))) s++;\n                            if(b!=0 && mask&(1<<(b-1))) s++;\n                            int mask1=mask^(1<<i)^(1<<j);\n                            if(a!=0) mask1^=(1<<(a-1));\n                            if(b!=0) mask1^=(1<<(b-1));\n                            g[mask1].push_back({mask,s});\n                        }\n    }\n    for(int i=0;i<lim;i++) d[i]=inf;\n    h.push({0,0});\n    d[0]=0;\n    while(!h.empty())\n    {\n        int nod=h.top().nod,c=h.top().c;\n        h.pop();\n        if(d[nod]!=c) continue;\n        for(auto vec : g[nod])\n            if(d[vec.nod]> d[nod]+vec.c)\n            {\n                d[vec.nod]=d[nod]+vec.c;\n                h.push({vec.nod,d[vec.nod]});\n            }\n    }\n    int mask=0;\n    for(int i=0;i<v.size();i++)\n        mask^=1<<(v[i]-1);\n    return d[mask];\n}\n\nint main(){\n    //ifstream cin(\"file.in\");\n    int n;\n    cin >> n;\n    vector<int> v(n, 0);\n    for(int i = 0, x, y, a; i < n-1; ++i){\n        cin >> x >> y >> a;\n        v[x] ^= a;\n        v[y] ^= a; }\n    for(int i = 0; i < n; ++i) nr_ops[v[i]]++;\n\n    int rez = 0;\n    vector<int> thing;\n    for(auto& x : nr_ops){\n        if(x.first == 0) continue;\n        if(x.second % 2 == 1) thing.push_back(x.first);\n        rez += x.second/2; }\n    rez += stupid_subproblem(thing);\n    cout << rez << endl;\n    return 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=100005;\nint val[maxn*20],hd[maxn],n,m;\nint to[maxn*20],ne[maxn*20],num,S;\nint XS[maxn],now,ci[20],d[maxn],C[233];\ninline void add(int x,int y,int z){ to[++num]=y,ne[num]=hd[x],hd[x]=num,val[num]=z;}\n\ninline void build(){\n\tfor(int i=1;i<ci[15];i++)\n\t    for(int j=1;j<=15;j++) if(ci[j-1]&i){\n\t    \tnow=i^ci[j-1],add(now,i,1);\n\t    \tfor(int k=1;k<=15;k++) if(ci[k-1]&now) add(now^ci[k-1]^ci[(j^k)-1],i,1+((now&ci[(j^k)-1])?1:0));\n\t\t}\n}\n\ninline void spfa(){\n\tqueue<int> q; bool v[maxn];\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(v,0,sizeof(v));\n\td[0]=0,q.push(0),v[0]=1;\n\t\n\tint x;\n\twhile(!q.empty()){\n\t\tx=q.front(),q.pop();\n\t\tfor(int i=hd[x];i;i=ne[i]) if(d[x]+val[i]<d[to[i]]){\n\t\t\td[to[i]]=d[x]+val[i];\n\t\t\tif(!v[to[i]]) v[to[i]]=1,q.push(to[i]);\n\t\t}\n\t\tv[x]=0;\n\t}\n}\n\ninline void init(){\n\tci[0]=1;\n\tfor(int i=1;i<=15;i++) ci[i]=ci[i-1]<<1;\n\t\n\tbuild();\n\tspfa();\n}\n\ninline void solve(){\n\tint uu,vv,ww,ans=1<<30;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&uu,&vv,&ww);\n\t\tuu++,vv++,XS[uu]^=ww,XS[vv]^=ww;\n\t}\n\t\n\tfor(int i=1;i<=n;i++) C[XS[i]]++;\n\tfor(int i=1;i<=n;i++){\n\t\tC[XS[i]]--;\n\t\t\n\t\tS=0,now=0;\n\t\tfor(int j=1;j<=15;j++){\n\t\t\tnow+=C[j]>>1;\n\t\t\tS|=(C[j]&1)*ci[j-1];\n\t\t}\n\t\tnow+=d[S];\n\t\tans=min(ans,now);\n\t\t\n\t\tC[XS[i]]++;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[16][1 << 16][8];\nint dp2(int idx, int mask, int tidx, int tcnt) {\n    if(tcnt >= 20) return 1e9;\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask);\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(idx, mask, tidx + 1, tcnt);\n\n    if(cc2[idx][mask][tidx].find(tcnt) != cc2[idx][mask][tidx].end()) return cc2[idx][mask][tidx][tcnt];\n    int &ret = cc2[idx][mask][tidx][tcnt];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(idx, mask, tidx + 1, tcnt));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(idx, mask ^ (1 << tidx) ^ (1 << didx), tidx, tcnt + 1));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(idx, mask, 1, 0);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "//TooWeakTooSlow\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int>   II;\ntypedef vector< II >      VII;\ntypedef vector<int>     VI;\ntypedef vector< VI > \tVVI;\ntypedef long long int \tLL;\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define si(n) scanf(\"%d\",&n)\n#define dout(n) printf(\"%d\\n\",n)\n#define sll(n) scanf(\"%lld\",&n)\n#define lldout(n) printf(\"%lld\\n\",n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n//FILE *fin = freopen(\"in\",\"r\",stdin);\n//FILE *fout = freopen(\"out\",\"w\",stdout);\n\nconst int N = 1e5 + 10;\nconst int MASK = 1 << 16;\nVI g[MASK];\nint val[N], cnt[16], dp[MASK];\nint f(int mask){\n  if(mask & 1)mask ^= 1;\n  if(mask == 0)return 0;\n  if(dp[mask] != -1)return dp[mask];\n  int &ret = dp[mask];\n  ret = 16;\n  assert(__builtin_popcount(mask) > 1);\n  REP(i, 16)if(mask & (1 << i)){\n    REP(j, 16)if(mask & (1 << j)){\n      if(i == j)continue;\n      int newmask = mask ^ (1 << i);\n      newmask ^= (1 << j);\n      int add = 1;\n      if(newmask & (1 << (i ^ j))){\n        add++;\n      }\n      newmask ^= (1 << (i ^ j));\n      ret = min(ret, add + f(newmask));\n    }\n  }\n  return ret;\n}\nint main()\n{\n  SET(dp, -1);\n  int n;si(n);\n  REP(i, n - 1){\n    int x, y, a;\n    si(x);si(y);si(a);\n    val[x] ^= a;\n    val[y] ^= a;\n  }\n  REP(i, n)cnt[val[i]]++;\n  int ans = 0;\n  FOR(i, 1, 16){\n    ans += cnt[i] / 2;\n    //trace(i, cnt[i], ans);\n    cnt[i] -= (cnt[i] / 2) * 2;\n  }\n  int mask = 0;\n  FOR(i, 1, 16)if(cnt[i])mask |= (1 << i);\n  //trace(bitset<10>(mask));\n  dout(ans + f(mask));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int uint;\ntypedef pair <int, int> pii;\ntypedef unsigned long long uLL;\n\ntemplate <typename T> inline void Read(T &x) {\n  char c = getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n\ntemplate <typename T> inline bool CheckMax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n\ntemplate <typename T> inline bool CheckMin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n\nconst int N = 100005;\n\nint n, m, ans, a[N], b[N], c[N], f[N];\n\nint main() {\n#ifdef wxh010910\n  freopen(\"d.in\", \"r\", stdin);\n#endif\n  Read(n);\n  for (int i = 1, x, y, w; i < n; ++i) {\n    Read(x), Read(y), Read(w);\n    a[x] ^= w, a[y] ^= w;\n  }\n  for (int i = 0; i < n; ++i) {\n    ++c[a[i]];\n  }\n  for (int i = 1; i < 16; ++i) {\n    ans += c[i] >> 1;\n    if (c[i] & 1) {\n      b[m++] = i;\n    }\n  }\n  for (int i = 1; i < 1 << m; ++i) {\n    int s = 0;\n    for (int j = 0; j < m; ++j) {\n      if (i >> j & 1) {\n        s ^= b[j];\n      }\n    }\n    if (s) {\n      f[i] = m;\n    } else {\n      f[i] = __builtin_popcount(i) - 1;\n    }\n    for (int j = s = i; j; j = j - 1 & s) {\n      CheckMin(f[i], f[j] + f[i ^ j]);\n    }\n  }\n  printf(\"%d\\n\", ans + f[(1 << m) - 1]);\n#ifdef wxh010910\n  Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nvector<vector<pair<ll, ll>>> tree;\n\nconst ll SZ = 32999;\n\nll dp[SZ], xr[SZ];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\ttree.resize(n);\n\n\tvector<ll> vec;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v, c;\n\t\tcin >> u >> v >> c;\n\n\t\ttree[u].push_back({ v, c });\n\t\ttree[v].push_back({ u, c });\n\t}\n\n\tll ans = 0;\n\tmap<ll, ll> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tll vl = 0;\n\t\tfor (auto to : tree[i]) {\n\t\t\tvl ^= to.second;\n\t\t}\n\t\tcnt[vl]++;\n\t}\n\n\tfor (auto cur : cnt) {\n\t\tif (cur.first == 0) continue;\n\n\t\tans += (cur.second) / 2;\n\t\tif (cur.second % 2) vec.push_back(cur.first);\n\t}\n\n\tll pw = (1ll << vec.size());\n\n\tfor (int i = 1; i < pw; i++) {\n\t\tll curVl = 0;\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcurVl ^= vec[j];\n\t\t\t}\n\t\t}\n\t\txr[i] = curVl;\n\t}\n\n\tfor (int i = 1; i < pw; i++) {\n\t\tif (xr[i] == 0) dp[i] = 1;\n\t\tfor (auto m = i; ; m = (m - 1) & i) {\n\t\t\tif (m == i) continue;\n\t\t\tif (xr[m] == 0) dp[i] = max(dp[i], dp[m] + 1);\n\t\t\tif (m == 0) break;\n\t\t}\n\t}\n\n\tcout << n - ans - dp[pw - 1];\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define swap(a,b) (a^=b^=a^=b)\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 100005\nint n,val[MN],num[16],ans;\nint f[1<<16],inf;\nint dfs(int S)\n{\n\tregister int i,j;\n\tif(!S) return f[S]=0; \n\tif(f[S]<inf)return f[S];\n    for(i=0;i<16;i++)if(S&(1<<i))for(j=0;j<16;j++)if(i!=j&&(S&(1<<j)))\n    {\n    \tint p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n    \tif(S&(1<<p)) f[S]=min(f[S],dfs(x)+2);\n    \telse f[S]=min(f[S],dfs(x)+1);\n    }\n    return f[S];\n}\nint main()\n{\n\tn=read();\n\tregister int i,j,k,x,y,z,S=0;\n\tfor(i=1;i<n;++i)\n\t\tx=read(),y=read(),z=read(),val[x]^=z,val[y]^=z;\n\tfor(i=0;i<n;++i) num[val[i]]++;\n\tfor(i=1;i<16;++i) ans+=(num[i]>>1),S+=(1<<i)*(num[i]&1);\n\tmemset(f,127,sizeof(f));inf=f[0];f[0]=0;\n\tprintf(\"%d\\n\",ans+dfs(S));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    //cout<<b<<\":\"<<dp[b]<<endl;\n    for(Int i=0;i<16;i++){      \n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\t//cout<<i<<\"@\"<<j<<endl;\n\tif(i&j){\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^(i&j));\n\t  fix(j^(i&j));\n\t  if(calc(nb)>=calc(b)) continue;\n\t  //assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" ::: \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n\tif(0){\n\t  Int dif=max(bc[i]-1,bc[j]-1)-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^j);\n\t  fix(0);\n\t  if(calc(nb)>=calc(b)) continue;\n\t  //assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" *** \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n      }\n    }\n  }\n  \n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint cnt[20],v[N];\nint dp[1<<20];\nint dfs(int s)\n{\n\tif(s==0) return 0;\n\tif(dp[s]!=-1) return dp[s];\n\tdp[s]=0x3f3f3f3f;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tif(s>>i&1)\n\t\t{\n\t\t\tfor(int j=0;j<16;j++)\n\t\t\t{\n\t\t\t\tif(s>>j&1)\n\t\t\t\t{\n\t\t\t\t\tint x=j^i;\n\t\t\t\t\tint ns=s^(1<<j)^(1<<i)^(1<<x);\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t dp[s]=min(dp[s],dfs(ns)+1+((s&(1<<x))==(1<<x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tv[x]^=z;\n\t\tv[y]^=z; \n\t}\n\tmemset(dp,-1,sizeof dp);\n\tfor(int i=0;i<n;i++)\n\t if(v[i]) cnt[v[i]]++;\n\tint ans=0,st=0;;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst|=(cnt[i]&1)<<i;\n\t}\n\tans+=dfs(st);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <utility>\n#include <list>\n\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <bitset>\n#include <complex>\n#include <climits>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\ntypedef pair<double, double> dd;\ntypedef unsigned long long ull;\n#define mp make_pair\n#define pb push_back\n\n#define debug(x) cerr << #x << \" = \" << x << \" \"\n\nconst int N = 1e5;\nint val[N];\nconst int B = 4;\nconst int MB = 1<<B;\nconst int MMB = 1<<MB;\nint cnt[MB];\nint d[MMB];\nint bitvalue[MMB];\nint bitcnt[MMB];\nint main()\n{\n  int n; scanf(\"%d\", &n);\n  for (int i = 1; i <= n-1; ++i)\n    {\n      int u, v, x;\n      scanf(\"%d %d %d\", &u, &v, &x);\n      val[u] ^= x;\n      val[v] ^= x;\n    }\n  for (int i = 0; i < n; ++i) ++cnt[val[i]];\n  int ans = 0;\n  for (int i = 0; i < MB; ++i) bitvalue[1<<i] = i;\n  for (int i = 1; i < MB; ++i) ans += cnt[i]/2, cnt[i] %= 2;\n  for (int i = 1; i < MMB; ++i)\n    {\n      int lb = i&-i;\n      bitvalue[i] = bitvalue[i^lb] ^ bitvalue[lb];\n      bitcnt[i] = bitcnt[i>>1] + (i&1);\n      d[i] = MB;\n      for (int sub = i; sub; sub = (sub-1)&i)\n\tif (bitvalue[sub] == 0)\n\t  d[i] = min(d[i], bitcnt[sub] -1 + d[i^sub]);\n    }\n  int mask = 0;\n  for (int i = 1; i < MB; ++i) mask ^= cnt[i] << i;\n  printf(\"%d\\n\", d[mask] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Sasayego! Sasayego! Shinzou wo Sasageyo!\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <ctime>\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define lid (id << 1)\n#define rid (lid ^ 1)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll, ll> pll;\ntypedef pair <int, int> pii;\n\nconst int maxN = 1e5 + 5;\nconst int maxA = 15;\nconst int maxK = (1 << maxA) + 5;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nint a[maxN], cnt[16];\nint l = 0, b[maxN];\nint arumin[2][maxK];\n\nint main(){\n\ttime_t START = clock();\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++){\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i]]++;\n\tint ans = 0;\n\tfor (int i = 1; i < 16; i++){\n\t\tans += (cnt[i] >> 1);\n\t\tcnt[i] &= 1;\n\t\tif (cnt[i])\n\t\t\tb[l++] = i;\n\t}\n\tfor (int mask = 1; mask < (1 << l); mask++){\n\t\tint lb = __builtin_ctz(mask);\n\t\tarumin[0][mask] = b[lb] ^ arumin[0][mask ^ (1 << lb)];\n\t\tif (arumin[0][mask] == 0){\n\t\t\tarumin[1][mask] = __builtin_popcount(mask) - 1;\n\t\t\tfor (int sub = mask & (mask - 1); sub >= mask >> 1; sub = (sub - 1) & mask)\n\t\t\t\tif (arumin[0][sub] == 0)\n\t\t\t\t\tarumin[1][mask] = max(arumin[1][mask], arumin[1][sub] + arumin[1][mask ^ sub]);\n\t\t}\n\t}\n\tans += arumin[1][(1 << l) - 1];\n\tprintf(\"%d\\n\", ans);\n\ttime_t FINISH = clock();\n\tcerr << \"Execution time: \" << (ld)(FINISH - START) / CLOCKS_PER_SEC * 1000.0 << \" milliseconds.\\n\";\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nlong long max(long long x, long long y){return (x > y ? x : y);}\nlong long min(long long x, long long y){return (x < y ? x : y);}\nint gcd(int a, int b) { return b ? gcd(b, a%b) : a; }\n\n#define ll int\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=1e5+500;\nconst ll inf=1e9+800;\nconst ll mod=1e9+7;\n\nll dp[1<<16];\nll xx[1<<16];\nvoid cal(){\n\txx[0]=0;\n\tfor(ll i=2;i<(1<<16);i+=2){\n\t\tll lb;\n\t\tfor(ll j=0;j<16;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tlb=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\txx[i]=(xx[i^(1<<lb)]^lb);\n  \t}\n\tdp[0]=0;\n\tfor(ll i=2;i<(1<<5);i+=2){\n\t\tfor(ll mas=i;mas>0;mas=((mas-1)&i)){\n\t\t\tif(xx[mas]==0)dp[i]=max(dp[i],dp[i^mas]+1);\n\t\t}\n\t}\n}\n\nvector<pii> ger[maxn];\nll cnt[16];\n\nvoid dfs(ll a,ll p=-1){\n\tll val=0;\n\tFOR(i,ger[a]){\n\t\tll v=ger[a][i].F;\n\t\tll w=ger[a][i].S;\n\t\tval^=w;\n\t\tif(v!=p)\n\t\tdfs(v,a);\n\t}\n\tcnt[val]++;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tll n;\n\tcin>>n;\n\tfor(ll i=1;i<n;i++){\n\t\tll v,u,w;\n\t\tcin>>v>>u>>w;\n\t\tger[v].pb(mp(u,w));\n\t\tger[u].pb(mp(v,w));\n\t}\n\tdfs(0);\n\tll ans=0;\n\tfor(ll i=1;i<16;i++){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\tll res=0;\n\tll t=0;\n\tfor(ll i=1;i<16;i++){\n\t\tif(cnt[i]){\n\t\t\tres+=(1<<i) ;\n\t\t\tt++;\n\t\t}\n\t}\n\tcal();\n\tcout<<ans+t-dp[res];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region revive\n#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define inl inline\n#define re register int\n#define fa(x) t[x].fa\n#define son(x, y) t[x].child[y]\n#define ls(x) t[x].child[0]\n#define rs(x) t[x].child[1]\n#define ll long long\n#define ull unsigned long long\nconst int inf = 0x3f3f3f3f;\n#define lowbit(x) ((x) & (-x))\nusing namespace std;\n//#ifndef _DEBUG\n//#define getchar() (*(IOB.in.p++))\n//#define putchar(c) (*(IOB.out.p++) = (c))\n//#define io_eof() (IOB.in.p >= IOB.in.pend)\n//struct IOBUF {\n//\tstruct {\n//\t\tchar buff[1 << 27], *p, *pend;\n//\t} in;\n//\tstruct {\n//\t\tchar buff[1 << 27], *p;\n//\t} out;\n//\tIOBUF() {\n//\t\tin.p = in.buff;\n//\t\tout.p = out.buff;\n//\t\tin.pend = in.buff + fread(in.buff, 1, 1 << 27, stdin);\n//\t}\n//\t~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); }\n//} IOB;\n//#endif\ntemplate <typename IO>\ninl void write(IO x) {\n\tif (x == 0) return (void)putchar('0');\n\tif (x < 0) putchar('-'), x = -x;\n\tstatic char buf[30];\n\tchar *p = buf;\n\twhile (x) {\n\t\t*(p++) = x % 10 + '0';\n\t\tx /= 10;\n\t}\n\twhile (p > buf)\n\t\tputchar(*(--p));\n}\ninl void writestr(const char *s) {\n\twhile (*s != 0)\n\t\tputchar(*(s++));\n}\ntemplate <typename IO>\ninl void writeln(IO x) { write(x), putchar('\\n'); }\ntemplate <typename IO>\ninl void writesp(IO x) { write(x), putchar(' '); }\ninl int readstr(char *s) {\n\tchar *begin = s, c = getchar();\n\twhile (c < 33 || c > 127) {\n\t\tc = getchar();\n\t}\n\twhile (c >= 33 && c <= 127) {\n\t\t*(s++) = c;\n\t\tc = getchar();\n\t}\n\t*s = 0;\n\treturn s - begin;\n}\ntemplate <typename IO>\ninl IO read() {\n\tIO x = 0;\n\tregister bool w = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn w ? -x : x;\n}\ntemplate <>\ninl double read<double>() {\n\tdouble x = 0;\n\tint w = 0, y = 0;\n\tll z = 1;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9' || c == '.') {\n\t\tif (c == '.') {\n\t\t\ty = 1, c = getchar();\n\t\t\tcontinue;\n\t\t}\n\t\tx = x * 10 + (c ^ 48);\n\t\tif (y) z *= 10;\n\t\tc = getchar();\n\t}\n\treturn (w ? -x : x) / z;\n}\n#pragma endregion\nint n, b[1 << 17], f[1 << 17], s;\nint a[100005], o[20], ans;\ninl int dp(int i) {\n\tif (f[i] < inf) return f[i];\n\tfor (re x = 1; x <= 15; x++) {\n\t\tif (((1 << x) & i) == 0) continue;\n\t\tfor (re y = 1; y <= 15; y++) {\n\t\t\tif (x == y) continue;\n\t\t\tif (((1 << y) & i) == 0) continue;\n\t\t\tre z = x ^ y, p = (((i ^ (1 << z)) ^ (1 << x)) ^ (1 << y));\n\t\t\tif ((1 << z) & i)\n\t\t\t\tf[i] = min(f[i], dp(p) + 2);\n\t\t\telse\n\t\t\t\tf[i] = min(f[i], dp(p) + 1);\n\t\t}\n\t}\n\treturn f[i];\n}\nint main() {\n\tn = read<int>();\n\tfor (re x, y, z, i = 1; i < n; i++) {\n\t\tx = read<int>(), y = read<int>(), z = read<int>();\n\t\ta[x] ^= z, a[y] ^= z;\n\t}\n\tfor (re i = 0; i < n; i++) o[a[i]]++;\n\tfor (re i = 1; i <= 15; i++) {\n\t\tif (o[i] >= 2) {\n\t\t\tans += o[i] / 2;\n\t\t\to[i] = o[i] & 1;\n\t\t}\n\t\tif (o[i]) s |= (1 << i);\n\t}\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] = 0;\n\twriteln(ans + dp(s));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=100005;\nconst int p=1e9+7;\nint n,a[N];\nint tot[16];\n\ntemplate<class T> void read(T &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nvoid Add(int &x,int y){\n\tx+=y;\n\twhile(x>=p) x-=p;\n}\n\nint f[1<<16],sum[1<<16];\nint main(){\n\tread(n);\n\tint x,y,w;\n\tfr(i,2,n){\n\t\tread(x);read(y);read(w);\n\t\tx++;y++;\n\t\ta[x]^=w;a[y]^=w;\n\t}\n\tfr(i,1,n) tot[a[i]]++;\n\tint ans=0,all=0;\n\tfr(i,1,15) ans+=tot[i]/2,all^=(tot[i]&1)<<i;\n\tfr(i,0,all)\n\t if ((i&all)==i){\n\t \tif ((i&(-i))==i){ f[i]=1;continue; }\n\t \tsum[i]=0;\n\t \tfr(j,0,15) if (i&(1<<j)) sum[i]^=j,f[i]++;\n\t \tif (sum[i]) continue;\n\t \tf[i]--;\n\t \tfor(int j=(i-1)&i;j;j=(j-1)&i)\n\t \t if (sum[j]==0) f[i]=min(f[i],f[j]+f[i^j]);\n\t }\n\tcout<<ans+f[all]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    //cout<<b<<\":\"<<dp[b]<<endl;\n    for(Int i=0;i<16;i++){      \n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\t//cout<<i<<\"@\"<<j<<endl;\n\tif(i&j){\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^(i&j));\n\t  fix(j^(i&j));\n\t  if(calc(nb)>=calc(b)) continue;\n\t  //assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" ::: \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n\t{\n\t  Int dif=max(bc[i]-1,bc[j]-1)-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^j);\n\t  fix(0);\n\t  if(calc(nb)>=calc(b)) continue;\n\t  //assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" *** \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n      }\n    }\n  }\n  \n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\nconst ll MOD=1e9+7;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvv<pii> g(n);\n\tvector<int> cs(n);\n\trep(i,n-1){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tg[x].eb(y,z);\n\t\tg[y].eb(x,z);\n\t\tcs[x]^=z;\n\t\tcs[y]^=z;\n\t}\n\tout(cs,1);\n\tvector<int> cnt(16);\n\tfor(int c:cs) ++cnt[c];\n\tint rem=0;\n\tint re=0;\n\treps(i,1,16){\n\t\tre+=cnt[i]/2;\n\t\tif(cnt[i]%2) rem|=1<<i;\n\t}\n\tvector<ll> dp(1<<16);\n\treps(i,1,1<<16){\n\t\tint s=0;\n\t\trep(j,16)if(i>>j&1) s^=j;\n\t\tif(s){\n\t\t\tdp[i]=MOD;\n\t\t}else{\n\t\t\tdp[i]=__builtin_popcount(i)-1;\n\t\t}\n\t}\n\treps(i,1,1<<16)for(int j=i; j<(1<<16); j=(j+1)|i){\n\t\tMN(dp[j], dp[i]+dp[j^i]);\n\t}\n\tcout<<re+dp[rem]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// }}}\n// #include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint n;\nconst int N = 1e5;\nint v[N];\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int x, y, a;\n    cin >> x >> y >> a;\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n  int cnt[16] = {};\n  for(int i = 0; i < n; i++) cnt[v[i]]++;\n  int ans = 0;\n  int s = 0;\n  for(int i = 1; i < 16; i++) ans += cnt[i] / 2, cnt[i] &= 1, s |= cnt[i] << (i - 1);\n\n  int popcount[1 << 15] = {};\n  int ok[1 << 15] = {};\n\n  for(int i = 1; i < 1 << 15; i++) popcount[i] = popcount[i >> 1] + (i & 1);\n  for(int i = 1; i < 1 << 15; i++) { // O(2^15 * 15)\n    int sum = 0;\n    for(int j = 1; j <= 15; j++) if(i & (1 << (j - 1))) {\n      sum ^= j;\n    }\n    ok[i] = sum == 0;\n  }\n  \n  // é¨åéåã«å¯¾ããbitDP O(3^15)\n  int dp[1 << 15] = {};\n  for(int i = 1; i < 1 << 15; i++) {\n    dp[i] = 1e9;\n    for(int j = i; j > 0; j = (j - 1) & i) if((s & j) == j) if(ok[j]) {\n      dp[i] = min(dp[i], dp[i^j] + popcount[j] - 1);\n    }\n  }\n\n  cout << ans + dp[s] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXBITS=4;\nvoid printmask(int mask) { printf(\"[\"); bool fst=true; FOR(j,1,1<<MAXBITS) if(mask&(1<<j)) { if(fst) fst=false; else printf(\",\"); printf(\"%d\",j); } printf(\"]\"); }\n\nint n;\nvector<pair<int,int> > adj[MAXN];\n\npair<int,int> solve(int at,int par) {\n\tpair<int,int> ret=MP(0,0);\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i].first; if(to==par) continue;\n\t\tpair<int,int> cur=solve(to,at);\n\t\tret.first+=cur.first;\n\t\tint sum=adj[at][i].second;\n\t\tFOR(j,1,1<<MAXBITS) if(cur.second&(1<<j)) {\n\t\t\tsum^=j;\n\t\t\tif(ret.second&(1<<j)) ++ret.first;\n\t\t\tret.second^=1<<j;\n\t\t}\n\t\tif(sum!=0) {\n\t\t\tif(ret.second&(1<<sum)) ++ret.first;\n\t\t\tret.second^=1<<sum;\n\t\t}\n\t}\n\t//printf(\"%d: %d,\",at,ret.first); printmask(ret.second); puts(\"\");\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n-1) { int a,b,c; scanf(\"%d%d%d\",&a,&b,&c); adj[a].PB(MP(b,c)); adj[b].PB(MP(a,c)); }\n\n\tpair<int,int> res=solve(0,-1);\n\tint ans=res.first,mask=res.second;\n\tREP(i,MAXBITS) {\n\t\tint fst=-1;\n\t\tFOR(j,1,1<<MAXBITS) if(mask&(1<<j)) if(j&(1<<i)) { if(fst==-1) fst=j; else mask^=1<<(j^fst); }\n\t\tif(fst!=-1) ++ans;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define LINF 1000000000000000000\n#define MOD 1000000007\n#define mod 1000007\n#define INF63 1061109567\n#define INF127 9187201950435737471\n#define F first\n#define S second\n#define ll long long\n#define N 100010\n#define M 20\n#define NM 70000\nusing namespace std;\nint n,m,val[N],tms[M],v=0,ans=0,dp[NM];\nbool can[NM]={};\nint main(){\n\tint i,j,x,y,z;\n\tcin>>n;\n\tmemset(tms,0,sizeof(tms));\n\tmemset(val,0,sizeof(val));\n\tfor(i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y>>z;\n\t\tval[x]^=z;\n\t\tval[y]^=z;\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\ttms[val[i]]++;\n\t}\n\tans+=tms[0];\n\tfor(i=1;i<16;i++)\n\t{\n\t\tif(tms[i]%2==1)\n\t\t{\n\t\t\tv+=(1<<i);\n\t\t}\n\t\tans+=tms[i]/2;\n\t}\n\tfor(i=0;i<(1<<16);i++)\n\t{\n\t\tx=0;\n\t\tfor(j=1;j<16;j++)\n\t\t{\n\t\t\tif((i&(1<<j))!=0)\n\t\t\t{\n\t\t\t\tx^=j;\n\t\t\t}\n\t\t}\n\t\tif(x==0)\n\t\t{\n\t\t\tcan[i]=true;\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor(i=0;i<(1<<16);i++)\n\t{\n\t\tfor(j=i;j!=0;j=i&(j-1))\n\t\t{\n\t\t\tif(can[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tans+=dp[v];\n\tcout<<n-ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nint scan() {\n  int r = 0, c;\n  while ((c = getchar_unlocked()) >= '0')\n    r = r * 10 + c - '0';\n  return r;\n}\n\ninline bool test(const int x, const int y) noexcept { return x & 1 << y; }\n\nint main() {\n  const int n = scan();\n  std::vector<int> v(n, 0);\n  for (int i = 0; i != n - 1; i += 1) {\n    const int x = scan();\n    const int y = scan();\n    const int a = scan();\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n  int ans = n;\n  int b = 0;\n  for (const int e : v) {\n    if (e == 0) {\n      ans -= 1;\n      continue;\n    }\n    if (test(b, e))\n      ans -= 1;\n    b ^= 1 << e;\n  }\n  std::vector<int> dp(b / 2 + 1, -1);\n  dp[b / 2] = 0;\n  for (int s = b; s != 0; s -= 2) {\n    if (dp[s >> 1] == -1)\n      continue;\n    int i = 16;\n    while (i != 0) {\n      i -= 1;\n      if (test(s, i))\n        break;\n    }\n    for (int j = 0; j != i; j += 1) {\n      if (!test(s, j))\n        continue;\n      const int k = i ^ j;\n      if (k > j)\n        continue;\n      int &d = dp[(s ^ 1 << i ^ 1 << j ^ 1 << k) >> 1];\n      if (test(s, k))\n        d = std::max(d, dp[s >> 1] + 1);\n      else\n        d = std::max(d, dp[s >> 1]);\n    }\n  }\n  printf(\"%d\", ans - dp[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1e9+7;\n\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint N, ans=0;\n\tint b[100005]={};\n\n\tcin >> N;\n\trep(i,N-1){\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tb[x] ^= a;\n\t\tb[y] ^= a;\n\t}\n\n\tint cnt[16]={};\n\trep(i,N) cnt[ b[i] ]++;\n\n\tint rest=0;\n\trep(i,15){\n\t\tans += cnt[i+1] / 2;\n\t\tif( cnt[i+1]%2 ) rest |= (1<<i);\n\t}\n\n\tint dp[1<<15];\n\tFill(dp, (int)INF);\n\tdp[0] = 0;\n\trep(k,1<<15){\n\t\tauto nex = [&](int h, int &mask){\n\t\t\th += 1;\n\t\t\twhile(h&mask) h += (h&mask);\n\t\t\treturn h;\n\t\t};\n\t\tfor(int h = nex(0,k); h < (1<<15); h=nex(h,k)){\n\t\t\tint sum = 0, cnt = 0;\n\t\t\trep(i,15) if(h & (1<<i)) sum ^= (i+1), cnt++;\n\t\t\tif( sum == 0 ) chmin(dp[k|h], dp[k] + cnt-1);\n\t\t}\n\t}\n\tans += dp[rest];\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n\nconst int MAXN = 100 * 1000 + 23, MXLA = 4 + 1;\n\n\n\n\nint n;\nvector<int> g[MXLA][MAXN];\nset<pii> s;\nbitset<MAXN> mark[MXLA];\n\n\nint dfs(int x, int v, int p = -1) {\n    vector<int> vec;\n    for (auto u : g[x][v])\n        if (u != p)\n            vec.push_back(dfs(x, u, v)); \n    for (int i = 0; i + 1 < vec.size(); i += 2)\n        s.insert({min(vec[i], vec[i + 1]), max(vec[i], vec[i + 1])});\n    if (vec.size() & 1)\n        return vec.back();\n    return v;\n}\n\n\n\n\n\n\n\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        for (int i = 0; i < MXLA; i++)\n            if (w & (1 << i))\n                g[i][v].push_back(u), g[i][u].push_back(v);\n    }\n    for (int i = 0; i < MXLA; i++)\n        for (int j = 0; j < n; j++)\n            if (!mark[i][j])\n                dfs(i, j);\n    cout << s.size();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint va[N];\nint num[20];\nint a[20],sz,b[1001000];\nint dp[1001000];\nint solve(int s)\n{\n\tif(dp[s]) return dp[s];\n\tdp[s]=1;\n\tfor(int i=s;i;)\n\t{\n\t\ti=(i-1)&s;\n        if(b[i]==0) dp[s]=max(dp[s],solve(i)+solve(s^i));\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tva[u]^=w; va[v]^=w;\n\t}\n\tfor(int i=0;i<n;++i) ++num[va[i]];\n\tint cnt=num[0];\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tcnt+=num[i]/2;\n\t\tif(num[i]&1) a[sz++]=i;\n\t}\n\tfor(int s=0;s<(1<<sz);++s)\n\t\tfor(int i=0;i<sz;++i)\n\t\t\tif(s>>i&1)\n\t\t\t\tb[s]^=a[i];\n\tcnt+=solve((1<<sz)-1);\n\tprintf(\"%d\\n\",n-cnt+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<ctime>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cctype>\n#include<cstdlib>\n#include<utility>\n#include<bitset>\n#include<set>\n#include<map>\n#include<stack>\n#include<iomanip>\n#define INF 1000000010\n#define ll long long\n#define min(x,y) ((x)>(y)?(y):(x))\n#define max(x,y) ((x)>(y)?(x):(y))\n#define db double\n#define EPS 1e-5\nusing namespace std;\nchar *fs,*ft,buf[1<<15];\ninline char getc()\n{\n\treturn (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;\n}\ninline int read()\n{\n    int x=0,f=1;char ch=getc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}\n    return x*f;\n}\nconst int MAXN=100010,maxn=20;\nint n,top;\nint a[MAXN],b[maxn],c[maxn];\nint ans;\nint f[1<<maxn];\ninline int calc(int x)\n{\n\tint cnt=0,last=0;\n\tfor(int i=1;i<=top;++i)\n\t{\n\t\tif(x&(1<<(i-1)))\n\t\t{\n\t\t\tif(last)\n\t\t\t{\n\t\t\t\tlast=last^c[i];\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\telse last=c[i];\n\t\t}\n\t}\n\tif(last)return INF;\n\treturn cnt;\n}\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint x,y,z;\n\t\tx=read()+1;y=read()+1;z=read();\n\t\ta[x]^=z;a[y]^=z;\n\t}\n\tfor(int i=1;i<=n;++i)++b[a[i]];\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tans+=b[i]>>1;\n\t\tb[i]=b[i]&1;\n\t\tif(b[i])c[++top]=i;\n\t}\n\tmemset(f,0x3f,sizeof(f));f[0]=0;\n\tfor(int i=1;i<(1<<top);++i)\n\t{\n\t\tf[i]=calc(i);\n\t\tfor(int s=i;s;s=i&(s-1))\n\t\t\tf[i]=min(f[i],f[s]+f[s^i]);\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<top)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 100010;\nconst ll maxa = 15;\n\nll n, A[maxn], B[maxa + 1], dp[1 << maxa], val[1 << maxa], bt[1 << maxa];\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    // ifstream cin(\".in\");\n\n    cin >> n;\n    fori (i, n - 1) {\n        ll a, b, c; cin >> a >> b >> c;\n        A[a] ^= c, A[b] ^= c;\n    }\n    fori (i, n) ++B[A[i]];\n    ll cm = B[0];\n    ll mask = 0;\n    fori (i, maxa) {\n        cm += B[i + 1] >> 1;\n        if (B[i + 1] & 1) mask ^= 1 << i;\n    }\n\n    fori (i, maxa) bt[1 << i] = i + 1;\n    forifrom (i, 1, 1 << maxa) {\n        ll lb = i & -i;\n        val[i] = val[i ^ lb] ^ bt[lb];\n    }\n    forifrom (i, 1, 1 << maxa) {\n        for (ll j = i; j; j = (j - 1) & i) {\n            smax(dp[i], dp[i ^ j] + (val[j] == 0));\n        }\n    }\n\n    cm += dp[mask];\n    cout << n - cm << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nint A[MAXN], C[16], DP[1 << 16];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = 0;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tREP(i, n)\n\t\t++C[A[i]];\n\tFOR(i, 1, 16)\n\t{\n\t\tans += C[i] >> 1;\n\t\tC[i] &= 1;\n\t}\n\tFOR(i, 1, 1 << 16)\n\t\tDP[i] = INF;\n\tDP[0] = DP[1] = 0;\n\tFOR(mask, 1, 1 << 16)\n\t{\n\t\tRFOR(pos, 16, 1)\n\t\t{\n\t\t\tif (mask & (1 << pos))\n\t\t\t\tFOR(submask, 1, pos)\n\t\t\t{\n\t\t\t\tint cur = bool(mask & (1 << submask));\n\t\t\t\tcur += bool(mask & (1 << (pos ^ submask)));\n\t\t\t\tDP[mask] = min(DP[mask],\n\t\t\t\t\tcur + DP[mask ^ (1 << pos) ^ (1 << submask) ^ (1 << (pos ^ submask))]);\n\t\t\t}\n\t\t}\n\t}\n\tint mask = 0;\n\tREP(i, 16)\n\t\tif (C[i] & 1)\n\t\t\tmask |= (1 << i);\n\tcout << ans + DP[mask];\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint valid(int mask){\n    int res = 0;\n    for(int i=0;i<15;i++) if(mask&(1<<i)) res ^= i+1;\n    return res == 0;\n}\n\nint main(){\n    int N; cin >> N;\n    vector<int> v(N, 0);\n    for(int i=0;i<N-1;i++){\n        int a, b, c; cin >> a >> b >> c;\n        v[a] ^= c;\n        v[b] ^= c;\n    }\n    int res = 0;\n    vector<int> cnt(15, 0);\n    for(auto& t : v){\n        if(t == 0) continue;\n        cnt[t-1]++;\n    }\n    for(auto& t : cnt){\n        res += t/2;\n        t %= 2;\n    }\n    vector<int> dp(1<<15, 0);\n    for(int i=1;i<(1<<15);i++){\n        if(!valid(i)) continue;\n        for(int j=i;j;j=i&(j-1)){\n            if(j != i && valid(j)){\n                dp[i] = max(dp[i], dp[j] + dp[i^j] + 1);\n            }\n        }\n    }\n    int c = 0;\n    int m = 0;\n    for(int i=0;i<15;i++){\n        if(!cnt[i]) continue;\n        m |= (1<<i);\n        c++;\n    }\n    if(m) res += c - 1 - dp[m];\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200010\nint n,va[N],c[N],ans,s,f[N],ss[N],nm[N];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<N;i++)\n\t\tnm[i]=nm[i-(i&-i)]+1;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tva[x]^=z;\n\t\tva[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[va[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]%2==1)s|=(1<<(i-1));\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))ss[i]^=(j+1);\n\tmemset(f,63,sizeof(f));\n\tfor(int i=1;i<(1<<15);i++)\n\t\tif(!ss[i]){\n\t\t\tf[i]=nm[i]-1;\n\t\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\t\tif(!ss[j]&&!ss[i-j])\n\t\t\t\t\tf[i]=min(f[i],f[i-j]+f[j]);\n\t\t}\n\tcout<<ans+f[s];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][20][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 20) return 1e9;\n    if(tidx == 4 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n\nint N, X[100000];\nint dp[1 << 16];\nint ok[1 << 16];\n\nint rec(int bit) {\n  if(~dp[bit]) return dp[bit];\n  int ret = ok[bit];\n  for(int i = bit; i > 0; i = (i - 1) & bit) {\n    if(i == bit) continue;\n    int other = i ^bit;\n    ret = min(ret, rec(i) + rec(other));\n  }\n  return dp[bit] = ret;\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    X[x] ^= z;\n    X[y] ^= z;\n  }\n  int bit = 0, ret = 0;\n  for(int i = 0; i < N; i++) {\n    if(X[i] == 0) continue;\n    if(bit & (1 << X[i])) ++ret;\n    bit ^= 1 << X[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  for(int i = 1; i < (1 << 16); i++) {\n    ok[i] = ok[i >> 1] + 1;\n    int v = 0;\n    for(int j = 0; j < 16; j++) {\n      if((i >> j) & 1) v ^= j;\n    }\n    if(v == 0) --ok[i];\n  }\n  cout << ret + rec(bit) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint main() {\n    int n;\n    cin >> n;\n\n    VI x(n);\n    REP(i,n-1){\n        int p, q, a;\n        scanf(\"%d %d %d\", &p, &q, &a);\n        x[p] ^= a;\n        x[q] ^= a;\n    }\n\n    VI a, c(16);\n    REP(i,n){\n        c[x[i]]++;\n    }\n\n    int ans = 0;\n    FOR(i,1,15){\n        ans += c[i] / 2;\n        if (c[i] % 2) a.push_back(i);\n    }\n\n    int m = a.size();\n    // REP(i,m) cout << a[i]<< endl;\n\n\n    VI dp(1<<m, -1);\n    FOR(mask,1,(1<<m)-1){\n        int s = 0;\n        REP(i,m) if ((mask >> i) & 1) s ^= a[i];\n        // cout << s << endl;\n        if (s) continue;\n        dp[mask] = 1;\n        for (int i = mask; i > 0; i = (mask & (i - 1))){\n            if (i == mask) continue;\n            s = 0;\n            REP(j,m) if ((i >> j) & 1) s ^= a[j];\n            if (s == 0){\n                dp[mask] = max(dp[mask], dp[i] + dp[mask]);\n            }\n        }\n    }\n\n    // REP(i,1<<m) cout << dp[i] << endl;\n\n    ans += m - dp[(1<<m)-1];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     âââââââââââ\n//                                                                   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                                                                ââââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬âââ\n//                                            âââââââââââ       âââ¬â¬â¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬ââ\n//                                      ââââââââââ¬â¬â¬â¬â¬âââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬ââ\n//                               âââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬ââ\n//                             âââââ¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//                           ââââ¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬ââââ¬â¬â¬â¬â¬â¬â¬âââââ\n//                         ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââââââââ¬â¬â¬â¬â¬ââ\n//                       ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                     ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬ââ\n//                 âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬ââââ\n//     ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬ââââââ\n//   âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬ââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââ¬â¬â¬ââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬ââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââââ¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬â¬â¬âââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬âââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââ\n//   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//       ââââââââââââââ  âââââ¬â¬â¬â¬â¬â¬ââââââââââââââââââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ\n//                         âââââââ                           âââââ  âââââââââââââââââââ  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n,0);\n  REP(_,n-1){\n    int x,y,v;\n    cin >> x >> y >> v;\n    a[x] ^= v;\n    a[y] ^= v;\n  }\n  \n  vec b(16,0);\n  REP(i,n) b[a[i]]++;\n\n  int ans = 0;\n  REP(i,16){\n    if(i) ans += b[i]/2;\n  }\n\n  vec dp(1<<15,INF); dp[0] = 0;\n  int mask = 0;\n  REP(i,15) if(b[i+1]&1) mask += (1<<i);\n  \n  REP(i,1<<15){\n    int x = mask & (~i);\n    for(;x>=0;x--){\n      x &= mask; int cnt = 0;\n      REP(k,15) if(parity(x,k)) cnt ^= k+1;\n      if(!cnt) chmin(dp[i+x],dp[i]+1); \n    }\n  }\n\n  cout << ans - dp[mask] + pcnt(mask) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[32768];\nint gg[32768];\n\nint root = 0;\nint p[100001];\nint x[100001];\n\n\nvector< pair<int, int> > g[100001];\nint cnt[16];\n\nvoid dfs(int me){\n    for(auto &nxt: g[me]){\n        if(nxt.first == p[me]) continue;\n        p[nxt.first] = me;\n        x[nxt.first] = nxt.second;\n        dfs(nxt.first);\n        x[me] ^= nxt.second;\n    }\n    if(me > 0) cnt[x[me]]++;\n}\n\nint rec(int now){\n    if(~dp[now]) return dp[now];\n    int bst = 0;\n    for(int i=1;i<=15;i++){\n        if(now & (1 << (i-1))){\n            for(int j=1;j<=15;j++){\n                if(i == j) continue;\n                int nxt = now - (1 << (i-1));\n                nxt ^= (1 << (j-1));\n                nxt ^= (1 << ((i^j)-1));\n                if(gg[nxt] < gg[now]){\n                    if(gg[now] - gg[nxt] == 3){\n                        bst = max(bst, 1 + rec(nxt));\n                    }else{\n                        bst = max(bst, rec(nxt));\n                    }\n                }\n            }\n        }\n    }\n    dp[now] = bst;\n    //printf(\"%d %d\\n\", now, bst);\n    return bst;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        int aa, bb, cc;\n        scanf(\"%d%d%d\",&aa,&bb,&cc);\n        g[aa].push_back({bb, cc});\n        g[bb].push_back({aa, cc});\n    }\n    p[0] = 0;\n    dfs(0);\n    int ans = 0;\n    for(int i=0;i<32768;i++){\n        dp[i] = -1;\n        for(int j=0;j<15;j++){\n            if(i &(1 << j)) gg[i]++;\n        }\n    }\n    for(int i=1;i<16;i++){\n        ans += cnt[i] / 2;\n        root += (1 << (i-1)) * (cnt[i] % 2);\n    }\n    //printf(\"%d\\n\", root);\n    printf(\"%d\\n\", ans + gg[root] - rec(root));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\nusing namespace std;\nint n,x,y,z,ans,val[1<<(N+1)],cnt[N*2],dp[1<<N];\nvector<int>G[N*2];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++;y++;\n\t\tval[x]^=z;val[y]^=z;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,val[i]=cnt[i]%2;\n\tint now=0,tot=0;\n\tfor (int i=1;i<=15;i++) if (val[i]) now|=(1<<i),tot++;\n\tmemset(dp,127,sizeof(dp));int inf=dp[now];dp[now]=0;\n\tfor (int i=0;i<(1<<16);i++) G[__builtin_popcount(i)].push_back(i);\n\tfor (int i=tot;i;i--){\n\t\tfor (int j=0;j<(int)G[i].size();j++){\n\t\t\tint S=G[i][j];\n\t\t\tif (dp[S]==inf) continue;\n\t\t\tfor (int x=1;x<=15;x++){\n\t\t\t\tfor (int y=1;y<=15;y++){\n\t\t\t\t\tif (x==y||(!(S>>x&1))||(!(S>>y&1))) continue;\n\t\t\t\t\tint tmp=x^y;\n\t\t\t\t\tint S1=S^(1<<x)^(1<<y);\n\t\t\t\t\tif (S1&(1<<tmp)) dp[S1^(1<<tmp)]=min(dp[S1^(1<<tmp)],dp[S]+2);\n\t\t\t\t\telse dp[S1|(1<<tmp)]=min(dp[S1|(1<<tmp)],dp[S]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<inf<<endl;\n\tprintf(\"%d\\n\",min(dp[1],dp[0])+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n#define fillZero(a) memset((a), 0,  sizeof(a))\n#define fillINF(a) memset((a), 0x3f, sizeof(a)) // 3f3f3f3f = 1,061,109,567 < 2^30\n#define all(a) (a).begin(), (a).end()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n\nclass Edge {\npublic:\n\tvirtual int from() const = 0;\n\tvirtual int to() const = 0;\n\tvirtual Edge* reversedEdge() = 0;\n};\n\ntypedef int EdgeWeight;\nclass SimpleEdge : public Edge {\n\tint from_, to_;\n\tEdgeWeight weight_;\npublic:\n\tSimpleEdge(int from,int to,EdgeWeight weight_) : from_(from), to_(to), weight_(weight_) {}\n\tstatic SimpleEdge* createFromInput(){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\treturn new SimpleEdge(a,b,w);\n\t}\n\tint to() const { return to_; }\n\tint from() const { return from_; } \n\tint weight() const { return weight_; }\n\tSimpleEdge* reversedEdge(){\n\t\treturn new SimpleEdge(to_, from_, weight_);\n\t}\n};\n\nclass Graph {\npublic:\n\tvirtual vector<Edge*> *connectedEdges(int v) = 0;\n\tvirtual void addEdge(Edge *edge) = 0;\n};\n\nclass UndirectedGraph : public Graph {\nprivate:\n\tvector<Edge*> edges;\n\tvector< vector<Edge*> > graph;\npublic:\n\tUndirectedGraph(int n){\n\t\tgraph.resize(n);\n\t}\n\t\n\tsize_t size(){\n\t\treturn graph.size();\n\t}\n\n\tvoid addEdge(Edge *edge){\n\t\tedges.push_back(edge);\n\t\tassert(edge->from() < size());\n\t\tassert(edge->to() < size());\n\n\t\tgraph[edge->from()].push_back(edge);\n\t\tgraph[edge->to()].push_back(edge->reversedEdge());\n\t}\n\tvector<Edge*> *connectedEdges(int v){\n\t\treturn &graph[v];\n\t}\n\tvector<Edge*> *allEdges(){\n\t\treturn &edges;\n\t}\n};\n\n\nconst int N_MAX = 100010;\nbool canMakeZero(int bit){\n\tint tst = 0;\n\trep(i,16) if( bit >> i & 1 ) tst ^= bit;\n\treturn tst == 0;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tUndirectedGraph g(n);\n\tfor(int i = 0 ; i < n - 1 ; i++){\n\t\tg.addEdge(SimpleEdge::createFromInput());\n\t}\n\t\n\tint vXors[N_MAX] = {};\n\tfor( auto e : *g.allEdges() ){\n\t\tvXors[e->from()] ^= ((SimpleEdge*)e)->weight();\n\t\tvXors[e->to()] ^= ((SimpleEdge*)e)->weight();\n\t}\n\tint freq[16] = {};\n\trep(i,g.size()){\n\t\tfreq[vXors[i]]++;\n\t}\n\tint baseAnswer = 0;\n\tint freqBit = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tbaseAnswer += freq[i] / 2;\n\t\tfreqBit |= (freq[i]%2) << i;\n\t}\n\n\tint dp[1<<16];\n\tfillINF(dp);\n\tdp[0] = 0;\n\tfor(int i = 0 ; i <= freqBit ; i+=2){\n\t\tint j = i;\n\t\twhile(j){\n\t\t\tif( canMakeZero(j) ){\n\t\t\t\tdp[i] = min(dp[i], dp[i^j] + popcount(j) - 1);\n\t\t\t}\n\t\t\tj = (j-1) & i;\n\t\t}\n\t\tfor(int k = 1 ; k < 16 ; k++){\n\t\t\tif( i >> k & 1 ){\n\t\t\t\tdp[i] = min(dp[i], dp[i^(1<<k)] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[freqBit] + baseAnswer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, B, w, x[100005], c[16], ans, p3[20];\nint dp[15000000], y[15000000], z[15000000];\nbool f[15000000]={1};\nvector<int> r;\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            if (dp[l]<0) continue;\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                    y[l+p3[l2]]=y[l]^r[l2];\n                    z[l+p3[l2]]=z[l]+p3[l2];\n                }\n            }\n            if (y[l]==0 && !f[l]){\n                //cout << \"*\";\n                dp[l+z[l]]=max(dp[l+z[l]], dp[l]+1);\n                y[l+z[l]]=0;\n                z[l+z[l]]=0;\n                f[l+z[l]]=1;\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100005;\n\nvector<pii> KV;\n\nint B[16];\nint A[MAXN];\n\nint N, Ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tfor(int i = 1, a, b, c; i < N; i++) {\n\t\tcin >> a >> b >> c;\n\t\ta++; b++;\n\t\tA[a] ^= c;\n\t\tA[b] ^= c;\n\t}\n\tfor(int i = 1; i <= N; i++) B[A[i]]++;\n\n\tAns = B[0]; B[0] = 0;\n\tfor(int i = 1; i <= 15; i++) {\n\t\tAns += B[i]/2;\n\t\tB[i] &= 1;\n\t}\n\n\tint master = 0;\n\tfor(int i = 0; i < 15; i++) B[i] = B[i+1];\n\tfor(int i = 0; i < 15; i++) if(B[i]) master |= 1<<i;\n\n\tfor(int key = 1; key <= master; key++) {\n\t\tif((key & master) != key) continue;\n\t\tint sum = 0, cnt = 0;\n\t\tfor(int i = 0; i < 15; i++) if(key & (1<<i)) {\n\t\t\tcnt++; sum ^= i+1;\n\t\t}\n\t\tif(sum) continue;\n\t\tKV.eb(cnt, key);\n\t}\n\n\tsorv(KV);\n\n\tint used = 0;\n\tfor(auto &p : KV) {\n\t\tif(used & p.second) continue;\n\t\tused |= p.second;\n\t\tAns++;\n\t}\n\n\tcout << (N - Ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        A[u]^=to.se;\n    }\n}\n\nint dp[1<<16];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=0;i<(1<<16);i++){\n        dp[i]=INF;\n    }\n    int rem=1;\n    for(int i=1;i<16;i++){\n        if(!cnt[i]){\n            rem^=(1<<i);\n        }\n    }\n    \n    dp[rem]=0;\n    \n    for(int bit=0;bit<(1<<16);bit++){\n        if(dp[bit]==INF) continue;\n        int S=(1<<16)-1-bit;\n        for(int mask=S;;mask=(mask-1)&S){\n            if(mask==0) break;\n            int sum=0;\n            for(int i=0;i<16;i++){\n                if(mask&(1<<i)) sum^=i;\n            }\n            if(sum==0) chmin(dp[bit^mask],dp[bit]+__builtin_popcount(mask)-1);\n            else chmin(dp[bit^mask],dp[bit]+__builtin_popcount(mask));\n        }\n    }\n    \n    cout<<ans+dp[(1<<16)-1]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nconst int N=100010;\n\nvpii e[N];\nbool v[N];\nint s,a[N],d[1<<16],q[1<<16],b[16];\n\nvoid dfs(int k,int x)\n{\n\tv[k]=1;int t=x;a[k]=0;\n\tfor (vpii::iterator p=e[k].begin();p!=e[k].end();p++)\n\t\tif (!v[p->x])\n\t\t{\n\t\t\tdfs(p->x,p->y);t^=p->y;a[k]^=a[p->x];\n\t\t}\n\tif (t) {s++;a[k]^=(1<<(t-1));}\n}\n\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\te[x].pb(mp(y,z));e[y].pb(mp(x,z));\n\t}\n\tv[0]=1;s=0;a[0]=0;\n\tfor (vpii::iterator p=e[0].begin();p!=e[0].end();p++)\n\t{\n\t\tdfs(p->x,p->y);a[0]^=a[p->x];\n\t}\n\tint f=1,r=1;q[1]=a[0];\n\tfor (int i=0;i<(1<<15);i++) d[i]=16;d[a[0]]=0;\n\twhile (f<=r)\n\t{\n\t\tint x=q[f++],p=0;\n\t\tfor (int i=0;i<15;i++) if (x&(1<<i)) b[p++]=i;\n\t\tfor (int i=0;i<p;i++)\n\t\t\tfor (int j=i+1;j<p;j++)\n\t\t\t\tif (d[x^(1<<b[i])^(1<<b[j])^(1<<((b[i]+1)^(b[j]+1)-1))]==16)\n\t\t\t\t{\n\t\t\t\t\tq[++r]=x^(1<<b[i])^(1<<b[j])^(1<<((b[i]+1)^(b[j]+1)-1));d[q[r]]=d[x]+1;\n\t\t\t\t}\n\t}\n\tint t=0;\n\tfor (int i=0;i<15;i++) if (a[0]&(1<<i)) t++;\n\tprintf(\"%d\\n\",(s-t)/2+d[0]+(t-d[0])/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],f[N],cnt[20],res,n,st,sxr[N],S;\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);rp(i,1,n-1)--f[i];\n\trp(i,1,S){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n\trp(i,1,S)\n\t{\n\t\tif(!sxr[i])for(int k=(i-1)&i;k;k=(k-1)&i)if(!sxr[k])f[i]=min(f[i],f[k]+f[i^k]);\n\t}\n\tprintf(\"%d\",res+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][20][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 50) return 1e9;\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if(tmp < tcnt || (tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\nconst int maxn = 1e5 + 42;\n\nvector<pair<int, int>> g[maxn];\n\nvoid make_edge(int u, int v, int c) {\n    g[u].push_back({v, c});\n    g[v].push_back({u, c});\n}\n\nint xr[4 * maxn];\n\nint get(int a, int b, int v = 1, int l = 0, int r = maxn) {\n    if(a <= l && r <= b) {\n        return xr[v];\n    } else if(r <= a || b <= l) {\n        return 0;\n    } else {\n        int m = (l + r) / 2;\n        return get(a, b, 2 * v, l, m) ^ get(a, b, 2 * v + 1, m, r);\n    }\n}\n\nvoid upd(int p, int c, int v = 1, int l = 0, int r = maxn) {\n    xr[v] ^= c;\n    if(r - l == 1) {\n        return;\n    }\n    int m = (l + r) / 2;\n    if(p < m) {\n        upd(p, c, 2 * v, l, m);\n    } else {\n        upd(p, c, 2 * v + 1, m, r);\n    }\n}\n\nint z[maxn];\nint in[maxn], out[maxn], t;\nvoid dfs(int v, int p) {\n    in[v] = t++;\n    for(auto it: g[v]) {\n        int u = it.first;\n        int x = it.second;\n        if(u != p) {\n            dfs(u, v);\n            z[u] = x;\n        }\n    }\n    out[v] = t;\n}\n\nint deg[maxn];\n\nmap<vector<int>, int> ans;\nvector<int> zmasks;\nint solve(vector<int> &need) {\n    if(!ans.count(need)) {\n        int res = accumulate(begin(need), end(need), 0);\n        for(auto it: zmasks) {\n            int t = 1e6;\n            for(int i = 0; i < 16; i++) {\n                if((it >> i) & 1) {\n                    t = min(t, need[i]);\n                }\n            }\n            for(int i = 0; i < 16; i++) {\n                if((it >> i) & 1) {\n                    need[i] -= t;\n                }\n            }\n            if(t) {\n                res = min(res, solve(need) + t * (__builtin_popcount(it) - 1));\n            }\n            for(int i = 0; i < 16; i++) {\n                if((it >> i) & 1) {\n                    need[i] += t;\n                }\n            }\n        }\n        ans[need] = res;\n    }\n    return ans[need];\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    int x[n - 1], y[n - 1], a[n - 1];\n    for(int i = 0; i < n - 1; i++) {\n        cin >> x[i] >> y[i] >> a[i];\n        make_edge(x[i], y[i], a[i]);\n    }\n    dfs(0, 0);\n    deque<int> que;\n    for(int i = 1; i < n; i++) {\n        deg[i] = g[i].size();\n        if(deg[i] == 1) {\n            que.push_back(i);\n        }\n    }\n    vector<int> need(16);\n    while(!que.empty()) {\n        int v = que.front();\n        que.pop_front();\n        deg[v]--;\n        for(auto it: g[v]) {\n            int u = it.first;\n            if(u > 0 && deg[u] > 0) {\n                deg[u]--;\n                if(deg[u] == 1) {\n                    que.push_back(u);\n                }\n            }\n        }\n        int t = get(in[v], out[v]);\n        need[t ^ z[v]]++;\n        upd(in[v], t ^ z[v]);\n    }\n    need[0] = 0;\n    int mask_sz = 1 << 16;\n    int zero[mask_sz];\n    memset(zero, 0, sizeof(zero));\n    for(int mask = 2; mask < mask_sz; mask += 2) {\n        int cur = 0;\n        for(int i = 0; i < 16; i++) {\n            if((mask >> i) & 1) {\n                cur ^= i;\n            }\n        }\n        zero[mask] = cur == 0;\n        for(int sub = mask & (mask - 1); sub; sub = (sub - 1) & mask) {\n            if(zero[sub]) {\n                zero[mask] = 0;\n                break;\n            }\n        }\n        if(zero[mask]) {\n            zmasks.push_back(mask);\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < 16; i++) {\n        ans += need[i] / 2;\n        need[i] %= 2;\n    }\n    cout << ans + solve(need) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 1e5 + 100; \nconst int maxm = 1 << 15 + 10;  \n\nint n, ans, state, tot; \nint val[maxn], cnt[20], f[maxm], s[maxn], sum[maxm]; \n// sumè¡¨ç¤ºæ¯ä¸ªéåçå¼æå¼\nint main() {\n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z; \n\t\tscanf(\"%d%d%d\", &x, &y, &z); \n\t\tx++, y++; \n\t\tval[x] ^= z, val[y] ^= z; \n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[val[i]]++; \n\tans = n; ans -= cnt[0]; \n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans -= cnt[i] / 2 ; \n\t\tstate += (cnt[i] & 1) * (1 << i); \n\t}\n\ttot = 1 << 15; \n\tfor (int i = 1; i < tot; ++i) {\n\t\tint tmp = 0; \t\n\t\tfor (int j = 1; j <= 15; ++j) {\n\t\t\tif ((i >> j) & 1) tmp ^= j; \n\t\t}\n\t\tsum[i] = tmp; \n\t}\n\tfor (int i = 1; i < tot; ++i) {\n\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\tif (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1); \n\t\t}\n\t}\n\tans -= f[state]; \n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22],lg[66666];\nint f[66666],q[66666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tint ans=0;\n\tfor(register int i=2,j=1;i<65536;i<<=1,++j)lg[i]=j;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])++w;//w|=1<<i;\n\tf[w]=0;\n\tfor(q[hq=1]=w,tq=2;hq!=tq;++hq)\n\t{\n\t\tint o=q[hq];\n\t\tint l=lg[o&-o];\n\t\tfor(register int i=l+1;i<16;++i)\n\t\t\tif(o&1<<i)\n\t\t\t{\n\t\t\t\tint t=o^1<<l^1<<i^1<<(l^i);\n\t\t\t\tt&=~1;\n\t\t\t\tif(f[t]>33333)f[t]=f[o]+1,q[tq++]=t;\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[0]); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint va[N];\nint num[20];\nint a[20],sz,b[1001000];\nint dp[1001000];\nint solve(int s)\n{\n\tif(dp[s]) return dp[s];\n\tdp[s]=1;\n\tfor(int i=s;i>1;)\n\t{\n\t\ti=(i-1)&s;\n        if(b[i]==0) dp[s]=max(dp[s],solve(i)+solve(s^i));\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tva[u]^=w; va[v]^=w;\n\t}\n\tfor(int i=0;i<n;++i) ++num[va[i]];\n\tint cnt=num[0];\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tcnt+=num[i]/2;\n\t\tif(num[i]&1) a[sz++]=i;\n\t}\n\tfor(int s=0;s<(1<<sz);++s)\n\t\tfor(int i=0;i<sz;++i)\n\t\t\tif(s>>i&1)\n\t\t\t\tb[s]^=a[i];\n\tif(sz)cnt+=solve((1<<sz)-1);\n\tprintf(\"%d\\n\",n-cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\næ°æ®ä¸æ¸ç©ºï¼çé¶ä¸¤è¡æ³ªã\nå¤æµä¸è¯»å®ï¼çé¶ä¸¤è¡æ³ªã\nè¾¹çä¸ç¹å¤ï¼çé¶ä¸¤è¡æ³ªã\nè´ªå¿ä¸è¯æï¼çé¶ä¸¤è¡æ³ªã\nD P é¡ºåºéï¼çé¶ä¸¤è¡æ³ªã\nå¤§å°å°ç­å·ï¼çé¶ä¸¤è¡æ³ªã\nåéä¸ç»ä¸ï¼çé¶ä¸¤è¡æ³ªã\nè¶çä¸å¤æ­ï¼çé¶ä¸¤è¡æ³ªã\nè°è¯ä¸æ³¨éï¼çé¶ä¸¤è¡æ³ªã\næº¢åºä¸ l lï¼çé¶ä¸¤è¡æ³ªã\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nconst int inf=0x3f3f3f3f;\nint lowbit(int x){return x&-x;}\nint ppc(int x){return __builtin_popcount(x);}\nconst int N=100000;\nint n;\nvector<pair<int,int> > nei[N+1];\nint buc[16];\nint dfs(int x=1,int fa=0){\n\tint xsm=0;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i].X,v=nei[x][i].Y;\n\t\tif(y==fa)continue;\n\t\txsm^=v;\n\t\tbuc[dfs(y,x)^v]++;\n\t}\n\treturn xsm;\n}\nint dp[1<<15];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tx++;y++;\n\t\tnei[x].pb(mp(y,z));nei[y].pb(mp(x,z));\n\t}\n\tdfs();\n\tfor(int i=1;i<1<<15;i++){\n\t\tdp[i]=ppc(i);\n\t\tint xsm=0;\n\t\tfor(int j=1;j<=15;j++)if(i&1<<j-1)xsm^=j;\n\t\tif(!xsm)dp[i]=ppc(i)-1;\n\t\tfor(int j=i-1&i;j;j=j-1&i)dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tint ans=0,msk=0;\n\tfor(int i=1;i<=15;i++)ans+=buc[i]>>1,msk|=(buc[i]&1)<<i-1;\n\tcout<<ans+dp[msk];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1000000000\n\n\n\nint main(){\n\t\n\tint N;\n\tcin>>N;\n\t\n\tvector<vector<int>> E(N,vector<int>());\n\t\n\tfor(int i=0;i<N-1;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tE[a].push_back(c);\n\t\tE[b].push_back(c);\n\t}\n\t\n\tint last = -1;\n\tvector<int> cnt(16,0);\n\t\n\tfor(int i=0;i<N;i++){\n\t\tif(E[i].size()==1){\n\t\t\tif(last==-1){\n\t\t\t\tlast = E[i][0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tint t=  0;\n\t\tfor(int j=0;j<E[i].size();j++)t^=E[i][j];\n\t\t//cout<<t<<endl;\n\t\tcnt[t]++;\n\t}\n\n\tfor(int i=0;i<16;i++){\n\t\t//cout<<cnt[i]<<endl;\n\t\tlast ^= (cnt[i]%2)*i;\n\t}\n//cout<<last<<endl;\n\tcnt[last]++;\n\t\n\tvector<int> calc(1<<16,0);\n\t\n\tfor(int i=0;i<(1<<16);i++){\n\t\tint t = 0;\n\t\tfor(int j=0;j<16;j++){\n\t\t\tif((i>>j)&1)t^=j;\n\t\t}\n\t\tcalc[i] = t;\n\t}\n\t/*\n\tfor(int i=0;i<cnt.size();i++){\n\t\tcout<<cnt[i]<<endl;\n\t}\n\t*/\n\t\n\t\n\tvector<vector<int>> dp(16,vector<int>(1<<16,Inf));\n\tdp[0][0] = 0;\n\t\n\tfor(int i=0;i<15;i++){\n\t\tfor(int j=0;j<(1<<16);j++){\n\t\t\tif(dp[i][j]==Inf)continue;\n\t\t\tint cost=  dp[i][j];\n\t\t\tcost += cnt[i+1]/2;\n\t\t\tif(cnt[i+1]%2==0){\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j],cost);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint S = j;\n\t\t\t\t//cost++;\n\t\t\t\tfor(int T = j;true;T=((T-1)&S)){\n\t\t\t\t\tint k = (i+1)^calc[T];\n\t\t\t\t\t\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tdp[i+1][S^T] = min(dp[i+1][S^T],cost);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i+1][S^T^(1<<k)] = min(dp[i+1][S^T^(1<<k)],cost+1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(T==0)break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<16;i++){\n\t\tfor(int j=0;j<9;j++){\n\t\t\tcout<<dp[i][j]<<',';\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\t\n\tint ans = Inf;\n\tfor(int i=0;i<(1<<16);i++){\n\t\tint c = 0;\n\t\tfor(int j=0;j<16;j++){\n\t\t\tif((i>>j)&1)c++;\n\t\t}\n\t\tc=0;\n\t\t//if(dp.back()[i]!=Inf)cout<<i<<endl;\n\t\tans = min(ans,dp.back()[i]+c);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=100005;\nconst int p=1e9+7;\nint n,a[N];\nint tot[16];\n\ntemplate<class T> void read(T &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nvoid Add(int &x,int y){\n\tx+=y;\n\twhile(x>=p) x-=p;\n}\n\nint f[1<<16],sum[1<<16];\nint main(){\n\tread(n);\n\tint x,y,w;\n\tfr(i,2,n){\n\t\tread(x);read(y);read(w);\n\t\tx++;y++;\n\t\ta[x]^=w;a[y]^=w;\n\t}\n\tfr(i,1,n) tot[a[i]]++;\n\tint ans=0,all=0;\n\tfr(i,1,15) ans+=tot[i]/2,all^=(tot[i]&1)<<i;\n\tfr(i,1,all)\n\t if ((i&all)==i){\n\t \t//if ((i&(-i))==i){ f[i]=1;continue; }\n\t \tsum[i]=0;\n\t \tfr(j,0,15) if (i&(1<<j)) sum[i]^=j,f[i]++;\n\t \tif (sum[i]) continue;\n\t \tf[i]--;\n\t \tfor(int j=(i-1)&i;j;j=(j-1)&i)\n\t \t if (sum[j]==0) f[i]=min(f[i],f[j]+f[i^j]);\n\t }\n\tcout<<ans+f[all]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, w, x[100005], c[16], ans, p3[20];\nshort dp[15000000];\nvector<int> r;\ninline bool val(int B){\n    int C=0;\n    bool f=0;\n    fox(l, m){\n        if (B/p3[l]%3==1){\n            C^=r[l];\n            f=1;\n        }\n    }\n    return f && C==0;\n}\ninline int nxt(int B){\n    fox(l, m){\n        if (B/p3[l]%3==1) B+=p3[l];\n    }\n    return B;\n}\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            if (dp[l]<0) continue;\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                }\n            }\n            if (val(l)){\n                //cout << \"*\";\n                dp[nxt(l)]=max(dp[nxt(l)], short(dp[l]+1));\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct edge{\n\tint to,nxt,dis;\n}e[200101];\nint head[101010],tot,n;\ninline void made(int from,int to,ll dis){\n\te[++tot].to=to;e[tot].nxt=head[from];head[from]=tot;\n\te[tot].dis=dis;\n}\nint a[101010],b[100],f[201010],g[202020];\nvoid dfs(int u,int faa){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==faa) continue; \n\t\ta[v]=e[i].dis;\n\t\tdfs(v,u);\n\t\ta[u]^=a[v];\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tmade(x+1,y+1,z),made(y+1,x+1,z);\n\t\ta[x]^=z,a[y]^=z; \n\t}\n//\tdfs(1,0); \n\tint all=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]) b[a[i]-1]^=1,all^=(1<<(a[i]-1));\n\t}\n\tfor (int zt=1;zt<=all;zt++){\n\t\tbool flag=0;\n\t\tfor (int i=0;i<15;i++){\n\t\t\tif (((1<<i)&zt)&&(!b[i])){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t\telse if ((1<<i)&zt) g[zt]^=i+1;\n\t\t}\n\t\tif (!flag){\n\t\t\tf[zt]=__builtin_popcount(zt)-1;\n\t\t\tfor (int i=zt&(zt-1);i;i=zt&(i-1)){\n\t\t\t\tif (g[zt^i]|g[i]){\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[all];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <utility>\n#include <list>\n\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <bitset>\n#include <complex>\n#include <climits>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\ntypedef pair<double, double> dd;\ntypedef unsigned long long ull;\n#define mp make_pair\n#define pb push_back\n\n#define debug(x) cerr << #x << \" = \" << x << \" \"\n\nconst int N = 1e5;\nint val[N];\nconst int B = 4;\nconst int MB = 1<<4;\nconst int MMB = 1<<MB;\nint cnt[MB];\nint d[MMB];\nint bitvalue[MMB];\nint bitcnt[MMB];\nint main()\n{\n  int n; scanf(\"%d\", &n);\n  for (int i = 1; i <= n-1; ++i)\n    {\n      int u, v, x;\n      scanf(\"%d %d %d\", &u, &v, &x);\n      val[u] ^= x;\n      val[v] ^= x;\n    }\n  for (int i = 0; i < n; ++i) ++cnt[val[i]];\n  int ans = 0;\n  for (int i = 0; i < MB; ++i) bitvalue[1<<i] = i;\n  for (int i = 1; i < MB; ++i) ans += cnt[i]/2, cnt[i] %= 2;\n  for (int i = 1; i < MMB; ++i)\n    {\n      int lb = i&-i;\n      bitvalue[i] = bitvalue[i^lb] ^ bitvalue[lb];\n      bitcnt[i] = bitcnt[i>>1] + (i&1);\n      d[i] = MB;\n      for (int sub = i; sub; sub = (sub-1)&i)\n\tif (bitvalue[sub] == 0)\n\t  d[i] = min(d[i], bitcnt[sub] -1 + d[i^sub]);\n    }\n  int mask = 0;\n  for (int i = 1; i < n; ++i) mask ^= cnt[i] << i;\n  assert(bitvalue[mask] == 0);\n  printf(\"%d\\n\", d[mask] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing i64 = long long;\n\nstd::vector<std::vector<std::pair<int, int>>> g;\nint cnt[16];\n\nauto precalc() {\n    std::vector<int> ret(1 << 16);\n    for (int i = 1; i < (1 << 16); i++) {\n        int x = 0;\n        for (int j = 0; j < 16; j++) if (i & (1 << j)) x ^= j;\n        int max = !x;\n        for (int j = i; j > 0; j = (j - 1) & i) {\n            const int v = ret[j] + ret[j ^ i];\n            if (v > max) max = v;\n        }\n        ret[i] = max;\n    }\n    return ret;\n}\n\nvoid dfs(const int v, const int p, const int x) {\n    for (const auto &edge : g[v]) {\n        if (edge.first == p) continue;\n        const int nx = x ^ edge.second;\n        cnt[nx]++;\n        dfs(edge.first, v, nx);\n    }\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    g.resize(n);\n    for (int i = 1; i < n; i++) {\n        int u, v, a;\n        std::cin >> u >> v >> a;\n        g[u].emplace_back(v, a);\n        g[v].emplace_back(u, a);\n    }\n\n    const auto v = precalc();\n    dfs(0, -1, 0);\n\n    int ret = 0, mask = 0;\n    for (int i = 0; i < 16; i++) {\n        ret += cnt[i] / 2;\n        if (cnt[i] & 1) mask |= 1 << i;\n    }\n\n    std::cout << n - 1 - ret - v[mask] << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint ans,a[N],xx,y,v,n,cc[17],c[N],q;\ninline int dfs(int x){\n\tif(!x)return 0;\n\tif(c[x])return c[x];\n\tc[x]=999999;\n\tint i,j,k,r1,r2,uu=0,y;\n\tfor(i=1;i<=15;++i){\n\t\tuu+=((1<<i)&x)>0;\n\t}\n\tif(uu==1){\n\t\tc[x]=1;\n\t\treturn 1;\n\t}\n\tfor(i=1;i<=15;++i){\n\t\tif((1<<i)&x){\n\t\t\tfor(j=i+1;j<=15;++j){\n\t\t\t\tif((1<<j)&x){\n\t\t\t\t\tfor(k=1;k<=3;++k){\n\t\t\t\t\t\tuu=1;y=x;\n\t\t\t\t\t\tr1=j^k;r2=i^k;\n\t\t\t\t\t\ty-=(1<<j);\n\t\t\t\t\t\ty-=(1<<i);\n\t\t\t\t\t\tif(r1>0){\n\t\t\t\t\t\tif(((1<<r1)&y)){\n\t\t\t\t\t\t\ty-=(1<<r1);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(r2>0){\n\t\t\t\t\t\tif(((1<<r2)&y)){\n\t\t\t\t\t\t\ty-=(1<<r2);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc[x]=min(c[x],dfs(y)+uu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c[x];\n}\nint i;\nint main(){\n\tcin>>n;\n\tfor(i=1;i<n;++i){\n\t\tcin>>xx>>y>>v;\n\t\ta[xx]^=v;\n\t\ta[y]^=v;\n\t}\n\tfor(i=0;i<n;++i)++cc[a[i]];\n\tfor(i=1;i<=15;++i){\n\t\tans+=cc[i]/2;\n\t\tq+=((cc[i]&1)<<i);\n\t}\n\tcout<<ans+dfs(q);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=16;\nint n,a[M];\nvvp g;\n\nint dfs(int v,int pre){\n\tint res=0;\n\tfor(auto p:g[v]){\n\t\tint u=p.first,c=p.second;\n\t\tif(pre!=u){\n\t\t\tint t=c^dfs(u,v);\n\t\t\tif(t) a[t]++;\n\t\t\tres^=c;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvp(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tg[u].push_back({v,c});\n\t\tg[v].push_back({u,c});\n\t}\n\tdfs(0,-1);\n\tint t=0;\n\tvi b,c,dp;\n\tfor(int i=1;i<M;i++){\n\t\tt+=a[i]/2;\n\t\tif(a[i]%2==1) b.push_back(i);\n\t}\n\tn=b.size();\n\tint N=1<<n;\n\tc=dp=vi(N);\n\tfor(int i=0;i<N;i++) for(int j=0;j<n;j++) if(i&1<<j) c[i]^=b[j];\n\tfor(int i=1;i<N;i++){\n\t\tint j=i;\n\t\tdo{\n\t\t\tdp[i]=max(dp[i],dp[i-j]+(c[j]?0:1));\n\t\t\tj=(j-1)&i;\n\t\t}while(j);\n\t}\n\tcout<<t+n-dp[N-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[100010],N,t[20],S,ans,dp[1000010];\nvector<int>g[20];\nint main()\n{\n\tcin>>N;\n\tfor(int u,v,w,i=1;i<N;i++)scanf(\"%d%d%d\",&u,&v,&w),a[u]^=w,a[v]^=w;\n\tfor(int i=0;i<N;i++)t[a[i]]++;\n\tfor(int i=1;i<16;i++)ans+=t[i]/2,t[i]&=1;\n\tfor(int i=1;i<16;i++)S|=t[i]<<(i-1);\n\tfor(int i=0;i<=S;i++)\n\t{\n\t\tint s=0,x=i;\n\t\twhile(x){if(x&1)s++;x>>=1;}\n\t\tg[s].push_back(i);\n\t}\n\tmemset(dp,0x3f,sizeof(dp));dp[S]=0;\n\tfor(int p=16;p>=0;p--)\n\t{\n\t\tfor(int x=0,s;x<g[p].size();x++)\n\t\t{\n\t\t\ts=g[p][x];\n\t\t\tfor(int i=1;i<16;i++)if(s&(1<<(i-1)))for(int j=1;j<16;j++)if(s&(1<<(j-1))&&i!=j)\n\t\t\t{\n\t\t\t\tint a=i^j;\n\t\t\t\tif((1<<a)&s)dp[s-(1<<(i-1))-(1<<(j-1))-(1<<(a-1))]=min(dp[s-(1<<(i-1))-(1<<(j-1))-(1<<(a-1))],dp[s]+2);\n\t\t\t\telse dp[s-(1<<(i-1))-(1<<(j-1))+(1<<(a-1))]=min(dp[s-(1<<(i-1))-(1<<(j-1))+(1<<(a-1))],dp[s]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0]+ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing i64 = long long;\n\nstd::vector<std::vector<std::pair<int, int>>> g;\nint cnt[16];\n\nauto precalc() {\n    std::vector<int> ret(1 << 16);\n    for (int i = 1; i < (1 << 16); i++) {\n        if (i & 1) continue;\n        int x = 0;\n        for (int j = 0; j < 16; j++) if (i & (1 << j)) x ^= j;\n        int max = !x;\n        for (int j = i; j > 0; j = (j - 1) & i) {\n            const int v = ret[j] + ret[j ^ i];\n            if (v > max) max = v;\n        }\n        ret[i] = max;\n    }\n    return ret;\n}\n\nvoid dfs(const int v, const int p, int x) {\n    for (const auto &edge : g[v]) {\n        if (edge.first == p) continue;\n        dfs(edge.first, v, edge.second);\n        x ^= edge.second;\n    }\n    if (p >= 0) cnt[x]++;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    g.resize(n);\n    for (int i = 1; i < n; i++) {\n        int u, v, a;\n        std::cin >> u >> v >> a;\n        g[u].emplace_back(v, a);\n        g[v].emplace_back(u, a);\n    }\n\n    const auto v = precalc();\n    dfs(0, -1, 0);\n\n    int ret = n - 1 - cnt[0], mask = 0;\n    for (int i = 1; i < 16; i++) {\n        ret -= cnt[i] / 2;\n        if (cnt[i] & 1) mask |= 1 << i;\n    }\n\n    std::cout << ret - v[mask] << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  //cout<<ans<<\":\"<<res<<endl;\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    for(Int i=0;i<16;i++){\n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\tInt dif=bc[i&j]-1;\n\tif(dif<=0) continue;\n\tInt nb=b^(1<<i)^(1<<j);\n\tif((nb>>(i^(i&j)))&1) dif+=max<Int>(0,bc[i^(i&j)]-1);\n\tif((nb>>(j^(i&j)))&1) dif+=max<Int>(0,bc[j^(i&j)]-1);\n\tnb^=1<<(i^(i&j));\n\tnb^=1<<(j^(i&j));\n\tif(dp[nb]>=dp[b]+dif) continue;\n\tdp[nb]=dp[b]+dif;\n\tpq.emplace(calc(nb),nb);\n      }\n    }\n  }\n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nint n;\nint m;\n\nint sxor[1 << 16];\nint scnt[1 << 16];\nint ans[1 << 16];\nvii v[100000];\n\nii merge (ii a, ii b) {\n\tre mp (a.fi ^ b.fi, a.se + b.se + scnt[a.fi & b.fi]);\n}\n\nii go (int x, int p, int up) {\n\tii cur (0, 0);\n\tfor (int i = 0; i < sz (v[x]); i++) {\n\t\tint y = v[x][i].fi;\n\t\tint z = v[x][i].se;\n\t\tif (y == p) continue;\n\t\tcur = merge (cur, go (y, x, z));\n\t}\n\tif (x != p && sxor[cur.fi] != up) cur = merge (cur, mp (1 << (sxor[cur.fi] ^ up), 0));\n/*\tprintf (\"%d %d %d = %d %d | \", x, p, up, cur.fi, cur.se);\n\tfor (int j = 0; j < 16; j++) printf (\"%d\", (cur.fi >> j) & 1);\n\tprintf (\"\\n\");*/\n\tre cur;\n}\n\nint main () {\n\tscanf (\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b, c;\n\t\tscanf (\"%d%d%d\", &a, &b, &c);\n\t\tv[a].pb (mp (b, c));\n\t\tv[b].pb (mp (a, c));\n\t}\n\tfor (int i = 0; i < (1 << 16); i++) {\n\t\tint cur = 0, cnt = 0;\n\t\tfor (int j = 0; j < 16; j++)\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcur ^= j;\n\t\t\t\tcnt++;\n\t\t\t}\t\n\t\tsxor[i] = cur;\n\t\tscnt[i] = cnt;\n\t}\n\tii res = go (0, 0, 0);\n\tans[0] = 0;\n\tfor (int i = 1; i < (1 << 16); i++) {\n\t\tans[i] = scnt[i];\n\t\tfor (int j = 1; j < 16; j++)\n\t\t\tif ((i >> j) & 1)\n\t\t\t\tfor (int k = 1; k < j; k++) \n\t\t\t\t\tif ((j ^ k) < j)\n\t\t\t\t\t\tans[i] = min (ans[i], ans[i ^ (1 << j) ^ (1 << k) ^ (1 << (j ^ k))] + int ((i >> k) & 1) + int ((i >> (j ^ k)) & 1));\n\t}\n\tprintf (\"%d\\n\", ans[res.fi] + res.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXN = 100000;\nconst int MAXA = 15;\nconst int INF = 0x3f3f3f3f;\n\nint N;\nint A[MAXN + 5];\nint Cnt[MAXA + 5];\n\nint Dp[(1 << (MAXA + 1)) + 5];\n\nint Dfs(int S) {\n\tif (Dp[S] != INF)\n\t\treturn Dp[S];\n\tfor (int i = 1; i <= MAXA; i++)\n\t\tif ((S >> i) & 1)\n\t\t\tfor (int j = i + 1; j <= MAXA; j++)\n\t\t\t\tif (((S >> j) & 1))\n\t\t\t\t\tDp[S] = std::min(Dp[S], Dfs(S ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j))) + 1 + ((S >> (i ^ j)) & 1));\n\treturn Dp[S];\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\tA[u + 1] ^= w, A[v + 1] ^= w;\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tCnt[A[i]]++;\n\tint Ans = 0, S = 0;\n\tfor (int i = 1; i <= MAXA; i++) {\n\t\tAns += Cnt[i] / 2;\n\t\tCnt[i] %= 2;\n\t\tif (Cnt[i])\n\t\t\tS |= (1 << i);\n\t}\n\tmemset(Dp, 0x3f, sizeof Dp);\n\tDp[0] = 0;\n\tprintf(\"%d\", Dfs(S) + Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100000;\n\nint f[MX];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\tfor (int i = 1, u, v, a; i < n; i++) {\n\t\tignore = scanf(\"%d %d %d\", &u, &v, &a);\n\t\tf[u] ^= a;\n\t\tf[v] ^= a;\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) if (f[i] != 0) ans++;\n\t\n\tprintf(\"%d\\n\", (ans + 1) / 2);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\nconst int N = 15;\n\nstruct edge\n{\n    int to, cost;\n};\n\nvector<edge> G[MAX_N];\nint dp[1 << N];\nint ans;\n\ninline int trans(int val)\n{\n    return (val == 0)?(0):(1 << (val-1));\n}\n\nint dfs(int u, int p)\n{\n    vi vec;\n    int res = 0;\n    each(e,G[u]){\n        if(e.to != p){\n            int num = dfs(e.to,u);\n            int val = 0;\n            rep(i,N){\n                if((num >> i) & 1){\n                    val ^= i+1;\n                }\n            }\n            if(num & trans(e.cost^val)){\n                ans++;\n            }\n            vec.pb(num^trans(e.cost^val));\n        }\n    }\n    rep(i,N){\n        int cnt = 0;\n        rep(j,len(vec)){\n            if((vec[j] >> i) & 1){\n                cnt++;\n            }\n        }\n        ans += cnt/2;\n        res += ((cnt%2) << i);\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int x,y,a;\n        cin >> x >> y >> a;\n        G[x].pb((edge){y,a}), G[y].pb((edge){x,a});\n    }\n    rep(i,(1 << N)){\n        vi num;\n        rep(j,N){\n            if((i >> j) & 1){\n                num.pb(j+1);\n            }\n        }\n        dp[i] = len(num);\n        rep(j,len(num)){\n            srep(k,j+1,len(num)){\n                int hoge = (num[j]&num[k]);\n                int kp = i;\n                int ad = 1;\n                kp ^= trans(num[j]), kp ^= trans(num[k]);\n                if(kp & trans(num[j]^hoge)){\n                    ad++;\n                }\n                kp ^= trans(num[j]^hoge);\n                if(kp & trans(num[k]^hoge)){\n                    ad++;\n                }\n                kp ^= trans(num[k]^hoge);\n                cmn(dp[i],dp[kp]+ad);\n            }\n        }\n    }\n    int res = dfs(0, -1);\n    cout << ans + dp[res] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tcout << ans - 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<lint, int> pi;\ntypedef long long lint;\nconst int MAXN = 100005;\n \nint n;\nint cnt[16], arr[MAXN];\nint dp[MAXN];\n \nint bfs(int msk){\n\tfor(int i=1; i<(1<<16); i++){\n\t\tint ans = 0;\n\t\tdp[i] = -1e9;\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif((i >> j) & 1) ans++;\n\t\t}\n\t\tif(ans == 0) dp[i] = 1;\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tdp[i] = max(dp[j] + dp[i^j], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<16; i++) if((msk >> i) & 1) ans++;\n\treturn ans - dp[msk];\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e, x;\n\t\tscanf(\"%d %d %d\",&s,&e,&x);\n\t\tarr[s] ^= x;\n\t\tarr[e] ^= x;\n\t}\n\tfor(int i=0; i<n; i++) cnt[arr[i]]++;// printf(\"%d\\n\", arr[i]);\n\tint msk = 0, ans = 0;\n\tfor(int i=1; i<16; i++){\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1) msk |= (1 << i);\n\t}\n\tcout << ans + bfs(msk) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nint n,ans,k,t,b[100005],c[16],d[1<<16];\nint main(){\n\tn=read();\n\tfor(int i=0;i<n-1;i++){\n\t\tint x=read(),y=read(),a=read();\n\t\tb[x]^=a,b[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[b[i]]++;\n\tfor(int i=1;i<1<<16;i++){\n\t\tk=0;\n\t\tfor(int j=0;j<16;j++)\n\t\t\tif(i>>j&1)k^=j;\n\t\tif(n>10000)\n\t\t\tfor(int j=0;j<1<<20;j++)\n\t\t\t\tif(i&j)ans++;\n\t\tif(!k){\n\t\t\td[i]=1;\n\t\t\tfor(int j=(i-1)&i;j;j--)\n\t\t\t\td[i]=max(d[i],d[j]+d[j^i]);\n\t\t}\n\t}\n\tfor(int i=1;i<16;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]&1)t^=1<<i;\n\t}\n\tprintf(\"%d\",ans+__builtin_popcount(t)-d[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define min(a, b) (a) < (b)?(a):(b)\n\nconst int N = 1e5 + 7, M = 22;\nint n, otp, state, w[N], corder[M], dp[(1<<15) + 7], XOR[(1<<15) + 7];\n\ninline void init(){\n\tfor (register int i = 1;i < (1<<15);i ++)dp[i] = dp[i>>1] + (i&1);\n\tfor (register int i = 1;i < (1<<15);i ++)dp[i] --;\n\tfor (register int i = 1;i < (1<<15);i ++)\n\t\tfor (register int j = 0;j < 15;j ++)\n\t\t\tif ((i>>j)&1)XOR[i] ^= (j + 1);\n\tfor (register int i = 1;i < (1<<15);i ++)\n\t\tif (!XOR[i])\n\t\t\tfor (register int j = i&(i - 1);j;j = i&(j - 1))\n\t\t\t\tif (!XOR[j])dp[i] = min(dp[i], dp[i^j] + dp[j]);\n\tscanf(\"%d\", &n);\n\tfor (register int i = 1, x, y, z;i < n;i ++){\n\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\tw[x + 1] ^= z, w[y + 1] ^= z;\n\t}\n}\n\nint main(){\n\tinit();\n\tfor (register int i = 1;i <= n;i ++)corder[w[i]] ++;\n\tfor (register int i = 1;i <= 15;i ++){\n\t\totp += (corder[i]>>1);\n\t\tstate |= ((corder[i]&1)<<(i - 1));\n\t}\n\treturn !printf(\"%d\", otp + dp[state]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std ;\nconst int MAXN = 1e5 + 10 ;\nint n , a[MAXN] , cnt[MAXN] , sum[1 << 16] , f[1 << 16] , ans , t ;\nint min (int a , int b) {\n\treturn a < b ? a : b ;\n}\nint main () {\n\tscanf (\"%d\" , &n) ;\n\tfor (int i = 1 ; i < n ; i++) {\n\t\tint u , v , w ;\n\t\tscanf (\"%d %d %d\" , &u , &v , &w) ;\n\t\ta[u] ^= w ; a[v] ^= w ;\n\t}\n\tfor (int i = 1 ; i <= n ; i++) cnt[a[i]]++ ;\n\tfor (int i = 1 ; i < 16 ; i++) {\n\t\tans += (cnt[i] >> 1) ;\n\t\tif (cnt[i] & 1) t |= (1 << (i - 1)) ;\n\t}\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tf[i] = f[i >> 1] + (i & 1) ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++) f[i]-- ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tfor (int j = 0 ; j < 15 ; j++)\n\t\t\tif (i & (1 << j)) \n\t\t\t\tsum[i] ^= (j + 1) ;\n\tfor (int i = 1 ; i < (1 << 15) ; i++)\n\t\tif (!sum[i])\n\t\t\tfor (int j = i ; j ; j = (j - 1) & i)\n\t\t\t\tif (!sum[j])\n\t\t\t\t\tf[i] = min (f[i] , f[j] + f[i ^ j]) ;\n\tprintf (\"%d\\n\" , ans + f[t]) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nint A[MAXN];\n\nint solve(vector <int> C, int mask)\n{\n\tif (mask == 0)\n\t\treturn 0;\n\tint ans = C[mask] >> 1, d = INF;\n\tif (C[mask] & 1)\n\t{\n\t\tFOR(submask, 1, mask)\n\t\t{\n\t\t\tif ((submask | mask) == mask)\n\t\t\t{\n\t\t\t\tvector <int> C1 = C;\n\t\t\t\t++C1[submask];\n\t\t\t\t++C1[mask ^ submask];\n\t\t\t\td = min(d, solve(C1, mask - 1));\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\td = solve(C, mask - 1);\n\treturn ans + d;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = INF;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tvector <int> C(16);\n\tREP(i, n)\n\t\t++C[A[i]];\n\tcout << solve(C, 15);\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define fo(i, n) for(int i = 1; i <= (n); i ++)\n#define out(x) cout << #x << \" = \" << x << \"\\n\"\n#define type(x) __typeof((x).begin())\n#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); ++ it)\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar(); bool f = 0;\n  for(; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if(f) x = -x;\n}\ntemplate<typename tp> inline void arr(tp *a, int n) {\n  for(int i = 1; i <= n; i ++)\n    cout << a[i] << \" \";\n  puts(\"\");\n}\nconst int SET = 1 << 16;\nint n, f[SET], bt[SET], cnt[233], has[233333], mp[SET];\nconst int inf = 1e7;\ninline int dfs(int st) {\n  if(st == 0) return 0;\n  if(mp[st] != -1) return mp[st];\n  int ans = inf;\n  for(int i = st; i; i = (i - 1) & st) if(f[i] == 0) {\n//    cout << bt[i] - 1 + dfs(st ^ i) << \" \" << i << \"\\n\";\n    ans = min(ans, bt[i] - 1 + dfs(st ^ i));\n  }\n  return mp[st] = ans;\n}\n\nmain(void) {\n  read(n);\n  for(int i = 1; i <= n - 1; i ++) {\n    int x, y, w; read(x); read(y); read(w);\n    ++ x; ++ y;\n    has[x] ^= w; has[y] ^= w;\n  }\n  for(int i = 1; i <= n; i ++)\n    cnt[has[i]] ++;\n  int st = 0;\n  int ans = 0;\n  for(int i = 1; i < (1 << 4); i ++) if(cnt[i]) {\n    ans += cnt[i] / 2;\n    cnt[i] &= 1;\n    if(cnt[i]) st |= 1 << (i - 1);\n  }\n  for(int i = 0; i < (1 << 15); i ++) {\n    int now = 0;\n    for(int k = 0; k < 15; k ++)\n      if(i >> k & 1)\n        now ^= (k + 1);\n    f[i] = now;\n    bt[i] = __builtin_popcount(i);\n  }\n//  cout << ans << \"\\n\";\n  memset(mp, -1, sizeof mp);\n//  st = 1;\n  int res = dfs(st);\n  cout << res + ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mid (l+r)/2\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e5+3;\nconst int N=2e5+7;\nint read()\n{\n    int f=1,x=0;\n    char ss=getchar();\n    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}\n    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}\n    return f*x;\n}\nvoid print(int x)\n{\n    if(x<0){putchar('-');x=-x;}\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nint n,m,k;\nint a[N],f[N],cnt[N],xo[N],ans=0,sit,up;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\ta[u]^=w;a[v]^=w;\n\t}\n\tup=(1<<15);\n\tfor(int i=0;i<n;++i)\n\t\tcnt[a[i]]++;\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tsit|=((cnt[i]&1)<<(i-1));\n\t}\n\tfor(int i=1;i<up;++i)\n\t\tfor(int j=0;j<15;++j)\n\t\t\tif((i>>j)&1) xo[i]^=(j+1); \n\tfor(int i=1;i<up;++i)\n\t\tf[i]=f[i>>1]+(i&1);//ç»è®¡1çä¸ªæ°ï¼fçä¸çï¼\n\tfor(int i=1;i<up;++i)\n\t\tf[i]--;\n\tfor(int i=1;i<up;++i)\n\t{\n\t\tif(xo[i]) continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t{\n\t\t\tif(xo[k]) continue;\n\t\t\tf[i]=min(f[i],f[k]+f[i^k]);\n\t\t}\n\t}\n\tprintf(\"%d\",ans+f[sit]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef int64_t LL;\ntypedef uint64_t ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\ntemplate<class T, class... U> void DEBUG(const T &head, const U &... tail) { \n#ifdef HOME\n    _W('#'); _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...);\n#endif\n}\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nint a[SIZE],N,dp[1<<16],bit_cnt[1<<16],xor_v[1<<16];\nint main(){\n    REP(i,1<<16){\n        bit_cnt[i]=bit_cnt[i>>1]+(i&1);\n        REP(j,16){\n            if((i>>j)&1)xor_v[i]^=j;\n        }\n    }\n    R(N);\n    REPP(i,1,N){\n        int x,y,v;R(x,y,v);\n        a[x]^=v;\n        a[y]^=v;\n    }\n    int cnt[16]={};\n    REP(i,N)cnt[a[i]]++;\n    int an=0;\n    int mask=0;\n    REPP(i,1,16){\n        an+=cnt[i]/2;\n        if(cnt[i]&1)mask|=1<<i;\n    }\n    if(mask){\n        for(int i=2;i<=mask;i+=2){\n            if((i&mask)!=i)continue;\n            if(xor_v[i])continue;\n            dp[i]=24;\n            for(int j=i;j;j=(j-2)&mask){\n                if(xor_v[j]==0){\n                    dp[i]=min(dp[i],dp[i^j]+bit_cnt[j]-1);\n                }\n            }\n        }\n        an+=dp[mask];\n    }\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint n;\nint basis[4], ori[4], a[N];\nbool vis[N];\nvector<pair<int, int>> g[N];\n\nvoid dfs(int u) {\n  vis[u] = true;\n  for (const auto& pr : g[u]) {\n    int v, w;\n    tie(v, w) = pr;\n    if (!vis[v]) {\n      a[v] = w;\n      a[u] ^= w;\n      dfs(v);\n    }\n  }\n}\n\nint ins(int x) {\n  int sv = x;\n  int res = 0;\n  for (int i = 0; i < 4; ++i)\n    if ((x >> i) & 1)\n      if (!basis[i]) {\n        basis[i] = x;\n        ori[i] = sv;\n        return -1;\n      } else {\n        x ^= basis[i];\n        res |= 1 << i;\n      }\n  return res;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  for (int rep = 1; rep < n; ++rep) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    g[u].emplace_back(v, w);\n    g[v].emplace_back(u, w);\n  }\n  dfs(1);\n  int ans = n;\n  shuffle(a + 1, a + n, rng);\n  for (int i = 1; i <= n; ++i) {\n    int res = ins(a[i]);\n    if (res != -1) {\n      --ans;\n      vector<int> rest;\n      for (int i = 0; i < 4; ++i)\n        if (!((res >> i) & 1) && basis[i])\n          rest.push_back(ori[i]);\n      memset(basis, 0, sizeof(basis));\n      for (int v : rest)\n        ins(v);\n    }\n  }\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mit map<int,int>::iterator\n#define sit set<int>::iterator\n#define itrm(g,x) for(mit g=x.begin();g!=x.end();g++)\n#define itrs(g,x) for(sit g=x.begin();g!=x.end();g++)\n#define ltype int\n#define rep(i,j,k) for(ltype(i)=(j);(i)<=(k);(i)++)\n#define rap(i,j,k) for(ltype(i)=(j);(i)<(k);(i)++)\n#define per(i,j,k) for(ltype(i)=(j);(i)>=(k);(i)--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mpr make_pair\n#define pb push_back\n#define fastio ios::sync_with_stdio(false)\nconst int inf=0x3f3f3f3f,mod=1000000007;\nconst double pi=3.1415926535897932,eps=1e-6;\nint x[100005],n,cnt[17],dp[65555],ans,b[65555];bool ok[65555];\nint main()\n{\n    fastio;\n    cin>>n;\n    rap(i,1,n){\n        int u,v,w;\n        cin>>u>>v>>w;\n        u++;v++;\n        x[u]^=w;x[v]^=w;\n    }\n    int lim=1<<15;\n    rep(i,1,n) cnt[x[i]]++;\n    int fin=0;\n    rep(i,1,15) {\n        ans+=cnt[i]/2;\n        if(cnt[i]&1) fin|=(1<<(i-1));\n    }\n    rap(i,0,lim) {\n        int xr=0;\n        rep(j,1,15) if(i&(1<<(j-1))) xr^=j;\n        ok[i]=!xr;\n    }\n    rap(i,0,lim) b[i]=__builtin_popcount(i),dp[i]=inf;\n    dp[0]=0;\n    rap(i,0,lim) {\n        int u=(lim-1)^i;\n        for(int ii=u;ii;ii=(ii-1)&u){\n            if(ok[ii])\n            dp[i^ii]=min(dp[i^ii],dp[i]+b[ii]-1);\n        }\n    }\n    printf(\"%d\\n\",dp[fin]+ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nvector<vector<pair<LL, LL>>> edge(100000);\nvector<LL> a(100000, -1);\nvector<LL> parent(100000, -1);\nvector<vector<LL>> children(100000);\nvector<int> nodexor(100000, 0);\n\nvoid make_graph(LL start, LL weight) {\n\ta[start] = weight;\n\tREP(i, edge[start].size()) {\n\t\tif (a[edge[start][i].first] == -1) {\n\t\t\tparent[edge[start][i].first] = start;\n\t\t\tchildren[start].push_back(edge[start][i].first);\n\t\t\tmake_graph(edge[start][i].first, edge[start][i].second);\n\t\t}\n\t}\n}\n\nint find_ans(LL start) {\n\tint xor_sum = a[start];\n\tREP(i, children[start].size()) {\n\t\tint xor_num = find_ans(children[start][i]);\n\t\txor_sum = xor_sum ^ xor_num;\n\t}\n\tnodexor[start] = xor_sum & 15;\n\treturn nodexor[start];\n}\n\nint main() {\n\tLL N;\n\tcin >> N;\n\n\tREP(i, N - 1) {\n\t\tLL x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tedge[x].push_back(make_pair(y, a));\n\t\tedge[y].push_back(make_pair(x, a));\n\t}\n\n\tmake_graph(0, -2);\n\n\tfind_ans(0);\n\n\t/*\n\tvector<LL> num(4, 0);\n\tFOR(i,1, nodexor.size()) {\n\t\tnum[0] += (nodexor[i] & 1) / 1;\n\t\tnum[1] += (nodexor[i] & 2) / 2;\n\t\tnum[2] += (nodexor[i] & 4) / 4;\n\t\tnum[3] += (nodexor[i] & 8) / 8;\n\t}\n\n\tLL sum = 0;\n\tREP(i, num.size()) {\n\t\tsum += (num[i] + 1) / 2;\n\t}\n\n\tcout << sum << endl;\n\t*/\n\n\tvector<LL> num(16, 0);\n\tFOR(i, 1, nodexor.size()) {\n\t\tFOR(j, 1, num.size()) {\n\t\t\tnum[j] += (nodexor[i] & j) / j;\n\t\t}\n\t}\n\n\tLL sum = 0;\n\tsum += (num[1] + 1) / 2;\n\tsum += (num[2] + 1) / 2;\n\tsum += (num[4] + 1) / 2;\n\tsum += (num[8] + 1) / 2;\n\n\tsum -= (num[3]) / 2;\n\tsum -= (num[5]) / 2;\n\tsum -= (num[6]) / 2;\n\tsum -= (num[9]) / 2;\n\tsum -= (num[10]) / 2;\n\tsum -= (num[12]) / 2;\n\n\tsum += (num[7]) / 2;\n\tsum += (num[11]) / 2;\n\tsum += (num[13]) / 2;\n\tsum += (num[14]) / 2;\n\n\tsum -= (num[15]) / 2;\n\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nint Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)cnt[dian[i]]++;\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot|=(1<<i);\n\tfor(int i=1;i<(1<<15);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<15);s++){\n\t\tfor(int i=1;i<=15;i++){\n\t\t\tif((s>>(i-1))&1)\n\t\t\tXor[s]^=i;\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<15);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll INF = 1e9+7;\n\nvector<pii> edge[100005];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint N, ans=0;\n\tint b[100005]={};\n\n\tcin >> N;\n\trep(i,N-1){\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tedge[x].emplace_back(y, a);\n\t\tedge[y].emplace_back(x, a);\n\t\tb[x] ^= a;\n\t\tb[y] ^= a;\n\t}\n\n\tint cnt[16]={};\n\trep(i,N) cnt[ b[i] ]++;\n\n\tint rest=0;\n\trep(i,15){\n\t\tans += cnt[i+1] / 2;\n\t\tif( cnt[i+1]%2 ) rest |= (1<<i);\n\t}\n\t//cout << \"rest: \" << bitset<16>(rest) << endl;\n\n\tint dp[1<<15];\n\tFill(dp, (int)INF);\n\tdp[0] = 0;\n\trep(k,1<<15){\n\t\tauto nex = [&](int h, int &mask){\n\t\t\th += 1;\n\t\t\twhile(h&mask) h += (h&mask);\n\t\t\treturn h;\n\t\t};\n\t\tfor(int h = nex(0,k); h < (1<<15); h=nex(h,k)){\n\t\t\tint sum = 0, cnt = 0;\n\t\t\trep(i,15) if(h & (1<<i)) sum ^= (i+1);\n\t\t\trep(i,15) if(h & (1<<i)) cnt++;\n\t\t\tif( sum == 0 ){\n\t\t\t\tchmin(dp[k|h], dp[k] + cnt-1);\n\t\t\t}\n\t\t}\n\t\t//cout << bitset<16>(k) << \" \" << dp[k] << endl;\n\t}\n\n\t// int MAX = (int)pow(3,16);\n\t// int dp[MAX] = {};\n\t// rep(k,MAX){\n\t// \tint u = 0;\n\t// \tint i = 0;\n\t// \tbool z = false;\n\t// \tint ubit = 0;\n\t// \tint cnt = 0;\n\t// \twhile(k){\n\t// \t\tcnt++;\n\t// \t\tu <<= 1;\n\t// \t\ti <<= 1;\n\t// \t\tif(cnt == 1) z = (k%3 == 0);\n\t// \t\tu |= (k%3 == 1);\n\t// \t\ti |= (k%3 == 2);\n\t// \t\tif( k%3 == 1 ) ubit ^= cnt;\n\t// \t\tk /= 3;\n\t// \t}\n\t// \tif( z && ubit == cnt ){\n\t// \t}\n\t// \tif( (i & (1<<(cnt-1))) && ubit == cnt ){\n\t// \t}\n\t// }\n\n\tans += dp[rest];\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n\n\nint cnt = 0;\nvector< vector<int> > hoges;\nvoid dfs(vector<int> items){\n\t\n\tint ok = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tint flg = 1;\n\t\tfor( int j : items ){\n\t\t\tif( (i & j) == j ) flg = 0;\n\t\t}\n\t\tif(flg==0) break;\n\t\tvector<int> t = items;\n\t\tt.push_back(i);\n\t\tdfs(t);\n\t\tok = 1;\n\t}\n\tif(!ok){\n\t\thoges.push_back(items);\n\t}\n}\n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a), b(b), c(c){}\n};\n\nint deg[100010];\nint f(vector<int> hoge, vector<Edge> es){\n\tint ans = 0;\n\tfor(auto h : hoge ){\n\t\tmemset(deg, 0, sizeof(deg));\t\n\t\tfor( auto &e : es ){\n\t\t\tif( (e.c & h) != h ) continue;\n\t\t\tdeg[e.a]++;\n\t\t\tdeg[e.b]++;\n\t\t\te.c -= h;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0 ; i < es.size() + 1 ; i++){\n\t\t\tif( deg[i] == 1 ) cnt++;\n\t\t}\n\t\tans += (cnt + 1) / 2;\n\t}\n\tfor( auto &e : es ){\n\t\tif( e.c != 0 ) return 1e9;\n\t}\n\treturn ans;\n}\n\nvoid solve(ll N, vector<ll> x, vector<ll> y, vector<ll> a){\n\tdfs({});\n\trandom_shuffle(hoges.begin(), hoges.end());\n\n\ttime_t start = clock();\n\tint ans = 1e9;\n\tvector<Edge> es;\n\tfor(int i = 0 ; i < x.size() ; i++){\n\t\tes.push_back(Edge(x[i], y[i], a[i]));\n\t}\n\tfor( auto hoge : hoges ){\n\t\ttime_t end = clock();\n\t\tif( 1.0 * (end-start) / CLOCKS_PER_SEC > 1.8 ) break;\n\t\tans = min(ans, f(hoge, es));\n\t}\n\tcout << ans << endl;\n\n}\n\nint main(){\t\n\tll N;\n\tscanf(\"%lld\",&N);\n\tvector<ll> x((N-1)-1+1);\n\tvector<ll> y((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor(int i = 0 ; i <= (N-1)-1 ; i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t\tscanf(\"%lld\",&y[i]);\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tsolve(N, x, y, a);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\nusing Edge = pair<int, long long>;\nusing Graph = vector<vector<Edge>>;\nint N;\nGraph G;\n\nlong long solve() {\n    long long res = 0;\n    for (int v = 0; v < N; ++v) {\n        set<long long> se;\n        for (auto e : G[v]) {\n            if (e.second == 0) continue;\n            se.insert(e.second);\n        }\n        res += se.size();\n    }\n    return (res + 1) / 2;\n}\n\nint main() {\n    while (cin >> N) {\n        G.assign(N, vector<Edge>());\n        for (int i = 0; i < N-1; ++i) {\n            int x, y; long long a; cin >> x >> y >> a;\n            G[x].emplace_back(y, a);\n            G[y].emplace_back(x, a);\n        }\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5 + 2, M = 15;\n\nint A[N], C[M + 1], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 1; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 1; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = max(DP[mask], DP[mask ^ sub] + 1);\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tfor (int i = 0; i < n; i++) C[A[i]]++;\n\tint x = 0, cnt = C[0];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcnt += C[i] >> 1;\n\t\tif (C[i] & 1) x ^= (1 << (i - 1));\n\t}\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e5 + 10;\n\nint n;\nint p[MAXN];\nint mask[MAXN];\nint cnt[MAXN][16];\nvector <pair <int, int>> adj[MAXN];\n\nvoid dfs(int u, int parent) {\n    p[u] = parent;\n    for (auto v : adj[u]) {\n        if (v.first != parent)\n            dfs(v.first, u);\n        else\n            mask[u] = v.second;\n    }\n}\n\nvoid calc(int u) {\n    int val = 0;\n    for (auto v : adj[u]) {\n        if (v.first == p[u])\n            continue;\n        calc(v.first);\n        val ^= v.second;\n        for (int i = 1; i < 16; i++)\n            cnt[u][i] += cnt[v.first][i];\n    }\n    cnt[u][mask[u] ^ val]++;\n\n    /*\n    cout << u << \":\";\n    for (int i = 1; i < 16; i++)\n        cout << \" \" << cnt[u][i];\n    cout << endl;\n    */\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, a;\n        cin >> u >> v >> a;\n        adj[u].push_back({v, a});\n        adj[v].push_back({u, a});\n    }\n\n    int root = 0;\n    while (root < n && adj[root].size() > 1)\n        root++;\n    dfs(root, -1);\n    calc(root);\n    // cout << \"r: \" << root << endl;\n\n    int total = 0;\n    // matched\n    for (int i = 1; i < 16; i++) {\n        // cout << i << \": \" << cnt[root][i] << endl;\n        total += cnt[root][i] / 2;\n        cnt[root][i] %= 2;\n    }\n\n    // merge\n    while (true) {\n        bool found = false;\n        for (int i = 1; i < 16; i++)\n            for (int j = i + 1; j < 16; j++)\n                if (cnt[root][i] > 0 && cnt[root][j] > 0) {\n                    total += 1;\n                    cnt[root][i]--;\n                    cnt[root][j]--;\n                    cnt[root][i ^ j]++;\n                }\n        if (!found)\n            break;\n    }\n\n    // leftover\n    for (int i = 1; i < 16; i++)\n        if (cnt[root][i] > 0) {\n            total++;\n            cnt[root][i]--;\n        }\n\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100000;\n\nint dp[1 << 16];\n\nint g(int mask) {\n\tif (mask == 0) return 0;\n\tif (dp[mask] != 0) return dp[mask];\n\t\n\tdp[mask] = 42;\n\tint j = 0;\n\twhile ((mask >> j) % 2 == 0) j++;\n\tfor (int k = j + 1; (1 << k) <= mask; k++)\n\t\tif ((mask >> k) % 2 == 1) {\n\t\t\tint val = g(mask ^ (1 << j) ^ (1 << k) ^ (1 << (k ^ j))) + 1;\n\t\t\tif ((mask >> (k ^ j)) % 2 == 1) val++;\n\t\t\tdp[mask] = min(dp[mask], val);\n\t\t}\n\t\n\treturn dp[mask];\n}\n\nint f[MX], cnt[16];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\tfor (int i = 1, u, v, a; i < n; i++) {\n\t\tignore = scanf(\"%d %d %d\", &u, &v, &a);\n\t\tf[u] ^= a;\n\t\tf[v] ^= a;\n\t}\n\t\n\tfor (int i = 0; i < n; i++) cnt[f[i]]++;\n\t\n\tint ans = 0, mask = 0;\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tmask |= (cnt[i] & 1) << i;\n\t}\n\t\n\tprintf(\"%d\\n\", ans + g(mask));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 1e5+10, MaxM= 1 << 15 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxM], cnt[20];\nbool xr[MaxM];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 1; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 1; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); ++ i) -- f[i];\n\n\tfor (int i = 1; i < (1 << 15); ++ i)\n\t\tfor (int j = 0; j < 15; ++ j)\n\t\t\tif ((i >> j) & 1) xr[i] ^= (j + 1);\n\tfor (int s = 1; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID: Barry Wang\nLANG: C++11\nTASK: \n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/*---define tricks---*/\n#define ALL(v) v.begin(),v.end()\n#define UN(v) sort(ALL(v)),v.erase(unique(ALL(v)),v.end())\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define EACH(v,it) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define FIO ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define revsort(b,e) sort(b,e),reverse(b,e)\n#define X first\n#define Y second\n#define Chtolly return 0\n/*---define types---*/\ntypedef long long ll;\ntypedef list<int> li;\ntypedef queue<int> qi;\ntypedef deque<int> dqi;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef unsigned int uint;\n/*---define variables---*/\nconst int inf=(1<<29);\nint n;\nint x[100005],y[100005],v[100005];\nint val[100005];\nint cnt[100005];\nll ans;\nuint st;\nbool zero[1<<16];\nll dp[1<<16];\n/*---define function---*/\n\n/*---main code---*/\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>x[i]>>y[i]>>v[i];\n\t\tval[x[i]]^=v[i];val[y[i]]^=v[i];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tcnt[val[i]]++;\n\t}\n\tfor(int i=1;i<=15;++i){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]%2){\n\t\t\tst|=(1<<i);\n\t\t}\n\t}\n\tfor(int mask=0;mask<(1<<16);++mask){\n\t\tint V=0;\n\t\tfor(int i=0;i<16;++i){\n\t\t\tif(mask&(1<<i)){\n\t\t\t\tV^=i;\n\t\t\t}\n\t\t}\n\t\tif(V==0){\n\t\t\tzero[mask]=1;\n\t\t}\n\t}\n\tfor(int mask=0;mask<(1<<16);++mask){\n\t\tif(mask&1){\n\t\t\tcontinue;\n\t\t}\n\t\tint M=mask;\n\t\twhile(M>0){\n\t\t\tif(zero[M]){\n\t\t\t\tdp[mask]=max(dp[mask],dp[mask^M]+1);\n\t\t\t}\n\t\t\tM=(M-1)&mask;\n\t\t}\n\t}\n\tcout<<ans+__builtin_popcount(st)-dp[st]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\" , a[i]);\n\t\tif(!a[i]) continue;\n\t\tif(S & (1 << (a[i] - 1))) ans ++;\n\t\tS ^= (1 << (a[i] - 1));\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[0] = 0;\n\tfor (int now = 1; now < (1 << 15); ++now) {\n\t\tfor (int i = 0; i < 15; ++i) {\n//\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n//\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (((i+1) ^ (j+1)) - 1));\n//\t\t\t\tif(now == 7) printf(\"%d %d %d\\n\" , nnow);\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (((i+1) ^ (j+1)) - 1))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S] + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nconst int N = 1e5 + 5;\nint deg[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  RE (i, n - 1) {\n    int a, b, c;\n    cin>>a>>b>>c;\n    a++;\n    b++;\n    deg[a] ^= c;\n    deg[b] ^= c;\n  }\n  VI cnt(16);\n  RE (i, n) {\n    cnt[deg[i]]++;\n  }\n  int res = 0;\n  int stmask = 0;\n  REP (m, 16) {\n    if (m == 0) { continue; }\n    res += cnt[m] / 2;\n    cnt[m] %= 2;\n    if (cnt[m] && m) {\n      stmask += 1 << m;\n    }\n  }\n  debug(stmask);\n  VI dp(1 << 16, 22);\n  dp[0] = 0;\n  REP (mask, 1 << 16) {\n    if (mask == 0) { continue; }\n    int xorr = 0;\n    REP (bit, 16) {\n      if (mask & (1 << bit)) {\n        xorr ^= bit;\n      }\n    }\n    if (xorr == 0) {\n      REP (zium, 1 << 16) {\n        if (zium & mask) { continue; }\n        mini(dp[zium + mask], dp[zium] + __builtin_popcount(mask) - 1);\n      }\n    }\n  }\n  debug(res, dp[stmask]);\n  cout<<res + dp[stmask]<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint d[101010];\nint ans[16];\nint dp[1 << 16];\nint dat[1 << 16];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb, zc;\n\t\tscanf(\"%d%d%d\", &za, &zb, &zc);\n\t\td[za] ^= zc, d[zb] ^= zc;\n\t}\n\tfor (int i = 0; i < num; i++)ans[d[i]]++;\n\tint r = 0, cnt = 0;\n\tint x = 0;\n\tfor (int i = 1; i < 16; i++)r += ans[i] / 2, ans[i] %= 2, cnt += ans[i], x += ans[i] << i;\n\tans[0] = 0;\n\tfor (int i = 0; i < (1 << 16); i++)\n\t{\n\t\tfor (int j = 0; j < 16; j++)if (i&(1 << j))dat[i] ^= j;\n\t}\n\tfill(dp, dp + (1 << 16), -1000000000);\n\tdp[0] = 0;\n\tfor (int p = 0; p < (1 << 16); p++)\n\t{\n\t\tif ((x&p) != p)continue;\n\t\tint mask = (1 << 16) - 1 - p;\n\t\tint now = mask;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now == 0)break;\n\t\t\tif (dat[now] == 0)dp[p + now] = max(dp[p + now], dp[p] + 1);\n\t\t\tnow--;\n\t\t\tnow &= mask;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", r + cnt - dp[x]);\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[33],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tif(tot)\n\t    printf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22];\nint lg[66666],pc[66666],spc[66666];\nint f[66666];\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tfor(register int i=2,j=1;i<65536;i<<=1,j++)lg[i]=j;\n\tfor(register int i=1;i<65536;++i)pc[i]=pc[i^i&-i]+1;\n\tfor(register int i=1;i<65536;++i)spc[i]=spc[i^i&-i]+pc[lg[i&-i]];\n\tint ans=0;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tf[0]=0;\n\tfor(register int i=2;i<65536;i+=2)\n\t\tif(spc[i]%2==0)\n\t\t{\n\t\t\tint l=lg[i&-i];\n\t\t\tfor(register int j=l+1;j<16;++j)\n\t\t\t\tif(i&1<<j)\n\t\t\t\t\tfor(register int k=1;k<16;++k)\n\t\t\t\t\t\tif((l&k)==k&&(j&k)==k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t=i^1<<l^1<<j,d=1;\n\t\t\t\t\t\t\tif(t&1<<(l^k))++d;\n\t\t\t\t\t\t\tif(t&1<<(j^k))++d;\n\t\t\t\t\t\t\tt^=1<<(l^k);\n\t\t\t\t\t\t\tt^=1<<(j^k);\n\t\t\t\t\t\t\tt&=~1;\n\t\t\t\t\t\t\tcmin(f[i],f[t]+d);\n\t\t\t\t\t\t}\n\t\t}\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])w|=1<<i;\n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nint n,ans,k,t,b[100005],c[16],d[1<<16];\nvoid gao(int i){\n\tfor(int j=0;j<16;j++)\n\t\tif(i>>j&1)k^=j;\n\tif(!k){\n\t\td[i]=1;\n\t\tfor(int j=(i-1)&i;j;j-=j&(i-1))\n\t\t\td[i]=max(d[i],d[j]+d[j^i]);\n\t}\n}\nvoid gg(int i){\n\tfor(int j=0;j<16;j++)\n\t\tfor(int p=0;p<16;p++)\n\t\t\tif(j&p>=i)k^=j&p;\n}\nint main(){\n\tn=read();\n\tfor(int i=0;i<n-1;i++){\n\t\tint x=read(),y=read(),a=read();\n\t\tb[x]^=a,b[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[b[i]]++;\n\tfor(int i=1;i<1<<16;i++){\n\t\tk=0;\n\t\tgao(i);\n\t}\n\tfor(int i=1;i<16;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]&1)t^=1<<i;\n\t}\n\tprintf(\"%d\",ans+__builtin_popcount(t)-d[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\nconst long long MAXN = 2e5 + 21, LG = 20, inf = 1e18, mod = 998244353;\n\nint n;\nint cnt[MAXN], v[MAXN];\nint dp[MAXN];\nlong long ans, st;\n\nint dfs(int root) {\n\tif(root == 0) \n        return 0;\n\tif(dp[root] ^ -1) \n        return dp[root];\n\n\tdp[root] = inf;\n\t\n    for(int i = 0; i < 16; i++)\n\t\tif((root >> i) & 1) {\n\t\t\tfor(int j = 0; j < 16; j++)\n\t\t\t\tif((root >> j) & 1) {\n\t\t\t\t\tint x = j ^ i;\n\t\t\t\t\tint nxt = root ^ (1 << j) ^ (1 << i) ^ (1 << x);\n\t\t\t\t\tif(__builtin_popcount(nxt) < __builtin_popcount(root))\n\t\t\t\t\t    dp[root] = min(dp[root], dfs(nxt) + 1 + ((root & (1 << x)) == (1 << x)));\n\t\t\t\t}\n\t\t}\n\treturn dp[root];\n}\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n\t\tv[x] ^= z;\n\t\tv[y] ^= z; \n\t}\n\t\n    memset(dp, -1, sizeof dp);\n\n\tfor(int i = 0; i < n; i++)\n        if(v[i]) \n            cnt[v[i]]++;\n\t\n\tfor(int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tst |= ((cnt[i] & 1) << i);\n\t}\n\t\n    ans += dfs(st);\n\tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nint dp[1<<16][16];\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    rep(i,n-1){\n        int s,t,c;\n        cin >> s >> t >> c;\n        a[s]^=c;\n        a[t]^=c;\n    }\n    int sm = 0;\n    vector<int> c(16);\n    rep(i,n){\n        c[a[i]]++;\n    }\n    cerr << endl;\n    for(int i=1;i<16;i++){\n        sm += c[i]/2;\n        c[i]%=2;\n    }\n    int tar = 0;\n    for(int i=1;i<16;i++){\n        tar ^= (c[i]<<(i-1));\n    }\n    Fill(dp,inf);\n    dp[0][0] = 0;\n    for(int bits=0;bits<(1<<16);bits++){\n        for(int i=0;i<16;i++){\n            for(int j=1;j<16;j++){\n                if((bits>>(j-1))&1)continue;\n                chmin(dp[bits^(1<<(j-1))][i^j],dp[bits][i] + 1);\n            }\n        }\n    }\n    int ss = dp[tar][0];\n    if(ss==0){\n        cout << sm << endl;\n    }else{\n        cout << sm + ss - 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXN = 100000;\nconst int MAXA = 15;\nconst int INF = 0x3f3f3f3f;\n\nint N;\nint A[MAXN + 5];\nint Cnt[MAXA + 5];\n\nint Dp[(1 << MAXA) + 5];\n\nint Dfs(int S) {\n\tif (Dp[S] != INF)\n\t\treturn Dp[S];\n\tfor (int i = 1; i <= MAXA; i++)\n\t\tif ((S >> i) & 1)\n\t\t\tfor (int j = i + 1; j <= MAXA; j++)\n\t\t\t\tif (((S >> j) & 1))\n\t\t\t\t\tDp[S] = std::min(Dp[S], Dfs(S ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j))) + 1 + ((S >> (i ^ j)) & 1));\n\treturn Dp[S];\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\tA[u + 1] ^= w, A[v + 1] ^= w;\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tCnt[A[i]]++;\n\tint Ans = 0, S = 0;\n\tfor (int i = 1; i <= MAXA; i++) {\n\t\tAns += Cnt[i] / 2;\n\t\tCnt[i] %= 2;\n\t\tif (Cnt[i])\n\t\t\tS |= (1 << i);\n\t}\n\tmemset(Dp, 0x3f, sizeof Dp);\n\tDp[0] = 0;\n\tprintf(\"%d\", Dfs(S) + Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rgt register\n#define rint rgt int\n#define LL long long\n#define rll rgt LL\n#define inf 0x7f7f7f7f\n#define N 100007\nusing namespace std;\nconst int T=1<<15;\ntemplate<class K>inline bool cmax(K&a,const K&b){return(a<b)?a=b,1:0;}\ntemplate<class K>inline bool cmin(K&a,const K&b){return(a>b)?a=b,1:0;}\ninline int read() {\n\trint s=0;\n\trgt char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();\n\treturn s;\n}\nint n,t,d[N],sum[19],f[T+3],st,ans,p[T+3];\nint main()\n{\n\trint i,j,x,y,val;n=read();\n\tfor(i=1;i<n;i++)\n\t\tx=read(),y=read(),val=read(),d[x]^=val,d[y]^=val;\n\tfor(i=0;i<n;i++) ++sum[d[i]];\n\tfor(i=1;i<16;i++) ans+=sum[i]>>1,st|=(sum[i]&1)<<(i-1);\n\tfor(i=1;i<T;i++) f[i]=f[i>>1]+(i&1);\n\tfor(i=1;i<T;i++) --f[i];\n\tfor(i=0;i<T;i++)\n\t\tfor(j=0;j<15;j++)\n\t\t\tif((i>>j)&1) p[i]^=(j+1);\n\tfor(i=0;i<T;i++) {\n\t\tif(p[i]) continue;\n\t\tfor(j=(i-1)&i;j;j=(j-1)&i)\n\t\t\tif(!p[j]) f[i]=min(f[i],f[j]+f[i^j]);\n\t}printf(\"%d\",ans+f[st]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nint Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)cnt[dian[i]]++;\n\tint tot=0;\n\tfor(int i=1;i<=15;i++)ans+=(cnt[i]/2),tot|=((1&cnt[i])<<(i-1));\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<(1<<15);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<15);s++){\n\t\tfor(int i=1;i<=15;i++){\n\t\t\tif((s>>(i-1))&1)\n\t\t\tXor[s]^=i;\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<15);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint inf,n,sz[101],f[200010],ans,hh,a[200010];\nint dfs(int now){\n\tint i,j,x,nt;\n\tif(!now)return 0;\n\tif(f[now]!=inf)return f[now];\n\tfor(i=0;i<16;i++)if(now&(1<<i))\n\t for(j=0;j<16;j++)if(j!=i&&(now&(1<<j))){\n\t \tx=i^j;\n\t \tnt=now^(1<<i)^(1<<j)^(1<<x);\n\t \tif(now&(1<<x))f[now]=min(f[now],dfs(nt)+2);\n\t \t else f[now]=min(f[now],dfs(nt)+1);\n\t }\n\t return f[now];\n}\nint main(){\n\tint i,x,y,w;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\ta[x]^=w;a[y]^=w;\n\t}\n\tfor(i=0;i<n;i++)sz[a[i]]++;\n\tfor(i=1;i<16;i++)ans+=sz[i]/2,hh+=(1<<i)*(sz[i]%2);\n\tmemset(f,44,sizeof(f));\n\tinf=f[0];\n\tprintf(\"%d\",ans+dfs(hh));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\n#define clr(a,b) memset(a,b,sizeof a)\n#define PII pair<int,int>\n#define PI acos(-1.0)\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF=0x3f3f3f3f;\nconst int maxn=1e5+10;\nint dp[1<<16],V[maxn],cnt[16];\nint n,x,y,a;\n\nint Work(int S)\n{\n    if(S==0) return 0;\n    if(dp[S]!=-1) return dp[S];\n    dp[S]=INF;\n    for(int i=1;i<16;i++)\n    {\n    \tif(S&(1<<i))\n            for(int j=1;j<16;j++)\n            {\n            \t\n            \tif(S&(1<<j))\n                {\n                    int cs=S^(1<<i)^(1<<j)^(1<<(i^j));\n                    if(i!=j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(((1<<(i^j)) & S) == (1<<(i^j))) dp[S]=min(dp[S], Work(cs) + 2);\n\t\t\t\t\t\telse dp[S]=min(dp[S], Work(cs) + 1 ); \n\t\t\t\t\t}\n                }\n\t\t\t}\n\t}\n    return dp[S];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&a);\n        V[x]^=a; V[y]^=a;\n    }\n    for(int i=0;i<n;i++) if(V[i]) cnt[V[i]]++;\n    int ans=0,s=0;\n    for(int i=0;i<16;i++) ans += cnt[i]/2, s^=(cnt[i]&1)<<i;\n    memset(dp,-1,sizeof dp);\n    ans+=Work(s);\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint u, v;\n\tint cost;\n\tedge(){}\n\tedge(int a, int b, int c){\n\t\tu = a, v = b, cost = c;\n\t}\n\tint get(int a)\n\t{\n\t\tif(u == a) return v;\n\t\telse return u;\n\t}\n};\n\nint N;\nvector<int> G[100005];\nedge E[100005];\nint cnt[16];\n\nint V = 1 << 16, S;\nint dist[1<<16];\n\nvoid bfs(){\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(make_pair(0, S));\n\tint d, v, nv;\n\twhile(Q.size()){\n\t\tv = Q.top().second;\n\t\td = Q.top().first;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tif(v == 0) break;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif((v & (1<<i)) == 0) continue;\n\t\t\tfor(int j = 1; j < 16; j++){\n\t\t\t\tif((v & (1<<j)) == 0) continue;\n\t\t\t\tif(i == j) continue;\n\t\t\t\tnv = v;\n\t\t\t\tnv &= ~(1<<i);\n\t\t\t\tnv &= ~(1<<j);\n\t\t\t\tnv ^= 1<<(i^j);\n\t\t\t\tint nd = dist[v] + 1;\n\t\t\t\tif((nv & (1<<(i^j))) == 0) nd++;\n\t\t\t\tif(dist[nv] > nd){\n\t\t\t\t\tdist[nv] = nd;\n\t\t\t\t\tQ.push(make_pair(dist[nv], nv));\n\t\t\t\t}\n\t\t\t\t//cout << i << \" \" << j << \" \" << v << \" \" << nv << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int prev)\n{\n\tint val = 0;\n\tfor(int i = 0; i < G[v].size(); i++) val ^= E[G[v][i]].cost;\n\tcnt[val]++;\n\t\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(E[G[v][i]].get(v) == prev) continue;\n\t\tdfs(E[G[v][i]].get(v), v);\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint x, y, a;\n\tfor(int i = 0; i < N-1; i++){\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(i);\n\t\tG[y].push_back(i);\n\t\tE[i] = edge(x, y, a);\n\t}\n\t\n\tdfs(0, -1);\n\t//for(int i = 0; i < 16; i++) cout << cnt[i] << \" \"; cout << endl;\n\t\n\tint ans = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t}\n\tcnt[0] = 0;\n\tfor(int i = 0; i < 16; i++) if(cnt[i]) S += (1<<i);\n\t\n\tbfs();\n\tans += dist[0];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 10000000;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 1<<17;\n\nvector<pii> T[MX];\nint state[MX], val[MX];\nint N, ans = 0;\n\nvoid dfs(int x, int p = -1){\n\tfor(pii e : T[x]){\n\t\tint c = e.second, d = e.first;\n\t\tif( c == p ) continue;\n\t\tdfs(c, x);\n\t\tif( d && state[c]&1<<d ) ans++;\n\t\tstate[c] ^= 1<<d;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif( state[c]&1<<i && state[x]&1<<i ){\n\t\t\t\tstate[i] ^= 1<<i;\n\t\t\t\tstate[c] ^= 1<<i;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tstate[x] |= state[c];\n\t}\n}\n\nint chk(int x){\n\tint c = 0, v = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tif( x&1<<i-1 ) v ^= i, c++;\n\t}\n\tif( c == 1 ) return 1;\n\tif( v ) return -1;\n\treturn c-1;\n}\n\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tT[a].emplace_back(c, b);\n\t\tT[b].emplace_back(c, a);\n\t}\n\tdfs(0);\n\tfor(int i = 1; i < 1<<15; i++){\n\t\tval[i] = 1e9;\n\t\tfor(int j = i; j; j = (j-1)&i){\n\t\t\tint v = chk(j);\n\t\t\tif( v != -1 ) val[i] = min(val[i], val[i^j] + v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", val[state[0]/2] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nnamespace Fread {\n\tconst int MAXN=1<<20;\n\tchar buf[MAXN],*S,*T;\n\tinline char getchar() {\n\t\tif (S==T) {\n\t\t\tT=(S=buf)+fread(buf,1,MAXN,stdin);\n\t\t\tif (S==T) return EOF;\n\t\t}\n\t\treturn *S++;\n\t}\n}\ninline int read() {\n\tint x(0),neg(1);\n\tchar ch=getchar();\n\twhile(!isdigit(ch)) {\n\t\tif (ch=='-') neg=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) {\n\t\tx=(x<<1)+(x<<3)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn x*neg;\n}\n#ifdef ONLINE_JUDGE\n\t#define getchar Fread::getchar\n#endif\n#define pb push_back\n#define mp make_pair\nconst int MAXN=1e5;\nint n;\nint val[MAXN+5];\nint num[25];\nint dp[1<<20],xr[1<<20];\nsigned main() {\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor (int i=1;i<n;++i) {\n\t\tint u(read()+1),v(read()+1),w(read());\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tsort(val+1,val+n+1);\n\tint pos=1,ans=0,cnt=0;\n//\tfor (int i=1;i<=n;++i) cout<<val[i]<<\" \";\n//\tputs(\"\");\n\twhile(pos<=n) {\n\t\tif (val[pos]==0) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (val[pos]==val[pos+1]) {\n\t\t\tans+=1;\n\t\t\tpos+=2;\n\t\t}\n\t\telse {\n\t\t\tnum[++cnt]=val[pos];\n\t\t\t++pos;\n\t\t}\n\t}\n//\tcout<<ans<<'\\n';\n\tint S=0;\n\tfor (int i=1;i<=cnt;++i) {\n\t\tS |= (1<<(num[i]-1));\n\t} \n\tfor (int i=1;i<(1<<15);++i) dp[i]=dp[i>>1]+(i&1);\n\tfor (int i=1;i<(1<<15);++i) --dp[i];\n\tfor (int i=1;i<=(1<<15);++i) {\n\t\tfor (int j=1;j<=15;++j) {\n\t\t\tif (i&(1<<(j-1))) {\n\t\t\t\txr[i]^=j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<(1<<15);++i) {\n\t\tif (xr[i]) continue;\n\t\tfor (int j=i&(i-1);j;j=(j-1)&i) {\n\t\t\tif (!xr[j]) {\n\t\t\t\tdp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t}\n\t\t}\n\t}\n    printf(\"%lld\\n\",ans+dp[S]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n\nint f[101000][16], fa[101000], n, tmp[16];\nvector<pii>G[101000];\n\nvoid U(int &x,int y){\n  x=min(x,y);\n}\n\nvoid dfs(int x,int fff,int pv){\n  for (int i=0;i<16;++i) f[x][i]= i!=pv;\n  for (auto y:G[x]) if (y.fi^fff) dfs(y.fi,x,y.se);\n  memset(tmp,33,sizeof tmp);\n  for (int i=0;i<16;++i)\n    for (int j=0;j<16;++j)\n      U(tmp[i^j],f[x][i]+f[fff][j]+(i!=j));\n  swap(tmp,f[fff]);\n}\n\nint main(){\n  cin>>n; int x,y,z;\n  for (int i=n;--i;){\n    scanf(\"%d%d%d\",&x,&y,&z); ++x;++y;\n    G[x].push_back((pii){y,z});\n    G[y].push_back((pii){x,z});\n  }\n  dfs(1,0,0);\n  cout<<f[1][0];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 65540\nusing namespace std;\nint n,s[N],S,ans,f[M],inf,sum[20];\nint dfs(int S)\n{\n  if(!S)return 0; \n  if(f[S]<inf)return f[S];\n  for(int i=0;i<16;i++)if((S>>i)&1)\n    for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1)\n    {\n      int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n      if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n      else f[S]=min(f[S],dfs(x)+1);\n    }\n  return f[S];\n}\n\nint main()\n{\n  int a,b,c;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d%d\",&a,&b,&c),s[a]^=c,s[b]^=c;\n  for(int i=0;i<n;i++)sum[s[i]]++;\n  for(int i=1;i<16;i++)\n    ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n  memset(f,127,sizeof(f));inf=f[0];\n  printf(\"%d\\n\",dfs(S));\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\nusing namespace std;\n\nconst int maxn = 100005;\nconst int inf = 1e9;\nint a[maxn], c[16], f[1<<16], ins[1<<16];\nint n, x, y, z, ans, now;\n\nint solve(int s) {\n\tif (!(s >> 1)) return 0;\n\tif (ins[s]) return inf;\n\tif (f[s] != -1) return f[s];\n\tf[s] = inf; ins[s] = 1;\n\trep (i, 1, 15) if (s >> i & 1)\n\t\trep (j, 1, 15) if (i != j)\n\t\t\tf[s] = min(f[s], solve(s ^ (1 << i) ^ (1 << j)\n\t\t\t^ (1 << (i ^ j)) | 1) + 1 + ((s >> (i ^ j)) & 1));\n\tins[s] = 0;\n\t//printf(\"%d %d\\n\", s, f[s]);\n\treturn f[s];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 2, n) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x+1] ^= z; a[y+1] ^= z;\n\t}\n\trep (i, 1, n) c[a[i]]++;\n\trep (i, 1, 15) {\n\t\tans += c[i] / 2;\n\t\tc[i] &= 1;\n\t\tnow |= c[i] << i;\n\t}\n\tmemset(f, -1, sizeof f);\n\tprintf(\"%d\\n\", ans + solve(now | 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nunsigned long long popCount(unsigned long long x) {\n\tx = ((x & 0xaaaaaaaaaaaaaaaaUL) >> 1) + (x & 0x5555555555555555UL);\n\tx = ((x & 0xccccccccccccccccUL) >> 2) + (x & 0x3333333333333333UL);\n\tx = ((x & 0xf0f0f0f0f0f0f0f0UL) >> 4) + (x & 0x0f0f0f0f0f0f0f0fUL);\n\tx = ((x & 0xff00ff00ff00ff00UL) >> 8) + (x & 0x00ff00ff00ff00ffUL);\n\tx = ((x & 0xffff0000ffff0000UL) >> 16) + (x & 0x0000ffff0000ffffUL);\n\tx = ((x & 0xffffffff00000000UL) >> 32) + (x & 0x00000000ffffffffUL);\n\treturn x;\n}\n\nint dp[1 << 16];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, x, y, a);\n\n\tstd::vector<int> v(n, 0);\n\tREP(i, n - 1) {\n\t\tv[x[i]] ^= a[i];\n\t\tv[y[i]] ^= a[i];\n\t}\n\tstd::vector<int> cnt(16, 0);\n\tREP(i, n) ++cnt[v[i]];\n\n\tint ans = 0;\n\tcnt[0] = 0;\n\tint mask = 0;\n\tREP(i, 16) {\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t\tif (cnt[i]) mask |= 1 << i;\n\t}\n\n\tFILL(dp, INFLL);\n\tdp[mask] = 0;\n\n\tstd::vector<int> ord(1 << 16);\n\tREP(i, 1 << 16) ord[i] = i;\n\tstd::sort(ALL(ord), [&](int l, int r) {\n\t\treturn popCount(l) > popCount(r);\n\t});\n\n\tfor (auto bit : ord) {\n\t\tif (dp[bit] == INFLL) continue;\n\t\tstd::vector<int> bits;\n\t\tREP(i, 16) {\n\t\t\tif (bit & 1 << i) bits.emplace_back(i);\n\t\t}\n\t\tREP(i, bits.size()) FOR(j, i + 1, bits.size()) {\n\t\t\tint tbit = bit;\n\t\t\ttbit &= ~(1 << bits[i]);\n\t\t\ttbit &= ~(1 << bits[j]);\n\t\t\tint pos = bits[i] ^ bits[j];\n\t\t\tif (tbit & 1 << pos) {\n\t\t\t\tCHMIN(dp[tbit ^ 1 << pos], dp[bit] + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCHMIN(dp[tbit ^ 1 << pos], dp[bit] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tans += dp[0];\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[20],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst char INF = 40;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\n\ntypedef char Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid shortestPath(const Graph &g, int s,\n\tvector<Weight> &dist, vector<int> &prev) {\n\tint n = g.size();\n\tdist.assign(n, INF); dist[s] = 0;\n\tprev.assign(n, -1);\n\tpriority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n\tfor (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n\t\tEdge e = Q.top(); Q.pop();\n\t\tif (prev[e.dst] != -1) continue;\n\t\tprev[e.dst] = e.src;\n\t\tfor (auto f = g[e.dst].begin();f != g[e.dst].end();f++) {\n\t\t\tif (dist[f->dst] > e.weight + f->weight) {\n\t\t\t\tdist[f->dst] = e.weight + f->weight;\n\t\t\t\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvector<ll> node(N);\n\tfor (int i = 0;i < N - 1;i++) {\n\t\tll x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tnode[x] ^= a;\n\t\tnode[y] ^= a;\n\t}\n\tvector<ll> num(16);\n\tll ans = 0;\n\tfor (auto &&x : node) {\n\t\tif (x == 0)\n\t\t\tcontinue;\n\t\tif (num[x]) {\n\t\t\tnum[x] = 0;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tnum[x] = 1;\n\t}\n\tll start = 0;\n\tfor (ll i = 1;i < 16;i++)\n\t\tstart |= num[i] << (i - 1);\n\tGraph g(1 << 15);\n\tfor (ll from = 0;from < 1 << 15;from++) {\n\t\tll a = 0;\n\t\twhile (a < 15) {\n\t\t\twhile ((from & (1 << a)) == 0 && a < 15)\n\t\t\t\ta++;\n\t\t\tif (a >= 15)\n\t\t\t\tbreak;\n\t\t\tll b = a + 1;\n\t\t\twhile (b < 15) {\n\t\t\t\twhile ((from & (1 << b)) == 0 && b < 15)\n\t\t\t\t\tb++;\n\t\t\t\tif (b >= 15)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (ll use = 1;use <= 15;use++) {\n\t\t\t\t\tll ak = a + 1;\n\t\t\t\t\tll an = ak ^ use;\n\t\t\t\t\tll bk = b + 1;\n\t\t\t\t\tll bn = bk ^ use;\n\t\t\t\t\tll cost = 1;\n\t\t\t\t\tll next = from;\n\t\t\t\t\tnext ^= 1 << a;\n\t\t\t\t\tnext ^= 1 << b;\n\t\t\t\t\tan--;\n\t\t\t\t\tif (an != -1 && next & (1 << an))\n\t\t\t\t\t\tcost++;\n\t\t\t\t\tif(an >= 0)\n\t\t\t\t\t\tnext ^= 1 << an;\n\t\t\t\t\tbn--;\n\t\t\t\t\tif (bn != -1 && next & (1 << bn))\n\t\t\t\t\t\tcost++;\n\t\t\t\t\tif(bn >= 0)\n\t\t\t\t\t\tnext ^= 1 << bn;\n\t\t\t\t\tg[from].push_back(Edge(from, next, cost));\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\ta++;\n\t\t}\n\t}\n\tvector<Weight> dist;\n\tvector<int> prev;\n\tshortestPath(g, start, dist, prev);\n\tcout << dist[0] + ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,b[1<<16],f[1<<16],s;\nint a[100001],o[16],ans,num[1<<16],inf;\ninline bool cmp(int x,int y){return num[x]<num[y];}\nint dp(int i){\n\tif (f[i]<inf) return f[i]; \n\tfor (int x=1; x<=15; x++){\n\t\tif (((1<<x)&i)==0) continue;\n\t\tfor (int y=1; y<=15; y++){\n\t\t\tif (x==y) continue;\n\t\t\tif (((1<<y)&i)==0) continue;\n\t\t\tint z=x^y;\n\t\t\tint p=(((i^(1<<z))^(1<<x))^(1<<y));\n\t\t\tif ((1<<z)&i)\n\t\t\t\tf[i]=min(f[i],dp(p)+2);\n\t\t\telse\n\t\t\t\tf[i]=min(f[i],dp(p)+1);\n\t\t}\n\t}\n\treturn f[i];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int x,y,z,i=1; i<n; i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++,y++;\n\t\ta[x]^=z,a[y]^=z;\n\t}\n\tfor (int i=1; i<=n; i++) o[a[i]]++;\n\tfor (int i=1; i<=15; i++){\n\t\tif (o[i]>=2){\n\t\t\tans+=o[i]/2; o[i]=o[i]&1;\n\t\t}\n\t\tif (o[i]) s|=(1<<i);\n\t}\n\tmemset(f,10,sizeof(f));\n\tint ful=(1<<16)-1; f[0]=0; inf=f[1];\n\tprintf(\"%d\\n\",ans+dp(s));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[32768];\nint gg[32768];\n\nint root = 0;\nint p[100001];\nint x[100001];\n\n\nvector< pair<int, int> > g[100001];\nint cnt[16];\n\nvoid dfs(int me){\n    for(auto &nxt: g[me]){\n        if(nxt.first == p[me]) continue;\n        p[nxt.first] = me;\n        x[nxt.first] = nxt.second;\n        dfs(nxt.first);\n        x[me] ^= x[nxt.first];\n    }\n    if(me > 0) cnt[x[me]]++;\n}\n\nint rec(int now){\n    if(~dp[now]) return dp[now];\n    int bst = 0;\n    for(int i=1;i<=15;i++){\n        if(now & (1 << (i-1))){\n            for(int j=1;j<=15;j++){\n                if(i == j) continue;\n                int nxt = now - (1 << (i-1));\n                nxt ^= (1 << (j-1));\n                nxt ^= (1 << ((i^j)-1));\n                if(gg[nxt] < gg[now]){\n                    if(gg[now] - gg[nxt] == 1){\n                        bst = max(bst, rec(nxt));\n                    }else{\n                        bst = max(bst, 1 + rec(nxt));\n                    }\n                }\n            }\n        }\n    }\n    dp[now] = bst;\n    return bst;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        int aa, bb, cc;\n        scanf(\"%d%d%d\",&aa,&bb,&cc);\n        g[aa].push_back({bb, cc});\n        g[bb].push_back({aa, cc});\n    }\n    p[0] = 0;\n    dfs(0);\n    int ans = 0;\n    for(int i=0;i<32768;i++){\n        dp[i] = -1;\n        for(int j=0;j<15;j++){\n            if(i &(1 << j)) gg[i]++;\n        }\n    }\n    for(int i=1;i<16;i++){\n        ans += cnt[i] / 2;\n        root += (1 << (i-1)) * (cnt[i] % 2);\n    }\n    printf(\"%d\", ans + gg[root] - rec(root));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nbool test(const int x, const int y) { return x & 1 << y; }\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::vector<int> v(n, 0);\n  for (int i = 0; i != n - 1; i += 1) {\n    int x, y, a;\n    std::cin >> x >> y >> a;\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n  int ans = n;\n  int b = 0;\n  for (const int e : v) {\n    if (e == 0) {\n      ans -= 1;\n      continue;\n    }\n    if (test(b, e))\n      ans -= 1;\n    b ^= 1 << e;\n  }\n  std::vector<int> dp(b + 1, -1);\n  dp[b] = 0;\n  for (int s = b; s != 0; s -= 1) {\n    if (dp[s] == -1)\n      continue;\n    int i = 16;\n    while (i != 0) {\n      i -= 1;\n      if (test(s, i))\n        break;\n    }\n    for (int j = 0; j != i; j += 1) {\n      if (!test(s, j))\n        continue;\n      const int k = i ^ j;\n      if (k > j)\n        continue;\n      int &d = dp[s ^ 1 << i ^ 1 << j ^ 1 << k];\n      if (test(s, k))\n        d = std::max(d, dp[s] + 1);\n      else\n        d = std::max(d, dp[s]);\n    }\n  }\n  std::cout << ans - dp[0] << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}//è´ªå¿ \n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç \n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);//é¢å¤çéåçå¼æå \n    for(int i=1;i<(1<<15);i++)//æä¸¾å­éè¿è¡è½¬ç§» \n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n\n#define cil(a,b) ( ((a)%(b) == 0)?((a)/(b)):((a)/(b)+1) )\n#define err(x) cerr << #x << \" = \" << x << endl;\n#define read(a) freopen(a,\"r\",stdin)\n#define write(a) freopen(a,\"w\",stdout)\n#define forall(i,a,b) for(int i=a;i<b;i++)\n#define foreach(v, c) for(typeof((c).begin())v=(c).begin();v!=(c).end();++v)\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pii> vii;\n\nclock_t start;\nvoid Time(bool timeIt) {\n\tif (!timeIt) return;\n\tclock_t end = clock();\n\tdouble elapsed_time = ((db)end - (db)start) / (db)CLOCKS_PER_SEC;\n\tprintf(\"Time elapsed = %0.4lf\\n\", elapsed_time); \n}\n\n#define LINF (long long)1e18\n#define EPS 1e-9\n#define INF 1000000007ll\n#define SIZE 100010\n#define MAX_A 1000010\n\nint dp[1 << 16], d[SIZE] = {0}, cnt[16] = {0}, x[1 << 16];\n\nint ans(int mask) {\n\tif (dp[mask] != -1) return dp[mask];\n\tdp[mask] = 0;\n\tfor (int i = (mask - 1) & mask ; i >= 0 ; i = (i - 1) & mask) {\n\t\tif (!x[i]) dp[mask] = max(dp[mask], 1 + ans(i));\n\t\tif (i == 0) break;\n\t}\n\treturn dp[mask];\n}\n\nint main() {\n\tstart = clock();\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1 ; i < n ; ++i) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\td[u] ^= w;\n\t\td[v] ^= w;\n\t}\n\tfor (int i = 0 ; i < (1 << 16) ; ++i) dp[i] = -1;\n\n\tint mask = 0, res = 0;\n\tfor (int i = 0 ; i < n ; ++i) {\n\t\tmask ^= (1 << d[i]);\n\t\tif (d[i] != 0 && (mask & (1 << d[i])) == 0) ++res;\n\t}\n\tfor (int i = 0 ; i < (1 << 16) ; ++i) {\n\t\tx[i] = 0;\n\t\tfor (int j = 0 ; j < 16 ; ++j) {\n\t\t\tif (i & (1 << j)) x[i] ^= j;\n\t\t}\n\t}\n\tdp[0] = 0;\n\tif (mask > 0) res += __builtin_popcount(mask) - ans(mask);\n\n\tprintf(\"%d\\n\", res);\n\n\tTime(false);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    for(int i=0; i<16; i++) ans+=cnt[i]>>1, cnt[i]=cnt[i]&1;\n    ans+=cnt[0];\n    cnt[0]=0;\n    dp[0]=0;\n    for(int mask=1; mask<(1<<16); mask++){\n        dp[mask]=100;\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            int nw=0;\n            for(int i=0; i<16; i++) if(((sub>>i)&1)&&cnt[i]) nw^=i;\n            if(nw==0) dp[mask]=min(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<16)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nint A[MAXN];\n\nint solve(vector <int> C, int mask)\n{\n\tif (mask == 0)\n\t\treturn 0;\n\tif (mask < 0)\n\t\treturn INF;\n\tint ans = C[mask] >> 1, d = INF;\n\tif (C[mask] & 1)\n\t{\n\t\tREP(j, 4)\n\t\t{\n\t\t\tif (mask & (1 << j))\n\t\t\t{\n\t\t\t\tvector <int> C1 = C;\n\t\t\t\t++C1[1 << j];\n\t\t\t\t++C1[mask ^ (1 << j)];\n\t\t\t\td = min(d, solve(C1, mask - 1));\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\td = solve(C, mask - 1);\n\treturn ans + d;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tint n, ans = INF;\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tA[u] ^= a;\n\t\tA[v] ^= a;\n\t}\n\tvector <int> C(16);\n\tREP(i, n)\n\t\t++C[A[i]];\n\tcout << solve(C, 15);\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint v[111111],cnt[22];\nint lg[66666],pc[66666],spc[66666];\nint f[66666];\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F(),w=io::F();\n\t\tv[x]^=w,v[y]^=w;\n\t}\n\tfor(register int i=0;i<n;++i)cnt[v[i]]++;\n\tfor(register int i=2,j=1;i<65536;i<<=1,j++)lg[i]=j;\n\tfor(register int i=1;i<65536;++i)pc[i]=pc[i^i&-i]+1;\n\tfor(register int i=1;i<65536;++i)spc[i]=spc[i^i&-i]+pc[lg[i&-i]];\n\tint ans=0;\n\tfor(register int i=1;i<16;++i)ans+=cnt[i]>>1,cnt[i]&=1;\n\tmemset(f,63,sizeof(f));\n\tf[0]=0;\n\tfor(register int i=2;i<65536;i+=2)\n\t\tif(spc[i]%2==0)\n\t\t{\n\t\t\tint l=lg[i&-i];\n\t\t\tfor(register int j=l+1;j<16;++j)\n\t\t\t\tif(i&1<<j)\n\t\t\t\t\tfor(register int k=1;k<16;++k)\n\t\t\t\t\t\tif((l&k)==k&&(j&k)==k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t=i^1<<l^1<<j,d=1;\n\t\t\t\t\t\t\tif(t&1<<(l^k))++d;\n\t\t\t\t\t\t\tif(t&1<<(j^k))++d;\n\t\t\t\t\t\t\tt^=1<<(l^k);\n\t\t\t\t\t\t\tt^=1<<(j^k);\n\t\t\t\t\t\t\tt&=~1;\n\t\t\t\t\t\t\tcmin(f[i],f[t]+d);\n\t\t\t\t\t\t}\n\t\t}\n\tint w=0;\n\tfor(register int i=1;i<16;++i)if(cnt[i])w|=1<<i;\n\tprintf(\"%d\\n\",ans+f[w]); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(int &x){\n\tchar ch=getchar();x=0;\n\tfor (;ch==' '||ch=='\\n';ch=getchar());\n\tfor (;ch!=' '&&ch!='\\n';x=x*10+ch-'0',ch=getchar());\n}\nvoid write(int x){\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n}\nint n,val[200004],cnt[16],ans,mask,dp[65540];\nbool good[65548];\nint main(){\n\tread(n);\n\tfor (int i=1;i<n;i++){\n\t    int x,y,z;\n\t    read(x),read(y),read(z);\n\t    val[x]^=z,val[y]^=z;\n\t}\n\tfor (int i=0;i<n;i++){\n    \tcnt[val[i]]++;\n\t}\n\tfor (int i=1;i<16;i++)ans+=cnt[i]/2,cnt[i]%=2;\n\tfor (int i=1;i<16;i++)if(cnt[i]==1)ans++,mask|=(1<<i); \n\tfor (int i=0;i<(1<<16);i++){\n\t\tint x=0;\n    \tfor (int j=0;j<16;j++){\n    \t\tif (i&(1<<j)){\n        \t\tx^=j;\n    \t\t}\n    \t}\n    \tgood[i]=(x==0);\n\t}\n\tfor (int i=0;i<(1<<16);i++){\n\t\tif (i&1)continue;\n    \tfor (int j=i;j;j=(j-1)&i)if(good[j])dp[i]=max(dp[i],dp[i^j]+1);\n    }\n\twrite(ans-dp[mask]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, w, x[100005], c[16], ans, p3[20];\nshort dp[15000000];\nvector<int> r;\ninline bool val(int B){\n    int C=0;\n    bool f=0;\n    fox(l, m){\n        if (B/p3[l]%3==1){\n            C^=r[l];\n            f=1;\n        }\n    }\n    return f && C==0;\n}\ninline int nxt(int B){\n    fox(l, m){\n        if (B/p3[l]%3==1) B+=p3[l];\n    }\n    return B;\n}\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            if (dp[l]<0) continue;\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                }\n            }\n            if (val(l)){\n                //cout << \"*\";\n                dp[nxt(l)]=max(dp[nxt(l)], dp[l]+1);\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 2 * 1e5 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxN], cnt[20];\nbool xr[MaxN];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 0; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 0; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 0; i < (1 << 15); ++ i) -- f[i];\n\n\tfor (int i = 0; i < (1 << 15); ++ i)\n\t\tfor (int j = 0; j < 15; ++ j)\n\t\t\tif ((i >> j) & 1) xr[i] ^= (j + 1);\n\tfor (int s = 0; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s] != 0) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (xr[t] == 0) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\n\nvector<int> eis[100010];\nint ps[100010];\nint val[100010];\n\nint deg[100010];\nbool dead[100010];\n\nqueue<int> q;\n\nint ans;\nvoid dfs(int x, int m){\n\tif(!m) return;\n\t++ans;\n\tint bef = -1;\n\twhile(true){\n\t\tbool f=0;\n\t\tfor(int ei:eis[x]){\n\t\t\tint y=ps[ei]-x;\n\t\t\tif(y == bef) continue;\n\t\t\tif(dead[y]) continue;\n\t\t\tif(!(val[m] & val[ei])) continue;\n\t\t\tval[ei] ^= val[m];\n\t\t\tbef = x; x = y;\n\t\t\tf=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(!f) break;\n\t}\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<n; ++i){\n\t\tint a, b, x; read(a, b, x);\n\t\tps[i]=a+b; val[i]=x;\n\t\teis[a].pb(i);\n\t\teis[b].pb(i);\n\t\t++deg[a]; ++deg[b];\n\t}\n\tfor(int i=0; i<n; ++i) if(deg[i]==1) q.push(i);\n\t\n\twhile(q.size()){\n\t\tint x=q.front(); q.pop();\n\t\tif(dead[x]) continue;\n\t\tdead[x]=1;\n\t\tfor(int ei:eis[x]){\n\t\t\tint y=ps[ei]-x;\n\t\t\tif(dead[y]) continue;\n\t\t\tdfs(x, val[ei]);\n\t\t\t--deg[y];\n\t\t\tif(deg[y]<=1) q.push(y);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N = 100010;\nint n, val[N], res, cnt[20], Get, dp[1 << 17], st[20];\nbool check(int s)\n{\n\tint cnt = 0;\n\twhile(s)\n\t{\n\t\tint t = s & 1;\n\t\ts >>= 1;\n\t\tif(st[cnt] == 0 && t) return false;\n\t\tcnt ++;\n\t}\n\treturn true;\n}\nint Solve(int s)\n{\n\tif(s == 0) return 0;\n\tif(dp[s] != 0x3f3f3f3f) return dp[s];\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tfor(int j=i+1;j<=15;j++)\n\t\t{\n\t\t\tif((s >> i & 1) && (s >> j & 1))\n\t\t\t{\n\t\t\t\tint t = i ^ j;\n\t\t\t\tint p = s ^ (1 << i) ^ (1 << j) ^ (1 << t);\n\t\t\t\tif(s >> t & 1) dp[s] = std:: min(dp[s], Solve(p) + 2);\n\t\t\t\telse dp[s] = std:: min(dp[s], Solve(p) + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s];\n}\nint main() \n{\n\tscanf(\"%d\", &n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tval[u] ^= w; val[v] ^= w; \n\t}\n\tfor(int i=0;i<n;i++) cnt[val[i]] ++;\n\tfor(int i=1;i<=15;i++) \n\t{\n\t\tres += cnt[i] / 2;\n\t\tif(cnt[i] & 1) Get |= (1 << i), st[i] = 1;\n\t}\n\tmemset(dp, 0x3f3f3f3f, sizeof(dp));\n\tprintf(\"%d\\n\", res + Solve(Get));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n, m; cin >> n >> m;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tvector< vector<int> > g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<int> komp(n, -1);\n\tint kompKnt = 0;\n\tvector<int> mik(n, -1);\n\t\n\tfunction<void(int, int, int)> dfs = [&](int v, int p, int kol) {\n\t\tkomp[v] = kol;\n\t\tif (mik[kol] < 0 || a[v] < a[mik[kol]]) {\n\t\t\tmik[kol] = v;\n\t\t}\n\t\tfor (int to: g[v]) {\n\t\t\tif (to != p) {\n\t\t\t\tdfs(to, v, kol);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tif (komp[i] < 0) {\n\t\t\tdfs(i, -1, kompKnt);\n\t\t\tkompKnt++;\n\t\t}\n\t}\n\t\n\tif (kompKnt == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tif (n - 2*kompKnt + 2 < 0) {\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tint64_t soom = 0;\n\t\n\tvector<char> used(n, true);\n\tfor (int i = 0; i < kompKnt; i++) {\n\t\tused[mik[i]] = false;\n\t\tsoom += a[mik[i]];\n\t}\n\t\n\tvector<int> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) {\n\t\t\tq.push_back(a[i]);\n\t\t}\n\t}\n\tsort(q.begin(), q.end());\n\tfor (int i = 0; i < kompKnt - 2; i++) {\n\t\tsoom += q[i];\n\t}\n\t\n\tcout << soom << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mit map<int,int>::iterator\n#define sit set<int>::iterator\n#define itrm(g,x) for(mit g=x.begin();g!=x.end();g++)\n#define itrs(g,x) for(sit g=x.begin();g!=x.end();g++)\n#define ltype int\n#define rep(i,j,k) for(ltype(i)=(j);(i)<=(k);(i)++)\n#define rap(i,j,k) for(ltype(i)=(j);(i)<(k);(i)++)\n#define per(i,j,k) for(ltype(i)=(j);(i)>=(k);(i)--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mpr make_pair\n#define pb push_back\n#define fastio ios::sync_with_stdio(false)\nconst int inf=0x3f3f3f3f,mod=1000000007;\nconst double pi=3.1415926535897932,eps=1e-6;\nint n,v[100005],b[32777],dp[32777],fin,cn[17],ans;bool ok[32777];\nint main()\n{\n    scanf(\"%d\",&n);\n    rap(i,1,n){\n        int x,y,w;\n        scanf(\"%d%d%d\",&x,&y,&w);\n        v[x]^=w;v[y]^=w;\n    }\n    int lim=1<<15;\n    rap(i,0,lim) cn[v[i]]++;\n    rap(i,0,lim) b[i]=__builtin_popcount(i);\n    rap(i,0,15) {\n        ans+=cn[i+1]/2;\n        if(cn[i+1]&1) fin|=(1<<i);\n    }\n    rap(i,0,lim){\n        int xr=0;\n        rap(j,0,15) if(i&(1<<j)) xr^=(j+1);\n        ok[i]=!xr;\n    }\n    rap(i,0,lim) dp[i]=inf;\n    dp[0]=0;\n    rap(i,0,lim){\n        int u=(lim-1)^i;\n        for(int ii=u;ii;ii=(ii-1)&u){\n            if(ok[ii])\n            dp[i^ii]=min(dp[i^ii],dp[i]+b[ii]-1);\n        }\n    }\n    printf(\"%d\\n\",ans+dp[fin]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define eb emplace_back\n#define ll long long\n#define nl '\\n'\n#define deb(x) cerr<<#x\" = \"<<x<<nl\n#define in() ( { int a ; scanf(\"%d\",&a); a; } )\n\nconst int N = 3e5 + 9;\nconst int mod = 1e9 + 7;\n\nint a[N], cnt[16], dp[1<<16], pos[1<<16];\nint32_t main()\n{\n    int n=in();\n    for(int i=1; i<n; i++){\n        int u=in(), v=in(), k=in();\n        u++; v++;\n        a[u]^=k; a[v]^=k;\n    }\n    int ans=0;\n    for(int i=1; i<=n; i++) cnt[a[i]]++;\n    ans+=cnt[0];\n    for(int i=1; i<16; i++) ans+=cnt[i]>>1, cnt[i]%=2;\n    cnt[0]=0;\n    dp[0]=0;\n    vector<int> v;\n    for(int i=0; i<16; i++) if(cnt[i]) v.eb(i);\n    int m=v.size();\n    for(int mask=1; mask<(1<<m); mask++){\n        int nw=0;\n        for(int i=0; i<m; i++) if((mask>>i)&1) nw^=v[i];\n        if(nw==0) pos[mask]=1;\n    }\n    for(int mask=1; mask<(1<<m); mask++){\n        for(int sub=mask; sub; sub=(sub-1)&mask){\n            if(pos[sub]) dp[mask]=max(dp[mask], dp[mask^sub]+1);\n        }\n    }\n    ans+=dp[(1<<m)-1];\n    cout<<n-ans<<nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nvoid chkmin(int &x,int y){\n\tx=x<y?x:y;\n}\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],w[maxn<<1],e;\nvoid putin(int s,int t,int v){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n\tw[e]=v;\n}\nint cnt[20],ans;\nvoid dfs(int u,int fa,int fv){\n\tint sum=fv;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tdfs(tto[i],u,w[i]);\n\t\tsum^=w[i];\n\t}\n\tif(sum==0) return;\n\tans+=cnt[sum];\n\tcnt[sum]^=1;\n}\nint dp[1<<15];\nint popcnt[1<<15];\nint main(){\n//\tfreopen(\"F.in\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s,t,v;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&s,&t,&v);\n\t\ts++,t++;\n\t\tputin(s,t,v);\n\t\tputin(t,s,v);\n\t}\n\tdfs(1,0,0);\n\tfor(int i=1;i<(1<<15);i++)\n\t\tpopcnt[i]=popcnt[i>>1]+(i&1);\n\n\tint val;\n\tfor(int i=1;i<(1<<15);i++){\n\t\tdp[i]=popcnt[i];\n\t\tval=0;\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tval^=j+1;\n\t\tif(val==0)\n\t\t\tdp[i]--;\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=i;j;j=i&(j-1))\n\t\t\tchkmin(dp[i],dp[j]+dp[i^j]);\n\tval=0;\n\tfor(int i=1;i<=15;i++)\n\t\tif(cnt[i])\n\t\t\tval|=1<<(i-1);\n\tans=ans+dp[val];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200010\nint n,va[N],c[N],ans,s,f[N],ss[N],nm[N];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<N;i++)\n\t\tnm[i]=nm[i-(i&-i)]+1;\n\tfor(int i=1;i<N;i++)nm[i]--;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tva[x]^=z;\n\t\tva[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[va[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]%2==1)s|=(1<<(i-1));\n\t}\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j))ss[i]^=(j+1);\n\tfor(int i=1;i<(1<<15);i++)\n\t\tif(!ss[i])\n\t\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\t\tif(!ss[j]&&!ss[i-j])\n\t\t\t\t\tnm[i]=min(nm[i],nm[i-j]+nm[j]);\n\tcout<<ans+nm[s];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();w[u]^=va;w[v]^=va;}rp(i,1,n)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tn=(1<<15)-1;\n\trp(i,1,n)d[i]=d[i>>1]+(i&1);rp(i,1,n-1)d[i]-=1;\n\trp(i,1,n){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n\trp(i,1,n)\n\t{\n\t\tif(!sxr[i])for(int k=(i-1)&i;k;k=(k-1)&i)if(!sxr[k])d[i]=min(d[i],d[k]+d[i^k]);\n\t}\n\tprintf(\"%d\",res+d[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: Barry Wang\nLANG: C++11\nTASK: \n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/*---define tricks---*/\n#define ALL(v) v.begin(),v.end()\n#define UN(v) sort(ALL(v)),v.erase(unique(ALL(v)),v.end())\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define EACH(v,it) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define FIO ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define revsort(b,e) sort(b,e),reverse(b,e)\n#define X first\n#define Y second\n#define Chtolly return 0\n/*---define types---*/\ntypedef long long ll;\ntypedef list<int> li;\ntypedef queue<int> qi;\ntypedef deque<int> dqi;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef unsigned int uint;\n/*---define variables---*/\nconst int inf=(1<<29);\nint n;\nint x[100005],y[100005],v[100005];\nint val[100005];\nint cnt[100005];\nll ans;\nuint st;\nbool zero[1<<16];\nll dp[1<<16];\n/*---define function---*/\n\n/*---main code---*/\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>x[i]>>y[i]>>v[i];\n\t\tval[x[i]]^=v[i];val[y[i]]^=v[i];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tcnt[val[i]]++;\n\t}\n\tfor(int i=1;i<=15;++i){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]%2){\n\t\t\tst|=(1<<i);\n\t\t}\n\t}\n\tfor(int mask=0;mask<(1<<16);++mask){\n\t\tint V=0;\n\t\tfor(int i=0;i<16;++i){\n\t\t\tif(mask&(1<<i)){\n\t\t\t\tV^=i;\n\t\t\t}\n\t\t}\n\t\tif(V==0){\n\t\t\tzero[mask]=1;\n\t\t}\n\t}\n\tfor(int mask=0;mask<(1<<16);++mask){\n\t\tif(mask&1){\n\t\t\tcontinue;\n\t\t}\n\t\tint M=mask;\n\t\twhile(M>0){\n\t\t\tif(zero[M]){\n\t\t\t\tdp[mask]=max(dp[mask],dp[mask^M]+1);\n\t\t\t}\n\t\t\tM=(M-1)&mask;\n\t\t}\n\t}\n\tcout<<ans+__builtin_popcount(st)-dp[st]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     âââââââââââ\n//                                                                   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                                                                ââââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬âââ\n//                                            âââââââââââ       âââ¬â¬â¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬ââ\n//                                      ââââââââââ¬â¬â¬â¬â¬âââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬ââ\n//                               âââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬ââ\n//                             âââââ¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//                           ââââ¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬ââââ¬â¬â¬â¬â¬â¬â¬âââââ\n//                         ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââââââââ¬â¬â¬â¬â¬ââ\n//                       ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬âââ\n//                     ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬ââ\n//                 âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬ââââ\n//     ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬ââââââ\n//   âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââââ¬â¬â¬â¬â¬â¬â¬ââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬âââ¬â¬â¬ââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬ââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââââ¬â¬â¬âââââ¬â¬âââââ¬â¬â¬â¬â¬â¬â¬âââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬âââ\n// âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬âââââ\n// ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââââ\n//   ââââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââââ¬â¬â¬â¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââ\n//       ââââââââââââââ  âââââ¬â¬â¬â¬â¬â¬ââââââââââââââââââââââââââââ¬â¬â¬â¬â¬âââ¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬â¬ââââ\n//                         âââââââ                           âââââ  âââââââââââââââââââ  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define fs first\n#define sc second\n//#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n,0);\n  REP(_,n-1){\n    int x,y,v;\n    cin >> x >> y >> v;\n    a[x] ^= v;\n    a[y] ^= v;\n  }\n  \n  vec b(16,0);\n  REP(i,n) b[a[i]]++;\n\n  int ans = 0;\n  REP(i,16){\n    if(i) ans += b[i]/2;\n  }\n\n  vec dp(1<<15,-INF); dp[0] = 0;\n  int mask = 0;\n  REP(i,15) if(b[i+1]&1) mask += (1<<i);\n  \n  REP(i,1<<15){\n    int x = mask & (~i);\n    for(;x;x--){\n      x &= mask; int cnt = 0;\n      REP(k,15) if(parity(x,k)) cnt ^= k+1;\n      if(!cnt) chmax(dp[i+x],dp[i]+1); \n    }\n  }\n\n  cout << ans - dp[mask] + pcnt(mask) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXS = 1 << 16;\nconst int MAXN = 1e5 + 5;\nint dp[MAXS] , n , S , a[MAXN];\nint main() {\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u , v , w;\n\t\tscanf(\"%d %d %d\" , &u , &v , &w);\n\t\ta[u] ^= w;\n\t\ta[v] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(S & (1 << a[i])) ans ++;\n\t\tS ^= (1 << a[i]);\n\t} \n//\tprintf(\"%d \" , S);\n\tmemset(dp , 127 , sizeof dp);\n\tdp[1] = dp[0] = 0;\n\tfor (int now = 2; now < (1 << 15); ++now) {\n\t\tfor (int i = 1; i < 15; ++i) {\n\t\t\tif(!(now & (1 << i))) continue;\n\t\t\tfor (int j = i + 1; j < 15; ++j) {\n\t\t\t\tif(!(now & (1 << j))) continue;\n\t\t\t\tint nnow = now ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\tdp[now] = min(dp[now] , dp[nnow] + 1 + ((now ^ (1 << i) ^ (1 << j)) & (1 << (i ^ j))));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\" , dp[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int NMAX = 1e5;\nint n;\nint b[NMAX + 5];\nint dp[(1 << 15)];\n\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i = 1;i < n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tx++;\n\t\ty++;\n\t\tb[x] ^= z;\n\t\tb[y] ^= z;\n\t}\n\t\n\tint ans = n;\n\tint mask = 0;\n\t\n\t\n\tfor(int i = 1;i <= n;i++){\n\t\tif(b[i] == 0){\n\t\t\tans--;\n\t\t}\n\t\telse if((mask >> (b[i] - 1)) & 1){\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t\tans--;\n\t\t}\n\t\telse{\n\t\t\tmask ^= (1 << (b[i] - 1));\n\t\t}\n\t}\n\t\t\n\tdp[0] = 0;\n\t\n\tfor(int i = 1;i <= mask;i++){\n\t\tdp[i] = -(1 << 28);\n\t\tfor(int j = i;j;j = (j - 1) & i){\n\t\t\tint xo = 0;\n\t\t\t\n\t\t\tfor(int b = 0;b < 15;b++){\n\t\t\t\tif((j >> b) & 1){\n\t\t\t\t\txo ^= (b + 1);///cause i subtracted 1 before to make them in [0,15) range\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(xo == 0){\n\t\t\t\tdp[i] = max(dp[i],1 + dp[i ^ j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans -= dp[mask];\n\t\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[100020];\nint n, x, y, z;\nint w[100020];\nint c[16];\nint f[65537];\nint g[65537];\nint ans, mask;\nint dfs(int x, int y) {\n\tint re = w[x];\n\tfor (int i: a[x]) {\n\t\tif (i != y) {\n\t\t\tre ^= dfs(i, x);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t\tw[x] ^= z;\n\t\tw[y] ^= z;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tc[w[i]]++;\n\t}\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += c[i] / 2;\n\t\tc[i] %= 2;\n\t\tmask |= c[i] << i;\n\t}\n\tfor (int i = 0; i < 1 << 16; i++) {\n\t\tint v = 0, c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tv ^= j;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif (v == 0) {\n\t\t\tf[i] = c - 1;\n\t\t} else {\n\t\t\tf[i] = -1;\n\t\t}\n\t\tfor (int j = i; ; j = (j - 1) & i) {\n\t\t\tif (f[j] >= 0 && f[i ^ j] >= 0) {\n\t\t\t\tf[i] = min(f[i], f[j] + f[i ^ j]);\n\t\t\t}\n\t\t\tif (j == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + f[mask]);\n//\tdfs(0, -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint main() {\n    int n;\n    cin >> n;\n\n    VI x(n);\n    REP(i,n-1){\n        int p, q, a;\n        scanf(\"%d %d %d\", &p, &q, &a);\n        x[p] ^= a;\n        x[q] ^= a;\n    }\n\n    VI a, c(16);\n    REP(i,n){\n        c[x[i]]++;\n    }\n\n    int ans = 0;\n    FOR(i,1,15){\n        ans += c[i] / 2;\n        if (c[i] % 2) a.push_back(i);\n    }\n\n    int m = a.size();\n    // REP(i,m) cout << a[i]<< endl;\n\n\n    VI dp(1<<m, 0);\n    FOR(mask,1,(1<<m)-1){\n        int s = 0;\n        REP(i,m) if ((mask >> i) & 1) s ^= a[i];\n        // cout << s << endl;\n        if (s) continue;\n        dp[mask] = 1;\n        for (int i = mask; i > 0; i = (mask & (i - 1))){\n            if (i == mask) continue;\n            s = 0;\n            REP(j,m) if ((i >> j) & 1) s ^= a[j];\n            if (s == 0){\n                dp[mask] = max(dp[mask], dp[i] + dp[mask ^ i]);\n            }\n        }\n    }\n\n    // REP(i,1<<m) cout << dp[i] << endl;\n\n    ans += m - dp[(1<<m)-1];\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100000+10;\nint n,a[maxn],cnt[20],f[1<<15],g[1<<15];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint x,y,w;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\ta[x]^=w;a[y]^=w;\n\t}\n\tfor(int i=0;i<n;i++) cnt[a[i]]++;\n\tint res=0,s=0;\n\tfor(int i=1;i<=15;i++)\n\t\tres+=cnt[i]>>1,s|=(cnt[i]&1)<<(i-1);\n\tfor(int i=0;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)\n\t\t\tif(i&(1<<j)) f[i]++,g[i]^=j+1;\n\tfor(int i=1;i<(1<<15);i++) f[i]=!g[i]?f[i]-1:0;\n\tfor(int i=1;i<(1<<15);i++)\n\t\tif(!g[i])\n\t\t{\n\t\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t\t\tif(!g[k]) f[i]=min(f[i],f[k]+f[i^k]);\n\t\t}\n\tprintf(\"%d\\n\",res+f[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=1e5,M=(1<<16)+1000;\nint n,a[N],f[M],cnt[M],as,st,S,x[M];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\t//freopen(\"3913.in\",\"r\",stdin);freopen(\"3913.out\",\"w\",stdout);\n\tn=read();rp(i,1,n-1){ri x=read()+1,y=read()+1,z=read();a[x]^=z;a[y]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\tf[0]=0;rp(i,1,S)f[i]=f[i>>1]+(i&1);\n\trp(i,1,S)--f[i];rp(i,1,S)rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; \nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}\n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++){\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[100020];\nint n, x, y, z;\nint w[100020];\nint c[16];\nint f[65537];\nint g[65537];\nint ans, mask;\nint dfs(int x, int y) {\n\tint re = w[x];\n\tfor (int i: a[x]) {\n\t\tif (i != y) {\n\t\t\tre ^= dfs(i, x);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t\tw[x] ^= z;\n\t\tw[y] ^= z;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tc[w[i]]++;\n\t}\n\tfor (int i = 0; i < 16; i++) {\n\t\tans += c[i] / 2;\n\t\tc[i] %= 2;\n\t\tmask |= c[i] << i;\n\t}\n\tfor (int i = 0; i < 1 << 16; i++) {\n\t\tint v = 0, c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tv ^= j;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif (v == 0) {\n\t\t\tf[i] = c - 1;\n\t\t} else {\n\t\t\tf[i] = -1;\n\t\t}\n\t\tfor (int j = i; ; j = (j - 1) & i) {\n\t\t\tif (f[j] >= 0 && f[i ^ j] >= 0) {\n\t\t\t\tf[j] = min(f[j], f[i] + f[i ^ j]);\n\t\t\t}\n\t\t\tif (j == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + f[mask]);\n//\tdfs(0, -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// KALAM\n# include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100000 + 77 , L = 16;\nint n , A , a[N] , T[L];\nint dp[1 << L] , XOR[1 << L];\nvector < int > V;\nint main() {\n   scanf(\"%d\" , & n);\n   for(int v , u , x , i = 1;i < n;++ i)\n      scanf(\"%d %d %d\" , & v , & u , & x) , a[++ v] ^= x , a[++ u] ^= x;\n   for(int i = 1;i <= n;++ i)\n      ++ T[a[i]];\n   T[0] = 1;\n   for(int i = 1;i < L;++ i)\n      A += (T[i] >> 1) , T[i] &= 1;\n   for(int i = 1;i < L;++ i)\n      if(T[i] > 0)\n         V.push_back(i);\n\n   int sz = V.size();\n   for(int msk = 1;msk < (1 << sz);++ msk) {\n      dp[msk] = N - 1;\n      for(int i = 0;i < sz;++ i)\n         if((1 << i) & msk)\n            XOR[msk] ^= V[i];\n      if(XOR[msk] > 0)\n         continue ;\n      dp[msk] = __builtin_popcount(msk) - 1;\n      for(int sub = msk;sub > 0;sub = (sub - 1) & msk)\n         if(XOR[sub] == 0)\n            dp[msk] = min(dp[msk] , dp[sub] + dp[msk ^ sub]);\n   }\n   printf(\"%d\\n\" , A + dp[(1 << sz) - 1]);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint num[16];\nvector<i_i> paths[100000];\nint ans = 0;\n\n/*\ni_i dfs(int now, int from) {\n    int nowcost = 0;\n    for(auto tmp : paths[now]) {\n        int to = tmp.first;\n        int c = tmp.second;\n        if(to == from) continue;\n        dfs(to, now);\n\n    }\n}\n*/\nint dp[1<<16];\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 0; i < N - 1; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        paths[a].push_back({b, c});\n        paths[b].push_back({a, c});\n    }\n    for(int i = 1; i < N; i++) {\n        int nowcost = 0;\n        for(auto tmp : paths[i]) {\n            nowcost ^= tmp.second;\n        }\n        num[nowcost]++;\n    }\n    /*\n    for(int i = 0; i < 16; i++) {\n        cerr << i << \" \" << num[i] << endl;\n    }\n    */\n    num[0] = 0;\n    int Rest = 0;\n    for(int i = 0; i < 16; i++) {\n        cerr << i << \" \" << num[i] << endl;\n        ans += (num[i] + 1) / 2;\n        num[i] &= 1;\n        Rest |= (num[i] << i);\n    }\n    cerr << ans << endl;\n    for(int bits = 0; bits < (1<<16); bits++) {\n        for(int sub = bits + 1; ;) {\n            sub--;\n            if(sub <= 0) break;\n            sub &= bits;\n            //cerr << bits << \" \" << sub << endl;\n            if((sub & Rest) != sub) continue;\n            int xorsum = 0;\n            for(int i = 0; i < 16; i++) {\n                if(sub & (1 << i)) xorsum ^= i;\n            }\n            if(xorsum != 0) continue;\n            chmax(dp[bits], dp[bits & (~sub)] + 1);\n        }\n        //cerr << bits << \" \" << dp[bits] << endl;\n    }\n    cout << ans - dp[(1 << 16) - 1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint ans,a[N],x,y,v,n,cc[17],c[N],q,mx[N],dp[N],ff[N];\nint i,j,k;\nint main(){\n\tcin>>n;\n\tfor(i=1;i<n;++i){\n\t\tcin>>x>>y>>v;\n\t\ta[x]^=v;\n\t\ta[y]^=v;\n\t}\n\tfor(i=0;i<n;++i)++cc[a[i]];\n\tfor(i=1;i<=15;++i){\n\t\tans+=cc[i]/2;\n\t\tq+=((cc[i]&1)<<i-1);\n\t}\n\tfor(i=1;i<(1<<15);++i){\n\t\tdp[i]=dp[i>>1]+(i&1);\n\t}\n\tfor(i=1;i<(1<<15);++i)--dp[i];\n\tfor(i=1;i<(1<<15);++i){\n\t\tfor(j=0;j<15;++j){\n\t\t\tif(((1<<j)&i))ff[i]^=(j+1);\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tif(ff[i])continue;\n\t\tfor(k=(i-1);k;k=(k-1)&i){\n\t\t\tif(ff[k]==0)dp[i]=min(dp[i],dp[k]+dp[i^k]);\n\t\t}\n\t}cout<<dp[q]+ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, w, x[100005], c[16], dp[15000000], ans, p3[20];\nvector<pii> v[100005];\nvector<int> r;\nbool val(int B){\n    int C=0;\n    bool f=0;\n    fox(l, m){\n        if (B/p3[l]%3==1){\n            C^=r[l];\n            f=1;\n        }\n    }\n    return f && C==0;\n}\nint nxt(int B){\n    fox(l, 16){\n        if (B/p3[l]%3==1) B+=p3[l];\n    }\n    return B;\n}\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                }\n            }\n            if (val(l)){\n                //cout << \"*\";\n                dp[nxt(l)]=max(dp[nxt(l)], dp[l]+1);\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define pb push_back\n#define ppb pop_back\n#define all(x) (x).begin(), (x).end()\n\ntemplate <typename T>\nusing pr = array <T, 2>;\n\ntemplate <typename T>\nusing ord_set = tree <T, null_type, less <T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1e5 + 123;\nint n, a[N], cnt[16], b[N], dp[1 << 15], f[1 << 15];\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint x, y, w;\n\t\tcin >> x >> y >> w;\n\t\ta[x] ^= w, a[y] ^= w;\n\t}\n\tint m = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[a[i]]++;\n\t}\n\tint k = cnt[0];\n\tfor (int i = 1; i < 16; i++) {\n\t\tk += cnt[i] / 2;\n\t\tif (cnt[i] & 1) {\n\t\t\tb[m++] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i < (1 << m); i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tf[i] ^= b[j];\n\t\t\t}\n\t\t}\n\t\tif (f[i] == 0) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\tdp[i] = max(dp[i], dp[j] + dp[i ^ j]);\n\t\t}\n\t}\n\tcout << n - dp[(1 << m) - 1] - k;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 100007\nusing namespace std;\nvector<int> g[MAXN],w[MAXN],v;\nint sga[MAXN],dp[MAXN],cnt[16];\nvoid dfs(int s,int f,int d)\n{\n\tint x=0;\n\tfor(int i=0;i<g[s].size();i++) if(g[s][i]!=f) dfs(g[s][i],s,w[s][i]);\n\tfor(int i=0;i<g[s].size();i++) if(g[s][i]!=f) x^=w[s][i];\n\tif(x!=d && s!=f) cnt[x^d]++;\n}\nint main()\n{\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint t1,t2,t3;\n\t\tcin>>t1>>t2>>t3;\n\t\tg[t1].push_back(t2);\n\t\tg[t2].push_back(t1);\n\t\tw[t1].push_back(t3);\n\t\tw[t2].push_back(t3);\n\t}\n\tdfs(0,0,0);\n\tint sol=0;\n\tfor(int i=1;i<=15;i++) {sol+=cnt[i]/2; if(cnt[i]&1) v.push_back(i);}\n\tint m=v.size();\n\tfor(int i=0;i<m;i++) sga[1<<i]=1;\n\tfor(int i=0;i<(1<<m);i++)\n\t{\n\t\tint x=0;\n\t\tfor(int j=0;j<m;j++) if((1<<j)&i) x^=v[j];\n\t\tif(x==0) sga[i]=__builtin_popcount(i)-1;\n\t}\n\tfill(dp,dp+MAXN,100000); dp[0]=0;\n\tfor(int i=1;i<(1<<m);i++)\n\t{\n\t\tint sb=i;\n\t\tdo\n\t\t{\n\t\t\tif(sga[sb]) dp[i]=min(dp[i],dp[i^sb]+sga[sb]);\n        \tsb = (sb-1) & i;\n    \t} while(sb!=0);\n\t}\n\tcout<<sol+dp[(1<<m)-1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nstruct node{\n\tint sumy;\n\tint val;\n};\nint n;\nint hed[N],tal[N<<1],val[N<<1],nxt[N<<1],cnt=0;\nint nod[N];\nint bot[16];\nint sum=0;\nint q[16],t=0;\nint sxr[1<<17];\nint d[1<<17];\nvoid addege(int x,int y,int z){\n\tcnt++;\n\ttal[cnt]=y;\n\tval[cnt]=z;\n\tnxt[cnt]=hed[x];\n\thed[x]=cnt;\n} \nvoid dfs(int u,int fa){\n\tfor(int i=hed[u];i;i=nxt[i]){\n\t\tint v=tal[i];\n\t\tif(v==fa) continue;\n\t\tnod[v]^=val[i];\n\t\tdfs(v,u);\n\t\tnod[u]^=val[i];\n\t}\n}\nbool cmp(node x,node y){\n\treturn x.sumy>y.sumy;\n}\nint st=0;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++,y++;\n\t\taddege(x,y,z);\n\t\taddege(y,x,z);\n\t}\n\tdfs(1,1);\n\t//for(int i=1;i<=n;i++) cout<<nod[i]<<endl;\n\tfor(int i=1;i<=n;i++) bot[nod[i]]++;\n\tfor(int i=1;i<=15;i++) sum+=bot[i]/2,st|=(bot[i]&1)<<(i-1);\t\n\tfor(int i=1;i<(1<<15);i++) d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++) d[i]-=1;\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++)\n    {\n        if(sxr[i]!=0) continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }\n    cout<<d[st]+sum<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>bin[20];\nconst int maxn=1000000;\nint n,d[maxn+4]={0},v[20]={0},f[(1<<20)+4];\nint main()\n{\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x]^=z,d[y]^=z;\n\t} \n\tint s=0,res=0,t=0;\n\tfor(int i=0;i<n;i++)v[d[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tres+=v[i]/2,v[i]%=2;\n\t\tif(v[i]){\n\t\t\ts|=(1<<(i-1));\n\t\t\tt++;\n\t\t}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=14;j++)\n\t\t\tif(i&(1<<j))cnt++;\n\t\tbin[cnt].push_back(i);\n\t}\n\tfor(int p=2;p<=t;p++)\n\t\tfor(int k=0;k<bin[p].size();k++){\n\t\t\tint i=bin[p][k];\n\t\t\tfor(int u=0;u<=14;u++)\n\t\t\tif(i&(1<<u))\n\t\t\tfor(int v=0;v<=14;v++)\n\t\t\t\tif(i&(1<<v)&&(u!=v)){\n\t\t\t\t\tint w=(u+1)^(v+1)-1; \n\t\t\t\t\tif(i&(1<<w))f[i]=min(f[i],f[i-(1<<w)-(1<<u)-(1<<v)]+2);\n\t\t\t\t\telse f[i]=min(f[i],f[i-(1<<u)-(1<<v)+(1<<w)]+1);\n\t\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[s]+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nclass edge {\npublic:\n\tint to, cost;\n\tedge() : to(-1), cost(0) {};\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<int> col(N);\n\tfunction<int(int, int, int)> set_col = [&](int pos, int pre, int pcol) {\n\t\tint res = 0;\n\t\tfor (edge e : G[pos]) {\n\t\t\tif (e.to == pre) continue;\n\t\t\tset_col(e.to, pos, e.cost);\n\t\t\tres ^= e.cost;\n\t\t}\n\t\tres ^= pcol;\n\t\tcol[pos] = res;\n\t\tres ^= col[pos];\n\t\treturn res;\n\t};\n\tset_col(0, -1, 0);\n\tvector<int> tbl(16);\n\tfor (int i = 0; i < N; ++i) {\n\t\t++tbl[col[i]];\n\t}\n\tint bit = 0, ans = 0;\n\tfor (int i = 1; i < 16; ++i) {\n\t\tans += (tbl[i] >> 1);\n\t\tbit |= (tbl[i] & 1) << i;\n\t}\n\tqueue<pair<int, int> > que;\n\tvector<int> dist(1 << 16, inf);\n\tque.push(make_pair(0, bit));\n\tdist[bit] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.front().second; que.pop();\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\tif (!((u >> i) & 1)) continue;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (!((u >> j) & 1)) continue;\n\t\t\t\tint b = u ^ (1 << i) ^ (1 << j);\n\t\t\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\t\t\tint tar = b ^ (1 << (i ^ k)) ^ (1 << (j ^ k)), cost = 1;\n\t\t\t\t\tif ((b >> (i ^ k)) & 1) ++cost;\n\t\t\t\t\tif ((b >> (j ^ k)) & 1) ++cost;\n\t\t\t\t\tif (dist[tar] > dist[u] + cost) {\n\t\t\t\t\t\tdist[tar] = dist[u] + cost;\n\t\t\t\t\t\tque.push(make_pair(-dist[tar], tar));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans += min(dist[0], dist[1]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <string>\n#include <time.h>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nvector <PII> g[MAXN];\nbool used[MAXN], T[4][MAXN], T1[4][MAXN];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tREP(i, SZ(g[v]))\n\t{\n\t\tint to = g[v][i].first;\n\t\tif (!used[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tREP(j, 4)\n\t\t\t\tif (g[v][i].second & (1 << j))\n\t\t\t\t{\n\t\t\t\t\tT[j][v] ^= 1;\n\t\t\t\t\tT[j][to] ^= 1;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"sparse.in\", \"r\", stdin);\n\t//freopen(\"sparse.out\", \"w\", stdout);\n\tsrand(time(NULL));\n\tint n, ans = INF, time0 = clock();\n\tcin >> n;\n\tREP(i, n - 1)\n\t{\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tg[u].push_back(MP(v, a));\n\t\tg[v].push_back(MP(u, a));\n\t}\n\tdfs(0);\n\twhile (clock() - time0 < 1.95 * CLOCKS_PER_SEC)\n\t{\n\t\tREP(j, 4)\n\t\t\tREP(i, n)\n\t\t\tT1[j][i] = T[j][i];\n\t\tint cur = 0;\n\t\tRFOR(mask, 16, 1)\n\t\t{\n\t\t\tvector <int> A;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tbool ok = true;\n\t\t\t\tREP(j, 4)\n\t\t\t\t\tif ((mask & (1 << j)) && !T1[j][i])\n\t\t\t\t\t\tok = false;\n\t\t\t\tif (ok)\n\t\t\t\t\tA.push_back(i);\n\t\t\t}\n\t\t\tint p = -1;\n\t\t\tif (SZ(A) & 1)\n\t\t\t\tp = rand() % SZ(A);\n\t\t\tcur += SZ(A) >> 1;\n\t\t\tREP(i, SZ(A))\n\t\t\t{\n\t\t\t\tif (i == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tREP(j, 4)\n\t\t\t\tif (mask & (1 << j))\n\t\t\t\t\tT1[j][A[i]] = false;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cur);\n\t}\n\tcout << ans;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 20171211;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N;cin>>N;\n  ll b[N]={};\n  for(ll i=0;i<N-1;i++){\n    ll x,y,a;cin>>x>>y>>a;\n    b[x]^=a;\n    b[y]^=a;\n  }\n  ll k[16]={};\n  for(ll i=0;i<N;i++){\n    k[b[i]]++;\n  }\n  //debugArray(k,16);\n  ll ans=0;\n  ll rem=0;\n  for(ll i=1;i<16;i++){\n    ans += k[i]/2;\n    rem |= (k[i]&1)<<(i-1);\n  }\n  ll dp[1<<15]={};\n  for(ll S=1;S<1<<15;S++){\n    ll x=0;\n    for(ll i=0;i<15;i++)if((S>>i)&1){\n      x ^= i+1;\n    }\n    if(!x)dp[S]=max(dp[S],1ll);\n    for(ll T=(S-1)&S;T>0;T=(T-1)&S)if(dp[T]>0&&dp[S^T]>0){\n      dp[S] = max(dp[S],dp[T]+dp[S^T]);\n    }\n  }\n  /*\n  debug(ans);\n  debug((bitset<4>)rem);\n  debug(dp[rem]);\n  */\n  ans += __builtin_popcountll(rem)-dp[rem];\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define testbit(mask,i) (((mask)>>(i))&1)\n#define setbit(mask,i) ((mask)|(1<<i))\n#define delbit(mask,i) ((mask)^(1<<i))\n#define randome_generate srand(std::chrono::high_resolution_clock::now().time_since_epoch().count())\nusing namespace std;\nvector<pair<int,int> > ga[100100];\nint u,v,w;\nint n;\nint cnt[18];\nint dq;\nint xo[262144],dp[262144];\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>u>>v>>w;\n\t\tga[u].push_back(make_pair(v,w));\n\t\tga[v].push_back(make_pair(u,w));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdq=0;\n\t\tfor(int j=0;j<ga[i].size();j++){\n\t\t\tdq^=ga[i][j].second;\n\t\t} \n\t\tcnt[dq]++;\n\t}\n\tint cc=0;\n\tcc+=cnt[0];\n\tint zt=0;\n\tfor(int i=1;i<=15;i++){\n\t\tcc+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t\tzt+=(1<<i);\n\t}\n\tfor(int i=0;i<(1<<16);i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(testbit(i,j)){\n\t\t\t\txo[i]^=j;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<16);i++){\n\t\tfor(int j=i;j>0;j=(j-1)&i){\n\t\t\tif(xo[j]==0)\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\t\t}\n\t}\n\tcc+=dp[zt];\n\tcout<<n-cc<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n\n*/\n#include <iostream>\n#include <fstream>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n#include <ctime>\n#include <algorithm>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define endl '\\n'\n#define mp make_pair\n#define pb push_back\n#define MOD 1000000007ULL\n#define MOD2 1000000009ULL\n#define INF 1000000000ULL\n#define F first\n#define S second\n#define eps 1e-9\n#define PI 3.14159265358979\n#define gcd __gcd\n#define sd(x) scanf(\"%d\", &(x))\n#define slld(x) scanf(\"%lld\", &(x))\n#define ss(x) scanf(\"%s\", x)\n#define sc(x) scanf(\" %c\", &x)\n#define pd(x) printf(\"%d\\n\", (x))\n#define plld(x) printf(\"%lld\\n\", (x));\n#define gc getchar\n\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<int, int> vii;\ntypedef vector<ll, ll> vll;\n\nvoid scanint(int &x)\n{\n    register int c = gc();\n    bool flag = false;\n    x = 0;\n    for(;((c<48 && c!=45) || c>57);c = gc());\n    if(c==45)\n    {\n\t\tflag = true;\n\t\tc = gc();\n    }\n    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n    if(flag)\n    \tx = x - (x<<1);\n    return;\n}\n\nvoid scanll(ll &x)\n{\n\tregister long long c;\n\tbool flag = false;\n\tx = 0;\n\tfor(;((c<48 && c!=45) || c>57);c = gc());\n\tif(c==45)\n\t{\n\t\tflag = true;\n\t\tc = gc();\n\t}\n\tfor(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n\tif(flag)\n    \tx = x - (x<<1);\n\treturn;\n}\n\nconst int N = 100005;\nconst int M = 16;\nvector<pii> v[N];\nbool visited[N];\nint cnt[M];\nint dp[1<<M];\nint val[1<<M];\nint arr[M], sz_arr;\n\nvoid dfs(int u)\n{\n\tvisited[u] = true;\n\tpii pt;\n\tint d = 0;\n\tfor(int i = 0; i<v[u].size(); i++)\n\t{\n\t\tpt = v[u][i];\n\t\td = d^pt.S;\n\t\tif(!visited[pt.F])\n\t\t\tdfs(pt.F);\n\t}\n\tcnt[d]++;\n\treturn;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t// clock_t clk;\n\t// clk = clock();\n\t// freopen(\"in.in\", \"r\", stdin);\n\t// freopen(\"out.out\", \"w\", stdout);\n\t\n\tint n, a, b, w;\n\tcin >> n;\n\tfor(int i = 1; i<n; i++)\n\t{\n\t\tcin >> a >> b >> w;\n\t\ta++;\n\t\tb++;\n\t\tv[a].pb(mp(b, w));\n\t\tv[b].pb(mp(a, w));\n\t}\n\tdfs(1);\n\tint ans = 0;\n\tsz_arr = 0;\n\tfor(int i = 1; i<M; i++)\n\t{\n\t\tans += cnt[i]/2;\n\t\tcnt[i] = cnt[i]%2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tarr[sz_arr] = i;\n\t\t\tsz_arr++;\n\t\t}\n\t}\n\tint up = (1<<sz_arr), temp;\n\n\tfor(int i = 0; i<up; i++)\n\t{\n\t\tval[i] = 0;\n\t\tfor(int j = 0; j<sz_arr; j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tval[i] = val[i]^arr[j];\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1; i<up; i++)\n\t{\n\t\tif(val[i] != 0)\n\t\t\tcontinue;\n\n\t\tdp[i] = __builtin_popcount(i) - 1;\n\t\tfor(int j = i; j>0; j = i&(j-1))\n\t\t\tif(val[j] == 0 && val[i^j] == 0)\n\t\t\t\tdp[i] = max(dp[i], dp[j]+dp[i^j]);\n\t}\n\tcout << dp[up-1] + ans << \"\\n\";\n\n\t// clk = clock() - clk;\n\t// cout << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\t// printf(\"Time: %lf\", ((double)clk)/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<int> sum(n, 0);\n    REP(i, n - 1) {\n        int x, y, a;\n        cin >> x >> y >> a;\n        sum[x] ^= a;\n        sum[y] ^= a;\n    }\n    vector<int> c(16, 0);\n    REP(i, n) c[sum[i]]++;\n    int ans = 0;\n    FOR(i, 1, 16) ans += c[i] / 2;\n    vector<int> dir((1 << 16), inf);\n    int tmp = 0;\n    FOR(i, 1, 16) if(c[i] % 2) tmp ^= (1 << i);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    q.push({0, tmp});\n    dir[tmp] = 0;\n    while(!q.empty()) {\n        int c = q.top().first;\n        int p = q.top().second;\n        q.pop();\n        if(dir[p] != c) continue;\n        bitset<16> b(p);\n        FOR(i, 1, 16) {\n            if(!b[i]) continue;\n            FOR(j, i + 1, 16) {\n                if(!b[j]) continue;\n                FOR(k, 1, 16) {\n                    bitset<16> nb(p);\n                    int cost = c + 1;\n                    nb[i] = 0;\n                    nb[j] = 0;\n                    if(i ^ k) {\n                        nb[i ^ k] = !nb[i ^ k];\n                        if(!nb[i ^ k]) cost++;\n                    }\n                    if(j ^ k) {\n                        nb[j ^ k] = !nb[j ^ k];\n                        if(!nb[j ^ k]) cost++;\n                    }\n                    if(dir[nb.to_ullong()] > cost) {\n                        dir[nb.to_ullong()] = cost;\n                        q.push({dir[nb.to_ullong()], nb.to_ullong()});\n                    }\n                }\n            }\n        }\n    }\n    cout << ans + dir[0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int maxn = (int) 1e5 + 5, maxx = 16;\nint dp[(1 << maxx)];\n\nvoid precalc() {\n  dp[0] = 0;\n  for (int msk = 1; msk < (1 << maxx); msk++) {\n    int x = 0;\n    for (int i = 0; i < maxx; i++) {\n      if (msk & (1 << i)) {\n        x ^= i;\n      }\n    }\n    if (!x) {\n      dp[msk] = 0;\n      for (int sub = msk; sub > 0; sub = (sub - 1) & msk) {\n        if (dp[sub] == -1) {\n          continue;\n        }\n        dp[msk] = max(dp[msk], dp[sub] + 1);\n      }\n    } else {\n      dp[msk] = -1;\n    }\n  }\n}\n\nint n;\nint a[maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    a[i] = 0;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u, x;\n    scanf(\"%d%d%d\", &v, &u, &x);\n    a[v] ^= x;\n    a[u] ^= x;\n  }\n  return true;\n}\n\nint cnt[maxx];\n\nvoid solve() {\n  for (int i = 0; i < maxx; i++) {\n    cnt[i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    cnt[a[i]]++;\n  }\n  int res = n - cnt[0];\n  cnt[0] = 0;\n  int msk = 0;\n  for (int i = 0; i < maxx; i++) {\n    res -= cnt[i] / 2;\n    cnt[i] %= 2;\n    if (cnt[i]) {\n      msk ^= (1 << i);\n    }\n  }\n  assert(dp[msk] != -1);\n  res -= dp[msk];\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nvoid DFS(int R, int par, vector< vector< pair<int, int> > > &G, vector<int> &X, vector<int> &Xs) {\n\tint x =0;\n\tALL_THE(G[R], it) if(it->ff != par) {\n\t\tX[it->ff] =it->ss;\n\t\tDFS(it->ff, R, G, X, Xs);\n\t\tx ^=Xs[it->ff];\n\t}\n\tXs[R] ^=x;\n\tX[R] ^=x;\n\tXs[R] ^=X[R];\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< vector< pair<int, int> > > G(N);\n\tfor(int i =0; i < N-1; i++) {\n\t\tint x,y,a;\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(make_pair(y, a));\n\t\tG[y].push_back(make_pair(x, a));\n\t}\n\tvector<int> X(N, 0), Xs(N, 0);\n\tDFS(0, 0, G, X, Xs);\n\tint cnt[16];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor(int i =0; i < N; i++) cnt[X[i]]++;\n\tint ans =0, s =0;\n\tfor(int i =1; i < 16; i++) {\n\t\tans +=cnt[i]/2;\n\t\tcnt[i] %=2;\n\t\ts +=cnt[i];\n\t}\n\tvector<int> x0sets;\n\tfor(int i =2; i < (1<<16); i +=2) {\n\t\tint x =0;\n\t\tfor(int j =1; j < 16; j++) if((i>>j)&1) if(cnt[j]) x ^=j;\n\t\tif(x == 0) x0sets.push_back(i);\n\t}\n\tvector<int> cnt_sets(1<<16, -N);\n\tint b0 =1;\n\tfor(int i =1; i < 16; i++) if(cnt[i] == 0) b0 +=1<<i;\n\tcnt_sets[b0] =0;\n\tfor(int i =0; i < (1<<16); i++) if(cnt_sets[i] >= 0)\n\t\tALL_THE(x0sets, it) if((i&(*it)) == 0)\n\t\t\tcnt_sets[i+(*it)] =max(cnt_sets[i+(*it)], cnt_sets[i]+1);\n\tans +=s-cnt_sets[(1<<16)-1];\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 1e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[32], p[20], dp[1 << 16], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << tot; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tif(tot) printf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define mpr make_pair\n#define pii pair<int,int>\n\ntypedef long long ll;\nconst int maxn = 1e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, s;\nint cnt[maxn], a[maxn], dp[maxn];\n\nsigned main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    for(int i = 1, u, v, w; i < n; i++)\n    {\n        cin>> u >> v >> w; u++; v++;\n        (a[v] ^= w);\n        (a[u] ^= w);\n    }\n\n    for(int v = 1; v <= n; v++) cnt[a[v]]++;\n    int ans = 0;\n    for(int i = 0; i < 15; i++)\n    {\n        if(i == 0) ans += cnt[i];\n        else ans += cnt[i]/2;\n        (cnt[i] &= 1);\n        cnt[0] = 0;\n    }\n\n    /// dp = maximum tedad daste\n    for(int msk = 0; msk < (1<<15); msk++)\n    {\n        dp[msk] = -inf;\n        int X = 0, id, is = 0;\n        for(int i = 0; i < 15; i++)\n            if((1<<i) & msk)\n            {\n                if(cnt[i]&1) (X ^= i);\n                if(cnt[i]) is = 1;\n                id = i;\n            }\n\n        if(X == 0 && msk > 0)\n        {\n            if(!is)\n            {\n                dp[msk] = 0;\n                continue;\n            }\n\n            if(__builtin_popcount(msk) == 1)\n            {\n                dp[msk] = cnt[id]/2;\n                if(id == 0) dp[msk] = cnt[id];\n            }\n            else\n            {\n                dp[msk] = 1;\n                for(int s = ((msk-1)&msk); s; s = ((s-1)&msk))\n                    dp[msk] = max(dp[msk], dp[s] + dp[msk^s]);\n            }\n        }\n    }\n\n    int msk = (1<<15)-1;\n    cout<< n-(dp[msk]+ans);\n}\n\n/*\n2\nT 30\nW 1\n3\nT 1\nW 1\nT 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nconst int maxm = 1 << 15 + 10;\nconst int inf = 0x3f3f3f3f;\n\nint n, ans, state;\nint v[maxn], cnt[20], f[maxm];\n\nint dp(int s) {\n\tif (!s) return 0;\n\tif (f[s] < inf) return f[s];\n\tfor (int i = 0; i <= 15; ++i) {\n\t\tif (!(s & (1 << i))) continue;\n\t\tfor (int j = 0; j <= 15; ++j) {\n\t\t\tif (i == j || !(s & (1 << j))) continue;\n\t\t\tint x = i ^ j;\n\t\t\tint y = s ^ (1 << i) ^ (1 << j) ^ (1 << x);\n\t\t\tif (s & (1 << x)) f[s] = min(f[s], dp(y) + 2);\n\t\t\telse f[s] = min(f[s], dp(y) + 1);\n\t\t}\n\t}\n\treturn f[s];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z;\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\tx += 1, y += 1;\n\t\tv[x] ^= z; v[y] ^= z;\n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[v[i]]++;\n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans += (cnt[i] >> 1);\n\t\tstate += (cnt[i] & 1) * (1 << i);\n\t}\n\tmemset(f, 0x3f, sizeof(f));\n\tprintf(\"%d\\n\", ans + dp(state));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntypedef long long ll;\n\nint n,r;\nint x[100005];\nint dp[1<<16];\n\nint f(int m){\n\tint& r=dp[m];\n\tif(r>=0)return r;\n\tr=1<<30;\n\tfore(i,1,16)if(m&(1<<i))fore(j,1,16)if(j!=i&&(m&(1<<j))){\n\t\tint k=i^j;\n\t\tint nm=m^(1<<i)^(1<<j);\n\t\tint a=1;\n\t\tif(k){\n\t\t\tif(nm&(1<<k))a++;\n\t\t\tnm^=1<<k;\n\t\t}\n\t\tr=min(r,a+f(nm));\n\t}\n\treturn r;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfore(_,1,n){\n\t\tint i,j,a;\n\t\tscanf(\"%d%d%d\",&i,&j,&a);\n\t\tx[i]^=a;x[j]^=a;\n\t}\n\tint m=0;\n\tfore(i,0,n){\n\t\tif(!x[i])continue;\n\t\tif(m&(1<<x[i]))r++;\n\t\tm^=1<<x[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));dp[0]=0;\n\tprintf(\"%d\\n\",r+f(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ninline int Min(int x,int y){return x<y?x:y;}\nint n,a[100000];\nint s[16],Ans,S;\nint f[1<<16];\nint main(){\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i) scanf(\"%d%d%d\",&x,&y,&z), a[x]^=z, a[y]^=z;\n\tfor(int i=0;i<n;++i) if(a[i]) Ans+=s[a[i]], s[a[i]]^=1;\n\tfor(int i=1;i<16;++i) S^=s[i]<<i;\n\tfor(int i=1;i<1<<16;++i){\n\t\tf[i]=(-1u)>>1;\n\t\tfor(int j=0;j<16;++j) if(i>>j&1)\n\t\t\tfor(int k=j+1;k<16;++k) if(i>>k&1)\n\t\t\t\tf[i]=Min(f[i],f[i^1<<j^1<<k^1<<(j^k)]+1+(i>>(j^k)&1));\n\t}\n\tprintf(\"%d\",Ans+f[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n\nint n, cnt[16], ans, now, f[101000];\nvector<pii>G[101000];\n\nvoid dfs(int x,int fff,int lasv){\n  for (auto y:G[x]){\n    if (y.fi==fff) continue;\n    dfs(y.fi,x,y.se);\n  }\n  lasv^=f[x];\n  if (fff){\n    ++cnt[lasv];\n    f[fff]^=lasv;\n  }\n}\n\nint main(){\n  cin>>n;\n  int x, y, z;\n  for (int i=1;i<n;++i){\n    scanf(\"%d%d%d\",&x,&y,&z); ++x; ++y;\n    G[x].push_back((pii){y,z});\n    G[y].push_back((pii){x,z});\n  }\n  dfs(1,0,0);\n  for (int i=1;i<16;++i) ans+=cnt[i]+1>>1;\n  cout<<ans-2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define F first\n#define S second\n#define FOR(i,a,b) for (int i = (a); i <= (b); ++i)\n#define NFOR(i,a,b) for(int i = (a); i >= (b); --i)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\ntypedef long long ll; typedef pair <int, int> ii; typedef vector <int> vi; const int inf = 1e9 + 7;\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cout << str << \" : \" << t << endl;}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cout << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cout << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cout << \", \"; cout << *i;} cout << \"]\";cout<<endl;}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint n; cin >> n;\n\tvector<vector<ii>> g(n);\n\tvi d(n);\n\tFOR (i, 0, n - 2) {\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tg[x].emplace_back(y, z);\n\t\tg[y].emplace_back(x, z);\n\t\td[x] ^= z;\n\t\td[y] ^= z;\n\t}\n\tvi f(16);\n\tFOR (i, 0, n - 1) f[d[i]]++;\n\tint ans = 0;\n\tvi yo;\n\tFOR (i, 1, 15) {\n\t\tans += f[i] / 2;\n\t\tif (f[i] & 1) {\n\t\t\tyo.push_back(i);\n\t\t}\n\t}\n\tint no = sz(yo);\n\n\tvector<int> dp(1 << no);\n\tvector<int> X(1 << no);\n\n\tdp[0] = 0;\n\tFOR (i, 1, (1 << no) - 1) {\n\t\tX[i] = X[i & (i - 1)] ^ yo[__builtin_ctz(i)];\n\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\tif (X[j] == 0) {\n\t\t\t\tdp[i] = max(dp[i], dp[i ^ j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << no - dp[(1 << no) - 1] + ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<set>\n#include<algorithm>\n#define reg register\ntypedef long long ll;\ntemplate<typename T>inline T read(){\n    reg T x=0;reg short f=1;reg char c=getchar();\n    for(;!isdigit(c);f=c=='-'?-1:1,c=getchar());\n    for(;isdigit(c);x=x*10+(c^48),c=getchar());\n    return x*f;\n}\nconst int MN=1e5+5;\nconst int inf=0x3f3f3f3f;\nconst int U=1<<16;\nint n,ans,s[MN],f[U],sum[17];\nusing std::min;\ninline int dfs(int S){\n\tif(f[S]<inf)return f[S];\n\tfor(reg int i=0;i<16;i++)if((S>>i)&1)\n\t\t\tfor(reg int j=0;j<16;j++)if((i^j)&&((S>>j)&1)){\n\t\t\t\t\treg int t=i^j,s=S^(1<<i)^(1<<j)^(1<<t);\n\t\t\t\t\tf[S]=min(f[S],dfs(s)+1+((S>>t)&1));\n\t\t\t\t}\n\treturn f[S];\n}\nint main(){\n\tn=read<int>();memset(f,0x3f,sizeof(f));\n\tfor(reg int i=1;i<n;i++){\n\t\treg int x=read<int>(),y=read<int>(),c=read<int>();\n\t\ts[x]^=c;s[y]^=c;\n\t}\n\tfor(reg int i=0;i<n;i++)sum[s[i]]++;\n\treg int S=0;f[0]=0;\n\tfor(reg int i=1;i<16;i++)ans+=(sum[i]>>1),S+=(1<<i)*(sum[s[i]]&1);\n\tprintf(\"%d\\n\",ans+dfs(S));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint A[100000];\nint C[16];\nint D[1<<15];\nvector<int> Q[100010];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int u, v, a;\n    cin >> u >> v >> a;\n    A[u] ^= a;\n    A[v] ^= a;\n  }\n  rep(i, N) C[A[i]]++;\n  int sum = 0, st = 0;\n  for (int i=1; i<16; i++) {\n    sum += C[i]/2;\n    if (C[i]%2) st |= 1<<(i-1);\n  }\n  rep(i, 1<<15) D[i] = INF;\n  Q[0].pb(st);\n  D[st] = 0;\n  for (int v=0; v<=100000; v++) {\n    for (int S : Q[v]) {\n      if (D[S] < v) continue;\n      rep(i, 15) if ((S>>i)&1) {\n        rep(j, i) if ((S>>j)&1) {\n          for (int z=1; z<=15; z++) {\n            int i2 = ((i+1)^z)-1, j2 = ((j+1)^z)-1;\n            int nS = S^(1<<i)^(1<<j), cost = 1;\n            if (i2 != -1) nS ^= (1<<i2), cost += (S>>i2)&1;\n            if (j2 != -1) nS ^= (1<<j2), cost += (S>>j2)&1;\n            if (D[nS] > D[S]+cost) D[nS] = D[S]+cost, Q[v+cost].pb(nS);\n          }\n        }\n      }\n    }\n    Q[v].clear();\n  }\n  cout << sum + D[0] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100100;\nconst int maxj = 17;\n\nint n,res,mask,nn,a[maxn],cnt[maxn],dp[(int)1<<maxj],good[(int)1<<maxj];\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int x,y,z;\n        cin>>x>>y>>z;\n        a[x]^=z;\n        a[y]^=z;\n    }\n    for (int i=0;i<n;i++) cnt[a[i]]++;\n    for (int i=1;i<=maxj;i++) {\n        res+=cnt[i]/2;\n        cnt[i]%=2;\n    }\n    for (int i=1;i<=maxj;i++)\n        if (cnt[i]!=0) {\n            mask|=(1<<i);\n            nn++;\n        }\n    for (int tt=0;tt<(1<<maxj);tt++) {\n        int x=0;\n        for (int i=0;i<maxj;i++)\n            if (tt&(1<<i)) x^=i;\n        good[tt] = (x==0);\n    }\n    for (int tt=0;tt<(1<<maxj);tt++) {\n        if (tt&1) continue;\n        int u=tt;\n        while (u>0) {\n            if (good[u]) dp[tt] = max(dp[tt],dp[tt^u] + 1);\n            u = (u-1)&tt;\n        }\n    }\n    cout<<res+nn-dp[mask];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() (rand() >> 3)*rand()\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, a, b, B, w, x[100005], c[16], ans, p3[20];\nint dp[15000000], y[15000000], z[15000000];\nbool f[15000000]={1};\nvector<int> r;\nint main(){\n    p3[0]=1; fox1(l, 18) p3[l]=p3[l-1]*3;\n    scanf(\"%i\", &n); ans=n;\n    fox(l, n-1){\n        scanf(\"%i%i%i\", &a, &b, &w);\n        x[a]^=w;\n        x[b]^=w;\n    }\n    fox(l, n){\n        c[x[l]]++;\n        //cout << x[l] << ' ';\n    }\n    ans-=c[0];\n    fox1(l, 15){\n        ans-=c[l]/2;\n        c[l]%=2;\n        if (c[l]) r.pb(l);\n    }\n    if (r.size()){\n        fox(l, p3[m]) dp[l]=-(1<<30);\n        dp[0]=0;\n        m=r.size();\n        fox(l, p3[m]){\n            if (dp[l]<0) continue;\n            fox(l2, m){\n                if (l/p3[l2]%3==0){\n                    dp[l+p3[l2]]=max(dp[l+p3[l2]], dp[l]);\n                    y[l+p3[l2]]=y[l]^r[l2];\n                    z[l+p3[l2]]=z[l]+p3[l2];\n                }\n            }\n            if (y[l]==0 && !f[l]){\n                cout << \"*\";\n                dp[l+z[l]]=max(dp[l+z[l]], dp[l]+1);\n                y[l+z[l]]=0;\n                z[l+z[l]]=0;\n                f[l+z[l]]=1;\n            }\n            //cout << l << ' ' << dp[l] << endl;\n        }\n        ans-=dp[p3[m]-1];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nint cc2[16][1 << 15][16];\nint dp2(int idx, int mask, int rem) {\n    int &ret = cc2[idx][mask][rem];\n    if(ret != -1) return ret;\n    if(rem == 0) return ret = dp1(idx - 1, mask);\n\n    ret = 1e9;\n    for(int i = 1; i < idx; i++) {\n        if((rem | i) == rem) {\n            if(mask & (1 << i)) {\n                ret = min(ret, 1 + dp2(idx, mask ^ (1 << i), rem - i));\n            }\n            else ret = min(ret, dp2(idx, mask ^ (1 << i), rem - i));\n        }\n    }\n    return ret;\n}\n\nint cc1[16][1 << 15];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tmp % 2 == 0) return ret = tmp / 2 + dp1(idx - 1, mask);\n    else return ret = tmp / 2 + dp2(idx, mask, idx);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint dp[1<<16],V[16],cnt[16];\n\nint DP(int s)\n{\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\tdp[s]=0x3FFFFFFF;\n\tfor(int i=1;i<16;i++)\n\t\tif(s&(1<<i))\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tif(s&(1<<j))\n\t\t\t\t{\n\t\t\t\t\tint ns=s^(1<<i)^(1<<j)^(1<<(i^j));\n\t\t\t\t\tif(__builtin_popcount(ns)<__builtin_popcount(s))\n\t\t\t\t\t\tdp[s]=min(dp[s],DP(ns)+1+(((1<<(i^j))&s)==(1<<(i^j))));\n\t\t\t\t}\n\treturn dp[s];\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y,a;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&a);\n\t\tV[x]^=a;\n\t\tV[y]^=a;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(V[i])\n\t\t\tcnt[V[i]]++;\n\tint ans=0,st=0;\n\tfor(int i=0;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tst^=(cnt[i]&1)<<i;\n\t}\n\tmemset(dp,-1,sizeof dp);\n\tans+=DP(st);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nvector < pii > g[N];\nint ans = 0;\nint dfs(int node,int prev)\n{\n    int cnt = 0;\n    for (auto it : g[node])\n        if (it.fi != prev)\n        {\n            int v = dfs(it.fi,node);\n            int xr = it.se;\n            for (int k = 0;k < 16;++k)\n                if ((v >> k) & 1)\n                {\n                    if ((cnt >> k) & 1)\n                        ++ans;\n                    cnt ^= 1 << k;\n                    xr ^= k;\n                }\n            if (xr)\n            {\n                if ((cnt >> xr) & 1)\n                    ++ans;\n                cnt ^= 1 << xr;\n            }\n        }\n    if (cnt & 1)\n        cnt ^= 1;\n    return cnt;\n}\nmap < vi , int > M;\nint f(vi ret)\n{\n    if (ret.empty())\n        return 0;\n    if (ret.size() == 1)\n        return 1;\n    if (M.count(ret))\n        return M[ret];\n    int &ans = M[ret];\n    ans = 1e9;\n    const int sz = ret.size();\n    for (int i = 0;i < sz;++i)\n        for (int j = i + 1;j < sz;++j)\n        {\n            vi nw;\n            for (int t = 0;t < sz;++t)\n                if (t != i)\n                {\n                    if (t != j)\n                    {\n                        if (ret[t] != ret[i])\n                            nw.pb(ret[t] ^ ret[i]);\n                    }\n                    else\n                    if (ret[t])\n                        nw.pb(ret[t]);\n                }\n            smin(ans,f(nw) + 1);\n        }\n    return ans;\n}\nint main(void)\n{\n    int n;\n    cin>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b,c;\n        cin>>a>>b>>c;\n        ++a;++b;\n        g[a].pb(mp(b,c));\n        g[b].pb(mp(a,c));\n    }\n    const int MM = 16;\n    const int M = 1 << MM;\n    int cnt = dfs(1,0);\n    vi v;\n    for (int i = 1;i < MM;++i)\n        if ((cnt >> i) & 1)\n            v.pb(i);\n    ans += f(v);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta++;\n\t\tb++;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[s]=0;\n\tfor(int p=s;p>=0;p--)\n\t{\n\t\tfor(int i=0;i<=15;i++)\n\t\t{\n\t\t\tif(!(p&(1<<i)))\n\t\t\t\tcontinue;\n\t\t\tfor(int j=0;j<=15;j++)\n\t\t\t{\n\t\t\t\tif(i==j||!(p&(1<<j)))\n\t\t\t\t\tcontinue;\n\t\t\t\tint k=i^j;\n\t\t\t\tint t=p^(1<<i)^(1<<j)^(1<<k);\n\t\t\t\tif(p&(1<<k))\n\t\t\t\t\tf[t]=min(f[t],f[p]+2);\n\t\t\t\telse\n\t\t\t\t\tf[t]=min(f[t],f[p]+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n;\nvector<pair<int,int> > g[N];\nvector<int> sons[N];\nint val[N];\nint used[N];\n\nvoid dfs(int v,int par_cost=0){\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i].first;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tint cost=g[v][i].second;\n\t\tsons[v].push_back(to);\n\t\tdfs(to,cost);\n\t}\n\n\tfor (int i=0;i<sons[v].size();i++){\n\t\tint to=sons[v][i];\n\t\tval[v]^=val[to];\n\t}\n\tval[v]^=par_cost;\n}\n\nint ans;\nint cnt[N];\nint pcount[N];\nint dp[N];\nint mem_xor[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(make_pair(b,c));\n\t\tg[b].push_back(make_pair(a,c));\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tpcount[i]=pcount[i/2]+i%2;\n\t}\n\n\tfor (int mask=0;mask<(1<<16);mask++){\n\t\tint here=0;\n\t\tfor (int i=0;i<16;i++){\n\t\t\tif (mask&(1<<i))\n\t\t\t\there^=i;\n\t\t}\n\t\tmem_xor[mask]=here;\n\t}\n\n\tdfs(0);\n\n\tfor (int i=1;i<n;i++){\n\t//\tcout<<val[i]<<endl;\n\t\tcnt[val[i]]++;\n\t}\n\n\tfor (int i=0;i<16;i++){\n\t\tif (i!=0)\n\t\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\n\t/*for (int i=0;i<16;i++){\n\t\tcout<<i<<\" \"<<cnt[i]<<endl;\n\t}*/\n\n\tdp[0]=0;\n\n\tfor (int mask=1;mask<(1<<16);mask++){\n\t\tint smask=mask;\n\t\tdp[mask]=1e9;\n\t\twhile (true){\n\t\t\tif (smask==0)\n\t\t\t\tbreak;\n\t\t\tint here=pcount[smask];\n\t\t\tint is_good=mem_xor[smask];\n\t\t\tif (is_good==0)\n\t\t\t\there--;\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+here);\n\t\t\tsmask=(smask-1);\n\t\t\tsmask&=mask;\n\t\t}\n\t}\n\n\tint interesting=0;\n\tfor (int i=0;i<16;i++){\n\t\tif (cnt[i])\n\t\t\tinteresting|=(1<<i);\n\t}\n\tcout<<ans+dp[interesting]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint a[N],f[N],cnt[20],as,n,st,x[N],S;\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri u=read()+1,v=read()+1,va=read();a[u]^=va;a[v]^=va;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);rp(i,1,S-1)--f[i];\n\trp(i,1,S){rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);}\n\trp(i,1,S)\n\t{\n\t\tif(!x[i])for(int k=(i-1)&i;k;k=(k-1)&i)if(!x[k])f[i]=min(f[i],f[k]+f[i^k]);\n\t}\n\tprintf(\"%d\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e9\n\nusing namespace std;\n\nstruct edge{\n\tint u, v;\n\tint cost;\n\tedge(){}\n\tedge(int a, int b, int c){\n\t\tu = a, v = b, cost = c;\n\t}\n\tint get(int a)\n\t{\n\t\tif(u == a) return v;\n\t\telse return u;\n\t}\n};\n\nint N;\nvector<int> G[100005];\nedge E[100005];\nint cnt[16];\n\nint V = 1 << 16, S;\nint dist[1<<16];\n\nvoid bfs(){\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(S);\n\tint v, nv;\n\twhile(Q.size()){\n\t\tv = Q.front();\n\t\tQ.pop();\n\t\tif(v == 0) break;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif(v & (1<<i)){\n\t\t\t\tnv = v & ~(1<<i);\n\t\t\t\tif(dist[nv] < inf) continue;\n\t\t\t\tQ.push(nv);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif((v & (1<<i)) == 0) continue;\n\t\t\tfor(int j = 1; j < 16; j++){\n\t\t\t\tif((v & (1<<j)) == 0) continue;\n\t\t\t\tif(i == j) continue;\n\t\t\t\tnv = v;\n\t\t\t\tnv &= ~(1<<i);\n\t\t\t\tnv ^= 1<<(i^j);\n\t\t\t\tif(dist[nv] < inf) continue;\n\t\t\t\tQ.push(nv);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int prev, int val)\n{\n\tint ret = val;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(E[G[v][i]].get(v) == prev) continue;\n\t\tret ^= dfs(E[G[v][i]].get(v), v, E[G[v][i]].cost);\n\t}\n\tcnt[ret]++;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint x, y, a;\n\tfor(int i = 0; i < N-1; i++){\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(i);\n\t\tG[y].push_back(i);\n\t\tE[i] = edge(x, y, a);\n\t}\n\t\n\tcnt[dfs(0, -1, 0)]--;\n\t\n\t//for(int i = 0; i < 16; i++) cout << cnt[i] << \" \"; cout << endl;\n\t\n\tint ans = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t}\n\tcnt[0] = 0;\n\tfor(int i = 0; i < 16; i++) if(cnt[i]) S += (1<<i);\n\t\n\tbfs();\n\tans += dist[0];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 100001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nbool v[1 << 15];\nint cc[N], cnt[16], bin[16], f[1 << 15], one[1 << 15];\n\nint main() {\n\tint n = read();\n\tfor(int i = 1; i < n; i++) {\n\t\tint x = read(), y = read(), c = read();\n\t\tcc[x] ^= c, cc[y] ^= c;\n\t} for(int i = 0; i < 16; i++) cnt[cc[i]]++;\n\tbin[0] = 1; for(int i = 1; i < 16; i++) bin[i] = bin[i - 1] << 1;\n\tint ans = 0, S = 0; for(int i = 1; i < 16; i++) ans += cnt[i] / 2, S += cnt[i] & 1 ? bin[i - 1] : 0;\n\tfor(int i = 0; i < bin[15]; i++) {\n\t\tint sum = 0;\n\t\tfor(int j = 0; j < 15; j++) if(i & bin[j]) sum ^= j + 1;\n\t\tif(!sum) v[i] = 1;\n\t} memset(f, 63, sizeof(f));\n\tf[0] = 0; for(int i = 1; i <= S; i++) {\n\t\tone[i] = one[i >> 1] + (i & 1);\n\t\tif(v[i]) {\n\t\t\tf[i] = one[i] - 1;\n\t\t\tfor(int j = (i - 1) & i; j; j = (j - 1) & i) if(v[j]) f[i ^ j] = _min(f[i ^ j], f[i] + f[j]);\n\t\t}\n\t} put(f[S] + ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e5, INF = 0x3f3f3f3f;\nint n, val[MAXN + 5], cnt[16], f[1 << 16], xsum[1 << 16];\n\ninline void chkmin ( int& a, const int b ) { if ( b < a ) a = b; }\n\nint main () {\n\tscanf ( \"%d\", &n );\n\tfor ( int i = 1, u, v, w; i < n; ++ i ) {\n\t\tscanf ( \"%d %d %d\", &u, &v, &w );\n\t\tval[u] ^= w, val[v] ^= w;\n\t}\n\tint ans = 0, S = 0;\n\tfor ( int i = 0; i < n; ++ i ) ++ cnt[val[i]];\n\tfor ( int i = 1; i < 16; ++ i ) {\n\t\tS |= ( cnt[i] & 1 ) << i >> 1;\n\t\tans += cnt[i] >> 1;\n\t}\n\tfor ( int i = 1; i < 1 << 15; ++ i ) {\n\t\tfor ( int j = 0; j < 15; ++ j ) {\n\t\t\tif ( ( i >> j ) & 1 ) {\n\t\t\t\t++ f[i], xsum[i] ^= j + 1;\n\t\t\t}\n\t\t}\n\t\t-- f[i];\n\t}\n\tfor ( int s = 0; s < 1 << 15; ++ s ) {\n\t\tif ( xsum[s] ) continue;\n\t\tfor ( int t = s; ; t = ( t - 1 ) & s ) {\n\t\t\tif ( ! xsum[t] && ! xsum[s ^ t] ) chkmin ( f[s], f[t] + f[s ^ t] );\n\t\t\tif ( ! t ) break;\n\t\t}\n\t}\n\tprintf ( \"%d\\n\", ans + f[S] );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<set>\n#define ll long long\n#define maxn 200005\n#define re register\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nint a[maxn],cnt[16],ans;\nint b[16],cnt1,sz[maxn],sz2[maxn],dp[maxn];\n\ninline int gs(int sta)\n{\n\tfor(int i=1;i<=cnt1;i++) if((sta&(1<<(i-1)))) sz[sta]^=b[i];\n}\n\nint main()\n{\n\tint n=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read(),w=read();\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(a[i]==0) continue;\n\t\tif(cnt[a[i]]) cnt[a[i]]=0,ans++;\n\t\telse cnt[a[i]]=1;\n\t}\n\tfor(int i=1;i<=15;i++) if(cnt[i]) b[++cnt1]=i;\n\tint ed=(1<<cnt1)-1;\n\t//for(int i=1;i<=cnt1;i++) cout<<b[i]<<\" \"; cout<<endl;\n\tfor(int i=1;i<=ed;i++) gs(i),sz2[i]=sz2[i>>1]+(i&1);\n\tfor(int i=1;i<=ed;i++) dp[i]=sz2[i]-1;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<sz[i]<<\" \"<<sz2[i]<<endl;\n\tfor(int i=1;i<=ed;i++)\n\t{\n\t\tif(sz[i]!=0) continue;\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(sz[j]==0) dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t//else dp[i]=min(dp[i],sz2[j]+sz2[i^j]+1);\n\t\t}\n\t}\n\tcout<<dp[ed]+ans<<endl;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<dp[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1e5 + 5, MAXS = ( 1 << 16 ) + 5;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MIN( const _T a, const _T b )\n{\n\treturn a < b ? a : b;\n}\n\nint f[MAXS];\nint w[MAXN];\nint N, cnt;\nbool vis[MAXS];\n\nbool chk( const int S, const int b ) { return S >> b & 1; }\n\nint DFS( const int S )\n{\n\tif( ! S ) return f[S] = 0;\n\tif( vis[S] ) return f[S];\n\tvis[S] = true;\n\tfor( int i = 1 ; i <= 15 ; i ++ )\n\t\tfor( int j = i + 1 ; j <= 15 ; j ++ )\n\t\t\tif( chk( S, i ) && chk( S, j ) )\n\t\t\t{\n\t\t\t\tint t = S ^ ( 1 << i - 1 ) ^ ( 1 << j - 1 );\n\t\t\t\tint v = i ^ j, nxt = t ^ ( 1 << v - 1 );\n\t\t\t\tf[S] = MIN( f[S], DFS( nxt ) + 1 + chk( t, v - 1 ) );\n\t\t\t}\n\treturn f[S];\n}\n\nint main()\n{\n\tread( N );\n\tfor( int i = 1, x, y, b ; i < N ; i ++ )\n\t\tread( x ), read( y ), read( b ),\n\t\tw[x + 1] ^= b, w[y + 1] ^= b;\n\tint sta = 0, tot = 0;\n\tfor( int i = 1 ; i <= N ; i ++ )\n\t\ttot += ( sta >> w[i] - 1 ) & 1, \n\t\tsta ^= 1 << w[i] - 1;\n\tmemset( f, 0x3f, sizeof f );\n\twrite( DFS( sta ) + tot ), putchar( '\\n' ); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint n, a[100009], b[100009], c[100009], e[100009], f[16], dist[1 << 16], s;\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>Q;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\te[a[i]] ^= c[i]; e[b[i]] ^= c[i];\n\t}\n\tfor (int i = 0; i < n; i++) { f[e[i]]++; }\n\tfor (int i = 0; i < 16; i++) { if (i >= 1) s += f[i] / 2; f[i] %= 2; }\n\tfor (int i = 0; i < (1 << 16); i++) dist[i] = (1 << 30);\n\tint I = 0;\n\tfor (int i = 0; i < 16; i++) I += f[i] * (1 << i);\n\tdist[I] = 0; Q.push(make_pair(dist[I], I));\n\twhile (!Q.empty()) {\n\t\tint pos = Q.top().second; Q.pop();\n\t\tvector<int>A; int bit[16]; for (int i = 0; i < 16; i++) bit[i] = 0;\n\t\tfor (int i = 0; i < 16; i++) { if ((pos / (1 << i)) % 2 == 1) { A.push_back(i); bit[i] = 1; } }\n\t\tfor (int i = 0; i < A.size(); i++) {\n\t\t\tfor (int j = i + 1; j < A.size(); j++) {\n\t\t\t\tfor (int k = 0; k < 16; k++) {\n\t\t\t\t\tint R = pos, S = bit[A[i]], T = bit[A[j]], U = bit[(A[i] ^ k)], V = bit[(A[j] ^ k)], cost = 1;\n\t\t\t\t\tbit[A[i]]--; R -= (1 << A[i]);\n\t\t\t\t\tbit[A[j]]--; R -= (1 << A[j]);\n\t\t\t\t\tbit[(A[i] ^ k)]++; R += (1 << (A[i] ^ k)); if (bit[(A[i] ^ k)] == 2) { bit[(A[i] ^ k)] = 0; if ((A[i] ^ k) != 0) cost++; R -= (2 << (A[i] ^ k)); }\n\t\t\t\t\tbit[(A[j] ^ k)]++; R += (1 << (A[j] ^ k)); if (bit[(A[j] ^ k)] == 2) { bit[(A[j] ^ k)] = 0; if ((A[j] ^ k) != 0) cost++; R -= (2 << (A[j] ^ k)); }\n\t\t\t\t\tif (dist[R] > dist[pos] + cost) {\n\t\t\t\t\t\tdist[R] = dist[pos] + cost;\n\t\t\t\t\t\tQ.push(make_pair(dist[R], R));\n\t\t\t\t\t}\n\t\t\t\t\tbit[A[i]] = S; bit[A[j]] = T; bit[(A[i] ^ k)] = U; bit[(A[j] ^ k)] = V;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = s + min(dist[0], dist[1]);\n\tcout << t << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 5.1e5;\n\nvoid Run() {\n  int n;\n  cin >> n;\n  vector<int> deg(n);\n  vector<int> freq(16);\n  vector<int> remains;\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, a;\n    cin >> u >> v >> a;\n    deg[u] ^= a;\n    deg[v] ^= a;\n  }\n  int nonzero = 0;\n  for (int i = 0; i < n; i++)\n    nonzero += (deg[i] > 0);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    freq[deg[i]] ^= 1;\n    if (deg[i] > 0 && !freq[deg[i]]) {\n      ans++;\n    }\n  }\n  for (int i = 1; i <= 15; ++i) {\n    if (freq[i]) {\n      remains.push_back(i);\n    }\n  }\n  const int N = remains.size();\n  vector<int> dp(1 << N);\n  for (int i = 0; i < (1 << N); ++i) {\n    int cur = 0;\n    for (int j = 0; j < N; ++j) {\n      int bit = (i >> j) & 1;\n      if (bit == 0) {\n        cur ^= remains[j];\n      }\n    }\n    for (int j = 0; j < N; ++j) {\n      if (i & (1 << j)) {\n        dp[i] = max(dp[i], dp[i ^ (1 << j)]);\n      }\n    }\n    if (cur == 0 && __builtin_popcount(i) < N) {\n      ++dp[i];\n    }\n  }\n  ans += dp[(1 << N) - 1];\n  cout << nonzero - ans << '\\n';\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  Run();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N][20];int cnt[20];int res;int n;int st;bool book[N];\nstruct data{int v;int cf;};queue <data> q;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n\tfor(int i=0;i<n;i++){cnt[w[i]]++;}\n\tfor(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\t\n\tfor(int i=0;i<(1<<15);i++)for(int j=0;j<=14;j++)d[i][j]=0x3f3f3f3f;\n\td[st][0]=0;q.push((data){st,0});\n\twhile(!q.empty())\n\t{\n\t\tdata nw=q.front();q.pop();int dis=d[nw.v][nw.cf]+1;\n\t\tif(nw.cf!=0)\n\t\t{\n\t\t\tint p=nw.v&(~(1<<(nw.cf-1)));\n\t\t\tif(d[p][0]==0x3f3f3f3f)d[p][0]=dis,q.push((data){p,0});\n\t\t}else \n\t\t{\n\t\t\tfor(int i=0;i<15;i++)\n\t\t\t\tif((nw.v>>i)&1)for(int j=0;j<15;j++)\n\t\t\t\t\tif(((nw.v>>j)&1)&&i!=j)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tr=nw.v;tr&=~(1<<i);tr&=~(1<<j);\n\t\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint p1=(i+1)^k;int p2=(j+1)^k;p1--;p2--;\n\t\t\t\t\t\t\tint p=tr;if(p1>0)p|=1<<p1;if(p2>0)p|=1<<p2;\n\t\t\t\t\t\t\tif((p1>0)&&((tr>>p1)&1)&&d[p][p1+1]==0x3f3f3f3f)\n\t\t\t\t\t\t\t\td[p][p1+1]=dis,q.push((data){p,p1+1});\n\t\t\t\t\t\t\telse if((p2>0)&&((tr>>p1)&1)&&d[p][p2+1]==0x3f3f3f3f)\n\t\t\t\t\t\t\t\td[p][p2+1]=dis,q.push((data){p,p1+1});\n\t\t\t\t\t\t\telse if(d[p][0]==0x3f3f3f3f)d[p][0]=dis,q.push((data){p,0});\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t}\n\t}printf(\"%d\",res+d[0][0]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n\tint to;\n\tint cost;\n\tedge(int t, int c) : to(t), cost(c) {}\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tgraph G(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tG[x].emplace_back(y, a);\n\t\tG[y].emplace_back(x, a);\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tbool flag = false;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tbool ok = false;\n\t\t\tfor (auto e : G[i]) {\n\t\t\t\tok ^= (e.cost & (1 << j)) != 0;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tcnt += flag;\n\t}\n\tcout << (cnt + 1) / 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair <int, int> pii;\nint mem[1 << 15];\n\nvector <pii> g[100010];\nint dep[100010];\nint cnt[20];\nint val[1 << 17];\n\nvoid dfs(int x, int par) {\n\tfor(auto i : g[x]) {\n\t\tif(i.first - par) {\n\t\t\tdfs(i.first, x);\n\t\t\tdep[i.first] = i.second ^ dep[x];\n\t\t}\n\t}\n}\n\nint dp(int mask) {\n\tif(mask == 0) return 0;\n\tif(mem[mask] != -1) return mem[mask];\n\tint ans = 0;\n\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\tif(val[submask] == 0) {\n\t\t\tans = max(ans, 1 + dp(mask ^ submask));\n\t\t}\n\t}\n\treturn mem[mask] = ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tmemset(mem, -1, sizeof mem);\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\t\tg[p].push_back(pii(q, r));\n\t\tg[q].push_back(pii(p, r));\n\t}\n\tdfs(0, -1);\n\tvector <int> v;\n\tint comp = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tcnt[dep[i]] += 1;\n\t}\n\tfor(int i = 1; i < 16; i++) {\n\t\tif(cnt[i] & 1) {\n\t\t\tv.push_back(i);\n\t\t}\n\t\tcomp += cnt[i] >> 1;\n\t}\n\tcomp += cnt[0];\n\t// for(auto i : v) cout << i << endl;\n\tfor(int i = 0; i < (1 << v.size()); i++) {\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tif((i >> j) & 1) {\n\t\t\t\tval[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\tcomp += dp((1 << v.size()) - 1);\n\tcout << n - comp << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for ( int i=1; i<=int(n); i++ )  \n#define MP make_pair\n#define PB push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n#define X first\n#define Y second\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef long double LD;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <class T>  \ninline bool RD(T &ret) {  \n        char c; int sgn;  \n        if (c = getchar(), c == EOF) return 0;  \n        while (c != '-' && (c<'0' || c>'9')) c = getchar();  \n        sgn = (c == '-') ? -1 : 1 , ret = (c == '-') ? 0 : (c - '0');  \n        while (c = getchar(), c >= '0'&&c <= '9') ret = ret * 10 + (c - '0');  \n        ret *= sgn;  \n        return 1;  \n}  \ntemplate <class T>  \ninline void PT(T x) {  \n        if (x < 0) putchar('-') ,x = -x;  \n        if (x > 9) PT(x / 10);  \n        putchar(x % 10 + '0');  \n}\n\nconst int N = 1e5 + 100;\n\nvector<int> G[N];\nint val[N];\nint cnt[20];\nint dp[1 << 20];\nint main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i < n; i ++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u ++, v ++;\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n\n    int ans = n;\n    for(int i = 1; i <= n; i ++) cnt[val[i]] ++;\n\n    vector<int> v;\n    v.clear();\n    for(int i = 0; i <= 15; i ++) {\n        if(! i) ans -= cnt[i];\n        else {\n            ans -= cnt[i] / 2;\n            if(cnt[i] % 2) v.push_back(i);\n        }\n    }\n\n    int sz = SZ(v);\n    dp[0] = 0;\n    for(int mask = 1; mask < (1 << sz); mask ++) {\n        for(int sub = mask; sub; sub = (sub - 1) & mask) {\n            int cur = 0;\n            for(int i = 0; i < sz; i ++) {\n                if((sub >> i) & 1) cur ^= v[i];\n            }\n            if(cur == 0) dp[mask] = max(dp[mask], dp[mask ^ sub] + 1);\n        }\n    }\n    ans -= dp[(1 << sz) - 1];\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstring> \n#include <algorithm> \n#include <cmath> \n\nusing namespace std; \n\n#define N 100010\n#define M 65540\n\nint n, G[N], x, ans, u, v, w; \nint f[N], inf, sum[20]; \n\nint dfs(int x) {\n    if(!x) return 0; \n    if(f[x] < inf) return f[x]; \n    for(int i = 0 ; i < 16 ; i++) {\n        if((x >> i) & 1) {\n            for(int j = 0 ; j < 16 ; j++) {\n                if (i != j && (x >> j) & 1) {\n                    int p = i ^ j, u = x ^ (1 << i) ^ (1 << j) ^ (1 << p); \n                    if(x >> p & 1) f[x] = min(f[x], dfs(u) + 2); \n                    else f[x] = min(f[x], dfs(u) + 1); \n                }\n            }\n        }\n    }   \n    return f[x]; \n}\n\nint main() {\n    scanf(\"%d\",&n); \n    for(int i = 1 ; i < n ; i++) {\n        scanf(\"%d%d%d\",  & u,  & v,  & w); \n        G[u] ^= w, G[v] ^= w; \n    }\n    for(int i = 0 ; i < n ; i++) sum[G[i]]++; \n    for(int i = 1 ; i < 16 ; i++) {\n        ans += (sum[i] >> 1); \n        x += (1 << i) * (sum[i] & 1); \n    }\n    memset(f, 127, sizeof(f)); \n    inf = f[0]; \n    printf(\"%d\\n\", ans + dfs(x)); \n    //system(\"pause\");\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 1e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[32], p[20], dp[1 << 16], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << tot; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tif(tot > 1) printf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nvector < pii > g[N];\nint ans = 0;\nvi dfs(int node,int prev)\n{\n    int cnt[16];\n    memset(cnt,0,sizeof(cnt));\n    for (auto it : g[node])\n        if (it.fi != prev)\n        {\n            vi v = dfs(it.fi,node);\n            if (v.empty() && it.se)\n                v.pb(0);\n            int xr = it.se;\n            for (auto u : v)\n                cnt[u] += 1,xr ^= u;\n            if (xr)\n                ++cnt[xr];\n        }\n    for (int i = 1;i < 16;++i)\n        ans += cnt[i] / 2,cnt[i] &= 1;\n    vi ret;\n    for (int i = 1;i < 16;++i)\n        if (cnt[i])\n            ret.pb(i);\n    return ret;\n}\nint main(void)\n{\n    int n;\n    cin>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b,c;\n        cin>>a>>b>>c;\n        ++a;++b;\n        g[a].pb(mp(b,c));\n        g[b].pb(mp(a,c));\n    }\n    int answer = 1e9;\n    for (int i = 1;i <= n;++i)\n    {\n        ans = 0;\n        ans += dfs(i,0).size();\n        smin(answer,ans);\n    }\n    cout << answer << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DBG1\n  #define LOCAL\n#endif\n\n#ifdef LOCAL\n  #define _GLIBCXX_DEBUG\n#endif\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#ifdef DBG1\n    #define dbg(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dbg(...)\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\n\nstruct Edge {\n  int v, w;\n};\n\nbool solve() {\n  int n;\n  if (scanf(\"%d\", &n) != 1) { return false; }\n  vector <vector<Edge>> ed(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    ed[u].push_back(Edge({v, w}));\n    ed[v].push_back(Edge({u, w}));\n    dbg(\"%d %d %d\\n\", u, v, w);\n  }\n\n  vector <int> xor_sum(n, 0);\n  for (int i = 0; i < n; ++i) {\n    for (auto & e : ed[i]) {\n      xor_sum[i] ^= e.w;\n    }\n  }\n  vector <int> cnt(16, 0);\n  for (int i = 0; i < n; ++i) {\n    if (xor_sum[i]) {\n      cnt[xor_sum[i]] += 1;\n    }\n  }\n  int mask = 0;\n  int ans = 0;\n  for (int i = 0; i < 16; ++i) {\n    dbg(\"cnt[%d] = %d\\n\", i, cnt[i]);\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n    mask |= (cnt[i] << i);\n  }\n  vector <int> dp(1 << 16, -1);\n  vector <int> q[3];\n  q[0].push_back(mask);\n  dp[mask] = 0;\n  int cntQ = 1;\n  while (cntQ) {\n    while (q[0].empty()) {\n      q[0].swap(q[1]);\n      q[1].swap(q[2]);\n    }\n\n    --cntQ;\n    int v = q[0].back();\n    q[0].pop_back();\n    dbg(\"dp[%d] = %d\\n\", v, dp[v]);\n    \n    for (int j = 0; j < 16; ++j) {\n      if (!(mask & (1 << j))) { continue; }\n      for (int k = 0; k < 16; ++k) {\n        if (!(mask & (1 << k)) || j == k) { continue; }\n\n        int u = v ^ (1 << j) ^ (1 << k) ^ (1 << (k ^ j));\n        int d = 1;\n        if (mask & (1 << (j ^ k))) {\n          d += 1;\n        }\n        if (dp[u] == -1 || dp[u] > dp[v] + d) {\n          dp[u] = dp[v] + d;\n          q[d].push_back(u);\n          ++cntQ;\n        }\n      }\n    }\n  }\n  dbg(\"ans %d dp[%d^0] = %d\\n\", ans, mask, dp[0]);\n  printf(\"%d\\n\", ans + dp[0]);\n  return true;\n}\n\nint main() {\n  while (solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nvector<vector<pair<ll, ll>>> tree;\n\nconst ll SZ = 32999;\n\nll dp[SZ], xr[SZ];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\ttree.resize(n);\n\n\tvector<ll> vec;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v, c;\n\t\tcin >> u >> v >> c;\n\n\t\ttree[u].push_back({ v, c });\n\t\ttree[v].push_back({ u, c });\n\t}\n\n\tll ans = 0;\n\tmap<ll, ll> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tll vl = 0;\n\t\tfor (auto to : tree[i]) {\n\t\t\tvl ^= to.second;\n\t\t}\n\t\tcnt[vl]++;\n\t}\n\n\tfor (auto cur : cnt) {\n\t\tif (cur.first == 0) {\n\t\t\tans += cur.second;\n\t\t\tcontinue;\n\t\t}\n\n\t\tans += (cur.second) / 2;\n\t\tif (cur.second % 2) vec.push_back(cur.first);\n\t}\n\n\tll pw = (1ll << vec.size());\n\n\tfor (int i = 1; i < pw; i++) {\n\t\tll curVl = 0;\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcurVl ^= vec[j];\n\t\t\t}\n\t\t}\n\t\txr[i] = curVl;\n\t}\n\n\tfor (int i = 1; i < pw; i++) {\n\t\tif (xr[i] == 0) dp[i] = 1;\n\t\tfor (auto m = i; ; m = (m - 1) & i) {\n\t\t\tif (m == i) continue;\n\t\t\tif (xr[m] == 0) dp[i] = max(dp[i], dp[m] + 1);\n\t\t\tif (m == 0) break;\n\t\t}\n\t}\n\n\tcout << n - ans - dp[pw - 1];\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nint n,a[maxn],cnt[16],dp[1<<16];\nvector<int> v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=0;i<n-1;++i) {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        a[u]^=w;\n        a[v]^=w;\n    }\n    for (int i=0;i<n;++i)\n        ++cnt[a[i]];\n    int res=0;\n    for (int i=1;i<16;++i) {\n        res+=cnt[i]/2;\n        if (cnt[i]&1)\n            v.push_back(i);\n    }\n    dp[0]=0;\n    for (int i=1;i<1<<(int)v.size();++i) {\n        int mask=0;\n        for (int j=0;j<(int)v.size();++j)\n            if (1&(i>>j))\n                mask^=v[j];\n        for (int j=0;j<(int)v.size();++j)\n            if (1&(i>>j))\n                dp[i]=max(dp[i],dp[i^(1<<j)]+!mask);\n    }\n    return cout<<res+v.size()-dp[(1<<(int)v.size())-1]<<endl,0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 1e5 + 10, MaxM = 1 << 15 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxN], cnt[20], xr[MaxN];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 1; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 1; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); ++ i) -- f[i];\n\tfor (int i = 1; i < (1 << 15); ++ i)\n\t\tfor (int j = 0; j < 15; ++ j)\n\t\t\tif ((i >> j) & 1) xr[i] ^= (j + 1);\n\tfor (int s = 1; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s] != 0) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (xr[t] == 0) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\næ°æ®ä¸æ¸ç©ºï¼çé¶ä¸¤è¡æ³ªã\nå¤æµä¸è¯»å®ï¼çé¶ä¸¤è¡æ³ªã\nè¾¹çä¸ç¹å¤ï¼çé¶ä¸¤è¡æ³ªã\nè´ªå¿ä¸è¯æï¼çé¶ä¸¤è¡æ³ªã\nD P é¡ºåºéï¼çé¶ä¸¤è¡æ³ªã\nå¤§å°å°ç­å·ï¼çé¶ä¸¤è¡æ³ªã\nåéä¸ç»ä¸ï¼çé¶ä¸¤è¡æ³ªã\nè¶çä¸å¤æ­ï¼çé¶ä¸¤è¡æ³ªã\nè°è¯ä¸æ³¨éï¼çé¶ä¸¤è¡æ³ªã\næº¢åºä¸ l lï¼çé¶ä¸¤è¡æ³ªã\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nconst int inf=0x3f3f3f3f;\nint lowbit(int x){return x&-x;}\nint ppc(int x){return __builtin_popcount(x);}\nconst int N=100000;\nint n;\nvector<pair<int,int> > nei[N+1];\nint buc[16];\nint dfs(int x=1,int fa=0){\n\tint xsm=0;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i].X,v=nei[x][i].Y;\n\t\tif(y==fa)continue;\n\t\tint tmp=dfs(y,x)^v;\n\t\txsm^=tmp;\n\t\tbuc[tmp]++;\n\t}\n\treturn xsm;\n}\nint dp[1<<15];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tx++;y++;\n\t\tnei[x].pb(mp(y,z));nei[y].pb(mp(x,z));\n\t}\n\tdfs();\n\tfor(int i=1;i<1<<15;i++){\n\t\tif(lowbit(i)==i){dp[i]=1;continue;}\n\t\tdp[i]=inf;\n\t\tint xsm=0;\n\t\tfor(int j=1;j<=15;j++)if(i&1<<j-1)xsm^=j;\n\t\tif(!xsm)dp[i]=ppc(i)-1;\n\t\tfor(int j=i-1&i;j;j=j-1&i)dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tint ans=0,msk=0;\n\tfor(int i=1;i<=15;i++)ans+=buc[i]>>1,msk|=(buc[i]&1)<<i-1;\n\tcout<<ans+dp[msk];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n\n\nint cnt = 0;\nvector< vector<int> > hoges;\nvoid dfs(vector<int> items){\n\t\n\tint ok = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tint flg = 1;\n\t\tfor( int j : items ){\n\t\t\tif( (i & j) == j ) flg = 0;\n\t\t}\n\t\tif(flg==0) break;\n\t\tvector<int> t = items;\n\t\tt.push_back(i);\n\t\tdfs(t);\n\t\tok = 1;\n\t}\n\tif(!ok){\n\t\thoges.push_back(items);\n\t}\n}\n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a), b(b), c(c){}\n};\n\nint deg[100010];\nint f(vector<int> hoge, vector<Edge> es){\n\tint ans = 0;\n\tfor(auto h : hoge ){\n\t\tmemset(deg, 0, sizeof(deg));\t\n\t\tfor( auto &e : es ){\n\t\t\tif( (e.c & h) != h ) continue;\n\t\t\tdeg[e.a]++;\n\t\t\tdeg[e.b]++;\n\t\t\te.c -= h;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0 ; i < es.size() + 1 ; i++){\n\t\t\tif( deg[i] == 1 ) cnt++;\n\t\t}\n\t\tans += (cnt + 1) / 2;\n\t}\n\tfor( auto &e : es ){\n\t\tif( e.c != 0 ) return 1e9;\n\t}\n\treturn ans;\n}\n\nvoid solve(ll N, vector<ll> x, vector<ll> y, vector<ll> a){\n\ttime_t start = clock();\n\tdfs({});\n\trandom_shuffle(hoges.begin(), hoges.end());\n\n\t\n\tint ans = 1e9;\n\tvector<Edge> es;\n\tfor(int i = 0 ; i < x.size() ; i++){\n\t\tes.push_back(Edge(x[i], y[i], a[i]));\n\t}\n\tfor( auto hoge : hoges ){\n\t\ttime_t end = clock();\n\t\tif( 1.0 * (end-start) / CLOCKS_PER_SEC > 1.8 ) break;\n\t\tans = min(ans, f(hoge, es));\n\t}\n\tcout << ans << endl;\n\n}\n\nint main(){\t\n\tll N;\n\tscanf(\"%lld\",&N);\n\tvector<ll> x((N-1)-1+1);\n\tvector<ll> y((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor(int i = 0 ; i <= (N-1)-1 ; i++){\n\t\tscanf(\"%lld\",&x[i]);\n\t\tscanf(\"%lld\",&y[i]);\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tsolve(N, x, y, a);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 10000000;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <pii> conn[100050];\nvector <int> son[100050];\nint par[100050][2];\nbool dchk[100050];\nvoid DFS(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) {\n\t\tif (dchk[it.second]) continue;\n\t\tpar[it.second][0] = n, par[it.second][1] = it.first;\n\t\tson[n].push_back(it.second);\n\t\tDFS(it.second);\n\t}\n}\n\nint cnt[16];\nvector <int> Vu;\nint dp[32768];\nint sum[32768];\nint main() {\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i < N; i++) {\n\t\tint t1, t2, t3;\n\t\tscanf(\"%d %d %d\", &t1, &t2, &t3);\n\t\tt1++, t2++;\n\t\tconn[t1].emplace_back(t3, t2);\n\t\tconn[t2].emplace_back(t3, t1);\n\t}\n\tDFS(1);\n\n\tfor (i = 2; i <= N; i++) {\n\t\tint v = par[i][1];\n\t\tfor (auto it : son[i]) v ^= par[it][1];\n\t\tcnt[v]++;\n\t}\n\n\tint ans = cnt[0];\n\tfor (i = 1; i <= 15; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif (cnt[i] % 2) Vu.push_back(i);\n\t}\n\n\tdp[0] = 0;\n\tint X = Vu.size();\n\tint mx = 0;\n\tfor (i = 1; i < (1 << X); i++) for (j = 0; j < X; j++) if (i & (1 << j)) sum[i] ^= Vu[j];\n\tfor (i = 1; i < (1 << X); i++) {\n\t\tdp[i] = 0;\n\t\tfor (j = i; j; j = (j - 1)&i) {\n\t\t\tif (sum[j]) continue;\n\t\t\tdp[i] = max(dp[i], dp[i^j] + 1);\n\t\t}\n\t\tmx = max(mx, dp[i]);\n\t}\n\treturn !printf(\"%d\\n\", N - 1 - ans - mx);\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint in[N],n,ans,is,msk,to = 1<<26,from;\nvector<int>v;\nshort dp[1<<26];\nvoid val(int msk){\n\tv.clear();\n\twhile(msk)\n\t\tv.push_back(msk%3),\n\t\tmsk/=3;\n\twhile(v.size() < 16)v.push_back(0);\n}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1,a,b,c;i < n;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tin[a]^=c;\n\t\tin[b]^=c;\n\t}\n\tfor(int i = 0;i < n;i++)\n\t\tans+=!!(is&(1<<in[i])),\n\t\tis^=1<<in[i];\n\tfor(int i = 0;i < to;i++)dp[i] = 17;\n \tfor(int i = 15;i+ 1;i--)msk = msk*3 + (!(is&(1<<i)) ? 2 : 0);\n\tdp[msk] = 0;\n\tfor(int i = 0;i < to;i++)\n\t\tif(dp[i] < 17){\n\t\t\tval(i);\n\t\t\tint three = 1, freq = 0,temp = 0;\n\t\t\tfrom = 0;\n\t\t\tfor(int j = 0;j < v.size();j++,three*=3){\n\t\t\t\tif(!v[j])dp[i + three] = min(dp[i + three],dp[i]);\n\t\t\t\tif(v[j] == 1)temp^=j,freq++;\n\t\t\t\tfrom = from*3 + (v[j] ? 2 : 0);\n\t\t\t}\n\t\t\tshort lol = dp[i] + freq - (freq > 1);\n\t\t\tif(!temp)dp[from] = min(dp[from],lol);\n\t\t}\n\tfrom = 0;\n\tfor(int i = 0;i < 16;i++)from = from*3 + 2;\n\tcout << ans + dp[from] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n//char buf[1<<24],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nint a[N],b[N];\nint f[(1<<16)+10],s[(1<<16)+10];\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tint n; sc(n);\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tint x,y,w; sc(x),sc(y),sc(w); ++x,++y;\n\t\ta[x]^=w,a[y]^=w;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\t++b[a[i]];\n\tint ans=0; n=0;\n\tfor (int i=1; i<=15; i++)\n\t{\n\t\tans+=b[i]>>1;\n\t\tif (b[i]&1) a[++n]=i;\n\t}\n\tint S=(1<<n)-1;\n\tfor (int s=1; s<=S; s++)\n\t{\n\t\tf[s]=f[s>>1]+(s&1);\n\t\tfor (int i=1; i<=n; i++) if (s>>(i-1)&1)\n\t\t\t::s[s]^=a[i];\n\t}\n\tfor (int i=1; i<=S; i++)\n\t\tf[i]=s[i]?1e9:f[i]-1;\n\tfor (int s=1; s<=S; s++) if (!::s[s])\n\t{\n\t\tfor (int s1=s; s1; s1=(s1-1)&s)\n\t\t\tf[s]=min (f[s],f[s1]+f[s-s1]);\n\t}\n\tpr(ans+f[S]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n;\nvector<pair<int,int> > g[N];\nvector<int> sons[N];\nint val[N];\nint used[N];\n\nvoid dfs(int v,int par_cost=0){\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i].first;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tint cost=g[v][i].second;\n\t\tsons[v].push_back(to);\n\t\tdfs(to,cost);\n\t}\n\n\tfor (int i=0;i<sons[v].size();i++){\n\t\tint to=sons[v][i];\n\t\tval[v]^=val[to];\n\t}\n\tval[v]^=par_cost;\n}\n\nint ans;\nint cnt[N];\nint pcount[N];\nint dp[N];\nint mem_xor[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(make_pair(b,c));\n\t\tg[b].push_back(make_pair(a,c));\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tpcount[i]=pcount[i/2]+i%2;\n\t}\n\n\tfor (int mask=0;mask<(1<<16);mask++){\n\t\tint here=0;\n\t\tfor (int i=0;i<16;i++){\n\t\t\tif (mask&(1<<i))\n\t\t\t\there^=i;\n\t\t}\n\t\tmem_xor[mask]=here;\n\t}\n\n\tdfs(0);\n\n\tfor (int i=1;i<n;i++){\n\t//\tcout<<val[i]<<endl;\n\t\tcnt[val[i]]++;\n\t}\n\n\tfor (int i=0;i<16;i++){\n\t\tif (i!=0)\n\t\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\n\t/*for (int i=0;i<16;i++){\n\t\tcout<<i<<\" \"<<cnt[i]<<endl;\n\t}*/\n\n\tdp[0]=0;\n\n\tfor (int mask=1;mask<(1<<16);mask++){\n\t\tint smask=mask;\n\t\tdp[mask]=1e9;\n\t\twhile (true){\n\t\t\tif (smask==0)\n\t\t\t\tbreak;\n\t\t\tint here=pcount[smask];\n\t\t\tint is_good=mem_xor[smask];\n\t\t\tif (is_good==0)\n\t\t\t\there--;\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+here);\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+dp[smask]);\n\t\t\tsmask=(smask-1);\n\t\t\tsmask&=mask;\n\t\t}\n\t}\n\n\tint interesting=0;\n\tfor (int i=0;i<16;i++){\n\t\tif (cnt[i])\n\t\t\tinteresting|=(1<<i);\n\t}\n\tcout<<ans+dp[interesting]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "import java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int bit[] = new int[N];\n        for(int i=0;i<N-1;++i){\n            int x = scan.nextInt();\n            int y = scan.nextInt();\n            int a = scan.nextInt();\n            bit[x]^=a;\n            bit[y]^=a;\n        }\n        int count[] = new int[1<<4];\n        for(int i=0;i<N;++i)count[bit[i]]++;\n        int ans =0;\n        for(int i=1;i<(1<<4);++i){\n            ans+=count[i]/2;\n            count[i]%=2;\n        }\n        int num=0;\n        for(int i=1;i<(1<<4);++i){\n            if(count[i]>0){\n                num^=i;\n                count[i]--;\n                if(num==i)continue;\n                ++ans;\n                if(count[num]>0){\n                    ++ans;\n                    num=0;\n                    count[num]--;\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nusing edge = struct {int to, cost;};\nvector<edge> graph[limit];\n\nint group[1 << 16];\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tgroup[0] = 0;\n\trep(mask, 1 << 16) {\n\t\trep(i, 1, 16) {\n\t\t\tif (mask & (1 << i)) continue;\n\t\t\tconst int nmask = mask | (1 << i);\n\t\t\tint ans = 0;\n\t\t\trep(j, 1, 16) if (nmask & (1 << j)) ans ^= j;\n\t\t\tchmax(group[nmask], group[mask] + (ans == 0));\n\t\t}\n\t}\n\n\trep(i, n - 1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgraph[x].push_back({y, a});\n\t\tgraph[y].push_back({x, a});\n\t}\n\n\tvector<int> num(16, 0);\n\trep(v, n) {\n\t\tint x = 0;\n\t\tfor (auto &e : graph[v]) x ^= e.cost;\n\t\tnum[x]++;\n\t}\n\n\tint ans = n  - num[0], mask = 0;\n\trep(i, 1, 16) {\n\t\tif (num[i] % 2 == 1) mask |= (1 << i);\n\t\tans -= num[i] / 2;\n\t}\n\tans -= group[mask];\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n;\nvector<P> g[101010];\nll v[101010],cnt[16];\nll res=0;\nll pre[1<<15],bc[1<<15];\nll dp[1<<15];\n\nint main(){\n\tcin>>n;\n  rep(i,n-1){\n    ll a,b,c;\n    cin>>a>>b>>c;\n    g[a].push_back(P(b,c));\n    g[b].push_back(P(a,c));\n  }\n  rep(i,n){\n    for(P e : g[i]){\n      v[i]^=e.se;\n    }\n    cnt[v[i]]++;\n  }\n  ll iS=0;\n  repl(i,1,16){\n    res+=cnt[i]/2;\n    cnt[i]%=2;\n    if(cnt[i])iS|=1<<(i-1);\n  }\n  rep(S,1<<15){\n    dp[S]=INF;\n    bc[S]=bcnt(S);\n    bool ok=true;\n    rep(j,15){\n      if((S>>j)&1)continue;\n      if(cnt[j+1])pre[S]^=j+1;\n    }\n  }\n  dp[iS]=0;\n  for(ll S=(1<<15)-1;S>=0;S--){\n    if(dp[S]==INF)continue;\n    for(ll T=S-1;T>=0;T--){\n      T&=S;\n      ll U=S-T;\n      if(pre[U]==0)minch(dp[T],dp[S]+bc[U]-1);\n    }\n  }\n  cout<<res+dp[0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define mpr make_pair\n#define pii pair<int,int>\n\ntypedef long long ll;\nconst int maxn = 1e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nint n, s;\nint cnt[maxn], a[maxn], dp[maxn];\n\nsigned main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    for(int i = 1, u, v, w; i < n; i++)\n    {\n        cin>> u >> v >> w; u++; v++;\n        (a[v] ^= w);\n        (a[u] ^= w);\n    }\n\n    for(int v = 1; v <= n; v++) cnt[a[v]]++;\n    int ans = 0;\n    for(int i = 0; i < 15; i++)\n    {\n        if(i == 0) ans += cnt[i];\n        else ans += cnt[i]/2;\n        (cnt[i] &= 1);\n    }\n\n    /// dp = maximum tedad daste\n    for(int msk = 0; msk < (1<<15); msk++)\n    {\n        dp[msk] = -inf;\n        int X = 0, id, is = 0;\n        for(int i = 0; i < 15; i++)\n            if((1<<i) & msk)\n            {\n                if(cnt[i]&1) (X ^= i);\n                if(cnt[i]) is = 1;\n                id = i;\n            }\n\n        if(X == 0 && msk > 0)\n        {\n            if(!is)\n            {\n                dp[msk] = 0;\n                continue;\n            }\n\n            if(__builtin_popcount(msk) == 1)\n            {\n                dp[msk] = cnt[id]/2;\n                if(id == 0) dp[msk] = cnt[id];\n            }\n            else\n            {\n                dp[msk] = 1;\n                for(int s = ((msk-1)&msk); s; s = ((s-1)&msk))\n                    dp[msk] = max(dp[msk], dp[s] + dp[msk^s]);\n            }\n        }\n    }\n\n    int msk = (1<<15)-1;\n    cout<< n-(dp[msk]+ans);\n}\n\n/*\n2\nT 30\nW 1\n3\nT 1\nW 1\nT 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n\nint n, cnt[16], ans, now, f[101000], g[77777];\nvector<pii>vec;\nvoid U(int &x,int y){ x=min(x,y); }\n\nint main(){\n  memset(g,33,sizeof g); g[0]=0;\n  for (int i=2;i<(1<<16);i+=2){\n    int x=0, c=-1;\n    for (int j=1;j<16;++j)\n      if (i>>j&1)\n        x^=j, ++c;\n    if (!x) vec.push_back((pii){i,c});\n  }\n  \n  for (int i=0;i<16;++i)\n    for (int x=0;x<(1<<16);x+=2) if (g[x]==i){\n      for (auto o:vec)\n        U(g[x^o.fi],i+o.se);\n    }\n  \n  cin>>n;\n  int x, y, z;\n  for (int i=1;i<n;++i){\n    scanf(\"%d%d%d\",&x,&y,&z); f[++x]^=z; f[++y]^=z;\n  }\n  for (int i=1;i<=n;++i) ++cnt[f[i]];\n  for (int i=1;i<16;++i){\n    ans+=cnt[i]>>1;\n    now|=(cnt[i]&1)<<i;\n  }\n  cout<<ans+g[now];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std ;\nint n ;\nconst int N = 1e5 + 10 ;\nconst int M = 1 << 17 ;\nint s[N] , S , ans , f[M] , inf , sum[20] ;\n\ninline int dfs(int S) {\n  if(! S) return 0 ;\n  if(f[S] < inf) return f[S] ;\n  for(register int i = 0 ; i < 16 ; i ++)\n    if(S & (1 << i)) {\n      for(register int j = 0 ; j < 16 ; j ++)\n        if(i != j && (S & (1 << j))) {\n          int p = i ^ j ;\n          int x = S ^ (1 << i) ^ (1 << j) ^ (1 << p) ;\n          if(S & (1 << p)) { f[S] = min(f[S] , dfs(x) + 2) ; }\n          else { f[S] = min(f[S] , dfs(x) + 1) ; }\n        }\n    }\n    return f[S] ;\n}\nsigned main(){\n  ios :: sync_with_stdio(false) ;\n  cin.tie(0) ;\n  cout.tie(0) ;\n  cin >> n ;\n  for(register int i = 1 ; i < n ; i ++) { int a , b , c ; cin >> a >> b >> c ; s[a] ^= c ; s[b] ^= c ; }\n  for(register int i = 0 ; i < n ; i ++) { sum[s[i]] ++ ; }\n  for(register int i = 1 ; i < 16 ; i ++)\n    ans += (sum[i] >> 1) , S += (1 << i) * (sum[i] & 1) ;\n  memset(f , 0x7f , sizeof(f)) ; inf = f[0] ;\n  cout << ans + dfs(S) << '\\n' ;\n}\n/*\n5\n0 1 1\n0 2 3\n0 3 6\n3 4 4\n*/"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[20],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nint N;\nmap<int, vector<pint>> edges;\n\nvector<int> xors;\n\nint next_combination(int comb)\n{\n    int x = comb & -comb, y = comb + x;\n    return ((comb & ~y) / x >> 1) | y;\n}\n\nconstexpr int D = 15;\n\nint main()\n{\n    cin >> N;\n    REP(i, N - 1)\n    {\n        int x, y, a;\n        cin >> x >> y >> a;\n        edges[x].emplace_back(y, a);\n        edges[y].emplace_back(x, a);\n    }\n    xors.resize(N);\n    REP(i, N) for (auto e : edges[i]) xors[i] ^= e.second;\n\n    vector<int> cou(D);\n    for (auto v : xors) if (v) cou[v - 1]++;\n\n    vector<int> dp(POW2(D), 100);\n    dp[0] = 0;\n\n    FOR(npop, 3, D + 1)\n    {\n        int S = POW2(npop) - 1;\n        while (S < POW2(D))\n        {\n            REP(d, D) if (S & POW2(d)) FOR(d1, d + 1, D) if (S & POW2(d1))\n            {\n                int new_a = ((d + 1) xor (d1 + 1)) - 1;\n                if (S & POW2(new_a)) mmin(dp[S], dp[S xor POW2(d) xor POW2(d1) xor POW2(new_a)] + 2);\n                else mmin(dp[S], dp[S xor POW2(d) xor POW2(d1) xor POW2(new_a)] + 1);\n            }\n            S = next_combination(S);\n        }\n    }\n    int ans = 0;\n    int S = 0;\n    REP(i, D)\n    {\n        ans += cou[i] / 2;\n        S += POW2(i) * (cou[i] % 2);\n    }\n    cout << ans + dp[S] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\nusing namespace std;\ninline int read(){\n\tint s=0,f=1; char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}\n\twhile(c>='0'&&c<='9') s=(s<<1)+(s<<3)+(c^48),c=getchar();\n\treturn f?s:-s;\n}\nint n,val[100010],cnt[20];\nint ans,st,f[1<<16],Xor[1<<16];\nint main(){\n\tn=read();\n\tfor(rint i=1;i<n;++i){\n\t\tint x=read(),y=read(),v=read();\n\t\tval[x]^=v; val[y]^=v;\n\t}\n\tfor(rint i=0;i<n;++i) ++cnt[val[i]];\n\tfor(rint i=1;i<=15;++i){\n\t\tans+=cnt[i]/2; cnt[i]%=2;\n\t\tst|=cnt[i]<<i-1;\n\t}\n\tfor(rint i=1;i<1<<15;++i) f[i]=f[i>>1]+(i&1);\n\tfor(rint i=1;i<1<<15;++i) --f[i];\n\tfor(rint i=1;i<1<<15;++i)\n\t\tfor(rint j=1;j<=15;++j)\n\t\t\tif(i&(1<<j-1)) Xor[i]^=j;\n\tfor(rint S=1;S<1<<15;++S){\n\t\tif(Xor[S]) continue;\n\t\tfor(rint i=(S-1)&S;i;i=(i-1)&S)\n\t\t\tif(!Xor[i]) f[S]=min(f[S],f[i]+f[S^i]);\n\t}\n\tprintf(\"%d\",ans+f[st]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define N 2001001\n#define MAX 2001\n#define re register\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst ll mod=1000000007; \ninline void read(re ll &ret)\n{\n    ret=0;re char c=getchar();re bool pd=false;\n    while(!isdigit(c)){pd|=c=='-';c=getchar();}\n    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}\n    ret=pd?-ret:ret;\n    return;\n}\nll n,x[N],y[N],a[N],w[N],cnt[N],ans,st,dp[N],sum[N];\nsigned main()\n{\n\tread(n);\n\tfor(re int i=1;i<n;i++)\n\t{\n\t\tread(x[i]);\n\t\tread(y[i]);\n\t\tread(a[i]);\n\t\tw[x[i]]^=a[i];\n\t\tw[y[i]]^=a[i];\n\t}\n\tfor(re int i=0;i<n;i++)\n\t\tcnt[w[i]]++;\n\tfor(re int i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]>>1;\n\t\tst|=(cnt[i]&1)<<(i-1);\n\t}\n\tfor(re int i=1;i<=(1<<15);i++)\n\t\tdp[i]=dp[i>>1]+(i&1);\n\tfor(re int i=1;i<=(1<<15);i++)\n\t\tdp[i]--;\n\tfor(re int i=1;i<=(1<<15);i++)\n\t\tfor(re int j=0;(1<<j)<=i;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tsum[i]^=j+1;\n\tfor(re int i=1;i<=(1<<15);i++)\n\t{\n\t\tif(sum[i])\n\t\t\tcontinue;\n\t\tfor(re int j=(i-1)&i;j;j=((j-1)&j))\n\t\t\tif(!sum[j])\n\t\t\t\tdp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t}\n\tprintf(\"%lld\\n\",ans+dp[st]);\n\texit(0);\n}\n/*\n9 9\n9 8 7 6 2 4 5 3 1\n4 9 3 6\n2 9 1 8\n3 8 2 4\n3 9 2 7\n2 8 1 6\n1 9 1 9\n1 3 5 7\n2 3 3 3\n6 6 6 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n\nint N, X[100000];\nint dp[1 << 16];\nint ok[1 << 16];\n\nint rec(int bit) {\n  if(~dp[bit]) return dp[bit];\n  int ret = ok[bit];\n  for(int i = bit; i > 0; i = (i - 1) & bit) {\n    if(i == bit) continue;\n    int other = i ^bit;\n    ret = min(ret, rec(i) + rec(other));\n  }\n  return dp[bit] = ret;\n}\n\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    X[x] ^= z;\n    X[y] ^= z;\n  }\n  int bit = 0, ret = 0;\n  for(int i = 0; i < N; i++) {\n    if(X[i] == 0) continue;\n    if(bit & (1 << X[i])) ++ret;\n    bit ^= 1 << X[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  for(int i = 1; i < (1 << 16); i++) {\n    ok[i] = ok[i & (i - 1)] + 1;\n  }\n  for(int i = 1; i < (1 << 16); i++) {\n    int v = 0;\n    for(int j = 0; j < 16; j++) {\n      if((i >> j) & 1) v ^= j;\n    }\n    if(v == 0) --ok[i];\n  }\n  cout << ret + rec(bit) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 2 * 1e5 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxN], cnt[20], xr[MaxN];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 1; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 1; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); ++ i) -- f[i];\n\n\tfor (int i = 1; i < (1 << 15); ++ i)\n\t\tfor (int j = 0; j < 15; ++ j)\n\t\t\tif ((i >> j) & 1) xr[i] ^= (j + 1);\n\tfor (int s = 1; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s] != 0) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (xr[t] == 0) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint va[N];\nint num[20];\nint a[20],sz,b[1001000];\nint dp[1001000];\nint solve(int s)\n{\n\tif(s==0||dp[s]) return dp[s];\n\tdp[s]=1;\n\tfor(int i=s;i;)\n\t{\n\t\ti=(i-1)&s;\n        if(b[i]==0) dp[s]=max(dp[s],solve(i)+solve(s^i));\n\t}\n\treturn dp[s];\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tva[u]^=w; va[v]^=w;\n\t}\n\tfor(int i=0;i<n;++i) ++num[va[i]];\n\tint cnt=num[0];\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tcnt+=num[i]/2;\n\t\tif(num[i]&1) a[sz++]=i;\n\t}\n\tfor(int s=0;s<(1<<sz);++s)\n\t\tfor(int i=0;i<sz;++i)\n\t\t\tif(s>>i&1)\n\t\t\t\tb[s]^=a[i];\n\tif(sz)cnt+=solve((1<<sz)-1);\n\tprintf(\"%d\\n\",n-cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define lb(i) i&(-i);\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int maxn =1e5+5;\nint n,a[maxn],xr[maxn],dp[(1<<16)],cal[maxn],re;\nbool ok[16];\nvector<int> v;\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n;\n    rep(i,1,n)\n    {\n        int x,y,w;\n        cin>>x>>y>>w;\n        xr[x]^=w;\n        xr[y]^=w;\n    }\n    rep(i,0,n)\n    {\n        if(xr[i]==0)\n        {\n            re++;\n        }\n        else if(ok[xr[i]])\n        {\n            ok[xr[i]]=0;\n            re++;\n        }\n        else\n        {\n            ok[xr[i]]=1;\n        }\n    }\n    rep(i,1,16)if(ok[i])\n    {\n        v.pb(i);\n        //cout<<v.back()<<' ';\n    }\n    //cout<<endl;\n    int l=v.size();\n    rep(i,1,(1<<l))\n    {\n        int j=0;\n        while(!(i&(1<<j)))j++;\n        cal[i]=cal[i^(1<<j)]^v[j];\n    }\n    rep(i,1,(1<<l))\n    {\n        dp[i]=1000;\n        for(int sub=i;sub>0;sub=(sub-1)&i)if(cal[sub]==0)\n        {\n            dp[i]=min(dp[i],dp[i^sub]+1);\n        }\n    }\n    re+=dp[(1<<l)-1];\n    cout<<n-re;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, sum[10005], cnt[16], dp[1 << 15];\nvector<pair<int, int>> g[10005];\n\nvoid dfs(int u, int fa) {\n\tfor (const auto &e : g[u]) {\n\t\tint v = e.first, w = e.second;\n\t\tif (v != fa) ++cnt[sum[v] = sum[u] ^ w], dfs(v, u);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v, c; i < n; ++i) {\n\t\tscanf(\"%d%d%d\", &u, &v, &c);\n\t\tg[u].emplace_back(v, c);\n\t\tg[v].emplace_back(u, c);\n\t}\n\tdfs(0, -1);\n\tint ans = 0, buc = 0;\n\tfor (int i = 1; i < 16; ++i) ans += cnt[i] >> 1, buc |= (cnt[i] & 1) << i - 1;\n\tfor (int s = 1; s <= buc; ++s) {\n\t\tint t = 0;\n\t\tfor (int i = 0; i < 15; ++i)\n\t\t\tif (s >> i & 1) ++dp[s], t ^= i + 1;\n\t\tdp[s] -= !t;\n\t\tfor (int t = s - 1 & s; t; t = t - 1 & s)\n\t\t\tdp[s] = min(dp[s], dp[t] + dp[s ^ t]);\n\t}\n\tprintf(\"%d\\n\", ans + dp[buc]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nvector<int> gay;\n\nint Dfs(int msk) {\n  if (!msk) return 0;\n  assert((msk & -msk) != msk);\n  int &res = gay[msk];\n  res = 2233;\n  for (int i = 0; i < 16; ++i) {\n    if (msk >> i & 1) {\n      for (int j = i + 1; j < 16; ++j) {\n        if (msk >> j & 1) {\n          int g = i ^ j;\n          res = min(res, 1 + (msk >> g & 1) + Dfs(msk ^ (1 << i) ^ (1 << j) ^ (1 << g)));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n;\n  cin >> n;\n  Vec w(n), cnt(16);\n  \n  for (int i = 1, x, y, z; i < n; ++i) {\n    cin >> x >> y >> z;\n    w[x] ^= z;\n    w[y] ^= z;\n  }\n  for (int i = 0; i < n; ++i) {\n    ++cnt[w[i]];\n  }\n\n  int ans = 0, msk = 0;\n  for (int i = 1; i < 16; ++i) {\n    ans += cnt[i] / 2;\n    cnt[i] %= 2;\n    msk |= cnt[i] << i;\n  }\n\n  gay.resize(1 << 16);\n  cout << ans + Dfs(msk) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9,mod=1e9+7;\ntypedef long long ll;\nint read() {\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n\treturn x*f;\n}\nusing namespace std;\nint val[1000001],f[1000001],cnt[20],vis[1000001],js,x,y,z,ans,n,len=(1<<15);\nint main() {\n\tn=read(),len=(1<<15);\n\tfor(int i=1; i<n; i++)\n\t\tx=read(),y=read(),z=read(),val[x]^=z,val[y]^=z;\n\tfor(int i=0; i<n; i++)\n\t\tcnt[val[i]]++;\n\tfor(int i=1; i<=15; i++)\n\t\tans+=cnt[i]/2,js|=(cnt[i]&1)<<(i-1);\n\tfor(int i=1; i<len; i++)\n\t\tf[i]=f[i>>1]+(i&1);\n\tfor(int i=1; i<len; i++)\n\t\tf[i]--;\n\tfor(int i=1; i<len; i++)\n\t\tfor(int j=0; j<15; j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tvis[i]^=(j+1);\n\tfor(int i=1; i<len; i++) {\n\t\tif(vis[i]) continue;\n\t\tfor(int k=(i-1)&i; k; k=(k-1)&i)\n\t\t\tif(!vis[k])\n\t\t\t\tf[i]=min(f[i],f[k]+f[i^k]);\n\t}\n\tprintf(\"%d\",ans+f[js]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nlong long max(long long x, long long y){return (x > y ? x : y);}\nlong long min(long long x, long long y){return (x < y ? x : y);}\nint gcd(int a, int b) { return b ? gcd(b, a%b) : a; }\n\n#define ll int\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=1e5+500;\nconst ll inf=1e9+800;\nconst ll mod=1e9+7;\n\nll dp[1<<16];\nll xx[1<<16];\nvoid cal(){\n\txx[0]=0;\n\tfor(ll i=2;i<(1<<16);i+=2){\n\t\tll lb;\n\t\tfor(ll j=0;j<16;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tlb=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\txx[i]=(xx[i^(1<<lb)]^lb);\n  \t}\n\tdp[0]=0;\n\tfor(ll i=2;i<(1<<16);i+=2){\n\t\tfor(ll mas=i;mas>0;mas=((mas-1)&i)){\n\t\t\tif(xx[mas]==0)dp[i]=max(dp[i],dp[i^mas]+1);\n\t\t}\n\t}\n}\n\nll a[maxn];\nll cnt[16];\n\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tll n;\n\tcin>>n;\n\tfor(ll i=1;i<n;i++){\n\t\tll v,u,w;\n\t\tcin>>v>>u>>w;\n\t\ta[v]^=w;\n\t\ta[u]^=w;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tcnt[a[i]]++;\n\t}\n\tcnt[0]=0;\n\tll ans=0;\n\tfor(ll i=0;i<16;i++){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\tll res=0;\n\tll t=0;\n\tfor(ll i=0;i<16;i++){\n\t\tif(cnt[i]){\n\t\t\tres+=(1LL<<i);\n\t\t\tt++;\n\t\t}\n\t}\n\tcal();\n\tcout<<ans+t-dp[res];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n\nint n, cnt[16], ans, now, f[101000], g[77777];\nvector<pii>G[101000], vec;\nvoid U(int &x,int y){ x=min(x,y); }\n\nvoid dfs(int x,int fff,int lasv){\n  for (auto y:G[x]){\n    if (y.fi==fff) continue;\n    dfs(y.fi,x,y.se);\n  }\n  lasv^=f[x];\n  if (fff&&lasv){\n    ++cnt[lasv];\n    f[fff]^=lasv;\n  }\n}\n\nint main(){\n  memset(g,33,sizeof g); g[0]=0;\n  for (int i=2;i<(1<<16);i+=2){\n    int x=0, c=-1;\n    for (int j=1;j<16;++j)\n      if (i>>j&1)\n        x^=j, ++c;\n    if (!x) vec.push_back((pii){i,c});\n  }\n  for (int i=1;i<16;++i) vec.push_back((pii){1<<i,1});\n  \n  for (int i=0;i<16;++i)\n    for (int x=0;x<(1<<16);x+=2) if (g[x]==i){\n      for (auto o:vec)\n        U(g[x^o.fi],i+o.se);\n    }\n  \n  cin>>n;\n  int x, y, z;\n  for (int i=1;i<n;++i){\n    scanf(\"%d%d%d\",&x,&y,&z); ++x; ++y;\n    G[x].push_back((pii){y,z});\n    G[y].push_back((pii){x,z});\n  }\n  dfs(1,0,0);\n  for (int i=1;i<16;++i){\n    ans+=cnt[i]>>1;\n    now|=(cnt[i]&1)<<i;\n  }\n  cout<<ans+g[now];\n}"
  },
  {
    "language": "C++",
    "code": "//by (111110101)2\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\nusing namespace std;\nint n,dp[1<<17],nm[101010],sum,cnt[22],ans,mk;\nbool gd[1<<17];\nint main()\n{\n\tfor(int i=0;i<(1<<16);i++)\n\t{\n\t\tsum=0;\n\t\tfor(int j=0;j<16;j++)\n\t\t{\n\t\t\tif((i>>j)&1)\n\t\t\t{\n\t\t\t\tsum^=j;\n\t\t\t}\n\t\t}\n\t\tif(sum==0)\n\t\t{\n\t\t\tgd[i]=true;\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;\n\t\tb--;\n\t\tnm[a]^=c;\n\t\tnm[b]^=c;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(nm[i])\n\t\t{\n\t\t\tcnt[nm[i]]++;\n\t\t}\n\t}\n\tfor(int i=0;i<21;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmk|=(1<<i);\n\t\t}\n\t}\n\tfor(int i=0;i<=mk;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(gd[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mk]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nint main()\n{\n\tmemset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot+=(1<<i);\n\tf[0]=0;\n\tfor(int s=1;s<=tot;s++){\n\t\tfor(int i=1;i<=15;i++)if(s>>i&1){\n\t\t\tfor(int j=1;j<=15;j++)if((s>>j&1) && (i!=j)){\n\t\t\t\tif(!((1<<(i^j))&s))f[s]=min(f[s],f[s-(1<<i)+(1<<(i^j))]+1);\n\t\t\t\telse{\n\t\t\t\t\tf[s]=min(f[s],f[s-(1<<i)-(1<<j)-(1<<i^j)]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\n#ifdef DEBUG\nstruct Timestamper {\n  string msg;\n  clock_t start;\n\n  Timestamper(const string &_msg) : msg(_msg), start(clock()) {}\n  ~Timestamper() {\n    eprintf(\"[ %s ] Time=%.3lfs\\n\", msg.c_str(), (clock() - start) * 1.0 / CLOCKS_PER_SEC);\n  }\n} __timestamper(\"end\");\n#else\nstruct Timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nconst int inf = 1e9;\n\nint cache[1 << 16];\nint solve(int msk) {\n  if (!msk) return 0;\n  if (cache[msk]) return cache[msk];\n\n  int ans = inf;\n  for (int i = 15; i >= 0; i--) if (msk & (1 << i)) {\n    ans = min(ans, 1 + solve(msk ^ (1 << i)));\n    for (int si = 0; si < i; si++) if (msk & (1 << si)) {\n      int si2 = i ^ si;\n      int cans = solve(msk ^ (1 << i) ^ (1 << si) ^ (1 << si2)) + 1;\n      if (msk & (1 << si2)) cans++;\n      ans = min(ans, cans);\n    }\n    break;\n  }\n  return cache[msk] = ans;\n}\n\nvector<vector<pii>> es;\nvi cnts;\n\nvoid dfs(int v, int par = -1) {\n  int tails = 0;\n  for (pii e : es[v])\n    if (e.first == par) {\n      tails ^= e.second;\n    } else {\n      dfs(e.first, v);\n      tails ^= e.second;\n    }\n//  eprintf(\"v=%d, tails=%d\\n\", v, tails);\n  cnts[tails]++;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    es = vector<vector<pii>>(n);\n    forn (i, n - 1) {\n      int a, b, w;\n      scanf(\"%d%d%d\", &a, &b, &w);\n      es[a].eb(b, w);\n      es[b].eb(a, w);\n    }\n    cnts = vi(16, 0);\n    dfs(0);\n    cnts[0] = 0;\n    eprintf(\"cnts:\\n\");\n//    forn (i, 16)\n//      eprintf(\"  [%d]=%d\\n\", i, cnts[i]);\n    int ans = 0;\n    int msk = 0;\n    forn (i, 16) {\n      ans += cnts[i] / 2;\n      if (cnts[i] & 1) {\n        msk |= 1 << i;\n      }\n    }\n    eprintf(\"preans=%d\\n\", ans);\n    ans += solve(msk);\n    printf(\"%d\\n\", ans);\n    eprintf(\"=====\\n\");\n    fflush(stdout);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst char nl = '\\n';\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> pt;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5+10, B = 16;\n\nint val[N];\nint dp[1 << B];\n\nint solve(int bm) {\n    if (!bm) return 0;\n    if (dp[bm] != -1) return dp[bm];\n    dp[bm] = INF;\n    int ans = INF;\n    for (int i = 0; i < B; i++) {\n        if (!(bm & (1 << i))) continue;\n        for (int j = i+1; j < B; j++) {\n            if (!(bm & (1 << j)) ) continue;\n            int nbm = bm ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n            bool b = bm & (1 << (i ^ j));\n            ans = min(ans, solve(nbm) + 1 + b);\n        }\n    }\n    return dp[bm] = ans;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int x, y, a; cin >> x >> y >> a;\n        val[x] ^= a;\n        val[y] ^= a;\n    }\n    int ans = 0;\n    int bm = 0;\n    for (int i = 0; i < n; i++) {\n        if (!val[i]) continue;\n        if (bm & (1 << val[i])) ans++;\n        bm ^= 1 << val[i];\n    }\n    memset(dp, -1, sizeof dp);\n    cout << ans + solve(bm) << nl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[32], p[20], dp[1 << 16], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << 16; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\nconst ll N = 1e5 + (1 << 16), inf = 1e9;\n\nll n, a[N], cnt[N], dp[N];\nvector <int> adj[N];\n\nll dfs(ll w) {\n\tif(dp[w] >= 0)\treturn dp[w];\n\telse\n\t\tdp[w] = inf;\n\tfor (int i = 0; i < 15; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tif(i == j)\tcontinue;\n\t\t\tif(!(w & (1 << i)) || !(w & (1 << j)))\n\t\t\t\tcontinue;\n\t\t\tint k = (i + 1) ^ (j + 1);\n\t\t\tk--;\n\t\t\tll small = dfs(w ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 1;\n\t\t\tif(w & (1 << k))\n\t\t\t\tdp[w] = min(dp[w], small + 1);\n\t\t\telse\n\t\t\t\tdp[w] = min(dp[w], small);\n\t\t}\n\t}\n\treturn dp[w];\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < N; i++)\n\t\tdp[i] = -inf;\n\t// VORODI SEFR BASEE\n\tint m = n - 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u, w;\n\t\tcin >> v >> u >> w;\n\t\tadj[v].push_back(u), adj[u].push_back(v);\n\t\ta[v] ^= w, a[u] ^= w;\n\t}\n\tfor (int i = 0; i < n; i++)\tcnt[a[i]]++;\n\tint ans = 0, num = 0;\n\tfor (int i = 1; i < (1 << 4); i++) {\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] &= 1;\n\t\tnum |= (cnt[i] * (1 << (i - 1)));\n\t}\n\tdp[0] = 0;\n//\tcout << ans << \"\\n\" << dfs(num) << \"\\n\";\n\tans += dfs(num);\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define Min(a,b) a=min(a,b);\n#define ret return puts(\"-1\"),0;\n#define N 500055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,num[17],cnt[70005],f[70005],x,y,v,a[N],b[N],ans;\nvector<int> vec[20];\nvoid dp(int S){\n    F(i,0,num[16]) cnt[i]=cnt[i>>1]+(i&1),vec[cnt[i]].push_back(i),f[i]=inf;\n    f[S]=0;\n    D(i,16,1)\n        for (int j=0;j<vec[i].size();j++){\n            int s=vec[i][j];\n            if (f[s]==inf) continue;\n            F(x,0,15)\n                F(y,0,15){\n                    if (!(s&num[x])||!(s&num[y])||x==y) continue;\n                    Min(f[s^num[x]^num[x^y]^num[y]],f[s]+1+((s&num[x^y])>0));\n                }\n        }\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1){\n\t\tx=read();y=read();v=read();\n\t\ta[x]^=v;a[y]^=v;\n\t}\n\tF(i,0,n-1) b[a[i]]++;\n\tF(i,1,15) ans+=b[i]/2;\n\tnum[0]=1;F(i,1,16) num[i]=num[i-1]*2;\n\tint sum=0;F(i,1,15) sum+=num[i]*(b[i]&1);\n\tdp(sum);\n\twrn(f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-10;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nvector<int> bit[100010];\nint m;\nvector<int> noww;\nint f(int now,int x){\n    m=(int)bit[now].size();\n    bool bo=false;\n    rep(i,0,1<<m){\n        int u=0;\n        noww.clear();\n        rep(j,0,m){\n            if((i>>j)&1){\n                u^=bit[now][j];\n            }\n            else noww.push_back(bit[now][j]);\n        }\n        if(u==x){\n            bit[now]=noww;\n            bo=true;\n            break;\n        }\n    }\n    if(bo==false){\n        rep(j,0,m)x=min(x,x^bit[now][j]);\n        bit[now].push_back(x);\n    }\n    return bo;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n;cin>>n;\n    vector<pii> v[n];\n    rep(i,0,n-1){\n        int x,y,a;cin>>x>>y>>a;\n        v[x].push_back({y,a});\n        v[y].push_back({x,a});\n    }\n    int par[n];\n    par[0]=-1;\n    queue<int> q;\n    q.push(0);\n    v[0].push_back({-1,-1});\n    int pa[n];\n    while(q.size()>0){\n        int now=q.front();q.pop();\n        rep(i,0,v[now].size()){\n            int ne=v[now][i].first;\n            if(ne==par[now]){\n                pa[now]=v[now][i].second;\n                continue;\n            }\n            par[ne]=now;\n            q.push(ne);\n        }\n    }\n    int cnt[n];\n    fill(cnt,cnt+n,0);\n    rep(i,0,n){\n        if(v[i].size()==1){\n            q.push(i);\n        }\n    }\n    int ans=0;\n    int h;\n    while(q.size()>0){\n        int now=q.front();q.pop();\n        if(now==0)break;\n        int pp=par[now],ata=pa[now];\n        h=f(now,ata);\n        if(h==0)ans++;\n        rep(i,0,bit[now].size()){\n            ans-=f(pp,bit[now][i]);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // ãããä½¿ããªãã°ãtieã¨ããæ¶ãã¦ï¼ï¼\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll n; cin >> n;\n    vll b(n);\n    vll c(16);\n    rep(i, n-1) {\n        ll x, y, a; cin >> x >> y >> a;\n        b[x] ^= a;\n        b[y] ^= a;\n    }\n    rep(i, n) {\n        c[b[i]]++;\n    }\n//    cout << c << endl;\n    ll ret = 0; c[0] = 0;\n    rep(i, 16) {\n        ret += c[i] / 2;\n        c[i] %= 2;\n    }\n//    cout << c << endl;\n//    cout << ret << endl;\n    ll state = 0;\n    rep(i, 15) {\n        if (c[i+1]) \n            state |= 1ll << i;\n    }\n//    cout << bitset<15>(state) <<endl;\n    ll maskn = 1<<15;\n    ll dp[maskn];\n    repi(mask, 1, maskn) {\n//        cout << mask << endl;\n        ll tmp = 0;\n        rep(i, 15) if (mask & (1ll << i)) {\n            tmp ^= (i+1);\n        }\n        dp[mask] = tmp == 0;\n\n    }\n    rep(i, maskn) {\n//        cout << i << endl;\n        for(int j=i;j>0;j=(j-1)&i) {\n            if (j != i && j != 0)\n                chmax(dp[i], dp[j] + dp[i^j]);\n        }\n    }\n    cout << ret + __builtin_popcountll(state) - dp[state] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX 100010\n\nusing namespace std;\n\nint n;\nint n1, n2, n3;\nint ans;\n\nbool marc[MAX][4];\n\nvector<int> grafo[MAX][4];\n\nvoid DFS(int i, int bit, int& szComponent, int& qtdLeafs)\n{\n\tszComponent++;\n\tif(grafo[i][bit].size() == 1) qtdLeafs++;\n\n\tmarc[i][bit] = true;\n\n\tfor(int g = 0 ; g < grafo[i][bit].size() ; g++)\n\t{\n\t\tint prox = grafo[i][bit][g];\n\n\t\tif(marc[prox][bit]) continue;\n\n\t\tDFS(prox , bit , szComponent , qtdLeafs);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\n\tfor(int g = 0 ; g < n - 1 ; g++)\n\t{\n\t\tscanf(\"%d %d %d\",&n1,&n2,&n3);\n\n\t\tfor(int h = 0 ; h < 4 ; h++)\n\t\t{\n\t\t\tif( !(n3 & (1 << h)) ) continue;\n\n\t\t\tgrafo[ n1 ][h].push_back( n2 );\n\t\t\tgrafo[ n2 ][h].push_back( n1 );\n\t\t}\n\t}\n\n\tfor(int h = 0 ; h < 4 ; h++)\n\t{\n\t\tfor(int g = 1 ; g <= n ; g++)\n\t\t{\n\t\t\tif(marc[g][h]) continue;\n\n\t\t\tint qtdLeafs = 0;\n\t\t\tint szComponent = 0;\n\n\t\t\tDFS(g , h , szComponent , qtdLeafs);\n\n\t\t\tif(szComponent > 1) ans += (qtdLeafs + 1)/2;\n\t\t}\t\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\nconst int N = 20;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nint n, val[MAXN], cnt[N];\nint bin[N], bit[MAXN], dp[MAXN];\nvector<int> vec[N];\n\nvoid init() {\n\tread(n);\n\tfor (int i=1;i<n;++i) {\n\t\tint u, v, w;\n\t\tread(u); read(v); read(w);\n\t\tval[u] ^= w;\n\t\tval[v] ^= w;\n\t}\n}\n\nvoid solve() {\n\tfor (int i=0;i<n;++i) {\n\t\t++cnt[val[i]];\n\t}\n\tint ans = 0, S = 0;\n\tfor (int i=1;i<=15;++i) {\n\t\tans += cnt[i] / 2;\n\t\tS |= (cnt[i] & 1) << i;\n\t}\n\tbin[0] = bit[0] = 1;\n\tfor (int i=1;i<=16;++i) {\n\t\tbin[i] = bin[i-1] << 1;\n\t}\n\tfor (int i=1;i<bin[16];++i) {\n\t\tbit[i] = bit[i>>1] + (i & 1);\n\t\tvec[bit[i]].push_back(i);\n\t}\n\tmset(dp, 0x3f);\n\tdp[S] = 0;\n\tfor (int d=15;d>0;--d) {\n\t\tfor (int i=0;i<vec[d].size();++i) {\n\t\t\tint s = vec[d][i];\n\t\t\tif (dp[s] == INF) continue;\n\t\t\tfor (int j=1;j<16;++j) {\n\t\t\t\tif (!(s>>j) & 1) continue;\n\t\t\t\tcmin( dp[s ^ bin[j]], dp[s] + 1 );\n\t\t\t\tfor (int k=j+1;k<16;++k) {\n\t\t\t\t\tif (!(s>>k) & 1) continue;\n\t\t\t\t\tcmin( dp[s ^ bin[j] ^ bin[k] ^ bin[j^k]], dp[s] + 1 + ((s>>(j^k)) & 1) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans += dp[0];\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1e9+7;\nconst llint big=(llint)44e15;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nstatic int dp[65536]={0};\nvector<vector<pair<int,int>>>ko;\narray<int,16>use;\nint solve(int ter,int oya){\n\t//è¿ãæ¹åã®xor\n\tint kox=0;\n\tfor(auto it:ko[ter]){\n\t\tif(it.fir==oya){kox^=it.sec;continue;}\n\t\tkox^=solve(it.fir,ter);\n\t}\n\tif(oya!=-1){use[kox]++;}\n\treturn kox;\n}\nint main(void){\n\tint n,ans,i,j;\n\t//i åbitãæã£ã¦ãã\n\tfor(i=1;i<65536;i++){//xorã0ã«ãªããããªçµã¿åããããã¾ããã¨è¦ã¤ãã\n\t\tint bi=0;\n\t\tfor(j=1;j<16;j++){\n\t\t\tif(((1<<j)&i)!=0){bi^=j;}\n\t\t}\n\t\tif(bi==0){maxeq(dp[i],1);}\n\t\t\n\t\tfor(j=1;j<65536;){\n\t\t\tif(((65535-i)&j)!=0){j+=(65535-i)&j;continue;}\n\t\t\tmaxeq(dp[i],dp[j]+dp[i-j]);\n\t\t\tj++;\n\t\t}\n\t}\n\tcin>>n;ans=n-1;\n\tko.res(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint x,y,a;cin>>x>>y>>a;\n\t\tko[x].pub(mp(y,a));\n\t\tko[y].pub(mp(x,a));\n\t}\n\tsolve(0,-1);\n\tans-=use[0];use[0]=0;\n\tfor(i=1;i<16;i++){ans-=use[i]/2;use[i]%=2;}\n\tint bi=0;for(i=0;i<16;i++){if(use[i]==1){bi+=(1<<i);}}\n\t//cout<<bi<<\" \"<<dp[bi]<<endl;\n\tans-=dp[bi];\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n\nconst int MAXN = 100 * 1000 + 23, MXLA = 4 + 1;\n\n\n\n\nint n;\nvector<int> g[MXLA][MAXN];\nset<pii> s;\nbitset<MAXN> mark[MXLA];\n\n\nint dfs(int x, int v, int p = -1) {\n    mark[x][v] = true;\n    vector<int> vec;\n    for (auto u : g[x][v])\n        if (u != p)\n            vec.push_back(dfs(x, u, v)); \n    for (int i = 0; i + 1 < vec.size(); i += 2)\n        s.insert({min(vec[i], vec[i + 1]), max(vec[i], vec[i + 1])});\n    if (vec.size() & 1)\n        return vec.back();\n    return v;\n}\n\n\n\n\n\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL), cout.tie(NULL);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        for (int i = 0; i < MXLA; i++)\n            if (w & (1 << i))\n                g[i][v].push_back(u), g[i][u].push_back(v);\n    }\n    for (int i = 0; i < MXLA; i++)\n        for (int j = 0; j < n; j++)\n            if (!mark[i][j])\n                dfs(i, j);\n    cout << s.size();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define Kafuu signed\n#define Chino main\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\n#define maxn 100005\n#define inf 0x3f3f3f3f\n#define px putchar\n#define pn px('\\n')\n#define ps px(' ')\n#define pd puts(\"======================\")\n#define pj puts(\"++++++++++++++++++++++\")\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\ntemplate<typename T>\ninline T read(){\n\tT x=0;\n\tint y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nint a[maxn],tax[16],f[1<<16];\nint dfs(int s){\n\tif(~f[s])return f[s];\n\tint x;\n\tf[s]=inf;\n\tfor(register int i=1;i<=15;++i)\n\t\tfor(register int j=1;j<=15;++j){\n\t\t\tif(i==j||!(s>>i-1&1)||!(s>>j-1&1))continue;\n\t\t\tx=i^j;\n\t\t\tif(s>>x-1&1)f[s]=min(f[s],dfs(s^(1<<i-1)^(1<<j-1)^(1<<x-1))+2);\n\t\t\telse f[s]=min(f[s],dfs(s^(1<<i-1)^(1<<j-1)^(1<<x-1))+1);\n\t\t}\n\treturn f[s];\n}\nKafuu Chino(){\n\tint n=read(),x,y,z,state=0;\n\tlong long ans=0;\n\tfor(register int i=1;i<n;++i)x=read()+1,y=read()+1,z=read(),a[x]^=z,a[y]^=z;\n\tfor(register int i=1;i<=n;++i)++tax[a[i]];\n\tfor(register int i=1;i<=15;++i){\n\t\tans+=tax[i]>>1;\n\t\tif(tax[i]&1)state|=1<<i-1;\n\t}\n\tmemset(f,-1,sizeof f),f[0]=0;\n\tprintf(\"%lld\\n\",ans+dfs(state));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9,mod=1e9+7;\ntypedef long long ll;\nint read() {\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n\treturn x*f;\n}\nusing namespace std;\nint val[1000001],f[1000001],cnt[20],vis[1000001],js,x,y,z,ans,n,len=(1<<15);\nint main() {\n\tn=read(),len=(1<<15);\n\tfor(int i=1; i<n; i++)\n\t\tx=read(),y=read(),z=read(),val[x]^=z,val[y]^=z;\n\tfor(int i=0; i<n; i++)\n\t\tcnt[val[i]]++;\n\tfor(int i=1; i<=15; i++)\n\t\tans+=cnt[i]/2,js|=(cnt[i]&1)<<(i-1);\n\tfor(int i=1; i<len; i++)\n\t\tf[i]=f[i>>1]+(i&1);\n\tfor(int i=1; i<len; i++)\n\t\tf[i]--;\n\tfor(int i=1; i<len; i++)\n\t\tfor(int j=0; j<15; j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tvis[i]^=(j+1);\n\tfor(int i=1; i<len; i++) {\n\t\tif(vis[i]) continue;\n\t\tfor(int k=(i-1)&i; k; k=(k-1)&i)\n\t\t\tif(!vis[k])\n\t\t\t\tf[i]=min(f[i],f[k]+f[i^k]);\n\t}\n\tprintf(\"%d\",ans+f[js]);\n\treturn 0;\n}//da"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nint A[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        \n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        A[u]^=to.se;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\n\nconst int inf=1e9+10;\nconst int maxn=2e5+10;\n\nint dp[1<<20],n,f[1<<20],vl[maxn],cnt[20];\nvector <int> v;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint u,v,c;\n\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\tvl[u]^=c; vl[v]^=c;\n\t}\n\tfor(int i=0;i<16;i++) cnt[i]=0;\n\tfor(int i=0;i<n;i++){\n\t//\tcout<<vl[i]<<endl; \n\t\tcnt[vl[i]]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<16;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]%2==1){\n\t\t//\tcout<<i<<endl;\n\t\t\tv.pb(i);\n\t\t}\n\t}\n//\tcout<<mask<<endl;\n\tfor(int msk=0;msk<(1<<(int)v.size());msk++){\n\t\tint val=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(msk&(1<<i)){\n\t\t\t\tval^=v[i];\n\t\t\t}\n\t\t}\n\t//\tif(val==0) cout<<msk<<endl;\n\t\tif(val==0) f[msk]=1;\n\t}\n\tfor(int msk=0;msk<(1<<(int)v.size());msk++){\n\t\tint u=msk;\n\t\twhile(u>0){\n\t\t\tif(f[u]){\n\t\t\t\tdp[msk]=max(dp[msk],dp[u^msk]+1);\n\t\t\t}\n\t\t\tu=(u-1)&msk;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+(int)v.size()-dp[(1<<(int)v.size())-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[100020];\nint n, x, y, z;\nint w[100020];\nint c[16];\nint f[65537];\nint g[65537];\nint ans, mask;\nint dfs(int x, int y) {\n\tint re = w[x];\n\tfor (int i: a[x]) {\n\t\tif (i != y) {\n\t\t\tre ^= dfs(i, x);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t\tw[x] ^= z;\n\t\tw[y] ^= z;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tc[w[i]]++;\n\t}\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += c[i] / 2;\n\t\tc[i] %= 2;\n\t\tmask |= c[i] << i;\n\t}\n\tfor (int i = 1; i < 1 << 16; i++) {\n\t\tint v = 0, c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tv ^= j;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif (v == 0) {\n\t\t\tf[i] = c - 1;\n\t\t} else {\n\t\t\tf[i] = -1;\n\t\t}\n\t\tfor (int j = i; ; j = (j - 1) & i) {\n\t\t\tif (f[j] >= 0 && f[i ^ j] >= 0) {\n\t\t\t\tf[i] = min(f[i], f[j] + f[i ^ j]);\n\t\t\t}\n\t\t\tif (j == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + f[mask]);\n//\tdfs(0, -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nvector<int> two[MAX];\nint A[MAX],sum[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        sum[u]^=sum[to.fi];\n        A[u]^=sum[to.fi];\n    }\n    sum[u]^=A[u];\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[sum[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/****** BISMILLAH HIR RAHMANIR RAHIM ******/\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<string,string> mss;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef map <int, vector<string> > mvis;\ntypedef map <string, vector<int> > mvsi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define INF 2000000000\n#define pb push_back\n#define MAX 100002\n#define debug cout<<\"A\"<<\"\\n\"\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=b; i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define ClearQ(x); while(!x.empty()) x.pop()\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n, u, v, k, d[MAX], cnt[20];\nvi rest;\nint dp[1<<17];\n\nint go(int mask)\n{\n\t// prnt(mask);\n\tif(mask&1) mask^=1;\n\tif(mask==0) return 0;\n\tif(dp[mask]!=-1) return dp[mask];\n\n\tint ret=16;\n\n\tfor(int i=1; i<=16; i++)\n\t{\n\t\tfor(int j=1; j<=16; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif((mask&(1<<i)) && (mask&(1<<j)))\n\t\t\t{\n\t\t\t\tint nxtmask=mask^(1<<i);\n\t\t\t\tnxtmask^=(1<<j);\n\n\t\t\t\tint add=1;\n\n\t\t\t\tif(mask&(1<<(i^j)))\n\t\t\t\t{\n\t\t\t\t\tnxtmask^=(1<<(i^j));\n\t\t\t\t\tadd++;\n\t\t\t\t}\n\n\t\t\t\tret=min(ret,add+go(nxtmask));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[mask]=ret;\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    scanf(\"%d\", &n);\n\n    FOR(i,0,n-1)\n    {\n    \tscanf(\"%d%d%d\", &u, &v, &k);\n\n    \td[u]^=k;\n    \td[v]^=k;\n    }\n\n    FOR(i,0,n)\n    {\n    \tif(d[i]) \n    \t{\n    \t\t// prnt(d[i]);\n    \t\tcnt[d[i]]++;\n    \t}\n    }\n\n    int ans=0, mask=0;\n\n    FOR(i,1,17)\n    {\n    \tans+=cnt[i]/2;\n    \tif(cnt[i]%2) rest.pb(i), mask|=(1<<i);\n    }\n\n    // debug;\n    // VecPrnt(rest);\n    // prnt(mask);\n\n    // prnt(ans);\n    ms(dp,-1);\n    prnt(ans+go(mask));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\nconst int N=5e5+100;\nll val[N];\nll t[20];\nll dp[(1<<16)];\nvector <int> f(ll x){\n    vector <int> bit;\n    while(x){\n        bit.pb(x%2);\n        x/=2;\n    }\n    while(bit.size()<16){\n        bit.pb(0);\n    }\n    return bit;\n}\nint32_t main(){\n    ll n;\n    cin >> n;\n    for (int i=0;i<n-1;i++){\n        ll u,v,w;\n        cin >> u >> v >> w;\n        u++;\n        v++;\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n    ll ans=0;\n    for (int i=1;i<=n;i++){\n        t[val[i]]++;\n     ///   cout << i << \" \" << val[i] << endl;\n        if (t[val[i]]==2 && val[i]!=0) ans++;\n        t[val[i]]%=2;\n    }\n    t[0]=0;\n    memset(dp,69,sizeof dp);\n    ll cnt1=0;\n    for (int i=0;i<=15;i++){\n        cnt1+=(t[i] << i);\n     //   cout << t[i] << endl;\n    }\n    dp[0]=0;\n    vector <pii> a;\n    for (int i=0;i<(1<<16);i++){\n        vector <int> bit=f(i);\n       ll cnt=0;\n        if (bit[0]) continue;\n        for (int j=0;j<16;j++){\n            cnt+=bit[j];\n        }\n        a.pb({cnt,i});\n    }\n  //  cout << cnt1 << endl;\n    sort(a.begin(),a.end());\n    for (int i=0;i<a.size();i++){\n        ll x=a[i].S;\n        vector <int> bit=f(x);\n        for (int j=0;j<16;j++){\n            if (bit[j]) dp[x]=min(dp[x],dp[(x^(1<<j))]+1);\n            for (int k=j+1;k<16;k++){\n                if (!bit[j] || !bit[k]) continue;\n                if (bit[(j^k)]) dp[x]=min(dp[x],2+dp[(x^((1<<j) + (1<<k) + (1<<(j^k))))]);\n                else dp[x]=min(dp[x],1+dp[(x^((1<<j) + (1<<k) + (1<<(j^k))))]);\n               // if (x==14){\n                 //   cout << dp[x] << \" \" << j << \" \" << k << \" \" << (j^k) << \" \" << 1+dp[(x^((1<<j) + (1<<k) + (1<<(j^k))))] << endl;\n                //}\n            }\n        }\n\n    }\n    cout << dp[cnt1]+ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=16;\nint n,a[M];\nvvp g;\n\nint dfs(int v,int pre){\n\tint res=0;\n\tfor(auto p:g[v]){\n\t\tint u=p.first,c=p.second;\n\t\tif(pre!=u){\n\t\t\tint t=c^dfs(u,v);\n\t\t\tif(t) a[t]++;\n\t\t\tres^=t;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvp(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tg[u].push_back({v,c});\n\t\tg[v].push_back({u,c});\n\t}\n\tdfs(0,-1);\n\tint t=0;\n\tvi b,c,dp;\n\tfor(int i=1;i<M;i++){\n\t\tt+=a[i]/2;\n\t\tif(a[i]%2==1) b.push_back(i);\n\t}\n\tn=b.size();\n\tint N=1<<n;\n\tc=dp=vi(N);\n\tfor(int i=0;i<N;i++) for(int j=0;j<n;j++) if(i&1<<j) c[i]^=b[j];\n\tfor(int i=1;i<N;i++){\n\t\tint j=i;\n\t\tdo{\n\t\t\tdp[j]=max(dp[j],dp[i-j]+(c[j]?0:1));\n\t\t\tj=(j-1)&i;\n\t\t}while(j);\n\t}\n\tcout<<t+n-dp[N-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 1e5 + 5, M = 16;\n\nint A[N], C[M + 1], DP[1 << M], XO[1 << M];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tfor (int mask = 0; mask < (1 << M); mask++) XO[mask] = XO[mask - (mask & -mask)] ^ (__builtin_ctz(mask) + 1);\n\tfor (int mask = 0; mask < (1 << M); mask++) for (int sub = mask; sub > 0; sub = (sub - 1) & mask) if (XO[sub] == 0) DP[mask] = DP[mask ^ sub] + 1;\n\n\tint n; cin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u, x; cin >> v >> u >> x;\n\t\tA[v] ^= x, A[u] ^= x;\n\t}\n\tfor (int i = 0; i < n; i++) C[A[i]]++;\n\tint x = 0, cnt = C[0];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcnt += C[i] >> 1;\n\t\tif (C[i] & 1) x ^= (1 << (i - 1));\n\t}\n\tcout << n - (cnt + DP[x]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n\n#define Grt ch = getchar()\n#define DeBug(x) std::cout << #x << '=' << x << std::endl\n\nconst int MaxN = 1e5 + 10, MaxM = 1 << 15 + 10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft == fs && (ft = (fs = buf) + fread(buf, 1, 1<<15, stdin), ft == fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx = 0;\n\t\tT f = 1, Grt;\n\t\twhile (!isdigit(ch) && ch ^ '-') Grt;\n\t\tif (ch == '-') f = -1, Grt;\n\t\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), Grt;\n\t\tx *= f;\n\t}\n\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe = Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe = Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++ = 48;\n\t\tif (x < 0) *fe++ = '-', x = -x;\n\t\tT num = 0, ch[20];\n\t\twhile (x) ch[++ num] = x % 10 + 48, x /= 10;\n\t\twhile (num) *fe++ = ch[num --];\n\t\t*fe++ = str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a < b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a > b ? a : b; }\n\nint v[MaxN], f[MaxM], cnt[20], xr[MaxM];\nint main()\n{\n\tint n, ans = 0, state = 0; read(n);\n\tfor (int i = 1, x, y, z; i < n; ++ i) read(x, y, z), v[x] ^= z, v[y] ^= z;\n\tfor (int i = 0; i < n; ++ i) ++ cnt[v[i]];\n\tfor (int i = 1; i <= 15; ++ i)\n\t{\n\t\tans += cnt[i] >> 1;\n\t\tstate |= (cnt[i] & 1) << (i - 1);\n\t}\n\tfor (int i = 1; i < (1 << 15); ++ i) f[i] = f[i >> 1] + (i & 1);\n\tfor (int i = 1; i < (1 << 15); ++ i) -- f[i];\n\tfor (int i = 1; i < (1 << 15); ++ i)\n\t\tfor (int j = 1; j <= 15; ++ j)\n\t\t\tif ((i >> j) & 1) xr[i] ^= j;\n\tfor (int s = 1; s < (1 << 15); ++ s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t = (s - 1) & s; t; t = (t - 1) & s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t] + f[t ^ s]);\n\t}\n\twrite(ans + f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\nconst long long MAXN = 2e5 + 21, LG = 20, inf = 1e18, mod = 998244353;\n\nint n;\nint cnt[MAXN], v[MAXN];\nint dp[MAXN];\nlong long ans, st;\n\nint dfs(int root) {\n\tif(root == 0) \n        return 0;\n\tif(dp[root] ^ -1) \n        return dp[root];\n\n\tdp[root] = inf;\n\t\n    for(int i = 0; i < 16; i++)\n\t\tif(root>>i&1) {\n\t\t\tfor(int j = 0; j < 16; j++)\n\t\t\t\tif(root>>j&1) {\n\t\t\t\t\tint x = j ^ i;\n\t\t\t\t\tint nxt = root ^ (1 << j) ^ (1 << i) ^ (1 << x);\n\t\t\t\t\tif(__builtin_popcount(nxt) < __builtin_popcount(root))\n\t\t\t\t\t    dp[root] = min(dp[root], dfs(nxt) + 1 + ((root & (1 << x)) == (1 << x)));\n\t\t\t\t}\n\t\t}\n\treturn dp[root];\n}\n\nint main(){\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n\t\tv[x] ^= z;\n\t\tv[y] ^= z; \n\t}\n\t\n    memset(dp, -1, sizeof dp);\n\n\tfor(int i = 0; i < n; i++)\n        if(v[i]) \n            cnt[v[i]]++;\n\t\n\tfor(int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tst |= ((cnt[i] & 1) << i);\n\t}\n\t\n    ans += dfs(st);\n\tcout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nint N;\nint X[1<<16], dp[1<<16];\nvector<int> to[100050], ve[100050];\nint st[100050];\n\nint dfs(int u, int p = -1) {\n  int res = 0;\n  st[u] = 0;\n  for (int zi = 0; zi < (int)to[u].size(); ++zi) {\n    const int v = to[u][zi], a = ve[u][zi];\n    if (v != p) {\n      res += dfs(v, u);\n      int stv = st[v];\n      if (X[st[v]] != a) {\n        int add = X[st[v]] ^ a;\n        if (stv & (1 << add)) {\n          stv ^= 1 << add;\n          ++res;\n        } else {\n          stv |= 1 << add;\n        }\n      }\n      res += __builtin_popcount(st[u] & stv);\n      st[u] ^= stv;\n    }\n  }\n  return res;\n}\n\nint main() {\n  for (int i = 0; i < (1<<16); ++i) {\n    X[i] = 0;\n    for (int j = 0; j < 16; ++j) {\n      if (i & (1 << j)) {\n        X[i] ^= j;\n      }\n    }\n  }\n\n  int N = in();\n  for (int i = 0; i < N - 1; ++i) {\n    int x = in();\n    int y = in();\n    int a = in();\n    to[x].push_back(y); ve[x].push_back(a);\n    to[y].push_back(x); ve[y].push_back(a);\n  }\n\n  int res = dfs(0);\n  vector<int> ps(1<<16);\n  for (int i = 0; i < (1<<16); ++i) {\n    ps[i] = i;\n  }\n  sort(ps.begin(), ps.end(), [] (const int a, const int b) {\n    return __builtin_popcount(a) < __builtin_popcount(b);\n  });\n\n  for (int i : ps) {\n    dp[i] = __builtin_popcount(i);\n    for (int j = 1; j < 16; ++j) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n      for (int k = j+1; k < 16; ++k) {\n        if (!(i & (1 << k))) {\n          continue;\n        }\n        int cost = 1;\n        if (i & (1 << (j ^ k))) {\n          ++cost;\n        }\n        chmin(dp[i], dp[i ^ (1<<j) ^ (1<<k) ^ (1<<(j^k))] + cost);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", res + dp[st[0]]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nvector<int> two[MAX];\nint A[MAX],sum[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        A[to.fi]^=to.se;\n        DFS(to.fi,u);\n        sum[u]^=sum[to.fi];\n    }\n    A[u]^=sum[u];\n    sum[u]=A[u];\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    //for(int i=1;i<N;i++) cout<<A[i]<<endl;\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=100005;\nconst int p=1e9+7;\nint n,a[N];\nint tot[16];\n\ntemplate<class T> void read(T &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nvoid Add(int &x,int y){\n\tx+=y;\n\twhile(x>=p) x-=p;\n}\n\nint f[1<<16],sum[1<<16];\nint main(){\n\tread(n);\n\tint x,y,w;\n\tfr(i,2,n){\n\t\tread(x);read(y);read(w);\n\t\tx++;y++;\n\t\ta[x]^=w;a[y]^=w;\n\t}\n\tfr(i,1,n) tot[a[i]]++;\n\tint ans=0,all=0;\n\tfr(i,1,15) ans+=tot[i]/2,all^=(tot[i]&1)<<i;\n\tfr(i,0,all)\n\t if ((i&all)==i){\n\t \tif ((i&(-i))==i){ f[i]=1;continue; }\n\t \tsum[i]=0;\n\t \tfr(j,0,15) if (i&(1<<j)) sum[i]^=j,f[i]++;\n\t \tif (sum[i]) continue;\n\t \tf[i]--;\n\t \tfor(int j=i;j;j=(j-1)&i)\n\t \t if (sum[j]==0) f[i]=min(f[i],f[j]+f[i^j]);\n\t }\n\tcout<<ans+f[all]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst int M = 20;\n\nint n, m;\nint a[N];\nint ans;\nint cnt[M];\nint dp[1 << M];\nint dp2[1 << M];\nvector<int> v;\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v, x;\n\t\tcin >> v >> u >> x;\n\t\ta[u] = a[u] ^ x;\n\t\ta[v] = a[v] ^ x;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcnt[a[i]]++;\n\t}\n\tans = cnt[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (cnt[a[i]] % 2)\n\t\t{\n\t\t\tv.push_back(a[i]);\n\t\t}\n\t\tans += cnt[a[i]] / 2;\n\t}\n\tm = v.size();\n\tfor (int i = 0; i < (1 << m); i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif ((i >> j) % 2 == 1)\n\t\t\t{\n\t\t\t\tdp2[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int mask = 1; mask < (1 << m); mask++)\n\t{\n\t\tif (dp2[mask] != 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdp[mask] = 1;\n\t\tint mask2 = mask;\n\t\twhile (mask2 > 0)\n\t\t{\n\t\t\tmask2 = (mask2 - 1) & mask;\n\t\t\tif (!dp2[mask2])\n\t\t\t{\n\t\t\t\tdp[mask] = max(dp[mask], dp[mask2] + dp[mask ^ mask2]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << n - ans - dp[(1 << m) - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 65540\nusing namespace std;\nint n,s[N],S,ans,f[M],inf,sum[20];\nint dfs(int S)\n{\n  if(!S)return 0; \n  if(f[S]<inf)return f[S];\n  for(int i=0;i<16;i++)if((S>>i)&1)\n    for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1)\n    {\n      int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n      if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n      else f[S]=min(f[S],dfs(x)+1);\n    }\n  return f[S];\n}\n\nint main()\n{\n  int a,b,c;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d%d\",&a,&b,&c),s[a]^=c,s[b]^=c;\n  for(int i=0;i<n;i++)sum[s[i]]++;\n  for(int i=1;i<16;i++)\n    ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n  memset(f,127,sizeof(f));inf=f[0];\n  printf(\"%d\\n\",ans+dfs(S));\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\ntypedef long long ll;\n#define inc(i) (++ (i))\n#define dec(i) (-- (i))\n#define Rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i <= i##Limit ; inc(i))\n#define rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i >= i##Limit ; dec(i))\n#define Eep(i , u , v) for(int i = Head[u] , v = Node[i] ; i ; v = Node[i = Next[i]])\nusing namespace std;\n\nconst int N = 100000 + 7 , M = 16;\nint n , tot[M] , Dp[(1 << 16) + 7] , W[N] , Sum[N];\n\nint main() {\n\tint u , v , w , S = 0 , Ret = 0;\n\tscanf(\"%d\" , &n);\n\tRep(i , 2 , n) scanf(\"%d%d%d\" , &u , &v , &w) , W[u + 1] ^= w , W[v + 1] ^= w;\n\tRep(i , 1 , n) inc(tot[W[i]]);\n\tRep(i , 0 , 15) Ret += tot[i] / 2 , S |= (tot[i] & 1) << i;\n\tRep(i , 0 , (1 << 16) - 1) Dp[i] = Dp[i >> 1] + (i & 1);\n\tRep(i , 0 , (1 << 16) - 1) Dp[i] -= 1;\n\tRep(i , 0 , (1 << 16) - 1)\n\t\tRep(j , 0 , 15) if((i >> j) & 1) Sum[i] ^= j;\n\tRep(i , 0 , (1 << 16) - 1) if(!Sum[i]) {\n\t\tfor(int k = i & (i - 1) ; k ; k = (k - 1) & i)\n\t\t\tif(!Sum[k]) Dp[i] = min(Dp[i] , Dp[i ^ k] + Dp[k]);\n\t}\n\tprintf(\"%d\" , Ret + Dp[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 1e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[32], p[20], dp[1 << 16], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << 16; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100000;\n\nint f[MX];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\tfor (int i = 1, u, v, a; i < n; i++) {\n\t\tignore = scanf(\"%d %d %d\", &u, &v, &a);\n\t\tf[u] ^= a;\n\t\tf[v] ^= a;\n\t}\n\t\n\tf[0] = 0;\n\tfor (int i = 1; i < n; i++) f[0] ^= f[i];\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) if (f[i] != 0) ans++;\n\t\n\tprintf(\"%d\\n\", (ans + 1) / 2);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nint val[N], cnt[16];\nint dis[1 << 16];\n\nqueue<int> q;\n\nvoid relax(int o, int d){\n\tif(dis[o] > d) dis[o] = d, q.push(o);\n}\n\nint SPFA(int S){\n\tmemset(dis, 0x3f, sizeof dis);\n\tdis[S] = 0;\n\tq.push(S);\n\twhile(!q.empty()){\n\t\tint o = q.front(); q.pop();\n\t\tif(!o) return dis[o];\n\t\tFor(i, 0, 14) if(o & (1 << i)) relax(o ^ (1 << i), dis[o] + 1);\n\t\tFor(i, 0, 14) if(o & (1 << i)) For(j, i + 1, 14) if(o & (1 << j))\n\t\t\tFor(k, 1, 15){\n\t\t\t\tint u = (i + 1) ^ k, v = (j + 1) ^ k;\n\t\t\t\tint st = o ^ (1 << i) ^ (1 << j), w = dis[o] + 1;\n\t\t\t\t\n\t\t\t\tif(u){\n\t\t\t\t\tif(o & (1 << (u - 1))) ++w;\n\t\t\t\t\tst ^= 1 << (u - 1);\n\t\t\t\t}\n\t\t\t\tif(v){\n\t\t\t\t\tif(o & (1 << (v - 1))) ++w;\n\t\t\t\t\tst ^= 1 << (v - 1);\n\t\t\t\t}\n\n\t\t\t\trelax(st, w);\n\t\t\t}\n\t}\n\tassert(false);\n}\n\nint main(){\n\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\t++u, ++v;\n\t\tval[u] ^= w, val[v] ^= w;\n\t}\n\tFor(i, 2, n) cnt[val[i]]++;\n\n\tint ans = 0;\n\tFor(i, 1, 15) ans += cnt[i] / 2, cnt[i] &= 1;\n\t\n\tint st = 0;\n\tFor(i, 1, 15) st |= cnt[i] << (i - 1);\n\tprintf(\"%d\\n\", ans + SPFA(st));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=100005;\nint val[N],cnt[N],sxr[1<<17];\nint a[17];\nint dp[1<<17];\ninline int read(){\n\tint x=0;char e=getchar();\n\tfor (;e<'0'||e>'9';e=getchar());\n\tfor (;e>='0'&&e<='9';e=getchar()) x=(x<<1)+(x<<3)+(e^48);\n\treturn x;\n}\ninline int Min(int a,int b){\n\treturn a<b?a:b;\n}\nint main (){\n    int n=read();\n\tfor (int i=1;i<n;i++){\n\t\tint u=read()+1,v=read()+1,w=read();\n\t\tval[u]^=w,val[v]^=w;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tint ans=0,to=0;\n\tfor (int i=0;i<16;i++){\n\t\tans+=(cnt[i]>>1);\n\t\tif (cnt[i]&1) to|=(1<<i);\n\t}\n\tfor (int i=0;i<(1<<16);i++)\n\t\tfor (int j=0;j<16;j++)\n\t\t\tif (i&(1<<j)) sxr[i]^=j;\n\tfor(int i=0;i<(1<<16);i++) dp[i]=dp[i>>1]+(i&1);\n    for(int i=0;i<(1<<16);i++) dp[i]--;\n\tfor (int i=0;i<(1<<16);i++){\n        if (sxr[i]!=0) continue;\n        for (int k=(i-1)&i;k;k=(k-1)&i)\n            if (!sxr[k]) dp[i]=Min(dp[i],dp[k]+dp[i^k]);\n\t}\n\tprintf (\"%d\",dp[to]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,x,y,z,ans,f[1<<15],a[100100],c[20];\nvector<int>o;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tscanf(\"%d\", &n);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z,a[y]^=z;\n\t}\n\tfor(int i=0;i<n;++i)++c[a[i]];\n\tfor(int i=1;i<=15;++i){\n\t\tans+=c[i]>>1;\n\t\tif(c[i]&1)o.push_back(i);\n\t}\n\tf[0]=0;\n\tfor(int i=1;i<(1<<o.size());++i){\n\t\tint x=0,k=0,j=0;\n\t\tfor(;j<o.size();++j)\n\t\t\tif(i&(1<<j))x^=o[j],++k;\n\t\tf[i]=x? 19260817:k-1;\n\t\tfor(j=i-(i&-i);j;j=(i-(i&-i))&(j-1))\n\t\t\tf[i]=min(f[i],f[j]+f[j^i]);\n\t}\n\tprintf(\"%d\\n\",f[(1<<o.size())-1]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nbool cmp(int A,int B){\n\tint C1,C2;\n\tC1=C2=0;\n\trep(i,16)\n\t\tif(i)\n\t\tif((A>>i)&1) C1++;\n\trep(i,16)\n\t\tif(i)\n\t\tif((B>>i)&1) C2++;\n\t\treturn C1<C2;\n}\nint main(){\n\tfastio;\n\tint n;\n\tcin>>n;\n\tint cnt[16]={0},x[100000]={0};\n\trep(i,n-1){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;x[a]^= c,x[b]^=c;\n\t}\n\trep(i,n)\n\t\tcnt[x[i]]++;\n\tint res=0;\n\trep(i,16)\n\tif(i)\n\tres+=cnt[i]/2,cnt[i]=cnt[i]%2;\n\tint dp[1<<16];\n\tint  Nmask=0;\n\trep(i,16)\n\t\tif(i)\n\t\tNmask|=cnt[i]<<i;\n\t\n\tmemset(dp,63,sizeof(dp));\n\t\n\tdp[Nmask]=0;\n\tvector<int> M;\n\trep(i,1<<16){\n\t\tM.PB(i);\n\t}\n\tsort(ALL(M),cmp);\n\trl(Cnt,(1<<16)-1,0){\n\t\tint i=M[Cnt];\n\t\tint cnt=0;\n\t\trep(j,16)\n\t\t\tif(j)\n\t\t\tif(i&(1<<j)) cnt++;\n\t\tif(cnt>=2){\n\t\t\trep(j,16){\n\t\t\t\tif(j)\n\t\t\t\tif(i&(1<<j))\n\t\t\t\trep(k,16){\n\t\t\t\t\tif(k)\n\t\t\t\t\tif(k!=j&&(i&(1<<k))){\n\t\t\t\t\t\tint New=(k^j);\n\t\t\t\t\t\tint nmask=(i-(1<<j)-(1<<k));\n\t\t\t\t\t\tif(nmask&(1<<New)){\n\t\t\t\t\t\t\tdp[nmask-(1<<New)]=min(dp[nmask-(1<<New)],dp[i]+2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[nmask+(1<<New)]=min(dp[nmask+(1<<New)],dp[i]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res+dp[0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nconst int N = 1e5 + 7;\n\ninline int read() {\n\tchar ch = getchar(); int r = 0, w = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n\twhile(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n\treturn r * w;\n}\n\nint n;\nint tot, w[N], cnt[32], p[20], dp[1 << 16], ans;\n\ninline int calc(int x) {\n\tint now = 0, res = 0, sz = 0;\n\twhile(x) {\n\t\tif(x & 1) res ^= p[now], sz++;\n\t\tx >>= 1;\n\t\tnow++;\n\t}\n\treturn res ? sz : sz - 1;\n}\n\nint main() {\n\tn = read();\n\tfor(register int i = 1; i < n; i++) {\n\t\tint x = read() + 1, y = read() + 1, z = read();\n\t\tw[x] ^= z, w[y] ^= z;\n\t}\n\tfor(register int i = 1; i <= n; i++)\n\t\tcnt[w[i]]++;\n\tfor(register int i = 1; i <= 31; i++) {\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1)\n\t\t\tp[tot++] = i;\n\t}\n\tfor(register int S = 1; S < 1 << tot; S++) {\n\t\tdp[S] = calc(S);\n\t\tfor(register int T = S; T; T = (T - 1) & S) {\n\t\t\tdp[S] = std::min(dp[S], dp[T] + dp[S ^ T]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + dp[(1 << (tot - 1)) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2e6+1000;\nint n,a[N],f[N],cnt[N],as,st,S,x[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();rp(i,1,n-1){ri t1=read()+1,t2=read()+1,z=read();a[t1]^=z;a[t2]^=z;}rp(i,1,n)++cnt[a[i]];\n\trp(i,1,15)as+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tS=(1<<15)-1;\n\trp(i,1,S)f[i]=f[i>>1]+(i&1);\n\trp(i,1,S)--f[i];rp(i,1,S)rp(j,0,14)if((i>>j)&1)x[i]^=(j+1);\n\trp(i,1,S)if(!x[i])for(ri j=(i-1)&i;j;j=(j-1)&i)if(!x[j])f[i]=min(f[i],f[j]+f[i^j]);\n\tprintf(\"%d\",as+f[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][20][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 20) return 1e9;\n    if(tidx == 4 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n \nint dp1(int idx, int mask);\n \nint cc2[16][1 << 16][16];\nint dp2(int idx, int mask, int rem) {\n    int &ret = cc2[idx][mask][rem];\n    if(ret != -1) return ret;\n    if(rem == 0) return ret = dp1(idx - 1, mask);\n \n    ret = 1e9;\n    for(int i = 1; i < idx; i++) {\n        if((rem | i) == rem) {\n            if(mask & (1 << i)) {\n                ret = min(ret, 1 + dp2(idx, mask ^ (1 << i), rem - i));\n            }\n            else ret = min(ret, dp2(idx, mask ^ (1 << i), rem - i));\n        }\n    }\n    return ret;\n}\n \nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n \n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tmp % 2 == 0) return ret = tmp / 2 + dp1(idx - 1, mask);\n    else return ret = tmp / 2 + dp2(idx, mask, idx);\n}\n \nint main() {\n    scanf(\"%d\", &N);\n \n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n \n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n \n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n \n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n \n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n \n    memset(cc1, -1, sizeof(cc1));\n    memset(cc2, -1, sizeof(cc2));\n    printf(\"%d\", dp1(15, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nint solve(int n, const vector<int> & x, const vector<int> & y, const vector<int> & a) {\n    constexpr int MAX_A = 0xf;\n    assert (*max_element(ALL(a)) <= MAX_A);\n\n    // make the adjacent list\n    vector<vector<int> > g(n);\n    REP (i, n - 1) {\n        g[x[i]].push_back(y[i]);\n        g[y[i]].push_back(x[i]);\n    }\n\n    // fix a root\n    vector<int> parent(n, -1);\n    function<void (int)> go = [&](int i) {\n        for (int j : g[i]) if (j != parent[i]) {\n            parent[j] = i;\n            go(j);\n        }\n    };\n    constexpr int root = 0;\n    go(root);\n\n    // move labels to nodes\n    vector<int> b(n, -1);\n    REP (i, n - 1) {\n        if (parent[x[i]] == y[i]) {\n            b[x[i]] = a[i];\n        } else if (x[i] == parent[y[i]]) {\n            b[y[i]] = a[i];\n        } else {\n            assert (false);\n        }\n    }\n\n    // tree dp\n    int removed = 0;\n    function<array<bool, MAX_A + 1> (int)> dp = [&](int i) {\n        array<bool, MAX_A + 1> cnt1 = {};\n        for (int j : g[i]) if (j != parent[i]) {\n            array<bool, MAX_A + 1> cnt2 = dp(j);\n            REP (x, MAX_A + 1) if (cnt2[x]) {\n                removed += cnt1[x];\n                cnt1[x] ^= 1;\n            }\n        }\n        int k = b[i];\n        if (k != -1) {\n            REP (x, MAX_A + 1) if (cnt1[x]) {\n                k ^= x;\n            }\n            if (k != 0) {\n                removed += cnt1[k];\n                cnt1[k] ^= 1;\n            }\n        }\n        return cnt1;\n    };\n    array<bool, MAX_A + 1> cnt = dp(root);\n\n    // finialize\n    REP (x, MAX_A + 1) if (cnt[x]) {\n        REP (y, x) if (cnt[y]) {\n            if (cnt[x ^ y]) {\n                cnt[x] = false;\n                cnt[y] = false;\n                cnt[x ^ y] = false;\n                removed += 2;\n                break;\n            }\n        }\n    }\n    return removed + accumulate(ALL(cnt), 0);\n}\n\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> x(n - 1), y(n - 1), a(n - 1);\n    REP (i, n - 1) {\n        cin >> x[i] >> y[i] >> a[i];\n    }\n\n    // solve\n    int answer = solve(n, x, y, a);\n\n    // output\n    cout << answer << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nvector<ll> dickstra(int from) {\n  const ll infl = 4e18;\n  const int n = 1 << 16;\n\n  vector<ll> dist(n, infl);\n  using Elem = pair<ll, int>;\n  priority_queue<Elem, vector<Elem>, greater<Elem>> o;\n  dist[from] = 0;\n  o.emplace(dist[from], from);\n  while (!o.empty()) {\n    int u;\n    ll cdist;\n    tie(cdist, u) = o.top();\n    o.pop();\n    //cerr << bitset<16>(u) << ' ' << cdist << '\\n';\n    if (cdist != dist[u])\n      continue;\n    for (int x = 0; x < 16; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        for (int z = 0; z < y; ++z) {\n          if (!(u & (1 << y)) || !(u & (1 << z))) {\n            continue;\n          }\n          int v = u ^ (1 << y) ^ (1 << z);\n          int yy = x ^ y, zz = x ^ z;\n          int w = 1;\n          if (v & (1 << yy)) {\n            ++w;\n          }\n          if (v & (1 << zz)) {\n            ++w;\n          }\n          v ^= (1 << yy) ^ (1 << zz);\n          if (v & 1) {\n            v ^= 1;\n          }\n          assert(v < n);\n\n          ll ndist = dist[u] + w;\n          if (ndist >= dist[v])\n            continue;\n          dist[v] = ndist;\n          o.emplace(dist[v], v);\n\n        }\n      }\n    }\n  }\n  return dist;\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"f.in\", \"r\", stdin));\n#endif\n  int n;\n  cin >> n;\n  vector<int> xx(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    xx[u] ^= w;\n    xx[v] ^= w;\n  }\n  int mask = 0;\n  int res = 0;\n  for (int x : xx) {\n    if (x == 0) {\n      continue;\n    }\n    if (mask & (1 << x)) {\n      ++res;\n    }\n    mask ^= 1 << x;\n  }\n  //cerr << bitset<16>(mask) << '\\n';\n  res += dickstra(mask)[0];\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mid (l+r)/2\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e5+3;\nconst int N=2e5+7;\nint read()\n{\n    int f=1,x=0;\n    char ss=getchar();\n    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}\n    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}\n    return f*x;\n}\nvoid print(int x)\n{\n    if(x<0){putchar('-');x=-x;}\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nint n,m,k;\nint a[N],f[N],cnt[N],xo[N],ans=0,sit,up;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\ta[u]^=w;a[v]^=w;\n\t}\n\tup=(1<<15)-1;\n\tfor(int i=0;i<n;++i)\n\t\tcnt[a[i]]++;\n\tfor(int i=1;i<=15;++i)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tsit|=((cnt[i]&1)<<(i-1));\n\t}\n\tfor(int i=1;i<up;++i)\n\t\tfor(int j=0;j<15;++j)\n\t\t\tif((i>>j)&1) xo[i]^=(j+1); \n\tfor(int i=1;i<up;++i)\n\t\tf[i]=f[i>>1]+(i&1);//ç»è®¡1çä¸ªæ°ï¼fçä¸çï¼\n\tfor(int i=1;i<up;++i)\n\t\tf[i]--;\n\tfor(int i=1;i<up;++i)\n\t{\n\t\tif(xo[i]) continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t{\n\t\t\tif(xo[k]) continue;\n\t\t\tf[i]=min(f[i],f[k]+f[i^k]);\n\t\t}\n\t}\n\tprintf(\"%d\",ans+f[sit]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e9\n\nusing namespace std;\n\nstruct edge{\n\tint u, v;\n\tint cost;\n\tedge(){}\n\tedge(int a, int b, int c){\n\t\tu = a, v = b, cost = c;\n\t}\n\tint get(int a)\n\t{\n\t\tif(u == a) return v;\n\t\telse return u;\n\t}\n};\n\nint N;\nvector<int> G[100005];\nedge E[100005];\nint cnt[16];\n\nint V = 1 << 16, S;\nint dist[1<<16];\n\nvoid bfs(){\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(S);\n\tint v, nv;\n\twhile(Q.size()){\n\t\tv = Q.front();\n\t\tQ.pop();\n\t\tif(v == 0) break;\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif(v & (1<<i)){\n\t\t\t\tnv = v & ~(1<<i);\n\t\t\t\tif(dist[nv] < inf) continue;\n\t\t\t\tQ.push(nv);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < 16; i++){\n\t\t\tif((v & (1<<i)) == 0) continue;\n\t\t\tfor(int j = 1; j < 16; j++){\n\t\t\t\tif((v & (1<<j)) == 0) continue;\n\t\t\t\tif(i == j) continue;\n\t\t\t\tnv = v;\n\t\t\t\tnv &= ~(1<<i);\n\t\t\t\tnv ^= 1<<(i^j);\n\t\t\t\tif(dist[nv] < inf) continue;\n\t\t\t\tQ.push(nv);\n\t\t\t\tdist[nv] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int prev, int val)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(E[G[v][i]].get(v) == prev) continue;\n\t\tval ^= E[G[v][i]].cost;\n\t\tdfs(E[G[v][i]].get(v), v, E[G[v][i]].cost);\n\t}\n\tif(prev != -1) cnt[val]++;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint x, y, a;\n\tfor(int i = 0; i < N-1; i++){\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(i);\n\t\tG[y].push_back(i);\n\t\tE[i] = edge(x, y, a);\n\t}\n\t\n\tdfs(0, -1, 0);\n\t//for(int i = 0; i < 16; i++) cout << cnt[i] << \" \"; cout << endl;\n\t\n\tint ans = 0;\n\tfor(int i = 1; i < 16; i++){\n\t\tans += cnt[i] / 2;\n\t\tcnt[i] %= 2;\n\t}\n\tcnt[0] = 0;\n\tfor(int i = 0; i < 16; i++) if(cnt[i]) S += (1<<i);\n\t\n\tbfs();\n\tans += dist[0];\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst long long mod = 1000000007;\nconst int maxn = 100100;\nint deg[maxn], cnt[16];\nint dp[1<<16], xo[1<<16];\nint main(){\n    int n;\n    cin >> n;\n    for(int e = 0; e < n - 1; e++){\n        int u, v, w;\n        cin >> u >> v >> w;\n        deg[u] ^= w;\n        deg[v] ^= w;\n    }\n    for(int e = 0; e < n; e++){\n        cnt[deg[e]]++;\n    }\n    int ans = cnt[0];\n    for(int e = 1; e < 16; e++){\n        ans += cnt[e] / 2;\n        cnt[e] %= 2;\n    }\n    for(int e = 1; e < 1<<16; e++){\n        xo[e] = 0;\n        for(int f = 0; f < 16; f++)\n            if(e & (1<<f)) xo[e] ^= f;\n    }\n    dp[0] = 0;\n    for(int e = 1; e < 1<<16; e++){\n        for(int f = e; f > 0; f = (f - 1) & e){\n            if(xo[f] == 0) dp[e] = max(dp[e], dp[f] + 1);\n        }\n    }\n    int msk = 0;\n    for(int e = 1; e < 16; e++)\n        if(cnt[e]) msk |= (1<<e);\n    ans += dp[msk];\n    cout << n - ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,ans;\nint val[100005];\nint S;\nint A[100005],siz[100005],F[100005];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<N;i++){\n\t\tint u,v,c;scanf(\"%d%d%d\",&u,&v,&c);\n\t\tval[u]^=c;val[v]^=c;\n\t}\n\tfor(int i=0;i<N;i++){S^=(1<<val[i]);if(!((S>>val[i])&1)) ans++;}\n\tfor(int i=1;i<(1<<16);i++){\n\t\tint j=0;\n\t\tfor(;;j++) if((i>>j)&1) break;\n\t\tA[i]=A[i^(1<<j)]^j; \n\t\tsiz[i]=siz[i>>1]+(i&1);\n\t}\n\tfor(int i=1;i<(1<<16);i++)if(A[i]==0){\n\t\tF[i]=siz[i]-1;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i) if(A[j]==0)\n\t\t\tF[i]=min(F[i],F[j]+F[i^j]);\n\t}\n\tprintf(\"%d\\n\",ans+F[S]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\n\nint n,ans;\nint t[N],a[18];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tt[x]^=z;\n\t\tt[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\ta[t[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t\tans+=a[i]>>1,a[i]&=1;\n\tfor(int i=1;i<=15;i++) if(a[i])\n\tfor(int j=i+1;j<=15;j++) if(a[j])\n\t\tif(a[i^j]) a[i]=0,a[j]=0,a[i^j]=0,ans+=2,i++,j=i+1;\n\tfor(int i=1;i<=15;i++) if(a[i])\n\tfor(int j=i+1;j<=15;j++) if(a[j])\n\tfor(int k=j+1;k<=15;k++) if(a[k])\n\t\tif(a[i^j^k]) a[i]=0,a[j]=0,a[k]=0,a[i^j^k]=0,ans+=3,i++,j=i+1,k=j+1;\n\tfor(int i=1;i<=15;i++)\n\t\tif(a[i]) a[16]++;\n\tif(a[16]>=5) ans+=a[16]-1;\n\telse ans+=a[16];\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[16][1 << 15][8];\nint dp2(int idx, int mask, int tidx, int tcnt) {\n    if(tcnt >= 20) return 1e9;\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask);\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(idx, mask, tidx + 1, tcnt);\n\n    if(cc2[idx][mask][tidx].find(tcnt) != cc2[idx][mask][tidx].end()) return cc2[idx][mask][tidx][tcnt];\n    int &ret = cc2[idx][mask][tidx][tcnt];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(idx, mask, tidx + 1, tcnt));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(idx, mask ^ (1 << tidx) ^ (1 << didx), tidx, tcnt + 1));\n    return ret;\n}\n\nint cc1[16][1 << 15];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(idx, mask, 1, 0);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint in[N],n,ans,is,msk,to = 1<<26,from;\nvector<int>v;\nint dp[1<<26];\nvoid val(int msk){\n\tv.clear();\n\twhile(msk)\n\t\tv.push_back(msk%3),\n\t\tmsk/=3;\n\twhile(v.size() < 16)v.push_back(0);\n}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1,a,b,c;i < n;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tin[a]^=c;\n\t\tin[b]^=c;\n\t}\n\tfor(int i = 0;i < n;i++)\n\t\tans+=!!(is&(1<<in[i])),\n\t\tis^=1<<in[i];\n\tfor(int i = 0;i < to;i++)dp[i] = 17;\n \tfor(int i = 15;i+ 1;i--)msk = msk*3 + (!(is&(1<<i)) ? 2 : 0);\n\tdp[msk] = 0;\n\tfor(int i = 0;i < to;i++)\n\t\tif(dp[i] < 17){\n\t\t\tval(i);\n\t\t\tint three = 1, freq = 0,temp = 0;\n\t\t\tfrom = 0;\n\t\t\tfor(int j = 0;j < v.size();j++,three*=3){\n\t\t\t\tif(!v[j])dp[i + three] = min(dp[i + three],dp[i]);\n\t\t\t\tif(v[j] == 1)temp^=j,freq++;\n\t\t\t\tfrom = from*3 + (v[j] ? 2 : 0);\n\t\t\t}\n\t\t\tif(!temp)dp[from] = min(dp[from],dp[i] + freq - (freq > 1));\n\t\t}\n\tfrom = 0;\n\tfor(int i = 0;i < 16;i++)from = from*3 + 2;\n\tcout << ans + dp[from] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, ap[20], E[100009], d[1 << 16], frm[1 << 16];\nvector < pair < int, int > > h[100009];\nvector < pair < int, int > > v[1 << 16];\n\nvoid dfs (int nod, int tata)\n{\n    for (auto it : h[nod])\n        if (it.first != tata)\n            E[it.first] = it.second, dfs (it.first, nod), E[nod] ^= it.second;\n}\n\npriority_queue < pair < int, int > > PQ;\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y, z;\n    scanf (\"%d %d %d\", &x, &y, &z), x ++, y ++;\n    h[x].push_back ({y, z});\n    h[y].push_back ({x, z});\n}\ndfs (1, -1);\nfor (int i=2; i<=N; i++)\n    ap[E[i]] ++;\nint ans = 0, msk = 0;\nfor (int i=1; i<16; i++)\n{\n    if (ap[i] & 1) msk |= 1 << i;\n    ans += (ap[i] >> 1);\n}\nfor (int msk = 0; msk < (1 << 16); msk +=2)\n    for (int i=1; i<16; i++)\n        if (msk & (1 << i))\n        {\n            v[msk].push_back ({msk ^ (1 << i), 1});\n            int aux = msk ^ (1 << i);\n            for (int j=1; j<16; j++)\n                if (aux & (1 << j))\n                {\n                    if (aux & (1 << (j ^ i))) v[msk].push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 2});\n                    else v[msk].push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 1});\n                }\n        }\nfor (int i=0; i<(1 << 16); i++)\n    d[i] = -1;\nPQ.push ({0, msk}), d[msk] = 0;\nwhile (!PQ.empty ())\n{\n    auto curr = PQ.top ();\n    PQ.pop ();\n    if (d[curr.second] != -curr.first) continue;\n    int nod = curr.second;\n    for (auto it : v[nod])\n        if (d[it.first] == -1 || (d[it.first] > d[nod] + it.second))\n            d[it.first] = d[nod] + it.second, PQ.push ({-d[it.first], it.first}), frm[it.first] = nod;\n}\nprintf (\"%d\\n\", ans + d[0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<set>\n#define ll long long\n#define maxn 200005\n#define re register\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nint a[maxn],cnt[16],ans;\nint b[16],cnt1,sz[maxn],sz2[maxn],dp[maxn];\n\ninline int gs(int sta)\n{\n\tfor(int i=1;i<=cnt1;i++) if((sta&(1<<(i-1)))) sz[sta]^=b[i];\n}\n\nint main()\n{\n\tint n=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read(),w=read();\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(a[i]==0) continue;\n\t\tif(cnt[a[i]]) cnt[a[i]]=0,ans++;\n\t\telse cnt[a[i]]=1;\n\t}\n\tfor(int i=1;i<=15;i++) if(cnt[i]) b[++cnt1]=i;\n\tint ed=(1<<cnt1)-1;\n\t//for(int i=1;i<=cnt1;i++) cout<<b[i]<<\" \"; cout<<endl;\n\tfor(int i=1;i<=ed;i++) gs(i),sz2[i]=sz2[i>>1]+1;\n\tfor(int i=1;i<=ed;i++) dp[i]=sz2[i]-1;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<sz[i]<<\" \"<<sz2[i]<<endl;\n\tfor(int i=1;i<=ed;i++)\n\t{\n\t\tif(sz[i]!=0) continue;\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(sz[j]==0) dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t//else dp[i]=min(dp[i],sz2[j]+sz2[i^j]+1);\n\t\t}\n\t}\n\tcout<<dp[ed]+ans<<endl;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<dp[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+(k!=0));\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+(j!=0));\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<=15;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n            dp[n][0]=min(dp[n][0],temp[i]+1);\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+(val!=0));\n            dp[n][i]=min(dp[n][i],temp[i]+(val!=0));\n\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 5.1e5;\n\nvoid Run() {\n  int n;\n  cin >> n;\n  vector<int> deg(n);\n  vector<int> freq(16);\n  vector<int> remains;\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v, a;\n    cin >> u >> v >> a;\n    deg[u] ^= a;\n    deg[v] ^= a;\n  }\n  int nonzero = 0;\n  for (int i = 0; i < n; i++)\n    nonzero += (deg[i] > 0);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    freq[deg[i]] ^= 1;\n    if (deg[i] > 0 && !freq[deg[i]]) {\n      ans++;\n    }\n  }\n  for (int i = 1; i <= 15; ++i) {\n    if (freq[i]) {\n      remains.push_back(i);\n    }\n  }\n  const int N = remains.size();\n  vector<int> dp(1 << N);\n  for (int i = 0; i < (1 << N); ++i) {\n    int cur = 0;\n    for (int j = 0; j < N; ++j) {\n      int bit = (i >> j) & 1;\n      if (bit == 0) {\n        cur ^= remains[j];\n      }\n    }\n    for (int j = 0; j < N; ++j) {\n      if (i & (1 << j)) {\n        dp[i] = max(dp[i], dp[i ^ (1 << j)]);\n      }\n    }\n    if (cur == 0 && __builtin_popcount(i) < N) {\n      ++dp[i];\n    }\n  }\n  ans += dp[(1 << N) - 1];\n  cout << nonzero - ans << '\\n';\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  Run();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nmap<int,int> memo;\nint dfs(int mask){\n  if(mask == 0) return 0;\n  if(__builtin_popcount(mask)==1) return INF;\n  if(memo.count(mask)>0) return memo[mask];\n// dbg(mask);\n  int ret = INF;\n  for(int nmask = mask; nmask>0; nmask = (nmask-1)&mask){\n    int x = 0;\n    rep(i,16) if(nmask>>i&1) x ^= i;\n    if(x == 0){\n      int r = dfs(mask - nmask);\n      ret = min(ret, r + __builtin_popcount(nmask) - 1);\n    }\n  }\n  return memo[mask] = ret;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> v(n, 0);\n  rep(i,n-1){\n    int x,y,a;\n    cin>>x>>y>>a;\n    v[x] ^= a;\n    v[y] ^= a;\n  }\n\n  vector<int> cnt(16, 0);\n  rep(i,n){\n    cnt[v[i]]++;\n  }\n\n  int ans = 0;\n  int mask = 0;\n  rep(i,1,16){\n    ans += cnt[i]/2;\n    if(cnt[i]%2) mask |= (1<<i);\n  }\n\n  int r = dfs(mask);\n  assert(r<INF);\n\n  cout << ans + r << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<int> > ed;\nvector<vector<int> > w;\nvector<int > V;\nvector<int> X(16, 0);\nvector<int> dp(1 << 16, -1);\nint dfs(int a, int p) {\n\tint x = 0;\n\tfor (int i = 0; i < ed[a].size(); i++) {\n\t\tif (ed[a][i] != p) {\n\t\t\tdfs(ed[a][i], a);\n\t\t\tX[V[ed[a][i]] ^ w[a][i]]++;\n\t\t\tx ^= (V[ed[a][i]] ^ w[a][i]);\n\t\t}\n\t}\n\tV[a] = x;\n\treturn V[a];\n}\nint rec(int a) {\n\tif (dp[a] != -1) {\n\t\treturn dp[a];\n\t}\n\tvector<int> T;\n\tint b = a;\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (b % 2 == 1) {\n\t\t\tT.push_back(i);\n\t\t}\n\t\tb /= 2;\n\t}\n\tdp[a] = 1000000000;\n\tint aa = 0;\n\tint p;\n\tfor (int i = 0; i < (int)T.size() - 1; i++) {\n\t\tfor (int j = i + 1; j < (int)T.size(); j++) {\n\t\t\taa = a ^ ((1 << T[i]) | (1 << T[j]));\n\t\t\tp = 1;\n\t\t\tif ((a & (1 << (T[i] ^ T[j]))) != 0) {\n\t\t\t\tp = 2;\n\t\t\t}\n\t\t\tdp[a] = min(dp[a], p + rec((a ^ ((1 << T[i]) | (1 << T[j]))) ^ (1 << (T[i]^T[j]))));\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)T.size(); i++) {\n\t\tdp[a] = min(dp[a], 1 + rec(a ^ (1 << T[i])));\n\t}\n\treturn dp[a];\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\ted.resize(N);\n\tw.resize(N);\n\tV.resize(N, 0);\n\tint a, b, c;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> a >> b >> c;\n\t\ted[a].push_back(b);\n\t\tw[a].push_back(c);\n\t\ted[b].push_back(a);\n\t\tw[b].push_back(c);\n\t}\n\tdfs(0, -1);\n\tint s = 0;\n\tint res = 0;\n\tfor (int i = 1; i < 16; i++) {\n\t\t//cerr << X[i] << endl;\n\t\tres += X[i] / 2;\n\t\tX[i] = X[i] % 2;\n\t\ts += (1 << i)*X[i];\n\t}\n\tcerr << s << endl;\n\tdp[0] = 0;\n\trec(s);\n\t//rec((1 << 16) - 1);\n\tcout << res + dp[s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[33],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=15;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct edge{\n\tint to,nxt,dis;\n}e[200101];\nint head[101010],tot,n;\ninline void made(int from,int to,ll dis){\n\te[++tot].to=to;e[tot].nxt=head[from];head[from]=tot;\n\te[tot].dis=dis;\n}\nint a[101010],b[100],f[201010],g[202020];\nvoid dfs(int u,int faa){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==faa) continue; \n\t\ta[v]=e[i].dis;\n\t\tdfs(v,u);\n\t\ta[u]^=a[v];\n\t}\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tmade(x+1,y+1,z),made(y+1,x+1,z);\n\t}\n\tdfs(1,0); \n\tint all=0,ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]) b[a[i]-1]++,all^=(1<<(a[i]-1));\n\t}\n\tfor (int i=0;i<15;i++) ans+=b[i]/2,b[i]&=1;\n\tfor (int zt=1;zt<=all;zt++){\n\t\tbool flag=0;\n\t\tfor (int i=0;i<15;i++){\n\t\t\tif (((1<<i)&zt)&&(!b[i])){\n\t\t\t\tflag=1;break;\n\t\t\t}\n\t\t\telse if ((1<<i)&zt) g[zt]^=i+1;\n\t\t}\n\t\tif (!flag){\n\t\t\tf[zt]=__builtin_popcount(zt)-1;\n\t\t\tfor (int i=zt&(zt-1);i;i=zt&(i-1)){\n\t\t\t\tif (g[zt^i]|g[i]){\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tf[zt]=min(f[zt],f[zt^i]+f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[all]+ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=j;i<=k;++i)\n#define Forr(i,j,k) for (int i=j;i>=k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T& a,T b) {return a<b?a=b,1:0;}\ntemplate<typename T>bool chkmin(T& a,T b) {return a>b?a=b,1:0;}\n\nconst int maxn=100000+100;\nstruct node {\n\tint to,dis,next;\n}e[maxn<<1];\nint n,tot=-1,ans;\nint head[maxn],cnt[maxn];\nqueue<int>q;\n\ninline void read(int &x) {\n\tx=0;\n\tint p=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)) {if (c=='-') p=-1; c=getchar();}\n\twhile (isdigit(c)) {x=(x<<1)+(x<<3)+(c-'0'); c=getchar();}\n\tx*=p;\n}\n\ninline void file() {\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n}\n\ninline void add(int from,int to,int dis) {\n\ttot++;\n\te[tot].to=to; e[tot].dis=dis; e[tot].next=head[from]; head[from]=tot;\n}\n\ninline bool check(int s,int a) {\n\tfor (int s0=s;s0;s0=(s0-1)&s) if (s0==a) return 1;\n\treturn 0;\n}\n\nvoid dfs(int u,int fa,int dis) {\n\tfor (int i=head[u];i!=-1;i=e[i].next) {\n\t\tint v=e[i].to;\n\t\tif (v==fa) continue;\n\t\tif (check(e[i].dis,dis)) {\n\t\t\te[i].dis^=dis; e[i^1].dis^=dis;\n\t\t\tdfs(v,u,dis);\n\t\t}\n\t}\n}\n\nint main() {\n//\tfile();\n\tSet(head,-1);\n\tread(n);\n\tFor (i,1,n-1) {\n\t\tint x,y,z; read(x); read(y); read(z);\n\t\tadd(x,y,z); add(y,x,z); cnt[x]++; cnt[y]++;\n\t}\n\tFor (i,0,n-1) if (cnt[i]==1) q.push(i);\n\twhile (!q.empty()) {\n\t\tint u=q.front(); q.pop();\n\t\tfor (int i=head[u];i!=-1;i=e[i].next) {\n\t\t\tint v=e[i].to;\n\t\t\tif (e[i].dis) {\n\t\t\t\tdfs(v,u,e[i].dis); e[i].dis=0; e[i^1].dis=0;\n\t\t\t\t++ans;\n\t\t\t}\n\t\t\tcnt[v]--; if (cnt[v]==1) q.push(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int N = 100005;\nconst int R = 16;\nconst int _R = 1 << R;\nint n, head[N], cnt[R], dp[_R], tot, x, y, z, ans;\nstruct edge { int to, nxt, cost; } e[N << 1];\nvoid addedge(int x, int y, int z) {\n\te[++tot] = (edge) { y, head[x], z }; head[x] = tot;\n\te[++tot] = (edge) { x, head[y], z }; head[y] = tot;\n}\nvoid dfs(int x, int f = -1) {\n\tint v = 0; for (int i = head[x]; i; i = e[i].nxt) v ^= e[i].cost; cnt[v]++;\n\tfor (int i = head[x]; i; i = e[i].nxt) if (e[i].to != f) dfs(e[i].to, x);\n}\nint main() {\n\tstd::scanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) std::scanf(\"%d%d%d\", &x, &y, &z), addedge(x, y, z); \n\tdfs(0);\n\tint v = 0;\n\tfor (int i = 1; i < R; i++) ans += cnt[i] >> 1, cnt[i] &= 1, v |= cnt[i] << i;\n\tstd::memset(dp, 0x3f, sizeof dp);\n\tfor (int i = 2; i < _R; i += 2) {\n\t\tint v = 0; for (int t = 0; t < 16; t++) if (i >> t & 1) v ^= t;\n\t\tif (v) continue;\n\t\tdp[i] = __builtin_popcount(i) - 1;\n\t\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\t\tdp[i] = std::min(dp[i], dp[j] + dp[i - j]);\n\t}\n\tstd::printf(\"%d\\n\", dp[v] + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=2e5+10;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[20], f[MaxM];\nbool xr[MaxM];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[x]^=z, v[y]^=z;\n\tfor (int i=0; i<n; ++i) ++cnt[v[i]];//è´ªå¿\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int i=1; i< (1<<15); ++i)\n        for (int j=0; j<15; ++j)\n\t\t\tif ((i>>j)&1) xr[i]^=(j+1);//é¢å¤çéåçå¼æå\n    for (int i=1; i<(1<<15); ++i)//æä¸¾å­éè¿è¡è½¬ç§»\n    {\n        if (xr[i]!=0) continue;\n        for(int k=(i-1)&i; k; k=(k-1)&i)\n            if (xr[k]==0) chkMin(f[i], f[k]+f[i^k]);\n    }\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 200010;\n\nint n, res, m;\nint w[N], d[N], cnt[20], sxr[N];\n\nint main()\n{\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i < n; i++) \n    {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c); \n        w[a] ^= c;\n        w[b] ^= c; \n    }\n\n    for (int i = 0; i < n; i++)  cnt[w[i]]++; \n\n    for (int i = 1; i <= 15; i++)\n    {\n        res += cnt[i] / 2;\n        m |= (cnt[i] & 1) << (i - 1);\n    }\n\n    for (int i = 1; i < (1 << 15); i++) d[i] = d[i >> 1] + (i & 1);\n    for (int i = 1; i < (1 << 15); i++) d[i] -= 1;\n    for (int i = 1; i < (1 << 15); i++)\n    {\n        for (int j = 0; j < 15; j++)\n        {\n            if ((i >> j) & 1)sxr[i] ^= (j + 1);\n        }\n    }\n    \n    for (int i = 1; i < (1 << 15); i++)\n    {\n        if (sxr[i] != 0)continue;\n        for (int k = (i - 1) & i; k; k = (k - 1) & i)\n        {\n            if (sxr[k] == 0)d[i] = min(d[i], d[k] + d[i ^ k]);\n        }\n    }\n\n    printf(\"%d\", res + d[m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nvector<vector<pair<LL, LL>>> edge(100000);\nvector<LL> a(100000, -1);\nvector<LL> parent(100000, -1);\nvector<vector<LL>> children(100000);\nvector<int> xor (100000, 0);\n\nvoid make_graph(LL start, LL weight) {\n\ta[start] = weight;\n\tREP(i, edge[start].size()) {\n\t\tif (a[edge[start][i].first] == -1) {\n\t\t\tparent[edge[start][i].first] = start;\n\t\t\tchildren[start].push_back(edge[start][i].first);\n\t\t\tmake_graph(edge[start][i].first, edge[start][i].second);\n\t\t}\n\t}\n}\n\nint find_ans(LL start) {\n\tint xor_sum = a[start];\n\tREP(i, children[start].size()) {\n\t\tint xor_num = find_ans(children[start][i]);\n\t\txor_sum = xor_sum ^ xor_num;\n\t}\n\txor[start] = xor_sum & 15;\n\treturn xor[start];\n}\n\nint main() {\n\tLL N;\n\tcin >> N;\n\n\tREP(i, N - 1) {\n\t\tLL x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tedge[x].push_back(make_pair(y, a));\n\t\tedge[y].push_back(make_pair(x, a));\n\t}\n\n\tmake_graph(0, -2);\n\n\tfind_ans(0);\n\n\tvector<LL> num(4, 0);\n\tFOR(i,1, xor.size()) {\n\t\tnum[0] += (xor[i] & 1) / 1;\n\t\tnum[1] += (xor[i] & 2) / 2;\n\t\tnum[2] += (xor[i] & 4) / 4;\n\t\tnum[3] += (xor[i] & 8) / 8;\n\t}\n\n\tLL sum = 0;\n\tREP(i, num.size()) {\n\t\tsum += (num[i] + 1) / 2;\n\t}\n\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector <int> vi;\ntypedef long double LD;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=100005,M=16;\nint n;\nint v[N],c[M];\nint dp[1<<M];\nint DP(int x){\n\tif (~dp[x])\n\t\treturn dp[x];\n\tif (x==0)\n\t\treturn dp[x]=0;\n\tint ans=1e9;\n\tFor(i,1,M-1)\n\t\tFor(j,1,M-1)\n\t\t\tif (i!=j&&(x>>i&1)&&(x>>j&1)){\n\t\t\t\tint s=x^(1<<i)^(1<<j);\n\t\t\t\tint v=i^j,c=0;\n\t\t\t\tif (v){\n\t\t\t\t\tif (s>>v&1)\n\t\t\t\t\t\tc++;\n\t\t\t\t\ts^=1<<v;\n\t\t\t\t}\n\t\t\t\tans=min(ans,DP(s)+1+c);\n\t\t\t}\n\treturn dp[x]=ans;\n}\nint main(){\n\tn=read();\n\tFor(i,1,n-1){\n\t\tint x=read()+1,y=read()+1,z=read();\n\t\tv[x]^=z,v[y]^=z;\n\t}\n\tFor(i,1,n)\n\t\tc[v[i]]++;\n\tint ans=0,S=0;\n\tFor(i,1,M-1){\n\t\tans+=c[i]>>1;\n\t\tc[i]&=1;\n\t\tS|=c[i]<<i;\n\t}\n\tmemset(dp,-1,sizeof dp);\n\tcout<<ans+DP(S)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];int sxr[N]; \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}//è´ªå¿ \n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;//é¢å¤çæ¯ä¸ªdpå¼çä¸ç \n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);//é¢å¤çéåçå¼æå \n    for(int i=1;i<(1<<15);i++)//æä¸¾å­éè¿è¡è½¬ç§» \n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,sxr[N];\nbool book[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++){ri u=read(),v=read(),va=read();w[u]^=va;w[v]^=va;}\n\tfor(int i=0;i<n;i++){cnt[w[i]]++;} \n\tfor(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);  \n\tfor(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<15);i++)d[i]-=1;\n\tfor(int i=1;i<(1<<15);i++)\n\t\tfor(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n\tfor(int i=1;i<(1<<15);i++)\n\t{\n\t\tif(sxr[i]!=0)continue;\n\t\tfor(int k=(i-1)&i;k;k=(k-1)&i)\n\t\t\tif(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n\t}printf(\"%d\",res+d[st]);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n  if (ib == ie) {\n    ib = ibuf;\n    ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n  }\n  return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nconst size_t N = 1e5 + 5;\nconst size_t M = 16;\n\nint val[N], cnt[M];\nint dp[1 << M];\n\nint solve(int msk) {\n  if (!msk) return 0;\n  if (~dp[msk]) return dp[msk];\n  int &ret = dp[msk] = 1e9;\n  for (int i = 0; i < M; ++i) {\n    if (msk >> i & 1) {\n      for (int j = 0; j < i; ++j) {\n        if (msk >> j & 1) {\n          int nmsk = msk;\n          nmsk ^= 1 << i;\n          nmsk ^= 1 << j;\n          int tmp = 1 << (i ^ j);\n          nmsk ^= tmp;\n          ret = min(ret, solve(nmsk) + 1 + (!(nmsk & tmp)));\n        }\n      }\n      ret = min(ret, solve(msk ^ (1 << i)) + 1);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  int n = read();\n  int ans = 0;\n\n  for (int i = 1; i < n; ++i) {\n    int x = read();\n    int y = read();\n    int a = read();\n    val[x] ^= a;\n    val[y] ^= a;\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    ++cnt[val[i]];\n  }\n\n  int msk = 0;\n  for (int i = 1; i < M; ++i) {\n    ans += cnt[i] >> 1;\n    msk |= (cnt[i] & 1) << i;\n  }\n\n  memset(dp, -1, sizeof dp);\n  cout << ans + solve(msk) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[16][1 << 15][8];\nint dp2(int idx, int mask, int tidx, int tcnt) {\n    if(tidx == 8) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask);\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(idx, mask, tidx + 1, tcnt);\n\n    if(cc2[idx][mask][tidx].find(tcnt) != cc2[idx][mask][tidx].end()) return cc2[idx][mask][tidx][tcnt];\n    int &ret = cc2[idx][mask][tidx][tcnt];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(idx, mask, tidx + 1, tcnt));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(idx, mask ^ (1 << tidx) ^ (1 << didx), tidx + 1, tcnt + 1));\n    return ret;\n}\n\nint cc1[16][1 << 15];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(idx, mask, 1, 0);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair <int, int> pii;\nvector <pii> g[100010];\nint dep[100010];\nint cnt[20];\nint val[1 << 17];\n\nvoid dfs(int x, int par) {\n\tfor(auto i : g[x]) {\n\t\tif(i.first - par) {\n\t\t\tdfs(i.first, x);\n\t\t\tdep[i.first] = i.second ^ dep[x];\n\t\t}\n\t}\n}\n\nint dp(int mask) {\n\tif(mask == 0) return 0;\n\tint ans = 0;\n\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\tif(val[submask] == 0) {\n\t\t\tans = max(ans, 1 + dp(mask ^ submask));\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\t\tg[p].push_back(pii(q, r));\n\t\tg[q].push_back(pii(p, r));\n\t}\n\tdfs(0, -1);\n\tvector <int> v;\n\tint comp = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tcnt[dep[i]] += 1;\n\t}\n\tfor(int i = 1; i < 16; i++) {\n\t\tif(cnt[i] & 1) {\n\t\t\tv.push_back(i);\n\t\t}\n\t\tcomp += cnt[i] >> 1;\n\t}\n\tcomp += cnt[0];\n\n\t// for(auto i : v) cout << i << endl;\n\tfor(int i = 0; i < (1 << v.size()); i++) {\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tif((i >> j) & 1) {\n\t\t\t\tval[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\tcomp += dp((1 << v.size()) - 1);\n\tcout << n - comp << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100000;\n\nint f[MX], cnt[16], dp[1 << 16];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\tfor (int i = 1, u, v, a; i < n; i++) {\n\t\tignore = scanf(\"%d %d %d\", &u, &v, &a);\n\t\tf[u] ^= a;\n\t\tf[v] ^= a;\n\t}\n\t\n\tfor (int i = 0; i < n; i++) cnt[f[i]]++;\n\t\n\tint ans = 0, mask = 0;\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += cnt[i] / 2;\n\t\tmask |= (cnt[i] & 1) << i;\n\t}\n\t\n\tdp[0] = ans;\n\tfor (int i = 1; i <= mask; i++) {\n\t\tint j = 0;\n\t\twhile ((i >> j) % 2 == 0) j++;\n\t\tdp[i] = 42;\n\t\tfor (int k = j + 1; (1 << k) <= i; k++)\n\t\t\tif ((i >> k) % 2 == 1) {\n\t\t\t\tint val = dp[i ^ (1 << j) ^ (1 << k) ^ (1 << (k ^ j))] + 1;\n\t\t\t\tif ((i >> (k ^ j)) % 2 == 1) val++;\n\t\t\t\tdp[i] = min(dp[i], val);\n\t\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[mask]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    os << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; cin >> N;\n    vector<vector<pair<int,int>>> G(N);\n    for (int i=0;i<N-1;++i){\n        int x,y,a; cin >> x >> y >> a;\n        G[x].emplace_back(y,a);\n        G[y].emplace_back(x,a);\n    }\n    vector<int> cnt(16,0);\n    auto dfs=[&](auto self,int v,int p,int a)->void{\n        for (auto e:G[v]){\n            int u=e.first;\n            if (u==p) continue;\n            self(self,u,v,e.second);\n            a^=e.second;\n        }\n        ++cnt[a];\n    };\n    dfs(dfs,0,-1,0);\n    int odd=0,ans=0;\n    for (int i=1;i<16;++i){\n        ans+=cnt[i]>>1;\n        odd+=cnt[i]&1;\n    }\n    cout << ans+(odd?odd-1:0) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=100005;\nint val[maxn*20],hd[maxn],n,m;\nint to[maxn*20],ne[maxn*20],num,S;\nint XS[maxn],now,ci[20],d[maxn],C[233];\ninline void add(int x,int y,int z){ to[++num]=y,ne[num]=hd[x],hd[x]=num,val[num]=z;}\n\ninline void build(){\n\tfor(int i=1;i<ci[15];i++)\n\t    for(int j=1;j<=15;j++) if(ci[j-1]&i){\n\t    \tnow=i^ci[j-1],add(now,i,1);\n\t    \tfor(int k=1;k<=15;k++) if(ci[k-1]&now) add(now^ci[k-1]^ci[(j^k)-1],i,1+((now&ci[(j^k)-1])?1:0));\n\t\t}\n}\n\ninline void spfa(){\n\tqueue<int> q; bool v[maxn];\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(v,0,sizeof(v));\n\td[0]=0,q.push(0),v[0]=1;\n\t\n\tint x;\n\twhile(!q.empty()){\n\t\tx=q.front(),q.pop();\n\t\tfor(int i=hd[x];i;i=ne[i]) if(d[x]+val[i]<d[to[i]]){\n\t\t\td[to[i]]=d[x]+val[i];\n\t\t\tif(!v[to[i]]) v[to[i]]=1,q.push(to[i]);\n\t\t}\n\t\tv[x]=0;\n\t}\n}\n\ninline void init(){\n\tci[0]=1;\n\tfor(int i=1;i<=15;i++) ci[i]=ci[i-1]<<1;\n\t\n\tbuild();\n\tspfa();\n}\n\ninline void solve(){\n\tint uu,vv,ww,ans=1<<30;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&uu,&vv,&ww);\n\t\tuu++,vv++,XS[uu]^=ww,XS[vv]^=ww;\n\t}\n\t\n\tfor(int i=1;i<=n;i++) C[XS[i]]++;\n\tfor(int i=1;i<=n;i++){\n\t\tC[XS[i]]--;\n\t\t\n\t\tS=0,now=0;\n\t\tfor(int j=1;j<=15;j++){\n\t\t\tnow+=C[j]>>1;\n\t\t\tS|=(C[j]&1)*ci[j-1];\n\t\t}\n\t\tnow+=d[S];\n\t\tans=min(ans,now);\n\t\t\n\t\tC[XS[i]]++;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nvector<vector<pair<LL, LL>>> edge(100000);\nvector<LL> a(100000, -1);\nvector<LL> parent(100000, -1);\nvector<vector<LL>> children(100000);\nvector<int> nodexor(100000, 0);\n\nvoid make_graph(LL start, LL weight) {\n\ta[start] = weight;\n\tREP(i, edge[start].size()) {\n\t\tif (a[edge[start][i].first] == -1) {\n\t\t\tparent[edge[start][i].first] = start;\n\t\t\tchildren[start].push_back(edge[start][i].first);\n\t\t\tmake_graph(edge[start][i].first, edge[start][i].second);\n\t\t}\n\t}\n}\n\nint find_ans(LL start) {\n\tint xor_sum = a[start];\n\tREP(i, children[start].size()) {\n\t\tint xor_num = find_ans(children[start][i]);\n\t\txor_sum = xor_sum ^ xor_num;\n\t}\n\tnodexor[start] = xor_sum & 15;\n\treturn nodexor[start];\n}\n\nint main() {\n\tLL N;\n\tcin >> N;\n\n\tREP(i, N - 1) {\n\t\tLL x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tedge[x].push_back(make_pair(y, a));\n\t\tedge[y].push_back(make_pair(x, a));\n\t}\n\n\tmake_graph(0, -2);\n\n\tfind_ans(0);\n\n\tvector<LL> num(4, 0);\n\tFOR(i,1, nodexor.size()) {\n\t\tnum[0] += (nodexor[i] & 1) / 1;\n\t\tnum[1] += (nodexor[i] & 2) / 2;\n\t\tnum[2] += (nodexor[i] & 4) / 4;\n\t\tnum[3] += (nodexor[i] & 8) / 8;\n\t}\n\n\tLL sum = 0;\n\tREP(i, num.size()) {\n\t\tsum += (num[i] + 1) / 2;\n\t}\n\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 65540\nusing namespace std;\nint n,s[N],S,ans,f[M],inf,sum[20];\n\nint dfs(int S)\n{\n  if(!S)return 0; \n  if(f[S]<inf)return f[S];\n  for(int i=0;i<16;i++)if((S>>i)&1)\n    for(int j=0;j<16;j++)if(i!=j&&(S>>j)&1)\n    {\n      int p=i^j,x=S^(1<<i)^(1<<j)^(1<<p);\n\t  if(S>>p&1)f[S]=min(f[S],dfs(x)+2);\n\t  else f[S]=min(f[S],dfs(x)+1);\n\t  //æä¸¾æ¯æ¬¡å¼æçä¸¤ä¸ªèç¹i,j,iå¼ææj,jå¼ææj,è¿å©ä¸p=i^j\n\t  //å¦æpæ¬èº«å­å¨é£ä¸¤ä¸ªpç´æ¥æ¶æ \n\t}\n  return f[S];\n}\n\nint main()\n{\n  int a,b,c;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d%d\",&a,&b,&c),s[a]^=c,s[b]^=c;\n  for(int i=0;i<n;i++)sum[s[i]]++;\n  for(int i=1;i<16;i++)\n    ans+=(sum[i]>>1),S+=(1<<i)*(sum[i]&1);\n  memset(f,127,sizeof(f));inf=f[0];\n  printf(\"%d\\n\",ans+dfs(S));\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=100010;\n\nint n,a[N],cnt[N],f[N],xs[N],lst[N];\n\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=1,x,y,w;i<n;i++)\n    scanf(\"%d%d%d\",&x,&y,&w),a[x]^=w,a[y]^=w;\n  for(int i=0;i<n;i++) cnt[a[i]]++;\n  int ans=cnt[0]; cnt[0]=0;\n  for(int i=1;i<16;i++) ans+=cnt[i]/2,cnt[i]%=2;\n  for(int i=1;i<(1<<15);i++){\n    lst[i]=(i&1)?1:lst[i>>1]+1;\n    xs[i]=xs[i-(1<<lst[i]-1)]^lst[i];\n    for(int j=i;j;j=(j-1)&i)\n      if(xs[j]==0) f[i]=max(f[i],f[i^j]+1);\n  }\n  int S=0;\n  for(int i=1;i<16;i++) S|=cnt[i]*(1<<i-1);\n  ans+=f[S];\n  printf(\"%d\\n\",n-ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1000000000\n\n\n\nint main(){\n\t\n\tint N;\n\tcin>>N;\n\t\n\tvector<vector<int>> E(N,vector<int>());\n\t\n\tfor(int i=0;i<N-1;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tE[a].push_back(c);\n\t\tE[b].push_back(a);\n\t}\n\t\n\tint last = -1;\n\tvector<int> cnt(16,0);\n\t\n\tfor(int i=0;i<N;i++){\n\t\tif(E[i].size()==1){\n\t\t\tif(last==-1){\n\t\t\t\tlast = E[i][0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tint t=  0;\n\t\tfor(int j=0;j<E[i].size();j++)t^=E[i][j];\n\t\tcnt[t]++;\n\t}\n\t\n\tfor(int i=0;i<16;i++){\n\t\tlast ^= (cnt[i]%2)*16;\n\t}\n\t\n\tcnt[last]++;\n\t\n\tvector<int> calc(1<<16,0);\n\t\n\tfor(int i=0;i<(1<<16);i++){\n\t\tint t = 0;\n\t\tfor(int j=0;j<16;j++){\n\t\t\tif((i>>j)&1)t^=j;\n\t\t}\n\t\tcalc[i] = t;\n\t}\n\t/*\n\tfor(int i=0;i<cnt.size();i++){\n\t\tcout<<cnt[i]<<endl;\n\t}\n\t*/\n\t\n\tvector<vector<int>> dp(16,vector<int>(1<<16,Inf));\n\tdp[0][0] = 0;\n\t\n\tfor(int i=0;i<15;i++){\n\t\tfor(int j=0;j<(1<<16);j++){\n\t\t\tif(dp[i][j]==Inf)continue;\n\t\t\tint cost=  dp[i][j];\n\t\t\tcost += cnt[i+1]/2;\n\t\t\tif(cnt[i+1]%2==0){\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j],cost);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint S = j;\n\t\t\t\tcost++;\n\t\t\t\tfor(int T = j;true;T=((T-1)&S)){\n\t\t\t\t\tint SS = S^T^(1<<((i+1)^calc[T]));\n\t\t\t\t\t//cout<<SS<<endl;\n\t\t\t\t\tdp[i+1][SS] = min(dp[i+1][SS],cost);\n\t\t\t\t\tif(T==0)break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<16;i++){\n\t\tfor(int j=0;j<9;j++){\n\t\t\tcout<<dp[i][j]<<',';\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\t\n\tint ans = Inf;\n\tfor(int i=0;i<(1<<16);i++){\n\t\tint c = 0;\n\t\tfor(int j=0;j<16;j++){\n\t\t\tif((i>>j)&1)c++;\n\t\t}\n\t\tans = min(ans,dp.back()[i]+c);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+(k!=0));\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+(j!=0));\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<20;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+1);\n            dp[n][i]=min(dp[n][i],temp[i]+1);\n\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 , B = 16 , MASK = (1 << B) ;\nint n ;\nint X[MASK] , dp[MASK] ;\n\nint x[N] ;\nvector <pii> g[N] ;\n\nvoid pre () {\n\tvector <int> vec ;\n\n\tfor (int mask = 1 ; mask < MASK ; mask ++) {\n\t\tfor (int i = 0 ; i < B ; i ++) {\n\t\t\tif (mask >> i & 1) {\n\t\t\t\tX[mask] = X[mask ^ (1 << i)] ^ i ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\n\t\tif (!X[mask]) dp[mask] = 1 , vec.push_back(mask) ;\n\t}\n\n\tfor (int m1 : vec)\n\t\tfor (int m2 : vec)\n\t\t\tif (m2 < m1 && (m1 & m2) == 0)\n\t\t\t\tdp[m1 | m2] = max(dp[m1 | m2] , dp[m1] + dp[m2]) ;\n}\n\nvoid dfs (int v , int par = -1) {\n\tfor (auto ed : g[v]) {\n\t\tint u = ed.F , w = ed.S ;\n\t\tif (u == par) continue ;\n\n\t\tx[v] ^= w ;\n\t\tx[u] = w ;\n\t\tdfs(u , v) ;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 , u , v , w ; i < n - 1 ; i ++) {\n\t\tcin >> u >> v >> w ;\n\t\tg[u].push_back({v , w}) ;\n\t\tg[v].push_back({u , w}) ;\n\t}\n\n\tdfs(0) ;\n\n\tint mask = 0 , cnt = 0 ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tif (x[i] == 0) cnt ++ ;\n\t\telse if (mask >> x[i] & 1) mask ^= (1 << x[i]) , cnt ++ ;\n\t\telse mask ^= (1 << x[i]) ;\n\t}\n\n\tcout << n - cnt - dp[mask] << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint const N = 1234567;\nint const INF = 1 << 30;\n \nint deg[N];\nint was[42];\n\nint dp[1 << 16];\n \nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u, w;\n\t\tcin >> v >> u >> w;\n\t\tdeg[v] ^= w;\n\t\tdeg[u] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (deg[i] == 0) continue;\n\t\tif (was[deg[i]]) {\n\t\t\t++ans;\n\t\t\twas[deg[i]] = false;\n\t\t} else {\n\t\t\twas[deg[i]] = true;\n\t\t}\n\t}\n\tint mask = 0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (was[i]) mask |= 1 << i;\n\t}\n\tfor (int i = 0; i < 1 << 16; i++) dp[i] = INF;\n\tdp[mask] = 0;\n\tfor (int i = mask; i >= 1; i--) {\n\t\tif (dp[i] == INF) continue;\n\t\tif ((i & (i - 1)) == 0) continue;\n\t\tfor (int j = 1; j < 16; j++) {\n\t\t\tif (((i >> j) & 1) == 0) continue;\n\t\t\tfor (int k = j + 1; k < 16; k++) {\n\t\t\t\tif (((i >> k) & 1) == 0) continue;\n\t\t\t\tif ((j & k) == 0) continue;\n\t\t\t\t// cerr << i << ' ' << j << ' ' << k << endl;\n\t\t\t\tint nj = j ^ k;\n\t\t\t\tint nmask = i ^ (1 << j) ^ (1 << k);\n\t\t\t\tint cost = 1;\n\t\t\t\tif (nj > 0) {\n\t\t\t\t\tif (((nmask >> nj) & 1) == 1) {\n\t\t\t\t\t\tcost++;\n\t\t\t\t\t}\n\t\t\t\t\tnmask ^= 1 << nj;\n\t\t\t\t}\n\t\t\t\t// cout << \"nmask = \" << nmask << endl;\n\t\t\t\tdp[nmask] = std::min(dp[nmask], dp[i] + cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0] + ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=100000 +10, oo= 1<<29;\n\nint b[MAXN], n,m, f[MAXN], cnt[17];\nbool vis[MAXN];\n\nint DP(int s);\n\nint main(){\n//\tfreopen(\"input.txt\",\"rt\",stdin);\n//\tfreopen(\"output.txt\",\"wt\",stdout);\n\tscanf(\"%d\", &n );\n\tfor (int i=1, u,v,a; i<n; i++){\n\t\tscanf(\"%d%d%d\", &u, &v, &a);\n\t\tb[u] ^= a;\n\t\tb[v] ^= a;\n\t}\n\tfor (int i=0; i<n; i++) cnt[b[i]]++;\n\tint ans=0, inista=0;\n\tfor(int i=0; i<16; i++){\n\t\t\t\n\t\tans += cnt[i]/ 2;\n\t\tcnt[i] %= 2;\n\t\tinista |= cnt[i]*(1<<i);\n\t\t#ifdef che\n\t\tif ( cnt[i]) debug(\"cnt[%d] = %d\\n\", i, cnt[i]);\n\t\t#endif\n\t}\n\t#ifdef che\n\tdebug(\"same contrad ans= %d\\tinitial state =%d\\n\", ans,inista);\n\t#endif\n\tans += DP(inista);\n\tprintf(\"%d\\n\" , ans);\n\treturn 0;\n}\n\nint DP(int s){\n\tif ( s==0) return 0;\n\tif ( vis[s]) return f[s];\n\tvis[s]= true; f[s] = oo;\n\tfor (int i=0; i<16; i++)\n\t\tfor (int j=i+1; j<16 ;j++)\n\t\t\tif ( s&(1<<i) && s&(1<<j) ){\n\t\t\t\tint rst= s^(1<<i)^(1<<j), nw= 1<<(i^j);\n\t\t\t\tif ( rst&nw) f[s]= min( f[s], DP(rst^nw)+2);\n\t\t\t\t\telse f[s]= min(f[s], DP(rst^nw)+1);\n\t\t\t}\n\t\n\treturn f[s];\n}"
  },
  {
    "language": "C++",
    "code": "// sync\n\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 1e5 + 51;\n\nint dp[N], xorv[N];\nint dfs(int S) {\n\tif (dp[S]) return dp[S];\n\tint ret = __builtin_popcount(S) - 1;\n\tfor (int T = (S - 1) & S; T; T = (T - 1) & S)\n\t\tif (!xorv[T]) ret = std::min(ret, dfs(T) + dfs(S ^ T));\n\treturn dp[S] = ret;\n}\n\nint n, x, y, z, v[N], c[22], ans, msk;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z), x++, y++;\n\t\tx[v] ^= z, y[v] ^= z;\n\t}\n\tfor (int i = 1; i <= n; i++) i[v][c]++;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tans += i[c] / 2;\n\t\tmsk |= (i[c] & 1) << (i - 1);\n\t}\n\tfor (int S = 0; S < 32768; S++)\n\t\tfor (int j = 1; j <= 15; j++)\n\t\t\tif ((S >> (j - 1)) & 1) xorv[S] ^= j;\n\tprintf(\"%d\", ans + (msk ? dfs(msk) : 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 2e5 + 5; \nint N, val[MAX_N], f[MAX_N]; \nint ans, S, cnt[20], sum[MAX_N]; \nint main () { \n    N = gi(); \n    for (int i = 1; i < N; i++) {\n        int u = gi(), v = gi(), w = gi(); \n        val[u] ^= w, val[v] ^= w; \n    } \n    for (int i = 0; i < N; i++) ++cnt[val[i]]; \n    for (int i = 1; i <= 15; i++) ans += (cnt[i] >> 1), S |= (cnt[i] & 1) << (i - 1); \n    for (int i = 1; i < (1 << 15); i++) f[i] = f[i >> 1] + (i & 1); \n    for (int i = 1; i < (1 << 15); i++) --f[i]; \n    for (int i = 1; i < (1 << 15); i++) \n        for (int j = 0; j < 15; j++) if ((i >> j) & 1) sum[i] ^= (j + 1); \n    for (int i = 1; i < (1 << 15); i++) \n        for (int j = (i - 1) & i; j; j = (j - 1) & i) \n            if (!sum[j]) f[i] = min(f[i], f[j] + f[i ^ j]); \n    printf(\"%d\\n\", f[S] + ans); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<set>\n#define ll long long\n#define maxn 200005\n#define re register\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nint a[maxn],cnt[16],ans;\nint b[16],cnt1,sz[maxn],sz2[maxn],dp[maxn];\n\ninline int gs(int sta)\n{\n\tfor(int i=1;i<=cnt1;i++) if((sta&(1<<(i-1)))) sz[sta]^=b[i];\n}\n\nint main()\n{\n\tint n=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read(),w=read();\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(cnt[a[i]]) cnt[a[i]]=0,ans++;\n\t\telse cnt[a[i]]=1;\n\t}\n\tfor(int i=0;i<=15;i++) if(cnt[i]) b[++cnt1]=i;\n\tint ed=(1<<cnt1)-1;\n\t//for(int i=1;i<=cnt1;i++) cout<<b[i]<<\" \"; cout<<endl;\n\tfor(int i=1;i<=ed;i++) gs(i),sz2[i]=sz2[i>>1]+1;\n\tfor(int i=1;i<=ed;i++) dp[i]=sz2[i]-1;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<sz[i]<<\" \"<<sz2[i]<<endl;\n\tfor(int i=1;i<=ed;i++)\n\t{\n\t\tif(sz[i]==0) continue;\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(sz[j]==0) dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t//else dp[i]=min(dp[i],sz2[j]+sz2[i^j]+1);\n\t\t}\n\t}\n\tcout<<dp[ed]+ans<<endl;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<dp[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxn], dp[1 << 16];\nll cnt[maxn];\nll ans;\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << (i - 1));\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[init] = 0;\n    for(int i = 15;i > 0;i--){\n        for(int S = 0;S < (1 << 15);S++){\n            ll cnt = 0;\n            for(int k = 0;k < 15;k++){\n                if((S >> k) & 1) cnt++;\n            }\n            if(cnt != i) continue;\n            // cout << cnt << \" \" << S << endl;\n            for(int k = 0;k < 15;k++){\n                if(!((S >> k) & 1)) continue;\n                for(int w = 0;w < 15;w++){\n                    if(k == w){\n                        dp[S ^ (1 << k)] = min(dp[S ^ (1 << k)], dp[S] + 1);\n                        continue;\n                    }\n                    if(!((S >> w) & 1)) continue;\n                    ll newnum = ((k + 1) ^ (w + 1)) - 1;\n                    if(((S >> newnum) & 1) == 1){\n                        dp[(S ^ (1 << k) ^ (1 << w)) ^ (1 << newnum)] = \n                        min(dp[S ^ (1 << k) ^ (1 << w) ^ (1 << newnum)], dp[S] + 2);\n                    } else {\n                        dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)] = \n                        min(dp[(S ^ (1 << k) ^ (1 << w)) | (1 << newnum)], dp[S] + 1);\n                    }\n                }\n            }\n        }\n    }\n    ans += dp[0];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\n\nint N;\nvector<pii> gg[MN], g[MN];\nint ret;\n\nvoid pre(int v, int p)\n{\n\tfor (pii e : gg[v]) if (e.fi != p) {\n\t\tg[v].eb(e);\n\t\tpre(e.fi, v);\n\t}\t\n}\n\nint dfs(int v)\n{\n\tvi vec;\n\tvi cnt(16);\n\n\tfor (pii e : g[v]) {\n\t\tint res = dfs(e.fi);\n\t\t++cnt[ret ^ e.se];\n\t}\n\n\tint xo = 0;\n\n\trep(i, 16) {\n\t\tret += cnt[i] / 2;\n\t\tif (cnt[i] & 1) {\n\t\t\txo ^= i;\n\t\t}\n\t}\n\n\tif (v == 0) {\n\t\trep(i, 16) ret += cnt[i] & 1;\n\t}\n\n\treturn xo;\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgg[x].eb(y, a);\n\t\tgg[y].eb(x, a);\n\t}\n\n\tpre(0, -1);\n\tdfs(0);\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ninline int Min(int x,int y){return x<y?x:y;}\nint n,a[100000];\nint s[16],Ans,S;\nint f[1<<16];\nint main(){\n\tint x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i) scanf(\"%d%d%d\",&x,&y,&z), a[x]^=z, a[y]^=z;\n\tfor(int i=0;i<n;++i) if(a[i]) Ans+=s[a[i]], s[a[i]]^=1;\n\tfor(int i=1;i<16;++i) S^=s[i]<<i;\n\tfor(int l=1;l<=15;++l) for(int i=1;i<1<<16;++i) if(__builtin_popcount(i)==l&&(i&1)==0){\n\t\tf[i]=(-1u)>>1;\n\t\tfor(int j=1;j<16;++j) if(i>>j&1)\n\t\t\tfor(int k=j+1;k<16;++k) if(i>>k&1)\n\t\t\t\tf[i]=Min(f[i],f[i^(1<<j)^(1<<k)^(1<<(j^k))]+1+(i>>(j^k)&1));\n\t}\n\tprintf(\"%d\",Ans+f[S]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define b(x) ((x)==0?0:(1<<((x)-1)))\n#define lb(x) ((x)&(-(x)))\nconst int nMaxn = 15, nMaxs = 32768;\nint N, nXorperp[nMaxn] = {0}, bRec[nMaxs];\nint bCalcable[nMaxs], bExibits[nMaxs];\nint nStstat = 0, bOutsteps = 0;\n\nint dfs(int vCur) {\n    if (bRec[vCur] != -1) return bRec[vCur];\n    int& vRes = bRec[vCur];\n    vRes = bExibits[vCur]-1;\n    \n    int bPos = lb(vCur);\n    for (int vSpl=(vCur-1)&vCur; vSpl; vSpl=(vSpl-1)&vCur) {\n        if ((vSpl&bPos)&&bCalcable[vSpl]&&bCalcable[vCur^vSpl]) {\n            vRes = min(vRes, dfs(vSpl)+dfs(vCur^vSpl));\n        }\n    }\n    \n    return vRes;\n}\n\ninline void check(int vStat) {\n    int bCov = 0, bBit = 0;\n    int vCopied = vStat;\n    while (vCopied) {\n        ++bBit;\n        if (vCopied&1) ++bExibits[vStat], bCov^=bBit;\n        vCopied >>= 1;\n    }\n    bCalcable[vStat] = bCov==0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N;\n    int u, v, w;\n    for (int i=1; i<N; ++i) \n        cin >> u >> v >> w,\n        nXorperp[u] ^= w,\n        nXorperp[v] ^= w;\n    for (int i=0; i<N; ++i)\n        nStstat ^= b(nXorperp[i]),\n        bOutsteps += nXorperp[i]&&!(nStstat&b(nXorperp[i]));\n    for (int i=0; i<nMaxs; ++i) \n        bRec[i] = -1,\n        check(i);\n    cout << max(0, dfs(nStstat)+bOutsteps) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nvector<P>edge[100005];\nint cnt[100005];\nint num[16],ret;\nint dp[(1<<16)];\nbool ok[(1<<16)];\nint main(){\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tedge[a].pb(mp(b,c));\n\t\tedge[b].pb(mp(a,c));\n\t}\n\trep(i,n){\n\t\trep(j,edge[i].size()){\n\t\t\tcnt[i] ^= edge[i][j].sc;\n\t\t}\n\t\tif(cnt[i]){\n\t\t\tnum[cnt[i]]++;\n\t\t\tret++;\n\t\t}\n\t}\n\tint mask = 0;\n\tfor(int i=1;i<16;i++){\n\t\tret -= num[i]/2;\n\t\tnum[i]%=2;\n\t\tif(num[i] == 1) mask |= (1<<i);\n\t}\n\tdp[0] = 0;\n\trep(i,(1<<16)){\n\t\tint v = 0;\n\t\trep(j,16) if(((i>>j)&1)) v ^= j;\n\t\tif(!v) ok[i] = 1;\n\t}\n\tfor(int i=1;i<(1<<16);i++){\n\t\tint x = i;\n\t\tdo{\n\t\t\tx = (x-1)&i;\n\t\t\tif(ok[x]){\n\t\t\t\tdp[i] = max(dp[i],dp[x]+dp[i-x]);\n\t\t\t}\n\t\t}while(x);\n\t\tdp[i] = max(dp[i],1);\n\t}\n\tret -= dp[mask];\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;const int N=2*1e5+10;\nint w[N];int d[N];int cnt[20];int res;int n;int st;bool book[N];\nstruct data{int v;int cf;};int sxr[N]; \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,u,v,va;i<n;i++){scanf(\"%d%d%d\",&u,&v,&va);w[u]^=va;w[v]^=va;}\n    for(int i=0;i<n;i++){cnt[w[i]]++;}\n    for(int i=1;i<=15;i++)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\t\n    for(int i=1;i<(1<<15);i++)d[i]=d[i>>1]+(i&1);\n    for(int i=1;i<(1<<15);i++)d[i]-=1;\n    for(int i=1;i<(1<<15);i++)\n        for(int j=0;j<15;j++)if((i>>j)&1)sxr[i]^=(j+1);\n    for(int i=1;i<(1<<15);i++)\n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)\n            if(sxr[k]==0)d[i]=min(d[i],d[k]+d[i^k]);\n    }printf(\"%d\",res+d[st]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n;\nvector<pair<int,int> > g[N];\nvector<int> sons[N];\nint val[N];\nint used[N];\n\nvoid dfs(int v,int par_cost=0){\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i].first;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tint cost=g[v][i].second;\n\t\tsons[v].push_back(to);\n\t\tval[to]=val[v];\n\t\tdfs(to,cost);\n\t}\n\n\tfor (int i=0;i<sons[v].size();i++){\n\t\tint to=sons[v][i];\n\t\tval[v]^=val[to];\n\t}\n\tval[v]^=par_cost;\n}\n\nint ans;\nint cnt[N];\nint pcount[N];\nint dp[N];\nint mem_xor[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(make_pair(b,c));\n\t\tg[b].push_back(make_pair(a,c));\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tpcount[i]=pcount[i/2]+i%2;\n\t}\n\n\tfor (int mask=0;mask<(1<<16);mask++){\n\t\tint here=0;\n\t\tfor (int i=0;i<16;i++){\n\t\t\tif (mask&(1<<i))\n\t\t\t\there^=i;\n\t\t}\n\t\tmem_xor[mask]=here;\n\t}\n\n\tdfs(0);\n\n\tfor (int i=1;i<n;i++){\n\t//\tcout<<val[i]<<endl;\n\t\tcnt[val[i]]++;\n\t}\n\n\tfor (int i=0;i<16;i++){\n\t\tif (i!=0)\n\t\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\n\t/*for (int i=0;i<16;i++){\n\t\tcout<<i<<\" \"<<cnt[i]<<endl;\n\t}*/\n\n\tdp[0]=0;\n\n\tfor (int mask=1;mask<(1<<16);mask++){\n\t\tint smask=mask;\n\t\tdp[mask]=1e9;\n\t\twhile (true){\n\t\t\tif (smask==0)\n\t\t\t\tbreak;\n\t\t\tint here=pcount[smask];\n\t\t\tint is_good=mem_xor[smask];\n\t\t\tif (is_good==0)\n\t\t\t\there--;\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+here);\n\t\t\tsmask=(smask-1);\n\t\t\tsmask&=mask;\n\t\t}\n\t}\n\n\tint interesting=0;\n\tfor (int i=0;i<16;i++){\n\t\tif (cnt[i])\n\t\t\tinteresting|=(1<<i);\n\t}\n\tcout<<ans+dp[interesting]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst int N=1e5+5;\nconst int M=1<<16+3;\nint dp[M],n;\nbool good[M];int ans;\nint num[N],cnt[20],mask;\nvoid init()\n{\n\tfor(int i=1;i<(1<<16);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=1;j<16;j++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tsum^=j;\n\t\tif(sum==0)\n\t\t{\n\t\t\tgood[i]=true;\n\t\t}\n\t}\n\treturn;\n}//Accepted\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}//Accepted\n\tfor(int i=0;i<n;i++)\n\t\tif(num[i])\n\t\t\tcnt[num[i]]++;\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\tif(cnt[i])\n\t\t{\n\t\t\tans++;\n\t\t\tmask+=(1<<i);\n\t\t}\n\t}\n\tinit();//Accetped\n\tfor(int i=0;i<=mask;i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t{\n\t\t\tif(good[j])\n\t\t\t{\n\t\t\t\tdp[i]=max(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans-dp[mask]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nconst int maxm = 1 << 15 + 10;\n\nint n, ans, state, tot;\nint val[maxn], cnt[20], f[maxm], s[maxn], sum[maxm];\n// sumè¡¨ç¤ºæ¯ä¸ªéåçå¼æå¼\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint x, y, z;\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\tx++, y++;\n\t\tval[x] ^= z, val[y] ^= z;\n\t}\n\tfor (int i = 1; i <= n; ++i) cnt[val[i]]++;\n\tans = n; ans -= cnt[0];\n\tfor (int i = 1; i <= 15; ++i) {\n\t\tans -= cnt[i] / 2 ;\n\t\tstate += (cnt[i] & 1) * (1 << i);\n\t}\n\ttot = 1 << 15;\n\tfor (int i = 1; i < tot; ++i) {\n\t\tint tmp = 0;\n\t\tfor (int j = 1; j <= 15; ++j) {\n\t\t\tif (i & (1 << (j - 1))) tmp ^= j;\n\t\t}\n\t\tsum[i] = tmp;\n\t}\n\tfor (int i = 1; i < tot; ++i) {\n\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\tif (!sum[i]) f[i] = max(f[i], f[i ^ j] + 1);\n\t\t}\n\t}\n\tans -= f[state];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint lowbit(int x){return x&-x;}\nint a[100010],c[20],v[32768],s[32768],f[32768];\nint main(){\n\tint n,i,j,x,y,z,res,M;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x+1]^=z;\n\t\ta[y+1]^=z;\n\t}\n\tfor(i=1;i<=n;i++)c[a[i]]++;\n\tres=M=0;\n\tres+=c[0];\n\tfor(i=1;i<16;i++){\n\t\tres+=c[i]/2;\n\t\tif(c[i]&1)v[1<<(M++)]=i;\n\t}\n\tfor(i=1;i<1<<M;i++)s[i]=s[i^lowbit(i)]^v[lowbit(i)];\n\tfor(i=1;i<1<<M;i++){\n\t\tif(s[i]==0){\n\t\t\tfor(j=i;j;j=(j-1)&i){\n\t\t\t\tif(s[j]==0)f[i]=max(f[i],f[i^j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",n-(res+f[(1<<M)-1]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define F(i,j,k) for(int i=(j);i<=(k);i++)\n#define DF(i,j,k) for(int i=(j);i>=(k);i--)\nusing namespace std;\ntemplate<typename T>inline void read(T &n){\n    T w=1;n=0;char ch=getchar();\n    while(!isdigit(ch)&&ch!=EOF){if(ch=='-')w=-1;ch=getchar();}\n    while(isdigit(ch)&&ch!=EOF){n=(n<<1)+(n<<3)+(ch^48);ch=getchar();}\n    n*=w;\n}\ntemplate<typename T>inline void write(T x){\n    ull y=0;\n    T l=0;\n    if(x<0){x=-x;putchar('-');}\n    if(!x){putchar(48);return;}\n    while(x){y=y*10+x%10;x/=10;l++;}\n    while(l){putchar(y%10+48);y/=10;l--;}\n}\ntemplate<typename T>inline void writeln(T x){\n    write(x);\n    puts(\"\");\n}\ntemplate<typename T>inline void writes(T x){\n    write(x);\n    putchar(' ');\n}\ntemplate<typename T>inline void checkmax(T &a,T b){a=a>b?a:b;}\ntemplate<typename T>inline void checkmin(T &a,T b){a=a<b?a:b;}\nint w[101000],h[22],dp[(1<<15)+1],s[(1<<15)+1],ans,st;\nint main(){\n \tint n;read(n);\n \tF(i,1,n-1){int x,y,a;read(x);read(y);read(a);w[x]^=a;w[y]^=a;}\n \tF(i,0,n-1)h[w[i]]++;\n \tF(i,1,15){ans+=h[i]/2;h[i]%=2;st^=(1<<(i-1))*h[i];}\n \tF(i,1,(1<<15))dp[i]=dp[i>>1]+(i&1);\n \tF(i,1,(1<<15))dp[i]--;\n \tF(i,1,(1<<15))\n \t\tF(j,0,14)\n \t\t\tif(i&(1<<j))s[i]^=(j+1);\n \tF(i,1,(1<<15)){\n \t\tif(s[i])continue;\n \t\tfor(int k=(i-1)&i;k;k=(k-1)&i){if(!s[k])checkmin(dp[i],dp[k]+dp[i^k]);}\n \t}\n \twriteln(ans+dp[st]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\tvll c(N, 0);\n\trep(i, N - 1){\n\t\tll x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tc[x] ^= a;\n\t\tc[y] ^= a;\n\t}\n\n\tll M = 16;\n\n\tvll cnt(M, 0);\n\trep(i, N)cnt[c[i]]++;\n\n\tll comp = 0;\n\tll X = 0;\n\tcomp += cnt[0];\n\n\trepn(i, M - 1) {\n\t\tcomp += cnt[i] / 2;\n\t\tif (cnt[i] % 2 == 1) { X += 1 << i; }\n\t}\n\n\tvll zero(1 << M, 0);\n\trep(i, 1 << M) {\n\t\tll t = 0;\n\t\trep(j, M) {\n\t\t\tif ((i >> j) & 1) { t ^= j; }\n\t\t}\n\t\tif (t == 0) { zero[i] = 1; }\n\t}\n\n\tvll dp(1 << M, 0);\n\trepn(i, (1 << M) - 1) {\n\t\tfor (ll j = i; j > 0; j = (j - 1) & i) {\n\t\t\tif (zero[j] == 0) { continue; }\n\t\t\tll k = i & ~j;\n\t\t\tdp[i] = max(dp[i], dp[k] + 1);\n\t\t}\n\t}\n\n\tcomp += dp[X];\n\n\tcout << N - comp << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n};\nstruct state {\n\tint bit, cost;\n};\nbool operator>(const state& s1, const state& s2) {\n\treturn s1.cost > s2.cost;\n}\nint solve(int bit) {\n\tpriority_queue<state, vector<state>, greater<state> > que; que.push(state{ bit, 0 });\n\tvector<int> d(1 << 15, -1); d[bit / 2] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.top().bit; que.pop();\n\t\tfor (int i = 1; i < 16; ++i) {\n\t\t\tfor (int j = 1; j < 16; ++j) {\n\t\t\t\tif (!((u >> j) & 1)) continue;\n\t\t\t\tfor (int k = 1; k < j; ++k) {\n\t\t\t\t\tif (!((u >> k) & 1)) continue;\n\t\t\t\t\tint delta = 1;\n\t\t\t\t\tint nxtbit = u - (1 << j) - (1 << k);\n\t\t\t\t\tif ((nxtbit >> (j ^ i)) & 1) ++delta; nxtbit ^= 1 << (j ^ i);\n\t\t\t\t\tif ((nxtbit >> (k ^ i)) & 1) ++delta; nxtbit ^= 1 << (k ^ i);\n\t\t\t\t\tif (nxtbit & 1) nxtbit -= 1;\n\t\t\t\t\tif (d[nxtbit / 2] == -1 || d[nxtbit / 2] > d[u / 2] + delta) {\n\t\t\t\t\t\td[nxtbit / 2] = d[u / 2] + delta;\n\t\t\t\t\t\tque.push(state{ nxtbit, d[nxtbit / 2] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[0];\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tG[x].push_back(edge{ y, a });\n\t\tG[y].push_back(edge{ x, a });\n\t}\n\tvector<int> seq = { 0 };\n\tfunction<void(int, int)> make_seq = [&](int pos, int pre) {\n\t\tfor (edge e : G[pos]) {\n\t\t\tif (e.to != pre) {\n\t\t\t\tseq.push_back(e.cost);\n\t\t\t\tmake_seq(e.to, pos);\n\t\t\t\tseq.push_back(e.cost);\n\t\t\t}\n\t\t}\n\t};\n\tmake_seq(0, -1);\n\tseq.push_back(0);\n\tint bit = 0, off = 0;\n\tfor (int i = 1; i < seq.size(); ++i) {\n\t\tint d = seq[i] ^ seq[i - 1];\n\t\tif (d != 0 && ((bit >> d) & 1)) ++off;\n\t\tbit ^= 1 << d;\n\t}\n\tint ans = solve(bit);\n\tcout << ans + off << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<set>\n#define ll long long\n#define maxn 200005\n#define re register\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nint a[maxn],cnt[16],ans;\nint b[16],cnt1,sz[maxn],sz2[maxn],dp[maxn];\n\ninline int gs(int sta)\n{\n\tfor(int i=1;i<=cnt1;i++) if((sta&(1<<(i-1)))) sz[sta]^=b[i];\n}\n\nint main()\n{\n\tint n=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read(),w=read();\n\t\ta[u]^=w; a[v]^=w;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(a[i]==0) continue;\n\t\tif(cnt[a[i]]) cnt[a[i]]=0,ans++;\n\t\telse cnt[a[i]]=1;\n\t}\n\tfor(int i=1;i<=15;i++) if(cnt[i]) b[++cnt1]=i;\n\tint ed=(1<<cnt1)-1;\n\t//for(int i=1;i<=cnt1;i++) cout<<b[i]<<\" \"; cout<<endl;\n\tfor(int i=1;i<=ed;i++) gs(i),sz2[i]=sz2[i>>1]+1;\n\tfor(int i=1;i<=ed;i++) dp[i]=sz2[i]-1;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<sz[i]<<\" \"<<sz2[i]<<endl;\n\tfor(int i=1;i<=ed;i++)\n\t{\n\t\tif(sz[i]!=0) continue;\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tif((i&j)!=j) continue;\n\t\t\tif(sz[j]==0) dp[i]=min(dp[i],dp[j]+dp[i^j]);\n\t\t\t//else dp[i]=min(dp[i],sz2[j]+sz2[i^j]+1);\n\t\t}\n\t}\n\tcout<<dp[ed]+ans<<endl;\n\t//for(int i=0;i<=ed;i++) cout<<i<<\" \"<<dp[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nvector<pair<int,int>> G[MAX];\nvector<int> two[MAX];\nint A[MAX],sum[MAX];\n\nvoid DFS(int u,int p){\n    for(auto to:G[u]){\n        if(to.fi==p) continue;\n        A[to.fi]=to.se;\n        DFS(to.fi,u);\n        sum[u]^=sum[to.fi];\n        A[u]^=sum[to.fi];\n    }\n    sum[u]^=A[u];\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[a].push_back(mp(b,c));\n        G[b].push_back(mp(a,c));\n    }\n    \n    DFS(0,-1);\n    \n    vector<int> cnt(16);\n    \n    for(int i=1;i<N;i++){\n        cnt[A[i]]++;\n    }\n    int ans=0;\n    \n    for(int i=1;i<16;i++){\n        ans+=cnt[i]/2;\n        cnt[i]&=1;\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            if(cnt[i]&&cnt[j]&&cnt[i^j]){\n                ans+=2;\n                cnt[i]=0;\n                cnt[j]=0;\n                cnt[i^j]=0;\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[i^j^k]){\n                    ans+=3;\n                    cnt[i]=0;\n                    cnt[j]=0;\n                    cnt[k]=0;\n                    cnt[i^j^k]=0;\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        for(int j=i+1;j<16;j++){\n            for(int k=j+1;k<16;k++){\n                for(int l=k+1;l<16;l++){\n                    if(cnt[i]&&cnt[j]&&cnt[k]&&cnt[l]&&cnt[i^j^k^l]){\n                        ans+=4;\n                        cnt[i]=0;\n                        cnt[j]=0;\n                        cnt[k]=0;\n                        cnt[l]=0;\n                        cnt[i^j^k^l]=0;\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int i=1;i<16;i++){\n        if(cnt[i]) ans++;\n    }\n    \n    //for(int i=1;i<N;i++) cout<<A[i]<<endl;\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+1;\n\nint val[N];\nint n;\n\ninline int read(){\n   int out = 0;char ch;\n   for(ch = getchar();ch > '9' || ch < '0';ch = getchar());\n   for(;ch >= '0' && ch <= '9';ch = getchar())\n      out = (out<<3)+(out<<1)+(ch&15);\n   return out;\n}\nstruct edge{\n   int tail[N],to[N],nxt[N],tot;\n   inline void add_edge(int x,int y){\n      to[++tot] = y; nxt[tot] = tail[x]; tail[x] = tot;\n   }\n}e;\n\nint v[16],f[1<<17];\nint deg[N];\nint main(){\n   n = read();\n   for(int i = 1;i < n; ++i){\n      int u,v,w;\n      u = read(); v = read(); w = read();deg[u] ^= w; deg[v] ^= w;\n   }\n   for(int i = 0;i < n; ++i)v[deg[i]] += 1;\n   int ans = 0;\n   int ps = 0;\n   for(int i = 0;i < 16; ++i){\n      if(i)ans += v[i]/2; v[i] %= 2;\n      if(i)ps |= (1<<(i-1))*v[i];\n      //cerr << i <<' ' << v[i] << ' ' << deg[i] << endl;\n   }\n   //cerr << ps <<' ' << ans << endl;\n   memset(f,0x3f,sizeof f);\n   f[ps] = 0;\n\n   for(int i = (1<<16)-1;i > 0; --i){\n      for(int j = 0;j < 15; ++j)\n         for(int k = j+1;k < 15; ++k){\n            if(((1 << j) & i) && ((1<<k)&i)){\n               int pi = (i ^ (1<<(j+1))); pi ^= (1<<(k+1));\n               int w = (j^k);\n               if(pi & (1<<(w-1)))f[pi^(1<<(w-1))] = min(f[pi^(1<<(w-1))],f[i]+2);\n               else f[pi^(1<<(w-1))] = min(f[pi^(1<<(w-1))],f[i]+1);\n            }\n         }\n   }\n   printf(\"%d\\n\",f[0]+ans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <utility>\n#include <list>\n\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <bitset>\n#include <complex>\n#include <climits>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\ntypedef pair<double, double> dd;\ntypedef unsigned long long ull;\n#define mp make_pair\n#define pb push_back\n\n#define debug(x) cerr << #x << \" = \" << x << \" \"\n\nconst int N = 1e5;\nint val[N];\nconst int B = 4;\nconst int MB = 1<<B;\nconst int MMB = 1<<MB;\nint cnt[MB];\nint d[MMB];\nint bitvalue[MMB];\nint bitcnt[MMB];\nint main()\n{\n  int n; scanf(\"%d\", &n);\n  for (int i = 1; i <= n-1; ++i)\n    {\n      int u, v, x;\n      scanf(\"%d %d %d\", &u, &v, &x);\n      val[u] ^= x;\n      val[v] ^= x;\n    }\n  for (int i = 0; i < n; ++i) ++cnt[val[i]];\n  int ans = 0;\n  for (int i = 0; i < MB; ++i) bitvalue[1<<i] = i;\n  for (int i = 1; i < MB; ++i) ans += cnt[i]/2, cnt[i] %= 2;\n  for (int i = 1; i < MMB; ++i)\n    {\n      int lb = i&-i;\n      bitvalue[i] = bitvalue[i^lb] ^ bitvalue[lb];\n      bitcnt[i] = bitcnt[i>>1] + (i&1);\n      d[i] = MB;\n      for (int sub = i; sub; sub = (sub-1)&i)\n\tif (bitvalue[sub] == 0)\n\t  d[i] = min(d[i], bitcnt[sub] -1 + d[i^sub]);\n    }\n  int mask = 0;\n  for (int i = 1; i < n; ++i) mask ^= cnt[i] << i;\n  printf(\"%d\\n\", d[mask] + ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=100004;\nint n,m,a[N],f[N],ans;\nint main()\n{\n\tf[7]=f[25]=f[42]=f[52]=f[76]=f[82]=f[97]=f[385]=f[642]=f[772]=f[1156]=f[1282]=f[1537]=f[2184]=f[2320]=f[2592]=f[3136]=f[4240]=f[4360]=f[4672]=f[5152]=f[6145]=f[8352]=f[8512]=f[8712]=f[9232]=f[10242]=f[12292]=f[16576]=f[16672]=f[16912]=f[17416]=f[18436]=f[20482]=f[24577]=2;\n\tf[30]=f[45]=f[51]=f[75]=f[85]=f[102]=f[120]=f[390]=f[408]=f[480]=f[645]=f[680]=f[720]=f[771]=f[816]=f[840]=f[1155]=f[1200]=f[1224]=f[1285]=f[1320]=f[1360]=f[1542]=f[1560]=f[1632]=f[1920]=f[2193]=f[2210]=f[2244]=f[2313]=f[2340]=f[2370]=f[2570]=f[2580]=f[2625]=f[3084]=f[3090]=f[3105]=f[4233]=f[4260]=f[4290]=f[4369]=f[4386]=f[4420]=f[4620]=f[4626]=f[4641]=f[5130]=f[5140]=f[5185]=f[6150]=f[6168]=f[6240]=f[6528]=f[7680]=f[8330]=f[8340]=f[8385]=f[8460]=f[8466]=f[8481]=f[8721]=f[8738]=f[8772]=f[9225]=f[9252]=f[9282]=f[10245]=f[10280]=f[10320]=f[10880]=f[11520]=f[12291]=f[12336]=f[12360]=f[13056]=f[13440]=f[16524]=f[16530]=f[16545]=f[16650]=f[16660]=f[16705]=f[16905]=f[16932]=f[16962]=f[17425]=f[17442]=f[17476]=f[18435]=f[18480]=f[18504]=f[19200]=f[19584]=f[20485]=f[20520]=f[20560]=f[21120]=f[21760]=f[24582]=f[24600]=f[24672]=f[24960]=f[26112]=f[30720]=3;\n\tf[427]=f[428]=f[434]=f[437]=f[458]=f[461]=f[467]=f[468]=f[667]=f[668]=f[689]=f[694]=f[713]=f[718]=f[739]=f[740]=f[794]=f[797]=f[809]=f[814]=f[849]=f[854]=f[866]=f[869]=f[1178]=f[1181]=f[1193]=f[1198]=f[1233]=f[1238]=f[1250]=f[1253]=f[1307]=f[1308]=f[1329]=f[1334]=f[1353]=f[1358]=f[1379]=f[1380]=f[1579]=f[1580]=f[1586]=f[1589]=f[1610]=f[1613]=f[1619]=f[1620]=f[2191]=f[2198]=f[2213]=f[2236]=f[2243]=f[2266]=f[2281]=f[2288]=f[2318]=f[2327]=f[2339]=f[2362]=f[2373]=f[2396]=f[2408]=f[2417]=f[2573]=f[2579]=f[2599]=f[2617]=f[2630]=f[2648]=f[2668]=f[2674]=f[2956]=f[2962]=f[2977]=f[3008]=f[3083]=f[3093]=f[3110]=f[3128]=f[3143]=f[3161]=f[3178]=f[3188]=f[3466]=f[3476]=f[3488]=f[3521]=f[3721]=f[3728]=f[3748]=f[3778]=f[3848]=f[3857]=f[3874]=f[3908]=f[4238]=f[4247]=f[4259]=f[4282]=f[4293]=f[4316]=f[4328]=f[4337]=f[4367]=f[4374]=f[4389]=f[4412]=f[4419]=f[4442]=f[4457]=f[4464]=f[4619]=f[4629]=f[4646]=f[4664]=f[4679]=f[4697]=f[4714]=f[4724]=f[5002]=f[5012]=f[5024]=f[5057]=f[5133]=f[5139]=f[5159]=f[5177]=f[5190]=f[5208]=f[5228]=f[5234]=f[5516]=f[5522]=f[5537]=f[5568]=f[5768]=f[5777]=f[5794]=f[5828]=f[5897]=f[5904]=f[5924]=f[5954]=f[6187]=f[6188]=f[6194]=f[6197]=f[6218]=f[6221]=f[6227]=f[6228]=f[6787]=f[6788]=f[6832]=f[6856]=f[6914]=f[6917]=f[6952]=f[6992]=f[7298]=f[7301]=f[7336]=f[7376]=f[7427]=f[7428]=f[7472]=f[7496]=f[8333]=f[8339]=f[8359]=f[8377]=f[8390]=f[8408]=f[8428]=f[8434]=f[8459]=f[8469]=f[8486]=f[8504]=f[8519]=f[8537]=f[8554]=f[8564]=f[8719]=f[8726]=f[8741]=f[8764]=f[8771]=f[8794]=f[8809]=f[8816]=f[9097]=f[9104]=f[9124]=f[9154]=f[9230]=f[9239]=f[9251]=f[9274]=f[9285]=f[9308]=f[9320]=f[9329]=f[9608]=f[9617]=f[9634]=f[9668]=f[9868]=f[9874]=f[9889]=f[9920]=f[9994]=f[10004]=f[10016]=f[10049]=f[10267]=f[10268]=f[10289]=f[10294]=f[10313]=f[10318]=f[10339]=f[10340]=f[10627]=f[10628]=f[10672]=f[10696]=f[11009]=f[11014]=f[11032]=f[11104]=f[11393]=f[11398]=f[11416]=f[11488]=f[11779]=f[11780]=f[11824]=f[11848]=f[12314]=f[12317]=f[12329]=f[12334]=f[12369]=f[12374]=f[12386]=f[12389]=f[12674]=f[12677]=f[12712]=f[12752]=f[12929]=f[12934]=f[12952]=f[13024]=f[13569]=f[13574]=f[13592]=f[13664]=f[13826]=f[13829]=f[13864]=f[13904]=f[14476]=f[14482]=f[14497]=f[14528]=f[14602]=f[14612]=f[14624]=f[14657]=f[14857]=f[14864]=f[14884]=f[14914]=f[15368]=f[15377]=f[15394]=f[15428]=f[16523]=f[16533]=f[16550]=f[16568]=f[16583]=f[16601]=f[16618]=f[16628]=f[16653]=f[16659]=f[16679]=f[16697]=f[16710]=f[16728]=f[16748]=f[16754]=f[16910]=f[16919]=f[16931]=f[16954]=f[16965]=f[16988]=f[17000]=f[17009]=f[17288]=f[17297]=f[17314]=f[17348]=f[17423]=f[17430]=f[17445]=f[17468]=f[17475]=f[17498]=f[17513]=f[17520]=f[17801]=f[17808]=f[17828]=f[17858]=f[18058]=f[18068]=f[18080]=f[18113]=f[18188]=f[18194]=f[18209]=f[18240]=f[18458]=f[18461]=f[18473]=f[18478]=f[18513]=f[18518]=f[18530]=f[18533]=f[18818]=f[18821]=f[18856]=f[18896]=f[19073]=f[19078]=f[19096]=f[19168]=f[19713]=f[19718]=f[19736]=f[19808]=f[19970]=f[19973]=f[20008]=f[20048]=f[20507]=f[20508]=f[20529]=f[20534]=f[20553]=f[20558]=f[20579]=f[20580]=f[20867]=f[20868]=f[20912]=f[20936]=f[21249]=f[21254]=f[21272]=f[21344]=f[21633]=f[21638]=f[21656]=f[21728]=f[22019]=f[22020]=f[22064]=f[22088]=f[22666]=f[22676]=f[22688]=f[22721]=f[22796]=f[22802]=f[22817]=f[22848]=f[23048]=f[23057]=f[23074]=f[23108]=f[23561]=f[23568]=f[23588]=f[23618]=f[24619]=f[24620]=f[24626]=f[24629]=f[24650]=f[24653]=f[24659]=f[24660]=f[25219]=f[25220]=f[25264]=f[25288]=f[25346]=f[25349]=f[25384]=f[25424]=f[25730]=f[25733]=f[25768]=f[25808]=f[25859]=f[25860]=f[25904]=f[25928]=f[26761]=f[26768]=f[26788]=f[26818]=f[26888]=f[26897]=f[26914]=f[26948]=f[27148]=f[27154]=f[27169]=f[27200]=f[27658]=f[27668]=f[27680]=f[27713]=f[28808]=f[28817]=f[28834]=f[28868]=f[28937]=f[28944]=f[28964]=f[28994]=f[29194]=f[29204]=f[29216]=f[29249]=f[29708]=f[29714]=f[29729]=f[29760]=4;\n\tf[127]=f[415]=f[487]=f[505]=f[687]=f[727]=f[762]=f[823]=f[847]=f[892]=f[1207]=f[1231]=f[1276]=f[1327]=f[1367]=f[1402]=f[1567]=f[1639]=f[1657]=f[1927]=f[1945]=f[1962]=f[1972]=f[1996]=f[2002]=f[2017]=f[2235]=f[2269]=f[2286]=f[2365]=f[2395]=f[2422]=f[2622]=f[2667]=f[2677]=f[2955]=f[2965]=f[2982]=f[3000]=f[3166]=f[3181]=f[3187]=f[3469]=f[3475]=f[3526]=f[3544]=f[3726]=f[3747]=f[3781]=f[3816]=f[3862]=f[3877]=f[3907]=f[3952]=f[4285]=f[4315]=f[4342]=f[4411]=f[4445]=f[4462]=f[4702]=f[4717]=f[4723]=f[5005]=f[5011]=f[5062]=f[5080]=f[5182]=f[5227]=f[5237]=f[5515]=f[5525]=f[5542]=f[5560]=f[5782]=f[5797]=f[5827]=f[5872]=f[5902]=f[5923]=f[5957]=f[5992]=f[6175]=f[6247]=f[6265]=f[6535]=f[6553]=f[6570]=f[6580]=f[6604]=f[6610]=f[6625]=f[6810]=f[6825]=f[6865]=f[6882]=f[6940]=f[6961]=f[6985]=f[7012]=f[7324]=f[7345]=f[7369]=f[7396]=f[7450]=f[7465]=f[7505]=f[7522]=f[7687]=f[7705]=f[7722]=f[7732]=f[7756]=f[7762]=f[7777]=f[8065]=f[8382]=f[8427]=f[8437]=f[8542]=f[8557]=f[8563]=f[8763]=f[8797]=f[8814]=f[9102]=f[9123]=f[9157]=f[9192]=f[9277]=f[9307]=f[9334]=f[9622]=f[9637]=f[9667]=f[9712]=f[9867]=f[9877]=f[9894]=f[9912]=f[9997]=f[10003]=f[10054]=f[10072]=f[10287]=f[10327]=f[10362]=f[10650]=f[10665]=f[10705]=f[10722]=f[10887]=f[10905]=f[10922]=f[10932]=f[10956]=f[10962]=f[10977]=f[11052]=f[11058]=f[11082]=f[11092]=f[11436]=f[11442]=f[11466]=f[11476]=f[11527]=f[11545]=f[11562]=f[11572]=f[11596]=f[11602]=f[11617]=f[11802]=f[11817]=f[11857]=f[11874]=f[12162]=f[12343]=f[12367]=f[12412]=f[12700]=f[12721]=f[12745]=f[12772]=f[12972]=f[12978]=f[13002]=f[13012]=f[13063]=f[13081]=f[13098]=f[13108]=f[13132]=f[13138]=f[13153]=f[13447]=f[13465]=f[13482]=f[13492]=f[13516]=f[13522]=f[13537]=f[13612]=f[13618]=f[13642]=f[13652]=f[13852]=f[13873]=f[13897]=f[13924]=f[14212]=f[14475]=f[14485]=f[14502]=f[14520]=f[14605]=f[14611]=f[14662]=f[14680]=f[14862]=f[14883]=f[14917]=f[14952]=f[15240]=f[15382]=f[15397]=f[15427]=f[15472]=f[15760]=f[16032]=f[16192]=f[16606]=f[16621]=f[16627]=f[16702]=f[16747]=f[16757]=f[16957]=f[16987]=f[17014]=f[17302]=f[17317]=f[17347]=f[17392]=f[17467]=f[17501]=f[17518]=f[17806]=f[17827]=f[17861]=f[17896]=f[18061]=f[18067]=f[18118]=f[18136]=f[18187]=f[18197]=f[18214]=f[18232]=f[18487]=f[18511]=f[18556]=f[18844]=f[18865]=f[18889]=f[18916]=f[19116]=f[19122]=f[19146]=f[19156]=f[19207]=f[19225]=f[19242]=f[19252]=f[19276]=f[19282]=f[19297]=f[19591]=f[19609]=f[19626]=f[19636]=f[19660]=f[19666]=f[19681]=f[19756]=f[19762]=f[19786]=f[19796]=f[19996]=f[20017]=f[20041]=f[20068]=f[20356]=f[20527]=f[20567]=f[20602]=f[20890]=f[20905]=f[20945]=f[20962]=f[21127]=f[21145]=f[21162]=f[21172]=f[21196]=f[21202]=f[21217]=f[21292]=f[21298]=f[21322]=f[21332]=f[21676]=f[21682]=f[21706]=f[21716]=f[21767]=f[21785]=f[21802]=f[21812]=f[21836]=f[21842]=f[21857]=f[22042]=f[22057]=f[22097]=f[22114]=f[22402]=f[22669]=f[22675]=f[22726]=f[22744]=f[22795]=f[22805]=f[22822]=f[22840]=f[23062]=f[23077]=f[23107]=f[23152]=f[23440]=f[23566]=f[23587]=f[23621]=f[23656]=f[23944]=f[24256]=f[24352]=f[24607]=f[24679]=f[24697]=f[24967]=f[24985]=f[25002]=f[25012]=f[25036]=f[25042]=f[25057]=f[25242]=f[25257]=f[25297]=f[25314]=f[25372]=f[25393]=f[25417]=f[25444]=f[25756]=f[25777]=f[25801]=f[25828]=f[25882]=f[25897]=f[25937]=f[25954]=f[26119]=f[26137]=f[26154]=f[26164]=f[26188]=f[26194]=f[26209]=f[26497]=f[26766]=f[26787]=f[26821]=f[26856]=f[26902]=f[26917]=f[26947]=f[26992]=f[27147]=f[27157]=f[27174]=f[27192]=f[27552]=f[27661]=f[27667]=f[27718]=f[27736]=f[28096]=f[28296]=f[28432]=f[28822]=f[28837]=f[28867]=f[28912]=f[28942]=f[28963]=f[28997]=f[29032]=f[29197]=f[29203]=f[29254]=f[29272]=f[29632]=f[29707]=f[29717]=f[29734]=f[29752]=f[30112]=f[30352]=f[30472]=f[30727]=f[30745]=f[30762]=f[30772]=f[30796]=f[30802]=f[30817]=f[31105]=f[31362]=f[31492]=f[31876]=f[32002]=f[32257]=5;\n\tf[510]=f[765]=f[891]=f[1275]=f[1405]=f[1662]=f[1950]=f[1965]=f[1971]=f[1995]=f[2005]=f[2022]=f[2040]=f[2295]=f[2415]=f[2655]=f[3015]=f[3033]=f[3038]=f[3050]=f[3053]=f[3059]=f[3060]=f[3135]=f[3495]=f[3513]=f[3518]=f[3563]=f[3564]=f[3570]=f[3573]=f[3735]=f[3770]=f[3773]=f[3803]=f[3804]=f[3825]=f[3830]=f[3855]=f[3899]=f[3900]=f[3930]=f[3933]=f[3945]=f[3950]=f[4335]=f[4471]=f[4671]=f[5031]=f[5049]=f[5054]=f[5099]=f[5100]=f[5106]=f[5109]=f[5215]=f[5575]=f[5593]=f[5598]=f[5610]=f[5613]=f[5619]=f[5620]=f[5775]=f[5819]=f[5820]=f[5850]=f[5853]=f[5865]=f[5870]=f[5911]=f[5946]=f[5949]=f[5979]=f[5980]=f[6001]=f[6006]=f[6270]=f[6558]=f[6573]=f[6579]=f[6603]=f[6613]=f[6630]=f[6648]=f[6813]=f[6830]=f[6839]=f[6863]=f[6870]=f[6885]=f[6908]=f[6939]=f[6959]=f[6966]=f[6990]=f[6999]=f[7011]=f[7034]=f[7323]=f[7343]=f[7350]=f[7374]=f[7383]=f[7395]=f[7418]=f[7453]=f[7470]=f[7479]=f[7503]=f[7510]=f[7525]=f[7548]=f[7710]=f[7725]=f[7731]=f[7755]=f[7765]=f[7782]=f[7800]=f[8070]=f[8088]=f[8108]=f[8114]=f[8138]=f[8148]=f[8160]=f[8415]=f[8511]=f[8823]=f[9111]=f[9146]=f[9149]=f[9179]=f[9180]=f[9201]=f[9206]=f[9327]=f[9615]=f[9659]=f[9660]=f[9690]=f[9693]=f[9705]=f[9710]=f[9927]=f[9945]=f[9950]=f[9962]=f[9965]=f[9971]=f[9972]=f[10023]=f[10041]=f[10046]=f[10091]=f[10092]=f[10098]=f[10101]=f[10365]=f[10653]=f[10670]=f[10679]=f[10703]=f[10710]=f[10725]=f[10748]=f[10910]=f[10925]=f[10931]=f[10955]=f[10965]=f[10982]=f[11000]=f[11039]=f[11051]=f[11061]=f[11085]=f[11091]=f[11111]=f[11129]=f[11423]=f[11435]=f[11445]=f[11469]=f[11475]=f[11495]=f[11513]=f[11550]=f[11565]=f[11571]=f[11595]=f[11605]=f[11622]=f[11640]=f[11805]=f[11822]=f[11831]=f[11855]=f[11862]=f[11877]=f[11900]=f[12165]=f[12188]=f[12200]=f[12209]=f[12233]=f[12240]=f[12260]=f[12411]=f[12699]=f[12719]=f[12726]=f[12750]=f[12759]=f[12771]=f[12794]=f[12959]=f[12971]=f[12981]=f[13005]=f[13011]=f[13031]=f[13049]=f[13086]=f[13101]=f[13107]=f[13131]=f[13141]=f[13158]=f[13176]=f[13470]=f[13485]=f[13491]=f[13515]=f[13525]=f[13542]=f[13560]=f[13599]=f[13611]=f[13621]=f[13645]=f[13651]=f[13671]=f[13689]=f[13851]=f[13871]=f[13878]=f[13902]=f[13911]=f[13923]=f[13946]=f[14211]=f[14234]=f[14249]=f[14256]=f[14280]=f[14289]=f[14306]=f[14535]=f[14553]=f[14558]=f[14570]=f[14573]=f[14579]=f[14580]=f[14631]=f[14649]=f[14654]=f[14699]=f[14700]=f[14706]=f[14709]=f[14871]=f[14906]=f[14909]=f[14939]=f[14940]=f[14961]=f[14966]=f[15249]=f[15254]=f[15266]=f[15269]=f[15299]=f[15300]=f[15344]=f[15375]=f[15419]=f[15420]=f[15450]=f[15453]=f[15465]=f[15470]=f[15753]=f[15758]=f[15779]=f[15780]=f[15810]=f[15813]=f[15848]=f[16010]=f[16013]=f[16019]=f[16020]=f[16065]=f[16070]=f[16088]=f[16139]=f[16140]=f[16146]=f[16149]=f[16161]=f[16166]=f[16184]=f[16575]=f[16735]=f[17007]=f[17295]=f[17339]=f[17340]=f[17370]=f[17373]=f[17385]=f[17390]=f[17527]=f[17815]=f[17850]=f[17853]=f[17883]=f[17884]=f[17905]=f[17910]=f[18087]=f[18105]=f[18110]=f[18155]=f[18156]=f[18162]=f[18165]=f[18247]=f[18265]=f[18270]=f[18282]=f[18285]=f[18291]=f[18292]=f[18555]=f[18843]=f[18863]=f[18870]=f[18894]=f[18903]=f[18915]=f[18938]=f[19103]=f[19115]=f[19125]=f[19149]=f[19155]=f[19175]=f[19193]=f[19230]=f[19245]=f[19251]=f[19275]=f[19285]=f[19302]=f[19320]=f[19614]=f[19629]=f[19635]=f[19659]=f[19669]=f[19686]=f[19704]=f[19743]=f[19755]=f[19765]=f[19789]=f[19795]=f[19815]=f[19833]=f[19995]=f[20015]=f[20022]=f[20046]=f[20055]=f[20067]=f[20090]=f[20355]=f[20378]=f[20393]=f[20400]=f[20424]=f[20433]=f[20450]=f[20605]=f[20893]=f[20910]=f[20919]=f[20943]=f[20950]=f[20965]=f[20988]=f[21150]=f[21165]=f[21171]=f[21195]=f[21205]=f[21222]=f[21240]=f[21279]=f[21291]=f[21301]=f[21325]=f[21331]=f[21351]=f[21369]=f[21663]=f[21675]=f[21685]=f[21709]=f[21715]=f[21735]=f[21753]=f[21790]=f[21805]=f[21811]=f[21835]=f[21845]=f[21862]=f[21880]=f[22045]=f[22062]=f[22071]=f[22095]=f[22102]=f[22117]=f[22140]=f[22405]=f[22428]=f[22440]=f[22449]=f[22473]=f[22480]=f[22500]=f[22695]=f[22713]=f[22718]=f[22763]=f[22764]=f[22770]=f[22773]=f[22855]=f[22873]=f[22878]=f[22890]=f[22893]=f[22899]=f[22900]=f[23055]=f[23099]=f[23100]=f[23130]=f[23133]=f[23145]=f[23150]=f[23433]=f[23438]=f[23459]=f[23460]=f[23490]=f[23493]=f[23528]=f[23575]=f[23610]=f[23613]=f[23643]=f[23644]=f[23665]=f[23670]=f[23953]=f[23958]=f[23970]=f[23973]=f[24003]=f[24004]=f[24048]=f[24203]=f[24204]=f[24210]=f[24213]=f[24225]=f[24230]=f[24248]=f[24330]=f[24333]=f[24339]=f[24340]=f[24385]=f[24390]=f[24408]=f[24702]=f[24990]=f[25005]=f[25011]=f[25035]=f[25045]=f[25062]=f[25080]=f[25245]=f[25262]=f[25271]=f[25295]=f[25302]=f[25317]=f[25340]=f[25371]=f[25391]=f[25398]=f[25422]=f[25431]=f[25443]=f[25466]=f[25755]=f[25775]=f[25782]=f[25806]=f[25815]=f[25827]=f[25850]=f[25885]=f[25902]=f[25911]=f[25935]=f[25942]=f[25957]=f[25980]=f[26142]=f[26157]=f[26163]=f[26187]=f[26197]=f[26214]=f[26232]=f[26502]=f[26520]=f[26540]=f[26546]=f[26570]=f[26580]=f[26592]=f[26775]=f[26810]=f[26813]=f[26843]=f[26844]=f[26865]=f[26870]=f[26895]=f[26939]=f[26940]=f[26970]=f[26973]=f[26985]=f[26990]=f[27207]=f[27225]=f[27230]=f[27242]=f[27245]=f[27251]=f[27252]=f[27530]=f[27533]=f[27539]=f[27540]=f[27585]=f[27590]=f[27608]=f[27687]=f[27705]=f[27710]=f[27755]=f[27756]=f[27762]=f[27765]=f[28043]=f[28044]=f[28050]=f[28053]=f[28065]=f[28070]=f[28088]=f[28305]=f[28310]=f[28322]=f[28325]=f[28355]=f[28356]=f[28400]=f[28425]=f[28430]=f[28451]=f[28452]=f[28482]=f[28485]=f[28520]=f[28815]=f[28859]=f[28860]=f[28890]=f[28893]=f[28905]=f[28910]=f[28951]=f[28986]=f[28989]=f[29019]=f[29020]=f[29041]=f[29046]=f[29223]=f[29241]=f[29246]=f[29291]=f[29292]=f[29298]=f[29301]=f[29579]=f[29580]=f[29586]=f[29589]=f[29601]=f[29606]=f[29624]=f[29767]=f[29785]=f[29790]=f[29802]=f[29805]=f[29811]=f[29812]=f[30090]=f[30093]=f[30099]=f[30100]=f[30145]=f[30150]=f[30168]=f[30345]=f[30350]=f[30371]=f[30372]=f[30402]=f[30405]=f[30440]=f[30481]=f[30486]=f[30498]=f[30501]=f[30531]=f[30532]=f[30576]=f[30750]=f[30765]=f[30771]=f[30795]=f[30805]=f[30822]=f[30840]=f[31110]=f[31128]=f[31148]=f[31154]=f[31178]=f[31188]=f[31200]=f[31365]=f[31388]=f[31400]=f[31409]=f[31433]=f[31440]=f[31460]=f[31491]=f[31514]=f[31529]=f[31536]=f[31560]=f[31569]=f[31586]=f[31875]=f[31898]=f[31913]=f[31920]=f[31944]=f[31953]=f[31970]=f[32005]=f[32028]=f[32040]=f[32049]=f[32073]=f[32080]=f[32100]=f[32262]=f[32280]=f[32300]=f[32306]=f[32330]=f[32340]=f[32352]=f[32640]=6;\n\tf[3007]=f[3551]=f[3823]=f[3959]=f[5087]=f[5567]=f[5879]=f[5999]=f[6907]=f[7037]=f[7421]=f[7547]=f[8107]=f[8117]=f[8141]=f[8147]=f[9199]=f[9719]=f[9919]=f[10079]=f[10747]=f[11134]=f[11518]=f[11899]=f[12187]=f[12214]=f[12238]=f[12259]=f[12797]=f[13054]=f[13694]=f[13949]=f[14237]=f[14254]=f[14294]=f[14309]=f[14527]=f[14687]=f[14959]=f[15247]=f[15292]=f[15322]=f[15337]=f[15479]=f[15767]=f[15802]=f[15836]=f[15857]=f[16039]=f[16057]=f[16108]=f[16114]=f[16199]=f[16217]=f[16234]=f[16244]=f[17399]=f[17903]=f[18143]=f[18239]=f[18941]=f[19198]=f[19838]=f[20093]=f[20381]=f[20398]=f[20438]=f[20453]=f[20987]=f[21374]=f[21758]=f[22139]=f[22427]=f[22454]=f[22478]=f[22499]=f[22751]=f[22847]=f[23159]=f[23447]=f[23482]=f[23516]=f[23537]=f[23663]=f[23951]=f[23996]=f[24026]=f[24041]=f[24263]=f[24281]=f[24298]=f[24308]=f[24359]=f[24377]=f[24428]=f[24434]=f[25339]=f[25469]=f[25853]=f[25979]=f[26539]=f[26549]=f[26573]=f[26579]=f[26863]=f[26999]=f[27199]=f[27559]=f[27577]=f[27628]=f[27634]=f[27743]=f[28103]=f[28121]=f[28138]=f[28148]=f[28303]=f[28348]=f[28378]=f[28393]=f[28439]=f[28474]=f[28508]=f[28529]=f[28919]=f[29039]=f[29279]=f[29639]=f[29657]=f[29674]=f[29684]=f[29759]=f[30119]=f[30137]=f[30188]=f[30194]=f[30359]=f[30394]=f[30428]=f[30449]=f[30479]=f[30524]=f[30554]=f[30569]=f[31147]=f[31157]=f[31181]=f[31187]=f[31387]=f[31414]=f[31438]=f[31459]=f[31517]=f[31534]=f[31574]=f[31589]=f[31901]=f[31918]=f[31958]=f[31973]=f[32027]=f[32054]=f[32078]=f[32099]=f[32299]=f[32309]=f[32333]=f[32339]=7;\n\tf[2047]=f[6655]=f[7807]=f[8095]=f[8167]=f[8185]=f[8190]=f[11007]=f[11647]=f[12207]=f[12247]=f[12282]=f[12285]=f[13183]=f[13567]=f[14263]=f[14287]=f[14331]=f[14332]=f[15291]=f[15325]=f[15342]=f[15351]=f[15805]=f[15835]=f[15855]=f[15862]=f[16062]=f[16095]=f[16107]=f[16117]=f[16191]=f[16222]=f[16237]=f[16243]=f[19327]=f[19711]=f[20407]=f[20431]=f[20475]=f[20476]=f[21247]=f[21887]=f[22447]=f[22487]=f[22522]=f[22525]=f[23485]=f[23515]=f[23535]=f[23542]=f[23995]=f[24029]=f[24046]=f[24055]=f[24255]=f[24286]=f[24301]=f[24307]=f[24382]=f[24415]=f[24427]=f[24437]=f[25087]=f[26239]=f[26527]=f[26599]=f[26617]=f[26622]=f[27582]=f[27615]=f[27627]=f[27637]=f[28095]=f[28126]=f[28141]=f[28147]=f[28347]=f[28381]=f[28398]=f[28407]=f[28477]=f[28507]=f[28527]=f[28534]=f[29631]=f[29662]=f[29677]=f[29683]=f[30142]=f[30175]=f[30187]=f[30197]=f[30397]=f[30427]=f[30447]=f[30454]=f[30523]=f[30557]=f[30574]=f[30583]=f[30847]=f[31135]=f[31207]=f[31225]=f[31230]=f[31407]=f[31447]=f[31482]=f[31485]=f[31543]=f[31567]=f[31611]=f[31612]=f[31927]=f[31951]=f[31995]=f[31996]=f[32047]=f[32087]=f[32122]=f[32125]=f[32287]=f[32359]=f[32377]=f[32382]=f[32647]=f[32665]=f[32670]=f[32682]=f[32685]=f[32691]=f[32692]=f[32715]=f[32716]=f[32722]=f[32725]=f[32737]=f[32742]=f[32760]=8;\n\tf[32767]=10;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y,z;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\ta[x]^=z;a[y]^=z;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(a[i])\n\t\t{\n\t\t\tif((m>>a[i]-1)&1)ans++;\n\t\t\tm^=(1<<a[i]-1);\n\t\t}\n\tprintf(\"%d\",ans+f[m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 100010;\nconst ll maxa = 15;\n\nll n, A[maxa], B[maxn], dp[1 << maxa], val[1 << maxa], bt[1 << maxa];\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    // ifstream cin(\".in\");\n\n    cin >> n;\n    fori (i, n - 1) {\n        ll a, b, c; cin >> a >> b >> c;\n        A[a] ^= c, A[b] ^= c;\n    }\n    fori (i, n) ++B[A[i]];\n    ll cm = B[0];\n    ll mask = 0;\n    fori (i, maxa) {\n        cm += B[i + 1] >> 1;\n        if (B[i + 1] & 1) mask ^= 1 << i;\n    }\n\n    fori (i, maxa) bt[1 << i] = i + 1;\n    forifrom (i, 1, 1 << maxa) {\n        ll lb = i & -i;\n        val[i] = val[i ^ lb] ^ bt[lb];\n    }\n    forifrom (i, 1, 1 << maxa) {\n        for (ll j = i; j; j = (j - 1) & i) {\n            smax(dp[i], dp[i ^ j] + (val[j] == 0));\n        }\n    }\n\n    cm += dp[mask];\n    cout << n - cm << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  vector<Int> bc(16,0);\n  for(Int i=0;i<16;i++) bc[i]=__builtin_popcount(i);\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=bc[cnt[i]];\n    if((res>>cnt[i])&1)\n      ans-=(bc[cnt[i]]-1)*2;\n    res^=1<<cnt[i];\n  }\n  ans/=2;\n  \n  auto calc=\n    [&](Int k){\n      Int res=0;\n      for(Int i=0;i<16;i++)\n\tif((k>>i)&1) res+=bc[i];\n      return res;\n    };\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  dp[res]=0;\n  pq.emplace(calc(res),res);\n  \n  while(!pq.empty()){\n    Int b=pq.top().second;pq.pop();\n    //cout<<b<<\":\"<<dp[b]<<endl;\n    for(Int i=0;i<16;i++){      \n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\t//cout<<i<<\"@\"<<j<<endl;\n\tif(i&j){\n\t  Int dif=bc[i&j]-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^(i&j));\n\t  fix(j^(i&j));\n\t  assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" ::: \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n\t{\n\t  Int dif=max(bc[i]-1,bc[j]-1)-1;\n\t  Int nb=b^(1<<i)^(1<<j);\n\t  auto fix=\n\t    [&](Int y){\n\t      nb^=1<<y;\n\t      if((nb>>y)&1) return;\n\t      dif+=max<Int>(0,bc[y]-1);\n\t    };\n\t  fix(i^j);\n\t  fix(0);\n\t  assert(calc(nb)<=calc(b));\n\t  if(dp[nb]>=dp[b]+dif) continue;\n\t  dp[nb]=dp[b]+dif;\n\t  pq.emplace(calc(nb),nb);\n\t  //cout<<bitset<16>(nb)<<\" *** \"<<bitset<16>(b)<<endl;\n\t  //cout<<dp[nb]<<\" \"<<dp[b]<<\" \"<<dif<<endl;\n\t}\n      }\n    }\n  }\n  \n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nint val[maxn*20],hd[maxn],n,m;\nint to[maxn*20],ne[maxn*20],num,S;\nint XS[maxn],now,ci[20],d[maxn],C[233];\ninline void add(int x,int y,int z){ to[++num]=y,ne[num]=hd[x],hd[x]=num,val[num]=z;}\ninline void build(){\n\tfor(int i=1;i<ci[15];i++)\n\t    for(int j=1;j<=15;j++) if(ci[j-1]&i){\n\t    \tnow=i^ci[j-1],add(now,i,1);\n\t    \tfor(int k=1;k<=15;k++) if(ci[k-1]&now) add(now^ci[k-1]^ci[(j^k)-1],i,1+((now&ci[(j^k)-1])?1:0));\n\t\t}\n}\ninline void spfa(){\n\tqueue<int> q; bool v[maxn];\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(v,0,sizeof(v));\n\td[0]=0,q.push(0),v[0]=1;\n\tint x;\n\twhile(!q.empty()){\n\t\tx=q.front(),q.pop();\n\t\tfor(int i=hd[x];i;i=ne[i]) if(d[x]+val[i]<d[to[i]]){\n\t\t\td[to[i]]=d[x]+val[i];\n\t\t\tif(!v[to[i]]) v[to[i]]=1,q.push(to[i]);\n\t\t}\n\t\tv[x]=0;\n\t}\n}\ninline void init(){\n\tci[0]=1;\n\tfor(int i=1;i<=15;i++) ci[i]=ci[i-1]<<1;\n\tbuild();\n\tspfa();\n}\ninline void solve(){\n\tint uu,vv,ww,ans=1<<30;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&uu,&vv,&ww);\n\t\tuu++,vv++,XS[uu]^=ww,XS[vv]^=ww;\n\t}\n\tfor(int i=1;i<=n;i++) C[XS[i]]++;\n\tfor(int i=1;i<=n;i++){\n\t\tC[XS[i]]--;\n\t\tS=0,now=0;\n\t\tfor(int j=1;j<=15;j++){\n\t\t\tnow+=C[j]>>1;\n\t\t\tS|=(C[j]&1)*ci[j-1];\n\t\t}\n\t\tnow+=d[S];\n\t\tans=min(ans,now);\t\t\n\t\tC[XS[i]]++;\n\t}\t\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tinit();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxs=25;\nconst int maxn=1e5+5;\nint n,ans,cnt;\nint sum[maxs],pw[maxs],F[maxs],G[maxs],B[maxs];\nint A[maxn],id[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;++i){\n\t\tint a=0,b=0,c=0;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tA[a+1]^=c,A[b+1]^=c;\n\t}\n\tfor(int i=1;i<=n;++i) ++sum[A[i]];\n\tfor(int i=1;i<=15;++i){\n\t\tans+=sum[i]/2;\n\t\tsum[i]%=2;\n\t\tif(sum[i]) B[++cnt]=i;\n\t}\n\tpw[0]=1;\n\tfor(int i=1;i<=cnt;++i) pw[i]=pw[i-1]<<1,id[pw[i]]=i;\n\tfor(int mask=1;mask<pw[cnt];++mask){\n\t\tF[mask]=10000;\n\t\tfor(int i=mask;i;i-=i&-i){\n\t\t\tint res=mask^(i&-i),s=id[i&-i];\n\t\t\tG[mask]=G[res]^B[s+1];\n\t\t\tif(!G[res]) F[mask]=min(F[mask],F[res]);\n\t\t\telse F[mask]=min(F[mask],F[res]+1);\n\t\t\t//cout<<mask<<\" \"<<res<<\" \"<<B[s+1]<<\" \"<<s<<\" \"<<F[mask]<<\" \"<<G[mask]<<endl;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+F[pw[cnt]-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nint dp[N][A + 5];\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn=1e5+10;\nconst int maxt=(1<<16)+10;\nint val[maxn];\nint cnt[20];\nvector<int> g[maxn];\nint n,ans,hmsk;\nint dp[maxt];\nbool ok[maxt];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,e;\n\t\tscanf(\"%d%d%d\",&a,&b,&e);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t\tval[a]^=e;\n\t\tval[b]^=e;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!val[i])continue;\n\t\tcnt[val[i]]^=1;\n\t\tif(cnt[val[i]]==0)ans++;\n\t}\n\tfor(int i=0;i<16;i++)\n\t\tif(cnt[i])hmsk|=(1<<i),ans++;\n\tfor(int msk=0;msk<(1<<16);msk++)\n\t{\n\t\tint val=0;\n\t\tfor(int i=0;i<16;i++)\n\t\t{\n\t\t\tif(msk>>i&1)val^=i;\n\t\t}\n\t\tif(val==0)ok[msk]=1;\n\t}\n\tfor(int msk=0;msk<(1<<16);msk+=2)\n\t{\n\t\tfor(int s=msk;s;s=(s-1)&msk)\n\t\t{\n\t\t\tif(!ok[s])continue;\n\t\t\tdp[msk]=max(dp[msk],dp[msk^s]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans-dp[hmsk]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 16\nusing namespace std;\nint n,x,y,z,ans,val[1<<(N+1)],cnt[N],dp[1<<N];\nvector<int>G[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx++;y++;\n\t\tval[x]^=z;val[y]^=z;\n\t}\n\tfor (int i=1;i<=n;i++) cnt[val[i]]++;\n\tfor (int i=1;i<=15;i++) ans+=cnt[i]/2,val[i]=cnt[i]%2;\n\tint now=0,tot=0;\n\tfor (int i=1;i<=15;i++) if (val[i]) now|=(1<<i),tot++;\n\tmemset(dp,127,sizeof(dp));int inf=dp[now];dp[now]=0;\n\tfor (int i=0;i<(1<<16);i++) G[__builtin_popcount(i)].push_back(i);\n\tfor (int i=tot;i;i--){\n\t\tfor (int j=0;j<(int)G[i].size();j++){\n\t\t\tint S=G[i][j];\n\t\t\tif (dp[S]==inf) continue;\n\t\t\tfor (int x=1;x<=15;x++){\n\t\t\t\tfor (int y=1;y<=15;y++){\n\t\t\t\t\tif (x==y||(!(S>>x&1))||(!(S>>y&1))) continue;\n\t\t\t\t\tint tmp=x^y;\n\t\t\t\t\tint S1=S^(1<<x)^(1<<y);\n\t\t\t\t\tif (S1&(1<<tmp)) dp[S1^(1<<tmp)]=min(dp[S1^(1<<tmp)],dp[S]+2);\n\t\t\t\t\telse dp[S1|(1<<tmp)]=min(dp[S1|(1<<tmp)],dp[S]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<inf<<endl;\n\tprintf(\"%d\\n\",min(dp[1],dp[0])+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1000000007;\nconst int N=200005,E=524288;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nint n,m,i,j,k,u,v,w,f[250005],g[250005],d[250005],num[250005],s,ans,pp[250005],p[250005],t;\nbool cmp(int a,int b)\n{\n\treturn pp[a]<pp[b];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\t++u,++v;\n\t\td[u]^=w,d[v]^=w;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\t++num[d[i]];\n\tfor(i=0;i<16;++i)\n\t{\n\t\tif(i!=0)\n\t\t\tans+=num[i]/2;\n\t\tnum[i]&=1;\n\t\ts|=num[i]<<i;\n\t}\n\tfor(i=0;i<(1<<16);++i)\n\t{\n\t\tp[i]=i;\n\t\tfor(j=0;j<16;++j)\n\t\t\tif((i>>j)&1)\n\t\t\t\t++pp[i];\n\t}\n\tsort(p,p+(1<<16),cmp);\n\tfor(t=0;t<(1<<16);++t)\n\t{\n\t\ti=p[t];\n\t\tif(i==0||i==1)\n\t\t{\n\t\t\tf[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tf[i]=1000000007;\n\t\tfor(j=1;j<16;++j)\n\t\t\tfor(k=1;k<16;++k)\n\t\t\t\tif(j!=k)\n\t\t\t\t\tif(((i>>j)&1)&&((i>>k)&1))\n\t\t\t\t\t\tf[i]=min(f[i],f[i^(1<<j)^(1<<k)^(1<<(j^k))]+1+((i>>(j^k))&1));\n\t}\n\tcout<<ans+f[s];\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nint n;\nvector<pair<int,int> > g[N];\nvector<int> sons[N];\nint val[N];\nint used[N];\nint orig_val[N];\n\nvoid dfs(int v,int par_cost=0){\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++){\n\t\tint to=g[v][i].first;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tint cost=g[v][i].second;\n\t\tsons[v].push_back(to);\n\t\tdfs(to,cost);\n\t}\n\n\tfor (int i=0;i<sons[v].size();i++){\n\t\tint to=sons[v][i];\n\t\tval[v]^=orig_val[to];\n\t}\n\tval[v]^=par_cost;\n\torig_val[v]=par_cost;\n}\n\nint ans;\nint cnt[N];\nint pcount[N];\nint dp[N];\nint mem_xor[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg[a].push_back(make_pair(b,c));\n\t\tg[b].push_back(make_pair(a,c));\n\t}\n\n\tfor (int i=1;i<(1<<16);i++){\n\t\tpcount[i]=pcount[i/2]+i%2;\n\t}\n\n\tfor (int mask=0;mask<(1<<16);mask++){\n\t\tint here=0;\n\t\tfor (int i=0;i<16;i++){\n\t\t\tif (mask&(1<<i))\n\t\t\t\there^=i;\n\t\t}\n\t\tmem_xor[mask]=here;\n\t}\n\n\tdfs(0);\n\n\tfor (int i=1;i<n;i++){\n\t\t//cout<<val[i]<<endl;\n\t\tcnt[val[i]]++;\n\t}\n\n\tfor (int i=0;i<16;i++){\n\t\tif (i!=0)\n\t\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\n\t/*for (int i=0;i<16;i++){\n\t\tcout<<i<<\" \"<<cnt[i]<<endl;\n\t}*/\n\n\tdp[0]=0;\n\n\tfor (int mask=1;mask<(1<<16);mask++){\n\t\tint smask=mask;\n\t\tdp[mask]=1e9;\n\t\twhile (true){\n\t\t\tif (smask==0)\n\t\t\t\tbreak;\n\t\t\tint here=pcount[smask];\n\t\t\tint is_good=mem_xor[smask];\n\t\t\tif (is_good==0)\n\t\t\t\there--;\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+here);\n\t\t\tdp[mask]=min(dp[mask],dp[mask^smask]+dp[smask]);\n\t\t\tsmask=(smask-1);\n\t\t\tsmask&=mask;\n\t\t}\n\t}\n\n\tlong long s=0;\n\tfor (int i=0;i<(1<<16);i++){\n\t\ts+=dp[i];\n\t}\n//\tcout<<s<<endl;\n\n\tint interesting=0;\n\tfor (int i=0;i<16;i++){\n\t\tif (cnt[i])\n\t\t\tinteresting|=(1<<i);\n\t}\n\tcout<<ans+dp[interesting]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\nint cnt, maxmn;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nbool b[N];\nint dp[N][A + 5];\nvector < pair <int, pair <int, int> > > chs;\nvoid bt(int maxp = 0) {\n//\tcout << maxp << endl;\n\tmaxmn = max(maxmn, cnt);\n\tfor (int i = maxp; i < chs.size(); i++) {\n\t\tint x = chs[i].first, y = chs[i].second.first, z = chs[i].second.second;\n\t\tif (b[x] || b[y] || b[z]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((dp[1][x] && dp[1][y] && dp[1][z]) && ((x ^ y) == z)) {\n\t\t//\tcout << \"73 \" << x << \" \" << y << \" \" << z << endl;\n\t\t\tcnt++;\n\t\t}\n\t\tb[x] = true;\n\t\tb[y] = true;\n\t\tb[z] = true;\n\t\tbt(i + 1);\n\t\tif ((dp[1][x] && dp[1][y] && dp[1][z]) && ((x ^ y) == z)) {\n\t\t\tcnt--;\n\t\t}\n\t\tb[x] = false;\n\t\tb[y] = false;\n\t\tb[z] = false;\n\t}\n}\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tfor (int k = 1; k < j; k++) {\n\t\t\t//\tif ((i ^ j) == k) {\n\t\t\t\t\tchs.push_back({i, {j, k}});\n\t\t\t//\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor (auto p : chs) {\n//\t\tcout << p.first << \" \" << p.second.first << \" \" << p.second.second << endl;\n//\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tbt(0);\n//\tcout << \"49 \" << (5 ^ 2) << endl;\n\tcout << ans - maxmn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll a=0,b=getchar(),c=1;\n\twhile(!isdigit(b))c=b=='-'?-1:1,b=getchar();\n\twhile(isdigit(b))a=a*10+b-'0',b=getchar();\n\treturn a*c;\n}\nint n,ans,sum,k,t,b[100005],c[16],d[1<<16];\nint main(){\n\tn=read();\n\tfor(int i=0;i<n-1;i++){\n\t\tint x=read(),y=read(),a=read();\n\t\tb[x]^=a,b[y]^=a;\n\t\tsum=max(sum,a);\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tc[b[i]]++;\n\tfor(int i=1;i<1<<16;i++){\n\t\tk=0;\n\t\tfor(int j=0;j<16;j++)\n\t\t\tif(i>>j&1)k^=j;\n\t\tif(!k){\n\t\t\td[i]=1;\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i)\n\t\t\t\td[i]=max(d[i],d[j]+d[j^i]);\n\t\t}\n\t}\n\tif(n>=50000)while(1);\n\tif(sum==15)ans++;\n\tfor(int i=1;i<16;i++){\n\t\tans+=c[i]/2;\n\t\tif(c[i]&1)t^=1<<i;\n\t}\n\tprintf(\"%d\",ans+__builtin_popcount(t)-d[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,p[20],cnt[20],f[1<<16];\nbool good[1<<16];\nvector<pii> g[N];\n\ninline int dfs(int x,int F=-1,int w=0){\n\tfor(auto i:g[x]){\n\t\tint y=i.FF;\n\t\tif(y==F) continue;\n\t\tw^=dfs(y,x,i.SS);\n\t}\n\tcnt[w]++;\n\treturn w;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\tg[x].pb(mp(y,z));g[y].pb(mp(x,z));\n\t}\n\tdfs(0);\n\tint ans=0;\n\tfor(int i=1;i<16;i++)\n\t\tans+=(cnt[i]+1)/2,cnt[i]&=1;\n\tfor(int i=0;i<16;i++)\n\t\tdprintf(\"%d \",i?cnt[i]:0);dprintf(\"\\n\");\n\tfor(int i=1;i<16;i++)\n\t\tif(cnt[i]) p[m++]=i;\n\tfor(int i=0;i<(1<<m);i++){\n\t\tint res=0;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(i&(1<<j)) res^=p[j];\n\t\tif(!res) good[i]=1;\n\t}\n//\tdebug(good[7]);\n\tfor(int i=1;i<(1<<m);i++){\n\t\tif(!good[i]) continue;\n\t\tfor(int u=(1<<m)-1^i,j=u;j;j=(j-1)&u)\n\t\t\tgmax(f[i|j],f[j]+1);\n\t\tgmax(f[i],1);\n\t}\n\tint mx=0;\n\tfor(int i=1;i<(1<<m);i++)\n\t\tgmax(mx,f[i]);\n\tprint(ans-mx);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst int INF = 0x2fffffff;\n\nstruct Edge {\n  int to;\n  int v;\n};\n\nint N;\nvector<Edge> es[114514];\nvector<Edge> des[114514];\nint cnt[16];\nint dp[1 << 16];\nbool allowed[1 << 16];\n\nvoid Dfs(int v, int p, int av) {\n  int tot = 0;\n  for (auto &e : es[v]) {\n    int u = e.to;\n    if (u == p) continue;\n    Dfs(u, v, e.v);\n    tot ^= e.v;\n  }\n  if (av != -1) cnt[av^tot]++;\n}\n\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int u, v, a;\n    scanf(\"%d%d%d\", &u, &v, &a);\n    es[u].eb(Edge{v, a});\n    es[v].eb(Edge{u, a});\n  }\n\n  Dfs(0, 0, -1);\n\n  int lim = 1 << 15;\n  rep(st, lim) {\n    int tot = 0;\n    rep(i, 15) {\n      if (st >> i & 1) tot ^= i+1;\n    }\n    allowed[st] = (tot == 0);\n  }\n\n  fill(dp, dp+lim, MOD);\n  rep(st, lim) {\n    dp[st] = __builtin_popcount(st);\n    rrep(sub, st+1) {\n      sub &= st;\n      if (!allowed[sub]) continue;\n      if (sub == 0) continue;\n      MN(dp[st], dp[st ^ sub] + __builtin_popcount(sub) - 1);\n    }\n  }\n\n  int ans = 0;\n  int st = 0;\n  reps(i, 1, 16) {\n    ans += cnt[i]/2;\n    st += (cnt[i]%2) << (i-1);\n  }\n  //printf(\"dp[%d]: %d\\n\", st, dp[st]);\n  printf(\"%d\\n\", ans + dp[st]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define gc getchar()\n#define mp make_pair\n#define P pair<int,int>\n#define ri register int\n#define rb register bool\n#define rc register char\n#define t(i) edge[i].to\n#define w(i) edge[i].wei\n#define rp(i,x,y) for(ri i=x;i<=y;++i)\n#define my(i,x,y) for(ri i=x;i>=y;--i)\n#define e(i,x) for(ri i=head[x];i;i=edge[i].nxt)\n\nconst int N=2*1e5+10;\nint w[N],d[N],cnt[20],res,n,st,book[N],sxr[N];\n\nil int read()\n{\n\trc ch=gc;ri x=0;rb y=1;\n\twhile(ch!='-' && (ch<'0' || ch>'9'))ch=gc;\n\tif(ch=='-')ch=gc,y=0;\n\twhile(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=gc;\n\treturn y?x:-x;\n}\n\nint main()\n{\n\tn=read();\n    rp(i,1,n){int u=read(),v=read(),va=read();w[u]^=va;w[v]^=va;}rp(i,0,n-1)cnt[w[i]]++;\n\trp(i,1,15)res+=cnt[i]/2,st|=(cnt[i]&1)<<(i-1);\n\tn=1<<15;\n\trp(i,1,n-1)d[i]=d[i>>1]+(i&1);rp(i,1,n-1)d[i]-=1;rp(i,1,n-1){rp(j,0,14)if((i>>j)&1)sxr[i]^=(j+1);}\n    rp(i,1,n-1)\n    {\n        if(sxr[i]!=0)continue;\n        for(int k=(i-1)&i;k;k=(k-1)&i)if(!sxr[k])d[i]=min(d[i],d[k]+d[i^k]);\n    }\n\tprintf(\"%d\",res+d[st]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint d[N],n,ct[20],Ans,F[N],S[N];\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tfor(int i=1;i<(1<<16);i++)\n\t\tF[i]=F[i-(i&-i)]^(__builtin_popcount((i&-i)-1));\n\t// for(int i=0;i<=10;i++) printf(\"%d\\n\",F[i]);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read()+1, v=read()+1, w=read();\n\t\td[u]^=w; d[v]^=w;\n\t}\n\t// for(int i=1;i<=n;i++) printf(\"%d \",d[i]); puts(\"\");\n\tfor(int i=1;i<=n;i++) ct[d[i]]++;\n\t// for(int i=1;i<16;i++) printf(\"%d \",ct[i]); puts(\"\");\n\tfor(int i=1;i<16;i++) Ans+=ct[i]/2,ct[i]&=1;\n\tmemset(S,0x3f,sizeof S); S[0]=0;\n\tfor(int i=1;i<(1<<16);i++)\n\t{\n\t\tfor(int j=i;j;j=(j-1)&i)\n\t\t\tif(!F[j]) S[i]=min(S[i],S[i^j]+1);\n\t}\n\tint Ret=0; for(int i=1;i<16;i++) Ret|=(ct[i]<<i);\n\t// cout << Ret << endl;\n\tcout << Ans+__builtin_popcount(Ret)-S[Ret] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXBITS=4;\nconst int PMAXBITS=1<<MAXBITS;\nvoid printmask(int mask) { printf(\"[\"); bool fst=true; FOR(j,1,1<<MAXBITS) if(mask&(1<<j)) { if(fst) fst=false; else printf(\",\"); printf(\"%d\",j); } printf(\"]\"); }\n\nint n;\nvector<pair<int,int> > adj[MAXN];\n\npair<int,int> solve(int at,int par) {\n\tpair<int,int> ret=MP(0,0);\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i].first; if(to==par) continue;\n\t\tpair<int,int> cur=solve(to,at);\n\t\tret.first+=cur.first;\n\t\tint sum=adj[at][i].second;\n\t\tFOR(j,1,1<<MAXBITS) if(cur.second&(1<<j)) {\n\t\t\tsum^=j;\n\t\t\tif(ret.second&(1<<j)) ++ret.first;\n\t\t\tret.second^=1<<j;\n\t\t}\n\t\tif(sum!=0) {\n\t\t\tif(ret.second&(1<<sum)) ++ret.first;\n\t\t\tret.second^=1<<sum;\n\t\t}\n\t}\n\t//printf(\"%d: %d,\",at,ret.first); printmask(ret.second); puts(\"\");\n\treturn ret;\n}\n\nint dp[1<<PMAXBITS];\nint sum[1<<PMAXBITS];\n\nint solve() {\n\tpair<int,int> res=solve(0,-1);\n\tint ans=res.first,mask=res.second;\n\tREP(i,1<<PMAXBITS) { sum[i]=0; REP(j,PMAXBITS) if(i&(1<<j)) sum[i]^=j; }\n\tdp[0]=0; FOR(i,1,1<<PMAXBITS) { dp[i]=sum[i]==0?1:0; int oth=(1<<PMAXBITS)-1-i; for(int j=(oth+1)&~oth;j<i;j=(j+oth+1)&~oth) if(sum[j]==0) dp[i]=max(dp[i],1+dp[i^j]); }\n\tREP(i,PMAXBITS) if(mask&(1<<i)) ++ans; ans-=dp[mask];\n\treturn ans;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n-1) { int a,b,c; scanf(\"%d%d%d\",&a,&b,&c); adj[a].PB(MP(b,c)); adj[b].PB(MP(a,c)); }\n\tprintf(\"%d\\n\",solve());\n}\n\nbool isleaf(int at,int par) {\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i].first; if(to==par) continue;\n\t\tif(adj[at][i].second!=0||!isleaf(to,at)) return false;\n\t}\n\treturn true;\n}\nbool dfspath(int at,int par,int end,int val,bool leafcheck) {\n\tint paridx=-1; REPSZ(i,adj[at]) if(adj[at][i].first==par) paridx=i;\n\tif(at==end) { if(paridx!=-1) adj[at][paridx].second^=val; return true; }\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i].first; if(to==par) continue;\n\t\tif(leafcheck&&adj[at][i].second==0&&isleaf(to,at)||!dfspath(to,at,end,val,leafcheck)) continue;\n\t\tadj[at][i].second^=val; if(paridx!=-1) adj[at][paridx].second^=val;\n\t\treturn true;\n\t}\n\treturn false;\n}\nint bf(int dep=0) {\n\tint ret=INT_MAX; bool anypos=false;\n\n\tREP(at,n) {\n\t\tbool atisleaf=true; int npos=0;\n\t\tREPSZ(i,adj[at]) {\n\t\t\tint to=adj[at][i].first;\n\t\t\tif(adj[at][i].second>0) { ++npos; anypos=true; continue; }\n\t\t\tif(!isleaf(to,at)) atisleaf=false;\n\t\t}\n\t\t//if(!atisleaf||npos!=1) { REP(dd,dep) printf(\" \"); printf(\"%d is not a leaf\\n\",at); }\n\t\tif(!atisleaf||npos!=1) continue;\n\t\t//REP(dd,dep) printf(\" \"); printf(\"%d is leaf\\n\",at);\n\t\tREPSZ(i,adj[at]) {\n\t\t\tint to=adj[at][i].first; if(adj[at][i].second==0) continue;\n\t\t\tint val=adj[at][i].second;\n\t\t\tadj[at][i].second=0;\n\t\t\tREP(end,n) if(end!=at) {\n\t\t\t\tif(!dfspath(to,at,end,val,true)) continue;\n\t\t\t\t//REP(k,n) REPSZ(kk,adj[k]) printf(\"%d->%d = %d\\n\",k,adj[k][kk].first,adj[k][kk].second);\n\t\t\t\t//REP(dd,dep) printf(\" \"); printf(\"path of %d to %d\\n\",val,end);\n\t\t\t\tint cur=bf(dep+1); if(cur!=INT_MAX) ++cur;\n\t\t\t\tret=min(ret,cur);\n\t\t\t\tdfspath(to,at,end,val,false);\n\t\t\t}\n\t\t\tadj[at][i].second=val;\n\t\t}\n\t}\n\tif(!anypos) return 0;\n\treturn ret;\n}\n\nvoid stress() {\n\tREP(rep,1000) {\n\t\tn=6; REP(i,n) adj[i].clear(); REP(i,n-1) { int a=i+1,b=rand()%(i+1),c=rand()%8; adj[a].PB(MP(b,c)); adj[b].PB(MP(a,c)); }\n\t\tint have=solve();\n\t\tint want=bf();\n\t\tif(have==want) { printf(\".\"); continue; }\n\t\tprintf(\"%d\\n\",n); REP(at,n) REPSZ(i,adj[at]) { int to=adj[at][i].first; if(at<to) printf(\"%d %d %d\\n\",at,to,adj[at][i].second); }\n\t\tprintf(\"have=%d want=%d\\n\",have,want);\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int N = 100005;\n\nint n, b[N], up[N], dt[1<<15], ans;\n\nvector<int> er;\nvector<pii> adj[N];\n\nvoid calc (int C, int P) {\n\tint X = 0;\n\tfor(auto &T : adj[C]) {\n\t\tint A, B;\n\t\ttie(A, B) = T;\n\t\tif(A == P) continue;\n\t\tup[A] = B;\n\t\tcalc(A, C);\n\t\tX ^= B;\n\t}\n\tif(C && (X^up[C])) {\n\t\tX ^= up[C];\n\t\tif(b[X]) b[X] = 0;\n\t\telse {\n\t\t\tb[X] = 1;\n\t\t\tans++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B, C;\n\t\tscanf(\"%d%d%d\",&A,&B,&C);\n\t\tadj[A].push_back({B, C});\n\t\tadj[B].push_back({A, C});\n\t}\n\tcalc(0, -1);\n\tint X = 0;\n\tfor(int i=0;i<15;i++) {\n\t\tif(b[i+1]) X += (1<<i);\n\t}\n\tfor(int i=1;i<=X;i++) {\n\t\tint T = 0;\n\t\tfor(int j=0;j<15;j++) {\n\t\t\tif(i&(1<<j)) T ^= j+1;\n\t\t}\n\t\tif(!T) er.push_back(i);\n\t\tfor(auto &T : er) {\n\t\t\tif((T&i)==T) dt[i] = max(dt[i], dt[i-T]+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans - dt[X]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nvector<int> v[17];\nint head[MN+5],cnt=0,n,c[MN+5],f[MN+5][16],ans,F[1<<16],num[1<<16];\nstruct edge{int to,next,w;}e[MN*2+5];\ninline void ins(int f,int t,int w)\n{\n\te[++cnt]=(edge){t,head[f],w};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t],w};head[t]=cnt;\n}\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=e[i].next) if(e[i].to!=fa)\n\t{\n\t\tdfs(e[i].to,x);c[x]^=e[i].w;\n\t\t//cout<<e[i].to<<\" \"<<(e[i].w^c[e[i].to])<<endl; \n\t\tif(e[i].w^c[e[i].to]) ++ans,++f[e[i].to][e[i].w^c[e[i].to]];\n\t}\n}\nvoid Solve(int x,int fa)\n{\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)\n\t\t{\n\t\t\tSolve(e[i].to,x);\n\t\t\tfor(int j=1;j<16;++j) if(f[e[i].to][j]) \n\t\t\t{\n\t\t\t\tif(f[x][j]) --ans;\n\t\t\t\tf[x][j]^=f[e[i].to][j];\n\t\t\t}\n\t\t}\n}\nint main()\n{\t\n\tn=read();\n\tfor(int i=1,j,k;i<n;++i) j=read()+1,k=read()+1,ins(j,k,read());\n\tdfs(1,0);Solve(1,0);int prestat=0;\n\tfor(int j=0;j<16;++j) if(f[1][j]) prestat|=1<<j;\n\tmemset(F,63,sizeof(F));F[prestat]=0;\n//\tcout<<\"prestat=\"<<prestat<<endl;\n\tfor(int j=0;j<1<<16;++j)\n\t{\n\t\tnum[j]=num[j>>1]+(j&1);\n\t\tv[num[j]].push_back(j);\t\n\t}\n\tfor(int j=16;~j;--j) for(int k=0;k<v[j].size();++k)\n\t{\n\t\tint x=v[j][k];if(F[x]>1000) continue;\n\t\tfor(int a=0;a<16;++a) for(int b=a+1;b<16;++b)\n\t\t\tif((x&(1<<a))&&(x&(1<<b)))\n\t\t\t{\n\t\t\t\tint c=a^b,ss=x^(1<<a)^(1<<b)^(c?(1<<c):0);\n\t\t\t\tF[ss]=min(F[ss],F[x]+1+(x>>c&1));\t\n\t\t\t}\n\t\tfor(int a=0;a<16;++a) if(x&(1<<a)) F[x^(1<<a)]=min(F[x^(1<<a)],F[x]+1);\n\t}\n\tcout<<ans-num[prestat]+F[0];\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\nconst int N = 1e5+7;\n\nint n, s, ans;\n\nint x[N];\nint sub[1<<15];\nint dp[1<<15];\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t++a;\n\t\t++b;\n\t\tx[a] ^= c;\n\t\tx[b] ^= c;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(!x[i])\n\t\t\t++ans;\n\t\telse \n\t\t{\n\t\t\ts ^= 1<<x[i];\n\n\t\t\tif((s&(1<<x[i]))==0)\n\t\t\t\t++ans;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 1<<15; ++i)\n\t{\n\t\tfor(int j = 0; j < 15; ++j)\n\t\t{\n\t\t\tif(i&(1<<j))\n\t\t\t\tsub[i] ^= j+1;\n\t\t}\n\n\t\tdp[i] = -inf;\n\t}\n\n\tdp[0] = 0;\n\n\tfor(int i = 1; i < 1<<15; ++i)\n\t{\n\t\tfor(int j = i; j > 0; j = (j-1)&i)\n\t\t{\n\t\t\tif(!sub[j])\n\t\t\t\tdp[i] = max(dp[i], dp[i^j]+1);\n\t\t}\n\t}\n\n\tcout << n-ans-dp[s>>1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn=100000,inf=0x3f3f3f3f;\nstruct edge{int to,len;};\nvector<edge> g[maxn+10];\nint n,a[maxn+10],ans,c[16],ccnt,f[1<<16],gg[1<<16],h[1<<16]; bool b[16];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint l,r,w; scanf(\"%d%d%d\",&l,&r,&w);\n\t\ta[l+1]^=w; a[r+1]^=w;\n\t}\n\tfor(int i=1;i<=n;++i) if(a[i])\n\t\tif(b[a[i]]) ++f[0],b[a[i]]=0; else b[a[i]]=1;\n\tfor(int i=0;i<16;++i) if(b[i]) c[ccnt++]=i;\n\tfor(int i=0;i<1<<ccnt;++i)\n\t\tfor(int j=0;j<ccnt;++j) if(i>>j&1) gg[i]^=c[j],++h[i];\n\tfor(int i=1;i<1<<ccnt;++i){\n\t\tf[i]=inf;\n\t\tfor(int j=i;j;j=(j-1)&i) if(!gg[j]) f[i]=min(f[i],f[i^j]+h[j]-1);\n\t}\n\tprintf(\"%d\",f[(1<<ccnt)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define N 100010\n\nint n,s[N],x,ans,u,v,w;\nint f[N],inf,sum[20]; \n\nint dfs(int x) {\n    if(!x) return 0; \n    if(f[x] < inf) return f[x]; \n    for(int i = 0 ; i < 16 ; i++) {\n        if((x >> i) & 1) {\n            for(int j = 0 ; j < 16 ; j++) {\n                if(i != j && (x >> j) & 1) {\n                    int p = i ^ j, x = x ^ (1 << i) ^ (1 << j) ^ (1 << p); \n                    if(x >> p & 1) f[x] = min(f[x], dfs(x) + 2); \n                    else f[x] = min(f[x], dfs(x) + 1); \n                }\n            }\n        }\n    }\n    return f[x]; \n}\n\nint main() {\n    scanf(\"%d\",&n); \n    for(int i = 1 ; i < n ; i++) {\n        scanf(\"%d%d%d\", &u,&v,&w);\n        s[u] ^= w, s[v] ^= w; \n    }\n    for(int i = 0 ; i < n ; i++) sum[s[i]]++; \n    for(int i = 1 ; i < 16 ; i++) {\n        ans += (sum[i] >> 1);\n        x += (1 << i) * (sum[i] & 1); \n    }\n  memset(f, 127, sizeof(f)); \n  inf = f[0]; \n  printf(\"%d\\n\", ans + dfs(x)); \n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int TOT = 1 << 15, N = 100010;\nint dp[TOT],n,val[N],cnt[16],ans,sta,res[TOT];\nint main() {\n  int a,b,c,tmp;\n  scanf(\"%d\",&n);\n  for (int i = 1 ; i < n ; ++ i) {\n    scanf(\"%d%d%d\",&a,&b,&c);\n    a++, b++;\n    val[a] ^= c;\n    val[b] ^= c;\n  }\n  for (int i = 1 ; i <= n ; ++ i)\n    ++ cnt[val[i]];\n  ans = n;\n  ans -= cnt[0];\n  for (int i = 1 ; i <= 15 ; ++ i)\n    ans -= cnt[i]/2, sta |= (cnt[i]&1) << i >> 1;\n  for (int i = 0 ; i < TOT ; ++ i) {\n    tmp = 0;\n    for (int j = 1 ; j <= 15 ; ++ j)\n      if ((i >> j-1)&1) tmp ^= j;\n    res[i] = tmp;\n  }\n  for (int i = 1 ; i < TOT ; ++ i) {\n    for (int j = i ; j ; j = (j-1) & i)\n      if (!res[j]) dp[i] = max(dp[i],dp[i^j] + 1);\n  }\n  ans -= dp[sta];\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\nint qmax(int a, int b){\n\treturn (a > b) ? a : b;\n}\n\nint n;\nint val[100100];\nint cnt[20];\nint res;\nint target_mask;\nbool good[33333];\nint dp[33333];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n-1){\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\ta--, b--;\n\t\tval[a] ^= c;\n\t\tval[b] ^= c;\n\t}\n\trep(i, n) if(val[i]) cnt[val[i]]++;\n\tres = 0;\n\tint bp = 0;\n\trep(i, 16){\n\t\tres += (cnt[i] / 2);\n\t\tif(i){\n\t\t\tbp += (cnt[i] & 1);\n\t\t\ttarget_mask |= ((cnt[i] & 1) << (i-1));\n\t\t}\n\t}\n\trep(mask, 1<<15){\n\t\tint XORsum = 0;\n\t\trep(i, 15){\n\t\t\tint now = i+1;\n\t\t\tif(mask & (1 << i)) XORsum ^= now;\n\t\t}\n\t\tif(XORsum == 0) good[mask] = 1;\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\trep(mask, 1<<15){\n\t\tint mask2 = mask;\n\t\twhile(mask2 > 0){\n\t\t\tif(good[mask2]) dp[mask] = qmax(dp[mask], dp[mask ^ mask2] + 1);\n\t\t\tmask2 = (mask2 - 1) & mask;\n\t\t}\n\t}\n\tcout << res + bp - dp[target_mask] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt[100003],cntt[16],ans;\nint dp[65536];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){int x,y,a;cin>>x>>y>>a;cnt[x]^=a;cnt[y]^=a;}\n\tfor(int i=0;i<n;i++)cntt[cnt[i]]++;\n\tfor(int i=1;i<16;i++)ans+=cntt[i]/2,cntt[i]%=2;\n\tint tmp=0;for(int i=1;i<16;i++)tmp=tmp+cntt[i]*(1<<i);\n\tmemset(dp,31,sizeof(dp));\n\tdp[tmp]=0; \n\tfor(int i=tmp;i>0;i-=2)\n\t\tif(dp[i]<20000000)\n\t\t\tfor(int j=1;j<16;j++)\n\t\t\t\tfor(int k=j+1;k<16;k++)\n\t\t\t\t\tif((i|(1<<j))==i&&(i|(1<<k))==i)\n\t\t\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t\t\t\tif(((j|k)|l)==(j|k))\n\t\t\t\t\t\t\t\tdp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]=min(dp[i]+1+bool((i&(1<<(j^l)))!=0)+\n\t\t\t\t\t\t\t\tbool((i&(1<<(k^l)))!=0),dp[(((i-(1<<j)-(1<<k))^(1<<(j^l)))^(1<<(k^l)))/2*2]);\n\tcout<<ans+dp[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n        a[u] ^= w;\n        a[v] ^= w;\n    }\n    vector<int> cnt(16);\n    for (int i = 0; i < n; ++i) cnt[a[i]]++;\n    int ans = 0;\n    cnt[0] = 0;\n    for (int i = 1; i < 16; ++i) {\n        ans += cnt[i] / 2;\n        cnt[i] &= 1;\n    }\n    vector<int> gd(1 << 16), dp(1 << 16);\n    for (int s = 0; s < (1 << 16); ++s) {\n        int v = 0;\n        for (int i = 0; i < 16; ++i) {\n            if (s >> i & 1) v ^= i;\n        }\n        if (v == 0) gd[s] = 1;\n    }\n    dp[0] = 0;\n    for (int s = 1; s < (1 << 16); ++s) {\n        dp[s] = -(1 << 16);\n        for (int sub = s; sub > 0; sub = (sub - 1) & s) {\n            if (gd[sub]) dp[s] = max(dp[s], dp[s ^ sub] + 1);\n        }\n    }\n    int mask = 0;\n    for (int i = 0; i < 16; ++i) {\n        if (cnt[i] > 0) {\n            mask |= (1 << i);\n            ans++;\n        }\n    }\n    printf(\"%d\\n\", ans - dp[mask]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nbool Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot|=(1<<(i-1));\n\tfor(int i=1;i<(1<<N);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<N);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<N);s++){\n\t\tfor(int i=0;i<=15;i++){\n\t\t\tif((1<<i)&s)Xor[s]^=(i+1);\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<N);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing i64 = long long;\n\nstd::vector<std::vector<std::pair<int, int>>> g;\nint cnt[16];\n\nauto precalc() {\n    std::vector<int> ret(1 << 16);\n    for (int i = 1; i < (1 << 16); i++) {\n        int x = 0;\n        for (int j = 0; j < 16; j++) if (i & (1 << j)) x ^= j;\n        int max = !x;\n        for (int j = i; j > 0; j = (j - 1) & i) {\n            const int v = ret[j] + ret[j ^ i];\n            if (v > max) max = v;\n        }\n        ret[i] = max;\n    }\n    return ret;\n}\n\nvoid dfs(const int v, const int p, int x) {\n    for (const auto &edge : g[v]) {\n        if (edge.first == p) continue;\n        dfs(edge.first, v, edge.second);\n        x ^= edge.second;\n    }\n    if (p >= 0) cnt[x]++;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    g.resize(n);\n    for (int i = 1; i < n; i++) {\n        int u, v, a;\n        std::cin >> u >> v >> a;\n        g[u].emplace_back(v, a);\n        g[v].emplace_back(u, a);\n    }\n\n    const auto v = precalc();\n    dfs(0, -1, 0);\n\n    int ret = n - 1 - cnt[0], mask = 0;\n    for (int i = 1; i < 16; i++) {\n        ret -= cnt[i] / 2;\n        if (cnt[i] & 1) mask |= 1 << i;\n    }\n\n    std::cout << ret - v[mask] << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pii pair<int,int>\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 100001;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nbool v[1 << 15];\nint cc[N], cnt[16], bin[16], f[1 << 15], one[1 << 15];\n\nint main() {\n\tint n = read();\n\tfor(int i = 1; i < n; i++) {\n\t\tint x = read(), y = read(), c = read();\n\t\tcc[x] ^= c, cc[y] ^= c;\n\t} for(int i = 0; i < 16; i++) cnt[cc[i]]++;\n\tbin[0] = 1; for(int i = 1; i < 16; i++) bin[i] = bin[i - 1] << 1;\n\tint ans = 0, S = 0; for(int i = 1; i < 16; i++) ans += cnt[i] / 2, S += cnt[i] & 1 ? bin[i - 1] : 0;\n\tfor(int i = 0; i < bin[15]; i++) {\n\t\tint sum = 0;\n\t\tfor(int j = 0; j < 15; j++) if(i & bin[j]) sum ^= j + 1;\n\t\tif(!sum) v[i] = 1;\n\t} memset(f, 63, sizeof(f));\n\tf[0] = 0; for(int i = 1; i <= S; i++) {\n\t\tone[i] = one[i >> 1] + (i & 1);\n\t\tif(v[i]) {\n\t\t\tf[i] = one[i] - 1;\n\t\t\tfor(int j = (i - 1) & i; j; j = (j - 1) & i) if(v[j]) f[i] = _min(f[i], f[i ^ j] + f[j]);\n\t\t}\n\t} put(f[S] + ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> p(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b, c;\n                scanf(\"%d %d %d\", &a, &b, &c);\n                p[a] ^= c;\n                p[b] ^= c;\n        }\n        vector<int> cnt(16, 0);\n        for (int i = 0; i < n; i ++) {\n                cnt[p[i]] ++;\n        }\n        int ans = 0;\n        int mask = 0;\n        for (int i = 1; i < 16; i ++) {\n                ans += cnt[i] / 2;\n                if (cnt[i] & 1) {\n                        mask |= 1 << i;\n                }\n        }\n        vector<bool> ok(1 << 16, 0);\n        for (int i = 0; i < (1 << 16); i ++) {\n                int check = 0;\n                for (int j = 0; j < 16; j ++) {\n                        if (i & (1 << j)) {\n                                check ^= j;\n                        }\n                }\n                ok[i] = check == 0;\n        }\n        vector<int> dp(1 << 16, 0);\n        for (int i = 0; i < (1 << 16); i ++) {\n                if (i & 1) continue;\n                int sub = i;\n                while (sub > 0) {\n                        if (ok[sub]) {\n                                dp[i] = max(dp[i], dp[i ^ sub] + 1);\n                        }\n                        sub = (sub - 1) & i;\n                }\n        }\n        printf(\"%d\\n\", ans + __builtin_popcount(mask) - dp[mask]);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  \n  vector<Int> cnt(n,0);\n  for(Int i=1;i<n;i++){\n    Int u,v,a;\n    cin>>u>>v>>a;\n    cnt[u]^=a;\n    cnt[v]^=a;\n  }\n  \n  Int ans=0,res=0;\n  for(Int i=0;i<n;i++){\n    if(!cnt[i]) continue;\n    ans+=__builtin_popcount(cnt[i]);\n    if((res>>cnt[i])&1)\n      ans-=(__builtin_popcount(cnt[i])-1);\n    res^=1<<cnt[i];\n  }\n  //cout<<ans<<\":\"<<res<<endl;\n  ans/=2;\n  \n  const Int INF = 1e9;\n  vector<Int> dp(1<<16,-INF);\n  dp[res]=0;\n  for(Int b=(1<<16)-1;b>0;b--){\n    for(Int i=0;i<16;i++){\n      if((~b>>i)&1) continue;\n      for(Int j=0;j<i;j++){\n\tif((~b>>j)&1) continue;\n\tif(!(i&j)) continue;\n\tInt dif=__builtin_popcount(i&j)-1;\n\tchmax(dp[b^(1<<i)^(1<<j)],dp[b]+dif);\n      }\n    }\n  }\n  ans-=*max_element(dp.begin(),dp.end());\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst ll INF = 1e15;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\n\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid shortestPath(const Graph &g, int s,\n\tvector<Weight> &dist, vector<int> &prev) {\n\tint n = g.size();\n\tdist.assign(n, INF); dist[s] = 0;\n\tprev.assign(n, -1);\n\tpriority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n\tfor (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n\t\tEdge e = Q.top(); Q.pop();\n\t\tif (prev[e.dst] != -1) continue;\n\t\tprev[e.dst] = e.src;\n\t\tfor (auto f = g[e.dst].begin();f != g[e.dst].end();f++) {\n\t\t\tif (dist[f->dst] > e.weight + f->weight) {\n\t\t\t\tdist[f->dst] = e.weight + f->weight;\n\t\t\t\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvector<ll> node(N);\n\tfor (int i = 0;i < N - 1;i++) {\n\t\tll x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tnode[x] ^= a;\n\t\tnode[y] ^= a;\n\t}\n\tvector<ll> num(16);\n\tll ans = 0;\n\tfor (auto &&x : node) {\n\t\tif (x == 0)\n\t\t\tcontinue;\n\t\tif (num[x]) {\n\t\t\tnum[x] = 0;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t\tnum[x] = 1;\n\t}\n\tll start = 0;\n\tfor (ll i = 1;i < 16;i++)\n\t\tstart |= num[i] << (i - 1);\n\tGraph g(1 << 15);\n\tfor (ll from = 0;from < 1 << 15;from++) {\n\t\tll a = 0;\n\t\twhile (a < 15) {\n\t\t\twhile ((from & (1 << a)) == 0 && a < 15)\n\t\t\t\ta++;\n\t\t\tif (a >= 15)\n\t\t\t\tbreak;\n\t\t\tll b = a + 1;\n\t\t\twhile (b < 15) {\n\t\t\t\twhile ((from & (1 << b)) == 0 && b < 15)\n\t\t\t\t\tb++;\n\t\t\t\tif (b >= 15)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (ll use = 1;use <= 15;use++) {\n\t\t\t\t\tll ak = a + 1;\n\t\t\t\t\tll an = ak ^ use;\n\t\t\t\t\tll bk = b + 1;\n\t\t\t\t\tll bn = bk ^ use;\n\t\t\t\t\tll cost = 1;\n\t\t\t\t\tll next = from;\n\t\t\t\t\tnext ^= 1 << a;\n\t\t\t\t\tnext ^= 1 << b;\n\t\t\t\t\tan--;\n\t\t\t\t\tif (an != -1 && next & (1 << an))\n\t\t\t\t\t\tcost++;\n\t\t\t\t\tif(an >= 0)\n\t\t\t\t\t\tnext ^= 1 << an;\n\t\t\t\t\tbn--;\n\t\t\t\t\tif (bn != -1 && next & (1 << bn))\n\t\t\t\t\t\tcost++;\n\t\t\t\t\tif(bn >= 0)\n\t\t\t\t\t\tnext ^= 1 << bn;\n\t\t\t\t\tg[from].push_back(Edge(from, next, cost));\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\ta++;\n\t\t}\n\t}\n\tvector<Weight> dist;\n\tvector<int> prev;\n\tshortestPath(g, start, dist, prev);\n\tcout << dist[0] + ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#include <unistd.h>\n//#include <iostream>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nvector<vector<pii>> G;\n\nsigned main() {\n  int n;\n  cin >> n;\n  G.resize(n);\n  rep (i, n - 1) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    G[u].emplace_back(v, c);\n    G[v].emplace_back(u, c);\n  }\n\n  vi a(n), c(16);\n  rep (i, n) {\n    rep (j, G[i].size()) {\n      a[i] ^= G[i][j].second;\n    }\n    c[a[i]]++;\n  }\n\n  int ans = 0;\n  ll mask = 0;\n  rep (i, 16) {\n    if (i == 0) {\n      c[i] = 0;\n      continue;\n    }\n    ans += c[i] / 2;\n    c[i] %= 2;\n    if (c[i]) {\n      mask += 1 << i;\n    }\n  }\n  DEBUG_VEC(c);\n  vector<vector<bool>> dp(100, vector<bool>(1 << 16, false));\n  dp[0][mask] = true;\n  rep (i, 100) {\n    if (dp[i][0] or dp[i][1]) {\n      cout << i + ans << endl;\n      return 0;\n    }\n    rrep (j, 1 << 16) {\n      if (not dp[i][j]) continue;\n      rep (k1, 16) {\n        if (k1 == 0) continue;\n        if ((j & (1 << k1)) == 0) continue;\n        rep (k2, 16) {\n          if (k2 == 0) continue;\n          if (k1 == k2) continue;\n          if ((j & (1 << k2)) == 0) continue;\n          int k3 = k1 ^ k2;\n          int nj = j;\n          nj -= 1 << k1;\n          nj -= 1 << k2;\n          nj ^= 1 << k3;\n          if (j & (1 << k3)) {\n            dp[i + 2][nj] = true;\n          }\n          else {\n            dp[i + 1][nj] = true;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int inf = 1012345678;\nclass edge {\npublic:\n\tint to, cost;\n\tedge() : to(-1), cost(0) {};\n\tedge(int to_, int cost_) : to(to_), cost(cost_) {};\n};\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<edge> > G(N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\tvector<int> col(N);\n\tfunction<int(int, int, int)> set_col = [&](int pos, int pre, int pcol) {\n\t\tint res = 0;\n\t\tfor (edge e : G[pos]) {\n\t\t\tif (e.to == pre) continue;\n\t\t\tset_col(e.to, pos, e.cost);\n\t\t\tres ^= e.cost;\n\t\t}\n\t\tres ^= pcol;\n\t\tcol[pos] = res;\n\t\tres ^= col[pos];\n\t\treturn res;\n\t};\n\tset_col(0, -1, 0);\n\tvector<int> tbl(16);\n\tfor (int i = 0; i < N; ++i) {\n\t\t++tbl[col[i]];\n\t}\n\tint bit = 0, ans = 0;\n\tfor (int i = 1; i < 16; ++i) {\n\t\tans += (tbl[i] >> 1);\n\t\tbit |= (tbl[i] & 1) << i;\n\t}\n\tqueue<pair<int, int> > que;\n\tvector<int> dist(1 << 16, inf);\n\tque.push(make_pair(0, bit));\n\tdist[bit] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.front().second; que.pop();\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\tif (!((u >> i) & 1)) continue;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (!((u >> j) & 1)) continue;\n\t\t\t\tint b = u ^ (1 << i) ^ (1 << j);\n\t\t\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\t\t\tif ((i ^ j ^ k) == 0) continue;\n\t\t\t\t\tint tar = b ^ (1 << (i ^ k)) ^ (1 << (j ^ k)), cost = 1;\n\t\t\t\t\tif ((u >> (i ^ k)) & 1) ++cost;\n\t\t\t\t\tif ((u >> (j ^ k)) & 1) ++cost;\n\t\t\t\t\tif (dist[tar] > dist[u] + cost) {\n\t\t\t\t\t\tdist[tar] = dist[u] + cost;\n\t\t\t\t\t\tque.push(make_pair(-dist[tar], tar));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans += min(dist[0], dist[1]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\nconst int maxn = 1e5 + 42;\n\nvector<pair<int, int>> g[maxn];\n\nvoid make_edge(int u, int v, int c) {\n    g[u].push_back({v, c});\n    g[v].push_back({u, c});\n}\n\nint xr[4 * maxn];\n\nint get(int a, int b, int v = 1, int l = 0, int r = maxn) {\n    if(a <= l && r <= b) {\n        return xr[v];\n    } else if(r <= a || b <= l) {\n        return 0;\n    } else {\n        int m = (l + r) / 2;\n        return get(a, b, 2 * v, l, m) ^ get(a, b, 2 * v + 1, m, r);\n    }\n}\n\nvoid upd(int p, int c, int v = 1, int l = 0, int r = maxn) {\n    xr[v] ^= c;\n    if(r - l == 1) {\n        return;\n    }\n    int m = (l + r) / 2;\n    if(p < m) {\n        upd(p, c, 2 * v, l, m);\n    } else {\n        upd(p, c, 2 * v + 1, m, r);\n    }\n}\n\nint z[maxn];\nint in[maxn], out[maxn], t;\nvoid dfs(int v, int p) {\n    in[v] = t++;\n    for(auto it: g[v]) {\n        int u = it.first;\n        int x = it.second;\n        if(u != p) {\n            dfs(u, v);\n            z[u] = x;\n        }\n    }\n    out[v] = t;\n}\n\nint deg[maxn];\n\nmap<vector<int>, int> ans;\nvector<int> zmasks;\nint solve(vector<int> &need) {\n    if(!ans.count(need)) {\n        int res = accumulate(begin(need), end(need), 0);\n        for(auto it: zmasks) {\n            int t = 1e6;\n            for(int i = 0; i < 16; i++) {\n                if((it >> i) & 1) {\n                    t = min(t, need[i]);\n                }\n            }\n            for(int i = 0; i < 16; i++) {\n                if((it >> i) & 1) {\n                    need[i] -= t;\n                }\n            }\n            if(t) {\n                res = min(res, solve(need) + t * (__builtin_popcount(it) - 1));\n            }\n            for(int i = 0; i < 16; i++) {\n                if((it >> i) & 1) {\n                    need[i] += t;\n                }\n            }\n        }\n        ans[need] = res;\n    }\n    return ans[need];\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    int x[n - 1], y[n - 1], a[n - 1];\n    for(int i = 0; i < n - 1; i++) {\n        cin >> x[i] >> y[i] >> a[i];\n        make_edge(x[i], y[i], a[i]);\n    }\n    dfs(0, 0);\n    deque<int> que;\n    for(int i = 1; i < n; i++) {\n        deg[i] = g[i].size();\n        if(deg[i] == 1) {\n            que.push_back(i);\n        }\n    }\n    vector<int> need(16);\n    while(!que.empty()) {\n        int v = que.front();\n        que.pop_front();\n        deg[v]--;\n        for(auto it: g[v]) {\n            int u = it.first;\n            if(u > 0 && deg[u] > 0) {\n                deg[u]--;\n                if(deg[u] == 1) {\n                    que.push_back(u);\n                }\n            }\n        }\n        int t = get(in[v], out[v]);\n        need[t ^ z[v]]++;\n        upd(in[v], t ^ z[v]);\n    }\n    need[0] = 0;\n    int mask_sz = 1 << 16;\n    int zero[mask_sz];\n    memset(zero, 0, sizeof(zero));\n    for(int mask = 2; mask < mask_sz; mask += 2) {\n        int cur = 0;\n        for(int i = 0; i < 16; i++) {\n            if((mask >> i) & 1) {\n                cur ^= i;\n            }\n        }\n        zero[mask] = cur == 0;\n        for(int sub = mask & (mask - 1); sub; sub = (sub - 1) & mask) {\n            if(zero[sub]) {\n                zero[mask] = 0;\n                break;\n            }\n        }\n        if(zero[mask]) {\n            zmasks.push_back(mask);\n        }\n    }\n    cout << solve(need) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair <int, int> pii;\nint mem[1 << 15];\n\nvector <pii> g[100010];\nint dep[100010];\nint cnt[20];\nint val[1 << 17];\n\nvoid dfs(int x, int par) {\n\tfor(auto i : g[x]) {\n\t\tif(i.first - par) {\n\t\t\tdfs(i.first, x);\n\t\t\tdep[i.first] = i.second ^ dep[x];\n\t\t}\n\t}\n}\n\nint dp(int mask) {\n\tif(mask == 0) return 0;\n\tif(mem[mask] != -1) return mem[mask];\n\tint ans = 0;\n\tfor(int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\tif(val[submask] == 0) {\n\t\t\tans = max(ans, 1 + dp(mask ^ submask));\n\t\t}\n\t}\n\treturn mem[mask] = ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tmemset(mem, -1, sizeof mem);\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\t\tg[p].push_back(pii(q, r));\n\t\tg[q].push_back(pii(p, r));\n\t}\n\tdfs(0, -1);\n\tvector <int> v;\n\tint comp = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tcnt[dep[i]] += 1;\n\t}\n\tfor(int i = 1; i < 16; i++) {\n\t\tif(cnt[i] & 1) {\n\t\t\tv.push_back(i);\n\t\t}\n\t\tcomp += cnt[i] >> 1;\n\t}\n\tcomp += cnt[0];\n\t// for(auto i : v) cout << i << endl;\n\tfor(int i = 0; i < (1 << v.size()); i++) {\n\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\tif((i >> j) & 1) {\n\t\t\t\tval[i] ^= v[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint check = 0;\n\tfor(auto i : v) {\n\t\tcheck ^= i;\n\t}\n\tassert(check == 0);\n\n\tcomp += dp((1 << v.size()) - 1);\n\tcout << n - comp << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\nlong long dp[100005][20];\nvector<pair<int,int> > V[100005];\nvoid dfs(int n=0,int p=-1,int val=0){\n    if(V[n].size()==1 && p!=-1){\n        dp[n][val]=0;\n        if(val) dp[n][0]=1;\n        return;\n    }\n    long long temp[20];\n    for(int i=0;i<20;++i) temp[i]=1000000000;\n    bool flag=1;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i].first==p) continue;\n        dfs(V[n][i].first,n,V[n][i].second);\n        if(flag){\n            flag=0;for(int j=0;j<20;++j) temp[j]=dp[V[n][i].first][j];\n        }\n        else{\n            long long temp2[20];\n            for(int i=0;i<20;++i) temp2[i]=1000000000;\n            for(int j=0;j<=15;++j){\n                for(int k=0;k<=15;++k){\n                    int u=(j^k);\n                    temp2[u]=min(temp2[u],temp[j]+dp[V[n][i].first][k]+1);\n\n                    temp2[j]=min(temp2[j],temp[j]+dp[V[n][i].first][k]+(k!=0));\n                    temp2[k]=min(temp2[k],temp[j]+dp[V[n][i].first][k]+(j!=0));\n                    temp2[0]=min(temp2[0],temp[j]+dp[V[n][i].first][k]+(k!=0) + (j!=0));\n                }\n\n            }\n            for(int i=0;i<20;++i) temp[i]=temp2[i];\n\n        }\n    }\n    for(int i=0;i<=15;++i){\n        if(val==i){\n            dp[n][i]=temp[i];\n            dp[n][0]=min(dp[n][0],temp[i]+1);\n        }\n        else{\n            dp[n][(val^i)]=min(dp[n][val^i],temp[i]+(val!=0));\n            dp[n][i]=min(dp[n][i],temp[i]+(val!=0));\n\n        }\n    }\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);\n        V[a].push_back(make_pair(b,c));\n        V[b].push_back(make_pair(a,c));\n    }\n    for(int i=0;i<n;++i) for(int j=0;j<20;++j) dp[i][j]=1000000000;\n    dfs();\n    long long ans=1000000000;\n    for(int i=1;i<=15;++i) ans=min(ans,dp[0][i]+1);\n    ans=min(ans,dp[0][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> adj[100010], U, V, W;\nint B[100010], cnt[16];\n\nint dp1(int idx, int mask);\n\nunordered_map<int, int> cc2[10][20][20];\nint dp2(int tidx, int tcnt, int idx, int mask) {\n    if(tcnt >= 20) return 1e9;\n    if(tidx == 8 || tidx == idx) {\n        int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n        if((tmp - tcnt) % 2) return 1e9;\n        else return (tmp - tcnt) / 2 + dp1(idx - 1, mask & ((1 << idx) - 1));\n    }\n    if((idx | tidx) != idx || tidx > (idx ^ tidx)) return dp2(tidx + 1, tcnt, idx, mask);\n\n    if(cc2[tidx][tcnt][idx].find(mask) != cc2[tidx][tcnt][idx].end()) return cc2[tidx][tcnt][idx][mask];\n    int &ret = cc2[tidx][tcnt][idx][mask];\n\n    int tmp = cnt[idx] + ((mask & (1 << idx))? 1 : 0);\n    if(tcnt == tmp) return ret = dp1(idx - 1, mask);\n\n    int didx = idx ^ tidx;\n\n    ret = 1e9;\n    ret = min(ret, dp2(tidx + 1, tcnt, idx, mask));\n    ret = min(ret, ((mask & (1 << tidx))? 1 : 0) + ((mask & (1 << didx))? 1 : 0) + dp2(tidx, tcnt + 1, idx, mask ^ (1 << tidx) ^ (1 << didx)));\n    return ret;\n}\n\nint cc1[16][1 << 16];\nint dp1(int idx, int mask) {\n    if(idx == 0) return 0;\n    int &ret = cc1[idx][mask];\n    if(ret != -1) return ret;\n\n    return ret = dp2(1, 0, idx, mask);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n\n        adj[u].push_back(U.size());\n        adj[v].push_back(U.size());\n        U.push_back(u);\n        V.push_back(v);\n        W.push_back(w);\n    }\n\n    for(int b = 0; b < 4; b++) {\n        for(int u = 0; u < N; u++) {\n            int tmp = 0;\n            for(int i = 0; i < adj[u].size(); i++) {\n                int e = adj[u][i];\n\n                if(W[e] & (1 << b)) tmp++;\n            }\n            if(tmp % 2) B[u] |= (1 << b);\n        }\n    }\n\n    for(int i = 0; i < N; i++) cnt[ B[i] ]++;\n\n    memset(cc1, -1, sizeof(cc1));\n    printf(\"%d\", dp1(15, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll maxn = 1e5 + 5;\nconst ll maxm = 1e3 + 5;\nconst ll inf = 0x3f3f3f3f3f3f3f3fll;\nnamespace IO{\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;\n    char _st[55];\n    int _qr = 0;\n    inline char gc(){\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread(){}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls){\n        register T1 __ = 0, ___ = 1;\n        register char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do{\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n    inline void flush(){\n        fwrite(obuf, 1, oS - obuf, stdout);\n        oS = obuf;\n        return ;\n    }\n    inline void putc_(char _x){\n        *oS++ = _x;\n        if(oS == oT) flush();\n    }\n    inline void qwrite(){}\n    template<class T1, class ...T2>\n    inline void qwrite(T1 IEE, T2... ls){\n        if(!IEE) putc_('0');\n        if(IEE < 0) putc_('-'), IEE = -IEE;\n        while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n        while(_qr) putc_(_st[_qr--]);\n        qwrite(ls...);\n        return ;\n    }\n    struct Flusher_{~Flusher_(){flush();}}io_flusher;\n}\nusing namespace IO;\nll n, u_, v_, w_;\nll v[maxm], dp[1 << 16];\nll cnt[maxn];\nll ans;\nll DP(ll S){\n    // cout << S << endl;\n    if(dp[S] != inf) return dp[S];\n    for(int i = 0;i < 16;i++){\n        if(((S >> i) & 1) == 0) continue;\n        for(int j = 0;j < 16;j++){\n            if(((S >> j) & 1) == 0) continue;\n            ll k = i ^ j;\n            if(k == 0){\n                dp[S] = min(dp[S], DP(S ^ (1 << i)) + 1);\n            } else if(((S >> k) & 1) == 0){\n                dp[S] = min(dp[S], DP(S ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 1);\n            } else {\n                dp[S] = min(dp[S], DP(S ^ (1 << i) ^ (1 << j) ^ (1 << k)) + 2);\n            }\n        }\n    }\n    return dp[S];\n}\nint main(){\n    cin.tie(0);\n    cin >> n;\n    for(int i = 1;i < n;i++){\n        cin >> u_ >> v_ >> w_;\n        v[u_] ^= w_;\n        v[v_] ^= w_;\n    }\n    for(int i = 0;i < n;i++){\n        cnt[v[i]]++;\n    }\n    ll init = 0;\n    for(int i = 1;i <= 15;i++){\n        ans += cnt[i] / 2;\n        // cout << cnt[i] << endl;\n        if(cnt[i] & 1){\n            init |= (1 << i);\n        }\n    }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[0] = 0;\n    cout << ans + DP(init) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[100020];\nint n, x, y, z;\nint w[100020];\nint c[16];\nint f[65537];\nint g[65537];\nint ans, mask;\nint dfs(int x, int y) {\n\tint re = w[x];\n\tfor (int i: a[x]) {\n\t\tif (i != y) {\n\t\t\tre ^= dfs(i, x);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t\tw[x] ^= z;\n\t\tw[y] ^= z;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tc[w[i]]++;\n\t}\n\tfor (int i = 1; i < 16; i++) {\n\t\tans += c[i] / 2;\n\t\tc[i] %= 2;\n\t\tmask |= c[i] << i;\n\t}\n\tfor (int i = 0; i < 1 << 16; i++) {\n\t\tint v = 0, c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tv ^= j;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif (v == 0) {\n\t\t\tf[i] = c - 1;\n\t\t} else {\n\t\t\tf[i] = -1;\n\t\t}\n\t\tfor (int j = i; ; j = (j - 1) & i) {\n\t\t\tif (f[j] >= 0 && f[i ^ j] >= 0) {\n\t\t\t\tf[j] = min(f[j], f[i] + f[i ^ j]);\n\t\t\t}\n\t\t\tif (j == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans + f[mask]);\n//\tdfs(0, -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\nããããããããããã â§ï¼¿â§  \nããããã â§ï¼¿â§ ãï¼Â´<_ï½ ï¼ã Welcome to My Coding Space!\nãããã ï¼ Â´_ã`ï¼ã/ã âi     \nããããï¼ãããï¼¼ã ã  |ã|     \nããã /ãã /ï¿£ï¿£ï¿£ï¿£/ãã|  \nã ï¼¿_(__ï¾ã¤/ã    ï¼¿/ .| .|ï¼¿ï¼¿ï¼¿ï¼¿  \nã ãããï¼¼/ï¼¿ï¼¿ï¼¿ï¼¿/ãï¼uãâ  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, A[101010], C[20];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N - 1) {\n        int a, b, c; cin >> a >> b >> c;\n        A[a] ^= c;\n        A[b] ^= c;\n    }\n    rep(i, 0, N) C[A[i]]++;\n\n    //rep(i, 0, 16) printf(\"%d \", C[i]); printf(\"\\n\");\n\n    int ans = 0;\n    rep(i, 1, 16) {\n        ans += C[i] / 2;\n        C[i] %= 2;\n    }\n\n    int x = 0;\n    rep(i, 1, 16) if (C[i]) x ^= i;\n    if (x != 0) {\n        printf(\"-1\\n\");\n        return;\n    }\n\n    vector<int> xo;\n    rep(i, 1, 16) if (C[i]) xo.push_back(i);\n    int n = xo.size();\n    vector<int> dp(1 << n);\n\n    rep(msk, 1, 1<<n) {\n        int x = 0;\n        rep(i, 0, n) if (msk & (1 << i)) x ^= xo[i];\n        if (x == 0) dp[msk] = 1;\n\n        for (int msk2 = msk; msk2>0; msk2 = (msk2 - 1)&msk) {\n            if (0 < dp[msk2] and 0 < dp[msk - msk2]) chmax(dp[msk], dp[msk2] + dp[msk - msk2]);\n        }\n    }\n\n    ans += n - dp[(1 << n) - 1];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N=100010,M=16;\nint s[N],cnt[M],ans,f[1000010];\nvoid chkmin(int &x,int y)\n{\n\tif(y<x)x=y;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint u,v,w;\n\tfor(int i=1;i<n;i++)\n\t\tscanf(\"%d%d%d\",&u,&v,&w),s[u]^=w,s[v]^=w;\n\tfor(int i=0;i<n;i++)\n\t\tcnt[s[i]]++;\n\tint now=0;\n\tfor(int i=1;i<16;i++)\n\t\tans+=cnt[i]/2,now+=((cnt[i]&1)<<i-1);\n\tmemset(f,127,sizeof(f)); f[now]=0;\n\tfor(int i=(1<<15)-1;i;i--)\n\t\tif(f[i]<2000000000)\n\t\t{\n\t\t\tfor(int j=1;j<=15;j++)\n\t\t\t\tif(i&(1<<j-1))\n\t\t\t\t\tfor(int k=1;k<=15;k++)\n\t\t\t\t\t\tif(i&(1<<k-1) && j!=k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint l=j^k;\n\t\t\t\t\t\t\tif(i&(1<<l-1))\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)-(1<<l-1)],f[i]+2);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchkmin(f[i-(1<<j-1)-(1<<k-1)+(1<<l-1)],f[i]+1);\n\t\t\t\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[0]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define LL long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\ninline int read() {\n\tchar c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;\n}\nconst int inf=1e9;\nconst int maxn=1e5+5;\nint d[maxn],cnt[16],dp[1<<16],vis[1<<16],n;\nint dfs(int S) {\n\tif(!S) return 0;\n\tif(vis[S]) return dp[S];\n\tdp[S]=inf;vis[S]=1;\n\tfor(re int i=1;i<16;++i) \n\t\tfor(re int j=i+1;j<16;++j) \n\t\t\tif((S>>(j-1)&1)&&(S>>(i-1)&1)) {\n\t\t\t\tint x=S^(1<<(i-1))^(1<<(j-1));\n\t\t\t\tif(x>>((i^j)-1)&1) \n\t\t\t\t\tdp[S]=min(dp[S],dfs(x^(1<<(i^j)-1))+2);\n\t\t\t\telse dp[S]=min(dp[S],dfs(x|(1<<(i^j)-1))+1);\n\t\t\t}\n\treturn dp[S];\n}\nint main() {\n\tn=read();\n\tfor(re int x,y,w,i=1;i<n;i++) {\n\t\tx=read(),y=read(),w=read();\n\t\td[x]^=w,d[y]^=w;\n\t}\n\tfor(re int i=1;i<=n;i++) cnt[d[i]]++;\n\tint S=0,nw=0;\n\tfor(re int i=1;i<16;++i) nw+=cnt[i]/2;\n\tfor(re int i=1;i<16;++i) if(cnt[i]&1) S|=(1<<(i-1));\n\tprintf(\"%d\\n\",nw+dfs(S)); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define LL long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\ninline int read() {\n\tchar c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;\n}\nconst int inf=1e9;\nconst int maxn=1e5+5;\nint d[maxn],cnt[16],dp[1<<16],vis[1<<16],n;\nint dfs(int S) {\n\tif(!S) return 0;\n\tif(vis[S]) return dp[S];\n\tdp[S]=inf;vis[S]=1;\n\tfor(re int i=1;i<16;++i) \n\t\tfor(re int j=i+1;j<16;++j) \n\t\t\tif((S>>(j-1)&1)&&(S>>(i-1)&1)) {\n\t\t\t\tint x=S^(1<<(i-1))^(1<<(j-1));\n\t\t\t\tif(x>>((i^j)-1)&1) \n\t\t\t\t\tdp[S]=min(dp[S],dfs(x^(1<<(i^j)-1))+2);\n\t\t\t\telse dp[S]=min(dp[S],dfs(x|(1<<(i^j)-1))+1);\n\t\t\t}\n\treturn dp[S];\n}\nint main() {\n\tn=read();\n\tfor(re int x,y,w,i=1;i<n;i++) {\n\t\tx=read(),y=read(),w=read();\n\t\td[x]^=w,d[y]^=w;\n\t}\n\tfor(re int i=0;i<n;i++) cnt[d[i]]++;\n\tint S=0,nw=0;\n\tfor(re int i=1;i<16;++i) nw+=cnt[i]/2;\n\tfor(re int i=1;i<16;++i) if(cnt[i]&1) S|=(1<<(i-1));\n\tprintf(\"%d\\n\",nw+dfs(S)); \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<int>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005,M=1<<16|2;\nint n,ans,d[N],a[N],dp[M],ycl[M];\nvector<PI> v[N];\nvoid dfs(){\n\tint sum=0; \n\tint zt=0;\n\tFor(i,1,n){\n\t\tint t=d[i]; if(!t){ans--; continue;};\n\t\tif(zt>>t&1)ans--; zt^=1<<t;\n\t}\n\t//cout<<\" \"<<zt<<\" \"<<dp[zt]<<endl;\n\tans-=dp[zt];\n}\nint main(){\n\tn=ans=read(); \n\tFor(i,1,n-1){\n\t\tint x=read(),y=read(),t=read();\n\t\td[x]^=t; d[y]^=t;\n\t}\n\tFor(i,0,(1<<16)-1){\n\t\tFor(j,0,15)if(i>>j&1)ycl[i]^=j;\n\t}\n\tFor(i,1,(1<<16)-1){\n\t\tfor(int j=i;j;j=(j-1)&i)if(!ycl[j])dp[i]=max(dp[i^j]+1,dp[i]);\n\t}\n\tdfs();\n\tcout<<ans<<endl;\n}\n/*\n3\n0 1 0\n1 2 3\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<cstring>\n#define Maxn 100000\nusing namespace std;\nint N;\nint dian[Maxn+5]={0};\nint cnt[20]={0};\nint ans=0;\nint f[1<<20];\nbool Xor[1<<20]={0};\nint main()\n{\n\t//memset(f,0x3f,sizeof(f));\n\tscanf(\"%d\",&N);\n\tfor(int i=1,x,y,c;i<N;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tx+=1,y+=1;\n\t\tdian[x]^=c;\n\t\tdian[y]^=c;\n\t}\n\tfor(int i=1;i<=N;i++)if(dian[i]!=0){\n\t\tcnt[dian[i]]++;\n\t\tif(cnt[dian[i]]==2)ans++,cnt[dian[i]]=0;\n\t}\n\tint tot=0;\n\t//for(int i=1;i<=N;i++)cout<<dian[i]<<endl;\n\tfor(int i=1;i<=15;i++)if(cnt[i])tot|=(1<<i);\n\tfor(int i=1;i<(1<<N);i++)f[i]=f[i>>1]+(i&1);\n\tfor(int i=1;i<(1<<N);i++)f[i]-=1;\n\tfor(int s=1;s<(1<<N);s++){\n\t\tfor(int i=0;i<=15;i++){\n\t\t\tif((1<<i)&s)Xor[s]^=(i+1);\n\t\t}\n\t}\n\tfor(int s=1;s<(1<<N);s++){\n\t\tif(Xor[s])continue;\n\t\tfor(int k=(s-1)&s;k;k=(k-1)&s){\n\t\t\tif(Xor[k])continue;\n\t\t\tf[s]=min(f[s],f[k]+f[s^k]);\n\t\t}\n\t}\n\tcout<<ans+f[tot];\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, ap[20], E[100009], d[1 << 16], frm[1 << 16];\nvector < pair < int, int > > h[100009];\nvector < pair < int, int > > v[1 << 16];\nbool ap2[1 << 16][4];\n\nvoid dfs (int nod, int tata)\n{\n    for (auto it : h[nod])\n        if (it.first != tata)\n            E[it.first] = it.second, dfs (it.first, nod), E[nod] ^= E[it.first];\n}\n\npriority_queue < pair < int, int > > PQ;\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y, z;\n    scanf (\"%d %d %d\", &x, &y, &z), x ++, y ++;\n    h[x].push_back ({y, z});\n    h[y].push_back ({x, z});\n}\ndfs (1, -1);\nfor (int i=2; i<=N; i++)\n    ap[E[i]] ++;\nint ans = 0, msk = 0;\nfor (int i=1; i<16; i++)\n{\n    if (ap[i] & 1) msk |= 1 << i;\n    ans += (ap[i] >> 1);\n}\nfor (int msk = 0; msk < (1 << 16); msk +=2)\n{\n    vector < pair < int, int > > curr;\n    for (int i=1; i<16; i++)\n    {\n        if (msk & (1 << i))\n        {\n            curr.push_back ({msk ^ (1 << i), 1});\n            int aux = msk ^ (1 << i);\n            for (int j=1; j<16; j++)\n                if (aux & (1 << j))\n                {\n                    if (aux & (1 << (j ^ i))) curr.push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 2});\n                    else curr.push_back ({aux ^ (1 << j) ^ (1 << (j ^ i)), 1});\n                }\n        }\n        else\n        {\n            for (int j=1; j<16; j++)\n                if (msk & (1 << j))\n                    for (int k=j + 1; k<16; k++)\n                        if (msk & (1 << k))\n                        {\n                            int to = msk ^ (1 << j) ^ (1 << k), cst = 1;\n                            if (to & (1 << (j ^ i))) cst ++;\n                            to ^= (1 << (j ^ i));\n                            if (to & (1 << (k ^ i))) cst ++;\n                            to ^= (1 << (k ^ i));\n                            curr.push_back ({to, cst});\n                        }\n            for (int j=1; j<16; j++)\n                if (msk & (1 << j))\n                {\n                    int to = msk ^ (1 << j), cst = 1;\n                    if (to & (1 << (j ^ i))) cst ++;\n                    to ^= (1 << (j ^ i));\n                    curr.push_back ({to, cst});\n                }\n        }\n    }\n    for (auto it : curr)\n        if (ap2[it.first][it.second] == 0)\n            ap2[it.first][it.second] = 1, v[msk].push_back (it);\n    for (auto it : v[msk])\n        ap2[it.first][it.second] = 0;\n}\nfor (int i=0; i<(1 << 16); i++)\n    d[i] = -1;\nPQ.push ({0, msk}), d[msk] = 0;\nwhile (!PQ.empty ())\n{\n    auto curr = PQ.top ();\n    PQ.pop ();\n    if (d[curr.second] != -curr.first) continue;\n    int nod = curr.second;\n    for (auto it : v[nod])\n        if (d[it.first] == -1 || (d[it.first] > d[nod] + it.second))\n            d[it.first] = d[nod] + it.second, PQ.push ({-d[it.first], it.first}), frm[it.first] = nod;\n}\nprintf (\"%d\\n\", ans + d[0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<ctime>\n#include<vector>\n#define INF 1e9\nusing namespace std;\nconst int maxn=100010;\nconst double Pi=acos(-1.0);\ntemplate<class T>void read(T &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9') {f|=(ch=='-');ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\tx=f?-x:x;\n\treturn;\n}\nint n,num[maxn],book[21],s;\nint f[(1<<15)+10],ans,sum;\nvector<int> a[21];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta++;\n\t\tb++;\n\t\tnum[a]^=c;\n\t\tnum[b]^=c;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbook[num[i]]++;\n\tfor(int i=1;i<=15;i++)\n\t{\n\t\tans+=(book[i]>>1);\n\t\ts|=(book[i]&1)<<i;//å¥æ°æåå©ä¸\n\t\tif(book[i]&1)\n\t\t\tsum++;\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[s]=0;\n\tfor(int i=0;i<=(1<<15)-1;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=15;j++)\n\t\t\tif(i&(1<<j))\n\t\t\t\tcnt++;\n\t\ta[cnt].push_back(i);\n\t}\n\tfor(int o=sum;o>=1;o--)\n\t\tfor(int p=0;p<a[o].size();p++)\n\t\t\tfor(int i=0;i<=15;i++)\n\t\t\t{\n\t\t\t\tif(!(p&(1<<i)))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=0;j<=15;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j||!(p&(1<<j)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint k=i^j;\n\t\t\t\t\tint t=p^(1<<i)^(1<<j)^(1<<k);\n\t\t\t\t\tif(p&(1<<k))\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tf[t]=min(f[t],f[p]+1);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\",ans+f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read(){\n    int x = 0,f = 1; char c = getchar();\n    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}\n    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}\n    return x * f;\n}\ninline void write(int x){\n    int k = 0;char put[40];\n    if (!x) putchar('0');\n    if (x < 0) putchar('-'),x = -x;\n    while (x)  put[++k] = (x % 10) + '0',x /= 10;\n    while (k)  putchar(put[k]),--k;\n\tputchar('\\n');\n}\nconst int N = 100005,L = 1<<15;\nint n,a[N],ans;\nint cnt[17],Q;\nint size[L],Xor[L],f[L];\nint main(){\n\tint i,j,k,u,v,w;\n\tn = read();\n\tfor (i = 1; i < n; ++i) u = read()+1,v = read()+1,w = read(),a[u] ^= w,a[v] ^= w;\n\tfor (i = 1; i <= n; ++i) ++cnt[a[i]];\n\tfor (i = 1; i <= 15; ++i){\n\t\tans += cnt[i] >> 1; if (cnt[i]&1) Q |= 1<<i-1;\n\t}\n\tfor (i = 1; i < L; ++i)\n\tfor (j = 1; j <= 15; ++j) if (i&(1<<j-1)) Xor[i] ^= j;\n\tfor (i = 1; i < L; ++i) size[i] = size[i>>1] + (i&1);\n\tfor (i = 1; i < L; ++i) if (Xor[i]) f[i] = 200; else f[i] = size[i] - 1;\n\tfor (i = 1; i <= Q; ++i){\n\t\tif (Xor[i]) continue;\n\t\tfor (j = (i-1)&i; j ; j = (j-1)&i) f[i] = min(f[i],f[i^j] + f[j]);\n\t}\n\tans += f[Q];\n\twrite(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nint solve(int n, const vector<int> & x, const vector<int> & y, const vector<int> & a) {\n    constexpr int MAX_A = 0xf;\n    assert (*max_element(ALL(a)) <= MAX_A);\n\n    // make the adjacent list\n    vector<vector<int> > g(n);\n    REP (i, n - 1) {\n        g[x[i]].push_back(y[i]);\n        g[y[i]].push_back(x[i]);\n    }\n\n    // fix a root\n    vector<int> parent(n, -1);\n    function<void (int)> go = [&](int i) {\n        for (int j : g[i]) if (j != parent[i]) {\n            parent[j] = i;\n            go(j);\n        }\n    };\n    constexpr int root = 0;\n    go(root);\n\n    // move labels to nodes\n    vector<int> b(n, -1);\n    REP (i, n - 1) {\n        if (parent[x[i]] == y[i]) {\n            b[x[i]] = a[i];\n        } else if (x[i] == parent[y[i]]) {\n            b[y[i]] = a[i];\n        } else {\n            assert (false);\n        }\n    }\n\n    // tree dp\n    int removed = 0;\n    function<array<bool, MAX_A + 1> (int)> dp = [&](int i) {\n        array<bool, MAX_A + 1> dp1 = {};\n        int k = b[i];\n        for (int j : g[i]) if (j != parent[i]) {\n            array<bool, MAX_A + 1> dp2 = dp(j);\n            REP (i, MAX_A + 1) if (dp2[i]) {\n                if (k != -1) {\n                    k ^= i;\n                }\n                removed += dp1[i];\n                dp1[i] ^= 1;\n            }\n        }\n        if (k >= 1) {\n            removed += dp1[k];\n            dp1[k] ^= 1;\n        }\n        return dp1;\n    };\n    array<bool, MAX_A + 1> dp1 = dp(root);\n\n    // finialize the count\n    REP (i, MAX_A + 1) if (dp1[i]) {\n        REP (j, i) if (dp1[j]) {\n            if (dp1[i ^ j]) {\n                dp1[i] = false;\n                dp1[j] = false;\n                dp1[i ^ j] = false;\n                removed += 2;\n                break;\n            }\n        }\n    }\n    return removed + accumulate(ALL(dp1), 0);\n}\n\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> x(n - 1), y(n - 1), a(n - 1);\n    REP (i, n - 1) {\n        cin >> x[i] >> y[i] >> a[i];\n    }\n\n    // solve\n    int answer = solve(n, x, y, a);\n\n    // output\n    cout << answer << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint ans,a[N],xx,y,v,n,cc[17],c[N],q;\ninline int dfs(int x){\n\tif(!x)return 0;\n\tif(c[x])return c[x];\n\tc[x]=999999;\n\tint i,j,k,r1,r2,uu,y;\n\tfor(i=1;i<=15;++i){\n\t\tif((1<<i)&x){\n\t\t\tfor(j=i+1;j<=15;++j){\n\t\t\t\tif((1<<j)&x){\n\t\t\t\t\tfor(k=1;k<=3;++k){\n\t\t\t\t\t\tuu=1;y=x;\n\t\t\t\t\t\tr1=j^k;r2=i^k;\n\t\t\t\t\t\ty-=(1<<j);\n\t\t\t\t\t\ty-=(1<<i);\n\t\t\t\t\t\tif(r1>0){\n\t\t\t\t\t\tif(((1<<r1)&y)){\n\t\t\t\t\t\t\ty-=(1<<r1);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(r2>0){\n\t\t\t\t\t\tif(((1<<r2)&y)){\n\t\t\t\t\t\t\ty-=(1<<r2);\n\t\t\t\t\t\t\t++uu;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse y+=(1<<r2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc[x]=min(c[x],dfs(y)+uu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c[x];\n}\nint i;\nint main(){\n\tcin>>n;\n\tfor(i=1;i<n;++i){\n\t\tcin>>xx>>y>>v;\n\t\ta[xx]^=v;\n\t\ta[y]^=v;\n\t}\n\tfor(i=0;i<n;++i)++cc[a[i]];\n\tfor(i=1;i<=15;++i){\n\t\tans+=cc[i]/2;\n\t\tq+=((cc[i]&1)<<i);\n\t}\n\tcout<<ans+dfs(q);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 5, M = 16, inf = 1e9;\nint a[N], cnt[M], p[M], dp[M], Xor[M];\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v, x; cin >> u >> v >> x;\n        a[u] ^= x, a[v] ^= x;\n    }\n    for (int i = 0; i < n; i++) cnt[a[i]]++;\n    int res = cnt[0], m = 0;\n    for (int i = 1; i < M; i++) {\n        res += cnt[i]>>1;\n        if (cnt[i]&1) p[m++] = i;\n    }\n    fill(dp + 1, dp + M, -inf);\n    for (int mask = 1; mask < (1<<m); mask++) {\n        Xor[mask] = p[__builtin_ctz(mask)] ^ Xor[mask^(mask&(-mask))];\n        for (int sub = mask; sub; sub = (sub - 1)&mask) if (Xor[sub] == 0)\n            dp[mask] = max(dp[mask], dp[mask^sub] + 1);\n    }\n    cout << n - res - dp[(1<<m) - 1] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxl 100010\n#define inf 2000000001\n\nusing namespace std;\n\nint n,ans,res;\nint a[maxl],dp[maxl],cnt[16];\n\ninline void prework()\n{\n\tfor(int i=0;i<n;i++)\n\t\ta[i]=0,cnt[i]=0;\n\tint u,v,val;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&u,&v,&val);\n\t\ta[u]^=val;a[v]^=val;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcnt[a[i]]++;\n\tres=0;ans=0;\n\tfor(int i=1;i<16;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tres^=(1<<i);\n\t}\t\t\n}\n\ninline int dfs(int s)\n{\n    if(s==0)\n        return 0;\n    if(dp[s])\n        return dp[s];\n    dp[s]=inf;\n    for(int i=1;i<16;i++)\n        if(s&(1<<i)){\n            for(int j=1;j<16;j++){\n                if(j!=i&&(s&(1<<j))){\n                    int q=i^j;\n                    if(s&(1<<q))\n                        dp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<q))+2);\n                    else\n                        dp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<q))+1);\n                }\n            }\n\n        }\n    return dp[s];\n}\n\ninline void mainwork()\n{\n\tint x=dfs(res);\n\tans+=x;\n}\n\ninline void print()\n{\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\tprework();\n\t\tmainwork();\n\t\tprint();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst int N = 100050;\n\nint a[N], n, s[17], f[1 << 15], siz[1 << 15];\nint XOR_S[1 << 15], ans, zt, rev[N];\nint main()\n{\n\n\tint i, j, k, h;\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; i ++){\n\t\tscanf(\"%d%d%d\", &j, &k, &h);\n\t\tj ++, k ++, a[j] ^= h, a[k] ^= h;\n\t}\n\tfor(i = 1; i <= n; i ++)\n\t\ts[a[i]] ++;\n\tfor(i = 1; i <= 15; i ++){\n\t\tans += s[i] >> 1, rev[1 << i - 1] = i;\n\t\tzt |= (s[i] & 1) << i - 1;\n\t}\n\tfor(i = 1; i < 1 << 15; i ++){\n\t\tXOR_S[i] = XOR_S[i - (i & -i)] ^ rev[i & -i];\n\t\tsiz[i] = siz[i - (i & -i)] + 1;\n\t}\n\tfor(i = 1; i <= zt; i ++){\n\t\tf[i] = 1000000000;\n\t\tfor(j = i; j; j = (j - 1) & i)\n\t\t\tif(XOR_S[j] == 0)\n\t\t\t\tf[i] = min(f[i], f[i - j] + siz[j] - 1);\n\t}\n\tprintf(\"%d\", f[zt] + ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> deg(n, 0);\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v, a;\n\t\tcin >> u >> v >> a;\n\t\tdeg[u] ^= a;\n\t\tdeg[v] ^= a;\n\t}\n\tint ans = 0;\n\tint mask = 0;\n\tfor(int x : deg){\n\t\tif(x == 0) continue;\n\t\tif((mask >> x) & 1) ans += 1;\n\t\tmask ^= (1 << x);\n\t}\n\tconst int B = 4;\n\tconst int F = 1 << B;\n\tvector<int> dp(1 << F, -1e6);\n\tvector<bool> ok(1 << F, false);\n\tfor(int i = 0; i < (1 << F); i++){\n\t\tint val = 0;\n\t\tfor(int j = 0; j < F; j++){\n\t\t\tif((i >> j) & 1) val ^= j;\n\t\t}\n\t\tif(val == 0) ok[i] = true;\n\t}\n\tdp[0] = 0;\n\tfor(int j = 0; j < (1 << F); j++){\n\t\tint k = j;\n\t\twhile(k > 0){\n\t\t\tif(ok[k]){\n\t\t\t\tdp[j] = max(dp[j], dp[j ^ k] + 1);\n\t\t\t}\n\t\t\tk = (k-1) & j;\n\t\t}\n\t}\n\tcout << (ans + __builtin_popcount(mask) - dp[mask]) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<lint, int> pi;\ntypedef long long lint;\nconst int MAXN = 100005;\n \nint n;\nint cnt[16], arr[MAXN];\nint dp[MAXN];\n \nint bfs(int msk){\n\tfor(int i=1; i<(1<<16); i++){\n\t\tint ans = 0;\n\t\tdp[i] = -1e9;\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif((i >> j) & 1) ans ^= j;\n\t\t}\n\t\tif(ans == 0) dp[i] = 1;\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tdp[i] = min(dp[j] + dp[i^j], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<16; i++) if((msk >> i) & 1) ans++;\n\treturn dp[msk];\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e, x;\n\t\tscanf(\"%d %d %d\",&s,&e,&x);\n\t\tarr[s] ^= x;\n\t\tarr[e] ^= x;\n\t}\n\tfor(int i=0; i<n; i++) cnt[arr[i]]++;// printf(\"%d\\n\", arr[i]);\n\tint msk = 0, ans = 0;\n\tfor(int i=1; i<16; i++){\n\t\tans += cnt[i] / 2;\n\t\tif(cnt[i] & 1) msk |= (1 << i);\n\t}\n\tcout << ans + bfs(msk) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cassert>\n \ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n \nconst int MAXN=1E5+10;\n \nint n,val[MAXN],S;\nint cnt[20],ans,f[1<<16];\nint stk[20],top,bin[20];\n \nint main()\n{\n    scanf(\"%d\",&n);memset(f,0x3f,sizeof f);\n    bin[0]=1;\n    for(int i=1;i<=15;i++) bin[i]=bin[i-1]<<1;\n    for(int i=1,u,v,w;i<n;i++)\n        scanf(\"%d%d%d\",&u,&v,&w),++u,++v,val[u]^=w,val[v]^=w;\n    for(int i=1;i<=n;i++) cnt[val[i]]++;\n    for(int i=1;i<=15;i++) ans+=cnt[i]>>1,S|=(cnt[i]&1)<<i;\n    f[0]=0;\n    for(int l=1;l<=15;l++)\n        for(int s=0;s<(1<<16);s++)\n            if(__builtin_popcount(s)==l&&(s&1)==0)\n                {\n                    top=0;\n                    for(int i=1;i<16;i++) if((s>>i)&1) stk[++top]=i;\n                    for(int i=1;i<=top;i++)\n                        for(int j=i+1;j<=top;j++)\n                            f[s]=min(f[s],f[s^bin[stk[i]]^bin[stk[j]]^bin[stk[i]^stk[j]]]+1+((s>>(stk[i]^stk[j]))&1));\n                }\n    printf(\"%d\\n\",f[S]+ans);\n    #ifdef LOCAL\n        system(\"pause\");\n    #endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#define ed end\n#define bg begin\n#define fr first\n#define sc second\n#define il inline\n#define LL long long\n#define pb push_back\n#define mk make_pair\n#define to(k) E[k].to\n#define val(k) E[k].val\n#define next(k) E[k].next\n#define pint pair<int, int>\n\n#define MAXN 400010\n#define MAXS 400100\n#define Inf 998244353\n\nusing namespace std ;\nstruct Edge{\n\tint to, next, val ;\n}E[MAXN << 1] ; int head[MAXN], cnt, sz[MAXS] ; \nint N, vals[MAXN], dp[MAXN], ctn[MAXN], now_st, ans ; \n\nvoid add(int u, int v, int w){\n\tE[++ cnt].to = v, E[cnt].val = w,\n\tE[cnt].next = head[u], head[u] = cnt ;\n\tE[++ cnt].to = u, E[cnt].val = w,\n\tE[cnt].next = head[v], head[v] = cnt ;\n}\nint do_do(int stt){\n\tif (!stt) return 0 ;\n\tif (dp[stt] != -1) return dp[stt] ;\n\tint ret = Inf ;\n\tfor (int i = 1 ; i <= 15 ; ++ i){\n\t\tif (!(stt >> i & 1)) continue ;\n\t\tfor (int j = 1 ; j <= 15 ; ++ j){\n\t\t\tif (i == j || !(stt >> j & 1)) continue ;\n\t\t\tint now_st = stt ^ (1 << i) ^ (1 << j) ;\n\t\t\tint q = i ^ j ; now_st ^= (1 << q) ; \n\t\t\tif (sz[now_st] < sz[stt]) ret = min(ret, do_do(now_st) + 1 + (~now_st >> (q) & 1)) ; \n\t\t}\n\t}\n\treturn dp[stt] = ret ; \n}\nint main(){\n\tcin >> N ; \n\tint u, v, w, i ; \n\tmemset(dp, -1, sizeof(dp)) ;\n\tfor (i = 1 ; i < N ; ++ i) \n\t\tscanf(\"%d%d%d\", &u, &v, &w), \n\t\tadd(u + 1, v + 1, w), vals[u + 1] ^= w, vals[v + 1] ^= w ;  \n\tfor (i = 1 ; i <= N ; ++ i) if (vals[i]) ctn[vals[i]] ++ ; \n\tfor (i = 0 ; i <= 15 ; ++ i) ans += ctn[i] / 2, now_st |= (ctn[i] & 1) << i ;\n\tfor (i = 1 ; i < MAXS ; ++ i) sz[i] = sz[i - (i & -i)] + 1 ; \n\tans += do_do(now_st) ; cout << ans << endl ; return 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define Min(a,b) a=min(a,b);\n#define ret return puts(\"-1\"),0;\n#define N 500055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,num[17],cnt[70005],f[70005],x,y,v,a[N],b[N],ans;\nvector<int> vec[20];\nvoid dp(int S){\n    F(i,0,num[16]) cnt[i]=cnt[i>>1]+(i&1),vec[cnt[i]].push_back(i),f[i]=inf;\n    f[S]=0;\n    D(i,16,1)\n        for (int j=0;j<vec[i].size();j++){\n            int s=vec[i][j];\n            if (f[s]==inf) continue;\n            F(x,0,15)\n                F(y,0,15){\n                    if (!(s&num[x])||!(s&num[y])||x==y) continue;\n                    Min(f[s^num[x]^num[x^y]^num[y]],f[s]+1+((s&num[x^y])>0));\n                }\n        }\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1){\n\t\tx=read();y=read();v=read();\n\t\ta[x]^=v;a[y]^=v;\n\t}\n\tF(i,0,n-1) b[a[i]]++;\n\tF(i,1,15) ans+=b[i]/2;\n\tnum[0]=1;F(i,1,16) num[i]=num[i-1]*2;\n\tint sum=0;F(i,1,15) sum+=num[i]*(b[i]&1);\n\tdp(sum);\n\twrn(f[0]+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\nint cnt, maxmn;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nbool b[N];\nint dp[N][A + 5];\nvector < pair <int, pair <int, int> > > chs;\nvoid bt(int maxp = 0) {\n//\tcout << maxp << endl;\n\tmaxmn = max(maxmn, cnt);\n\tfor (int i = maxp; i < chs.size(); i++) {\n\t\tint x = chs[i].first, y = chs[i].second.first, z = chs[i].second.second;\n\t\tif (b[x] || b[y] || b[z]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dp[1][x] && dp[1][y] && dp[1][z]) {\n\t\t\tcnt++;\n\t\t}\n\t\tb[x] = true;\n\t\tb[y] = true;\n\t\tb[z] = true;\n\t\tbt(i + 1);\n\t\tif (dp[1][x] && dp[1][y] && dp[1][z]) {\n\t\t\tcnt--;\n\t\t}\n\t\tb[x] = false;\n\t\tb[y] = false;\n\t\tb[z] = false;\n\t}\n}\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tfor (int k = 1; k < j; k++) {\n\t\t\t\tchs.push_back({i, {j, k}});\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tbt();\n\tcout << ans - maxmn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename t>inline t min_(t a,t b){return a<=b?a:b;}\ntemplate<typename t>inline t max_(t a,t b){return a>=b?a:b;}\ntemplate<typename t>inline void chkmin(t&a,t b){if(a>b)a=b;}\ntemplate<typename t>inline void chkmax(t&a,t b){if(a<b)a=b;}\n\ntypedef long long ll;\nconst int maxn=1e5+10,maxa=16;\nint n,a[maxn],cnt[maxa],ans;\nint tot,x[maxa],dp[1<<maxa];\nbool vis[1<<maxa];\n\nint main(){\n\tcin>>n;\n\tfor(int i=1,u,v,x;i<n;++i){\n\t\tcin>>u>>v>>x;\n\t\ta[u]^=x;a[v]^=x;\n\t}\n\tfor(int i=0;i<n;++i)\n\t\t++cnt[a[i]];\n\tfor(int i=1;i<maxa;++i)\n\t\tans+=cnt[i]/2,cnt[i]-=cnt[i]/2*2;\n\tfor(int i=1;i<maxa;++i)\n\t\tif(cnt[i])\n\t\t\tx[tot++]=i;\n\tfor(int i=0;i<(1<<tot);++i){\n\t\tint xxx=0;\n\t\tfor(int j=0;j<tot;++j)\n\t\t\tif(i>>j&1)\n\t\t\t\txxx^=x[j];\n\t\tif(xxx==0)\n\t\t\tvis[i]=true;\n\t}\n\tmemset(dp,100,sizeof(dp));\n\tdp[0]=0;\n\tfor(int i=0;i<(1<<tot);++i)\n\t\tfor(int j=(i+1)|i;j<(1<<tot);j=(j+1)|i)\n\t\t\tif(vis[i^j])\n\t\t\t\tchkmin(dp[j],dp[i]+__builtin_popcount(i^j)-1);\n\tprintf(\"%d\\n\",ans+dp[(1<<tot)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=1e5+5;\nint n,a[N],vis[16],dp[1<<15],sum[1<<15];\nvector<int>v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n        a[u]^=w;a[v]^=w;\n    }\n    for(int i=1;i<=n;i++)\n        vis[a[i]]++;\n    int ans=0;\n    for(int i=1;i<=15;i++)\n    {\n        ans+=vis[i]/2;\n        if(vis[i]&1)\n            v.push_back(i);\n    }\n    memset(dp,inf,sizeof(dp));\n    dp[0]=0;\n    int m=v.size();\n    int up=1<<m;\n    for(int i=0;i<up;i++)\n    {\n        for(int j=0;j<m;j++)\n            if(!(i>>j&1))\n        {\n            int st=i^(1<<j);\n            sum[st]=sum[i]^v[j];\n            if(sum[st]==0) dp[st]=min(dp[st],dp[i]);\n            else dp[st]=min(dp[st],dp[i]+1);\n        }\n    }\n    printf(\"%d\\n\",ans+dp[up-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\n\nint N;\nvector<pii> gg[MN], g[MN];\nint ret;\n\nvoid pre(int v, int p)\n{\n\tfor (pii e : gg[v]) if (e.fi != p) {\n\t\tg[v].eb(e);\n\t\tpre(e.fi, v);\n\t}\t\n}\n\nint dfs(int v)\n{\n\tvi cnt(16);\n\n\tfor (pii e : g[v]) {\n\t\tint res = dfs(e.fi);\n\t\t++cnt[res ^ e.se];\n\t}\n\n\tint xo = 0;\n\n\trep(i, 16) {\n\t\tret += cnt[i] / 2;\n\t\tif (cnt[i] & 1) {\n\t\t\txo ^= i;\n\t\t}\n\t}\n\n\tbool f = 0;\n\tfor (int i = 1; i < 16; ++i) {\n\t\tif (cnt[i] & 1) {\n\t\t\t++ret;\n\t\t\tf = 1;\n\t\t}\n\t}\n\n\tif (f && xo == 0) {\n\t\t--ret;\n\t}\n\n\treturn xo;\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tgg[x].eb(y, a);\n\t\tgg[y].eb(x, a);\n\t}\n\n\tpre(0, -1);\n\tdfs(0);\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint n;\nint tot=0,num[N],cnt[32],p[20],f[(1<<16)+7],ans;\ninline bool pd(int x,int w){\n\treturn (x&w)==w;\n}/*\nbool dfs(int x,int fa,int w){\n\tint res=0;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tint y=ver[i];\n\t\tif(y==fa) continue;\n\t\tif(!pd(edge[i],w))ans[w]+=dfs(y,x,w);\n\t\telse dfs(y,x,w),res+=1;\n\t}\n\tans[w]+=res/2;\n\tif(x==1) ans[w]+=res&1;\n\treturn res&1;\n}*/\ninline bool ch(int x,int y){\n\tint res=x+y;\n\tif((res^y)==x) return 0;\n\treturn 1;\n}\nint g(int x){\n\tint now=0,res=0,sz=0;\n\twhile(x){\n\t\tif(x&1) res^=p[now],sz++;\n\t\tx>>=1;\n\t\tnow++;\n\t}\n\treturn res?sz:sz-1;\n}\nint main(){\n\t//freopen(\"xor.in\",\"r\",stdin);\n\t//freopen(\"xor.out\",\"w\",stdout);\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tread(x),read(y),read(z);\n\t\tnum[x]^=z,num[y]^=z;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[num[i]]++;\n\tfor(int i=1;i<=31;i++){\n\t\tans+=cnt[i]/2;\n\t\tif(cnt[i]&1)\n\t\t\tp[tot++]=i;\n\t}\n\tfor(int i=1;i<1<<16;i++){\n\t\tf[i]=g(i);\n\t\tfor(int j=i;j;j=(j-1)&i){\n\t\t\tf[i]=min(f[i],f[j]+f[i^j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+f[(1<<(tot-1))-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\nconst int N=5e5+100;\nll val[N];\nll t[20];\nll dp[(1<<16)];\nvector <int> f(ll x){\n    vector <int> bit;\n    while(x){\n        bit.pb(x%2);\n        x/=2;\n    }\n    while(bit.size()<16){\n        bit.pb(0);\n    }\n    return bit;\n}\nint32_t main(){\n    ll n;\n    cin >> n;\n    for (int i=0;i<n-1;i++){\n        ll u,v,w;\n        cin >> u >> v >> w;\n        u++;\n        v++;\n        val[u] ^= w;\n        val[v] ^= w;\n    }\n    ll ans=0;\n    for (int i=1;i<=n;i++){\n        t[val[i]]++;\n     ///   cout << i << \" \" << val[i] << endl;\n        if (t[val[i]]==2 && val[i]!=0) ans++;\n        t[val[i]]%=2;\n    }\n    t[0]=0;\n    memset(dp,69,sizeof dp);\n    ll cnt1=0;\n    for (int i=0;i<=15;i++){\n        cnt1+=(t[i] << i);\n     //   cout << t[i] << endl;\n    }\n    dp[0]=0;\n    vector <pii> a;\n    for (int i=0;i<(1<<16);i++){\n        vector <int> bit=f(i);\n       ll cnt=0;\n        if (bit[0]) continue;\n        for (int j=0;j<16;j++){\n            cnt+=bit[j];\n        }\n        a.pb({cnt,i});\n    }\n  //  cout << cnt1 << endl;\n    sort(a.begin(),a.end());\n    for (int i=0;i<a.size();i++){\n        ll x=a[i].S;\n        vector <int> bit=f(x);\n        for (int j=0;j<16;j++){\n            if (bit[j]) dp[x]=min(dp[x],dp[(x^(1<<j))]+1);\n            for (int k=j+1;k<16;k++){\n                if (!bit[j] || !bit[k]) continue;\n                if (bit[(j^k)]) dp[x]=min(dp[x],2+dp[(x^((1<<j) + (1<<k) + (1<<(j^k))))]);\n                else dp[x]=min(dp[x],1+dp[(x^((1<<j) + (1<<k) + (1<<(j^k))))]);\n               // if (x==14){\n                 //   cout << dp[x] << \" \" << j << \" \" << k << \" \" << (j^k) << \" \" << 1+dp[(x^((1<<j) + (1<<k) + (1<<(j^k))))] << endl;\n                //}\n            }\n        }\n\n    }\n    cout << dp[cnt1]+ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n \n#pragma comment(linker, \"/STACK:336777216\")  \n \nusing namespace std;\n\nconst int MAXN = 200000 + 10;\n\nint N;\nint To[MAXN], Wt[MAXN], Next[MAXN], Node[MAXN], nE;\nint iw[MAXN], rem[MAXN];\nint Cnt[MAXN][16];\n\nvoid InsertEdge(int a, int b, int c)\n{\n\tTo[nE] = b;\n\tWt[nE] = c;\n\tNext[nE] = Node[a];\n\tNode[a] = nE ++;\n}\n\nvoid DFS(int i, int Par)\n{\n\tfor (int e = Node[i]; e != -1; e = Next[e])\n\t{\n\t\tint j = To[e];\n\t\tif (j == Par) continue;\n\t\tiw[j] = iw[i] ^ Wt[e];\n\t\tDFS(j, i);\n\t}\n\n\trem[i] = iw[i];\n\tfor (int e = Node[i]; e != -1; e = Next[e])\n\t{\n\t\tint j = To[e];\n\t\tif (j == Par) continue;\n\t\tfor (int msk = 0; msk < 16; msk ++)\n\t\t{\n\t\t\tCnt[i][msk] += Cnt[j][msk];\n\t\t\tif (Cnt[j][msk] % 2 == 1)\n\t\t\t\trem[i] ^= msk;\n\t\t}\n\t}\n\tCnt[i][rem[i]] ++;\n}\n\nint Step[1 << 16], Q[1 << 16];\n\nvoid Work()\n{\n\tscanf(\"%d\", &N);\n\tmemset(Node, -1, sizeof(Node));\n\tnE = 0;\n\tfor (int i = 1; i < N; i ++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tInsertEdge(a, b, c);\n\t\tInsertEdge(b, a, c);\n\t}\n\tDFS(0, -1);\n\t\n\tCnt[0][0] = 0;\n\tint m = 0;\n\tfor (int msk = 0; msk < 16; msk ++)\n\t\tif (Cnt[0][msk] % 2 == 1)\n\t\t\tm |= (1 << msk);\n\n\tmemset(Step, -1, sizeof(Step));\n\tStep[m] = 0;\n\tint Tail = 0;\n\tQ[Tail ++] = m;\n\tfor (int h = 0; h < Tail; h ++)\n\t{\n\t\tint msk = Q[h];\n\t\tfor (int i = 1; i < 16; i ++)\n\t\t\tif (msk & (1 << i))\n\t\t\t{\n\t\t\t\tint nmsk = msk ^ (1 << i);\n\t\t\t\tif (Step[nmsk] == -1)\n\t\t\t\t{\n\t\t\t\t\tStep[nmsk] = Step[msk] + 1;\n\t\t\t\t\tQ[Tail ++] = nmsk;\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int i = 1; i < 16; i ++)\n\t\t\tfor (int j = i + 1; j < 16; j ++)\n\t\t\t\tif ((msk & (1 << i)) && (msk & (1 << j)))\n\t\t\t\t{\n\t\t\t\t\tint nmsk = msk ^ (1 << i) ^ (1 << j) ^ (1 << (i ^ j));\n\t\t\t\t\tif (msk & (1 << (i ^ j)))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Step[nmsk] == -1 || Step[nmsk] > Step[msk] + 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStep[nmsk] = Step[msk] + 2;\n\t\t\t\t\t\t\tQ[Tail ++] = nmsk;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Step[nmsk] == -1 || Step[nmsk] > Step[msk] + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStep[nmsk] = Step[msk] + 1;\n\t\t\t\t\t\t\tQ[Tail ++] = nmsk;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\tint Ans = 0;\n\tfor (int msk = 1; msk < 16; msk ++)\n\t\tAns += Cnt[0][msk] / 2;\n\tAns += Step[0];\n\tprintf(\"%d\\n\", Ans);\n}\n\nint main()\n{\n\tWork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdint>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nqueue<int> Q;\nvector<int> a[200001];\nvector<int> b[200001];\nint sum[100001],deg[100001];\nint fax[100001];\nint fa[100001];\nbool v[100001];\nint ans;\ninline void dfs1(int d)\n{\n\tv[d]=true;\n\tint i;\n\tfor(i=0;i<a[d].size();i++)\n\t{\n\t\tint t=a[d][i];\n\t\tif(!v[t])\n\t\t{\n\t\t\tfa[t]=d;\n\t\t\tfax[t]=b[d][i];\n\t\t\tdfs1(t);\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s,t,x;\n\tint i;\n\tfor(i=1;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&s,&t,&x);\n\t\ts++;\n\t\tt++;\n\t\ta[s].push_back(t);\n\t\ta[t].push_back(s);\n\t\tb[t].push_back(x);\n\t\tb[s].push_back(x);\n\t}\n\tdfs1(1);\n\tfor(i=1;i<=n;i++)\n\t\tdeg[fa[i]]++;\n\tfor(i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint d=Q.front();\n\t\tQ.pop();\n\t\tdeg[fa[d]]--;\n\t\tif(fa[d]!=0&&deg[fa[d]]==0)\n\t\t\tQ.push(fa[d]);\n\t\tsum[fax[d]]++;\n\t\tfax[fa[d]]^=fax[d];\n\t\tfax[d]=0;\n\t}\n\tfor(i=1;i<=15;i++)\n\t\tans+=(sum[i]+1)/2;\n        ans--;\n        ans=max(ans,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nvector < pii > g[N];\nint ans = 0;\nint dfs(int node,int prev)\n{\n    int cnt = 0;\n    for (auto it : g[node])\n        if (it.fi != prev)\n        {\n            int v = dfs(it.fi,node);\n            int xr = it.se;\n            for (int k = 0;k < 16;++k)\n                if ((v >> k) & 1)\n                {\n                    if ((cnt >> k) & 1)\n                        ++ans;\n                    cnt ^= 1 << k;\n                    xr ^= k;\n                }\n            if (xr)\n            {\n                if ((cnt >> xr) & 1)\n                    ++ans;\n                cnt ^= 1 << xr;\n            }\n        }\n    for (int i = 1;i < 16;++i)\n        if ((cnt >> i) & 1)\n            for (int j = 1;j < 16;++j)\n                if ((cnt >> j) & 1)\n                    if ((cnt >> (i ^ j)) & 1)\n                    {\n                        ans += 2;\n                        cnt ^= 1 << i;\n                        cnt ^= 1 << j;\n                        cnt ^= 1 << (i ^ j);\n                    }\n    if (cnt & 1)\n        cnt ^= 1;\n    return cnt;\n}\nint main(void)\n{\n    int n;\n    cin>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b,c;\n        cin>>a>>b>>c;\n        ++a;++b;\n        g[a].pb(mp(b,c));\n        g[b].pb(mp(a,c));\n    }\n    ans += __builtin_popcount(dfs(1,0));\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nconst int N=100010;\n\nvpii e[N];\nbool v[N];\nint s,a[N],d[1<<16],q[1<<16],b[16];\n\nvoid dfs(int k,int x)\n{\n\tv[k]=1;int t=x;a[k]=0;\n\tfor (vpii::iterator p=e[k].begin();p!=e[k].end();p++)\n\t\tif (!v[p->x])\n\t\t{\n\t\t\tdfs(p->x,p->y);t^=p->y;a[k]^=a[p->x];\n\t\t}\n\tif (t) {s++;a[k]^=(1<<(t-1));}\n}\n\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\te[x].pb(mp(y,z));e[y].pb(mp(x,z));\n\t}\n\tv[0]=1;s=0;a[0]=0;\n\tfor (vpii::iterator p=e[0].begin();p!=e[0].end();p++)\n\t{\n\t\tdfs(p->x,p->y);a[0]^=a[p->x];\n\t}\n\tint f=1,r=1;q[1]=a[0];\n\tfor (int i=0;i<(1<<15);i++) d[i]=16;d[a[0]]=0;\n\twhile (f<=r)\n\t{\n\t\tint x=q[f++],p=0;\n\t\tfor (int i=0;i<15;i++) if (x&(1<<i)) b[p++]=i;\n\t\tfor (int i=0;i<p;i++)\n\t\t{\n\t\t\tfor (int j=i+1;j<p;j++)\n\t\t\t\tif (d[x^(1<<b[i])^(1<<b[j])^(1<<((b[i]+1)^(b[j]+1)-1))]==16)\n\t\t\t\t{\n\t\t\t\t\tq[++r]=x^(1<<b[i])^(1<<b[j])^(1<<((b[i]+1)^(b[j]+1)-1));d[q[r]]=d[x]+1;\n\t\t\t\t}\n\t\t\tif (d[x^(1<<b[i])]==16)\n\t\t\t{\n\t\t\t\tq[++r]=x^(1<<b[i]);d[q[r]]=d[x]+1;\n\t\t\t}\n\t\t}\n\t}\n\tint t=0;\n\tfor (int i=0;i<15;i++) if (a[0]&(1<<i)) t++;\n\tprintf(\"%d\\n\",(s-t)/2+d[0]+(t-d[0])/2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=100005;\nint val[maxn*20],hd[maxn],n,m;\nint to[maxn*20],ne[maxn*20],num,S;\nint XS[maxn],now,ci[20],d[maxn],C[233];\ninline void add(int x,int y,int z){ to[++num]=y,ne[num]=hd[x],hd[x]=num,val[num]=z;}\n\ninline void build(){\n\tfor(int i=1;i<ci[15];i++)\n\t    for(int j=1;j<=15;j++) if(ci[j-1]&i){\n\t    \tnow=i^ci[j-1],add(now,i,1);\n\t    \tfor(int k=1;k<=15;k++) if(ci[k-1]&now) add(now^ci[k-1]^ci[(j^k)-1],i,1+((now&ci[(j^k)-1])?1:0));\n\t\t}\n}\n\ninline void spfa(){\n\tqueue<int> q; bool v[maxn];\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(v,0,sizeof(v));\n\td[0]=0,q.push(0),v[0]=1;\n\t\n\tint x;\n\twhile(!q.empty()){\n\t\tx=q.front(),q.pop();\n\t\tfor(int i=hd[x];i;i=ne[i]) if(d[x]+val[i]<d[to[i]]){\n\t\t\td[to[i]]=d[x]+val[i];\n\t\t\tif(!v[to[i]]) v[to[i]]=1,q.push(to[i]);\n\t\t}\n\t\tv[x]=0;\n\t}\n}\n\ninline void init(){\n\tci[0]=1;\n\tfor(int i=1;i<=15;i++) ci[i]=ci[i-1]<<1;\n\t\n\tbuild();\n\tspfa();\n}\n\ninline void solve(){\n\tint uu,vv,ww,ans=1<<30;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d%d\",&uu,&vv,&ww);\n\t\tuu++,vv++,XS[uu]^=ww,XS[vv]^=ww;\n\t}\n\t\n\tfor(int i=1;i<=n;i++) C[XS[i]]++;\n\tfor(int i=1;i<=n;i++){\n\t\tC[XS[i]]--;\n\t\t\n\t\tS=0,now=0;\n\t\tfor(int j=1;j<=15;j++){\n\t\t\tnow+=C[j]>>1;\n\t\t\tS|=(C[j]&1)*ci[j-1];\n\t\t}\n\t\tnow+=d[S];\n\t\tans=min(ans,now);\n\t\t\n\t\tC[XS[i]]++;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cassert>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n\nconst int MAXN=1E5+10;\n\nint n,val[MAXN],S;\nint cnt[20],ans,f[1<<16];\nint stk[20],top,bin[20];\n\nint main()\n{\n    scanf(\"%d\",&n);memset(f,0x3f,sizeof f);\n    bin[0]=1;\n    for(int i=1;i<=15;i++) bin[i]=bin[i-1]<<1;\n    for(int i=1,u,v,w;i<n;i++)\n        scanf(\"%d%d%d\",&u,&v,&w),++u,++v,val[u]^=w,val[v]^=w;\n    for(int i=1;i<=n;i++) cnt[val[i]]++;\n    for(int i=1;i<=15;i++) ans+=cnt[i]>>1,S|=(cnt[i]&1)<<i;\n    f[0]=0;\n    for(int s=0;s<(1<<16);s++)\n    {\n        top=0;\n        for(int i=1;i<16;i++) if((s>>i)&1) stk[++top]=i;\n        for(int i=1;i<=top;i++)\n            for(int j=i+1;j<=top;j++)\n                f[s]=min(f[s],f[s^bin[stk[i]]^bin[stk[j]]^bin[stk[i]^stk[j]]]+1+((s>>(i^j))&1));\n    }\n    printf(\"%d\\n\",f[S]+ans);\n    #ifdef LOCAL\n        system(\"pause\");\n    #endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nint z[MC];\nint c[MC];\nint dp[1<<16];\nint dp2[1<<16];\n/*\nint solve(int s){\n\tif(~dp[s]) return dp[s];\n\tdp[s] = 123456789;\n\trepp(i,2,16) if(s&(1<<i)){\n\t\trepp(j,1,i) if(s&(1<<j)){\n\t\t\trepp(k,1,16){\n\t\t\t\tint w = 1;\n\t\t\t\tif(s&(1<<(i^k))) ++w;\n\t\t\t\tif(s&(1<<(j^k))) ++w;\n\t\t\t\tint t = s ^ (1<<i) ^ (1<<j) ^ (1<<(i^k)) ^ (1<<(j^k));\n\t\t\t\tif(s>t) dp[s] = min(dp[s],solve(t)+w);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s];\n}*/\n\nint main(){\n\tcin >> N;\n\trepp(i,1,N){\n\t\tint x,y,a;\n\t\tcin >> x >> y >> a;\n\t\tz[x] ^= a;\n\t\tz[y] ^= a;\n\t}\n\trepp(i,0,N) ++c[z[i]];\n\tint ans = 0;\n\tint s = 0;\n\trepp(i,1,16){\n\t\tans += c[i]/2;\n\t\tif(c[i]%2==1) s |= (1<<i);\n\t}\n\tfill(dp,dp+(1<<16),-1);\n\tdp[0] = dp[1] = 0;\n\tfill(dp2,dp2+(1<<16),-1);\n\tdp2[0] = dp2[1] = 0;\n\trepp(i,2,1<<16){\n\t\tif(i&1) continue;\n\t\tint p = 0 , q = 0;\n\t\trepp(k,1,16) if(i&(1<<k)){\n\t\t\t++p;\n\t\t\tq ^= k;\n\t\t}\n\t\tif(q) continue;\n\t\tdp2[i] = p-1;\n\t\tfor(int j = (i-1)&i ; j > 0 ; j = (j-1)&i){\n\t\t\tif(~dp2[j]) dp2[i] = min(dp2[i] , dp2[j] + dp2[i^j]);\n\t\t}\n\t\t//if(solve(i) != dp2[i]) cout << i << ' ' << dp[i] << ' ' << dp2[i] << endl;\n\t}\n\tcout << ans + dp2[s] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst int INF = 0x2fffffff;\n\nstruct Edge {\n  int to;\n  int v;\n};\n\nint N;\nvector<Edge> es[114514];\nvector<Edge> des[114514];\nint cnt[16];\nint dp[1 << 16];\n\nvoid Dfs(int v, int p, int av) {\n  int tot = 0;\n  for (auto &e : es[v]) {\n    int u = e.to;\n    if (u == p) continue;\n    Dfs(u, v, e.v);\n    tot ^= e.v;\n  }\n  if (av != -1) cnt[av^tot]++;\n}\n\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int u, v, a;\n    scanf(\"%d%d%d\", &u, &v, &a);\n    es[u].eb(Edge{v, a});\n    es[v].eb(Edge{u, a});\n  }\n\n  Dfs(0, 0, -1);\n\n  priority_queue<pii, vector<pii>, greater<pii>> que;\n  int lim = 1 << 15;\n  rep(st, lim) {\n    dp[st] = __builtin_popcount(st);\n    que.push(pii(dp[st], st));\n\n    rep(i, 15) {\n      if (!(st >> i & 1)) continue;\n      rep(j, 15) {\n        if (i == j) continue;\n        int k = ((i+1)^(j+1)) - 1;\n        assert(k >= 0);\n\n        int ext = 0;\n        if (st >> j & 1) ext++;\n        if (st >> k & 1) ext++;\n        int nst = st;\n        nst ^= 1 << i;\n        nst ^= 1 << j;\n        nst ^= 1 << k;\n        des[nst].eb(Edge{st, ext});\n      }\n    }\n  }\n\n  while (!que.empty()) {\n    auto &p = que.top(); que.pop();\n    int cost = p.first;\n    int v = p.second;\n    if (dp[v] < cost) continue;\n\n    for (auto &e : des[v]) {\n      int u = e.to;\n      int l = e.v;\n      if (dp[u] > cost + l) {\n        dp[u] = cost + l;\n        que.push(pii(dp[u], u));\n      }\n    }\n  }\n\n  int ans = 0;\n  int st = 0;\n  reps(i, 1, 16) {\n    ans += cnt[i]/2;\n    st += (cnt[i]%2) << (i-1);\n  }\n  //printf(\"dp[%d]: %d\\n\", st, dp[st]);\n  printf(\"%d\\n\", ans + dp[st]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint const N = 1234567;\nint const INF = 1 << 30;\n \nint deg[N];\nint was[42];\n\nint dp[1 << 16];\n \nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v, u, w;\n\t\tcin >> v >> u >> w;\n\t\tdeg[v] ^= w;\n\t\tdeg[u] ^= w;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (deg[i] == 0) continue;\n\t\tif (was[deg[i]]) {\n\t\t\t++ans;\n\t\t\twas[deg[i]] = false;\n\t\t} else {\n\t\t\twas[deg[i]] = true;\n\t\t}\n\t}\n\tint mask = 0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (was[i]) mask |= 1 << i;\n\t}\n\tfor (int i = 0; i < 1 << 16; i++) dp[i] = INF;\n\tdp[mask] = 0;\n\tfor (int i = mask; i >= 1; i--) {\n\t\tif (dp[i] == INF) continue;\n\t\tif ((i & (i - 1)) == 0) continue;\n\t\tfor (int j = 1; j < 16; j++) {\n\t\t\tif (((i >> j) & 1) == 0) continue;\n\t\t\tfor (int k = j + 1; k < 16; k++) {\n\t\t\t\tif (((i >> k) & 1) == 0) continue;\n\t\t\t\tif ((j & k) == 0) continue;\n\t\t\t\t// cerr << i << ' ' << j << ' ' << k << endl;\n\t\t\t\tint got = j & k;\n\t\t\t\tint nj = j ^ got;\n\t\t\t\tint nk = k ^ got;\n\t\t\t\tint nmask = i ^ (1 << j) ^ (1 << k);\n\t\t\t\tint cost = 1;\n\t\t\t\tif (nj > 0) {\n\t\t\t\t\tif (((nmask >> nj) & 1) == 1) {\n\t\t\t\t\t\tcost++;\n\t\t\t\t\t}\n\t\t\t\t\tnmask ^= 1 << nj;\n\t\t\t\t}\n\t\t\t\tif (nk > 0) {\n\t\t\t\t\tif (((nmask >> nk) & 1) == 1) {\n\t\t\t\t\t\tcost++;\n\t\t\t\t\t}\n\t\t\t\t\tnmask ^= 1 << nk;\n\t\t\t\t}\n\t\t\t\t// cout << \"nmask = \" << nmask << endl;\n\t\t\t\tdp[nmask] = std::min(dp[nmask], dp[i] + cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0] + ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri rd<int>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; --i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++i)\nconst int maxN = 1e5 + 7;\nconst int maxS = (1 << 15) + 3;\n\ntemplate<class T> T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return f ? x : -x;\n}\n\nint n, m;\nint a[maxN];\nbool ok[maxS];\nint f[maxS];\n\nint main() {\n\n\tm = n = ri();\n\tFor (i, 1, n) {\n\t\tint x = ri() + 1, y = ri() + 1, d = ri();\n\t\ta[x] ^= d;\n\t\ta[y] ^= d;\n\t}\n\n\tsort(a+1, a+n+1, greater<int>());\n\tint res = 0, mask = 0;\n\tfor (; n > 0 && a[n] == 0; --n) ++res;\n\twhile (n > 0) {\n\t\tfor (; n >= 2 && a[n] == a[n-1]; n -= 2) ++res;\n\t\tif (n >= 1) mask |= 1 << (a[n--] - 1);\n\t}\n\n\tfor (int s = mask; s; (--s) &= mask) {\n\t\tint tp = 0;\n\t\trep (i, 1, 15) if (s >> (i-1) & 1) tp ^= i;\n\t\tok[s] = tp == 0;\n\t}\n\tok[0] = true;\n\trep (s, 1, mask) if ((mask & s) == s && ok[s]){\n\t\tfor (int t = s; t; (--t) &= s) if (ok[t] && ok[s^t]) {\n\t\t\tf[s] = max(f[s], f[s ^ t] + 1);\n\t\t}\n\t}\n\tres += f[mask];\n\tprintf(\"%d\\n\", m - res);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n \ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n \ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n \ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n \n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n \nconst int MAX = 100010;\nint n;\nint x[MAX];\nint il[16];\nint dp[1 << 17];\nint xx[1 << 17];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  R(i,n-1){\n    int a,b,c;\n    cin >> a >> b >> c;\n    x[a]^=c;\n    x[b]^=c;\n  }\n  R(i,n){\n    il[x[i]]++;\n  }\n  vector<int> pom;\n  int res = 0;\n  R(i,16)if(i){\n    if(il[i]&1){\n      pom.PB(i);\n    }\n    res += il[i]/2;\n  }\n  R(i,1<<SZ(pom)){\n    R(j,SZ(pom))if((i >> j)&1){\n      xx[i] ^= pom[j];\n    }\n  }\n  R(i,1<<SZ(pom)){\n    debug(xx[i],i);\n    if(xx[i] == 0){\n      dp[i] = 1;\n      for(int j = (i - 1) & i; j ; j = (j -1)&i){\n        if(xx[j] == 0){\n          maxi(dp[i], dp[j] + 1);\n        }\n      }\n    }\n  }\n  debug(SZ(pom),res,dp[(1 << SZ(pom))-1]);\n  cout << res + max(0ll, SZ(pom) - dp[(1 << SZ(pom))-1]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define F first\n#define S second\n#define FOR(i,a,b) for (int i = (a); i <= (b); ++i)\n#define NFOR(i,a,b) for(int i = (a); i >= (b); --i)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\ntypedef long long ll; typedef pair <int, int> ii; typedef vector <int> vi; const int inf = 1e9 + 7;\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cout << str << \" : \" << t << endl;}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cout << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cout << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cout << \", \"; cout << *i;} cout << \"]\";cout<<endl;}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint n; cin >> n;\n\tvector<vector<ii>> g(n);\n\tvi d(n);\n\tFOR (i, 0, n - 2) {\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tg[x].emplace_back(y, z);\n\t\tg[y].emplace_back(x, z);\n\t\td[x] ^= z;\n\t\td[y] ^= z;\n\t}\n\tvi f(16);\n\tFOR (i, 0, n - 1) f[d[i]]++;\n\tint ans = 0;\n\tvi yo;\n\tFOR (i, 1, 15) {\n\t\tans += f[i] / 2;\n\t\tif (f[i] & 1) {\n\t\t\tyo.push_back(i);\n\t\t}\n\t}\n\tint no = sz(yo);\n\n\tvector<vector<int>> dp(no + 1, vector<int>(1 << 16));\n\n\tNFOR (i, no - 1, 0) {\n\t\tint x = yo[i];\n\t\tFOR (j, 0, (1 << 16) - 1) {\n\t\t\tdp[i][j] = !!(j & (1 << x)) + dp[i + 1][j ^ (1 << x)];\n\t\t\tdp[i][j] = max(dp[i][j], dp[i+1][j]);\n\t\t\tFOR (k, 1, 15) if (x != k and (j & (1 << k))) {\n\t\t\t\tint y = x ^ k;\n\t\t\t\tint nj = j ^ (1 << k);\n\t\t\t\tdp[i][j] = max(dp[i][j], !!(nj & (1 << y)) + dp[i + 1][nj ^ (1 << y)]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << no - dp[0][0] + ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\n#define fillZero(a) memset((a), 0,  sizeof(a))\n#define fillINF(a) memset((a), 0x3f, sizeof(a)) // 3f3f3f3f = 1,061,109,567 < 2^30\n#define all(a) (a).begin(), (a).end()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n\nclass Edge {\npublic:\n\tvirtual int from() const = 0;\n\tvirtual int to() const = 0;\n\tvirtual Edge* reversedEdge() = 0;\n};\n\ntypedef int EdgeWeight;\nclass SimpleEdge : public Edge {\n\tint from_, to_;\n\tEdgeWeight weight_;\npublic:\n\tSimpleEdge(int from,int to,EdgeWeight weight_) : from_(from), to_(to), weight_(weight_) {}\n\tstatic SimpleEdge* createFromInput(){\n\t\tint a,b,w;\n\t\tcin >> a >> b >> w;\n\t\treturn new SimpleEdge(a,b,w);\n\t}\n\tint to() const { return to_; }\n\tint from() const { return from_; } \n\tint weight() const { return weight_; }\n\tSimpleEdge* reversedEdge(){\n\t\treturn new SimpleEdge(to_, from_, weight_);\n\t}\n};\n\nclass Graph {\npublic:\n\tvirtual vector<Edge*> *connectedEdges(int v) = 0;\n\tvirtual void addEdge(Edge *edge) = 0;\n};\n\nclass UndirectedGraph : public Graph {\nprivate:\n\tvector<Edge*> edges;\n\tvector< vector<Edge*> > graph;\npublic:\n\tUndirectedGraph(int n){\n\t\tgraph.resize(n);\n\t}\n\t\n\tsize_t size(){\n\t\treturn graph.size();\n\t}\n\n\tvoid addEdge(Edge *edge){\n\t\tedges.push_back(edge);\n\t\tassert(edge->from() < size());\n\t\tassert(edge->to() < size());\n\n\t\tgraph[edge->from()].push_back(edge);\n\t\tgraph[edge->to()].push_back(edge->reversedEdge());\n\t}\n\tvector<Edge*> *connectedEdges(int v){\n\t\treturn &graph[v];\n\t}\n\tvector<Edge*> *allEdges(){\n\t\treturn &edges;\n\t}\n};\n\n\nconst int N_MAX = 100010;\nbool canMakeZero(int bit){\n\tint tst = 0;\n\trep(i,16) if( bit >> i & 1 ) tst ^= i;\n\treturn tst == 0;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tUndirectedGraph g(n);\n\tfor(int i = 0 ; i < n - 1 ; i++){\n\t\tg.addEdge(SimpleEdge::createFromInput());\n\t}\n\t\n\tint vXors[N_MAX] = {};\n\tfor( auto e : *g.allEdges() ){\n\t\tvXors[e->from()] ^= ((SimpleEdge*)e)->weight();\n\t\tvXors[e->to()] ^= ((SimpleEdge*)e)->weight();\n\t}\n\tint freq[16] = {};\n\trep(i,g.size()){\n\t\tfreq[vXors[i]]++;\n\t}\n\tint baseAnswer = 0;\n\tint freqBit = 0;\n\tfor(int i = 1 ; i < 16 ; i++){\n\t\tbaseAnswer += freq[i] / 2;\n\t\tfreqBit |= (freq[i]%2) << i;\n\t}\n\n\tint dp[1<<16];\n\tfillINF(dp);\n\tdp[0] = 0;\n\tfor(int i = 0 ; i <= freqBit ; i+=2){\n\t\tint j = i;\n\t\twhile(j){\n\t\t\tdp[i] = min(dp[i], dp[i^j] + popcount(j) - (canMakeZero(j) ? 1 : 0));\n\t\t\tj = (j-1) & i;\n\t\t}\n\t}\n\tcout << dp[freqBit] + baseAnswer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nvector < pii > g[N];\nint ans = 0;\nvi dfs(int node,int prev)\n{\n    int cnt[16];\n    memset(cnt,0,sizeof(cnt));\n    for (auto it : g[node])\n        if (it.fi != prev)\n        {\n            vi v = dfs(it.fi,node);\n            if (v.empty() && it.se)\n                v.pb(0);\n            for (auto u : v)\n            ++cnt[u ^ it.se];\n        }\n    for (int i = 0;i < 16;++i)\n        ans += cnt[i] / 2,cnt[i] &= 1;\n    if (node == 1)\n        ans += accumulate(cnt,cnt + 16,0);\n    else\n    {\n        vi ret;\n        for (int i = 0;i < 16;++i)\n            if (cnt[i])\n                ret.pb(i);\n        return ret;\n    }\n    return vi(0);\n}\nint main(void)\n{\n    int n;\n    cin>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b,c;\n        cin>>a>>b>>c;\n        ++a;++b;\n        g[a].pb(mp(b,c));\n        g[b].pb(mp(a,c));\n    }\n    dfs(1,0);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxn=100005;\nint n,x[maxn],a[16],dp[1<<16],s,mask[1<<16];\nvector<int> v;\nvector<pii> G[maxn];\nvoid dfs(int u,int fa) {\n    for (int i=0;i<(int)G[u].size();++i) {\n        int v=G[u][i].first,w=G[u][i].second;\n        if (v==fa)\n            continue;\n        x[v]=w^x[u];\n        dfs(v,u);\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=0;i<n-1;++i) {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        G[u].push_back(pii(v,w));\n        G[v].push_back(pii(u,w));\n    }\n    dfs(0,-1);\n    for (int i=0;i<n;++i)\n        ++a[x[i]];\n    int res=n-a[0];\n    for (int i=1;i<16;++i) {\n        if (a[i]%2==1)\n            v.push_back(i);\n        res-=a[i]/2;\n    }\n    if (!v.size())\n        return 0*printf(\"%d\\n\",res);\n    s=1<<v.size();\n    for (int i=0;i<s;++i)\n        for (int j=0;j<(int)v.size();++j)\n            if (i&(1<<j))\n                mask[i]^=v[j];\n    for (int i=0;i<s;++i)\n        for (int j=0;j<(int)v.size();++j)\n            if (i&(1<<j))\n                dp[i]=max(dp[i],dp[i^(1<<j)]+(mask[i]==0));\n    printf(\"%d\\n\",res-dp[s-1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+1;\n\nint val[N];\nint n;\n\ninline int read(){\n   int out = 0;char ch;\n   for(ch = getchar();ch > '9' || ch < '0';ch = getchar());\n   for(;ch >= '0' && ch <= '9';ch = getchar())\n      out = (out<<3)+(out<<1)+(ch&15);\n   return out;\n}\nstruct edge{\n   int tail[N],to[N],nxt[N],tot;\n   inline void add_edge(int x,int y){\n      to[++tot] = y; nxt[tot] = tail[x]; tail[x] = tot;\n   }\n}e;\n\nint v[16],f[1<<17];\nint deg[N];\nint main(){\n   n = read();\n   for(int i = 1;i < n; ++i){\n      int u,v,w;\n      u = read(); v = read(); w = read();deg[u] ^= w; deg[v] ^= w;\n   }\n   for(int i = 0;i < n; ++i)v[deg[i]] += 1;\n   int ans = 0;\n   int ps = 0;\n   for(int i = 0;i < 16; ++i){\n      if(i)ans += v[i]/2; v[i] %= 2;\n      ps |= (1<<i)*v[i];\n      //cerr << i <<' ' << v[i] << ' ' << deg[i] << endl;\n   }\n   //cerr << ps <<' ' << ans << endl;\n   memset(f,0x3f,sizeof f);\n   f[ps] = 0;\n\n   for(int i = (1<<16)-1;i > 0; --i){\n      for(int j = 0;j < 16; ++j)\n         for(int k = j;k < 16; ++k){\n            if(((1 << j) & i) && ((1<<k)&i)){\n               int pi = (i ^ (1<<j)); pi ^= (1<<k);\n               int w = (j^k);\n               if(pi & (1<<w))f[pi^(1<<w)] = min(f[pi^(1<<w)],f[i]+2);\n               else f[pi^(1<<w)] = min(f[pi^(1<<w)],f[i]+1);\n            }\n         }\n   }\n   printf(\"%d\\n\",f[0]+ans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, A = 15;\nint ans;\nint cnt, maxmn;\n\n\nvector <pair <int, int> > adj[N];\nbool mark[N];\nbool b[N];\nint dp[N][A + 5];\nvector < pair <int, pair <int, int> > > chs;\nvoid bt(int maxp = 0) {\n//\tcout << maxp << endl;\n\tmaxmn = max(maxmn, cnt);\n\tfor (int i = maxp; i < chs.size(); i++) {\n\t\tint x = chs[i].first, y = chs[i].second.first, z = chs[i].second.second;\n\t\tif (b[x] || b[y] || b[z]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dp[1][x] && dp[1][y] && dp[1][z]) {\n\t\t\tcnt++;\n\t\t}\n\t\tb[x] = true;\n\t\tb[y] = true;\n\t\tb[z] = true;\n\t\tbt(i + 1);\n\t\tif (dp[1][x] && dp[1][y] && dp[1][z]) {\n\t\t\tcnt--;\n\t\t}\n\t\tb[x] = false;\n\t\tb[y] = false;\n\t\tb[z] = false;\n\t}\n}\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto p : adj[v]) {\n\t\tint u = p.first, w = p.second;\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tfor (int i = 0; i <= A; i++) {\n\t\t\t\tdp[v][i] += dp[u][i];\n\t\t\t\tif (dp[u][i] % 2 == 1) {\n\t\t\t\t\tw ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[v][w]++;\n\t\t}\n\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[v][i] && dp[v][j] && dp[v][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[v][i] = 0;\n\t\t\t\tdp[v][j] = 0;\n\t\t\t\tdp[v][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[v][i] / 2;\n\t\tdp[v][i] %= 2;\n\t}*/\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i] / 2;\n\t\tdp[1][i] %= 2;\n\t//\tcout << i << \" \" << dp[1][i] << endl;\n\t}\n/*\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (dp[1][i] && dp[1][j] && dp[1][i ^ j]) {\n\t\t\t\tans += 2;\n\t\t\t\tdp[1][i] = 0;\n\t\t\t\tdp[1][j] = 0;\n\t\t\t\tdp[1][i ^ j] = 0;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tfor (int k = 1; k < j; k++) {\n\t\t\t\tchs.push_back({i, {j, k}});\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tans += dp[1][i];\n\t}\n\tbt();\n\tcout << ans - maxmn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<P> G[100000];\nP dfs(int x, int p) {\n  int s = 0, mask = 0;\n  for (P pp : G[x]) if (pp._1 != p) {\n    int t = pp._1, w = pp._2;\n    P r = dfs(t, x);\n    s += r._1;\n    rep(i, 4) if ((w>>i)&1) if (((r._2>>i)&1) == 0) s++;\n    s -= __builtin_popcount(w&mask);\n    mask ^= w;\n  }\n  return P(s, mask);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int x, y, a;\n    cin >> x >> y >> a;\n    G[x].pb(P(y, a));\n    G[y].pb(P(x, a));\n  }\n  cout << dfs(0, -1)._1 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define file(s) freopen(s\".in\",\"r\",stdin), freopen(s\".out\",\"w\",stdout)\n\n#define Grt ch=getchar()\n#define DeBug(x) std::cout<<#x<<'='<<x<<std::endl\n\ntypedef long long ll;\nconst int MaxN=1e5+10, MaxM=1<<15;\n\nnamespace IO\n{\n\tchar buf[1<<15], *fs, *ft;\n\tinline char getc() { return ft==fs && (ft=(fs=buf)+fread(buf, 1, 1<<15, stdin), ft==fs) ? 0 : *fs++; }\n\ttemplate <typename T> inline void read(T &x)\n\t{\n\t\tx=0;\n\t\tT f=1, Grt;\n\t\twhile (!isdigit(ch) && ch^'-') Grt;\n\t\tif (ch=='-') f=-1, Grt;\n\t\twhile (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), Grt;\n\t\tx*=f;\n\t}\n\n\ttemplate <typename T, typename... Args>\n\tinline void read(T &x, Args &...args) { read(x); read(args...); }\n\n\tchar Out[1<<24], *fe=Out;\n\tinline void flush() { fwrite(Out, 1, fe-Out, stdout); fe=Out; }\n\ttemplate <typename T> inline void write(T x, char str)\n\t{\n\t\tif (!x) *fe++=48;\n\t\tif (x<0) *fe++='-', x=-x;\n\t\tT num=0, ch[20];\n\t\twhile (x) ch[++num]=x%10+48, x/=10;\n\t\twhile (num) *fe++=ch[num--];\n\t\t*fe++=str;\n\t}\n}\n\nusing IO::read;\nusing IO::write;\n\ntemplate <typename T> inline bool chkMin(T &a, const T &b) { return a>b ? (a=b, true) : false; }\ntemplate <typename T> inline bool chkMax(T &a, const T &b) { return a<b ? (a=b, true) : false; }\ntemplate <typename T> inline T min(T a, T b) { return a<b ? a : b; }\ntemplate <typename T> inline T max(T a, T b) { return a>b ? a : b; }\n\nint v[MaxN], cnt[16], f[MaxM+10];\nbool xr[MaxM+10];\nint main()\n{\n\tint n, ans=0, state=0; read(n);\n\tfor (int i=1, x, y, z; i< n; ++i) read(x, y, z), v[x]^=z, v[y]^=z;\n\tfor (int i=0; i<n; ++i) ++cnt[v[i]];\n\tfor (int i=1; i<=15; ++i) ans+=cnt[i]>>1, state|=(cnt[i]&1)<<(i-1);\n\n\tfor (int i=1; i< (1<<15); ++i) f[i]=f[i>>1]+(i&1);\n\tfor (int i=1; i< (1<<15); ++i) --f[i];//é¢å¤çæ¯ä¸ªdpå¼çä¸ç\n\tfor (int s=1; s< (1<<15); ++s)\n\t\tfor (int i=0; i< 15; ++i)\n\t\t\tif ((s>>i)&1) xr[s]^=(i+1);\n\tfor (int s=1; s< (1<<15); ++s)\n\t{\n\t\tif (xr[s]) continue;\n\t\tfor (int t=(s-1)&s; t; t=(t-1)&s)\n\t\t\tif (!xr[t]) chkMin(f[s], f[t]+f[s^t]);\n\t}\n\twrite(ans+f[state], '\\n');\n\tIO::flush();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 1e5 + 51;\n\nint dp[N], xorv[N];\nint dfs(int S) {\n\tif (dp[S]) return dp[S];\n\tint ret = __builtin_popcount(S) - 1;\n\tfor (int T = (S - 1) & S; T; T = (T - 1) & S)\n\t\tif (!xorv[T]) ret = std::min(ret, dfs(T) + dfs(S ^ T));\n\treturn dp[S] = ret;\n}\n\nint n, x, y, z, v[N], c[22], ans, msk;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z), x++, y++;\n\t\tx[v] ^= z, y[v] ^= z;\n\t}\n\tfor (int i = 1; i <= n; i++) i[v][c]++;\n\tfor (int i = 1; i <= 15; i++) {\n\t\tans += i[c] / 2;\n\t\tmsk |= (i[c] & 1) << (i - 1);\n\t}\n\tfor (int S = 0; S < 32768; S++)\n\t\tfor (int j = 1; j <= 15; j++)\n\t\t\tif ((S >> (j - 1)) & 1) xorv[S] ^= j;\n\tprintf(\"%d\", ans + (msk ? dfs(msk) : 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint f[133333],g[133333],a[133333],w[133333],p[133333];\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint n,i,x,y,l,j,cnt=0,ans=0;\n\tscanf(\"%d\",&n);\n//\tprintf(\"%d\\n\",n);\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&x,&y,&l);\n\t\tx++,y++;\n\t\tg[x]^=l,g[y]^=l; \n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(a[g[i]]&&g[i])\n\t\t\tans++;\n\t\ta[g[i]]^=1;\n\t}\n//\tprintf(\"%d\\n\",ans);\n\tfor(i=0;i<16;i++)\n\t\tif(a[i])\n\t\t\tp[++cnt]=i;//,printf(\"%d\\n\",i);\n//\tprintf(\"%d|\",cnt);\n\tfor(i=0;i<(1<<cnt);i++)\n\t{\n\t\tint sum=0;\n\t\tfor(j=1;j<=cnt;j++)\n\t\t\tif((1<<j-1)&i)\n\t\t\t\tw[i]^=p[j],sum++;\n\t\tif(i)\n\t\tf[i]=sum-1;\n\t\tif(!w[i])\n\t\t{\n\t\t\tfor(j=i-1;j;j=(j-1)&i)\n\t\t\t{\n\t\t\t\tif(!w[j])\n\t\t\t\t\tf[i]=min(f[i],f[j]+f[i-j]);\n\t\t\t\telse\n\t\t\t\t\tf[i]=min(f[i],f[j]+f[i-j]+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[(1<<cnt)-1]+ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint in[N],n,ans,is,msk,to = 1<<26,from;\nvector<int>v;\nshort dp[1<<26];\nvoid val(int msk){\n\tv.clear();\n\twhile(msk)\n\t\tv.push_back(msk%3),\n\t\tmsk/=3;\n\twhile(v.size() < 16)v.push_back(0);\n}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1,a,b,c;i < n;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tin[a]^=c;\n\t\tin[b]^=c;\n\t}\n\tfor(int i = 0;i < n;i++)\n\t\tans+=!!(is&(1<<in[i])) && in[i],\n\t\tis^=1<<in[i];\n\tis&=(~0) - 1;\n\tfor(int i = 0;i < to;i++)dp[i] = 17;\n \tfor(int i = 15;i+ 1;i--)msk = msk*3 + (!(is&(1<<i)) ? 2 : 0);\n\tdp[msk] = 0;\n\tfor(int i = 0;i < to;i++)\n\t\tif(dp[i] < 17){\n\t\t\tval(i);\n\t\t\tint three = 1, freq = 0,temp = 0;\n\t\t\tfrom = 0;\n\t\t\tfor(int j = 0;j < v.size();j++,three*=3){\n\t\t\t\tif(!v[j])dp[i + three] = min(dp[i + three],dp[i]);\n\t\t\t\tif(v[j] == 1)temp^=j,freq++;\n\t\t\t\tfrom = from*3 + (v[j] ? 2 : 0);\n\t\t\t}\n\t\t\tshort lol = dp[i] + freq - (freq > 1);\n\t\t\tif(!temp)dp[from] = min(dp[from],lol);\n\t\t}\n\tfrom = 0;\n\tfor(int i = 0;i < 16;i++)from = from*3 + 2;\n\tcout << ans + dp[from] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 100000\n#define P 15\n#define INF 1e9\n#define Gmin(x,y) (x>(y)&&(x=(y)))\nconst int maxn = 100035;\nconst int maxs = 1<<17;\n\nint n,cnt,a[maxn],f[maxs],sta,ans;\n\nclass Class_FIO\n{\n\tprivate:\n\t\t#define FS 100000\n\t\t#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)\n\t\t#define pc(c) (putchar(c))\n\t\t#define tn(x) (x<<3)+(x<<1)\n\t\t#define D isdigit(c=tc())\n\t\tint T;char c,*A,*B,FI[FS],S[FS];\n\tpublic:\n\t\tI Class_FIO() {A=B=FI;}\n\t\tTp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}\n\t\tTp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}\n\t\tTs I void read(Ty& x,Ar&... y) {read(x),read(y...);}\n}F;\nint dp(int x)\n{\n\tif (!x) return 0;\n\tif (f[x]!=-1) return f[x];\n\tint ret = 1e9;\n\tfor (int i=1; i<16; i++)\n\t\tif (x&(1<<i)) for (int j=1; j<16; j++)\n\t\t\tif ((x&(1<<j))&&i!=j)\n\t\t\t\tret = std::min(ret, dp(x^(1<<i)^(1<<j)^(1<<(i^j)))+1+((x&(1<<(i^j)))?1:0));\n\tf[x] = ret;\n\treturn ret;\n}\nint main()\n{\n\tfreopen(\"xor.in\",\"r\",stdin);\n\tfreopen(\"xor.out\",\"w\",stdout);\n\tF.read(n);\n\tmemset(f, -1, sizeof f);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint x,y,z;\n\t\tF.read(x), ++x, F.read(y), ++y, F.read(z);\n\t\ta[x] ^= z, a[y] ^= z;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tif (a[i]&&((sta>>a[i])&1)) sta ^= 1<<a[i], ++ans;\n\t\telse if (a[i]) sta ^= 1<<a[i];\n\tprintf(\"%d\\n\",ans+dp(sta));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\nconst int N=2e5;\nint ans,n,a[N],t,f[1<<20][20],q[N];\nint main()\n{\n\tn=read();\n\tint x,y,v;\n\tfor(int i=1;i<n;++i)x=read()+1,y=read()+1,v=read(),a[x]^=v,a[y]^=v;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)\n\tif(i<n&&a[i]==a[i+1]) a[i]!=0?ans++:0,i++;\n\telse q[++t]=a[i];\n\tmemset(f,0x3f,sizeof(f));f[0][0]=0;\n\tfor(int i=1;i<=t;++i)f[1<<(i-1)][q[i]]=0;\n\tfor(int i=0;i<(1<<t);++i)\n\tfor(int j=0;j<16;++j)\n\tfor(int k=1;k<=t;++k)\n\tif(i&(1<<(k-1)))\n\tf[i][j]=min(f[i][j],f[i-(1<<(k-1))][j^q[k]]+1);\n\tprintf(\"%d\\n\",f[(1<<t)-1][0]+ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#define SIZE 100005\n#define MX 20\n#define BT (1<<16)+5\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct edge\n{\n\tint to,cost;\n\tedge(int to=0,int cost=0):to(to),cost(cost){}\n};\nvector <edge> vec[SIZE];\nint A[SIZE];\nint dp[BT],rv[MX];\nint nw[BT];\nint nm[MX];\n\nint dfs(int v=0,int p=-1)\n{\n\tint all=0;\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tedge e=vec[v][i];\n\t\tif(e.to!=p)\n\t\t{\n\t\t\tint g=dfs(e.to,v);\n\t\t\tA[e.to]=g^e.cost;\n\t\t\tall^=A[e.to];\n\t\t\tall^=g;\n\t\t}\n\t}\n\treturn all;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint x,y,a;\n\t\tscanf(\"%d %d %d\",&x,&y,&a);\n\t\tvec[x].push_back(edge(y,a));\n\t\tvec[y].push_back(edge(x,a));\n\t}\n\tdfs();\n\t//for(int i=1;i<n;i++) printf(\"%d\\n\",A[i]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tnm[A[i]]++;\n\t}\n\tint ret=nm[0];\n\tfor(int i=1;i<MX;i++)\n\t{\n\t\tret+=nm[i]/2;\n\t\tnm[i]%=2;\n\t}\n\tvector <int> vt;\n\tfor(int i=1;i<MX;i++) if(nm[i]==1) vt.push_back(i);\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(rv,-1,sizeof(rv));\n\tfor(int i=0;i<vt.size();i++) rv[vt[i]]=i;\n\tdp[0]=0;\n\tfor(int i=0;i<vt.size();i++)\n\t{\n\t\tmemset(nw,-1,sizeof(nw));\n\t\tfor(int S=0;S<1<<i;S++)\n\t\t{\n\t\t\tif(dp[S]==-1) continue;\n\t\t\tnw[S|1<<i]=max(nw[S|1<<i],dp[S]);\n\t\t\tfor(int a=0;a<i;a++)\n\t\t\t{\n\t\t\t\tif(!(S>>a&1)) continue;\n\t\t\t\tfor(int b=a+1;b<i;b++)\n\t\t\t\t{\n\t\t\t\t\tif(!(S>>b&1)) continue;\n\t\t\t\t\tif(vt[a]^vt[b]^vt[i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b);\n\t\t\t\t\t\tnw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=b+1;c<i;c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(S>>c&1)) continue;\n\t\t\t\t\t\tint t=vt[a]^vt[b]^vt[c];\n\t\t\t\t\t\tint T=S-(1<<a)-(1<<b)-(1<<c);\n\t\t\t\t\t\tif(t^vt[i]==0) nw[T]=max(nw[T],dp[S]+1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt^=vt[i];\n\t\t\t\t\t\t\tif(rv[t]!=-1&&(T>>rv[t]&1))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint K=T-(1<<rv[t]);\n\t\t\t\t\t\t\t\tnw[K]=max(nw[K],dp[S]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int S=0;S<1<<(i+1);S++) dp[S]=nw[S];\n\t}\n\tint mx=0;\n\tfor(int i=0;i<BT;i++) mx=max(mx,dp[i]);\n\tprintf(\"%d\\n\",n-1-ret-mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\ntypedef struct{\n    long long st;\n    long long fi;\n    long long kr;\n    long long id;\n}rs;\n\ntypedef struct{\n    long long st;\n    long long kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st > ((rs*)b)->st){return 1;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nif(((rs*)a)->fi > ((rs*)b)->fi){return 1;}\nif(((rs*)a)->fi < ((rs*)b)->fi){return -1;}\nreturn 0;\n}\n\nvoid makemkj(rs g[],mkj x[],long long n){\n    long long i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\nint main(void){\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n  long long v[524288]={0};\n  long long bk[16]={0};\n  long long dp[32768],fl[32768];\n  for(i=0;i<32768;i++){dp[i]=llinf;}\n  for(i=0;i<32768;i++){\n    w=0;\n    for(j=0;j<15;j++){\n      if((i&(1ll<<j))!=0){w^=(j+1ll);}\n    }\n    if(w==0){fl[i]=lldsumb(i,2)-1;}else{fl[i]=0;}\n  }\n  scanf(\"%lld\",&n);\n  for(i=0;i<(n-1);i++){\n    scanf(\"%lld%lld%lld\",&a,&b,&c);\n    v[a]^=c;\n    v[b]^=c;\n  }\n  for(i=0;i<n;i++){bk[v[i]]++;}\n  w=0;\n  for(i=1;i<16;i++){\n    r+=(bk[i]/2);\n    //printf(\"%lld : %lld\\n\",i,bk[i]);\n    if(bk[i]%2==1){w|=(1ll<<(i-1));}\n  }\n  dp[w]=0;\n  for(i=w;i>=1;i--){\n    if(dp[i]==llinf){continue;}\n    for(j=i;j>0;j=((j-1ll)&i)){\n      if(fl[j]!=0){\n        dp[i^j]=llmin(dp[i^j],dp[i]+fl[j]);\n        //printf(\"%lld -> %lld : %lld\\n\",i,i^j,dp[i^j]);\n      }\n    }\n  }\n  \n  printf(\"%lld\\n\",r+dp[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll bitdp[1 << 18];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\te[a[i]] ^= c[i];\n\t\te[b[i]] ^= c[i];\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\td[e[i]]++;\n\t}\n\tull begin = 0;\n\tfor (i = 1; i < 16; i++) {\n\t\tresult += d[i] / 2;\n\t\tif (d[i] % 2) begin |= (1LL << i);\n\t}\n\n\tfor (i = 0; !(i >> 16); i++) {\n\t\tbitdp[i] = BIG;\n\t}\n\tbitdp[begin] = 0;\n\tfor (i = (1LL << 16) - 1; i; i--) {\n\t\tif (bitdp[i] == BIG) continue;\n\t\tull largest = 15;\n\t\twhile (!(i & (1LL << largest))) largest--;\n\n\t\tfor (j = largest - 1; j; j--) {\n\t\t\tull nex = largest ^ j;\n\t\t\tif (nex > largest) continue;\n\n\t\t\tull ni = i ^ (1LL << largest) ^ (1LL << j) ^ (1LL << nex);\n\t\t\tull ad = 1;\n\t\t\tif (i & (1LL << nex)) ad++;\n\n\t\t\tbitdp[ni] = smin(bitdp[ni], bitdp[i] + ad);\n\t\t}\n\t}\n\tresult += bitdp[0];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < n - 1; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\tscanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint main(){\n\tint N, x, y, a, i, j, K = 16, ans = 0, remain_num, xor, i_num;\n\tscanf(\"%d\", &N);\n\tint *val = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tval[i] = 0;\n\t}\n\tfor(i = 1; i < N; i++){\n\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\tval[x] ^= a;\n\t\tval[y] ^= a;\n\t}\n\tint *remain = (int *)malloc(sizeof(int) * K);\n\tfor(i = 0; i < K; i++){\n\t\tremain[i] = 0;\n\t}\n\tfor(i = 0; i < N; i++){\n\t\tif(val[i] > 0 && remain[val[i]] == 1){\n\t\t\tans++;\n\t\t}\n\t\tremain[val[i]] ^= 1;\n\t}\n\tremain[0] = 0;\n\tremain_num = 0;\n\tfor(i = 0; i < K; i++){\n\t\tremain_num ^= (remain[i] << i);\n\t}\n//\tprintf(\"ans = %d\\n\", ans);\n//\tprintf(\"remain_num = %d\\n\", remain_num);\n\tint *dp = (int *)malloc(sizeof(int) * (1 << K));\n\tdp[0] = 0;\n\tfor(i = 0; i < (1 << K); i++){\n//\t\tprintf(\"dp[%d] = %d\\n\", i, dp[i]);\n\t\txor = 0;\n\t\ti_num = 0;\n\t\tfor(j = 0; j < K; j++){\n\t\t\tif((i & (1 << j)) != 0){\n//\t\t\t\tprintf(\"j = %d\\n\", j);\n\t\t\t\txor ^= j;\n\t\t\t\ti_num++;\n\t\t\t}\n\t\t}\n\t\tif(xor != 0){\n\t\t\tdp[i] = inf;\n\t\t}\n\t\telse{\n\t\t\tdp[i] = i_num - 1;\n//\t\t\tprintf(\"dp[%d] = %d\\n\", i, dp[i]);\n\t\t\tfor(j = i; j > 0; j = ((j - 1) & i)){\n\t\t\t\tdp[i] = min(dp[i], dp[j] + dp[i ^ j]);\n\t\t\t}\n\t\t}\n\t\tif(i == 0){\n\t\t\tdp[i] = 0;\n\t\t}\n//\t\tprintf(\"dp[%d] = %d\\n\", i, dp[i]);\n\t\tif(i == remain_num){\n\t\t\tprintf(\"%d\\n\", ans + dp[remain_num]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    int n;\n    void solve(){\n        n = ni();\n        int[] b = new int[n];\n        for(int i = 0; i < n-1; i++){\n            int from = ni();\n            int to = ni();\n            int cost = ni();\n            b[from] ^= cost;\n            b[to] ^= cost;\n        }\n        int[] c = new int[16];\n        for(int i = 0; i < n; i++){\n            c[b[i]]++;\n        }\n        int ans = 0;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]>=2){\n                ans += c[i]/2;\n                c[i] = c[i]%2;\n            }\n        }\n        int[] res = new int[1<<16];\n        for(int i = 0; i < (1<<15); i++){\n            int tmp = 0;\n            int count = 0;\n            for(int j = 0; j < 15; j++){\n                if((i>>j)%2==1){\n                    tmp ^= (j+1);\n                    count++;\n                }\n            }\n            if(tmp==0){\n                res[i] = count;\n            }\n            else res[i] = -1;\n        }\n        int[] dp = new int[1<<15];\n        Arrays.fill(dp, 100000);\n        for(int i = 0; i < (1<<15); i++){\n            for(int j = i; j > 0 ; j = (j-1)&i){\n                int A = j;\n                int B = j^i;\n                if(res[A]>=0) dp[A] = Math.min(dp[A], res[A]);\n                if(res[B]>=0) dp[B] = Math.min(dp[B], res[B]);\n                // out.println(a+\" \"+b2+\" \"+resa);\n            }\n        }\n        int mask = 0;\n        int p = 1;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]==1) mask += p;\n            p *= 2;\n        }\n        out.println(dp[mask]+ans);\n\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    int n;\n    void solve(){\n        n = ni();\n        int[] b = new int[n];\n        for(int i = 0; i < n-1; i++){\n            int from = ni();\n            int to = ni();\n            int cost = ni();\n            b[from] ^= cost;\n            b[to] ^= cost;\n        }\n        int[] c = new int[16];\n        for(int i = 0; i < n; i++){\n            c[b[i]]++;\n        }\n        int ans = 0;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]>=2){\n                ans += c[i]/2;\n                c[i] = c[i]%2;\n            }\n        }\n        int[] res = new int[1<<15];\n        for(int i = 0; i < (1<<15); i++){\n            int tmp = 0;\n            int count = 0;\n            for(int j = 0; j < 15; j++){\n                if((i>>j)%2==1){\n                    tmp ^= (j+1);\n                    count++;\n                }\n            }\n            if(tmp==0){\n                res[i] = count>0 ? count-1 : 0;\n            }\n            else res[i] = 1000000;\n        }\n        for(int i = 0; i < (1<<15); i++){\n            for(int j = i; j > 0 ; j = (j-1)&i){\n                int A = j;\n                int B = j^i;\n                if(res[A]<=100000 && res[B]<=100000) res[i] = Math.min(res[i], res[A]+res[B]);\n            }\n        }\n        int mask = 0;\n        int p = 1;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]==1) mask += p;\n            p *= 2;\n        }\n        out.println(res[mask]+ans);\n\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    public static final int GEN = 6;\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 1; i < 16; ++i) {\n        mask |= ((a[i] % 2) << i);\n        res -= (a[i] % 2);\n      }\n      // best = 10000000;\n      // //D = new HashMap<>();\n      // go(a, 0);\n      // res = best;\n\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      int[] d = new int[1 << 16];\n      Arrays.fill(d, Integer.MAX_VALUE);\n      d[mask] = 0;\n      int[][] q = new int[GEN][(1 << 15) + 2];\n      int[] ql = new int[GEN];\n      q[0][ql[0]++] = mask;\n      for (int dist = 0; dist < 30; ++dist) {\n        int[] curQ = q[dist % GEN];\n        int qr = 0;\n        while (ql[dist % GEN] > qr) {\n          int m = curQ[qr++];\n          int val = d[m];\n          for (int x = 1; x < 16; ++x) {\n            for (int i = 1; i < 16; ++i) {\n              if ((m >> i) % 2 == 1) {\n                {\n                  int nm = m ^ (1 << i);\n                  int inc = 1;\n                  int k = (i ^ x);\n                  if ((nm >> k) % 2 == 1) {\n                    ++inc;\n                  }\n                  if (k > 0) {\n                    nm ^= (1 << k);\n                  }\n                  if (d[nm] > val + inc) {\n                    d[nm] = val + inc;\n                    q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n                  }\n                }\n                for (int j = i + 1; j < 16; ++j) {\n                  int inc = 1;\n                  int nm = m ^ (1 << i) ^ (1 << j);\n                  int ki = (i ^ x);\n                  if ((nm >> ki) % 2 == 1) {\n                    inc += 1;\n                  }\n                  if (ki > 0) {\n                    nm ^= (1 << ki);\n                  }\n                  int kj = (j ^ x);\n                  if ((nm >> kj) % 2 == 1) {\n                    inc += 1;\n                  }\n                  if (kj > 0) {\n                    nm ^= (1 << kj);\n                  }\n                  if (d[nm] > val + inc) {\n                    d[nm] = val + inc;\n                    q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n                  }\n                }\n              }\n            }\n          }\n        }\n        ql[dist % GEN] = 0;\n      }\n      res += d[0];\n\n      // ArrayList<DijkstraHeap.Edge>[] G = new ArrayList[1 << 16];\n      // for (int i = 0; i < G.length; ++i)\n      //     G[i] = new ArrayList<>();\n      // for (int m = 1; m < (1 << 16); ++m) {\n      //     for (int i = 0; i < 16; ++i) {\n      //         {\n      //             int nm = m ^ (1 << i);\n      //             G[m].add(new DijkstraHeap.Edge(nm, 1));\n      //         }\n      //         for (int j = i + 1; j < 16; ++j) {\n      //             int k = (i ^ j);\n      //             int inc = 1;\n      //             int nm = m ^ (1 << i) ^ (1 << j);\n      //             if ((nm >> k) % 2 == 1) {\n      //                 ++inc;\n      //             }\n      //             nm ^= (1 << k);\n      //             G[m].add(new DijkstraHeap.Edge(nm, (long) inc));\n      //         }\n      //     }\n      // }\n      // long[] prio = new long[G.length];\n      // int[] pred = new int[G.length];\n      // DijkstraHeap.shortestPaths(G, mask, prio, pred);\n\n      // int[] d = new int[1 << 16];\n      // Arrays.fill(d, Integer.MAX_VALUE);\n      // d[mask] = res;\n      // int[][] q = new int[GEN][(1 << 15) + 2];\n      // int[] ql = new int[GEN];\n      // q[0][ql[0]++] = mask;\n      // for (int dist = 0; dist < 100; ++dist) {\n      //     int[] curQ = q[dist % GEN];\n      //     int qr = 0;\n      //     while (ql[dist % GEN] > qr) {\n      //         int m = curQ[qr++];\n      //         int val = d[m];\n      //         for (int i = 1; i < 16; ++i) {\n      //             {\n      //                 int nm = m ^ (1 << i);\n      //                 int inc = 2;\n      //                 if ((m >> i) % 2 == 0 && a[i] >= 2) --inc;\n      //                 if (d[nm] > val + inc) {\n      //                     d[nm] = val + inc;\n      //                     q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                 }\n      //             }\n      //             for (int j = i + 1; j < 16; ++j) {\n      //                 int k = (i ^ j);\n      //                 int inc = 2;\n      //                 if ((m >> i) % 2 == 0 && a[i] >= 2) --inc;\n      //                 if ((m >> j) % 2 == 0 && a[j] >= 2) --inc;\n      //                 int nm = m ^ (1 << i) ^ (1 << j);\n      //                 if ((nm >> k) % 2 == 1) {\n      //                     inc += 2;\n      //                 }\n      //                 nm ^= (1 << k);\n      //                 if (d[nm] > val + inc) {\n      //                     d[nm] = val + inc;\n      //                     q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                 }\n      //             }\n      //         }\n      //     }\n      //     ql[dist % GEN] = 0;\n      // }\n      // //res += d[0];\n      // res = d[0];\n      // Assert.assertTrue(res % 2 == 0);\n      // res /= 2;\n\n      // for (int nbits = 1; nbits <= 16; ++nbits) {\n      //     for (int m = 1; m < (1 << 16); ++m)\n      //         if (Integer.bitCount(m) == nbits) {\n      //             d[m] = 1000000;\n      //             for (int i = 0; i < 16; ++i)\n      //                 if ((m >> i) % 2 == 1) {\n      //                     {\n      //                         int nm = m ^ (1 << i);\n      //                         d[m] = Math.min(d[m], d[nm] + 1);\n      //                     }\n      //                     for (int j = i + 1; j < 16; ++j)\n      //                         if ((m >> j) % 2 == 1) {\n      //                             int k = (i ^ j);\n      //                             int inc = 1;\n      //                             int nm = m ^ (1 << i) ^ (1 << j);\n      //                             if ((nm >> k) % 2 == 1) {\n      //                                 ++inc;\n      //                             }\n      //                             nm ^= (1 << k);\n      //                             d[m] = Math.min(d[m], d[nm] + inc);\n      //                         }\n      //                 }\n      //         }\n      // }\n      // res += d[mask];\n      //     // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n      //     //     int tot = 0;\n      //     //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n      //     //         tot ^= i;\n      //     //     if (tot != 0) continue;\n      //     //     mask ^= m;\n      //     //     res += nbits - 1;\n      //     // }\n      // }\n\n      //res += Integer.bitCount(mask);\n      //res += (int) prio[0];\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n          }\n          ++a[val];\n          //mask ^= val;\n          mask ^= e.second;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 0; i < 16; ++i) {\n        mask |= (a[i] << i);\n        res -= a[i];\n      }\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      // ArrayList<DijkstraHeap.Edge>[] G = new ArrayList[1 << 16];\n      // for (int i = 0; i < G.length; ++i)\n      //     G[i] = new ArrayList<>();\n      // for (int m = 1; m < (1 << 16); ++m) {\n      //     for (int i = 0; i < 16; ++i) {\n      //         {\n      //             int nm = m ^ (1 << i);\n      //             G[m].add(new DijkstraHeap.Edge(nm, 1));\n      //         }\n      //         for (int j = i + 1; j < 16; ++j) {\n      //             int k = (i ^ j);\n      //             int inc = 1;\n      //             int nm = m ^ (1 << i) ^ (1 << j);\n      //             if ((nm >> k) % 2 == 1) {\n      //                 ++inc;\n      //             }\n      //             nm ^= (1 << k);\n      //             G[m].add(new DijkstraHeap.Edge(nm, (long) inc));\n      //         }\n      //     }\n      // }\n      // long[] prio = new long[G.length];\n      // int[] pred = new int[G.length];\n      // DijkstraHeap.shortestPaths(G, mask, prio, pred);\n\n      int[] d = new int[1 << 16];\n      Arrays.fill(d, Integer.MAX_VALUE);\n      d[mask] = 0;\n      int[][] q = new int[3][(1 << 15) + 2];\n      int[] ql = new int[3];\n      q[0][ql[0]++] = mask;\n      for (int dist = 0; dist < 100; ++dist) {\n        int[] curQ = q[dist % 3];\n        int curL = ql[dist % 3];\n        int[] nextQ = q[(dist + 1) % 3];\n        ql[(dist + 1) % 3] = 0;\n        int[] nnextQ = q[(dist + 2) % 3];\n        ql[(dist + 2) % 3] = 0;\n        int qr = 0;\n        while (curL > qr) {\n          int m = curQ[qr++];\n          int val = d[m];\n          for (int i = 0; i < 16; ++i) {\n            {\n              int nm = m ^ (1 << i);\n              if (d[nm] > val + 1) {\n                d[nm] = val + 1;\n                nextQ[ql[(dist + 1) % 3]++] = nm;\n              }\n            }\n            for (int j = i + 1; j < 16; ++j) {\n              int k = (i ^ j);\n              int inc = 1;\n              int nm = m ^ (1 << i) ^ (1 << j);\n              if ((nm >> k) % 2 == 1) {\n                ++inc;\n              }\n              nm ^= (1 << k);\n              if (d[nm] > val + inc) {\n                d[nm] = val + inc;\n                if (inc == 1) {\n                  nextQ[ql[(dist + inc) % 3]++] = nm;\n                } else {\n                  nnextQ[ql[(dist + inc) % 3]++] = nm;\n                }\n              }\n            }\n          }\n        }\n      }\n      // for (int nbits = 1; nbits <= 16; ++nbits) {\n      //     for (int m = 1; m < (1 << 16); ++m) if (Integer.bitCount(m) == nbits) {\n      //         d[m] = 1000000;\n      //         for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1) {\n      //             {\n      //                 int nm = m ^ (1 << i);\n      //                 d[m] = Math.min(d[m], d[nm] + 1);\n      //             }\n      //             for (int j = i + 1; j < 16; ++j) if ((m >> j) % 2 == 1) {\n      //                 int k = (i ^ j);\n      //                 int inc = 1;\n      //                 int nm = m ^ (1 << i) ^ (1 << j);\n      //                 if ((nm >> k) % 2 == 1) {\n      //                     ++inc;\n      //                 }\n      //                 nm ^= (1 << k);\n      //                 d[m] = Math.min(d[m], d[nm] + inc);\n      //             }\n      //         }\n      //     }\n      //     // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n      //     //     int tot = 0;\n      //     //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n      //     //         tot ^= i;\n      //     //     if (tot != 0) continue;\n      //     //     mask ^= m;\n      //     //     res += nbits - 1;\n      //     // }\n      // }\n\n      //res += Integer.bitCount(mask);\n      //res += d[mask];\n      //res += (int) prio[0];\n      res += d[0];\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n            a[val] ^= 1;\n          }\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    public static final int GEN = 6;\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 1; i < 16; ++i) {\n        mask |= ((a[i] % 2) << i);\n        res -= (a[i] % 2);\n      }\n      Assert.assertTrue(res % 2 == 0);\n\n      // ArrayList<DijkstraHeap.Edge>[] G = new ArrayList[1 << 16];\n      // for (int i = 0; i < G.length; ++i)\n      //     G[i] = new ArrayList<>();\n      // for (int m = 1; m < (1 << 16); ++m) {\n      //     for (int i = 0; i < 16; ++i) {\n      //         {\n      //             int nm = m ^ (1 << i);\n      //             G[m].add(new DijkstraHeap.Edge(nm, 1));\n      //         }\n      //         for (int j = i + 1; j < 16; ++j) {\n      //             int k = (i ^ j);\n      //             int inc = 1;\n      //             int nm = m ^ (1 << i) ^ (1 << j);\n      //             if ((nm >> k) % 2 == 1) {\n      //                 ++inc;\n      //             }\n      //             nm ^= (1 << k);\n      //             G[m].add(new DijkstraHeap.Edge(nm, (long) inc));\n      //         }\n      //     }\n      // }\n      // long[] prio = new long[G.length];\n      // int[] pred = new int[G.length];\n      // DijkstraHeap.shortestPaths(G, mask, prio, pred);\n\n      int[] d = new int[1 << 16];\n      Arrays.fill(d, Integer.MAX_VALUE);\n      d[mask] = res;\n      int[][] q = new int[GEN][(1 << 15) + 2];\n      int[] ql = new int[GEN];\n      q[0][ql[0]++] = mask;\n      for (int dist = 0; dist < 100; ++dist) {\n        int[] curQ = q[dist % GEN];\n        int qr = 0;\n        while (ql[dist % GEN] > qr) {\n          int m = curQ[qr++];\n          int val = d[m];\n          for (int i = 1; i < 16; ++i) {\n            {\n              int nm = m ^ (1 << i);\n              int inc = 2;\n              if ((m >> i) % 2 == 0 && a[i] >= 2) {\n                --inc;\n              }\n              if (d[nm] > val + inc) {\n                d[nm] = val + inc;\n                q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n              }\n            }\n            for (int j = i + 1; j < 16; ++j) {\n              int k = (i ^ j);\n              int inc = 2;\n              if ((m >> i) % 2 == 0 && a[i] >= 2) {\n                --inc;\n              }\n              if ((m >> j) % 2 == 0 && a[j] >= 2) {\n                --inc;\n              }\n              int nm = m ^ (1 << i) ^ (1 << j);\n              if ((nm >> k) % 2 == 1) {\n                inc += 2;\n              }\n              nm ^= (1 << k);\n              if (d[nm] > val + inc) {\n                d[nm] = val + inc;\n                q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n              }\n            }\n          }\n        }\n        ql[dist % 3] = 0;\n      }\n      //res += d[0];\n      res = d[0];\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      // for (int nbits = 1; nbits <= 16; ++nbits) {\n      //     for (int m = 1; m < (1 << 16); ++m)\n      //         if (Integer.bitCount(m) == nbits) {\n      //             d[m] = 1000000;\n      //             for (int i = 0; i < 16; ++i)\n      //                 if ((m >> i) % 2 == 1) {\n      //                     {\n      //                         int nm = m ^ (1 << i);\n      //                         d[m] = Math.min(d[m], d[nm] + 1);\n      //                     }\n      //                     for (int j = i + 1; j < 16; ++j)\n      //                         if ((m >> j) % 2 == 1) {\n      //                             int k = (i ^ j);\n      //                             int inc = 1;\n      //                             int nm = m ^ (1 << i) ^ (1 << j);\n      //                             if ((nm >> k) % 2 == 1) {\n      //                                 ++inc;\n      //                             }\n      //                             nm ^= (1 << k);\n      //                             d[m] = Math.min(d[m], d[nm] + inc);\n      //                         }\n      //                 }\n      //         }\n      // }\n      // res += d[mask];\n      //     // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n      //     //     int tot = 0;\n      //     //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n      //     //         tot ^= i;\n      //     //     if (tot != 0) continue;\n      //     //     mask ^= m;\n      //     //     res += nbits - 1;\n      //     // }\n      // }\n\n      //res += Integer.bitCount(mask);\n      //res += (int) prio[0];\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n          }\n          ++a[val];\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n    int best;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      // int mask = 0;\n      // for (int i = 1; i < 16; ++i) {\n      //     mask |= ((a[i] % 2) << i);\n      //     res -= (a[i] % 2);\n      // }\n      best = 10000000;\n      //D = new HashMap<>();\n      go(a, 0);\n      res = best;\n\n      // Assert.assertTrue(res % 2 == 0);\n      // res /= 2;\n      //\n      // int[] d = new int[1 << 16];\n      // Arrays.fill(d, Integer.MAX_VALUE);\n      // d[mask] = 0;\n      // int[][] q = new int[GEN][(1 << 15) + 2];\n      // int[] ql = new int[GEN];\n      // q[0][ql[0]++] = mask;\n      // for (int dist = 0; dist < 30; ++dist) {\n      //     int[] curQ = q[dist % GEN];\n      //     int qr = 0;\n      //     while (ql[dist % GEN] > qr) {\n      //         int m = curQ[qr++];\n      //         int val = d[m];\n      //         for (int x = 1; x < 16; ++x) {\n      //             for (int i = 1; i < 16; ++i) if ((m >> i) % 2 == 1){\n      //                 {\n      //                     int nm = m ^ (1 << i);\n      //                     int inc = 1;\n      //                     int k = (i ^ x);\n      //                     if ((nm >> k) % 2 == 1) {\n      //                         ++inc;\n      //                     }\n      //                     if (k > 0) nm ^= (1 << k);\n      //                     if (d[nm] > val + inc) {\n      //                         d[nm] = val + inc;\n      //                         q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                     }\n      //                 }\n      //                 for (int j = i + 1; j < 16; ++j) {\n      //                     int inc = 1;\n      //                     int nm = m ^ (1 << i) ^ (1 << j);\n      //                     int ki = (i ^ x);\n      //                     if ((nm >> ki) % 2 == 1) {\n      //                         inc += 1;\n      //                     }\n      //                     if (ki > 0) nm ^= (1 << ki);\n      //                     int kj = (j ^ x);\n      //                     if ((nm >> kj) % 2 == 1) {\n      //                         inc += 1;\n      //                     }\n      //                     if (kj > 0) nm ^= (1 << kj);\n      //                     if (d[nm] > val + inc) {\n      //                         d[nm] = val + inc;\n      //                         q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                     }\n      //                 }\n      //             }\n      //         }\n      //     }\n      //     ql[dist % GEN] = 0;\n      // }\n      // res += d[0];\n\n      // ArrayList<DijkstraHeap.Edge>[] G = new ArrayList[1 << 16];\n      // for (int i = 0; i < G.length; ++i)\n      //     G[i] = new ArrayList<>();\n      // for (int m = 1; m < (1 << 16); ++m) {\n      //     for (int i = 0; i < 16; ++i) {\n      //         {\n      //             int nm = m ^ (1 << i);\n      //             G[m].add(new DijkstraHeap.Edge(nm, 1));\n      //         }\n      //         for (int j = i + 1; j < 16; ++j) {\n      //             int k = (i ^ j);\n      //             int inc = 1;\n      //             int nm = m ^ (1 << i) ^ (1 << j);\n      //             if ((nm >> k) % 2 == 1) {\n      //                 ++inc;\n      //             }\n      //             nm ^= (1 << k);\n      //             G[m].add(new DijkstraHeap.Edge(nm, (long) inc));\n      //         }\n      //     }\n      // }\n      // long[] prio = new long[G.length];\n      // int[] pred = new int[G.length];\n      // DijkstraHeap.shortestPaths(G, mask, prio, pred);\n\n      // int[] d = new int[1 << 16];\n      // Arrays.fill(d, Integer.MAX_VALUE);\n      // d[mask] = res;\n      // int[][] q = new int[GEN][(1 << 15) + 2];\n      // int[] ql = new int[GEN];\n      // q[0][ql[0]++] = mask;\n      // for (int dist = 0; dist < 100; ++dist) {\n      //     int[] curQ = q[dist % GEN];\n      //     int qr = 0;\n      //     while (ql[dist % GEN] > qr) {\n      //         int m = curQ[qr++];\n      //         int val = d[m];\n      //         for (int i = 1; i < 16; ++i) {\n      //             {\n      //                 int nm = m ^ (1 << i);\n      //                 int inc = 2;\n      //                 if ((m >> i) % 2 == 0 && a[i] >= 2) --inc;\n      //                 if (d[nm] > val + inc) {\n      //                     d[nm] = val + inc;\n      //                     q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                 }\n      //             }\n      //             for (int j = i + 1; j < 16; ++j) {\n      //                 int k = (i ^ j);\n      //                 int inc = 2;\n      //                 if ((m >> i) % 2 == 0 && a[i] >= 2) --inc;\n      //                 if ((m >> j) % 2 == 0 && a[j] >= 2) --inc;\n      //                 int nm = m ^ (1 << i) ^ (1 << j);\n      //                 if ((nm >> k) % 2 == 1) {\n      //                     inc += 2;\n      //                 }\n      //                 nm ^= (1 << k);\n      //                 if (d[nm] > val + inc) {\n      //                     d[nm] = val + inc;\n      //                     q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                 }\n      //             }\n      //         }\n      //     }\n      //     ql[dist % GEN] = 0;\n      // }\n      // //res += d[0];\n      // res = d[0];\n      // Assert.assertTrue(res % 2 == 0);\n      // res /= 2;\n\n      // for (int nbits = 1; nbits <= 16; ++nbits) {\n      //     for (int m = 1; m < (1 << 16); ++m)\n      //         if (Integer.bitCount(m) == nbits) {\n      //             d[m] = 1000000;\n      //             for (int i = 0; i < 16; ++i)\n      //                 if ((m >> i) % 2 == 1) {\n      //                     {\n      //                         int nm = m ^ (1 << i);\n      //                         d[m] = Math.min(d[m], d[nm] + 1);\n      //                     }\n      //                     for (int j = i + 1; j < 16; ++j)\n      //                         if ((m >> j) % 2 == 1) {\n      //                             int k = (i ^ j);\n      //                             int inc = 1;\n      //                             int nm = m ^ (1 << i) ^ (1 << j);\n      //                             if ((nm >> k) % 2 == 1) {\n      //                                 ++inc;\n      //                             }\n      //                             nm ^= (1 << k);\n      //                             d[m] = Math.min(d[m], d[nm] + inc);\n      //                         }\n      //                 }\n      //         }\n      // }\n      // res += d[mask];\n      //     // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n      //     //     int tot = 0;\n      //     //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n      //     //         tot ^= i;\n      //     //     if (tot != 0) continue;\n      //     //     mask ^= m;\n      //     //     res += nbits - 1;\n      //     // }\n      // }\n\n      //res += Integer.bitCount(mask);\n      //res += (int) prio[0];\n      out.printLine(res);\n    }\n\n    private void go(int[] a, int cnt) {\n      a[0] = 0;\n      int lo = cnt, hi = cnt;\n      for (int i = 1; i < 16; ++i) {\n        lo += a[i] / 2;\n        hi += (a[i] + 1) / 2;\n      }\n      if (hi < best) {\n        best = hi;\n      }\n      if (lo >= best) {\n        return;\n      }\n      //if (D.containsKey(a))\n      //    return;\n      for (int i = 1; i < 16; ++i) {\n        if (a[i] > 0) {\n          --a[i];\n          go(a, cnt + 1);\n          ++a[i];\n\n          for (int j = i + 1; j < 16; ++j) {\n            if (a[j] > 0) {\n              int k = (i ^ j);\n              --a[i];\n              --a[j];\n              if (k > 0) {\n                ++a[k];\n              }\n              go(a, cnt + 1);\n              ++a[i];\n              ++a[j];\n              if (k > 0) {\n                --a[k];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n          }\n          ++a[val];\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskF solver = new TaskF();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int[] xor = new int[n];\n            for (int i = 1; i < n; i++) {\n                int x = in.readInt();\n                int y = in.readInt();\n                int a = in.readInt();\n                xor[x] ^= a;\n                xor[y] ^= a;\n            }\n\n            int[] cnts = new int[16];\n            for (int i = 0; i < n; i++) {\n                cnts[xor[i]]++;\n            }\n\n            int cc = 0;\n            cc += cnts[0];\n            cnts[0] = 0;\n            for (int i = 1; i < 16; i++) {\n                cc += cnts[i] / 2;\n                cnts[i] %= 2;\n            }\n\n            BitOperator bo = new BitOperator();\n            SubsetGenerator sg = new SubsetGenerator();\n            int[] dp = new int[1 << 16];\n\n            int mask = 0;\n            for (int i = 0; i < 16; i++) {\n                if (cnts[i] == 1) {\n                    mask = bo.setBit(mask, i, true);\n                }\n            }\n\n            for (int i = 1; i < dp.length; i++) {\n                if (!bo.subset(i, mask)) {\n                    dp[i] = 0;\n                    continue;\n                }\n\n                int x = 0;\n                for (int j = 0; j < 16; j++) {\n                    if (bo.bitAt(i, j) == 1) {\n                        x ^= j;\n                    }\n                }\n                if (x != 0) {\n                    continue;\n                }\n                dp[i] = 1;\n                sg.setSet(i);\n                while (sg.hasNext()) {\n                    int next = sg.next();\n                    if (next == 0 || next == i) {\n                        continue;\n                    }\n                    dp[i] = Math.max(dp[i], dp[next] + dp[i - next]);\n                }\n            }\n\n            cc += dp[mask];\n            int edge = n - cc;\n            out.println(edge);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SubsetGenerator {\n        private int[] meanings = new int[33];\n        private int[] bits = new int[33];\n        private int remain;\n        private int next;\n\n        public void setSet(int set) {\n            int bitCount = 0;\n            while (set != 0) {\n                meanings[bitCount] = set & -set;\n                bits[bitCount] = 0;\n                set -= meanings[bitCount];\n                bitCount++;\n            }\n            remain = 1 << bitCount;\n            next = 0;\n        }\n\n        public boolean hasNext() {\n            return remain > 0;\n        }\n\n        private void consume() {\n            remain = remain - 1;\n            int i;\n            for (i = 0; bits[i] == 1; i++) {\n                bits[i] = 0;\n                next -= meanings[i];\n            }\n            bits[i] = 1;\n            next += meanings[i];\n        }\n\n        public int next() {\n            int returned = next;\n            consume();\n            return returned;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class BitOperator {\n        public int bitAt(int x, int i) {\n            return (x >> i) & 1;\n        }\n\n        public int setBit(int x, int i, boolean v) {\n            if (v) {\n                x |= 1 << i;\n            } else {\n                x &= ~(1 << i);\n            }\n            return x;\n        }\n\n        public boolean subset(long x, long y) {\n            return intersect(x, y) == x;\n        }\n\n        public long intersect(long x, long y) {\n            return x & y;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package agc.apc001;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[] xor = new int[n];\n        for (int i = 0; i < n-1 ; i++) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            int a = in.nextInt();\n            xor[x] ^= a;\n            xor[y] ^= a;\n        }\n        int[] px = new int[16];\n        for (int i = 0; i < n ; i++) {\n            px[xor[i]]++;\n        }\n\n        int cost = 0;\n        int left = 0;\n        for (int i = 1 ; i < px.length; i++) {\n            cost += px[i] / 2;\n            if (px[i] % 2 == 1) {\n                left ^= 1<<(i-1);\n            }\n        }\n\n        int[] dp = new int[1<<15];\n        Arrays.fill(dp, 127);\n        dp[left] = 0;\n\n        Queue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));\n        q.add(new int[]{0, left});\n        while (q.size() >= 1) {\n            int[] qt = q.poll();\n            int now = qt[1];\n            int time = qt[0];\n            if (dp[now] < time) {\n                continue;\n            }\n\n            for (int i = 0; i < 15; i++) {\n                if ((now & (1<<i)) == 0) {\n                    continue;\n                }\n                for (int j = i+1 ; j < 15; j++) {\n                    if ((now & (1<<j)) == 0) {\n                        continue;\n                    }\n                    for (int k = 1 ; k <= 15; k++) {\n                        int tc = time+1;\n                        int nw = now ^ (1<<i) ^ (1<<j);\n                        int ti = ((i+1) ^ k);\n                        int tj = ((j+1) ^ k);\n                        if (ti >= 1) {\n                            nw ^= (1<<(ti-1));\n                            if ((nw & (1<<(ti-1))) == 0) {\n                                tc++;\n                            }\n                        }\n                        if (tj >= 1) {\n                            nw ^= (1<<(tj-1));\n                            if ((nw & (1<<(tj-1))) == 0) {\n                                tc++;\n                            }\n                        }\n                        if (dp[nw] > tc) {\n                            dp[nw] = tc;\n                            q.add(new int[]{tc, nw});\n                        }\n                    }\n                }\n            }\n        }\n        out.println(cost + dp[0]);\n        out.flush();\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int[] b = new int[n];\n    for (int i = 0; i < n - 1; i++) {\n      int x = ni();\n      int y = ni();\n      int a = ni();\n      b[x] ^= a;\n      b[y] ^= a;\n    }\n\n    int bm = 15;\n    int[] cnt = new int[bm + 1];\n    for (int v : b) {\n      cnt[v]++;\n    }\n    cnt[0] = 0;\n    int ret = 0;\n    int s = 0;\n    int t = 0;\n    int f = 1;\n    for (int i = 1; i <= bm; i++) {\n      ret += cnt[i] / 2;\n      if (cnt[i] % 2 == 1) {\n        s++;\n        t += f * 2;\n      }\n      f *= 3;\n    }\n    int m = (int) Math.pow(3, bm);\n    int[] dp = new int[m];\n    Arrays.fill(dp, Integer.MIN_VALUE / 2);\n    dp[t] = 0;\n\n    for (int i = t; i >= 0; i--) {\n      int x = i;\n      int y = 0;\n      int h = 1;\n      int to = i;\n      for (int j = 0; j < bm; j++) {\n        int z = x % 3;\n        x /= 3;\n        if (z == 1) {\n          y ^= (j + 1);\n          to -= h;\n        } else if (z == 2) {\n          dp[i - h] = Math.max(dp[i - h], dp[i]);\n        }\n        h *= 3;\n      }\n      if (to < i && y == 0) {\n        dp[to] = Math.max(dp[to], dp[i] + 1);\n      }\n    }\n    System.out.println(s - dp[0] + ret);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    int n;\n    void solve(){\n        n = ni();\n        int[] b = new int[n];\n        for(int i = 0; i < n-1; i++){\n            int from = ni();\n            int to = ni();\n            int cost = ni();\n            b[from] ^= cost;\n            b[to] ^= cost;\n        }\n        int[] c = new int[16];\n        for(int i = 0; i < n; i++){\n            c[b[i]]++;\n        }\n        int ans = 0;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]>=2){\n                ans += c[i]/2;\n                c[i] = c[i]%2;\n            }\n        }\n        int[] res = new int[1<<16];\n        for(int i = 0; i < (1<<15); i++){\n            int tmp = 0;\n            int count = 0;\n            for(int j = 0; j < 15; j++){\n                if((i>>j)%2==1){\n                    tmp ^= (j+1);\n                    count++;\n                }\n            }\n            if(tmp==0){\n                res[i] = count>0 ? count-1 : 0;\n            }\n            else res[i] = -1;\n        }\n        int[] dp = new int[1<<15];\n        Arrays.fill(dp, 100000);\n        for(int i = 0; i < (1<<15); i++){\n            for(int j = i; j > 0 ; j = (j-1)&i){\n                int A = j;\n                int B = j^i;\n                if(res[A]>=0 && res[B]>=0) dp[i] = Math.min(dp[i], res[A]+res[B]);\n            }\n        }\n        int mask = 0;\n        int p = 1;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]==1) mask += p;\n            p *= 2;\n        }\n        out.println(dp[mask]+ans);\n\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    public static final int GEN = 6;\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 1; i < 16; ++i) {\n        mask |= ((a[i] % 2) << i);\n        res -= (a[i] % 2);\n      }\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      int[] d = new int[1 << 16];\n      Arrays.fill(d, Integer.MAX_VALUE);\n      d[mask] = 0;\n      int[][] q = new int[GEN][(1 << 15) + 2];\n      int[] ql = new int[GEN];\n      q[0][ql[0]++] = mask;\n      for (int dist = 0; dist < 30; ++dist) {\n        int[] curQ = q[dist % GEN];\n        int qr = 0;\n        while (ql[dist % GEN] > qr) {\n          int m = curQ[qr++];\n          int val = d[m];\n          for (int x = 1; x < 16; ++x) {\n            for (int i = 1; i < 16; ++i) {\n              if ((m >> i) % 2 == 1) {\n                {\n                  int nm = m ^ (1 << i);\n                  int inc = 1;\n                  int k = (i ^ x);\n                  if ((nm >> k) % 2 == 1) {\n                    ++inc;\n                  }\n                  if (k > 0) {\n                    nm ^= (1 << k);\n                  }\n                  if (d[nm] > val + inc) {\n                    d[nm] = val + inc;\n                    q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n                  }\n                }\n                for (int j = i + 1; j < 16; ++j) {\n                  int inc = 1;\n                  int nm = m ^ (1 << i) ^ (1 << j);\n                  int ki = (i ^ x);\n                  if ((nm >> ki) % 2 == 1) {\n                    inc += 1;\n                  }\n                  if (ki > 0) {\n                    nm ^= (1 << ki);\n                  }\n                  int kj = (j ^ x);\n                  if ((nm >> kj) % 2 == 1) {\n                    inc += 1;\n                  }\n                  if (kj > 0) {\n                    nm ^= (1 << kj);\n                  }\n                  if (d[nm] > val + inc) {\n                    d[nm] = val + inc;\n                    q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n                  }\n                }\n              }\n            }\n          }\n        }\n        ql[dist % GEN] = 0;\n      }\n      res += d[0];\n\n      // ArrayList<DijkstraHeap.Edge>[] G = new ArrayList[1 << 16];\n      // for (int i = 0; i < G.length; ++i)\n      //     G[i] = new ArrayList<>();\n      // for (int m = 1; m < (1 << 16); ++m) {\n      //     for (int i = 0; i < 16; ++i) {\n      //         {\n      //             int nm = m ^ (1 << i);\n      //             G[m].add(new DijkstraHeap.Edge(nm, 1));\n      //         }\n      //         for (int j = i + 1; j < 16; ++j) {\n      //             int k = (i ^ j);\n      //             int inc = 1;\n      //             int nm = m ^ (1 << i) ^ (1 << j);\n      //             if ((nm >> k) % 2 == 1) {\n      //                 ++inc;\n      //             }\n      //             nm ^= (1 << k);\n      //             G[m].add(new DijkstraHeap.Edge(nm, (long) inc));\n      //         }\n      //     }\n      // }\n      // long[] prio = new long[G.length];\n      // int[] pred = new int[G.length];\n      // DijkstraHeap.shortestPaths(G, mask, prio, pred);\n\n      // int[] d = new int[1 << 16];\n      // Arrays.fill(d, Integer.MAX_VALUE);\n      // d[mask] = res;\n      // int[][] q = new int[GEN][(1 << 15) + 2];\n      // int[] ql = new int[GEN];\n      // q[0][ql[0]++] = mask;\n      // for (int dist = 0; dist < 100; ++dist) {\n      //     int[] curQ = q[dist % GEN];\n      //     int qr = 0;\n      //     while (ql[dist % GEN] > qr) {\n      //         int m = curQ[qr++];\n      //         int val = d[m];\n      //         for (int i = 1; i < 16; ++i) {\n      //             {\n      //                 int nm = m ^ (1 << i);\n      //                 int inc = 2;\n      //                 if ((m >> i) % 2 == 0 && a[i] >= 2) --inc;\n      //                 if (d[nm] > val + inc) {\n      //                     d[nm] = val + inc;\n      //                     q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                 }\n      //             }\n      //             for (int j = i + 1; j < 16; ++j) {\n      //                 int k = (i ^ j);\n      //                 int inc = 2;\n      //                 if ((m >> i) % 2 == 0 && a[i] >= 2) --inc;\n      //                 if ((m >> j) % 2 == 0 && a[j] >= 2) --inc;\n      //                 int nm = m ^ (1 << i) ^ (1 << j);\n      //                 if ((nm >> k) % 2 == 1) {\n      //                     inc += 2;\n      //                 }\n      //                 nm ^= (1 << k);\n      //                 if (d[nm] > val + inc) {\n      //                     d[nm] = val + inc;\n      //                     q[(dist + inc) % GEN][ql[(dist + inc) % GEN]++] = nm;\n      //                 }\n      //             }\n      //         }\n      //     }\n      //     ql[dist % GEN] = 0;\n      // }\n      // //res += d[0];\n      // res = d[0];\n      // Assert.assertTrue(res % 2 == 0);\n      // res /= 2;\n\n      // for (int nbits = 1; nbits <= 16; ++nbits) {\n      //     for (int m = 1; m < (1 << 16); ++m)\n      //         if (Integer.bitCount(m) == nbits) {\n      //             d[m] = 1000000;\n      //             for (int i = 0; i < 16; ++i)\n      //                 if ((m >> i) % 2 == 1) {\n      //                     {\n      //                         int nm = m ^ (1 << i);\n      //                         d[m] = Math.min(d[m], d[nm] + 1);\n      //                     }\n      //                     for (int j = i + 1; j < 16; ++j)\n      //                         if ((m >> j) % 2 == 1) {\n      //                             int k = (i ^ j);\n      //                             int inc = 1;\n      //                             int nm = m ^ (1 << i) ^ (1 << j);\n      //                             if ((nm >> k) % 2 == 1) {\n      //                                 ++inc;\n      //                             }\n      //                             nm ^= (1 << k);\n      //                             d[m] = Math.min(d[m], d[nm] + inc);\n      //                         }\n      //                 }\n      //         }\n      // }\n      // res += d[mask];\n      //     // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n      //     //     int tot = 0;\n      //     //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n      //     //         tot ^= i;\n      //     //     if (tot != 0) continue;\n      //     //     mask ^= m;\n      //     //     res += nbits - 1;\n      //     // }\n      // }\n\n      //res += Integer.bitCount(mask);\n      //res += (int) prio[0];\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n          }\n          ++a[val];\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int bit[] = new int[N];\n        for(int i=0;i<N-1;++i){\n            int x = scan.nextInt();\n            int y = scan.nextInt();\n            int a = scan.nextInt();\n            bit[x]^=a;\n            bit[y]^=a;\n        }\n        int count[] = new int[1<<4];\n        for(int i=0;i<N;++i)count[bit[i]]++;\n        int ans =0;\n        for(int i=1;i<(1<<4);++i){\n            ans+=count[i]/2;\n            count[i]%=2;\n        }\n        int num=0;\n        for(int i=1;i<(1<<4);++i){\n            if(count[i]>0){\n                num^=i;\n                count[i]--;\n                if(num==i)continue;\n                ++ans;\n                if(count[num]>0){\n                    ++ans;\n                    num=0;\n                    count[num]--;\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 0; i < 16; ++i) {\n        mask |= (a[i] << i);\n        res -= a[i];\n      }\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      // ArrayList<DijkstraHeap.Edge>[] G = new ArrayList[1 << 16];\n      // for (int i = 0; i < G.length; ++i)\n      //     G[i] = new ArrayList<>();\n      // for (int m = 1; m < (1 << 16); ++m) {\n      //     for (int i = 0; i < 16; ++i) {\n      //         {\n      //             int nm = m ^ (1 << i);\n      //             G[m].add(new DijkstraHeap.Edge(nm, 1));\n      //         }\n      //         for (int j = i + 1; j < 16; ++j) {\n      //             int k = (i ^ j);\n      //             int inc = 1;\n      //             int nm = m ^ (1 << i) ^ (1 << j);\n      //             if ((nm >> k) % 2 == 1) {\n      //                 ++inc;\n      //             }\n      //             nm ^= (1 << k);\n      //             G[m].add(new DijkstraHeap.Edge(nm, (long) inc));\n      //         }\n      //     }\n      // }\n      // long[] prio = new long[G.length];\n      // int[] pred = new int[G.length];\n      // DijkstraHeap.shortestPaths(G, mask, prio, pred);\n\n      int[] d = new int[1 << 16];\n      Arrays.fill(d, Integer.MAX_VALUE);\n      d[mask] = 0;\n      int[][] q = new int[3][(1 << 15) + 2];\n      int[] ql = new int[3];\n      q[0][ql[0]++] = mask;\n      for (int dist = 0; dist < 100; ++dist) {\n        int[] curQ = q[dist % 3];\n        int curL = ql[dist % 3];\n        int[] nextQ = q[(dist + 1) % 3];\n        //ql[(dist + 1) % 3] = 0;\n        int[] nnextQ = q[(dist + 2) % 3];\n        //ql[(dist + 2) % 3] = 0;\n        int qr = 0;\n        while (curL > qr) {\n          int m = curQ[qr++];\n          int val = d[m];\n          for (int i = 1; i < 16; ++i) {\n            {\n              int nm = m ^ (1 << i);\n              if (d[nm] > val + 1) {\n                d[nm] = val + 1;\n                nextQ[ql[(dist + 1) % 3]++] = nm;\n              }\n            }\n            for (int j = i + 1; j < 16; ++j) {\n              int k = (i ^ j);\n              int inc = 1;\n              int nm = m ^ (1 << i) ^ (1 << j);\n              if ((nm >> k) % 2 == 1) {\n                ++inc;\n              }\n              nm ^= (1 << k);\n              if (d[nm] > val + inc) {\n                d[nm] = val + inc;\n                if (inc == 1) {\n                  nextQ[ql[(dist + inc) % 3]++] = nm;\n                } else {\n                  nnextQ[ql[(dist + inc) % 3]++] = nm;\n                }\n              }\n            }\n          }\n        }\n        ql[dist % 3] = 0;\n      }\n      res += d[0];\n\n      // for (int nbits = 1; nbits <= 16; ++nbits) {\n      //     for (int m = 1; m < (1 << 16); ++m)\n      //         if (Integer.bitCount(m) == nbits) {\n      //             d[m] = 1000000;\n      //             for (int i = 0; i < 16; ++i)\n      //                 if ((m >> i) % 2 == 1) {\n      //                     {\n      //                         int nm = m ^ (1 << i);\n      //                         d[m] = Math.min(d[m], d[nm] + 1);\n      //                     }\n      //                     for (int j = i + 1; j < 16; ++j)\n      //                         if ((m >> j) % 2 == 1) {\n      //                             int k = (i ^ j);\n      //                             int inc = 1;\n      //                             int nm = m ^ (1 << i) ^ (1 << j);\n      //                             if ((nm >> k) % 2 == 1) {\n      //                                 ++inc;\n      //                             }\n      //                             nm ^= (1 << k);\n      //                             d[m] = Math.min(d[m], d[nm] + inc);\n      //                         }\n      //                 }\n      //         }\n      // }\n      // res += d[mask];\n      //     // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n      //     //     int tot = 0;\n      //     //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n      //     //         tot ^= i;\n      //     //     if (tot != 0) continue;\n      //     //     mask ^= m;\n      //     //     res += nbits - 1;\n      //     // }\n      // }\n\n      //res += Integer.bitCount(mask);\n      //res += (int) prio[0];\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n            a[val] ^= 1;\n          }\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1, 0);\n      int mask = 0;\n      for (int i = 0; i < 16; ++i) {\n        mask |= (a[i] << i);\n        res -= a[i];\n      }\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      for (int nbits = 1; nbits <= 16; ++nbits) {\n        for (int m = 1; m < (1 << 16); ++m) {\n          if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n            int tot = 0;\n            for (int i = 0; i < 16; ++i) {\n              if ((m >> i) % 2 == 1) {\n                tot ^= i;\n              }\n            }\n            if (tot != 0) {\n              continue;\n            }\n            mask ^= m;\n            res += nbits - 1;\n          }\n        }\n      }\n\n      res += Integer.bitCount(mask);\n      out.printLine(res);\n    }\n\n    private void dfs(int x, int p, int mask) {\n      if (mask != 0) {\n        a[mask] ^= 1;\n        ++res;\n      }\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          dfs(e.first, x, mask ^ e.second);\n        }\n      }\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    ArrayList<ii>[] g;\n    int[] a;\n    int[] d;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 0; i < 16; ++i) {\n        mask |= (a[i] << i);\n        res -= a[i];\n      }\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      d = new int[1 << 16];\n      for (int nbits = 1; nbits <= 16; ++nbits) {\n        for (int m = 1; m < (1 << 16); ++m) {\n          if (Integer.bitCount(m) == nbits) {\n            d[m] = 1000000;\n            for (int i = 0; i < 16; ++i) {\n              if ((m >> i) % 2 == 1) {\n                {\n                  int nm = m ^ (1 << i);\n                  d[m] = Math.min(d[m], d[nm] + 1);\n                }\n                for (int j = i + 1; j < 16; ++j) {\n                  if ((m >> j) % 2 == 1) {\n                    int k = (i ^ j);\n                    int inc = 1;\n                    int nm = m ^ (1 << i) ^ (1 << j);\n                    if ((nm >> k) % 2 == 1) {\n                      ++inc;\n                    }\n                    nm ^= (1 << k);\n                    d[m] = Math.min(d[m], d[nm] + inc);\n                  }\n                }\n              }\n            }\n          }\n        }\n        // for (int m = 1; m < (1 << 16); ++m) if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n        //     int tot = 0;\n        //     for (int i = 0; i < 16; ++i) if ((m >> i) % 2 == 1)\n        //         tot ^= i;\n        //     if (tot != 0) continue;\n        //     mask ^= m;\n        //     res += nbits - 1;\n        // }\n      }\n\n      //res += Integer.bitCount(mask);\n      res += d[mask];\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n            a[val] ^= 1;\n          }\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    int n;\n    void solve(){\n        n = ni();\n        int[] b = new int[n];\n        for(int i = 0; i < n-1; i++){\n            int from = ni();\n            int to = ni();\n            int cost = ni();\n            b[from] ^= cost;\n            b[to] ^= cost;\n        }\n        int[] c = new int[16];\n        for(int i = 0; i < n; i++){\n            c[b[i]]++;\n        }\n        int ans = 0;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]>=2){\n                ans += c[i]/2;\n                c[i] = c[i]%2;\n            }\n        }\n        int[] res = new int[1<<16];\n        for(int i = 0; i < (1<<15); i++){\n            int tmp = 0;\n            int count = 0;\n            for(int j = 0; j < 15; j++){\n                if((i>>j)%2==1){\n                    tmp ^= (j+1);\n                    count++;\n                }\n            }\n            if(tmp==0){\n                res[i] = count;\n            }\n            else res[i] = -1;\n        }\n        int[] dp = new int[1<<15];\n        Arrays.fill(dp, 100000);\n        for(int i = 0; i < (1<<15); i++){\n            for(int j = i; j > 0 ; j = (j-1)&i){\n                int A = j;\n                int B = j^i;\n                if(res[A]>=0) dp[A] = Math.min(dp[A], res[A]);\n                if(res[B]>=0) dp[B] = Math.min(dp[B], res[B]);\n                // out.println(a+\" \"+b2+\" \"+resa);\n            }\n        }\n        int mask = 0;\n        int p = 1;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]==1) mask += p;\n            p *= 2;\n        }\n        // out.println(mask);\n        out.println(dp[mask]);\n\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class F {\n\n\tclass Edge {\n\t\tint from, to, mark;\n\n\t\tpublic Edge(int from, int to, int mark) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.mark = mark;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", mark=\" + mark + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tList<Edge>[] graph;\n\t\n\tint dfs(int u, int p) {\n\t\tint xor = 0;\n\t\tfor (int t = 0; t < graph[u].size(); t++) {\n\t\t\tEdge e = graph[u].get(t);\n\t\t\tint to = u ^ e.from ^ e.to;\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te.mark ^= dfs(to, u);\n\t\t\txor ^= e.mark;\n\t\t}\n\t\treturn xor;\n\t}\n\t\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tgraph = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\t\t\n\t\tEdge[] e = new Edge[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\te[i] = new Edge(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tgraph[e[i].from].add(e[i]);\n\t\t\tgraph[e[i].to].add(e[i]);\n\t\t}\n\t\tdfs(0, -1);\n\t\tint allMask = 0;\n\t\tint result = 0;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint bit = e[i].mark;\n\t\t\tif (bit == 0) {\n\t\t\t\tresult++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((allMask & (1 << bit)) != 0) {\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tallMask ^= 1 << bit;\n\t\t}\n\t\tint[] xor = new int[1 << 16];\n\t\tfor (int i =0 ; i < 1 << 16; i++) {\n\t\t\tfor (int j = 0; j < 16; j++ ) {\n\t\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\t\txor[i] ^= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[1 << 16];\n\t\tfor (int mask = 1; mask < 1 << 16; mask++) {\n\t\t\tfor (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\t\t\tif (xor[submask] == 0) {\n\t\t\t\t\tdp[mask] = Math.max(dp[mask], dp[mask ^ submask] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println((n - 1) - (dp[allMask] + result));\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew F().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tint[][] g;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tg = new int[n][];\n\t\tint[] a = new int[3 * n - 3];\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[3 * i] = nextInt();\n\t\t\ta[3 * i + 1] = nextInt();\n\t\t\ta[3 * i + 2] = nextInt();\n\t\t\tdeg[a[3 * i]]++;\n\t\t\tdeg[a[3 * i + 1]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new int[2 * deg[i]];\n\t\t}\n\n\t\tfor (int i = 0; i < 3 * n - 3; i += 3) {\n\t\t\tint v = a[i];\n\t\t\tint u = a[i + 1];\n\t\t\tint lbl = a[i + 2];\n\t\t\t--deg[v];\n\t\t\tg[v][2 * deg[v]] = u;\n\t\t\tg[v][2 * deg[v] + 1] = lbl;\n\t\t\t--deg[u];\n\t\t\tg[u][2 * deg[u]] = v;\n\t\t\tg[u][2 * deg[u] + 1] = lbl;\n\t\t}\n\t\t\n\t\tdfs(0, -1);\n\t\t\n\t\tint groups = 0;\n\t\tgroups += cnt[0];\n\t\tcnt[0] = 0;\n\t\tfor (int i = 1; i < 16; i++) {\n\t\t\tgroups += cnt[i] / 2;\n\t\t\tcnt[i] %= 2;\n\t\t}\n\t\t\n\t\tgroups += go(cnt);\n\t\tout.println(n - 1 - groups);\n\t}\n\t\n\tint go(int[] arr) {\n\t\tint[] xor = new int[1 << 15];\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\txor[1 << i] = i + 1;\n\t\t}\n\t\tfor (int i = 1; i < xor.length; i++) {\n\t\t\tint low = i & -i;\n\t\t\txor[i] = xor[low] ^ xor[i ^ low];\n\t\t}\n\t\t\n\t\tint[] dp = new int[1 << 15];\n\t\tdp[0] = 0;\n\t\tfor (int mask = 1; mask < 1 << 15; mask++) {\n\t\t\tfor (int sub = mask; sub > 0; sub = (sub - 1) & mask) {\n\t\t\t\tdp[mask] = Math.max(dp[mask], dp[mask ^ sub] + (xor[sub] == 0 ? 1 : 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint look = 0;\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\tif (cnt[i + 1] > 0) {\n\t\t\t\tlook |= 1 << i;\n\t\t\t}\n\t\t}\n\t\treturn dp[look];\n\t}\n\t\n\tint[] cnt = new int[16];\n\t\n\tint dfs(int v, int p) {\n\t\tint up = 0;\n\t\tint allChild = 0;\n\t\tfor (int i = 0; i < g[v].length; i += 2) {\n\t\t\tint u = g[v][i];\n\t\t\tint x = g[v][i + 1];\n\t\t\tif (u == p) {\n\t\t\t\tup = x;\n\t\t\t} else {\n\t\t\t\tallChild ^= dfs(u, v);\n\t\t\t}\n\t\t}\n\t\tif (p != -1) {\n//\t\t\tSystem.err.println(ret);\n\t\t\tcnt[up ^ allChild]++;\n\t\t}\n\t\treturn up;\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static int n;\n    static ArrayList<Integer>[][] g;\n    static ArrayList<Integer>[][] rg;\n    static ArrayList<Integer>[] vs;\n    static boolean[] used;\n    static int[][] cmp;\n    static int[][] cmpcnt;\n    static int ov2cnt;\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        n = sc.nextInt();\n        \n        g = new ArrayList[4][n];\n        rg = new ArrayList[4][n];\n        vs = new ArrayList[4];\n        for(int i=0; i<4; i++){\n            for(int j=0; j<n; j++){\n                g[i][j] = new ArrayList<Integer>();\n                rg[i][j] = new ArrayList<Integer>();\n            }\n            vs[i] = new ArrayList<Integer>();\n        }\n        \n        used = new boolean[n];\n        cmp = new int[4][n];\n        cmpcnt = new int[4][n];\n        \n        for(int i=0; i<n-1; i++){\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int a = sc.nextInt();\n            \n            int max = Math.max(x,y);\n            int min = Math.min(x,y);\n            \n            for(int j=0; j<4; j++){\n                addEdgeBit(min, max, j);\n                if(((a >> j) & 1)==1){\n                    addEdgeBit(max, min, j);\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<4; i++){\n            scc(i);\n            //System.out.println(ov2cnt);\n            ans += ov2cnt;\n        }\n        \n        System.out.println(ans);\n    }\n    \n    public static int scc(int bit){\n        usedReset();\n        for(int i=0; i<n; i++){\n            if(!used[i]){\n                dfs(i, bit);\n            }\n        }\n        \n        ov2cnt = 0;\n        \n        int k =0;\n        usedReset();\n        for(int i=n-1; i>=0; i--){\n            if(!used[vs[bit].get(i)]) rdfs(vs[bit].get(i), k++, bit);\n        }\n        \n        return k;\n    }\n    \n    \n    public static void usedReset(){\n        Arrays.fill(used, false);\n    }\n    \n    public static void addEdgeBit(int from, int to, int bit){\n        g[bit][from].add(to);\n        rg[bit][to].add(from);\n    }\n    \n    public static void dfs(int v, int bit){\n        used[v] = true;\n        for(int i=0; i<g[bit][v].size(); i++){\n            if(!used[g[bit][v].get(i)]) dfs(g[bit][v].get(i), bit);\n        }\n        vs[bit].add(v);\n    }\n    \n    public static void rdfs(int v, int k, int bit){\n        used[v] = true;\n        cmp[bit][v] = k;\n        cmpcnt[bit][k]++;\n        if(cmpcnt[bit][k]==2){\n            ov2cnt++;\n        }\n        for(int i=0; i<rg[bit][v].size(); i++){\n            if(!used[rg[bit][v].get(i)]) rdfs(rg[bit][v].get(i), k, bit);\n        }\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tint[][] g;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tg = new int[n][];\n\t\tint[] a = new int[3 * n - 3];\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[3 * i] = nextInt();\n\t\t\ta[3 * i + 1] = nextInt();\n\t\t\ta[3 * i + 2] = nextInt();\n\t\t\tdeg[a[3 * i]]++;\n\t\t\tdeg[a[3 * i + 1]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new int[2 * deg[i]];\n\t\t}\n\n\t\tfor (int i = 0; i < 3 * n - 3; i += 3) {\n\t\t\tint v = a[i];\n\t\t\tint u = a[i + 1];\n\t\t\tint lbl = a[i + 2];\n\t\t\t--deg[v];\n\t\t\tg[v][2 * deg[v]] = u;\n\t\t\tg[v][2 * deg[v] + 1] = lbl;\n\t\t\t--deg[u];\n\t\t\tg[u][2 * deg[u]] = v;\n\t\t\tg[u][2 * deg[u] + 1] = lbl;\n\t\t}\n\t\t\n\t\tdfs(0, -1);\n\t\t\n\t\tint groups = 0;\n\t\tgroups += cnt[0];\n\t\tcnt[0] = 0;\n\t\tfor (int i = 1; i < 16; i++) {\n\t\t\tgroups += cnt[i] / 2;\n\t\t\tcnt[i] %= 2;\n\t\t}\n\t\t\n\t\tgroups += go(cnt);\n\t\tout.println(n - 1 - groups);\n\t}\n\t\n\tint go(int[] arr) {\n\t\tint[] xor = new int[1 << 15];\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\txor[1 << i] = i + 1;\n\t\t}\n\t\tfor (int i = 1; i < xor.length; i++) {\n\t\t\tint low = i & -i;\n\t\t\txor[i] = xor[low] ^ xor[i ^ low];\n\t\t}\n\t\t\n\t\tint[] dp = new int[1 << 15];\n\t\tdp[0] = 0;\n\t\tfor (int mask = 1; mask < 1 << 15; mask++) {\n\t\t\tfor (int sub = mask; sub > 0; sub = (sub - 1) & mask) {\n\t\t\t\tdp[mask] = Math.max(dp[mask], dp[mask ^ sub] + (xor[sub] == 0 ? 1 : 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint look = 0;\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\tif (cnt[i + 1] > 0) {\n\t\t\t\tlook |= 1 << i;\n\t\t\t}\n\t\t}\n\t\treturn dp[look];\n\t}\n\t\n\tint[] cnt = new int[16];\n\t\n\tint dfs(int v, int p) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < g[v].length; i += 2) {\n\t\t\tint u = g[v][i];\n\t\t\tint x = g[v][i + 1];\n\t\t\tif (u == p) {\n\t\t\t\tret ^= x;\n\t\t\t} else {\n\t\t\t\tret ^= dfs(u, v);\n\t\t\t}\n\t\t}\n\t\tif (p != -1) {\n//\t\t\tSystem.err.println(ret);\n\t\t\tcnt[ret]++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tclass Edge {\n\t\tint from, to, mark;\n\n\t\tpublic Edge(int from, int to, int mark) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.mark = mark;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", mark=\" + mark + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tList<Edge>[] graph;\n\t\n\tint dfs(int u, int p) {\n\t\tint xor = 0;\n\t\tfor (int t = 0; t < graph[u].size(); t++) {\n\t\t\tEdge e = graph[u].get(t);\n\t\t\tint to = u ^ e.from ^ e.to;\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te.mark ^= dfs(to, u);\n\t\t\txor ^= e.mark;\n\t\t}\n\t\treturn xor;\n\t}\n\t\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tgraph = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\t\t\n\t\tEdge[] e = new Edge[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\te[i] = new Edge(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tgraph[e[i].from].add(e[i]);\n\t\t\tgraph[e[i].to].add(e[i]);\n\t\t}\n\t\tdfs(0, -1);\n\t\tint allMask = 0;\n\t\tint result = 0;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint bit = e[i].mark;\n\t\t\tif (bit == 0) {\n\t\t\t\tresult++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((allMask & (1 << bit)) != 0) {\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tallMask ^= 1 << bit;\n\t\t}\n\t\tint[] xor = new int[1 << 16];\n\t\tfor (int i =0 ; i < 1 << 16; i++) {\n\t\t\tfor (int j = 0; j < 16; j++ ) {\n\t\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\t\txor[i] ^= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[1 << 16];\n\t\tfor (int mask = 1; mask < 1 << 16; mask++) {\n\t\t\tfor (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\t\t\tif (xor[submask] == 0) {\n\t\t\t\t\tdp[mask] = Math.max(dp[mask], dp[mask ^ submask] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println((n - 1) - (dp[allMask] + result));\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    int n;\n    void solve(){\n        n = ni();\n        int[] b = new int[n];\n        for(int i = 0; i < n-1; i++){\n            int from = ni();\n            int to = ni();\n            int cost = ni();\n            b[from] ^= cost;\n            b[to] ^= cost;\n        }\n        int[] c = new int[16];\n        for(int i = 0; i < n; i++){\n            c[b[i]]++;\n        }\n        int ans = 0;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]>=2){\n                ans += c[i]/2;\n                c[i] = c[i]%2;\n            }\n        }\n        int[] res = new int[1<<16];\n        for(int i = 0; i < (1<<15); i++){\n            int tmp = 0;\n            int count = 0;\n            for(int j = 0; j < 15; j++){\n                if((i>>j)%2==1){\n                    tmp ^= (j+1);\n                    count++;\n                }\n            }\n            if(tmp==0){\n                res[i] = count>0 ? count-1 : 0;\n            }\n            else res[i] = -1;\n        }\n        int[] dp = new int[1<<15];\n        Arrays.fill(dp, 100000);\n        for(int i = 0; i < (1<<15); i++){\n            for(int j = i; j > 0 ; j = (j-1)&i){\n                int A = j;\n                int B = j^i;\n                if(res[A]>=0) dp[A] = Math.min(dp[A], res[A]);\n                if(res[B]>=0) dp[B] = Math.min(dp[B], res[B]);\n                // out.println(a+\" \"+b2+\" \"+resa);\n            }\n        }\n        int mask = 0;\n        int p = 1;\n        for(int i = 1; i <= 15; i++){\n            if(c[i]==1) mask += p;\n            p *= 2;\n        }\n        out.println(dp[mask]+ans);\n\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    ArrayList<ii>[] g;\n    int[] a;\n    int res;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      g = new ArrayList[n];\n      for (int i = 0; i < n; ++i) {\n        g[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n - 1; ++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int c = in.nextInt();\n        g[x].add(new ii(y, c));\n        g[y].add(new ii(x, c));\n      }\n      a = new int[16];\n      res = 0;\n      dfs(0, -1);\n      int mask = 0;\n      for (int i = 0; i < 16; ++i) {\n        mask |= (a[i] << i);\n        res -= a[i];\n      }\n      Assert.assertTrue(res % 2 == 0);\n      res /= 2;\n\n      for (int nbits = 1; nbits <= 16; ++nbits) {\n        for (int m = 1; m < (1 << 16); ++m) {\n          if ((m & mask) == m && Integer.bitCount(m) == nbits) {\n            int tot = 0;\n            for (int i = 0; i < 16; ++i) {\n              if ((m >> i) % 2 == 1) {\n                tot ^= i;\n              }\n            }\n            if (tot != 0) {\n              continue;\n            }\n            mask ^= m;\n            res += nbits - 1;\n          }\n        }\n      }\n\n      res += Integer.bitCount(mask);\n      out.printLine(res);\n    }\n\n    private int dfs(int x, int p) {\n      int mask = 0;\n      for (ii e : g[x]) {\n        if (e.first != p) {\n          int val = dfs(e.first, x);\n          val ^= e.second;\n          if (val != 0) {\n            ++res;\n            a[val] ^= 1;\n          }\n          mask ^= val;\n        }\n      }\n      return mask;\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class ii implements Comparable<ii> {\n\n    public int first;\n    public int second;\n\n    public ii() {\n    }\n\n    public ii(int first, int second) {\n      this.first = first;\n      this.second = second;\n    }\n\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      ii ii = (ii) o;\n\n      if (first != ii.first) {\n        return false;\n      }\n      if (second != ii.second) {\n        return false;\n      }\n\n      return true;\n    }\n\n    public int hashCode() {\n      int result = first;\n      result = 31 * result + second;\n      return result;\n    }\n\n    public int compareTo(ii o) {\n      if (first != o.first) {\n        return first < o.first ? -1 : 1;\n      }\n      if (second != o.second) {\n        return second < o.second ? -1 : 1;\n      }\n      return 0;\n    }\n\n\n    public String toString() {\n      return \"{\" +\n          \"first=\" + first +\n          \", second=\" + second +\n          '}';\n    }\n\n  }\n\n  static class Assert {\n\n    public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n      if (!flag) {\n        throw new AssertionError();\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tint[][] g;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tg = new int[n][];\n\t\tint[] a = new int[3 * n - 3];\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[3 * i] = nextInt();\n\t\t\ta[3 * i + 1] = nextInt();\n\t\t\ta[3 * i + 2] = nextInt();\n\t\t\tdeg[a[3 * i]]++;\n\t\t\tdeg[a[3 * i + 1]]++;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new int[2 * deg[i]];\n\t\t}\n\n\t\tfor (int i = 0; i < 3 * n - 3; i += 3) {\n\t\t\tint v = a[i];\n\t\t\tint u = a[i + 1];\n\t\t\tint lbl = a[i + 2];\n\t\t\t--deg[v];\n\t\t\tg[v][2 * deg[v]] = u;\n\t\t\tg[v][2 * deg[v] + 1] = lbl;\n\t\t\t--deg[u];\n\t\t\tg[u][2 * deg[u]] = v;\n\t\t\tg[u][2 * deg[u] + 1] = lbl;\n\t\t}\n\t\t\n\t\tdfs(3, -1);\n\t\t\n\t\tint groups = 0;\n\t\tgroups += cnt[0];\n\t\tcnt[0] = 0;\n\t\tfor (int i = 1; i < 16; i++) {\n\t\t\tgroups += cnt[i] / 2;\n\t\t\tcnt[i] %= 2;\n\t\t}\n\t\t\n\t\tgroups += go(cnt);\n\t\tout.println(n - 1 - groups);\n\t}\n\t\n\tint go(int[] arr) {\n\t\tint[] xor = new int[1 << 15];\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\txor[1 << i] = i + 1;\n\t\t}\n\t\tfor (int i = 1; i < xor.length; i++) {\n\t\t\tint low = i & -i;\n\t\t\txor[i] = xor[low] ^ xor[i ^ low];\n\t\t}\n\t\t\n\t\tint[] dp = new int[1 << 15];\n\t\tdp[0] = 0;\n\t\tfor (int mask = 1; mask < 1 << 15; mask++) {\n\t\t\tfor (int sub = mask; sub > 0; sub = (sub - 1) & mask) {\n\t\t\t\tdp[mask] = Math.max(dp[mask], dp[mask ^ sub] + (xor[sub] == 0 ? 1 : 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint look = 0;\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\tif (cnt[i + 1] > 0) {\n\t\t\t\tlook |= 1 << i;\n\t\t\t}\n\t\t}\n\t\treturn dp[look];\n\t}\n\t\n\tint[] cnt = new int[16];\n\t\n\tint dfs(int v, int p) {\n\t\tint up = 0;\n\t\tint allChild = 0;\n\t\tfor (int i = 0; i < g[v].length; i += 2) {\n\t\t\tint u = g[v][i];\n\t\t\tint x = g[v][i + 1];\n\t\t\tif (u == p) {\n\t\t\t\tup = x;\n\t\t\t} else {\n\t\t\t\tallChild ^= dfs(u, v);\n\t\t\t}\n\t\t}\n\t\tif (p != -1) {\n//\t\t\tSystem.err.println(ret);\n\t\t\tcnt[up ^ allChild]++;\n\t\t}\n\t\treturn up;\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n - 1; ++i) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                int v = in.nextInt();\n                a[x] ^= v;\n                a[y] ^= v;\n            }\n            int[] cnt = new int[16];\n            for (int x : a) if (x > 0) ++cnt[x];\n            int res = 0;\n            for (int i = 0; i < cnt.length; ++i) {\n                res += cnt[i] / 2;\n                cnt[i] %= 2;\n            }\n            int[] dist = new int[1 << 16];\n            Arrays.fill(dist, (int) 1e9);\n            int[] q = new int[1 << 20];\n            int qt = 0;\n            int qh = 1;\n            q[0] = 0;\n            dist[0] = 0;\n            while (qt < qh) {\n                int src = q[qt++];\n                for (int v = 1; v < 16; ++v) {\n                    for (int x = 1; x < 16; ++x) {\n                        for (int y = 1; y < 16; ++y) {\n                            int nx = x ^ v;\n                            int ny = y ^ v;\n                            int cur = src;\n                            int len = 1;\n                            if (nx != 0) {\n                                if ((cur & (1 << nx)) == 0) {\n                                    ++len;\n                                }\n                                cur ^= (1 << nx);\n                            }\n                            if (ny != 0) {\n                                if ((cur & (1 << ny)) == 0) {\n                                    ++len;\n                                }\n                                cur ^= (1 << ny);\n                            }\n                            if ((cur & (1 << x)) != 0) {\n                                ++len;\n                            }\n                            cur ^= (1 << x);\n                            if ((cur & (1 << y)) != 0) {\n                                ++len;\n                            }\n                            cur ^= (1 << y);\n                            if (dist[src] + len < dist[cur]) {\n                                dist[cur] = dist[src] + len;\n                                q[qh++] = cur;\n                            }\n                        }\n                    }\n                }\n            }\n            int got = 0;\n            for (int i = 1; i < 16; ++i) if (cnt[i] > 0) got |= 1 << i;\n            out.println(dist[got] + res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tclass Edge {\n\t\tint from, to, mark;\n\n\t\tpublic Edge(int from, int to, int mark) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.mark = mark;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", mark=\" + mark + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tList<Edge>[] graph;\n\t\n\tint dfs(int u, int p) {\n\t\tint xor = 0;\n\t\tfor (int t = 0; t < graph[u].size(); t++) {\n\t\t\tEdge e = graph[u].get(t);\n\t\t\tint to = u ^ e.from ^ e.to;\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\txor ^= e.mark;\n\t\t\te.mark ^= dfs(to, u);\n\t\t}\n\t\treturn xor;\n\t}\n\t\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tgraph = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgraph[i] = new ArrayList<>();\n\t\t}\n\t\t\n\t\tEdge[] e = new Edge[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\te[i] = new Edge(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tgraph[e[i].from].add(e[i]);\n\t\t\tgraph[e[i].to].add(e[i]);\n\t\t}\n\t\tdfs(0, -1);\n\t\tint allMask = 0;\n\t\tint result = 0;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint bit = e[i].mark;\n\t\t\tif (bit == 0) {\n\t\t\t\tresult++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((allMask & (1 << bit)) != 0) {\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tallMask ^= 1 << bit;\n\t\t}\n\t\tint[] xor = new int[1 << 16];\n\t\tfor (int i =0 ; i < 1 << 16; i++) {\n\t\t\tfor (int j = 0; j < 16; j++ ) {\n\t\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\t\txor[i] ^= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[1 << 16];\n\t\tfor (int mask = 1; mask < 1 << 16; mask++) {\n\t\t\tfor (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n\t\t\t\tif (xor[submask] == 0) {\n\t\t\t\t\tdp[mask] = Math.max(dp[mask], dp[mask ^ submask] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println((n - 1) - (dp[allMask] + result));\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing Number = System.Int64;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var a = new int[n];\n            for (int i = 0; i < n - 1; i++) {\n                var u = ri;\n                var v = ri;\n                var x = ri;\n                a[u] ^= x;\n                a[v] ^= x;\n            }\n            var cnt = new int[15];\n            for (int i = 0; i < n; i++)\n                cnt[a[i]]++;\n            var ans = 0;\n            var mask = 0;\n            for (int i = 0; i < 15; i++) {\n                ans += cnt[i] / 2;\n                if (cnt[i] % 2 == 1)\n                    mask |= 1 << i;\n            }\n            var pop = new int[1 << 15];\n            var dp = new int[1 << 15];\n            for (int i = 1; i < 1 << 15; i++) {\n                dp[i] = 1000000;\n                var v = 0;\n                for (int j = 0; j < 15; j++)\n                    if ((i >> j & 1) == 1) {\n                        v ^= j;\n                        pop[i]++;\n                    }\n                if (v != 0) pop[i] = 100000;\n                for (int s = i; s > 0; s = (s - 1) & i) {\n                    dp[i] = Min(dp[i], pop[s] - 1 + dp[i ^ s]);\n                }\n            }\n\n            Console.WriteLine(ans + dp[mask]);\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "//author: camypaper\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing static System.Math;\nusing Number = System.Int64;\nusing System.Runtime.CompilerServices;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var a = new int[n];\n            for (int i = 0; i < n - 1; i++) {\n                var u = ri;\n                var v = ri;\n                var x = ri;\n                a[u] ^= x;\n                a[v] ^= x;\n            }\n            var cnt = new int[16];\n            for (int i = 0; i < n; i++)\n                cnt[a[i]]++;\n            var ans = 0;\n            var mask = 0;\n            for (int i = 1; i < 16; i++) {\n                ans += cnt[i] / 2;\n                if (cnt[i] % 2 == 1)\n                    mask |= 1 << i;\n            }\n            var pop = new int[1 << 16];\n            var dp = new int[1 << 16];\n            for (int i = 1; i < 1 << 16; i++) {\n                dp[i] = 1000000;\n                var v = 0;\n                for (int j = 0; j < 16; j++)\n                    if ((i >> j & 1) == 1) {\n                        v ^= j;\n                        pop[i]++;\n                    }\n                if (v != 0) pop[i] = 100000;\n                for (int s = i; s > 0; s = (s - 1) & i) {\n                    dp[i] = Min(dp[i], pop[s] - 1 + dp[i ^ s]);\n                }\n            }\n\n            Console.WriteLine(ans + dp[mask]);\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int[] C = new int[N];\n        for(int j=0;j<N-1;j++){\n            int f = re.i();\n            int t = re.i();\n            int a = re.i();\n            C[f] ^= a;\n            C[t] ^= a;\n        }\n        int[] A = new int[16];\n        for(int i=0;i<N;i++){\n            A[C[i]]++;\n        }\n        int count = 0;\n        List<int> D = new List<int>();\n        for(int i=1;i<16;i++){\n            count += A[i]/2;\n            if(A[i]%2 == 1){\n                D.Add(i);\n            }\n        }\n        int[] DP = new int[1 << (D.Count)];\n        int[] sum = new int[1 << (D.Count)];\n        DP[0] = 0;\n        sum[0] = 0;\n        for(int i=1;i<DP.Length;i++){\n            for(int j=0;j<D.Count;j++){\n                if((i & (1 << j)) != 0){\n                    sum[i] = sum[i-(1<<j)] ^ D[j];\n                    break;\n                }\n            }\n        }\n        for(int i=1;i<DP.Length;i++){\n            if(sum[i] == 0){\n                int max = 1;\n                for(int j=(i-1) & i;j > 0;j=(j-1) & i){\n                    if(sum[j] == 0){\n                        max = Math.Max(DP[j]+DP[i-j],max);\n                    }\n                }\n                DP[i] = max;\n            }\n        }\n        count += D.Count-DP[DP.Length-1];\n        sb.Append(count+\"\\n\");\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n\n    Scanner cin;\n\n\n    int N;\n    int[] X;\n    int[] Y;\n    int[] A;\n    List<Tuple<int, int>>[] es;\n\n    const int MAX = (1 << 16);\n    const int B = 16;\n    int[] dp = new int[MAX];\n    int[] dec = new int[MAX];\n    int[,] next = new int[MAX, 16];\n    bool[,] nextok = new bool[MAX, 16];\n\n    int ans = 0;\n    \n\n    void calc()\n    {\n\n        cin = new Scanner();\n\n        for (int i = 0; i < MAX; i++)\n        {\n            dp[i] = 0;\n            //3-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    int l = j ^ k;\n                    if (((i >> l) & 1) == 0) continue;\n                    if (l <= k) continue;\n                    dp[i] = Math.Max(dp[i], dp[i - (1 << j) - (1 << k) - (1 << l)] + 1);\n                }\n            }\n            //4-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    for (int l = k + 1; l < B; l++)\n                    {\n                        if (((i >> l) & 1) == 0) continue;\n\n                        int m = (j ^ k ^ l);\n                        if (((i >> m) & 1) == 0) continue;\n                        if (m <= l) continue;\n                        dp[i] = Math.Max(dp[i], dp[i - (1 << j) - (1 << k) - (1 << l) - (1 << m)] + 1);\n                    }\n                }\n            }\n\n\n            //5-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    for (int l = k + 1; l < B; l++)\n                    {\n                        if (((i >> l) & 1) == 0) continue;\n                        for (int n = l + 1; n < B; n++)\n                        {\n                            if (((i >> n) & 1) == 0) continue;\n\n                            int m = (j ^ k ^ l ^ n);\n                            if (((i >> m) & 1) == 0) continue;\n                            if (m <= n) continue;\n                            dp[i] = Math.Max(dp[i], dp[i - (1 << j) - (1 << k) - (1 << l) - (1 << m) - (1 << n)] + 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        N = cin.nextInt();\n        X = new int[N];\n        Y = new int[N];\n        A = new int[N];\n        int[] P = new int[N];\n        es = new List<Tuple<int, int>>[N];\n\n        for (int i = 0; i < N; i++)\n        {\n            es[i] = new List<Tuple<int, int>>();\n        }\n        \n        for (int i = 0; i < N - 1; i++)\n        {\n            X[i] = cin.nextInt();\n            Y[i] = cin.nextInt();\n            A[i] = cin.nextInt();\n            P[X[i]] ^= A[i];\n            P[Y[i]] ^= A[i];\n        }\n\n        int[] sum = new int[B];\n        for (int i = 0; i < N; i++)\n        {\n            sum[P[i]]++;\n        }\n\n        int ans = 0;\n        int flag = 0;\n        for (int i = 1; i < B; i++)\n        {\n            ans += (sum[i] + 1) / 2;\n            if (sum[i] % 2 == 1) flag |= (1 << i);\n        }\n        \n        ans -= dp[flag];\n        Console.WriteLine(ans);\n    }\n\n    int bitCount(long x)\n    {\n        x = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n        x = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n        x = (x & 0x0f0f0f0f0f0f0f0f) + (x >> 4 & 0x0f0f0f0f0f0f0f0f);\n        x = (x & 0x00ff00ff00ff00ff) + (x >> 8 & 0x00ff00ff00ff00ff);\n        x = (x & 0x0000ffff0000ffff) + (x >> 16 & 0x0000ffff0000ffff);\n        return (int)((x & 0x00000000ffffffff) + (x >> 32 & 0x00000000ffffffff));\n    }\n\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n\n    Scanner cin;\n\n\n    int N;\n    int[] X;\n    int[] Y;\n    int[] A;\n    List<Tuple<int, int>>[] es;\n\n    const int MAX = (1 << 16);\n    const int B = 16;\n    int[] dp = new int[MAX];\n    int[] dec = new int[MAX];\n    int[,] next = new int[MAX, 16];\n    bool[,] nextok = new bool[MAX, 16];\n\n    int ans = 0;\n    \n\n    void calc()\n    {\n\n        cin = new Scanner();\n\n        for (int i = 0; i < MAX; i++)\n        {\n            dp[i] = i;\n            //3-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    int l = j ^ k;\n                    if (((i >> l) & 1) == 0) continue;\n                    if (l <= k) continue;\n                    dp[i] = i - (1 << j) - (1 << k) - (1 << l);\n                    dec[i] = dec[dp[i]] + 1;\n                    break;\n                }\n                if (dp[i] != i) break;\n            }\n            if (dp[i] != i) continue;\n            //4-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    for (int l = k + 1; l < B; l++)\n                    {\n                        if (((i >> l) & 1) == 0) continue;\n\n                        int m = (j ^ k ^ l);\n                        if (((i >> m) & 1) == 0) continue;\n                        if (m <= l) continue;\n                        dp[i] = i - (1 << j) - (1 << k) - (1 << l) - (1 << m);\n                        dec[i] = dec[dp[i]] + 1;\n                        break;\n                    }\n                    if (dp[i] != i) break;\n                }\n                if (dp[i] != i) break;\n            }\n\n            //calc-next\n            if (dp[i] == i)\n            {\n                for (int j = 0; j < B; j++)\n                {\n                    next[i, j] = i | (1 << j);\n                }\n\n                for (int j = 0; j < B; j++)\n                {\n                    if (((i >> j) & 1) == 0) continue;\n                    nextok[i, j] = true;\n                    next[i, j] = (1 << j);\n\n                    for (int k = j + 1; k < B; k++)\n                    {\n                        if (((i >> k) & 1) == 0) continue;\n\n                        nextok[i, j ^ k] = true;\n                        next[i, j ^ k] = (1 << j) | (1 << k);\n\n                        for (int l = k + 1; l < B; l++)\n                        {\n                            if (((i >> l) & 1) == 0) continue;\n\n                            nextok[i, j ^ k ^ l] = true;\n                            next[i, j ^ k ^ l] = (1 << j) | (1 << k) | (1 << l);\n\n                            for (int m = l + 1; m < B; m++)\n                            {\n                                if (((i >> m) & 1) == 0) continue;\n                                nextok[i, j ^ k ^ l ^ m] = true;\n                                next[i, j ^ k ^ l ^ m] = (1 << j) | (1 << k) | (1 << l) | (1 << m);\n                            }\n                        }\n                        if (dp[i] != i) break;\n                    }\n                    if (dp[i] != i) break;\n                }\n            }\n        }\n\n        N = cin.nextInt();\n        X = new int[N];\n        Y = new int[N];\n        A = new int[N];\n        es = new List<Tuple<int, int>>[N];\n\n        for (int i = 0; i < N; i++)\n        {\n            es[i] = new List<Tuple<int, int>>();\n        }\n        \n        for (int i = 0; i < N - 1; i++)\n        {\n            X[i] = cin.nextInt();\n            Y[i] = cin.nextInt();\n            A[i] = cin.nextInt();\n            es[X[i]].Add(Tuple.Create(Y[i], A[i]));\n            es[Y[i]].Add(Tuple.Create(X[i], A[i]));\n        }\n\n\n        dfs(0, -1, 0);\n        Console.WriteLine(ans);\n    }\n\n    int dfs(int a, int parent, int preMove)\n    {\n        int flag = 0;\n        foreach (var item in es[a])\n        {\n            int c = item.Item1;\n            int f = item.Item2;\n            if (c == parent) continue;\n            int ff = dfs(c, a, f);\n            int and = ff & flag;\n            ans -= bitCount(and);\n            flag ^= ff;\n        }\n        ans -= dec[flag];\n        flag = dp[flag];\n\n        if (preMove == 0) return 0;\n        int nextflag = next[flag, preMove];\n        if(!nextok[flag, preMove])\n        {\n            ans++;\n        }\n        return nextflag;\n    }\n\n    int bitCount(long x)\n    {\n        x = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n        x = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n        x = (x & 0x0f0f0f0f0f0f0f0f) + (x >> 4 & 0x0f0f0f0f0f0f0f0f);\n        x = (x & 0x00ff00ff00ff00ff) + (x >> 8 & 0x00ff00ff00ff00ff);\n        x = (x & 0x0000ffff0000ffff) + (x >> 16 & 0x0000ffff0000ffff);\n        return (int)((x & 0x00000000ffffffff) + (x >> 32 & 0x00000000ffffffff));\n    }\n\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n\n    Scanner cin;\n\n\n    int N;\n    int[] X;\n    int[] Y;\n    int[] A;\n    List<Tuple<int, int>>[] es;\n\n    const int MAX = (1 << 16);\n    const int B = 16;\n    int[] dp = new int[MAX];\n    int[] dec = new int[MAX];\n    int[,] next = new int[MAX, 16];\n    bool[,] nextok = new bool[MAX, 16];\n\n    int ans = 0;\n    \n\n    void calc()\n    {\n\n        cin = new Scanner();\n\n        for (int i = 0; i < MAX; i++)\n        {\n            dp[i] = 0;\n            //3-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    int l = j ^ k;\n                    if (((i >> l) & 1) == 0) continue;\n                    if (l <= k) continue;\n                    dp[i] = Math.Max(dp[i], dp[i - (1 << j) - (1 << k) - (1 << l)] + 1);\n                }\n            }\n            //4-set\n            for (int j = 0; j < B; j++)\n            {\n                if (((i >> j) & 1) == 0) continue;\n                for (int k = j + 1; k < B; k++)\n                {\n                    if (((i >> k) & 1) == 0) continue;\n                    for (int l = k + 1; l < B; l++)\n                    {\n                        if (((i >> l) & 1) == 0) continue;\n\n                        int m = (j ^ k ^ l);\n                        if (((i >> m) & 1) == 0) continue;\n                        if (m <= l) continue;\n                        dp[i] = Math.Max(dp[i], dp[i - (1 << j) - (1 << k) - (1 << l) - (1 << m)] + 1);\n                    }\n                }\n            }\n        }\n\n        N = cin.nextInt();\n        X = new int[N];\n        Y = new int[N];\n        A = new int[N];\n        int[] P = new int[N];\n        es = new List<Tuple<int, int>>[N];\n\n        for (int i = 0; i < N; i++)\n        {\n            es[i] = new List<Tuple<int, int>>();\n        }\n        \n        for (int i = 0; i < N - 1; i++)\n        {\n            X[i] = cin.nextInt();\n            Y[i] = cin.nextInt();\n            A[i] = cin.nextInt();\n            P[X[i]] ^= A[i];\n            P[Y[i]] ^= A[i];\n        }\n\n        int[] sum = new int[B];\n        for (int i = 0; i < N; i++)\n        {\n            sum[P[i]]++;\n        }\n\n        int ans = 0;\n        int flag = 0;\n        for (int i = 1; i < B; i++)\n        {\n            ans += (sum[i] + 1) / 2;\n            if (sum[i] % 2 == 1) flag |= (1 << i);\n        }\n        \n        ans -= dp[flag];\n        Console.WriteLine(ans);\n    }\n\n    int bitCount(long x)\n    {\n        x = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n        x = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n        x = (x & 0x0f0f0f0f0f0f0f0f) + (x >> 4 & 0x0f0f0f0f0f0f0f0f);\n        x = (x & 0x00ff00ff00ff00ff) + (x >> 8 & 0x00ff00ff00ff00ff);\n        x = (x & 0x0000ffff0000ffff) + (x >> 16 & 0x0000ffff0000ffff);\n        return (int)((x & 0x00000000ffffffff) + (x >> 32 & 0x00000000ffffffff));\n    }\n\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.7.3\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[] g = new int[n];\n    foreach (i; 0..n-1) {\n        int a, b, z;\n        sc.read(a, b, z);\n        g[a] ^= z;\n        g[b] ^= z;\n    }\n    \n    int f;\n    int ans = g.count(0).to!int;\n    foreach (d; 1..16) {\n        int u = g.count(d).to!int;\n        ans += u/2;\n        if (u % 2) f |= (1<<d);\n    }\n\n    int[] ls;\n    foreach (i; 1..(1<<16)) {\n        int x = 0;\n        foreach (j; 0..16) {\n            if (i & (1<<j)) x ^= j;\n        }\n        if (x == 0) ls ~= i.to!int;\n    }\n\n    int[] dp = new int[1<<16];\n    foreach (i; 0..(1<<16)) {\n        if (i & ~f) continue;\n        foreach (d; ls) {\n            if (d & ~i) continue;\n            if (d > i) break;\n            dp[i] = max(dp[i], dp[i^d]+1);\n        }\n    }\n    ans += dp[f];\n    writeln(n - ans);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100100\nusing namespace std;\n\nint n,num[N],ans,cnt[16],tmp,dp[400000],tm[16];\nbool hav[16];\n\nint dfs(int zt)\n{\n\tif(dp[zt]!=-1) return dp[zt];\n\tint i,j,k,tt=0,res=30;\n\tmemset(hav,0,sizeof(hav));\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tif((1 << (i-1))&zt) tm[++tt]=i,hav[i]=1;\n\t}\n\tfor(i=1;i<=tt;i++)\n\t{\n\t\tfor(j=1;j<=tt;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tk=tm[j]^tm[i];\n\t\t\tif(hav[k])\n\t\t\t{\n\t\t\t\tres=min(res,dfs(zt^(1 << (tm[j]-1))^(1 << (tm[i]-1))^(1 << (k-1)))+2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres=min(res,dfs(zt^(1 << (tm[i]-1))^(1 << (tm[j]-1))^(1 << (k-1)))+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[zt]=res;\n}\n\nint main()\n{\n\tint i,j,p,q,o;\n\tcin>>n;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&p,&q,&o);\n\t\tnum[++p]^=o;\n\t\tnum[++q]^=o;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n//\t\tcout<<num[i]<<\" \";\n\t\tcnt[num[i]]++;\n\t}\n\tfor(i=1;i<=15;i++)\n\t{\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t\ttmp|=cnt[i]*(1 << (i-1));\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0]=0;\n\tcout<<dfs(tmp)+ans;\n}"
  },
  {
    "language": "Bash",
    "code": "/*     !ya khoda!     */\n#include <bits/stdc++.h>\n\n#define ll long long\n#define ld long double\n\n#define pp push\n#define po pop()\n#define pb push_back\n#define pf push_front\n#define pob pop_back()\n#define pof pop_front()\n#define I insert\n#define E erase\n\n#define F first\n#define S second\n\n#define mkp make_pair\n#define pll pair<ll,ll>\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define all(a) a.begin(),a.end()\n\n#define coutghat(x)      cout<<tolower(x);\n#define coutashar(x,d)   cout<<fixed<<setprecision(x)<<(ld)d\n#define IOS ios_base::sync_with_stdio(false) , cin.tie(0);\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n//#define poow(a,b,M)   b?(poow((a*a)%M,b/2)%M * (b&1?a))%M:1 ;\n/*==========================================================================*/\nusing namespace std;\nll poow(ll x,ll n,ll Mod=1e9+7) { return (n==0?1:poow(x*x%Mod,n/2)*(n&1?x:1)%Mod); }\n//#pragma optimize O3\n// 107,109, 211,223, 307, 401,409, 503,509, 601,607, 701,709, 809, 907, 1009\n/*==========================================================================*/\nconst int N=2e5+10  , M=1e4+10  , SQ=320 , LG=23 , base=2;\nconst int mod=1e9+7 , MOD=1e9+9;\nconst ll  INF=1e9   , inf=1e18 , super_inf=~0ull/4;\nll n,m,a[N]  ,  cnt[16]  ,  dp[1<<16],val[1<<16]  ,  x,k;\nvector<ll>vec;\n/*==========================================================================*/\nint main()\n{\n    IOS;\n    cin>>n;\n\tfor(int i=1;i<n;i++)\n\t{   ll v,u,w;\n        cin>>v>>u>>w;\n\t\ta[v]^=w  ,  a[u]^=w;\n\t}\n\tfor(int i=0;i<n;i++)   cnt[a[i]]++;\n\n\n\tx=cnt[0]  ,  cnt[0]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cnt[a[i]]%2)    vec.pb(a[i]);\n\t\tx+=cnt[a[i]]/2  ,  cnt[a[i]]=0;\n\t}\n\n\tm=vec.size() , k=(1<<m);\n\tfor(int i=0;i<k;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(i>>j&1)\n\t\t\t\tval[i]^=vec[j];\n\n\tfor(int i=1;i<k;i++)\n\t{   dp[i]=1;\n\t\tif(val[i]!=0)   continue;\n\t\tfor(int j=i;j>0;j=(j-1)&i)\n\t\t\tif(!val[j])\n\t\t\t\tdp[i]=max(dp[i],dp[j]+dp[i^j]);\n\t}\n\n\tcout<<n-(dp[k-1]+x);\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "//InTheNameOfGod\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define rep(i,j,k) for(int i=j;i<k;++i)\n#define rrep(i,j,k) for(int i=j;i>=k;i--)\n#define pb push_back\n#define lb(i) i&(-i);\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nconst int maxn =1e5+5;\nint n,a[maxn],xr[maxn],dp[(1<<16)],cal[maxn],re;\nbool ok[16];\nvector<int> v;\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    cin>>n;\n    rep(i,1,n)\n    {\n        int x,y,w;\n        cin>>x>>y>>w;\n        xr[x]^=w;\n        xr[y]^=w;\n    }\n    rep(i,0,n)\n    {\n        if(xr[i]==0)\n        {\n            re++;\n        }\n        else if(ok[xr[i]])\n        {\n            ok[xr[i]]=0;\n            re++;\n        }\n        else\n        {\n            ok[xr[i]]=1;\n        }\n    }\n    rep(i,1,16)if(ok[i])\n    {\n        v.pb(i);\n        //cout<<v.back()<<' ';\n    }\n    //cout<<endl;\n    int l=v.size();\n    rep(i,1,(1<<l))\n    {\n        int j=0;\n        while(!(i&(1<<j)))j++;\n        cal[i]=cal[i^(1<<j)]^v[j];\n    }\n    rep(i,1,(1<<l))\n    {\n        dp[i]=1000;\n        for(int sub=i;sub>0;sub=(sub-1)&i)if(cal[sub]==0)\n        {\n            dp[i]=min(dp[i],dp[i^sub]+1);\n        }\n    }\n    re+=dp[(1<<l)-1];\n    cout<<n-re;\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\n#define INF 0x3FFFFFFF\nusing namespace std;\nint a[MAXN],w[MAXN],dp[MAXN];\nint u,v,val;\nint dfs(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s])\n\t\treturn dp[s];\n\tdp[s]=INF;\n\tfor(int i=1;i<16;i++)\n\t\tif(s&(1<<i)){\n\t\t\tfor(int j=1;j<16;j++){\n\t\t\t\tif(j!=i&&(s&(1<<j))){\n\t\t\t\t\tint q=i^j;\n\t\t\t\t\tif(s&(1<<q))\n\t\t\t\t\t\tdp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<q))+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[s]=min(dp[s],dfs(s^(1<<i)^(1<<j)^(1<<q))+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n}\nint main(){\n\tint S,n,ans=0;\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tSF(\"%d%d%d\",&u,&v,&val);\n\t\ta[u]^=val;\n\t\ta[v]^=val;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tw[a[i]]++;\n\tfor(int i=1;i<16;i++){\n\t\tans+=w[i]/2;\n\t\tif(w[i]%2==1)\n\t\t\tS^=(1<<i);\n\t}\n\tPF(\"%d\",ans+dfs(S));\n}"
  },
  {
    "language": "Bash",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nlong long max(long long x, long long y){return (x > y ? x : y);}\nlong long min(long long x, long long y){return (x < y ? x : y);}\nint gcd(int a, int b) { return b ? gcd(b, a%b) : a; }\n\n#define ll int\n#define FOR(i,a) for(ll i=0;i<(ll)a.size();i++)\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=1e5+500;\nconst ll inf=1e9+800;\nconst ll mod=1e9+7;\n\nll dp[1<<16];\nll xx[1<<16];\nvoid cal(){\n\txx[0]=0;\n\tfor(ll i=1;i<(1<<16);i++){\n\t\tll lb;\n\t\tfor(ll j=0;j<16;j++){\n\t\t\tif((i>>j)&1){\n\t\t\t\tlb=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\txx[i]=(xx[i^(1<<lb)]^lb);\n  \t}\n\tdp[0]=0;\n\tfor(ll i=1;i<(1<<16);i++){\n\t\t// dp[i]\n\t\tfor(ll mas=i;mas>0;mas=((mas-1)&i)){\n\t\t\tif(xx[mas]==0)\n\t\t\t\tdp[i]=max(dp[i],dp[i^mas]+1);\n\t\t}\n\t}\n}\n\nvector<pii> ger[maxn];\nll cnt[16];\n\nvoid dfs(ll a,ll p=-1){\n\tll val=0;\n\tFOR(i,ger[a]){\n\t\tll v=ger[a][i].F;\n\t\tll w=ger[a][i].S;\n\t\tval^=w;\n\t\tif(v!=p)\n\t\tdfs(v,a);\n\t}\n\tif(p!=-1)\n\t\tcnt[val]++;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tll n;\n\tcin>>n;\n\tfor(ll i=1;i<n;i++){\n\t\tll v,u,w;\n\t\tcin>>v>>u>>w;\n\t\tger[v].pb(mp(u,w));\n\t\tger[u].pb(mp(v,w));\n\t}\n\tdfs(0);\n\tll ans=0;\n\tfor(ll i=1;i<16;i++){\n\t\tans+=cnt[i]/2;\n\t\tcnt[i]%=2;\n\t}\n\tll res=0;\n\tfor(ll i=1;i<16;i++){\n\t\tif(cnt[i]){\n\t\t\tres^=i;\n\t\t}\n\t}\n\tcnt[res]++;\n\tcnt[res]=0;\n\tans+=cnt[res]/2;\n\tcnt[res]%=2;\n\n\tres=0;\n\tll t=0;\n\tfor(ll i=1;i<16;i++){\n\t\tif(cnt[i]){\n\t\t\tres+=(1<<i);\n\t\t\tt++;\n\t\t}\n\t}\n\tcal();\n\tcout<<ans+t-dp[res];\n}"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\nn = int(input())\nnodes = [0] * n\nfor _ in range(n - 1):\n    x, y, a = map(int, input().split())\n    nodes[x] ^= a\n    nodes[y] ^= a\n\nc = Counter(nodes)\ndel c[0]\nans = 0\nremains = set()\nfor i, v in c.items():\n    ans += v // 2\n    if v % 2:\n        remains.add(i)\n\nfor r in (3, 4, 5):\n    while not r < len(remains) < r * 2:\n        for ns in combinations(remains, r):\n            if reduce(xor, ns) == 0:\n                remains.difference_update(ns)\n                ans += r - 1\n                break\n        else:\n            break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#pragma region revive\n#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define inl inline\n#define re register int\n#define fa(x) t[x].fa\n#define son(x, y) t[x].child[y]\n#define ls(x) t[x].child[0]\n#define rs(x) t[x].child[1]\n#define ll long long\n#define ull unsigned long long\nconst int inf = 0x3f3f3f3f;\n#define lowbit(x) ((x) & (-x))\nusing namespace std;\n//#ifndef _DEBUG\n//#define getchar() (*(IOB.in.p++))\n//#define putchar(c) (*(IOB.out.p++) = (c))\n//#define io_eof() (IOB.in.p >= IOB.in.pend)\n//struct IOBUF {\n//\tstruct {\n//\t\tchar buff[1 << 27], *p, *pend;\n//\t} in;\n//\tstruct {\n//\t\tchar buff[1 << 27], *p;\n//\t} out;\n//\tIOBUF() {\n//\t\tin.p = in.buff;\n//\t\tout.p = out.buff;\n//\t\tin.pend = in.buff + fread(in.buff, 1, 1 << 27, stdin);\n//\t}\n//\t~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); }\n//} IOB;\n//#endif\ntemplate <typename IO>\ninl void write(IO x) {\n\tif (x == 0) return (void)putchar('0');\n\tif (x < 0) putchar('-'), x = -x;\n\tstatic char buf[30];\n\tchar *p = buf;\n\twhile (x) {\n\t\t*(p++) = x % 10 + '0';\n\t\tx /= 10;\n\t}\n\twhile (p > buf)\n\t\tputchar(*(--p));\n}\ninl void writestr(const char *s) {\n\twhile (*s != 0)\n\t\tputchar(*(s++));\n}\ntemplate <typename IO>\ninl void writeln(IO x) { write(x), putchar('\\n'); }\ntemplate <typename IO>\ninl void writesp(IO x) { write(x), putchar(' '); }\ninl int readstr(char *s) {\n\tchar *begin = s, c = getchar();\n\twhile (c < 33 || c > 127) {\n\t\tc = getchar();\n\t}\n\twhile (c >= 33 && c <= 127) {\n\t\t*(s++) = c;\n\t\tc = getchar();\n\t}\n\t*s = 0;\n\treturn s - begin;\n}\ntemplate <typename IO>\ninl IO read() {\n\tIO x = 0;\n\tregister bool w = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn w ? -x : x;\n}\ntemplate <>\ninl double read<double>() {\n\tdouble x = 0;\n\tint w = 0, y = 0;\n\tll z = 1;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9' || c == '.') {\n\t\tif (c == '.') {\n\t\t\ty = 1, c = getchar();\n\t\t\tcontinue;\n\t\t}\n\t\tx = x * 10 + (c ^ 48);\n\t\tif (y) z *= 10;\n\t\tc = getchar();\n\t}\n\treturn (w ? -x : x) / z;\n}\n#pragma endregion\nint n, b[1 << 16], f[1 << 16], s;\nint a[100001], o[16], ans;\ninl int dp(int i) {\n\tif (f[i] < inf) return f[i];\n\tfor (re x = 1; x <= 15; x++) {\n\t\tif (((1 << x) & i) == 0) continue;\n\t\tfor (re y = 1; y <= 15; y++) {\n\t\t\tif (x == y) continue;\n\t\t\tif (((1 << y) & i) == 0) continue;\n\t\t\tre z = x ^ y, p = (((i ^ (1 << z)) ^ (1 << x)) ^ (1 << y));\n\t\t\tif ((1 << z) & i)\n\t\t\t\tf[i] = min(f[i], dp(p) + 2);\n\t\t\telse\n\t\t\t\tf[i] = min(f[i], dp(p) + 1);\n\t\t}\n\t}\n\treturn f[i];\n}\nint main() {\n\tn = read<int>();\n\tfor (re x, y, z, i = 1; i < n; i++) {\n\t\tx = read<int>() + 1, y = read<int>() + 1, z = read<int>();\n\t\ta[x] ^= z, a[y] ^= z;\n\t}\n\tfor (re i = 1; i <= n; i++) o[a[i]]++;\n\tfor (re i = 1; i <= 15; i++) {\n\t\tif (o[i] >= 2) {\n\t\t\tans += o[i] / 2;\n\t\t\to[i] = o[i] & 1;\n\t\t}\n\t\tif (o[i]) s |= (1 << i);\n\t}\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] = 0;\n\tans += dp(s);\n\tif (ans) writeln(ans);\n}"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\nn = int(input())\nnodes = [0] * n\nfor _ in range(n - 1):\n    x, y, a = map(int, input().split())\n    nodes[x] ^= a\n    nodes[y] ^= a\n\nc = Counter(nodes)\nans = 0\nremains = set()\nfor i, v in c.items():\n    if i == 0:\n        continue\n    ans += v // 2\n    if v % 2:\n        remains.add(i)\n\nfor r in (3, 4, 5):\n    while True:\n        for ns in combinations(remains, r):\n            if reduce(xor, ns) == 0:\n                remains.difference_update(ns)\n                ans += r - 1\n                break\n        else:\n            break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\nn = int(input())\nnodes = [0] * n\nfor _ in range(n - 1):\n    x, y, a = map(int, input().split())\n    nodes[x] ^= a\n    nodes[y] ^= a\n\nc = Counter(nodes)\ndel c[0]\nans = 0\nremains = set()\nfor i, v in c.items():\n    ans += v // 2\n    if v % 2:\n        remains.add(i)\n\nfor r in (3, 4, 5):\n    while len(remains) < r * 2:\n        for ns in combinations(remains, r):\n            if reduce(xor, ns) == 0:\n                remains.difference_update(ns)\n                ans += r - 1\n                break\n        else:\n            break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nB = [0]*N\nfor i in range(N-1):\n    x, y, a = map(int, input().split())\n    B[x] ^= a\n    B[y] ^= a\nD = {}\nfor b in B:\n    D[b] = D.get(b, 0) + 1\nD[0] = 0\nans = 0\nfirst = 0\nfor b in D:\n    ans += D[b]//2\n    if D[b]%2:\n        first |= 1 << b\n\nA = [0]*(1 << 16)\nfor i in range(1, 1<<16):\n    bit = i & -i\n    l = len(bin(bit))-3\n    A[i] = A[i ^ bit] ^ l\n\nmemo = {0: 0}\ndef dfs(state):\n    if state in memo:\n        return memo[state]\n    cur = state\n    res = 10**9+7\n    while cur:\n        if A[cur] == 0:\n            res = min(res, dfs(state ^ cur) + bin(cur).count('1')-1)\n        cur -= 1\n        cur &= state\n    memo[state] = res\n    return res\nans += dfs(first)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nB = [0]*N\nfor i in range(N-1):\n    x, y, a = map(int, input().split())\n    B[x] ^= a\n    B[y] ^= a\nD = {}\nfor b in B:\n    D[b] = D.get(b, 0) + 1\nD[0] = 0\nans = 0\nfirst = 0\nfor b in D:\n    ans += D[b]//2\n    if D[b]%2:\n        first |= 1 << b\n\nA = [0]*(1 << 15)\nfor i in range(1, 1<<15):\n    bit = i & -i\n    l = len(bin(bit))-3\n    A[i] = A[i ^ bit] ^ l\n\nmemo = {0: 0}\ndef dfs(state):\n    if state in memo:\n        return memo[state]\n    cur = state\n    res = 10**9+7\n    while cur:\n        if A[cur] == 0:\n            res = min(res, dfs(state ^ cur) + bin(cur).count('1')-1)\n        cur -= 1\n        cur &= state\n    memo[state] = res\n    return res\nans += dfs(first)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "//It is made by M_sea\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200000+10;\n\nint w[N],cnt[20],f[1<<15],sxor[1<<15];\n\nint main() {\n\tint n=read();\n\tfor (re int i=1;i<n;++i) {\n\t\tint u=read()+1,v=read()+1,val=read();\n\t\tw[u]^=val,w[v]^=val;\n\t}\n\tfor (re int i=1;i<=n;++i) ++cnt[w[i]];\n\tint ans=0,s=0;\n\tfor (re int i=1;i<=15;++i) ans+=cnt[i]/2,s|=(cnt[i]&1)<<(i-1);\n\tfor (re int i=1;i<(1<<15);++i) f[i]=f[i>>1]+(i&1);\n\tfor (re int i=1;i<(1<<15);++i) --f[i];\n\tfor (re int i=1;i<(1<<15);++i)\n\t\tfor (re int j=1;j<=15;++j)\n\t\t\tif (i&(1<<(j-1))) sxor[i]^=j;\n\tfor (re int i=1;i<(1<<15);++i) {\n\t\tif (sxor[i]) continue;\n\t\tfor (re int j=i&(i-1);j;j=(j-1)&i)\n\t\t\tif (!sxor[j]) f[i]=min(f[i],f[j]+f[i^j]);\n\t}\n\tprintf(\"%d\\n\",ans+f[s]);\n\treturn 0;\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn make_table() -> Vec<usize> {\n    let mut dp = vec![0; 1 << 16];\n    for pc in 1..16 + 1 {\n        for bits in 0usize..1 << 16 {\n            if (bits & 1) == 1 || bits.count_ones() != pc { continue; }\n            let mut mi = 1 << 16;\n            for i in 1..16 {\n                if (bits & 1 << i) == 0 { continue; }\n                mi = min(mi, dp[bits ^ 1 << i] + 1);\n                for j in 1..16 {\n                    if i == j || (bits & 1 << j) == 0 { continue; }\n                    for k in 1..16 {\n                        let mut newbits = bits ^ 1 << i ^ 1 << j;\n                        let mut app = 1;\n                        if (newbits ^ 1 << (i ^ k)) != 0 {\n                            app += 1;\n                        }\n                        newbits ^= 1 << (i ^ k);\n                        if (newbits ^ 1 << (j ^ k)) != 0 {\n                            app += 1;\n                        }\n                        newbits ^= 1 << (j ^ k);\n                        newbits &= !1;\n                        mi = min(mi, dp[newbits] + app);\n                    }\n                }\n            }\n            dp[bits] = mi;\n        }\n    }\n    dp\n}\n\nfn dfs(g: &[Vec<(usize, usize)>], v: usize, par: usize,\n       b: &mut [usize], mut acc: usize) {\n    for &(w, d) in &g[v] {\n        if w == par { continue; }\n        dfs(g, w, v, b, d);\n        acc ^= b[w];\n    }\n    b[v] = acc;\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        xya: [(usize, usize, usize); n - 1],\n    }\n    let tbl = make_table();\n    /*\n    for i in (0..16) {\n        let i = 2 * i;\n        for j in 0..5 {\n            if (i & 1 << j) != 0 {\n                eprint!(\"{} \", j);\n            }\n        }\n        eprintln!(\": {}\", tbl[i]);\n    }*/\n    let mut g = vec![vec![]; n];\n    for &(x, y, a) in &xya {\n        g[x].push((y, a));\n        g[y].push((x, a));\n    }\n    let mut b = vec![0; n];\n    dfs(&g, 0, n, &mut b, 0);\n    b[0] = 0;\n    let mut freq = [0; 16];\n    for &b in &b {\n        freq[b] += 1;\n    }\n    // eprintln!(\"b = {:?}\", b);\n    let mut tot = 0;\n    let mut rem = 0;\n    for i in 1..16 {\n        tot += freq[i] / 2;\n        if freq[i] % 2 == 1 {\n            rem |= 1 << i;\n        }\n    }\n    tot += tbl[rem];\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let n = readl!(usize);\n    let mut dif = vec![0; n];\n    for _ in 0..n-1 {\n        let (a, b, c) = readl!(usize, usize, usize);\n        dif[a] ^= c;\n        dif[b] ^= c;\n    }\n\n    let mut imask = 0;\n    let mut iv = 0;\n    for i in 0..n {\n        if dif[i] != 0 {\n            if (imask>>dif[i])&1 == 1 {\n                iv += 1;\n            }\n            imask ^= 1<<(dif[i]);\n\n        }\n    }\n    let imask = imask;\n    let iv = iv;\n    let dma = dif.iter().map(|&x| x).max().unwrap();\n    \n    let inf = 1_000_000_000;\n    let mut dp = vec![inf; 1<<15];\n    // dp[imask] = iv;\n    dp[0] = 0;\n    for mask in 1..1<<dma {\n        let mut pmask = 0;\n        while pmask != mask {\n            let sx = (0..dma).fold(0, \n                |sum, x| if (pmask>>x)&1 == 1 {sum^x} else {sum});\n            if sx == 0 {\n                dp[mask] = std::cmp::min(dp[mask], dp[pmask]+(pmask^mask).count_ones()-1);\n            }\n            pmask = ((pmask as i64-mask as i64) & mask as i64) as usize;\n        }\n    }\n    \n    printer.println(dp[imask]+iv);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let n = readl!(usize);\n    let mut dif = vec![0; n];\n    for _ in 0..n-1 {\n        let (a, b, c) = readl!(usize, usize, usize);\n        dif[a] ^= c;\n        dif[b] ^= c;\n    }\n\n    let mut imask = 0;\n    let mut iv = 0;\n    for i in 0..n {\n        if dif[i] != 0 {\n            if (imask>>dif[i])&1 == 1 {\n                iv += 1;\n            }\n            imask ^= 1<<(dif[i]);\n        }\n    }\n    let imask = imask;\n    let iv = iv;\n    let dma = dif.iter().map(|&x| x).max().unwrap()+1;\n    \n    let inf = 1_000_000_000;\n    let mut dp = vec![inf; 1<<15];\n    // dp[imask] = iv;\n    dp[0] = 0;\n    for mask in 1..1<<dma {\n        let mut pmask = 0;\n        while pmask != mask {\n            let sx = (0..dma).fold(0, \n                |sum, x| if (pmask>>x)&1 == 1 {sum^x} else {sum});\n            if sx == 0 {\n                dp[mask] = std::cmp::min(dp[mask], dp[pmask]+(pmask^mask).count_ones()-1);\n            }\n            pmask = ((pmask as i64-mask as i64) & mask as i64) as usize;\n        }\n    }\n    \n    printer.println(dp[imask]+iv);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn make_table() -> Vec<usize> {\n    let mut dp = vec![0; 1 << 16];\n    for pc in 1..16 + 1 {\n        for bits in 0usize..1 << 16 {\n            if (bits & 1) == 1 || bits.count_ones() != pc { continue; }\n            let mut mi = 1 << 16;\n            for i in 0..16 {\n                if (bits & 1 << i) == 0 { continue; }\n                mi = min(mi, dp[bits ^ 1 << i] + 1);\n                for j in 0..16 {\n                    if i == j || (bits & 1 << j) == 0 { continue; }\n                    let newbits = bits ^ 1 << i ^ 1 << j ^ 1 << (i ^ j);\n                    let app = if (newbits & 1 << (i ^ j)) == 0 { 1 } else { 0 };\n                    mi = min(mi, dp[newbits] + 1 + app);\n                }\n            }\n            dp[bits] = mi;\n        }\n    }\n    dp\n}\n\nfn dfs(g: &[Vec<(usize, usize)>], v: usize, par: usize,\n       b: &mut [usize], mut acc: usize) {\n    for &(w, d) in &g[v] {\n        if w == par { continue; }\n        dfs(g, w, v, b, d);\n        acc ^= b[w];\n    }\n    b[v] = acc;\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        xya: [(usize, usize, usize); n - 1],\n    }\n    let tbl = make_table();\n    let mut g = vec![vec![]; n];\n    for &(x, y, a) in &xya {\n        g[x].push((y, a));\n        g[y].push((x, a));\n    }\n    let mut b = vec![0; n];\n    dfs(&g, 0, n, &mut b, 0);\n    let mut freq = [0; 16];\n    for &b in &b {\n        freq[b] += 1;\n    }\n    let mut tot = 0;\n    let mut rem = 0;\n    for i in 1..16 {\n        tot += freq[i] / 2;\n        if freq[i] % 2 == 1 {\n            rem |= 1 << i;\n        }\n    }\n    tot += tbl[rem];\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn make_table() -> Vec<usize> {\n    let mut dp = vec![0; 1 << 16];\n    for pc in 1..16 + 1 {\n        for bits in 0usize..1 << 16 {\n            if (bits & 1) == 1 || bits.count_ones() != pc { continue; }\n            let mut mi = 1 << 16;\n            for i in 0..16 {\n                if (bits & 1 << i) == 0 { continue; }\n                mi = min(mi, dp[bits ^ 1 << i] + 1);\n                for j in 0..16 {\n                    if i == j || (bits & 1 << j) == 0 { continue; }\n                    let newbits = bits ^ 1 << i ^ 1 << j ^ 1 << (i ^ j);\n                    let app = if (newbits & 1 << (i ^ j)) == 0 { 1 } else { 0 };\n                    mi = min(mi, dp[newbits] + 1 + app);\n                }\n            }\n            dp[bits] = mi;\n        }\n    }\n    dp\n}\n\nfn dfs(g: &[Vec<(usize, usize)>], v: usize, par: usize,\n       b: &mut [usize], mut acc: usize) {\n    for &(w, d) in &g[v] {\n        if w == par { continue; }\n        dfs(g, w, v, b, d);\n        acc ^= d;\n    }\n    b[v] = acc;\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        xya: [(usize, usize, usize); n - 1],\n    }\n    let tbl = make_table();\n    /*\n    for i in (0..16) {\n        let i = 2 * i;\n        for j in 0..5 {\n            if (i & 1 << j) != 0 {\n                eprint!(\"{} \", j);\n            }\n        }\n        eprintln!(\": {}\", tbl[i]);\n    }*/\n    let mut g = vec![vec![]; n];\n    for &(x, y, a) in &xya {\n        g[x].push((y, a));\n        g[y].push((x, a));\n    }\n    let mut b = vec![0; n];\n    dfs(&g, 0, n, &mut b, 0);\n    b[0] = 0;\n    let mut freq = [0; 16];\n    for &b in &b {\n        freq[b] += 1;\n    }\n    // eprintln!(\"b = {:?}\", b);\n    let mut tot = 0;\n    let mut rem = 0;\n    for i in 1..16 {\n        tot += freq[i] / 2;\n        if freq[i] % 2 == 1 {\n            rem |= 1 << i;\n        }\n    }\n    tot += tbl[rem];\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn make_table() -> Vec<usize> {\n    let mut dp = vec![0; 1 << 16];\n    for pc in 1..16 + 1 {\n        for bits in 0usize..1 << 16 {\n            if (bits & 1) == 1 || bits.count_ones() != pc { continue; }\n            let mut mi = 1 << 16;\n            for i in 0..16 {\n                if (bits & 1 << i) == 0 { continue; }\n                mi = min(mi, dp[bits ^ 1 << i] + 1);\n                for j in 0..16 {\n                    if i == j || (bits & 1 << j) == 0 { continue; }\n                    let newbits = bits ^ 1 << i ^ 1 << j ^ 1 << (i ^ j);\n                    let app = if (newbits & 1 << (i ^ j)) == 0 { 1 } else { 0 };\n                    mi = min(mi, dp[newbits] + 1 + app);\n                }\n            }\n            dp[bits] = mi;\n        }\n    }\n    dp\n}\n\nfn dfs(g: &[Vec<(usize, usize)>], v: usize, par: usize,\n       b: &mut [usize], mut acc: usize) {\n    for &(w, d) in &g[v] {\n        if w == par { continue; }\n        dfs(g, w, v, b, d);\n        acc ^= b[w];\n    }\n    b[v] = acc;\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        xya: [(usize, usize, usize); n - 1],\n    }\n    let tbl = make_table();\n    let mut g = vec![vec![]; n];\n    for &(x, y, a) in &xya {\n        g[x].push((y, a));\n        g[y].push((x, a));\n    }\n    let mut b = vec![0; n];\n    dfs(&g, 0, n, &mut b, 0);\n    b[0] = 0;\n    let mut freq = [0; 16];\n    for &b in &b {\n        freq[b] += 1;\n    }\n    let mut tot = 0;\n    let mut rem = 0;\n    for i in 1..16 {\n        tot += freq[i] / 2;\n        if freq[i] % 2 == 1 {\n            rem |= 1 << i;\n        }\n    }\n    tot += tbl[rem];\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let n = readl!(usize);\n    let mut dif = vec![0; n];\n    for _ in 0..n-1 {\n        let (a, b, c) = readl!(usize, usize, usize);\n        dif[a] ^= c;\n        dif[b] ^= c;\n    }\n\n    let mut imask = 0;\n    let mut iv = 0;\n    for i in 0..n {\n        if dif[i] != 0 {\n            if (imask>>dif[i])&1 == 1 {\n                iv += 1;\n            }\n            imask ^= 1<<(dif[i]);\n        }\n    }\n    let imask = imask;\n    let iv = iv;\n    let dma = dif.iter().map(|&x| x).max().unwrap()+1;\n    \n    let inf = 1_000_000_000;\n    let mut dp = vec![inf; 1<<dma];\n    // dp[imask] = iv;\n    dp[0] = 0;\n    for mask in 1..1<<dma {\n        let mut pmask = 0;\n        while pmask != mask {\n            let sx = (0..dma).fold(0, \n                |sum, x| if (pmask>>x)&1 == 1 {sum^x} else {sum});\n            if sx == 0 {\n                dp[mask] = std::cmp::min(dp[mask], dp[pmask]+(pmask^mask).count_ones()-1);\n            }\n            pmask = ((pmask as i64-mask as i64) & mask as i64) as usize;\n        }\n    }\n\n    printer.println(dp[imask]+iv);\n}\n\n"
  }
]