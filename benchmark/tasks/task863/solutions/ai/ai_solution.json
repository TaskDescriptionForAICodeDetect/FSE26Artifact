[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\n// Graph representation using adjacency list\ntypedef struct Edge {\n    int to;\n    int value;\n    struct Edge* next;\n} Edge;\n\n// Tree structure\ntypedef struct {\n    Edge* adj[MAX_N];\n    int parent[MAX_N];\n    int depth[MAX_N];\n} Tree;\n\n// Function to add an edge to the graph\nvoid addEdge(Tree* tree, int from, int to, int value) {\n    Edge* newEdge = malloc(sizeof(Edge));\n    newEdge->to = to;\n    newEdge->value = value;\n    newEdge->next = tree->adj[from];\n    tree->adj[from] = newEdge;\n}\n\n// DFS to set parent and depth\nvoid dfs(Tree* tree, int node, int par, int d) {\n    tree->parent[node] = par;\n    tree->depth[node] = d;\n\n    for (Edge* edge = tree->adj[node]; edge; edge = edge->next) {\n        if (edge->to != par) {\n            dfs(tree, edge->to, node, d + 1);\n        }\n    }\n}\n\n// Find lowest common ancestor\nint lca(Tree* tree, int u, int v) {\n    if (tree->depth[u] < tree->depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n\n    // Bring u to same depth as v\n    while (tree->depth[u] > tree->depth[v]) {\n        u = tree->parent[u];\n    }\n\n    // Move both up simultaneously\n    while (u != v) {\n        u = tree->parent[u];\n        v = tree->parent[v];\n    }\n\n    return u;\n}\n\n// Find the path between two vertices\nvoid findPath(Tree* tree, int u, int v, int* path, int* pathLen) {\n    int ancestor = lca(tree, u, v);\n    *pathLen = 0;\n\n    // Go from u to LCA\n    while (u != ancestor) {\n        path[(*pathLen)++] = u;\n        u = tree->parent[u];\n    }\n    path[(*pathLen)++] = ancestor;\n\n    // Store vertices from LCA to v in reverse order\n    int reversePath[MAX_N];\n    int reverseLen = 0;\n    while (v != ancestor) {\n        reversePath[reverseLen++] = v;\n        v = tree->parent[v];\n    }\n\n    // Append reverse path\n    for (int i = reverseLen - 1; i >= 0; i--) {\n        path[(*pathLen)++] = reversePath[i];\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Tree tree;\n    memset(&tree, 0, sizeof(Tree));\n\n    // Read edges\n    for (int i = 0; i < M; i++) {\n        int x, y, a;\n        scanf(\"%d %d %d\", &x, &y, &a);\n        addEdge(&tree, x, y, a);\n        addEdge(&tree, y, x, a);\n    }\n\n    // Precompute parent and depth\n    dfs(&tree, 0, -1, 0);\n\n    int operations = 0;\n    int xorValues[MAX_N] = {0};\n\n    // Process each edge\n    for (int u = 0; u < N; u++) {\n        for (Edge* edge = tree.adj[u]; edge; edge = edge->next) {\n            int v = edge->to;\n            if (u > v) continue;  // Avoid processing same edge twice\n\n            int path[MAX_N];\n            int pathLen;\n            findPath(&tree, u, v, path, &pathLen);\n\n            int pathXor = 0;\n            for (int j = 0; j < pathLen - 1; j++) {\n                pathXor ^= xorValues[path[j]];\n            }\n\n            int edgeValue = edge->value ^ pathXor;\n            if (edgeValue != 0) {\n                operations++;\n                xorValues[path[0]] ^= edgeValue;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", operations);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int to;\n    int a;\n    int next;\n} Edge;\n\nEdge edges[2 * MAX_N];\nint head[MAX_N];\nint edge_count = 0;\n\nint depth[MAX_N];\nint parent[MAX_N];\nint xor_sum[MAX_N];\nint a_original[MAX_N];\n\nvoid add_edge(int u, int v, int a) {\n    edges[edge_count].to = v;\n    edges[edge_count].a = a;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int p, int d) {\n    parent[u] = p;\n    depth[u] = d;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v != p) {\n            xor_sum[v] = xor_sum[u] ^ edges[i].a;\n            dfs(v, u, d + 1);\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n\n    for (int i = 0; i < N - 1; i++) {\n        int x, y, a;\n        scanf(\"%d %d %d\", &x, &y, &a);\n        add_edge(x, y, a);\n        add_edge(y, x, a);\n        a_original[i] = a;\n    }\n\n    memset(xor_sum, 0, sizeof(xor_sum));\n    dfs(0, -1, 0);\n\n    int xor_all = 0;\n    for (int i = 0; i < N - 1; i++) {\n        xor_all ^= a_original[i];\n    }\n\n    if (xor_all != 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int count = 0;\n    for (int i = 0; i < N - 1; i++) {\n        int u = edges[2 * i].to;\n        int v = edges[2 * i + 1].to;\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n        if (xor_sum[u] ^ xor_sum[v] == a_original[i]) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to, a;\n};\n\nvector<vector<Edge>> adj;\nvector<int> xor_sum;\nunordered_map<int, int> freq;\n\nvoid dfs(int u, int parent, int current_xor) {\n    xor_sum[u] = current_xor;\n    for (const Edge &e : adj[u]) {\n        if (e.to != parent) {\n            dfs(e.to, u, current_xor ^ e.a);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    adj.resize(N);\n    xor_sum.resize(N);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y, a;\n        cin >> x >> y >> a;\n        adj[x].push_back({y, a});\n        adj[y].push_back({x, a});\n    }\n\n    dfs(0, -1, 0);\n\n    for (int i = 1; i < N; ++i) {\n        freq[xor_sum[i]]++;\n    }\n\n    int operations = 0;\n    for (const auto &p : freq) {\n        if (p.first != 0) {\n            operations += min(p.second, freq[0] + 1);\n        }\n    }\n\n    cout << operations << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeXOROperations {\n    static class Edge {\n        int to, a, rev;\n        Edge(int to, int a, int rev) {\n            this.to = to;\n            this.a = a;\n            this.rev = rev;\n        }\n    }\n\n    static List<List<Edge>> tree;\n    static int[] parent;\n    static int[] depth;\n    static int[] xor;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        tree = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int a = scanner.nextInt();\n            tree.get(x).add(new Edge(y, a, tree.get(y).size()));\n            tree.get(y).add(new Edge(x, a, tree.get(x).size() - 1));\n        }\n\n        parent = new int[N];\n        depth = new int[N];\n        xor = new int[N];\n        Arrays.fill(parent, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        parent[0] = -1;\n        depth[0] = 0;\n        xor[0] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (Edge e : tree.get(u)) {\n                if (parent[e.to] == -1 && e.to != parent[u]) {\n                    parent[e.to] = u;\n                    depth[e.to] = depth[u] + 1;\n                    xor[e.to] = xor[u] ^ e.a;\n                    queue.add(e.to);\n                }\n            }\n        }\n\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int i = 1; i < N; i++) {\n            freq.put(xor[i], freq.getOrDefault(xor[i], 0) + 1);\n        }\n\n        int operations = 0;\n        for (int val : freq.keySet()) {\n            int cnt = freq.get(val);\n            if (val == 0) {\n                continue;\n            }\n            if (cnt >= 2) {\n                operations += cnt - 1;\n            } else {\n                operations += 1;\n            }\n        }\n\n        System.out.println(operations);\n    }\n}",
    "timestamp": "2025-08-05 23:10:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private List<List<int[]>> graph;\n    private int[] parent;\n    private int[] rank;\n\n    public int minimumOperations(int N, int[][] edges) {\n        graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        parent = new int[N];\n        rank = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n        }\n\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            graph.get(u).add(new int[]{v, w});\n            graph.get(v).add(new int[]{u, w});\n        }\n\n        boolean[] visited = new boolean[N];\n        int operations = 0;\n\n        for (int i = 0; i < N; i++) {\n            if (!visited[i]) {\n                operations += dfs(i, visited, 0);\n            }\n        }\n\n        return operations;\n    }\n\n    private int dfs(int node, boolean[] visited, int xorSum) {\n        visited[node] = true;\n        int operations = 0;\n\n        for (int[] neighbor : graph.get(node)) {\n            int v = neighbor[0], edgeValue = neighbor[1];\n            \n            if (!visited[v]) {\n                int newXorSum = xorSum ^ edgeValue;\n                operations += dfs(v, visited, newXorSum);\n            } else {\n                int requiredXor = xorSum ^ edgeValue;\n                if (requiredXor != 0) {\n                    operations++;\n                }\n            }\n        }\n\n        return operations;\n    }\n}",
    "timestamp": "2025-08-05 23:11:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nvector<pair<int, int>> graph[MAXN];\nint edge_values[MAXN];\nint parent[MAXN], depth[MAXN];\n\nvoid dfs(int node, int par, int d) {\n    parent[node] = par;\n    depth[node] = d;\n    for (auto& [child, edge_idx] : graph[node]) {\n        if (child != par) {\n            dfs(child, node, d + 1);\n        }\n    }\n}\n\nvector<int> get_path(int u, int v) {\n    vector<int> path_u, path_v;\n    while (u != v) {\n        if (depth[u] > depth[v]) {\n            path_u.push_back(u);\n            u = parent[u];\n        } else {\n            path_v.push_back(v);\n            v = parent[v];\n        }\n    }\n    path_u.push_back(u);\n    reverse(path_v.begin(), path_v.end());\n    \n    for (int node : path_v) {\n        path_u.push_back(node);\n    }\n    \n    return path_u;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int N, M;\n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int x, y, a;\n        cin >> x >> y >> a;\n        x--; y--;\n        graph[x].emplace_back(y, i);\n        graph[y].emplace_back(x, i);\n        edge_values[i] = a;\n    }\n    \n    dfs(0, -1, 0);\n    \n    int operations = 0;\n    \n    for (int i = 0; i < M; i++) {\n        if (edge_values[i] != 0) {\n            int u = graph[i].first, v = graph[i].second;\n            vector<int> path = get_path(u, v);\n            \n            int path_xor = 0;\n            for (int j = 1; j < path.size(); j++) {\n                int curr = path[j], prev = path[j-1];\n                for (auto& [child, edge_idx] : graph[prev]) {\n                    if (child == curr) {\n                        path_xor ^= edge_values[edge_idx];\n                        break;\n                    }\n                }\n            }\n            \n            if (path_xor != edge_values[i]) {\n                operations++;\n                for (int j = 1; j < path.size(); j++) {\n                    int curr = path[j], prev = path[j-1];\n                    for (auto& [child, edge_idx] : graph[prev]) {\n                        if (child == curr) {\n                            edge_values[edge_idx] ^= path_xor;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << operations << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_operations(N, edges):\n    from collections import defaultdict, deque\n\n    def bfs(root, edges):\n        queue = deque([root])\n        visited = [-1] * N\n        visited[root] = 0\n        parent = [-1] * N\n        xor_from_root = [0] * N\n        while queue:\n            node = queue.popleft()\n            for neighbor, edge_value in edges[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    xor_from_root[neighbor] = xor_from_root[node] ^ edge_value\n                    queue.append(neighbor)\n        return xor_from_root, parent\n\n    graph = defaultdict(list)\n    for x, y, a in edges:\n        graph[x].append((y, a))\n        graph[y].append((x, a))\n\n    xor_from_root, parent = bfs(0, graph)\n    xor_basis = []\n\n    for node in range(1, N):\n        current_xor = xor_from_root[node]\n        for b in xor_basis:\n            current_xor = min(current_xor, current_xor ^ b)\n\n        if current_xor != 0:\n            xor_basis.append(current_xor)\n\n    return len(xor_basis)\n\n# Sample usage:\n# N = number of vertices\n# edges = [(x_0, y_0, a_0), (x_1, y_1, a_1), ..., (x_(N-2), y_(N-2), a_(N-2))]\n\nN = 4\nedges = [(0, 1, 3), (1, 2, 4), (2, 3, 7)]\n# The function call would be:\nprint(minimum_operations(N, edges))",
    "timestamp": "2025-08-13 13:55:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeOperations {\n    static class Edge {\n        int from, to, value;\n\n        Edge(int from, int to, int value) {\n            this.from = from;\n            this.to = to;\n            this.value = value;\n        }\n    }\n\n    private static int dfs(int node, int parent, List<Edge>[] tree, boolean[] visited, int[] group) {\n        visited[node] = true;\n        int changes = 0;\n        for (Edge edge : tree[node]) {\n            int nextNode = edge.to == node ? edge.from : edge.to;\n            if (nextNode == parent || visited[nextNode]) continue;\n            int groupValue = group[node] ^ edge.value;\n            if (groupValue != 0) {\n                changes++;\n                group[nextNode] = group[node] ^ edge.value;\n            } else {\n                group[nextNode] = group[node];\n            }\n            changes += dfs(nextNode, node, tree, visited, group);\n        }\n        return changes;\n    }\n\n    public static int minOperationsToZeroEdges(int N, int[][] edges) {\n        List<Edge>[] tree = new ArrayList[N];\n        for (int i = 0; i < N; ++i) {\n            tree[i] = new ArrayList<>();\n        }\n\n        for (int[] edge : edges) {\n            int from = edge[0];\n            int to = edge[1];\n            int value = edge[2];\n            tree[from].add(new Edge(from, to, value));\n            tree[to].add(new Edge(to, from, value));\n        }\n\n        boolean[] visited = new boolean[N];\n        int[] group = new int[N];\n        return dfs(0, -1, tree, visited, group);\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[][] edges = {\n            {0, 1, 1},\n            {1, 2, 1},\n            {2, 3, 1},\n            {3, 4, 1}\n        };\n        System.out.println(minOperationsToZeroEdges(N, edges)); // Expected output depends on specific implementation\n    }\n}",
    "timestamp": "2025-08-13 13:55:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100010\n\ntypedef struct {\n    int v, nxt;\n    int weight;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN], edge_cnt;\n\nvoid add_edge(int u, int v, int w) {\n    edges[edge_cnt].v = v;\n    edges[edge_cnt].weight = w;\n    edges[edge_cnt].nxt = head[u];\n    head[u] = edge_cnt++;\n}\n\nint dfs(int u, int p, int xor_value, int* xor_from_root, int* visited) {\n    if (visited[u]) return 0;\n    visited[u] = 1;\n    xor_from_root[u] = xor_value;\n\n    for (int i = head[u]; i != -1; i = edges[i].nxt) {\n        int v = edges[i].v;\n        int weight = edges[i].weight;\n        if (v == p) continue;\n        if (!visited[v]) {\n            if (dfs(v, u, xor_value ^ weight, xor_from_root, visited))\n                return 1;\n        } else {\n            if ((xor_value ^ xor_from_root[v] ^ weight) != 0)\n                return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    memset(head, -1, sizeof(head));\n    edge_cnt = 0;\n\n    for (int i = 0; i < N-1; ++i) {\n        int x, y, a;\n        scanf(\"%d %d %d\", &x, &y, &a);\n        add_edge(x, y, a);\n        add_edge(y, x, a);\n    }\n\n    int xor_from_root[MAXN], visited[MAXN];\n    memset(xor_from_root, -1, sizeof(xor_from_root));\n    memset(visited, 0, sizeof(visited));\n\n    if (dfs(0, -1, 0, xor_from_root, visited))\n        printf(\"-1\\n\");\n    else\n        printf(\"0\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:55:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<pair<int, int>> adj[MAXN];\nint value[MAXN];\nbool visited[MAXN];\nvector<tuple<int, int, int>> edges;\n\nvoid dfs(int u, int par) {\n    visited[u] = true;\n    for (auto &v : adj[u]) {\n        if (v.first == par) continue;\n        if (!visited[v.first]) {\n            value[v.first] = value[u] ^ v.second;\n            dfs(v.first, u);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; ++i) {\n        int x, y, a;\n        cin >> x >> y >> a;\n        adj[x].push_back({y, a});\n        adj[y].push_back({x, a});\n        edges.push_back({x, y, a});\n    }\n\n    dfs(0, -1);\n\n    vector<int> basis;\n\n    auto insert_basis = [&](int mask) {\n        for (int b : basis) mask = min(mask, mask ^ b);\n        if (mask == 0) return false;\n        basis.push_back(mask);\n        sort(basis.begin(), basis.end(), greater<int>());\n        for (int i = 1; i < basis.size(); ++i) {\n            for (int j = 0; j < i; ++j) {\n                basis[i] = min(basis[i], basis[i] ^ basis[j]);\n            }\n        }\n        return true;\n    };\n\n    for (auto &[x, y, a] : edges) {\n        int xor_path = value[x] ^ value[y] ^ a;\n        insert_basis(xor_path);\n    }\n\n    cout << basis.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:55:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_tree_edge_zeroing(N, edges):\n    # Create adjacency list representation of the tree\n    graph = defaultdict(list)\n    for x, y, a in edges:\n        graph[x].append((y, a))\n        graph[y].append((x, a))\n    \n    # Track visited nodes and parent mapping\n    visited = [False] * N\n    parent = [None] * N\n    \n    # Perform depth-first traversal to track parents\n    def dfs(node, prev=None):\n        visited[node] = True\n        parent[node] = prev\n        for neighbor, _ in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node)\n    \n    dfs(0)\n    \n    # Track operations needed\n    operations = 0\n    \n    # Process each edge\n    for x, y, initial_value in edges:\n        # Find path between x and y\n        path_x = []\n        current = x\n        while current is not None:\n            path_x.append(current)\n            current = parent[current]\n        \n        path_y = []\n        current = y\n        while current is not None:\n            path_y.append(current)\n            current = parent[current]\n        \n        # Find lowest common ancestor\n        path_x.reverse()\n        path_y.reverse()\n        lca_index = 0\n        while (lca_index < len(path_x) and lca_index < len(path_y) and \n               path_x[lca_index] == path_y[lca_index]):\n            lca_index += 1\n        lca_index -= 1\n        \n        # Calculate XOR path value\n        path_value = initial_value\n        for node in path_x[lca_index:]:\n            path_value ^= node\n        for node in reversed(path_y[lca_index:]):\n            path_value ^= node\n        \n        # If path value is non-zero, we need an operation\n        if path_value != 0:\n            operations += 1\n    \n    return operations\n\n# Example usage\nN = 5\nedges = [(0, 1, 3), (1, 2, 5), (2, 3, 7), (3, 4, 2)]\nresult = solve_tree_edge_zeroing(N, edges)\nprint(result)",
    "timestamp": "2025-08-13 13:55:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N)]\n    edges = []\n    for _ in range(N-1):\n        x, y, a = map(int, sys.stdin.readline().split())\n        adj[x].append((y, len(edges)))\n        adj[y].append((x, len(edges)))\n        edges.append(a)\n    \n    parent = [-1] * N\n    depth = [0] * N\n    edge_to_parent = [-1] * N  # edge index to parent\n    stack = [(0, -1)]\n    while stack:\n        u, p = stack.pop()\n        for v, idx in adj[u]:\n            if v != p:\n                parent[v] = u\n                depth[v] = depth[u] + 1\n                edge_to_parent[v] = idx\n                stack.append((v, u))\n    \n    cnt = [0] * (N - 1)\n    for u in range(1, N):\n        idx = edge_to_parent[u]\n        cnt[idx] = edges[idx]\n    \n    xor = [0] * N\n    stack = [(0, -1)]\n    while stack:\n        u, p = stack.pop()\n        for v, idx in adj[u]:\n            if v != p:\n                xor[v] = xor[u] ^ edges[idx]\n                stack.append((v, u))\n    \n    freq = defaultdict(int)\n    for num in xor:\n        freq[num] += 1\n    \n    res = 0\n    for u in range(1, N):\n        idx = edge_to_parent[u]\n        if cnt[idx] != 0:\n            x = cnt[idx]\n            res += 1\n            stack = [(u, x)]\n            while stack:\n                node, val = stack.pop()\n                for v, edge_idx in adj[node]:\n                    if v != parent[node]:\n                        if cnt[edge_idx] == val:\n                            cnt[edge_idx] = 0\n                            stack.append((v, val))\n                        elif cnt[edge_idx] != 0:\n                            cnt[edge_idx] ^= val\n            cnt[idx] = 0\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 13:55:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumOperations(N, edges) {\n    const adjList = Array.from({ length: N }, () => []);\n    const edgeValues = {};\n\n    for (const [x, y, a] of edges) {\n        adjList[x].push([y, a]);\n        adjList[y].push([x, a]);\n        edgeValues[`${Math.min(x, y)}-${Math.max(x, y)}`] = a;\n    }\n\n    let xorSum = 0;\n    const visited = Array(N).fill(false);\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const [neighbor, edgeValue] of adjList[node]) {\n            const key = `${Math.min(node, neighbor)}-${Math.max(node, neighbor)}`;\n            if (!visited[neighbor]) {\n                xorSum ^= edgeValues[key];\n                dfs(neighbor);\n            }\n        }\n    }\n\n    dfs(0);\n\n    // In a tree, we need exactly one operation for the entire XOR path\n    return xorSum === 0 ? 0 : 1;\n}\n\n// Usage\nconst N = 5;\nconst edges = [\n    [0, 1, 1],\n    [0, 2, 3],\n    [1, 3, 2],\n    [2, 4, 4],\n];\n\nconsole.log(minimumOperations(N, edges)); // Example usage",
    "timestamp": "2025-08-13 13:56:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumOperations(N, edges, values) {\n    const graph = Array.from({ length: N }, () => []);\n    const edgeMap = new Map();\n    \n    for (let i = 0; i < edges.length; i++) {\n        const [x, y] = edges[i];\n        graph[x].push(y);\n        graph[y].push(x);\n        edgeMap.set(`${x},${y}`, values[i]);\n        edgeMap.set(`${y},${x}`, values[i]);\n    }\n    \n    const visited = new Array(N).fill(false);\n    let operations = 0;\n    \n    function dfs(node) {\n        visited[node] = true;\n        let nodeXor = 0;\n        \n        for (const neighbor of graph[node]) {\n            if (!visited[neighbor]) {\n                const edgeValue = edgeMap.get(`${node},${neighbor}`);\n                const childXor = dfs(neighbor);\n                \n                if ((edgeValue ^ childXor) !== 0) {\n                    operations++;\n                    nodeXor ^= edgeValue;\n                }\n            }\n        }\n        \n        return nodeXor;\n    }\n    \n    dfs(0);\n    \n    return operations;\n}",
    "timestamp": "2025-08-13 13:56:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    let ptr = 0;\n    const N = parseInt(input[ptr++], 10);\n    const adj = Array.from({ length: N }, () => []);\n    const edges = [];\n    for (let i = 0; i < N - 1; i++) {\n        const [x, y, a] = input[ptr++].split(' ').map(Number);\n        adj[x].push({ to: y, a, index: i });\n        adj[y].push({ to: x, a, index: i });\n        edges.push({ x, y, a });\n    }\n\n    const parent = new Array(N).fill(-1);\n    const depth = new Array(N).fill(0);\n    const xor = new Array(N).fill(0);\n    const stack = [{ node: 0, parent: -1, currentXor: 0 }];\n\n    while (stack.length > 0) {\n        const { node, parent: p, currentXor } = stack.pop();\n        parent[node] = p;\n        xor[node] = currentXor;\n        for (const { to, a } of adj[node]) {\n            if (to !== p) {\n                depth[to] = depth[node] + 1;\n                stack.push({ node: to, parent: node, currentXor: currentXor ^ a });\n            }\n        }\n    }\n\n    const edgeXor = new Array(N - 1).fill(0);\n    for (let i = 0; i < N - 1; i++) {\n        const { x, y, a } = edges[i];\n        if (depth[x] > depth[y]) {\n            edgeXor[i] = xor[x] ^ xor[y];\n        } else {\n            edgeXor[i] = xor[y] ^ xor[x];\n        }\n    }\n\n    const basis = new Array(30).fill(0);\n    let rank = 0;\n\n    const insert = (x) => {\n        let xCopy = x;\n        for (let i = 29; i >= 0; i--) {\n            if ((xCopy >> i) & 1) {\n                if (!basis[i]) {\n                    basis[i] = xCopy;\n                    rank++;\n                    return;\n                }\n                xCopy ^= basis[i];\n            }\n        }\n    };\n\n    for (const a of edgeXor) {\n        insert(a);\n    }\n\n    console.log(rank);\n};\n\nsolve();",
    "timestamp": "2025-08-13 13:56:21"
  }
]