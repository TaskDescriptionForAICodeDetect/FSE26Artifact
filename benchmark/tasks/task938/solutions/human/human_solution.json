[
  {
    "language": "Crystal",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.to_s.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.to_s.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.to_s.chomp.split(\" \").map{|u|u.to_i}end\nn = inp[0]\nl = na(0)\nr = na(0)\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,501,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  len = rr-ll\n  x = 1\n    (1..(len)).each do |j|\n    min = dp[i-1][0..(len)].min + (ll-1)\n    dp[i][j] = min\n  end\n  ((len+1)..(rr-1)).each do |j|\n    dp[i][x] = dp[i-1][x..j].min + (rr - j )\n\n        x+=1\n  end\n  min = dp[i-1][ll..rr].min\n  (ll..(rr)).each do |j|\n    dp[i][j] = min\n  end\n    x =ll+1\n  ((rr+1)..(500)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][(x)..j].min + ind\n    x += 1\n  end\nend\np dp\ndp[n].delete_at(0)\np dp[n].min"
  },
  {
    "language": "Crystal",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.to_s.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.to_s.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.to_s.chomp.split(\" \").map{|u|u.to_i}end\nn = inp[0]\nl = na(0)\nr = na(0)\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,11,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  len = rr-ll\n  x = 1\n    (1..(len)).each do |j|\n    min = dp[i-1][0..(len)].min + (ll-1)\n    dp[i][j] = min\n  end\n  ((len+1)..(rr-1)).each do |j|\n    dp[i][x] = dp[i-1][x..j].min + (rr - j )\n\n        x+=1\n  end\n  min = dp[i-1][ll..rr].min\n  (ll..(rr)).each do |j|\n    dp[i][j] = min\n  end\n    x =ll+1\n  ((rr+1)..(10)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][(x)..j].min + ind\n    x += 1\n  end\nend\np dp\ndp[n].delete_at(0)\np dp[n].min"
  },
  {
    "language": "Crystal",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.to_s.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.to_s.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.to_s.chomp.split(\" \").map{|u|u.to_i}end\nn = inp[0]\nl = na(0)\nr = na(0)\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,501,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  len = rr-ll\n  x = 0\n    (0..(len)).each do |j|\n    min = dp[i-1][0..len].min + (ll - len)\n    dp[i][j] = min\n  end\n  ((len)..(ll-1)).each do |j|\n    dp[i][j] = dp[i-1][x..j].min + (ll - j + len)\n    x+=1\n  end\n  min = dp[i-1][ll..rr].min\n  (ll..(rr)).each do |j|\n    dp[i][j] = min\n  end\n    x =ll\n  ((rr+1)..(500)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][x..j].min + ind\n    x += 1\n  end\nend\n\ndp[n].delete_at(0)\np dp[n].min"
  },
  {
    "language": "Crystal",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.to_s.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.to_s.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.to_s.chomp.split(\" \").map{|u|u.to_i}end\nn = inp[0]\nl = na(0)\nr = na(0)\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,501,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  len = rr-ll\n  x = 1\n    (1..(len)).each do |j|\n    min = dp[i-1][0..(len)].min + (ll-1)\n    dp[i][j] = min\n  end\n  ((len+1)..(rr-1)).each do |j|\n    dp[i][x] = dp[i-1][x..j].min + (rr - j )\n\n        x+=1\n  end\n  min = dp[i-1][ll..rr].min\n  (ll..(rr)).each do |j|\n    dp[i][j] = min\n  end\n    x =ll+1\n  ((rr+1)..(500)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][(x)..j].min + ind\n    x += 1\n  end\nend\ndp[n].delete_at(0)\np dp[n].min"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n;\n  R n;\n  P a[n];\n  rep(i,n) cin >> a[i].F >> a[i].S;\n  sort(a,a+n);\n  ll ans=MAX;\n  rep(k,n) {\n    rep(t,401) {\n      ll x=a[k].S+t,y=a[k].F+t,sum=t;\n      rep(i,n) {\n        if(i==k) continue;\n        if(x<a[i].F) {\n          sum+=a[i].F-x;\n          x+=a[i].S-a[i].F;\n        } else if(a[i].S<y) {\n          sum+=y-a[i].S;\n          y-=a[i].S-a[i].F;\n        } else if(y<=a[i].F) x=max(x,(ll)a[i].S);\n        else y=min(y,(ll)a[i].F);\n      }\n      ans=min(ans,sum);\n    }\n  }\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=100005;\nint n,l[max_n],r[max_n];\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d%d\",l+i,r+i);\n    multiset<ll> L,R;\n    ll ans=0;\n    L.insert(l[1]),R.insert(l[1]);\n    ll sl=0,sr=0;\n    for(int i=2;i<=n;i++){\n        sl-=r[i]-l[i];\n        sr+=r[i-1]-l[i-1];\n        ll xl=sl+*L.rbegin(),xr=sr+*R.begin();\n        if(l[i]<=xl){\n            ans+=xl-l[i];\n            L.erase(L.find(xl-sl));\n            R.insert(xl-sr);\n            L.insert(l[i]-sl);\n            L.insert(l[i]-sl);\n        }\n        else if(l[i]>=xr){\n            ans+=l[i]-xr;\n            R.erase(R.find(xr-sr));\n            L.insert(xr-sl);\n            R.insert(l[i]-sr);\n            R.insert(l[i]-sr);\n        }\n        else{\n            L.insert(l[i]-sl);\n            R.insert(l[i]-sr);\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\n\nint N;\nint L[100000], R[100000]; // small 400\nint D[100000];\n\nint main() {\n    cin >> N;\n    rep(i, N){\n        cin >> L[i] >> R[i];\n    }\n    rep(i, N){\n        D[i] = 0;\n    }\n\n    // run\n    while(true){\n\n        bool flag = false;\n        rep(i, N){\n            bool c1 = D[i] < L[i];\n            bool c2 = (i == 0)   || (D[i]+1) <= D[i-1] + (R[i-1] - L[i-1]);\n            bool c3 = (i == N-1) || (D[i]+1) <= D[i+1] + (R[i+1] - L[i+1]);\n            if(c1 && c2 && c3){\n                D[i]++;\n                flag = true;\n            }\n        }\n\n        if(!flag) break;\n    }\n\n    ll ret = 0;\n    rep(i, N){\n        ret += abs(D[i] - L[i]);\n        // cerr << D[i] << endl;\n    }\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint main () {\n    int N;\n    cin >> N;\n    vector<int> l(N);\n    vector<int> r(N);\n    int lmax = 0, rmax = 0;\n    REP (i, 0, N) cin >> l[i] >> r[i];\n    REP (i, 0, N) {\n        lmax = max(lmax, l[i]);\n        rmax = max(rmax, r[i]);\n    }\n\n    if (rmax > 400) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int ans = 1 << 30;\n\n    REP (i, 0, rmax + 1) {\n        int temp = 0;\n        REP (j, 0, N) {\n            if (i < l[j]) {\n                temp += (l[j] - i);\n            } else if (r[j] < i) {\n                temp += (i - r[j]);\n            }\n        }\n        ans = min(ans, temp);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\nlong double pi=3.14159265358979323846L;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll gya[1000010];\nll kai[1000010];\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    ll n;cin>>n;\n    ll l[n+1],r[n+1];\n    ll ans=0;\n    rep(i,1,n+1){\n        cin>>l[i]>>r[i];\n    }\n    l[0]=-inf;r[0]=inf;\n    ll gel[n+1],ger[n+1];\n    rep(i,0,n+1){\n        gel[i]=l[i];\n        ger[i]=r[i];\n    }\n    for(int i=1;i<=n;i+=1){\n        if(i%2==1){\n            if(r[i]<l[i-1]){\n                ans+=l[i-1]-r[i];\n                l[i]+=l[i-1]-r[i];\n                r[i]=l[i-1];\n                gel[i]=l[i];\n                ger[i]=r[i-1]+r[i]-l[i];\n            }\n            else if(l[i]>r[i-1]){\n                ans+=l[i]-r[i-1];\n                r[i]-=l[i]-r[i-1];\n                l[i]=r[i-1];\n                ger[i]=r[i];\n                gel[i]=l[i-1]-(r[i]-l[i]);\n            }\n            else{\n                ll f=l[i],g=r[i];\n                gel[i]-=g-l[i-1];\n                ger[i]+=r[i-1]-f;\n            }\n        }\n        else{\n            if(l[i]<l[i-1]){\n            if(r[i]<l[i-1]){\n                ans+=l[i-1]-r[i];\n                if(r[i]<gel[i-1]){\n                    l[i]+=gel[i-1]-r[i];\n                }\n                r[i]=l[i-1];\n                \n            }\n        }\n        else{\n            if(r[i-1]<l[i]){\n                ans+=l[i]-r[i-1];\n                if(l[i]>ger[i-1]){\n                    r[i]-=l[i]-ger[i-1];\n                }\n                l[i]=r[i-1];\n            }\n        }\n        }\n        //rep(j,1,3)cout<<l[j]<<\" \"<<r[j]<<endl;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <queue> \nusing namespace std;\nconst int N=100001;\nint n,minn;\nstruct node\n{\n    int l;\n    int r;\n    int len;\n}p[N];\nint dp[401][401];//第i层的左端点在j \nint main()\n{\n    int i,j,k;\n    cin>>n;\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%d %d\",&p[i].l,&p[i].r);\n        p[i].len=(p[i].r-p[i].l);\n    }\n    memset(dp,0x7f,sizeof(dp));\n    minn=dp[0][0];\n    for(i=1;i<=n;i++)\n        dp[1][i]=abs(p[1].l-i);\n    for(i=2;i<=n;i++)\n    {\n        for(j=1;j<=400;j++)\n            for(k=1;k<=400;k++)\n            {\n                if((j>k+p[i-1].len)||(k>j+p[i].len))    continue; \n                dp[i][j]=min(dp[i][j],dp[i-1][k]+abs(j-p[i].l));\n            }\n    }\n    for(i=1;i<=400;i++)\n        minn=min(minn,dp[n][i]);\n    cout<<minn;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst string filename = \"test\";\n\n#define int long long\n\ntypedef pair<int, int> ii;\nconst int infinity = 1e18;\n\nint number;\nii segment[100001];\nint f[401][401];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> number;\n\tfor (int i = 1; i <= number; i++)\n\t{\n\t\tcin >> segment[i].first >> segment[i].second;\n\t\tif (segment[i].first > 400 || segment[i].second > 400) while(1){}\n\t}\t\n\tfor (int i = 0; i <= 400; i++)\n\t\tfor (int j = 0; j <= 400; j++)\n\t\t\tf[i][j] = infinity;\n\tfor (int j = 1; j <= 400; j++)\t\n\t{\n\t\tint l = segment[1].first, r = segment[1].second;\n\t\tf[1][j] = max(l - j, j - l);\n\t}\n\tfor (int i = 2; i <= number; i++)\n\t{\n\t\tfor (int j = 1; j <= 400; j++)\n\t\t{\n\t\t\tint l = segment[i].first, r = segment[i].second;\n\t\t\tint cost = max(l - j, j - l);\n\t\t\tint cur_length = r - l;\n\t\t\tint pre_length = segment[i - 1].second - segment[i - 1].first;\n\t\t\tfor (int k = max(1LL, j - pre_length); k <= min(400LL, j + cur_length); k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[i - 1][k] + cost);\n\t\t}\n\t}\n\n\tint answer = infinity;\n\tfor (int i = 1; i <= 400; i++)\n\t\tanswer = min(answer, f[number][i]);\n\tcout << answer;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\nusing namespace std;\n#define lowbit(x) ((x)&(-x))\nconst int maxn = 400 + 50;\nint n , dp[maxn][maxn] , l[maxn] , r[maxn];\n\nbool Connect( int l1 , int r1 , int l2 , int r2 ){\n\tif( l1 > l2 )\n\t\tswap( l1 , l2 ) , swap( r1 , r2 );\n\treturn l2 <= r1 ;\n}\n\nint main( int argc , char * argv[] ){\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tl[i] = read() , r[i] = read();\n\tlong long ans = 1e18;\n\tfor(int fix = 1 ; fix <= n ; ++ fix){\n\t\tint prel = l[fix] , prer = r[fix];\n\t\tlong long cost = 0;\n\t\tfor(int up = fix + 1 ; up <= n ; ++ up)\n\t\t\tif( Connect( prel , prer , l[up] , r[up] ) )\n\t\t\t\tprel = l[up] , prer = r[up];\n\t\t\telse{\n\t\t\t\tif( l[up] > prer ){\n\t\t\t\t\tcost += l[up] - prer;\n\t\t\t\t\tprel = prer , prer = prel + r[up] - l[up];\n\t\t\t\t}else{\n\t\t\t\t\tcost += prel - r[up];\n\t\t\t\t\tprer = prel , prel = prer - (r[up] - l[up]);\n\t\t\t\t}\n\t\t\t}\n\t\tprel = l[fix] , prer = r[fix];\n\t\tfor(int down = fix - 1 ; down >= 1 ; -- down)\n\t\t\tif( Connect( prel , prer , l[down] , r[down] ) )\n\t\t\t\tprel = l[down] , prer = r[down];\n\t\t\telse{\n\t\t\t\tif( l[down] > prer ){\n\t\t\t\t\tcost += l[down] - prer;\n\t\t\t\t\tprel = prer , prer = prel + r[down] - l[down];\n\t\t\t\t}else{\n\t\t\t\t\tcost += prel - r[down];\n\t\t\t\t\tprer = prel , prel = prer - (r[down] - l[down]);\n\t\t\t\t}\n\t\t\t}\n\t\tans = min( ans , cost );\n\t}\n\tprintf( \"%lld\\n\" , ans );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <cmath>\n#include <iostream>\nusing namespace std;\n\nint _left[405];\nint _right[405];\nint dp[405][405];\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++ i) {\n        cin >> _left[i] >> _right[i];\n    }\n    for (int i = 0; i <= 400; ++ i) {\n        dp[1][i] = abs(_left[1] - i);\n    }\n    for (int i = 2; i <= n; ++ i) {\n        for (int j = 0; j <= 400; ++ j) {\n            dp[i][j] = 1.e9;\n            for (int k = max(0, j - (_right[i - 1] - _left[i - 1])); k <= min(j + _right[i] - _left[i], 400); ++ k) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(_left[i] - j));\n            }\n        }\n    }\n    \n    cout << *min_element(dp[n], dp[n] + 401) << \"\\n\";\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\tint n;\n\tvector<int> l, r;\n\tfor (int i=0; i<n; i++) {\n\t\tint l_, r_; cin >> l_, r_;\n\t\tl.push_back(l_);\n\t\tr.push_back(r_);\n\t}\n\tif(n > 400){\n\t\treturn 0;\n\t}\n\tlong min_loss = -1;\n\tint loss_pos = -1;\n\tfor(int i=1; i<=400;i++){\n\t\tlong loss = 0;\n\t\tfor (int j=0; j < n; j++) {\n\t\t\tif (r[j] < i) {\n\t\t\t\tloss += i - r[j];\n\t\t\t} else if (l[j] > i) {\n\t\t\t\tloss += l[j] - i;\n\t\t\t}\n\t\t}\n\t\tif (loss < min_loss || loss_pos == -1) {\n\t\t\tloss_pos = i;\n\t\t\tmin_loss = loss;\n\t\t}\n\t}\n\tcout << min_loss << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int N = 5e5 + 5;\n\nint n, l[N], r[N], len[N];\n\ntemplate <class T>\nstruct shift_pq {\n  T Q;\n  ll total;\n  shift_pq() : total(0) {}\n\n  void shift(ll X) {\n    total += X;\n  }\n  void push(ll X) {\n    Q.push(X - total);\n  }\n  void pop() {\n    Q.pop();\n  }\n  ll top() {\n    return Q.top() + total;\n  }\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"in\", \"r\", stdin);\n#endif\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d %d\", &l[i], &r[i]);\n    len[i] = r[i] - l[i] + 1;\n  }\n\n  shift_pq<priority_queue<ll>> L;\n  shift_pq<priority_queue<ll, vector<ll>, greater<ll>>> R;\n\n  ll ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    L.shift(-(len[i - 1] - 1));\n    R.shift(len[i] - 1);\n\n    L.push(r[i]);\n    R.push(r[i]);\n\n    if (r[i] < L.top()) {\n      ans += L.top() - r[i];\n      L.push(r[i]);\n      R.push(L.top());\n      L.pop();\n      R.pop();\n    } else if (r[i] > R.top()) {\n      ans += r[i] - R.top();\n      R.push(r[i]);\n      L.push(R.top());\n      L.pop();\n      R.pop();\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n#include<valarray>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\nint n;\nint l[112345], r[112345], x[112345];\n\n/// --- Treap Sequence Library {{{ ///\n#include <cstdint>\n#include <utility>\n\ntemplate < class M_act >\nstruct TreapSeq {\nprivate:\n  using u32 = uint_fast32_t;\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n  TreapSeq *l = nullptr, *r = nullptr;\n  X val;\n  X accum = Monoid::identity();\n  M lazy = M_act::identity();\n  bool rev = false;\n  int sz = 1;\n  u32 pri;\n  // call after touch its child\n  // a is not nullptr and is evaled, its child is proped\n  friend TreapSeq *prop(TreapSeq *a) {\n    a->sz = size(a->l) + 1 + size(a->r);\n    a->accum = Monoid::op(Monoid::op(Accumulated(a->l), a->val), Accumulated(a->r));\n    return a;\n  }\n  // call before use val, accum\n  friend void eval(TreapSeq *a) {\n    // if(a->lazy != M_act::identity()) {\n      a->val = M_act::actInto(a->lazy, 1, a->val);\n      a->accum = M_act::actInto(a->lazy, a->sz, a->accum);\n      if(a->l != nullptr) a->l->lazy = M_act::op(a->lazy, a->l->lazy);\n      if(a->r != nullptr) a->r->lazy = M_act::op(a->lazy, a->r->lazy);\n      a->lazy = M_act::identity();\n    // }\n    if(a->rev) {\n      swap(a->l, a->r);\n      if(a->l != nullptr) a->l->rev ^= 1;\n      if(a->r != nullptr) a->r->rev ^= 1;\n      a->rev = false;\n    }\n  }\n  friend X Accumulated(TreapSeq *a) {\n    return a == nullptr ? Monoid::identity() : (eval(a), a->accum);\n  }\n  /// --- XorShift128 Embeddable {{{ ///\n\n  struct XorShift128Embeddable {\n    using result_type = uint_fast32_t;\n    static constexpr result_type min() { return 0; }\n    static constexpr result_type max() { return 0xFFFFFFFF; }\n    result_type x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    XorShift128Embeddable(result_type seed = 0) { z ^= seed; }\n    result_type operator()() {\n      result_type t = x ^ (x << 11);\n      x = y, y = z, z = w;\n      return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n  };\n\n  /// }}}--- ///\n  u32 nextPriority() {\n    static XorShift128Embeddable xs(__LINE__ * 1333 + 57);\n    return xs();\n  }\n\npublic:\n  TreapSeq(X val, u32 pri) : val(val), pri(pri) {}\n  TreapSeq(X val = Monoid::identity()) : TreapSeq(val, nextPriority()) {}\n  friend TreapSeq *merge(TreapSeq *a, TreapSeq *b) {\n    if(a == nullptr) return b;\n    if(b == nullptr) return a;\n    eval(a);\n    eval(b);\n    if(a->pri > b->pri) {\n      a->r = merge(a->r, b);\n      return prop(a);\n    } else {\n      b->l = merge(a, b->l);\n      return prop(b);\n    }\n  }\n  friend int size(TreapSeq *a) { return a == nullptr ? 0 : a->sz; }\n  using PNN = pair< TreapSeq *, TreapSeq * >;\n  // [0, k), [k, n)\n  // 左のグループにk個いれる\n  friend PNN split(TreapSeq *a, int k) {\n    if(a == nullptr) return PNN(nullptr, nullptr);\n    eval(a);\n    TreapSeq *sl, *sr;\n    if(k <= size(a->l)) {\n      tie(sl, sr) = split(a->l, k);\n      a->l = sr;\n      return PNN(sl, prop(a));\n    } else {\n      tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n      a->r = sl;\n      return PNN(prop(a), sr);\n    }\n  }\n  friend void insert(TreapSeq *&a, int k, const X &x) {\n    TreapSeq *sl, *sr;\n    tie(sl, sr) = split(a, k);\n    a = merge(sl, merge(new TreapSeq(x), sr));\n  }\n  friend X erase(TreapSeq *&a, int k) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    a = merge(tl, sr);\n    return tr->val;\n  }\n  friend void erase(TreapSeq *&a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    a = merge(tl, sr);\n  }\n  friend void set1(TreapSeq *a, int k, X const &x) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    if(tr != nullptr) tr->val = tr->accum = x;\n    merge(merge(tl, tr), sr);\n  }\n  friend X get(TreapSeq *a, int k) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    X res = tr == nullptr ? Monoid::identity() : tr->val;\n    merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void act(TreapSeq *a, int l, int r, M const &m) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->lazy = M_act::op(m, tr->lazy);\n    merge(merge(tl, tr), sr);\n  }\n  friend X fold(TreapSeq *a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    X res = tr == nullptr ? Monoid::identity() : tr->accum;\n    merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void reverse(TreapSeq *a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->rev ^= 1;\n    merge(merge(tl, tr), sr);\n  }\n  friend vector<X> get_all(TreapSeq *a) {\n    vector<X> res;\n    get_all_dfs(a, res);\n    return res;\n  }\nprivate:\n  static void get_all_dfs(TreapSeq *a, vector<X> &v) {\n    if(!a) return;\n    eval(a);\n    get_all_dfs(a->l, v);\n    v.push_back(a->val);\n    get_all_dfs(a->r, v);\n  }\n};\n\n/// }}}--- ///\n\n// ax + b, length\nusing P = pair<ll, ll>;\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(inf_monoid, inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return -T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return T(a.first + b.first, a.second + b.second); }\n  static constexpr T identity() { return T(0, 0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\n// template < class U = long long, class V = U >\n// struct RangeMinAdd {\n//   using X = U;\n//   using M = V;\n//   using Monoid = RangeMin< U >;\n//   static M op(const M &a, const M &b) { return a + b; }\n//   static constexpr M identity() { return M{0, 0}; }\n//   static X actInto(const M &m, ll, const X &x) { return m + x; }\n// };\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return -M(inf_monoid); }\n  static X actInto(const M &m, ll, const X &) { return m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return -M(inf_monoid); }\n  static X actInto(const M &m, ll, const X &) { return m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return M(a.first + b.first, a.second + b.second); }\n  static constexpr M identity() { return M(0, 0); }\n  static X actInto(const M &m, ll n, const X &x) { return X(n * m.first + x.first, n * m.second + x.second); }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return -M(inf_monoid); }\n  static X actInto(const M &m, ll n, const X &) { return m * n; }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, ll b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, ll n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, ll n, const X &) {\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, ll, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, ll, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, ll, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seq = TreapSeq< RangeSumAdd<P, P> > *;\nSeq seq = nullptr;\n\n\nconstexpr ll inf = 1e18;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> x[i] >> r[i], l[i] = r[i] - x[i];\n\n  insert(seq, 0, P{-inf, 0});\n  insert(seq, 1, P{0, inf});\n\n  ll bias = 0;\n  ll z = 0;\n\n  for(int i = 0; i < n; i++) {\n    dump(i);\n    {\n      int ok = 0, ng = size(seq) - 1;\n      while(abs(ok - ng) > 1) {\n        int mid = (ok + ng) >> 1;\n        if(fold(seq, 0, mid + 1).second - bias <= x[i]) ok = mid; else ng = mid;\n      }\n      auto d = fold(seq, 0, ok + 1);\n      d.second -= bias;\n      dump(ok, d, x[i]);\n      if(d.second != x[i]) {\n        dump(\"here\");\n        auto tap = x[i] - d.second;\n        auto eca = get(seq, ok + 1);\n        auto uku = eca;\n        eca.second = tap;\n        uku.second -= tap;\n        assert(uku.second > 0);\n        insert(seq, ok + 1, eca);\n        set1(seq, ok + 2, uku);\n        ok++;\n      }\n      z += x[i] + bias;\n      act(seq, 0, ok + 1, P{-1, 0});\n      act(seq, ok + 1, size(seq), P{1, 0});\n    }\n\n    if(i != n - 1) {\n      int ok = 0, ng = size(seq) - 1;\n      while(abs(ok - ng) > 1) {\n        int mid = (ok + ng) >> 1;\n        if(get(seq, mid).first < 0) ok = mid; else ng = mid;\n      }\n      dump(ok);\n      insert(seq, ok + 1, P{0, l[i] + l[i+1]});\n      dump(l[i] + l[i+1]);\n      bias += l[i+1];\n    }\n  }\n\n  dump(z, bias);\n  ll ans = z;\n\n  auto v = get_all(seq);\n\n  for(int i = 1; i < v.size(); i++) {\n    auto p = v[i];\n    if(p.first <= 0) {\n      z += p.first * p.second;\n      ans = min(ans, z);\n    } else break;\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 100010;\nset<int> lp,rp;\nset<int>::iterator t1,t2;\nint n,l[N],r[N],v,lt,rt,p,cur;\nsigned main() {\n  scanf(\"%lld\",&n);\n  for (int i = 1 ; i <= n ; ++ i)\n    scanf(\"%lld%lld\",&l[i],&r[i]);\n  lp.clear(), rp.clear();\n  lp.insert(l[1]), rp.insert(l[1]);\n  for (int i = 2 ; i <= n ; ++ i) {\n    t1 = lp.end(), -- t1;\n    t2 = rp.begin();\n    lt -= r[i] - l[i];\n    rt += r[i-1] - l[i-1];\n    p = l[i];\n    if (p < *t1 + lt)\n      v += *t1 + lt - p, rp.insert(*t1 + lt - rt), lp.erase(t1), lp.insert(p - lt);\n    else if (p > *t2 + rt)\n      v += p - *t2 - rt, lp.insert(*t2 + rt - lt), rp.erase(t2), rp.insert(p - rt);\n    else lp.insert(p - lt), rp.insert(p - rt);\n  }\n  printf(\"%lld\\n\",v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara = 1e6;\nconst ll LINF = 1e18;\n\n\nlong long int n,cnt=0,ans=INF,a[ohara],b[ohara],c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl=true;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n      cin>>n;\n      ll le=INF,ri=0;\n      rep(i,n){\n        cin>>a[i]>>b[i];\n        le=min(le,a[i]);\n        ri=max(ri,b[i]);\n      }\n      rrep(i,le,ri+1){\n        cnt=0;\n        rep(j,n){\n          if(a[j]<=i&&b[j]>=i)continue;\n          cnt+=min(abs(a[j]-i),abs(b[j]-i));\n         // cout<<i<<\" \"<<j<<\" \"<<cnt<<\"\\n\";\n        }\n        ans=min(ans,cnt);\n      }\n      Cout(ans);\n     \n\n       \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define all(x) (x).begin() , (x).end()\n#define rall(x) (x).rbegin() , (x).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define int long long\nconst int N = 1001;\nll dp[2][N];\nconst ll inf = 1e18;\nsigned main(){\n    int n;cin >> n;\n    vector < pair < int , int > > line(n + 1);\n    for(int i = 1; i <= n; ++i)\n        cin >> line[i].fi >> line[i].se;\n    line[0] = {0 , 0};\n    for(int i = 1 ; i <= n; ++i){\n        fill(dp[i&1] , dp[i&1] + N , inf);\n        int l , r , l1 , r1;\n        for(int j = 0; j < N; ++j){\n            l = j , r = j + line[i].se - line[i].fi;\n            if(r >= N)continue;\n            for(int prev = 0 ; prev < N; ++prev){\n                l1 = prev , r1 = prev + line[i-1].se - line[i-1].fi;\n                if(r < l1 || r1 < l)continue;\n                dp[i&1][j] = min(dp[i&1][j] , dp[(i&1)^1][prev] + abs(line[i].fi - l));\n            }\n        }\n    }\n    int ans = *min_element(dp[n&1] , dp[n&1] + N);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Author : rama_pang\n * Problem: \n * Time   : O(N log N)\n * Memory : O(N)\n * \n * Let dp(n, x) = minimum cost for the first n rectangles, and the n-th rectangle left endpoint is at x.\n * Let len[n] = r[n] - l[n] + 1\n * \n * dp(n, x) = min{dp(n - 1, y) for (x - len[n - 1] + 1 <= y <= x + len[n] - 1)} + abs(l[n] - x)\n * \n * Left f(n, x) be the plot function of dp(n, x), with f(n) as the whole plot\n * \n * Alternatively, we define\n * g(n) = min{f(n - 1) for (x - (len[n - 1] - 1) <= y <= x + len[n] - 1)}\n * h(n) = abs(l[n] - x)\n * f(n) = g(n) + h(n)\n * \n * We first see that f(n) is concave. Why? Since h(n) is concave, and g(n) applies transfromation to an already\n * concave function, when we added those two, the resulting function is still concave.\n * \n * Assume we have found f(n - 1). How do we transition into f(n)?\n * First, we apply g(n).\n * \n * Notice that since the function is concave, the left part is shifted to the left, and the right part is shifted\n * to the right by (len[n - 1] - 1). The exception is the minimummost point, which gets bigger.\n * \n * Next, we apply h(n).\n * Notice that for all values with x <= l[n], their line gradient is decreased by 1, and for x >= l[n], the line\n * gradient is shifted up by 1.\n * \n * We can query the minimum point to find the answer, which is at a point where the gradient is 0 (since the function\n * is concave).\n * \n * We can use 2 priority queues maintaining the left side of the minimummost area and the right side of the minimummost\n * area.\n * \n**/\n\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n\n  int n;\n  cin >> n;\n\n  priority_queue<lint, vector<lint>, less<lint>> lower;\n  priority_queue<lint, vector<lint>, greater<lint>> upper;\n\n  lint ans = 0;\n  lint lazy_lower = 0;\n  lint lazy_upper = 0;\n\n  lint cur_len = 0, last_len = 0;\n  for (int i = 0; i < n; i++) {\n    lint l, r;\n    cin >> l >> r;\n    tie(last_len, cur_len) = make_pair(cur_len, r - l + 1);\n\n    if (i == 0) {\n      lower.emplace(l);\n      upper.emplace(l);\n      continue;\n    }\n\n    // Apply g(n)\n    lazy_lower -= cur_len - 1;     // points <= minimum get shifted by len[n] - 1\n    lazy_upper += last_len - 1; // points >= minimum get shifted by len[n - 1] - 1\n\n    if (l <= lower.top() + lazy_lower) {\n      lint top = lower.top() + lazy_lower;\n      ans += top - l; // move segment to a minimum point, which is at top since top's gradient is now 0 (previously -1).\n      // Apply h(n)\n      lower.emplace(l - lazy_lower);\n      lower.emplace(l - lazy_lower);\n      upper.emplace(top - lazy_upper);\n      lower.pop();\n    } else if (l >= upper.top() + lazy_upper) {\n      lint top = upper.top() + lazy_upper;\n      ans += l - top; // move segment to a minimum point, which is at top since top's gradient is now 0 (previously 1).\n      // Apply h(n)\n      upper.emplace(l - lazy_upper);\n      upper.emplace(l - lazy_upper);\n      lower.emplace(top - lazy_lower);\n      upper.pop();\n    } else { // segment is already at an optimal place, so we just apply h(n)\n      lower.emplace(l - lazy_lower);\n      upper.emplace(l - lazy_upper);\n    }\n  }\n\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\nint maxpos=-1 , minpos=LINF;\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\tminpos = min( minpos , l[i] );\n\t\tmaxpos = max( maxpos , l[i] );\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = minpos;i <= maxpos;i++)\n\t\tans = min(  ans  ,  dp(1,i)  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tint len=r[1]-l[1];\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[i]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx;j++){\n\t\t\tf[i][j]=100000000;\n\t\t\tfor(int k=max(1,j-len-len_);k<=min(mx,j+len);k++){\n\t\t\t\tif(k>j)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-k)));\n\t\t\t\telse if(k>j-len_)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-j)));\n\t\t\t\telse f[i][j]=min(f[i][j],f[i-1][k]+min(abs(r[i]-j),abs(l[i]-(k+len_))));\n\t\t\t}\n\t\t}\n\t}\n\tans=100000000;\n\tfor(int j=1;j<=mx;j++)ans=min(ans,f[n][j]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int MAX_RECT = 405;\nconst int MAX_COORD = 405;\nconst int INF = 1023456789;\n\nusing namespace std;\n\nint dp [MAX_RECT][MAX_COORD];\nint width [MAX_RECT], lft [MAX_COORD];\n\nbool overlap (int al, int ar, int bl, int br) {\n  if (bl < al) {\n    swap(al, bl);\n    swap(ar, br);\n  }\n\n  return (ar >= bl);\n}\n\nint main () {\n  for (int i = 0; i < MAX_RECT; i++) {\n    for (int j = 0; j < MAX_RECT; j++) {\n      dp[i][j] = INF;\n    }\n  }\n\n  int rectcnt;\n  cin >> rectcnt;\n\n  for (int i = 0; i < rectcnt; i++) {\n    int right;\n    cin >> lft[i] >> right;\n    width[i] = right - lft[i];\n  }\n\n  for (int i = 0; i < MAX_COORD - width[0]; i++) {\n    dp[0][i] = abs(lft[0] - i);\n  }\n\n  for (int i = 1; i < rectcnt; i++) {\n    for (int j = 0; j < MAX_COORD - width[i]; j++) {\n      for (int k = 0; k < MAX_COORD; k++) {\n        if (overlap(j, j + width[i], k, k + width[i - 1])) {\n          dp[i][j] = min(dp[i][j], abs(lft[i] - j) + dp[i - 1][k]);\n        }\n      }\n    }\n  }\n\n  int ans = INF;\n  for (int i = 0; i < MAX_COORD; i++) {\n    ans = min(ans, dp[rectcnt - 1][i]);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n \nstatic int getMinCost(multiset<int> &leftNodes,\n\t\t      multiset<int> &rightNodes,\n\t\t      int curmincost,\n\t\t      int minpos)\n{\n    if (leftNodes.size() == 0) {\n\treturn curmincost;\n    }\n\n    int lmax = *max_element(leftNodes.begin(), leftNodes.end());\n    int rmin = *min_element(rightNodes.begin(), rightNodes.end());\n\n    if (lmax <= minpos) {\n\tif (minpos <= rmin) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - rmin + curmincost;\n    } else {\n\treturn lmax - minpos + curmincost;\n    }\n}\n \nint main(void){\n    int n;\n    int mincost;\n    multiset<int> leftNodess[2];\n    multiset<int> rightNodess[2];\n    multiset<int> *lp, *rp;\n    multiset<int> *nlp, *nrp;\n    stringstream st;\n    string line;\n      \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n    lp = &leftNodess[0];\n    nlp = &leftNodess[1];\n    rp = &rightNodess[0];\n    nrp = &rightNodess[1];\n\n    \n    int nl, nr;\n    int l, r;\n    mincost = 0;    \n    for (int i = 0; i < n; i++) {\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> nl >> nr;\n\tif (i >= 1) {\n\t    \n\t    lp = &leftNodess[i % 2];\n\t    nlp = &leftNodess[(i + 1) % 2];\n\t    rp = &rightNodess[i % 2];\n\t    nrp = &rightNodess[(i + 1) % 2];\n\t    mincost = getMinCost(*lp, *rp, mincost, l);\n\t    auto ilmax = max_element(lp->begin(), lp->end());\n\t    if (ilmax == lp->end()) {\n\t\tlp->insert(l);\n\t\trp->insert(l);\n\t    } else {\n\t\tif (*ilmax <= l) {\n\t\t    auto irmin = min_element(rp->begin(), rp->end());\t\t\n\t\t    if (l <= *irmin) {\n\t\t\tlp->insert(l);\n\t\t\trp->insert(l);\n\t\t    } else {\n\t\t\trp->insert(l);\n\t\t\trp->insert(l);\n\n\t\t\tlp->insert(*irmin);\n\t\t\trp->erase(irmin);\n\t\t    }\n\t\t} else {\n\t\t    lp->insert(l);\n\t\t    lp->insert(l);\n\n\t\t    rp->insert(*ilmax);\n\t\t    lp->erase(ilmax);\n\t\t}\n\t    }\n\n\t    nlp->clear();\n\t    nrp->clear();\n\t    for (auto &e : *lp) {\n\t\tnlp->insert(e - (nr - nl));\n\t    }\n\t    for (auto &e : *rp) {\n\t\tnrp->insert(e + (r - l));\n\t    }\n#if 1\n\t    for (auto e : *nlp) {\n\t\tcout << e << \" \";\n\t    }\n\t    for (auto e : *nrp) {\n\t\tcout << e << \" \";\n\t    }\t    \n\t    cout << endl;\n#endif\t\n\t}\n\tl = nl;\n\tr = nr;\n    }\n \n    mincost = getMinCost(*nlp, *nrp, mincost, l);\n \n    cout << mincost << endl;\n    return 0;\n \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nconst int MAXN = 405;\nint l[MAXN], r[MAXN];\n\nint dp[MAXN][MAXN];\n\nint n;\n\nint main() {\n    GI(n);\n\n    FORN(j, MAXN) FORN(k, MAXN) dp[j][k] = INF;\n\n    FOR1(i, n) {\n        GI(l[i]);\n        GI(r[i]);\n        \n        if (i == 1) {\n            FORN(j, MAXN) {\n                dp[i][j] = abs(j - l[i]);\n            }\n        }\n        else {\n            FORN(j, MAXN) {\n                FORN(k, MAXN) {\n                    int rj = j + r[i] - l[i];\n                    int rk = k + r[i-1] - l[i-1];\n\n                    if (rj >= k && rk >= j) {\n                        dp[i][j] = min(dp[i][j], dp[i-1][k] + abs(j - l[i]));\n                    }\n                }\n            }\n        }\n    }\n\n    int res = INF;\n    FORN(j, MAXN) res = min(res, dp[n][j]);\n\n    cout << res << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,a,n)     for(int i=a;i<n;i++)\n#define rep3(n)        for(int i=0;i<n;i++)\n#define ll             long long\n#define int            long long\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define endl           \"\\n\"\n#define eb             emplace_back\n#define x              first\n#define y              second\n#define gcd(a,b)       __gcd(a,b)\n#define mem1(a)        memset(a,-1,sizeof(a))\n#define mem0(a)        memset(a,0,sizeof(a))\n#define pres(a,x)      a.find(x)!=a.end()\n#define sz(a)          (int)a.size()\n#define pii            pair<int,int>\n#define hell           1000000007\n#define elasped_time   1.0 * clock() / CLOCKS_PER_SEC\nusing namespace std;\n\n\ntemplate<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<\" \"<<a.y;return out;}\ntemplate<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}\ntemplate<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}\n\nconst int N=500;\nint dp[N][N];\n\nint solve(){\n \tint n;cin>>n;\n \tvector<pii>vec(n+1);\n \trep(i,1,n+1){\n \t\tcin>>vec[i];\n \t}\n \tsort(vec.begin()+1,vec.end(),[&](pii p1,pii p2){return p1.y<p2.y;});\n \tfor(int i=1;i<=400;i++){\n \t\tfor(int j=1;j<=400;j++)dp[i][j]=1e18;\n \t}\n \tfor(int i=1;i<=400;i++){\n \t\tdp[1][i]=abs(i-vec[1].y);\n \t}\n \tfor(int i=2;i<=n;i++){\n \t\tfor(int j=1;j<=400;j++){\n \t\t\tfor(int k=j;k<=400;k++){\n \t\t\t\tint left=k-vec[i].y+vec[i].x;\n \t\t\t\tif(left<=j)mins(dp[i][k],abs(k-vec[i].y)+dp[i-1][j]);\n \t\t\t}\t\n \t\t}\n \t}\n \tint mn=1e18;\n \trep(i,1,401)mins(mn,dp[n][i]);\n \tcout<<mn<<endl;\n return 0;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #ifdef SIEVE\n    sieve();\n    #endif\n    #ifdef NCR\n    init();\n    #endif\n    int t=1;//cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int M = 1000000007;\nconst double PI = atan(1) * 4;\nconst int oo = 1000000000;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n;\nvector<pair<ll,ll> >v;\nll get(ll md){\n\tll ans=0;\n\tll lsx=md, lsy=md;\n\tif(v[0].second<md){\n\t\tans=md-v[0].second;\n\t\tint d=v[0].second-v[0].first;\n\t\tlsy=md;\n\t\tlsx=lsy-d;\n\t}else if(v[0].first>md){\n\t\tans=v[0].first-md;\n\t\tint d=v[0].second-v[0].first;\n\t\tlsx=md;\n\t\tlsy=lsx+d;\n\t}else{\n\t\tlsx=v[0].first;\n\t\tlsy=v[0].second;\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tbool f=0;\n\t\tif(lsx<=v[i].first && v[i].first<=lsy)f=true;\n\t\tif(lsx<=v[i].second && v[i].second<=lsy)f=true;\n\t\tif(lsx>=v[i].first && lsy<=v[i].second)f=true;\n\t\tif(lsx<=v[i].first && lsy>=v[i].second)f=true;\n\t\tif(f){\n\t\t\tlsx=v[i].first;\n\t\t\tlsy=v[i].second;\n\t\t}else{\n\t\t\tif(lsx>v[i].second){\n\t\t\t\tans+=lsx-v[i].second;\n\t\t\t\tint d=v[i].second-v[i].first;\n\t\t\t\tlsy=lsx;\n\t\t\t\tlsx=lsy-d;\n\t\t\t}else{\n\t\t\t\tans+=v[i].first-lsy;\n\t\t\t\tint d=v[i].second-v[i].first;\n\t\t\t\tlsx=lsy;\n\t\t\t\tlsy=lsx+d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=0; i<n; ++i)\n\t\tscanf(\"%lld%lld\",&v[i].first,&v[i].second);\n\tll lo=0, hi=2*oo, md1, md2, bst=1ll*oo*oo;\n\twhile(hi-lo>10){\n\t\tmd1=(2ll*lo+hi)/3;\n\t\tmd2=(lo+2ll*hi)/3;\n\t\tll d1=get(md1);\n\t\tll d2=get(md2);\n\t\tbst=min(bst,min(d1,d2));\n\t\tif(d1<d2)\n\t\t\thi=md2;\n\t\telse\n\t\t\tlo=md1;\n\t}\n\tfor(int i=lo; i<=hi; ++i)\n\t\tbst=min(bst,get(i));\n\tcout<<bst<<endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nconst int maxn = 810;\nconst int INF = 1<<30;\n\nint f[maxn][maxn];\nint l[maxn], r[maxn];\n\nint main()\n{\n\t//freopen(\"E.in\",\"r\",stdin);\n\t//freopen(\"E.out\",\"w\",stdout);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\t\n\tfor (int i=0;i<maxn;i++)\n\t\tfor (int j=0;j<maxn;j++) f[i][j] = INF;\n\tfor (int i=max(r[1]-l[1],1);i<maxn;i++) f[1][i] = abs(r[1] - i);\n\t\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=0;j<maxn;j++)\n\t\t{\n\t\t\tfor (int x=-maxn/2;x<maxn/2;x++)\n\t\t\t{\n\t\t\t\tint newl = l[i+1] - x, newr = r[i+1] - x;\n\t\t\t\tif (newl <= 0) break;\n\t\t\t\tif (newl <= j && newr >= j-r[i]+l[i]) f[i+1][newr] = min(f[i+1][newr], f[i][j] + abs(x));\n\t\t\t\t//cout<<i<<\" \"<<i+1<<\" \"<<j<<\" \"<<x<<\" \"<<newr<<\" \"<<f[i][j]+abs(x)<<\" \"<<f[i+1][newr]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i=0;i<maxn;i++) ans = min(ans,f[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define sz(a) ((int)(a).size())\n#define clr(a,v) memset(a, v, sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define pii pair<int,int>\n#define pdd pair<ld,ld> \n#define rep(i,a,b) for(int i=a; i<b; i++)\n#define dec(i,a,b) for(int i=a; i>=b; i--)\n#define ler freopen(\"inspection.in\",\"r\",stdin);freopen(\"inspection.out\",\"w\",stdout)\n#define fastio ios::sync_with_stdio(0), cin.tie(0)\n#define debug cout<<\"!!?!!\\n\"\nusing namespace std;\n#define PI 2*asin(1) \n#define EPS 1e-9\n#define MOD 1000000007\n#define MAXN 404LL\n#define INF 2000000000000000LL\n\nll dp[404][404], n, a[MAXN], b[MAXN], tam[MAXN];\n\nll solve(int i, int x){\n\tif(dp[i][x]!=-1) return dp[i][x];\n\tll ans=INF;\n\tif(i!=0){\n\t\trep(j,max(0LL,x+1-tam[i-1]),min(x+tam[i],MAXN))\n\t\t\tans= min(ans, solve(i-1,j));\n\t}\n\tif(ans==INF) ans=0;\n\tans+= abs(x-a[i]);\n\treturn dp[i][x]= ans;\n}\n\nint main(){\n\tclr(dp,-1);\n\tfastio;\n\t\n\tcin >> n;\n\trep(i,0,n){\n\t\tcin >> a[i] >> b[i];\n\t\ttam[i]= b[i]-a[i]+1;\n\t}\n\t\n\tll ans=INF;\n\trep(i,0,MAXN){\n\t\tans= min(ans, solve(n-1,i));\n\t}\n\tcout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef pair<int, int> P1;\ntypedef pair<int, pair<int, int> > P2;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\nstatic const int mod = 1000000007;\n\n\n\nint N;\nint L[100005],R[100005];\nint len[100005];\nint dp[5005][5005];\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<5000;++i)for(int j=0;j<5000;++j)dp[i][j]=INF;\n    for(int i=0;i<N;++i){\n        cin>>L[i]>>R[i];\n        len[i] = R[i]-L[i];\n    }\n    if(N>400)exit(0);\n    for(int i=1;i<5000;++i)dp[0][i] = abs(i-L[0]);\n    for(int i=0;i<N-1;++i){\n        for(int j=0;j<=400;++j){\n            for(int k=0;k<=400;++k){\n                int pl = k,pr = k+len[i];\n                int l=j,r=j+len[i+1];\n                if(pr<l||r<pl)continue;\n                //cout<<l<<\" \"<<pl<<endl;\n                //cout<<\"//////////////////\"<<endl;\n                dp[i+1][l] = min(dp[i+1][l],dp[i][pl] + abs(L[i]-l));\n                //cout<<dp[i+1][l]<<endl;\n            }\n        }\n    }\n    int ans=INF;\n    for(int i=1;i<=400;++i)ans=min(ans,dp[N-1][i]);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define pb push_back\n#define mp make_pair\n\nint n;\npii mas[123456];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> mas[i].first >> mas[i].second;\n    }\n    int ans = 0, mn = 1000000000;\n    int l, r;\n    for(int i = 1; i <= 400; i++){\n        l = i, r = i - mas[0].first + (mas[0].second - mas[0].first + 1);\n        ans = abs(i - mas[0].first);\n        for(int j = 1; j < n; j++){\n            int l1 = mas[j].first, r1 = mas[j].second;\n            if(l1 > r){\n                ans += (l1 - r);\n                l = r, r = l + (mas[j].second - mas[j].first + 1);\n            }\n            else if(r1 < l){\n                ans += (l - r1);\n                r = l, l = r - (mas[j].second - mas[j].first + 1);\n            }\n        }\n        mn = min(ans, mn);\n    }\n    cout << mn << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long\n\nusing namespace std;\n\nconst int N = 1e5+5;\n\nint n;\nint l[N], r[N];\nlong ans, lz_l, lz_r;\nmultiset<long> L, R;\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", l+i, r+i), r[i] -= l[i];\n    for(int i = 1; i <= n; i++) {\n        ans += l[i];\n        L.emplace(l[i] + lz_l), R.emplace(l[i] - lz_r);\n        while(*L.rbegin() - lz_l > *R.begin() + lz_r) {\n            long l = *L.rbegin(), r = *R.begin();\n            L.erase(L.find(l)), R.erase(R.find(r));\n            L.emplace(r + lz_r + lz_l), R.emplace(l + lz_l + lz_r);\n        }\n        long pv = 0;\n        while(!L.empty() && *L.begin() - lz_l - r[i+1] <= 0) {\n            ans -= abs(*L.begin() - lz_l - pv) * L.size();\n            pv = *L.begin() - lz_l;\n            L.erase(L.begin());\n        }\n        ans -= abs(pv - r[i+1]) * L.size();\n        lz_l += r[i+1], lz_r += r[i];\n    }\n    long m = L.size(), pv = 0;\n    for(long x : L) {\n        ans -= abs(x - lz_l - pv) * m--;\n        pv = x - lz_l;\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF (1e9)\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 2000\n#define P +MAXN\n \nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n \nint mem[MAXN][MAXN P];\nint myabs( int x ){\n\tif( x >= 0 ) return x;\n\telse return -x;\n}\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl P] != -1) return mem[pos][lastl P];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++){\n\t\tint nowans = dp(pos+1,nowl) + myabs(l[pos]-nowl);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\tmem[pos][lastl P] = ans;\n\treturn ans;\n}\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = -MAXN;i <= MAXN;i++){\n\t\tint nowans = dp(2,i) + myabs(i-l[1]);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\t\t\n\tprintf(\"%d\\n\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(r[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    Int x=r[i]-l[i];\n    dL-=x;//dR+=x;\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(l[i]<dL+*latte){\n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define eps 1e-9\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int N= 400 + 50;\nint n , dp[N][N] , l[N] , r[N];\n \nint main()\n{\n\tn = read();\n\trep(i, 1, n)\n\t\tl[i] = read() , r[i] = read();\n\trep(j, 1, 400)\n\t\tdp[1][j] = abs( j - l[1] );\n\trep(i, 2, n)\n\t\trep(j, 1, 400)\n                {\n\t\t\tint mi = 1e9 + 7;\n\t\t\tfor(int k = max( 1 , j - (r[i - 1] - l[i - 1]) ) ; k <= min( 400 , j + r[i] - l[i] ) ; ++ k)\n\t\t\t\tmi = min( mi , dp[i - 1][k] );\n\t\t\tmi += abs( j - l[i] );\n\t\t\tdp[i][j] = mi;\n\t\t}\n\tint mi = 1e9 + 7;\n\tfor(int i = 1 ; i <= 400 ; ++ i) \n\t\tmi = min( mi , dp[n][i] );\n\tprintf( \"%d\\n\" , mi );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define Reps(i, x, N) for(int i = x; i < N; i++)\n\nconst int LLINF = 1LL << 60;\nsigned main()\n{\n  int N;\n  int l[405], r[405];\n\n  cin >> N;\n\n  Rep(i, N) cin >> l[i] >> r[i];\n\n  int sum, minv = LLINF;\n  \n  Reps(i, 1, 405) {\n    sum = 0;\n\n    Rep(j, N) {\n      sum += max(0LL, max(l[j] - i, i - r[j]));\n    }\n    \n    minv = min(sum, minv);\n  }\n\n  cout << minv << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAXN=1e5+10;\nint n,l[MAXN],r[MAXN];\nint ls,rs;ll res=0;\npriority_queue<int> L;\npriority_queue<int,vector<int>,greater<int> > R;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&l[i],&r[i]);\n    L.push(l[1]);R.push(r[1]);\n    for(int i=2;i<=n;i++)\n    {\n        ls-=r[i]-l[i];rs+=r[i-1]-l[i-1];\n        int lb=L.top()+ls,rb=R.top()+rs;\n        if(l[i]<lb)\n        {\n            res+=lb-l[i];R.push(lb-rs);\n            L.push(l[i]-ls);L.push(l[i]-ls);L.pop();\n        }\n        else if(l[i]>rb)\n        {\n            res+=l[i]-rb;L.push(rb-ls);\n            R.push(l[i]-rs);R.push(l[i]-rs);R.pop();\n        }\n        else\n        {\n            L.push(l[i]-ls);\n            R.push(l[i]-rs);\n        }\n    }\n    printf(\"%lld\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\n\nconst int MAX = 100010;\nconst int INF = 2e9;\nconst lint LNF = 2e18;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\n\tlint c=0, lb=0, rb=0;\n\tpriority_queue<lint> L;\n\tpriority_queue<lint, vector<lint>, greater<lint>> R;\n\n\tfor(int i=1, sp=0, zp=0; i<=n; i++){\n\t\tint s, e, z; cin>>s>>e; z = e-s;\n\t\tlb -= z, rb += zp;\n\t\tlint l0 = (L.empty() ? -LNF : L.top()+lb);\n\t\tlint r0 = (R.empty() ? +LNF : R.top()+rb);\n\t\tif(l0<=s && s<=r0){\n\t\t\tL.push(s-lb); R.push(s-rb);\n\t\t}\n\t\telse if(s<l0){\n\t\t\tL.push(s-lb); L.push(s-lb);\n\t\t\tL.pop(); R.push(l0-rb);\n\t\t\tc += l0-s;\n\t\t}\n\t\telse if(r0<s){\n\t\t\tR.push(s-rb); R.push(s-rb);\n\t\t\tR.pop(); L.push(r0-lb);\n\t\t\tc += s-r0;\n\t\t}\n\t\tsp = s, zp = z;\n\t}\n\n\tcout<<c<<'\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=100005;\nint L[MAXN],R[MAXN],len[MAXN],n;\npriority_queue<LL> hp2;\npriority_queue<LL,vector<LL>,greater<LL> > hp1;\nLL mov1,mov2;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)L[i]=read(),R[i]=read(),len[i]=R[i]-L[i];\n\thp1.push(R[1]);\n\thp2.push(R[1]);LL ans=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tmov1+=len[i];mov2-=len[i-1];\n\t\tLL fl=hp2.top()+mov2,fr=hp1.top()+mov1;\n\t\tif(fl<=R[i]&&R[i]<=fr)hp1.push(R[i]-mov1),hp2.push(R[i]-mov2);\n\t\telse if(fl<=R[i])\n\t\t{\n\t\t\tans+=R[i]-fr;hp1.pop();hp2.push(fr-mov2);\n\t\t\thp1.push(R[i]-mov1);hp1.push(R[i]-mov1);\n\t\t}\n\t\telse if(R[i]<=fr)\n\t\t{\n\t\t\tans+=fl-R[i];hp2.pop();hp1.push(fl-mov1);\n\t\t\thp2.push(R[i]-mov2);hp2.push(R[i]-mov2);\n\t\t}\n\t}pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link relink\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string &fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 805;\n\nint n, k;\nint l[N], r[N];\nint dp[N][N];\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  l[0] = 0, r[0] = N;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < N; j++) {\n      // current is j,j+r[i]-l[i]\n      dp[i][j] = INF;\n      for (int k = max(0, j - (r[i - 1] - l[i - 1]));\n           k <= min(N, j + r[i] - l[i]); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n      }\n      dp[i][j] += abs(l[i] - j);\n    }\n  }\n\n  cout << *min_element(dp[n], dp[n] + N) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tmultiset<ll>s1, s2;\n\tll t1 = 0, t2 = 0;\n\tll bef;\n\tll ans = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tll za, zb;\n\t\tscanf(\"%lld%lld\", &za, &zb);\n\t\tif (i == 0)\n\t\t{\n\t\t\tt1 = t2 = za;\n\t\t\ts1.insert(0), s2.insert(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt1 -= zb - za;\n\t\t\tt2 += bef;\n\t\t\tmultiset<ll>::iterator it1 = s1.end();\n\t\t\tit1--;\n\t\t\tll s = (*it1) + t1;\n\t\t\tmultiset<ll>::iterator it2 = s2.begin();\n\t\t\tll t = (*it2) + t2;\n\t\t\tif (za < s)\n\t\t\t{\n\t\t\t\ts1.erase(it1);\n\t\t\t\ts2.insert(s - t2);\n\t\t\t\ts1.insert(za - t1);\n\t\t\t\ts1.insert(za - t1);\n\t\t\t\tans += s - za;\n\t\t\t}\n\t\t\telse if (za <= t)\n\t\t\t{\n\t\t\t\ts1.insert(za - t1);\n\t\t\t\ts2.insert(za - t2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts2.erase(it2);\n\t\t\t\ts1.insert(t - t1);\n\t\t\t\ts2.insert(za - t2);\n\t\t\t\ts2.insert(za - t2);\n\t\t\t\tans += za - t;\n\t\t\t}\n\t\t}\n\t\tbef = zb - za;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nint n, dp[405][805];\nstruct rectangle {\n\tint l, r;\n} r[405];\n\nbool cmp(rectangle x, rectangle y) {\n\treturn x.l < y.l;\n}\n\nint abs(int x) {\n\treturn x > 0 ? x : -x;\n}\n\nint min(int x, int y) {\n\treturn x < y ? x : y;\n}\n\nint max(int x, int y) {\n\treturn x > y ? x : y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d %d\", &r[i].l, &r[i].r);\n\tstd::sort(r + 1, r + n + 1, cmp);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= 800; j++) dp[i][j] = 2e9;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = r[i].r - r[i].l; j <= 800; j++) {\n\t\t\tfor (int k = j - r[i].r + r[i].l; k <= min(800, j+400); k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - r[i].r));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 2e9;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[n][i]);\n\tprintf(\"%d\\n\", ans);\n}\n\n/*\n5\n1 7\n5 9\n12 18\n16 20\n24 30\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint l[100010];\nint r[100010];\n\nint main (int argc, char const* argv[])\n{\n\tpriority_queue <long long> dec;\n\tpriority_queue <long long, vector <long long>, greater <long long> > inc;\n\t\n\tlong long add_dec = 0;\n\tlong long add_inc = 0;\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t}\t \n\t\n\tlong long c = 0;\n\tdec.push(l[1]);\n\tinc.push(l[1]);\n\tfor(int i = 2; i <= n; i++) {\n\t\tadd_dec -= r[i] - l[i];\n\t\tadd_inc += r[i-1] - l[i-1];\n\t\tlong long opt1 = dec.top() + add_dec;\n\t\tlong long opt2 = inc.top() + add_inc;\n\t\tif(l[i] <= opt1) {\n\t\t\tdec.pop();\n\t\t\tinc.push(opt1 - add_inc);\n\t\t\tdec.push(l[i] - add_dec);\n\t\t\tdec.push(l[i] - add_dec);\n\t\t\tc += abs(l[i] - opt1);\n\t\t} else if (opt2 <= l[i]) {\n\t\t\tinc.pop();\n\t\t\tdec.push(opt2 - add_dec);\n\t\t\tinc.push(l[i] - add_inc);\n\t\t\tinc.push(l[i] - add_inc);\n\t\t\tc += abs(l[i] - opt2);\n\t\t} else {\n\t\t\tdec.push(l[i] - add_dec);\n\t\t\tinc.push(l[i] - add_inc);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", c);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define error(args...) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\ndouble find_min(double a, double b, function<double(double)> f) {\n    REP(_, 86) {\n        double c = (a * 2 + b) / 3;\n        double d = (a + b * 2) / 3;\n        if(f(c) < f(d)) { // '>': maximum, '<': minimum\n            b = d;\n        } else {\n            a = c;\n        }\n    }\n    return (a + b) / 2;\n}\nLL calc(const vector<LL>& diff, LL D) {\n    LL ans = 0;\n    for(int i = 0; i < diff.size(); i++) {\n        ans += abs(diff[i] + D);\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int N;\n    while(cin >> N) {\n        vector<LL> L(N), R(N);\n        REP(i, N){\n            cin >> L[i] >> R[i];\n        }\n        vector<LL> diff(N);\n\n        for(int i = 1; i < N; i++) {\n            if(R[i-1] < L[i]) {\n                diff[i] = R[i-1] - L[i];\n                R[i] += diff[i];\n                L[i] += diff[i];\n                error(diff[i], L[i], R[i]);\n            } else if(L[i-1] > R[i]) {\n                diff[i] = L[i-1] - R[i];\n                R[i] += diff[i];\n                L[i] += diff[i];\n                error(diff[i], L[i], R[i]);\n            }\n        }\n\n        auto f = [&](double x) -> double {\n            int D = (int)x;\n            return calc(diff, x);\n        };\n\n        double d = find_min(-2e9, 2e9, f);\n\n        LL ans = LLONG_MAX;\n        for(int i = -20; i <= 20; i++) {\n            ans = min(ans, calc(diff, (LL)d + i));\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,a,n)     for(int i=a;i<n;i++)\n#define rep3(n)        for(int i=0;i<n;i++)\n#define ll             long long\n#define int            long long\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define endl           \"\\n\"\n#define eb             emplace_back\n#define x              first\n#define y              second\n#define gcd(a,b)       __gcd(a,b)\n#define mem1(a)        memset(a,-1,sizeof(a))\n#define mem0(a)        memset(a,0,sizeof(a))\n#define pres(a,x)      a.find(x)!=a.end()\n#define sz(a)          (int)a.size()\n#define pii            pair<int,int>\n#define hell           1000000007\n#define elasped_time   1.0 * clock() / CLOCKS_PER_SEC\nusing namespace std;\n\n\ntemplate<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<\" \"<<a.y;return out;}\ntemplate<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}\ntemplate<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}\n\nconst int N=500;\nint dp[N][N];\n\nint solve(){\n \tint n;cin>>n;\n \tvector<pii>vec(n+1);\n \trep(i,1,n+1){\n \t\tcin>>vec[i];\n \t}\n \tsort(vec.begin()+1,vec.end(),[&](pii p1,pii p2){return p1.x<p2.x;});\n \tfor(int i=1;i<=400;i++){\n \t\tfor(int j=1;j<=400;j++)dp[i][j]=1e18;\n \t}\n \tfor(int i=1;i<=400;i++){\n \t\tdp[1][i]=abs(i-vec[1].x);\n \t}\n \tfor(int i=2;i<=n;i++){\n \t\tfor(int j=1;j<=400;j++){\n \t\t\tint r2=vec[i-1].y-vec[i-1].x+j;\n \t\t\tint l2=j;\n \t\t\tfor(int k=j;k<=400;k++){\n \t\t\t\tint r1=vec[i].y-vec[i].x+k;\n \t\t\t\tint l1=k;\n \t\t\t\tif(max(l1,l2)<=min(r2,r1))mins(dp[i][k],abs(l1-vec[i].x)+dp[i-1][j]);\t\n \t\t\t}\t\n \t\t}\n \t}\n \tint mn=1e18;\n \trep(i,1,401)mins(mn,dp[n][i]);\n \tcout<<mn<<endl;\n return 0;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #ifdef SIEVE\n    sieve();\n    #endif\n    #ifdef NCR\n    init();\n    #endif\n    int t=1;//cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tll l, r, len, pbl, pbr, ans = 0, L, R;\n\tpriority_queue<ll> ql;\n\tpriority_queue<ll, vector<ll>, greater<ll>> qr;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\t\tql.push(r - pbl);\n\t\tqr.push(r - pbr);\n\n\t\twhile ((L = (ql.top() + pbl)) > (R = (qr.top() + pbr))) {\n\t\t\tans += L - R;\n\n\t\t\tql.pop();\n\t\t\tqr.pop();\n\t\t\t\n\t\t\tql.push(R - pbl);\n\t\t\tqr.push(L - pbr);\n\t\t}\n\n\t\tpbl -= len;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n#define ep emplace_back\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);++i)\nconstexpr int mod=1000000007;\nconstexpr int mod1=998244353;\nvector<int> dx={0,1,0,-1},dy={-1,0,1,0};\nbool inside(int y,int x,int h,int w){\n\tif(y<h && y>=0 && x<w && x>=0) return true;\n\treturn false;\n}\n\n\n\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;cin >> n;\n\tvector<int> l(n),r(n);\n\trep(i,n) cin >> l.at(i) >> r.at(i);\n\tll lb = 0, ub= 1e9 + 1;\n\trep(i,200){\n\t\tll t1 = (2 * lb + ub) / 3;\n\t\tll t2 = (lb + 2 * ub) / 3;\n\t\tll sum1 = 0, sum2 = 0;\n\t\trep(j,n){\n\t\t\tif(l.at(j) <= t1 && r.at(j) >= t1){\n\t\t\t\tsum1 += 0;\n\t\t\t}\n\t\t\telse if(l.at(j) > t1){\n\t\t\t\tsum1 += l.at(j) - t1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum1 += t1 - r.at(j);\n\t\t\t}\n\t\t\tif(l.at(j) <= t2 && r.at(j) >= t2){\n\t\t\t\tsum2 += 0;\n\t\t\t}\n\t\t\telse if(l.at(j) > t2){\n\t\t\t\tsum2 += l.at(j) - t2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum2 += t2 - r.at(j);\n\t\t\t}\n\t\t}\n\t\tif(sum1 > sum2) lb = t1;\n\t\telse ub = t2;\n\t}\n\tll ans = 1e18;\n\tfor(int j = -100; j <= 100; j++){\n\t\tif(lb + j < 0) continue;\n\t\tll sum = 0;\n\t\trep(i,n){\n\t\t\tif(l.at(i) <= lb + j && r.at(i) >= lb + j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(l.at(i) > lb + j){\n\t\t\t\tsum += l.at(i) - (lb + j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += lb + j - r.at(i);\n\t\t\t}\n\t\t}\n\t\tans = min(ans, sum);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define dbg(x) cerr<<#x\": \"<<x<<\"\\n\"\n#define dbg_v(x, n) do{cerr<<#x\"[]: \";for(long long _=0;_<n;++_)cerr<<x[_]<<\" \";cerr<<'\\n';}while(0)\n#define dbg_ok cerr<<\"OK!\\n\"\n\n#define MOD 66610013LL\n#define DMAX 444\nusing namespace std;\n\nlong long n, ans, k, rmax = 0;\nlong long v[444];\nlong long r[DMAX], l[DMAX];\nlong long dp[DMAX][DMAX];\n\nlong long Min(long long k, long long left, long long right)\n{\n\tif(k==0)\n\t\treturn 0;\n\tlong long asd = 1000000000LL, lg = r[k] - l[k];\n\tfor(long long i=min(left, rmax);i<=min(right+lg, rmax);i++)\n\t{\n\t\tasd = min(dp[k][i], asd);\n\t}\n\treturn asd;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin >> n;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tcin >> l[i] >> r[i];\n\t\trmax = max(r[i], rmax);\n\t}\n\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tdp[i][0]=1000000000LL;\n\t\tfor(long long j=1;j<=rmax;j++)\n\t\t{\n\t\t\tif(r[i]-l[i] > j) \n\t\t\t{\n\t\t\t\tdp[i][j] = 1000000000LL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j] = Min(i-1, j+l[i]-r[i], j) + abs(r[i] - j);\n\t\t}\n\t\t//dbg_v(dp[i], rmax + 1);\n\t}\n\n\tlong long m = dp[n][1];\n\tfor(int i=1;i<=rmax;i++)\n\t\tm = min(m, dp[n][i]);\n\tcout << m << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename C, typename T> vector<T> prefixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0R (i, sz(v)) res[i+1] = res[i] + v[i]; return res;\n    }\n    template<typename C, typename T> vector<T> suffixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0Rd (i, sz(v)) res[i] = v[i] + res[i+1]; return res;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.precision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N); vi l(N), w(N);\n    F0R (i, N) {\n        re(l[i], w[i]);\n        w[i] -= l[i];\n    }\n\n    ll c = 0, ladj = 0, radj = 0;\n    priority_queue<ll> left;\n    priority_queue<ll, vll, greater<ll>> right;\n    left.push(l[0]);\n    right.push(l[0]);\n\n    FOR (i, 1, N) {\n        ladj -= w[i];\n        radj += w[i-1];\n\n        if (l[i] < left.top() + ladj) {\n            c += (left.top() + ladj) - l[i];\n            right.push(left.top() + ladj - radj);\n            left.pop();\n            F0R (rep, 2) left.push(l[i] - ladj);\n        } else if (l[i] > right.top() + radj) {\n            c += l[i] - (right.top() + radj);\n            left.push(right.top() + radj - ladj);\n            right.pop();\n            F0R (rep, 2) right.push(l[i] - radj);\n        } else {\n            left.push(l[i] - ladj);\n            right.push(l[i] - radj);\n        }\n\n        assert(sz(left) == sz(right));\n    }\n\n    ps(c);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n// }}}\n// pre-written code {{{\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\nint N;\nInt l[100010], r[100010];\n\nInt f(Int l0){\n\tInt cost = abs(l0-l[0]);\n\tInt r0 = l0 + r[0] - l[0];\n\tfor(int i=1;i<N;i++){\n\t\tif(r0<l[i]){\n\t\t\tcost+=l[i]-r0;\n\t\t\tl0 = r0;r0 = l0+r[i]-l[i];\n\t\t}else if(r[i]<l0){\n\t\t\tcost+=l0-r[i];\n\t\t\tr0 = l0;l0 = r0 - (r[i]-l[i]);\n\t\t}else{\n\t\t\tl0 = l[i];r0 = r[i];\n\t\t}\n\t}\n\treturn -cost;\n}\n\npair<Int,Int> find_max(Int a, Int b, Int f(Int)) {\n\tconst long double r = 2 / (3 + sqrt(5));\n\tlong double cd = a + r * (b - a), dd = b - r * (b - a);\n\tInt c = (Int)cd, d = (Int)(dd+1);\n\tInt fc = f(c), fd = f(d);\n//\twhile (d - c > EPS) {\n\twhile (d - c >=10) {\n//\t\tcerr<<\" \"<<a<<\" \"<<c<<\" \"<<d<<\" \"<<b<<endl;\n\t\tif (fc < fd) { // '<': maximum, '>': minimum\n//\t\t\ta = c; c = d; d = (b - r * (b - a));\n\t\t\ta = c; c = d; d = (Int)(b - r * (b - a)+1);\n\t\t\tfc = fd; fd = f(d);\n\t\t} else {\n//\t\t\tb = d; d = c; c = a + r * (b - a);\n\t\t\tb = d; d = c; c = (Int)(a + r * (b - a));\n\t\t\tfd = fc; fc = f(c);\n\t\t}\n\t}\n//\treturn c;\n\treturn {a,b};\n}\n\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>l[i]>>r[i];\n\t/*\n\tauto p = find_max(0ll,2000000000ll,f);\n\t*/\n//\tcerr<<\" \"<<p.first<<\" \"<<p.second<<endl;\n\tInt ans = 1e+18;\n\tfor(int i=0;i<=400;i++){\n\t\tans = min(ans,-f(i));\n\t}\n\t/*\n\tfor(Int l = p.first;l<=p.second;l++){\n\t\tans = min(ans,-f(l));\n\t}\n\t*/\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> a(n),b(n);\n  REP(i,n) cin >> a[i] >> b[i];\n  \n  assert(n <= 400);\n\n  int N = 444;\n  mat dp(N,vec(N,0));\n  REP(i,n){\n    assert(a[i] <= 400 && b[i] <= 400);\n    REP(j,N) dp[i+1][j] = INF;\n    FOR(j,1,401){\n      int tmp = abs(j-a[i]);\n      int len = b[i]-a[i]+1;\n      if(j+len >= N) continue;\n      int mn = INF;\n      REP(k,len) mn = min(mn,dp[i][j+k]);\n      REP(k,len) dp[i+1][j+k] = min(dp[i+1][j+k],mn+tmp);\n    }\n  }\n\n  int ans = INF;\n  REP(i,N) ans = min(ans,dp[n][i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define mp make_pair\ntypedef long long ll;\nmultiset<ll> pos,neg;\nint timer;\nll len[100011];\nll shiftpos,shiftneg;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tll m=0; ll c=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tlen[i]=r-l;\n\t\tif(i>0){shiftpos+=len[i-1]; c-=len[i-1]*m;}\n\t\tshiftneg-=len[i];\n\t\tpos.insert(l-shiftpos); pos.insert(l-shiftpos);\n\t\tauto it=pos.begin(); ll res=(*it)+shiftpos;\n\t\tpos.erase(pos.begin()); neg.insert(res-shiftneg);\n\t\tll neglas=(*prev(neg.end()))+shiftneg;\n\t\tll posles=(*pos.begin())+shiftpos;\n\t\tif(!neg.empty()&&neglas>posles)\n\t\t{\n\t\t\tneg.erase(prev(neg.end())); pos.erase(pos.begin());\n\t\t\tpos.insert(neglas-shiftpos); neg.insert(posles-shiftneg);\n\t\t}\n\t\tm++; c-=l;\n\t}\n\twhile(m>0)\n\t{\n\t\tc+=(*prev(pos.end()))+shiftpos;\n\t\tm--;\n\t\tpos.erase(prev(pos.end()));\n\t}\n\tcout<<c<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\nconst int BufMax=364364;\nstruct Kyuri{\n\tKyuri *l,*r;\n\tint x,lz,rng,s;\n\tvoid Propagate(){\n\t\tif(l)l->lz+=lz;\n\t\tif(r)r->lz+=lz;\n\t\tx+=lz;\n\t\tlz=0;\n\t}\n\tKyuri* Update(){\n\t\ts=1;\n\t\tif(l)s+=l->s;\n\t\tif(r)s+=r->s;\n\t\treturn this;\n\t}\n} ks[BufMax];\nKyuri* Merge(Kyuri* a,Kyuri* b){\n\tif(!a)return b;\n\tif(!b)return a;\n\tif(a->rng>b->rng){\n\t\ta->Propagate();\n\t\ta->r=Merge(a->r,b);\n\t\treturn a->Update();\n\t}else{\n\t\tb->Propagate();\n\t\tb->l=Merge(a,b->l);\n\t\treturn b->Update();\n\t}\n}\npair<Kyuri*,Kyuri*> SplitByX(Kyuri* a,int x){\n\tif(!a)return MP((Kyuri*)0,(Kyuri*)0);\n\ta->Propagate();\n\tif(x<=a->x){\n\t\tauto s=SplitByX(a->l,x);\n\t\ta->l=s.second;\n\t\treturn MP(s.first,a->Update());\n\t}else{\n\t\tauto s=SplitByX(a->r,x);\n\t\ta->r=s.first;\n\t\treturn MP(a->Update(),s.second);\n\t}\n}\npair<Kyuri*,Kyuri*> SplitByS(Kyuri* a,int s){\n\tif(!a)return MP((Kyuri*)0,(Kyuri*)0);\n\tif(s==0)return MP((Kyuri*)0,a);\n\tif(s==a->s)return MP(a,(Kyuri*)0);\n\ta->Propagate();\n\tint c=a->l?a->l->s:0;\n\tif(s<=c){\n\t\tauto g=SplitByS(a->l,s);\n\t\ta->l=g.second;\n\t\treturn MP(g.first,a->Update());\n\t}else{\n\t\tauto g=SplitByS(a->r,s-1-c);\n\t\ta->r=g.first;\n\t\treturn MP(a->Update(),g.second);\n\t}\n}\nKyuri* GetL(Kyuri* a){\n\tif(!a->l)return a;\n\ta->Propagate();\n\treturn GetL(a->l);\n}\nvoid GetX(Kyuri* a,vi& dst){\n\tif(!a)return;\n\ta->Propagate();\n\tGetX(a->l,dst);\n\tdst.PB(a->x);\n\tGetX(a->r,dst);\n}\nKyuri* newNode(int x){\n\tstatic int c=0;\n\tks[c].x=x;\n\tks[c].s=1;\n\treturn ks+(c++);\n}\n\nsigned main(){\n\tREP(i,BufMax)ks[i].rng=(int(rand())<<32)|rand();\n\tint n=read();\n\tvector<pi> w;\n\tREP(i,n){\n\t\tint l=read(),r=read();\n\t\tw.PB(pi(l,r));\n\t}\n\tKyuri* root=Merge(newNode(w[0].first),newNode(w[0].first));\n\t__int128 cost=0;\n\tFOR(i,1,n){\n\t\tauto s=SplitByS(root,i);\n\t\ts.first->lz-=w[i].second-w[i].first;\n\t\ts.second->lz+=w[i-1].second-w[i-1].first;\n\t\troot=Merge(s.first,s.second);\n\t\tauto g=GetL(root);\n\t\tint gx=g->x+g->lz;\n\t\ts=SplitByX(root,w[i].first);\n\t\troot=Merge(Merge(s.first,newNode(w[i].first)),Merge(newNode(w[i].first),s.second));\n\t\tint hx=min(gx,w[i].first);\n\t\tcost+=(gx-hx)*i;\n\t\tcost+=w[i].first-hx;\n\t}\n\tvi x;\n\tGetX(root,x);\n\tFOR(i,1,n)cost+=(x[i]-x[i-1])*(i-n);\n\tcout<<int(cost)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1024;\n\nint dp[N + N][N + N];\nint l[N], r[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  for (int i = 0; i < N; i++) {\n    dp[0][i] = abs(i-l[i]);\n  }\n  for (int i = 0; i + 1 < n; i++) {\n    int sbef = r[i]-l[i], snow = r[i+1]-l[i+1];\n    deque< int > dq;\n    for (int j = 0; j < snow; j++) {\n      while (!dq.empty()) {\n        if (dq.front() > dp[i][j])\n          dq.pop_front();\n        else\n          break;\n      }\n      dq.push_front(dp[i][j]);\n    }\n    for (int j = 0; j < N; j++) {\n      while (!dq.empty()) {\n        if (dq.front() > dp[i][j+snow])\n          dq.pop_front();\n        else\n          break;\n      }\n      dq.push_front(dp[i][j+snow]);\n      dp[i+1][j] = ((l[i+1] <= j && j <= r[i+1]) ? 0 : min(abs(l[i+1]-j), abs(j-r[i+1]))) + dq.back();\n      if (j-sbef >= 0 && dq.back() == dp[i][j-sbef])\n        dq.pop_back();\n      // if (j < 20)\n        // cerr << dp[i+1][j] << \" \";\n    }\n    // cerr << i+ 1<< endl;\n  }\n  int ans = dp[n-1][0];\n  for (int i = 0; i < N; i++)\n    ans = min(ans, dp[n-1][i]);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define ABS(a) (((a)>0)?(a):(-(a)))\nint n,l[505],r[505],dp[505][505];\nint main(){\n\tscanf(\"%d\",&n);\n\tint xb,x2,x3,res=1e9;\n\tfor(xb=0;xb<n;xb++) scanf(\"%d%d\",&l[xb],&r[xb]);\n\tif(n==1){\n\t\tprintf(\"0\");\n\t\treturn 0;\n\t}\n\tfor(xb=1;xb<n;xb++){\n\t\tfor(x2=0;x2<500;x2++){\n\t\t\tint rb=x2+r[xb]-l[xb];\n\t\t\tdp[xb][x2]=1e9;\n\t\t\tfor(x3=MAX(0,x2+l[xb-1]-r[xb-1]-3);x3<=rb;x3++){\n\t\t\t\tdp[xb][x2]=MIN(dp[xb][x2],dp[xb-1][x3]+ABS(x3-l[xb-1]));\n\t\t\t}\n\t\t\tif(xb==n-1) res=MIN(res,dp[xb][x2]+ABS(l[xb]-x2));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int N;\nlong long int l[100000], r[100000];\nlong long int ans, box;\n\nint main() {\n\tcin >> N;\n\tans = 1000000000;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tfor (int i = 1; i <= 400; i++) {\n\t\tbox = 0;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (l[j] > i)box += l[j] - i;\n\t\t\telse if (r[j] < i)box += i - r[j];\n\t\t}\n\t\tans = min(ans, box);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define x first\n# define y second\n# define mp make_pair\n// everything goes according to my plan\n# define pb push_back\n# define sz(a) (int)(a.size())\n# define vec vector\n// shimkenttin kyzdary, dzyn, dzyn, dzyn...\n# define y1    Y_U_NO_y1\n# define left  Y_U_NO_left\n# define right Y_U_NO_right\n\n//put debug temp\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int Mod = (int)1e9 + 7;\nconst int MX = 1073741822;\nconst ll MXLL = 4e18;\nconst int Sz = 1110111;\n// a pinch of soul\ninline void Read_rap () {\n  ios_base :: sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n}\ninline void randomizer3000 () {\n  unsigned int seed;\n  asm (\"rdtsc\" : \"=A\"(seed));\n  srand (seed);\n}\nvoid files (string problem) {\n  if (fopen ((problem + \".in\").c_str(),\"r\")) {\n    freopen ((problem + \".in\").c_str(),\"r\",stdin);\n    freopen ((problem + \".out\").c_str(),\"w\",stdout);\n  }\n}\nvoid localInput(const char in[] = \"s\") {\n  if (fopen (in, \"r\")) {\n    freopen (in, \"r\", stdin);\n  }\n  else\n    cerr << \"Warning: Input file not found\" << endl;\n}\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, \nrb_tree_tag, tree_order_statistics_node_update>;\n\npii a[Sz];\n\nint main()\n{\n  # ifdef Local\n    //localInput();\n  # endif\n  Read_rap();\n  int n;\n  cin >> n;\n  set<pii> pt;\n  \n  for (int i = 1; i <= n; i++) {\n  \tcin >> a[i].first >> a[i].second;\n  \tfor (int x = -1; x <= 1; x++) {\n  \t\tpt.insert(mp(x + a[i].first, 1));\t\n  \t\tpt.insert(mp(x + a[i].second, 2));\n  \t}\n  }\n\n  // sort (a+1, a+1 + n, [] (pii a, pii b) {\n  // \treturn mp(a.second, a.first) < mp(b.second, b.first);\n  // });\n\n  ll ans = MXLL;\n  for (auto y : pt) {\n  \tint x = y.first;\n  \tll res = 0;\n\n  \tfor (int i = 1; i <= n; i++) {\n\n  \t\tif (a[i].second < x) \n  \t\t\tres += x - a[i].second;\n  \t\tif (a[i].first > x)\n  \t\t\tres += a[i].first - x;\n  \t}\n  \t//cout << x << ' ' << res << endl;\n  \tans = min (ans, res);\n  }\n  cout << ans;\n  return 0;\n}\n\n\n\n\n\n// Coded by Z.."
  },
  {
    "language": "C++",
    "code": "//new.cpp\n/*\nAuthor : Hocky Yudhiono\nMin 03 Mar 2019 03:21:18  WIB\nCurrent Local Time : 15:21:18\n\ngetchar_unlocked > getchar > cin without sync > scanf > cin with sync\nbool operator<(const MyStruct& rhs) const\n\nOn how to print Long Double to 5 decimal places :\nprintf(\"%.5Lf\",ans);\n\nOn how to get random numbers :\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); //For int\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); //For LL\ncout << rng() << endl;\nshuffle(isi.begin(),isi.end(),rng);\n\n*/\n\n//#include <unordered_map>\n//#include <unordered_set>\n\n//#include <random>\n//#include <chrono>\n\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <cstdio>\n#include <limits>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n//using namespace __gnu_pbds;\nusing namespace std;\n\n#if 0\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(3)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n#pragma GCC target(\"f16c\")\n#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n#pragma GCC diagnostic error \"-fwhole-program\"\n#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n#pragma GCC diagnostic error \"-std=c++14\"\n#pragma GCC target (\"string\"...)\n#pragma GCC push_options\n#pragma GCC pop_options\n#pragma GCC reset_options\n#pragma GCC optimize (\"O3\")\n#endif\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n// typedef tree<long long, null_type, less<long long>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n//If the time limit is strict, try not to use long double\n\n\n#define fbo find_by_order\n#define ook order_of_key\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define remove erase\n//Remember to undefine if the problem is interactive\n#define endl '\\n'\n#define DEBUG(X) cout << \">>> DEBUG(\" << __LINE__ << \") \" << #X << \" = \" << (X) << endl\n\nconst double eps = 1e-9;\nconst int INFMEM = 63;\nconst int INF = 1061109567;\nconst LL LINF = 4557430888798830399LL;\nconst double DINF = numeric_limits<double>::infinity();\nconst LL MOD = 1000000007;\nconst int dx[8] = {1,0,-1,0,1,1,-1,-1};\nconst int dy[8] = {0,1,0,-1,1,-1,1,-1};\nconst double PI = 3.141592653589793;\n\n#ifdef _WIN32\n#define getchar_unlocked getchar\n#endif\n#define GETCHAR getchar_unlocked\ninline void fastll(LL &input_number) \n{\n    input_number = 0;\n    int ch = GETCHAR();\n    int sign = 1;\n    while(ch < '0' || ch > '9'){\n        if(ch == '-') sign=-1;\n        ch = GETCHAR();\n    }\n    while(ch >= '0' && ch <= '9'){\n        input_number = (input_number << 3)+(input_number << 1) + ch-'0';\n        ch = GETCHAR();\n    }\n    input_number *= sign;\n}\n\ninline void open(string a){\n    freopen((a+\".in\").c_str(),\"r\",stdin);\n    freopen((a+\".out\").c_str(),\"w\",stdout);\n}\n\ninline void fasterios(){\n    //Do not use if interactive\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n}\n\n/*\n6 1\n2 10 0 2 4 3\n\n10\n=================\n\n6 3\n2 10 2 6 4 3\n\n6\n=================\n\n4 1\n1 4 1 4\n\n4\n=================\n\n10 1\n10 9 8 7 6 5 4 3 2 1\n\n0\n=================\n3 0\n1 1 3\n\n2\n=================\n*/\n\nLL n,h,l[100005],r[100005],len[100005];\n\npriority_queue<LL> lower;\n//Grafik yang slopenya negatif\n\npriority_queue<LL,vector<LL>,greater<LL>> upper;\n//Grafik yang slopenya positif\n\nLL lazylow, lazyhigh;\n\nint main(){\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n    \tcin >> l[i] >> r[i];\n    \tlen[i] = r[i]-l[i];\n    }\n    //dp(n,k) = minimum cost untuk kayu ke n, apabila kepala kayu ke n berada pada posisi k\n    //define len[i] = r[i]-l[i]\n    // dp(n,k) = allmin[ k-len[i-1] <= K' <= k+len[i] ] dp(n-1,K') + |k-l[i]|\n    // dp(n,k) (baru) pengen dari dp(n-1,k-len[i-1])\n    // dp(n,k) (baru) pengen dari dp(n-1,k+len[i])\n\tLL ans = 0;\n\tupper.push(l[1]); lower.push(l[1]);\n\tfor(int i = 2;i <= n;i++){\n\t\tlazylow -= len[i];\n\t\t//Lazylow would be negative\n\t\t// as we translate it more to the left\n\t\tlazyhigh += len[i-1];\n\t\t// Lazyup would be positive\n\t\t//Kasus 1\n\t\t// cout << lazylow << \" \" << lazyhigh << endl;\n\t\tif(l[i] <= lower.top()+lazylow){\n\t\t\t// cout << \"Kasus 1 \" << endl;\n\t\t\t//The update point is on the negative slope of our graph\n\t\t\tLL shifted = lower.top()+lazylow;\n\t\t\tans += (shifted-l[i]);\n\t\t\tlower.push(l[i]-lazylow);\n\t\t\tlower.push(l[i]-lazylow);\n\t\t\tlower.pop();\n\t\t\tupper.push(shifted-lazyhigh);\n\t\t}\n\t\t// kasus 2\n\t\telse if(l[i] >= upper.top()+lazyhigh) {\n\t\t\t// cout << \"Kasus 2 \" << endl;\n\t\t\t//The update point is on the positive slope of our graph\n\t\t\tLL shifted = upper.top()+lazyhigh;\n\t\t\tans += (l[i]-shifted);\n\t\t\tupper.push(l[i]-lazyhigh);\n\t\t\tupper.push(l[i]-lazyhigh);\n\t\t\tupper.pop();\n\t\t\tlower.push(shifted-lazylow);\n\t\t}\n \n\t\t// kasus 3\n\t\telse {\n\t\t\t// cout << \"Kasus 3 \" << endl;\n\t\t\tlower.push(l[i]-lazylow);\n\t\t\tupper.push(l[i]-lazyhigh);\n\t\t}\n\t\t// cout << \"here got \" << i << \" \" << ans << endl;\n\t}\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\npriority_queue<LL , vector<LL> , greater<LL> > pq2;\npriority_queue<LL> pq1;\nLL add1,add2,val;\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tpq1.push(0);pq2.push((int)1e9);\n\tfor(int i=1,last=0,l,r;i<=n;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(i!=1){\n\t\t\tadd1-=r-l;\n\t\t\tadd2+=last;\n\t\t}\n\t\tLL pl=pq1.top()+add1,pr=pq2.top()+add2;\n\t\tif(l<pl){\n\t\t\tpq1.pop(),pq2.push(pl-add2),pq1.push(l-add1),pq1.push(l-add1);\n\t\t\tval+=pl-l;\n\t\t}else if(l>pr){\n\t\t\tpq2.pop(),pq1.push(pr-add1),pq2.push(l-add2),pq2.push(l-add2);\n\t\t\tval+=l-pr;\n\t\t}else{\n\t\t\tpq1.push(l-add1),pq2.push(l-add2);\n\t\t\tval+=0;\n\t\t}\n\t\tlast=r-l;\n\t}\n\tcout<<val<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ls (o << 1)\n#define rs (o << 1 | 1)\n#define mid ((L + R) >> 1)\nusing namespace std;\nconst int MAXN = 100100;\nconst int mod = 998244353;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nint n, ll[MAXN], rr[MAXN];\npriority_queue<LL> L;\npriority_queue<LL, vector<LL>, greater<LL> > R;\nint main() {\n#ifdef TEST\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tscanf(\"%d\", &n);\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", &ll[i], &rr[i]);\n\t\tll[i] = rr[i] - ll[i];\n\t}\n\tL.push(rr[0]);\n\tR.push(rr[0]);\n\tLL l = 0, r = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tl += ll[i - 1];\n\t\tr += ll[i];\n\t\tLL topl = L.top() - l;\n\t\tLL topr = R.top() + r;\n\t\tif (rr[i] >= topl && rr[i] <= topr) {\n\t\t\tL.push(rr[i] + l);\n\t\t\tR.push(rr[i] - r);\n\t\t} else if (rr[i] > topr) {\n\t\t\tans += rr[i] - topr;\n\t\t\tL.push(topr + l);\n\t\t\tR.pop();\n\t\t\tR.push(rr[i] - r);\n\t\t\tR.push(rr[i] - r);\n\t\t} else {\n\t\t\tans += topl - rr[i];\n\t\t\tL.pop();\n\t\t\tR.push(topl - r);\n\t\t\tL.push(rr[i] + l);\n\t\t\tL.push(rr[i] + l);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 200010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nmultiset<ll> L, R;\nint A[MAX_N], B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i] >> B[i];\n\tint a = A[0], b = A[0];\n\tL.insert(A[0]); R.insert(A[0]);\n\tL.insert(-inf); R.insert(inf);\n\tll ans = 0;\n\trep(i, 1, N) {\n\t\ta -= B[i] - A[i];\n\t\tb += B[i - 1] - A[i - 1];\n\t\t//debug(a, b);\n\t\tint l = *L.rbegin(), r = *R.begin();\n\t\tif(a <= A[i] && A[i] <= b) {\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\ta = A[i]; b = A[i];\n\t\t}\n\t\telse if(A[i] < a) {\n\t\t\tans += abs(A[i] - a);\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tint le = *L.rbegin() + (a - l);\n\t\t\tL.erase(--L.end());\n\t\t\tR.insert(le - (b - r));\n\t\t\ta = *L.rbegin() + (a - l);\n\t\t\tb = le;\n\t\t}\n\t\telse {\n\t\t\tans += abs(A[i] - b);\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\tint rb = *R.begin() + (b - r);\n\t\t\tR.erase(R.begin());\n\t\t\tL.insert(rb - (a - l));\n\t\t\ta = rb;\n\t\t\tb = *R.begin() + (b - r);\n\t\t}\n\t\t//debug(a, vi(all(L)));\n\t\t//debug(b, vi(all(R)));\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define all(x) (x).begin() , (x).end()\n#define rall(x) (x).rbegin() , (x).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define int long long\nconst int N = 401;\nll dp[2][N];\nconst ll inf = 1e18;\nsigned main(){\n    int n;cin >> n;\n    vector < pair < int , int > > line(n + 1);\n    for(int i = 1; i <= n; ++i)\n        cin >> line[i].fi >> line[i].se;\n    line[0] = {0 , 0};\n    for(int i = 1 ; i <= n; ++i){\n        fill(dp[i&1] , dp[i&1] + N , inf);\n        int l , r , l1 , r1;\n        for(int j = 0; j < N; ++j){\n            l = j , r = j + line[i].se - line[i].fi;\n            if(r >= N)continue;\n            for(int prev = 0 ; prev < N; ++prev){\n                l1 = prev , r1 = prev + line[i-1].se - line[i-1].fi;\n                if(r < l1 || r1 < l)continue;\n                ll COST = inf;\n                if(r < l1)\n                    COST = l1 - r;\n                else if(l > r1)\n                    COST = l - r1;\n                else COST = 0;\n                dp[i&1][j] = min(dp[i&1][j] , dp[(i&1)^1][prev] + COST);\n            }\n        }\n    }\n    int ans = *min_element(dp[n&1] , dp[n&1] + N);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + ofL;\n\t\tret += (temp - L);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + ofR;\n\t\tret += (L - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tmultiset<LL>::iterator Left,Right;\n\t\tLeft = LS.end();\n\t\tLeft--;\n\t\tRight = RS.begin();\n\t\t/*\n\t\tif( L < *Left + ofL ){\n\t\t\tLL temp = *Left + ofL;\n\t\t\tret += (temp - L);\n\t\t\n\t\t\tRS.insert( temp - ofR );\n\n\t\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\t\tLS.insert( L - ofR );\n\t\t\tLS.insert( L - ofR );\n\t\t}else if( *Right + ofR < L ){\n\t\t\tLL temp = *Right + ofR;\n\t\t\tret += (L - temp);\n\n\t\t\tRS.erase( Right );\n\t\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\t\tLS.insert( temp - ofL );\n\t\t}\n\t\t*/\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tadd2init();\n\taddABSfunc2(0,0,L[0]);\n\tfor(int i=1;i<N;++i){\n\t\taddABSfunc2(R[i]-L[i],R[i-1]-L[i-1],L[i]);\n\t}\n\tcout << ret2 << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve3();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\nusing namespace std;\nconst int MAXN=100000;\ntypedef long long LL;\nint l[MAXN+5],r[MAXN+5],n;\npriority_queue <LL> pqkiri;\npriority_queue <LL,vector<LL>,greater<LL> >pqkanan;\nLL ans=0,konstankiri=0,konstankanan=0;\nvoid urusgeser(int idx){\n\tint geser;\n\t//geser untuk pq kiri\n\tkonstankiri+=-(r[idx]-l[idx]);\t\t\t//karena geser ke kiri jadi minus\n\t\n\t//geser untuk pq kanan;\n\tkonstankanan+=(r[idx-1]-l[idx-1]);\n}\nbool ngecek(){\n\treturn (pqkiri.top()+konstankiri<=pqkanan.top()+konstankanan);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tif(i==1)\n\t\t{\n\t\t\tpqkiri.push(l[i]);\n\t\t\tpqkanan.push(l[i]);\n\t\t\tcontinue;\n\t\t}\n\t\turusgeser(i);\n\t\t\n\t\tif((pqkiri.top()+konstankiri)<=l[i]&&l[i]<=(pqkanan.top()+konstankanan))\t\t\t//muncul di antaranya\n\t\t{\n\t\t\tpqkiri.push(l[i]-konstankiri);\n\t\t\tpqkanan.push(l[i]-konstankanan);\n\t\t}\n\t\telse if(pqkiri.top()+konstankiri>l[i])\t\t\t\t\t\t\t//kasus di sebelah kiri\n\t\t{\n\t\t\tpqkiri.push(l[i]-konstankiri);\n\t\t\tpqkiri.push(l[i]-konstankiri);\n\t\t\tLL temp=pqkiri.top()+konstankiri;\n\t\t\tans+=pqkiri.top()-(l[i]-konstankiri);\n\t\t\tpqkiri.pop();\n\t\t\tpqkanan.push(temp-konstankanan);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpqkanan.push(l[i]-konstankanan);\n\t\t\tpqkanan.push(l[i]-konstankanan);\n\t\t\tLL temp=pqkanan.top()+konstankanan;\n\t\t\tans+=(l[i]-konstankanan)-pqkanan.top();\n\t\t\tpqkanan.pop();\n\t\t\tpqkiri.push(temp-konstankiri);\n\t\t}\n\t\tassert(ngecek());\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define f(z) for(int i=1;i<=z;i++)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define vi vector<int>\n#define pb push_back\n#define si set<int>\n#define mod  1000000007\n#define cl(n,m) (n-1)/m  + 1 ;\n#define T() int TT; cin>>TT; while(TT--)\n#define P pair<int,int>\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n \nconst int N = 2e6 + 5 ;\nint inf = N*N ;\nint l[N] , r[N] , ans = inf , dp[401][401];\nsigned main(){\n\tint n ;\n\tcin >> n ;\n\tf(n) {\n\t\tcin >> l[i] >> r[i] ; \n\t}\n\tfor ( int i = 0 ; i<=400 ; i++){\n\t\tdp[1][i] = abs( i - l[1] ) ;\n\t}\n\tfor ( int i = 2 ; i<=n ; i++){\n\t\tfor ( int j = 0 ; j<=400 ; j++){\n\t\t\tdp[i][j] = inf ;\n\t\t\tfor ( int k = 0 ; k<=400 ; k++){\n\t\t\t\tint x = max( j , k ) ; \n\t\t\t\tint y = min( j + r[i] - l[i],k +  r[i-1] - l[i-1] ) ;\n\t\t\t\tif( x<=y ) \n\t\t\t\t\tdp[i][j] =  min( dp[i][j] ,abs( l[i] - j) + dp[i-1][k]) ;\n\t\t\t\t\n\t\t\t}\n\t\t\tif( i==n ) \n\t\t\tans = min ( ans , dp[i][j] ) ;\n\t\t}\n\n\t}\n\tcout << ans ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nstd::priority_queue<LL> L;\nstd::priority_queue<LL, std::vector<LL>, std::greater<LL> > R;\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tint n; std::cin >> n;\n\tconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\n\tL.push(-INF), R.push(INF);\n\tLL tl = 0, tr = 0, lst = 0, ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tLL l, r, len; std::cin >> l >> r;\n\t\ttl -= lst, tr += len = r - l, lst = len;\n\t\tLL pl = L.top() + tl, pr = R.top() + tr;\n\t\tif (pl <= r && r <= pr) L.push(r - tl), R.push(r - tr);\n\t\telse if (r < pl) {\n\t\t\tL.pop(); L.push(r - tl), L.push(r - tl), R.push(pl - tr);\n\t\t\tans += pl - r;\n\t\t} else {\n\t\t\tR.pop(), R.push(r - tr), R.push(r - tr), L.push(pr - tl);\n\t\t\tans += r - pr;\n\t\t}\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug==\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<60;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-12;};\ntemplate<> inline long double EPS<long double>(){return 1e-12;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> inline T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> inline T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tif(N > 400) return;\n\t\tvector<pair<int,int>> rs(N); cin >> rs;\n\t\t// sort(ALL(rs));\n\n\t\tvector<vector<ll>> dp(N,vector<ll>(501,INF<ll>()));\n\t\tfor(int r:range(500)){\n\t\t\tdp[0][r] = abs(rs[0].second - r);\n\t\t}\n\n\t\tfor(int i:range(1,N)){\n\t\t\tfor(int rp:range(500)){\n\t\t\t\tfor(int r:range(500)){\n\t\t\t\t\tint lp = rp-(rs[i-1].second-rs[i-1].first), l = r-(rs[i].second-rs[i].first);\n\t\t\t\t\tif((lp <= l && l <= rp) || (lp <= r && r <= rp)\n\t\t\t\t|| (l <= lp && lp <= r) || (l <= rp && rp <= r)){\n\t\t\t\t\t\tdp[i][r] =  min(dp[i][r],dp[i-1][rp] + abs(rs[i].second - r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll res = INF<ll>();\n\t\tfor(int r:range(500)) res = min(res,dp[N-1][r]);\n\n\t\tcout << res << endl;\n\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\npii po[425];\nint cost[425][425];\n\nint main(){\n  scanf(\"%d\",&n);\n  assert(n<=425);\n  REP(i,n){\n    int l,r;\n    scanf(\"%d%d\",&l,&r);\n    assert(r<=425);\n    --l;--r;\n    po[i] = pii(l,r);\n  }\n  REP(i,n){\n    REP(j,425)cost[i+1][j]=1e9;\n    int l,r;\n    l = po[i].first;\n    r = po[i].second;\n    int len = r-l+1;\n    REP(j,425){\n      int sa = abs(l-j);\n      int mn = 1e9;\n      FOR(k,j,j+len)if(k<425){\n        CHMIN(mn,cost[i][k]);\n      }\n      FOR(k,j,j+len)if(k<425){\n        CHMIN(cost[i+1][k],mn+sa);\n      }\n    }\n    // REP(j,10)printf(\"%d \",cost[i+1][j]);\n    // puts(\"\");\n  }\n  int ans = 1e9;\n  REP(i,425)CHMIN(ans,cost[n][i]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n\nstatic int getMinCost(multiset<int> nodes,\n\t       int curmincost,\n\t       int minpos)\n{\n    if (nodes.size() == 0) {\n\treturn curmincost;\n    }\n    \n    int len = nodes.size();\n    auto ll = nodes.begin();\n    for (int i = 0; i < len / 2 - 1; i++) {\n\tll++;\n    }\n    auto rf = ll;\n    rf++;\n\n    //cout << *rf << \" \" << *ll << \" \" << minpos << endl;\n    if (*ll <= minpos) {\n\tif (minpos <= *rf) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - *rf + curmincost;\n    } else {\n\treturn *ll - minpos + curmincost;\n    }\n}\n\nint main(void){\n    int n;\n    int mincost;\n    multiset<int> nodess[2];\n    multiset<int> *p;\n    multiset<int> *np;\n    stringstream st;\n    string line;\n    vector<pair<int, int>> rects;\n\n    \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n    for (int i = 0; i < n; i++) {\n\tint l, r;\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> l >> r;\n\trects.push_back(pair<int, int>(l, r));\n    }\n\n    mincost = 0;\n\n    for (int i = 1; i < n; i++) {\n\tp = &nodess[i % 2];\n\tnp = &nodess[(i + 1) % 2];\n\tint l = rects[i - 1].first;\n\tint r = rects[i - 1].second;\n\tint nl = rects[i].first;\n\tint nr = rects[i].second;\n\tmincost = getMinCost(*p, mincost, l);\n\t//cout << l << \" \" << r << \" \" << mincost << endl;\n\tp->insert(l);\n\tp->insert(l);\t\n\tint len = p->size();\n\tint j = 0;\n\tnp->clear();\n\tfor (auto &e : *p) {\n\t    int nv = 0;\n\t    if (j < len / 2) {\n\t\tnv = e - (nr - nl);\n\t    } else {\n\t\tnv = e + (r - l);\n\t    }\n\t    np->insert(nv);\n\t    j++;\n\t}\n\t#if 0\n\tfor (auto e : *np) {\n\t    cout << e << \" \";\n\t}\n\tcout << endl;\n\t#endif\t\n\t\n    }\n    mincost = getMinCost(*np, mincost, rects[n - 1].first);\n\n    cout << mincost << endl;\n    return 0;\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n#define first fi\n#define second se\n#define sz(x) (int)x.size()\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9+7;\n\nconst int N = 405;\n\nint n, dp[N][N];\n\nint main() {\n    scanf(\"%d\", &n);\n    int l, r;\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d%d\", &l, &r);\n        for (int j = 0; j <= 400; j++) dp[i][j] = inf;\n        for (int j = 0; j <= 400; j++) {\n            for (int k = 0; k < r - l + 1; k++) {\n                if (j + k <= 400) dp[i][j + k] = min(dp[i][j + k], dp[i - 1][j] + abs(l - j));\n                if (j - k >= 0) dp[i][j - k] = min(dp[i][j - k], dp[i - 1][j] + abs(r - j));\n            }\n        }\n    }\n    int ans = inf;\n    for (int j = 0; j <= 400; j++) ans = min(ans, dp[n][j]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi l(n), r(n);\n  rep(i,n) cin>>l[i]>>r[i];\n  priority_queue<ll> ql;\n  PQ(ll) qr;\n  ll offl = 0, offr = 0;\n  ql.push(0); qr.push(0);\n  ll ans = 0;\n  rep(i,n-1) {\n    ll xl = r[i+1]-l[i];\n    ll xr = l[i+1]-r[i];\n    offl -= xl; offr -= xr;\n    if (offl+ql.top() >= 0) {\n      ql.push(-offl); ql.push(-offl);\n      ll x = ql.top()+offl; ql.pop();\n      ans += x;\n      qr.push(x-offr);\n    } else if (offr+qr.top() <= 0) {\n      qr.push(-offr); qr.push(-offr);\n      ll x = qr.top()+offr; qr.pop();\n      ans += -x;\n      ql.push(x-offl);\n    } else {\n      ql.push(-offl);\n      qr.push(-offr);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-6;\nconst double pi = atan2(0, -1);\n\nstruct Queue\n{\n    stack<pair<int, int> > s1, s2;\n    Queue() {}\n    void push(int x)\n    {\n        if (s1.empty())\n            s1.push({x, x});\n        else\n            s1.push({x, min(s1.top().se, x)});\n    }\n    void pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                int x = s1.top().fi;\n                s1.pop();\n                if (s2.empty())\n                    s2.push({x, x});\n                else\n                    s2.push({x, min(s2.top().se, x)});\n            }\n        }\n        s2.pop();\n    }\n    int get_mi()\n    {\n        int res = inf;\n        if (!s1.empty())\n            res = min(res, s1.top().se);\n        if (!s2.empty())\n            res = min(res, s2.top().se);\n        return res;\n    }\n};\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"arrayop.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //int TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n][2];\n    rep(i, 0, n)\n    {\n        cin >> a[i][0] >> a[i][1];\n        a[i][0]--; a[i][1]--;\n    }\n    int ans = inf;\n    int dp[n][400];\n    rep(x, 0, n)\n    {\n        rep(i, 0, n)\n            rep(j, 0, 400)\n                dp[i][j] = inf;\n        dp[x][a[x][0]] = 0;\n        rep(i, x + 1, n)\n        {\n            Queue q;\n            rep(j, 0, a[i][1] - a[i][0] + 1)\n                q.push(dp[i - 1][j]);\n            rep(j, 0, 400 - (a[i][1] - a[i][0]))\n            {\n                dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n                if (j - (a[i - 1][1] - a[i - 1][0]) >= 0)\n                    q.pop();\n                if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                    q.push(dp[i - 1][j + (a[i][1] - a[i][0]) + 1]);\n            }\n        }\n        repb(i, x - 1, -1)\n        {\n            Queue q;\n            rep(j, 0, a[i][1] - a[i][0] + 1)\n                q.push(dp[i + 1][j]);\n            rep(j, 0, 400 - (a[i][1] - a[i][0]))\n            {\n                dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n                if (j - (a[i + 1][1] - a[i + 1][0]) >= 0)\n                    q.pop();\n                if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                    q.push(dp[i + 1][j + (a[i][1] - a[i][0]) + 1]);\n            }\n        }\n        int ans1 = inf, ans2 = inf;\n        rep(j, 0, 400)\n        {\n            ans1 = min(ans1, dp[0][j]);\n            ans2 = min(ans2, dp[n - 1][j]);\n        }\n        /*rep(i, 0, n)\n        {\n            rep(j, 0, 5)\n                if (dp[i][j] != inf)\n                    cout << dp[i][j] << \" \";\n                else\n                    cout << 'x' << \" \";\n            cout << endl;\n        }\n        cout << endl;*/\n        ans = min(ans, ans1 + ans2);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst int inf=1e8;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\ntypedef int SegT;\nconst int defvalue=inf;\nclass SegTree{\n\tpublic:\n\t\tvector<SegT>val;\n\t\tint n;\n\t\tSegT combine(SegT a,SegT b){return min(a,b);}\n\t\tSegTree(int size){\n\t\t\tn=1;\n\t\t\twhile(n<size)n<<=1;\n\t\t\tval=vector<SegT>(2*n,defvalue);\n\t\t}\n\t\tSegTree(const vector<SegT> &in){\n\t\t\tn=1;\n\t\t\twhile(n<in.size())n<<=1;\n\t\t\tval=vector<SegT>(2*n,defvalue);\n\t\t\tfor(int i=n-1+in.size()-1;i>=0;i--){\n\t\t\t\tif(n-1<=i)val[i]=in[i-(n-1)];\n\t\t\t\telse val[i]=combine(val[i*2+1],val[i*2+2]);\n\t\t\t}\n\t\t}\n\t\tvoid update(int i,SegT a){\n\t\t\ti+=n-1;\n\t\t\tval[i]=a;\n\t\t\twhile(i>0){\n\t\t\t\ti=(i-1)/2;\n\t\t\t\tval[i]=combine(val[i*2+1],val[i*2+2]);\n\t\t\t}\n\t\t}\n\t\tSegT query(int a,int b,int k=0,int l=0,int r=-1){//[a,b)\n\t\t\tif(r==-1)r=n;\n\t\t\tif(r<=a||b<=l)return defvalue;\n\t\t\tif(a<=l&&r<=b)return val[k];\n\t\t\telse return combine(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t\tvoid tmp(){\n\t\t\trep(i,val.size())cout<<\" \"<<val[i];cout<<endl;\n\t\t}\n};\nint main(){\n\tint n;\n\tcin>>n;\n\tif(n>500)return 1;\n\tvp in(n);\n\trep(i,n)cin>>in[i].first>>in[i].second;\n\tSegTree st(vi(600,inf));\n\trep(i,n){\n\t\tSegTree tmp(vi(600,inf));\n\t\trep(j,600)if(j+in[i].second-in[i].first<600){\n\t\t\tint t=st.query(max(0,j-(i?in[i-1].second-in[i-1].first:0)),j+in[i].second-in[i].first+1);\n//\t\t\tif(j<10)cout<<t<<\" \"<<abs(in[i].first-j)<<endl;\n\t\t\ttmp.update(j,(i?t:0)+abs(in[i].first-j));\n\t\t}\n\t\tst.val=tmp.val;\n//\t\trep(j,10)cout<<\" \"<<tmp.val[j+1023];cout<<endl;\n\t}\n\tint out=st.query(0,600);\n//\trep(i,600)out=min(out,st.val[i]);\n\tcout<<out<<endl;\n}\n\n/*\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tsort(all(in));\n\tll sum=0;\n\tint out=0;\n\trep(i,n){\n\t\tvi dp(k+1);\n\t\tdp[0]=1;\n\t\trep(j,n)if(i!=j){\n\t\t\tfor(int q=k;q>=0;q--)if(q+in[j]<=k)dp[q+in[j]]|=dp[q];\n\t\t}\n\t\tbool h=false;\n\t\trep(j,k)if(in[i]+j>=k&&dp[j])h=true;\n\t\tif(h)out++;\n//\t\trep(j,k+1)cout<<dp[j];cout<<endl;\n\t}\n\tcout<<n-out<<endl;\n}\n//*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 999999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\nint maxpos=-1 , minpos=MAXN;\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\tminpos = min( minpos , l[i] );\n\t\tmaxpos = max( maxpos , l[i]+len[i] );\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = 1;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> l(N), r(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tvector<vector<int>> dp(N + 1, vector<int>(401));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tif (j >= l[i] && j <= r[i]) {\n\t\t\t\tint mini = 1000000000;\n\t\t\t\tfor (int k = max(j - (r[i] - l[i]), 0); k <= min(j + (r[i] - l[i]), 400); k++) {\n\t\t\t\t\tmini = min(mini, dp[i][k] + (k >= l[i] && k <= r[i] ? 0 : min(abs(k - l[i]), abs(k - r[i]))));\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j] = mini;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint mini = 1000000000;\n\t\t\t\tfor (int k = max(j - (r[i] - l[i]), 0); k <= min(j + (r[i] - l[i]), 400); k++) {\n\t\t\t\t\tmini = min(mini, dp[i][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j] = mini + min(abs(j - l[i]), abs(j - r[i]));\n\t\t\t}\n\t\t}\n\t}\n\tint res = 1000000000;\n\tfor (int i = 0; i <= 400; i++) {\n\t\tres = min(res, dp[N][i]);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define N 400001\n#define MAX_V 400010\n#define vec vector<int>\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umap unordered_map<ll,int,custom_hash>\nstruct pair_hash\n{\n    template<class T1,class T2>\n    size_t operator() (const pair<T1,T2> &p)const{\n        return hash<T1>()(p.first)^hash<T2>()(p.second);\n    }\n};\n\n\nmain(){\n    ll n=lin();\n    priority_queue<ll> p1;\n    priority_queue<ll,vector<ll>,greater<ll>> p2;\n    ll ans=0;\n    ll d=0;\n    ll l=lin(),r=lin();\n    ll mid=l+r;\n    ll length=r-l;\n    p1.push(mid);\n    p2.push(mid);\n    rep(i,n-1){\n        l=lin();r=lin();\n        d+=length+r-l;\n        length=r-l;\n        mid=l+r;\n        ll n1=p1.top()-d,n2=p2.top()+d;\n        if(mid<=n1){\n            p2.push(n1-d);\n            p1.pop();\n            p1.push(mid+d);p1.push(mid+d);\n            ans+=p2.top()+d-mid;\n        }\n        else if(n1<mid&&mid<=n2){\n            p1.push(mid+d);\n            p2.push(mid-d);\n        }\n        else{\n            p1.push(n2+d);\n            p2.pop();\n            p2.push(mid-d);p2.push(mid-d);\n            ans+=mid-(p1.top()-d);\n        }\n    }\n    cout<<ans/2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n \nstatic int getMinCost(multiset<int> &leftNodes,\n\t\t      multiset<int> &rightNodes,\n\t\t      int curmincost,\n\t\t      int minpos)\n{\n    if (leftNodes.size() == 0) {\n\treturn curmincost;\n    }\n\n    int lmax = *max_element(leftNodes.begin(), leftNodes.end());\n    int rmin = *min_element(rightNodes.begin(), rightNodes.end());\n\n    if (lmax <= minpos) {\n\tif (minpos <= rmin) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - rmin + curmincost;\n    } else {\n\treturn lmax - minpos + curmincost;\n    }\n}\n \nint main(void){\n    int n;\n    int mincost;\n    multiset<int> leftNodess[2];\n    multiset<int> rightNodess[2];\n    multiset<int> *lp, *rp;\n    multiset<int> *nlp, *nrp;\n    stringstream st;\n    string line;\n      \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n    lp = &leftNodess[0];\n    nlp = &leftNodess[1];\n    rp = &rightNodess[0];\n    nrp = &rightNodess[1];\n\n    \n    int nl, nr;\n    int l, r;\n    mincost = 0;    \n    for (int i = 0; i < n; i++) {\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> nl >> nr;\n\tif (i >= 1) {\n\t    \n\t    lp = &leftNodess[i % 2];\n\t    nlp = &leftNodess[(i + 1) % 2];\n\t    rp = &rightNodess[i % 2];\n\t    nrp = &rightNodess[(i + 1) % 2];\n\t    mincost = getMinCost(*lp, *rp, mincost, l);\n\t    auto ilmax = max_element(lp->begin(), lp->end());\n\t    if (ilmax == lp->end()) {\n\t\tlp->insert(l);\n\t\trp->insert(l);\n\t    } else {\n\t\tif (*ilmax <= l) {\n\t\t    auto irmin = min_element(rp->begin(), rp->end());\t\t\n\t\t    if (l <= *irmin) {\n\t\t\tlp->insert(l);\n\t\t\trp->insert(l);\n\t\t    } else {\n\t\t\trp->insert(l);\n\t\t\trp->insert(l);\n\n\t\t\tlp->insert(*irmin);\n\t\t\trp->erase(irmin);\n\t\t    }\n\t\t} else {\n\t\t    lp->insert(l);\n\t\t    lp->insert(l);\n\n\t\t    rp->insert(*ilmax);\n\t\t    lp->erase(ilmax);\n\t\t}\n\t    }\n\n\t    nlp->clear();\n\t    nrp->clear();\n\t    for (auto &e : *lp) {\n\t\tnlp->insert(e - (nr - nl));\n\t    }\n\t    for (auto &e : *rp) {\n\t\tnrp->insert(e + (r - l));\n\t    }\n#if 0\n\t    for (auto e : *nlp) {\n\t\tcout << e << \" \";\n\t    }\n\t    for (auto e : *nrp) {\n\t\tcout << e << \" \";\n\t    }\t    \n\t    cout << endl;\n#endif\t\n\t}\n\tl = nl;\n\tr = nr;\n    }\n \n    mincost = getMinCost(*nlp, *nrp, mincost, l);\n \n    cout << mincost << endl;\n    return 0;\n \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <iomanip>\n \nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n \n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\nll dp[2][100005];\nll INF = ll(1e21);\n\nint main(void)\n{\n    cin.sync_with_stdio(false);\n    ll N;\n    cin >> N;\n\n    vector<pair<ll,ll>> LRs(N);\n    REP(n,N) {\n        ll l, r;\n        cin >> l >> r;\n        LRs[n] = mp(l,r);\n    }\n\n    bool turn = 0;\n    REP(n,N) {\n        auto cur_l = LRs[n].first;\n        auto cur_r = LRs[n].second;\n        turn = !turn;\n        if (n == 0) {\n            FOR(pos, 1, 405) {\n                dp[turn][pos] = abs(cur_l - pos);\n            }\n        }\n        else {\n            auto prv_l = LRs[n-1].first;\n            auto prv_r = LRs[n-1].second;\n\n            FOR(pos_cur, 1, 405) {\n                dp[turn][pos_cur] = INF;\n                FOR(pos_prv, 1, 405) {\n                    if (dp[!turn][pos_prv] == INF) continue;\n                    if (prv_r < cur_l || cur_r < prv_l) {\n                        dp[turn][pos_cur] = INF;\n                    }\n                    else {\n                        dp[turn][pos_cur] = min(dp[turn][pos_cur],\n                                                dp[!turn][pos_prv] + abs(cur_l - pos_cur));\n                    }\n                }\n            }\n        }\n    }\n\n    ll ans = INF;\n    FOR(pos_cur, 1, 405) {\n        ans = min(ans, dp[turn][pos_cur]);\n    }\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; cin>>n;\n  ll l[100010], r[100010];\n  for(int i=0; i<n; i++) cin>>l[i]>>r[i];\n  priority_queue<ll> quel;\n  priority_queue<ll, vector<ll>, greater<ll>> quer;\n  quel.push(l[0]);\n  quer.push(l[0]);\n  ll dl=0, dr=0, s=0;\n  for(int i=1; i<n; i++){\n    dl-=r[i]-l[i];\n    dr+=r[i-1]-l[i-1];\n    if(quel.top()+dl>l[i]){\n      quel.push(l[i]-dl);\n      quel.push(l[i]-dl);\n      s+=(quel.top()+dl-l[i]);\n      quer.push(quel.top()+dl-dr);\n      quel.pop();\n    }else if(quer.top()+dr<l[i]){\n      quer.push(l[i]-dr);\n      quer.push(l[i]-dr);\n      s+=(l[i]-quer.top()-dr);\n      quel.push(quer.top()+dr-dl);\n      quer.pop();\n    }else{\n      quel.push(l[i]-dl);\n      quer.push(l[i]-dr);\n    }\n  }\n  cout<<s<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#include <set>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\ntypedef long long llint;\nconst llint inf = 1000000000000000000LL;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\nstruct HalfDP {\n  map<llint,llint> dslope;\n  llint shift_x;\n\n  HalfDP() { shift_x = 0; }\n\n  pair<llint,llint> shifted(pair<llint,llint> p) {\n    p.first += shift_x;\n    return p;\n  }\n  pair<llint,llint> first() { return shifted(*dslope.begin()); }\n  pair<llint,llint> last() { return shifted(*--dslope.end()); }\n  \n  void shift(llint x) { shift_x += x; }\n  void add(llint x, llint y) { dslope[x - shift_x] += y; }\n  void pop_first() { dslope.erase(dslope.begin()); }\n  void pop_last() { dslope.erase(--dslope.end()); }\n};\n\nstruct FullDP {\n  HalfDP L, R;\n  llint min_y;\n\n  void init(llint x) {\n    L.dslope[x] = -1;\n    R.dslope[x] = +1;\n    min_y = 0;\n  }\n\n  void apply_min(llint wl, llint wr) {\n    L.shift(-wl);\n    R.shift(+wr);\n  }\n\n  void add_abs(llint x) {\n    llint lx = L.last().first;\n    llint rx = R.first().first;\n\n    if (x >= lx && x <= rx) {\n      L.add(x, -1);\n      R.add(x, +1);\n    } else if (x > rx) {\n      R.add(rx, -1);\n      R.add(x, +2);\n      L.add(rx, -1);\n      min_y += abs(rx - x);\n    } else {\n      L.add(lx, +1);\n      L.add(x, -2);\n      R.add(lx, +1);\n      min_y += abs(lx - x);\n    }\n\n    if (R.first().second == 0) \n      R.pop_first();\n\n    if (L.last().second == 0) \n      L.pop_last();\n  }\n} dp;\n\n\nint main(void) \n{\n  const int MAXN = 1e5 + 5;\n  int N;\n  static llint l[MAXN];\n  static llint r[MAXN];\n  \n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%lld%lld\", l+i,r+i);\n\n  dp.init(l[0]);\n  \n  FOR(i, 1, N) {\n    llint wr = r[i - 1] - l[i - 1];\n    llint wl = r[i] - l[i];\n    dp.apply_min(wl, wr);\n    dp.add_abs(l[i]);\n  }\n\n  printf(\"%lld\\n\", dp.min_y);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tint len=r[1]-l[1];\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[i]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx;j++){\n\t\t\tf[i][j]=100000000;\n\t\t\tfor(int k=max(1,j-len-len_);k<=min(n,j+len);k++){\n\t\t\t\tif(k>j)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-l[i-1])));\n\t\t\t\telse f[i][j]=min(f[i][j],f[i-1][k]+min(abs(r[i]-j),abs(l[i]-r[i-1])));\n\t\t\t}\n\t\t}\n\t}\n\tans=100000000;\n\tfor(int j=1;j<=mx;j++)ans=min(ans,f[n][j]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int MAX = 801;\n\nint n, l[MAX], r[MAX];\nlong long dp[MAX][MAX];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= MAX; j++) dp[i][j] = INF;\n\tfor(int j = 1; j <= MAX; j++) dp[1][j] = abs(l[1] - j);\n\tfor(int i = 2; i <= n; i++) for(int j = 1; j <= MAX; j++) {\n\t\tfor(int k = max(j-r[i-1]+1, 1); k <= min(j+r[i]-1, MAX); k++) dp[i][j] = min(dp[i-1][k]+abs(j-l[i]), dp[i][j]);\n\t}\n\tlong long ans = INF;\n\tfor(int j = 1; j <= MAX; j++) ans = min(dp[n][j], ans);\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()) {\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t) {\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain() {\n\tint n;\n\tcin >> n;\n\tvint a(n);\n\tvint b(n);\n\tvint c(n);\n\tassert(n <= 400);\n\trep(i, n) {\n\t\tcin >> a[i] >> b[i];\n\t\tassert(b[i] <= 400);\n\t\ta[i]--, b[i]--;\n\t\tc[i] = b[i] - a[i];\n\t}\n\tvint dp(500);\n\trep(i, n) {\n\t\tif(i == 0) {\n\t\t\trep(j,500) dp[j] = abs(j - a[i]);\n\t\t}\n\t\telse {\n\t\t\tvint next(500, INF);\n\t\t\trep(j, 500) {\n\t\t\t\treep(k, j - c[i - 1], j + c[i] + 1) {\n\t\t\t\t\tif(k < 0) continue;\n\t\t\t\t\tif(k >= 500) continue;\n\t\t\t\t\tmins(next[j], dp[k] + abs(a[i] - j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 500) mins(ans, dp[i]);\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(20);\n\tmainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst int mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint n;\nint l[400],r[400];\nint dp[405][405];\n\nint main(){\n    cin >> n;\n    if (n>400) return 0;\n    rep(i,n) cin >> l[i] >> r[i];\n    rep(i,401)rep(j,401) dp[i][j]=INF;\n    rep2(j,1,401)dp[1][j]=abs(l[0]-j);\n    rep2(i,1,n){\n        rep(j,401){\n            int w=r[i]-l[i];\n            int prew=r[i-1]-l[i-1];\n            int cost=abs(l[i]-j);\n            rep2(k,max(0,j-prew),min(401,j+w+1)){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][k]+cost);\n            }\n        }\n    }\n    int ans=INF;\n    rep(j,401){\n        ans=min(ans,dp[n][j]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\nusing namespace std;\nint dp[410][2000];\nint n;\nint ans=1e9;\nint l[410],r[410];\nint mabs(int x)\n{\n\tif(x<0)return -x;return x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n>400)\n\t{\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",l+i,r+i);\n\t\tif(l[i]>400 || r[i]>400)return 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint ln=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=400;j++)\n\t\t{\n\t\t\tdp[i][j]=1e9;\n\t\t\tint cst=mabs(l[i]-j);\n\t\t\tfor(int k=max(1,j-ln);k<=min(400,j+r[i]-l[i]);k++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][k]==1e9)continue;\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+cst);\n\t\t\t\tif(i==n)ans=min(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e10\nusing namespace std;\n\nconst int maxn = 210000;\n\nint n;\nmultiset<ll>ql,qr;\nll L,R,len,re;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,las=0;i<=n;i++,las=len)\n\t{\n\t\tll l,r; scanf(\"%lld%lld\",&l,&r);\n\t\tlen=r-l;\n\t\tif(i==1)\n\t\t{\n\t\t\tql.insert(-inf); ql.insert(l);\n\t\t\tqr.insert(inf); qr.insert(l);\n\t\t\tcontinue;\n\t\t}\n\t\tL-=len,R+=las;\n\t\tll pl=*ql.rbegin()+L,pr=*qr.begin()+R;\n\t\tif(l<pl)\n\t\t{\n\t\t\tql.insert(l-L); ql.insert(l-L);\n\t\t\tql.erase(*ql.rbegin());\n\t\t\tre+=pl-L-*ql.rbegin();\n\t\t\tqr.insert(pl-R);\n\t\t}\n\t\telse if(l<=pr)\n\t\t\tql.insert(l-L),qr.insert(l-R);\n\t\telse\n\t\t{\n\t\t\tqr.insert(l-R); qr.insert(l-R);\n\t\t\tqr.erase(*qr.begin());\n\t\t\tre+=*qr.begin()+R-pr;\n\t\t\tql.insert(pr-L);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\nmultiset<ll> L, R;\nll C, lp, rp;\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    L.insert(-S[0].first);\n    R.insert(S[0].first);\n    C = lp = rp = 0;\n    for(int i = 1; i < N; i++) {\n        int plen = S[i - 1].second - S[i - 1].first;\n        int clen = S[i].second - S[i].first;\n        ll x = S[i].first;\n\n        lp += clen;\n        rp += plen;\n\n        if(-lp - *L.begin() <= x && x <= rp + *R.begin()) {\n            L.insert(-lp - x);\n            R.insert(-rp + x);\n        }\n        else if(x < -lp - *L.begin()) {\n            ll tx = -lp - *L.begin();\n            L.erase(L.begin());\n            L.insert(-lp - x);\n            L.insert(-lp - x);\n            R.insert(-rp + tx);\n            C += tx - x;\n        }\n        else if(rp + *R.begin() < x) {\n            ll tx = rp + *R.begin();\n            R.erase(R.begin());\n            R.insert(-rp + x);\n            R.insert(-rp + x);\n            L.insert(-lp - tx);\n            C += x - tx;\n        }\n    }\n    printf(\"%lld\", C);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> l(n), r(n);\n    for(int i=0; i<n; ++i)\n        cin >> l[i] >> r[i];\n\n    vector<int> dp(400, 0);\n    for(int x=0; x<400; ++x)\n        dp[x] = abs(x - l[0]);\n\n    for(int i=1; i<n; ++i){\n        vector<int> nextDp(400, INF);\n        for(int x1=0; x1<400; ++x1){\n            for(int x2=0; x2<400; ++x2){\n                if(x1 <= x2 + (r[i] - l[i]) && x2 <= x1 + (r[i-1] - l[i-1])){\n                    int cost = dp[x1] + abs(x2 - l[i]);\n                    nextDp[x2] = min(nextDp[x2], cost);\n                }\n            }\n        }\n        dp.swap(nextDp);\n    }\n    cout << *min_element(dp.begin(), dp.end()) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tif (n > 400) return 0;\n\tvector<int> l(n), r(n);\n\tint rmax = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\trmax = max(rmax, r[i]);\n\t}\n\tif (rmax > 400) return 0;\n\tint ans = INF;\n\tfor (int i = 1; i <= rmax; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i < l[j]) sum += l[j] - i;\n\t\t\telse if (i > r[j]) sum += i - r[j];\n\t\t}\n\t\tans = min(ans, sum);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvl l,r,len;\n\nint main(){\n\tcin>>n;\n\tl=r=len=vl(n);\n\tmultiset<ll> L,R;\n\tll lx=0,rx=0,res=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>l[i]>>r[i];\n\t\tlen[i]=r[i]-l[i];\n\t}\n\tL.insert(l[0]);\n\tR.insert(l[0]);\n\tfor(int i=1;i<n;i++){\n\t\t lx-=len[i];\n\t\t rx+=len[i-1];\n\t\t auto li=L.end(),ri=R.begin();\n\t\t li--;\n\t\t ll ls=*li+lx,rs=*ri+rx;\n\t\t if(ls<=l[i]&&l[i]<=rs){\n\t\t\t L.insert(l[i]-lx);\n\t\t\t R.insert(l[i]-rx);\n\t\t }\n\t\t else if(l[i]<=ls){\n\t\t\t L.insert(l[i]-lx);\n\t\t\t L.insert(l[i]-lx);\n\t\t\t L.erase(li);\n\t\t\t R.insert(ls-rx);\n\t\t\t res+=ls-l[i];\n\t\t }\n\t\t else{\n\t\t\t R.insert(l[i]-rx);\n\t\t\t R.insert(l[i]-rx);\n\t\t\t R.erase(ri);\n\t\t\t L.insert(rs-lx);\n\t\t\t res+=l[i]-rs;\n\t\t }\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nll l[100001];\nll r[100001];\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tpriority_queue<ll> L;\n\tpriority_queue<ll, vector<ll>, greater<ll>> R;\n\tll offL = 0, offR = 0, m = 0;\n\tL.push(-INF);\n\tR.push(INF);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i > 0) {\n\t\t\toffR += (r[i - 1] - l[i - 1]);\n\t\t\toffL -= (r[i] - l[i]);\n\t\t}\n\t\tif (l[i] < L.top() + offL) {\n\t\t\tm += L.top() + offL - l[i];\n\t\t\tR.push(L.top() + offL - offR);\n\t\t\tL.push(l[i] - offL);\n\t\t\tL.push(l[i] - offL);\n\t\t\tL.pop();\n\t\t}\n\t\telse if (R.top() + offR < l[i]) {\n\t\t\tm += l[i] - (R.top() + offR);\n\t\t\tL.push(R.top() + offR - offL);\n\t\t\tR.push(l[i] - offR);\n\t\t\tR.push(l[i] - offR);\n\t\t\tR.pop();\n\t\t}\n\t\telse {\n\t\t\tL.push(l[i] - offL);\n\t\t\tR.push(l[i] - offR);\n\t\t}\n\t}\n\tcout << m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\nint mem[MAXN][MAXN];\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 0;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nint dp[410][410];\nvoid push(deque<PII>& q, int i, int x){\n  while(!q.empty() && q.back().SS >= x)\n\tq.pop_back();\n  q.push_back(MP(i,x));\n}\nvoid pop(deque<PII>& q, int b){\n  while(!q.empty() && q.front().FF <= b)\n\tq.pop_front();\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<PII> xs(N);\n  VI ws(N);\n  REP(i,N){\n\tcin >> xs[i];\n\tws[i] = xs[i].SS - xs[i].FF;\n  }\n\n  fill((int*)dp, (int*)dp+410*410, INF);\n  REP(x,401)\n\tdp[0][x] = abs(x - xs[0].FF);\n\n  FOR(i,1,N){\n\tdeque<PII> q;\n\tfor(int x=0;x<=ws[i]&&x<410;++x)\n\t  push(q, x, dp[i-1][x]);\n\n\tfor(int x=0;x<410;++x){\n\t  if(x+ws[i] < 410)\n\t\tpush(q, x+ws[i], dp[i-1][x+ws[i]]);\n\t  dp[i][x] = abs(x - xs[i].FF) + q.front().SS;\n\t  pop(q, x-ws[i-1]);\n\t}\n  }\n\n  cout << *min_element(ALL(dp[N-1])) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e10\nusing namespace std;\n\nconst int maxn = 210000;\n\nint n;\nmultiset<ll>ql,qr;\nmultiset<ll>::iterator it;\nll addL,addR,len,re;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,las=0;i<=n;i++,las=len)\n\t{\n\t\tll l,r; scanf(\"%lld%lld\",&l,&r);\n\t\tlen=r-l;\n\t\tif(i==1)\n\t\t{\n\t\t\tql.insert(-inf); ql.insert(l);\n\t\t\tqr.insert(inf); qr.insert(l);\n\t\t\tcontinue;\n\t\t}\n\t\taddL-=len,addR+=las;\n\t\tll pl=*ql.rbegin()+addL,pr=*qr.begin()+addR;\n\t\tif(l<pl)\n\t\t{\n\t\t\tit=ql.end();it--; ql.erase(it);\n\t\t\tql.insert(l-addL); ql.insert(l-addL);\n\t\t\tre+=pl-l;\n\t\t\tqr.insert(pl-addR);\n\t\t}\n\t\telse if(l<=pr)\n\t\t\tql.insert(l-addL),qr.insert(l-addR);\n\t\telse\n\t\t{\n\t\t\tit=qr.begin(); qr.erase(it);\n\t\t\tqr.insert(l-addR); qr.insert(l-addR);\n\t\t\tre+=l-pr;\n\t\t\tql.insert(pr-addL);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <chrono> //1e+9で割る auto end= chrono::system_clock::now()-st;  cout<<end.count()%1e+9<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef long double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll N;\nll l[400],r[400];\nll dp[400][401];//i番目　j最小\nll deq[401];\nll lef,rig;\nconst ll INF=0xffffffffff;\n\nint main()\n{\n\tcin>>N;\n\tif(N>400) return 0;\n\trep(i,N){\n\t\tcin>>l[i]>>r[i];\n\t}\n\tll cnt=0;\n\trep(i,401){\n\t\tdp[0][i]=abs(l[0]-i);\n\t}\n\t\n\tfor(ll i=1;i<N;i++){\n\t\tll s=0,t=0;\n\t\tlef=r[i-1]-l[i-1];\n\t\trig=r[i]-l[i];\n\t\trep(j,rig){\n\t\t\twhile(j<=400 && s<t && dp[i-1][deq[t-1]] >= dp[i-1][j]) t--;\n\t\t\tdeq[t++]=j;\n\t\t}\n\t\tfor(ll j=0;j<=400;j++){\n\t\t\twhile(j+rig<=400 && s<t && dp[i-1][deq[t-1]] >= dp[i-1][j+rig]) t--;\n\t\t\tdeq[t++]=j+rig;\n\t\t\t\n\t\t\tdp[i][j] = abs(j-l[i])+dp[i-1][deq[s]];\n\t\t\t\n\t\t\tif(j-lef>=0&&deq[s]==j-lef){\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\trep(i,401){\n\t\tans=min(ans,dp[N-1][i]);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pairs;\n\nconst int N = 202020;\n#define get() getchar()\ntemplate<typename T>\ninline void read(T &x) {\n    static char c; x = 0; int sgn = 0;\n    for (c = get(); c < '0' || c > '9'; c = get()) if (c == '-') sgn = 1;\n    for (; c >= '0' && c <= '9'; c = get()) x = x * 10 + c - '0';\n    if (sgn) x = -x;\n}\n\nint n;\nll addl, addr, ans;\nint l[N], r[N];\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\n\ntemplate<typename T>\ninline T Abs(T x) {\n    return x < 0 ? -x : x;\n}\n\nint main(void) {\n    read(n);\n    for (int i = 1; i <= n; i++) {\n        read(l[i]); read(r[i]);\n        if (i == 1) {\n            L.push(l[i]); R.push(l[i]);\n            addl = addr = 0;\n            continue;\n        }\n        int len2 = r[i] - l[i], len1 = r[i - 1] - l[i - 1];\n        addl -= len2;\n        addr += len1;\n        ll lb = L.top() + addl, rb = R.top() + addr;\n        if (l[i] < lb) {\n            ans += Abs(lb - l[i]);\n            R.push(lb - addr);\n            L.push(l[i] - addl);\n            L.push(l[i] - addl);\n            L.pop();\n        } else if (l[i] > rb) {\n            ans += Abs(rb - l[i]);\n            L.push(rb - addl);\n            R.push(l[i] - addr);\n            R.push(l[i] - addr);\n            R.pop();\n        } else {\n            L.push(l[i] - addl);\n            R.push(l[i] - addr);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n, ml, mr, ans, a[100005], b[100005];\nmultiset<ll> l, r;\n\nmultiset<ll>::iterator last (multiset<ll> &S) {\n\tauto it = S.end(); it--;\n\treturn it;\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t}\n\tl.insert(0);\n\tr.insert(0);\n\tml = b[1]; mr = b[1];\n\tfor(ll i=2;i<=n;i++) {\n\t\tml -= b[i-1] - a[i-1];\n\t\tmr += b[i] - a[i];\n\t\tif(ml <= b[i] && b[i] <= mr) {\n\t\t\tll GL = b[i] - ml, GR = mr - b[i];\n\t\t\tl.insert((*last(l))+GL);\n\t\t\tr.insert((*last(r))+GR);\n\t\t\tml = b[i]; mr = b[i];\n\t\t}\n\t\telse if(b[i] < ml) {\n\t\t\tll G = ml - b[i];\n\t\t\tans += G;\n\t\t\tr.insert((*last(r))+mr-ml);\n\t\t\tauto it = last(l);\n\t\t\tll V = (*it);\n\t\t\tl.erase(it);\n\t\t\tl.insert(V - G);\n\t\t\tl.insert(V - G);\n\t\t\tmr = ml; ml = mr - (V - (*last(l)));\n\t\t}\n\t\telse {\n\t\t\tll G = b[i] - mr;\n\t\t\tans += G;\n\t\t\tl.insert((*last(l))+mr-ml);\n\t\t\tauto it = last(r);\n\t\t\tll V = (*it);\n\t\t\tr.erase(it);\n\t\t\tr.insert(V - G);\n\t\t\tr.insert(V - G);\n\t\t\tml = mr; mr = ml + (V - (*last(r)));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nlong long n,m,i,j,k,ans,dp[405][405],l[405],r[405];\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<=n;i++) cin>>l[i]>>r[i];\n\tl[0]=1;\n\tr[0]=400;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=1;j+r[i]-l[i]<=400;j++)\n\t\t{\n\t\t\tdp[i][j]=1ll<<55;\n\t\t\tfor (k=1;k+r[i-1]-l[i-1]<=400;k++)\n\t\t\t{\n\t\t\t\tif ((j<=k&&j+r[i]-l[i]>=k)||(j<=k+r[i-1]-l[i-1]&&j+r[i]-l[i]>=k+r[i-1]-l[i-1])||(j<=k&&j+r[i]-l[i]>=k+r[i-1]-l[i-1])||(j>=k&&j+r[i]-l[i]<=k+r[i-1]-l[i-1]))\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+abs(l[i]-j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=1ll<<55;\n\tfor (i=1;i+r[n]-l[n]<=400;i++) \n\t{\n\t\tans=min(ans,dp[n][i]);\n\t\t//cerr<<dp[n][i]<<' ';\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    if(i < L[0]) dp[i] = L[0] - i;\n    else if(i < R[0]) dp[i] = 0;\n    else dp[i] = i - R[0];\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto left = j, right = left + R[i] - L[i];\n      auto preleft = max(0, j - R[i - 1] - L[i - 1] + 1);\n      for(int k = preleft; k <= right; k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\nint l[100001],r[100001];\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    long long ladd=0,radd=0;\n    for (int i=1;i<=n;++i)\n        scanf(\"%d%d\",l+i,r+i);\n    priority_queue<long long> pl;\n    priority_queue<long long,vector<long long>,greater<long long>> pr;\n    pl.push(l[1]);\n    pr.push(l[1]);\n    long long c=0;\n    for (int i=2;i<=n;++i)\n    {\n        ladd+=r[i]-l[i];\n        radd+=r[i-1]-l[i-1];\n        long long il=pl.top()-ladd,ir=pr.top()+radd;\n        if (l[i]<il)\n        {\n            c+=il-l[i];\n            pr.push(il-radd);\n            pl.pop();\n            pl.push(l[i]+ladd);\n            pl.push(l[i]+ladd);\n        }\n        else if (l[i]>ir)\n        {\n            c+=l[i]-ir;\n            pl.push(ir+ladd);\n            pr.pop();\n            pr.push(l[i]-radd);\n            pr.push(l[i]-radd);\n        }\n        else\n        {\n            pl.push(l[i]+ladd);\n            pr.push(l[i]-radd);\n        }\n    }\n    printf(\"%lld\\n\",c);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int L=1e5+1;\n\nLL l[L];\nLL w[L];\nint main() {\n\tint N;\n\tcin >> N;\n\tfor(int i=0;i<N;i++){\n\t\tLL r;\n\t\tcin >> l[i] >> r;\n\t\tw[i]=r-l[i];\n\t}\n\tmultiset<LL> left,right;\n\tLL lo=0,ro=0;\n\tleft.insert(l[0]);\n\tright.insert(l[0]);\n\tLL h=0;\n\tfor(int i=1;i<N;i++){\n\t\tro+=w[i-1];\n\t\tlo-=w[i];\n\t\tauto a=left.end();\n\t\ta--;\n\t\tauto b=right.begin();\n\t\tif(l[i]<*a+lo){\n\t\t\th+=*a+lo-l[i];\n\t\t\tright.insert(*a+lo-ro);\n\t\t\tleft.erase(a);\n\t\t\tleft.insert(l[i]-lo);\n\t\t\tleft.insert(l[i]-lo);\n\t\t}\n\t\telse if(l[i]<=*b+ro){\n\t\t\tleft.insert(l[i]-lo);\n\t\t\tright.insert(l[i]-ro);\n\t\t}\n\t\telse{\n\t\t\th+=l[i]-(*b+ro);\n\t\t\tleft.insert(*b+ro-lo);\n\t\t\tright.erase(b);\n\t\t\tright.insert(l[i]-ro);\n\t\t\tright.insert(l[i]-ro);\n\t\t}\n\t}\n\tcout << h << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef tuple<ll, ll, ll> iii;\ntypedef vector<ll> vi;\ntypedef vector<ii> vii;\ntypedef vector<iii> viii;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\n#define REP(i,n) for (ll i = 0; i < n; ++i)\n#define REPR(i,n) for (ll i = n-1; i >= 0; --i)\n#define FOR(i,m,n) for (ll i = m; i < n; ++i)\n#define FORR(i,m,n) for (ll i = n-1; i >= m; --i)\n#define FORE(x,xs) for (const auto& x : xs)\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define ALL(v) v.begin(), v.end()\n\nconst int MAX = 1e5+10;\nconst int RANGE = 1e9+10;\n\nint N;\nll L[MAX], R[MAX];\n\nll solve() {\n    multiset<int> left, right;\n    ll ans = 0;\n\n    left.insert(L[0]);\n    right.insert(L[0]);\n    FOR (i, 1, N) {\n        int lmx = *left.rbegin();\n        int rmn = *right.begin();\n        int baseL = lmx - (R[i] - L[i]);\n        int baseR = rmn + (R[i-1] - L[i-1]);\n\n        if (L[i] < baseL) {\n            left.erase(--left.end());\n            left.insert(L[i]); left.insert(L[i]);\n            right.insert(lmx);\n            ans += baseL - L[i];\n        } else if (L[i] > baseR) {\n            right.erase(right.begin());\n            right.insert(L[i]); right.insert(L[i]);\n            left.insert(rmn);\n            ans += L[i] - baseR;\n        } else {\n            left.insert(L[i]);\n            right.insert(L[i]);\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    cin >> N;\n    REP (i, N) cin >> L[i] >> R[i];\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <string.h>\n#include <memory.h>\n#include <stdio.h>\n#include <complex>\n#include <cstdlib>\n#include <sstream>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include<deque>\ntypedef long long ll;\nusing namespace std;\nconst int N = 1000 ;\nint n;\nint l[N], r[N];\nll dp[N][N];\nll calc(int idx, int s) {\n\tif(idx == n)\n\t\treturn 0;\n\tll &ret = dp[idx][s];\n\tif (ret != -1)\n\t\treturn ret;\n\tint len = (r[idx] - l[idx] + 1);\n\tint e = min(400 - len, s + (r[idx - 1] - l[idx - 1]));\n\tret = 1e18;\n\tfor (int i = max(1,s-len+1); i <= e; ++i)\n\t\tret = min(ret, calc(idx + 1, i) + abs(i - l[idx]));\n\treturn ret;\n}\n\n\nint main() {\n\t//freopen(\"myfile.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(\"%d%d\", l + i, r + i);\n\tif (n == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tll ans = 1e18;\n\n\tint len = (r[0] - l[0] + 1);\n\tfor (int i = 1; i <= 400-len; ++i)\n\t\tans = min(ans, calc(1, i) + abs(i - l[0]));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int limit = 400;\nint dp[limit+3][limit+3], n;\n\nint main(){\n//\tfreopen(\"narrowrectangles.in\", \"r\", stdin);\n\tcin >> n;\n\tint a,b; cin >> a >> b;\n\tint prvlen = b-a;\n\tfor(int i=1; i<=limit; i++) dp[0][i] = abs(i-a);\n\tfor(int i=1; i<n; i++){\n\t\tcin >> a >> b;\n\t\tint len = b-a;\n\t\tfor(int j = 1; j<=limit; j++){\n\t\t\tdp[i][j] = INT_MAX/2;\n\t\t\tfor(int k = max(1,j-prvlen); k<=min(j+len,limit); k++){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + abs(j-a));\n\t\t\t}\n\t\t}\n\t\tprvlen = len;\n\t}\n\tint ans = INT_MAX;\n\tfor(int i = 1; i<=limit; i++){\n\t\tans = min(ans, dp[n-1][i]);\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,l[N],r[N],addl,addr,ans,l1,l2,lb,rb;\npriority_queue <ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\nsigned main(){\n\tn=read();\n\tF(i,1,n){\n\t\tl[i]=read();r[i]=read();\n\t\tif (i==1){L.push(l[i]);R.push(r[i]);continue;}\n\t\tl2=r[i]-l[i];l1=r[i-1]-l[i-1];\n\t\taddl-=l2;addr+=l1;\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (l[i]<lb){\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.push(l[i]-addl);\n\t\t\tL.push(l[i]-addl);L.pop();\n\t\t}\n\t\telse if (l[i]>rb){\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.push(l[i]-addr);R.push(l[i]-addr);\n\t\t\tR.pop();\n\t\t}\n\t\telse{\n\t\t\tL.push(l[i]-addl);\n\t\t\tR.push(l[i]-addr);\n\t\t}\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\nusing namespace std;\n#define lowbit(x) ((x)&(-x))\nconst int maxn = 400 + 50;\nint n , dp[maxn][maxn] , l[maxn] , r[maxn];\n\nint main( int argc , char * argv[] ){\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tl[i] = read() , r[i] = read();\n\tfor(int j = 1 ; j <= 400 ; ++ j)\n\t\tdp[1][j] = abs( j - l[1] );\n\tfor(int i = 2 ; i <= n ; ++ i)\n\t\tfor(int j = 1 ; j <= 400 ; ++ j){\n\t\t\tint mi = 1e9 + 7;\n\t\t\tfor(int k = max( 1 , j - (r[i - 1] - l[i - 1]) ) ; k <= min( 400 , j + r[i] ) ; ++ k)\n\t\t\t\tmi = min( mi , dp[i - 1][k] );\n\t\t\tmi += abs( j - l[i] );\n\t\t\tdp[i][j] = mi;\n\t\t}\n\tint mi = 1e9 + 7;\n\tfor(int i = 1 ; i <= 400 ; ++ i)\n\t\tmi = min( mi , dp[n][i] );\n\tprintf( \"%d\\n\" , mi );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                //  #define PI 3.14159265358979323846\n                                        #define paa pair<int,char>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn y != p.y ? y<p.y: x<p.x;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            int mod;\n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=mod;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=mod;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%mod;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n            \t\n            }\n          //   cin.tie(0);\n\t\t//\tios::sync_with_stdio(false);\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint l[100020],d[100020];\nmultiset<int> s1,s2;\nsigned main(){\nint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tcin>>l[i]>>d[i];\n\t\td[i]-=l[i];\n\t}\n\t\n\t\n\ts2.insert(l[0]);\n\ts1.insert(l[0]);\n\t\n\tint de=0;\n\tint h=l[0],m=l[0];\n\tint w=0,e=0;\n\tfor(int i=1;i<n;i++){\n\t\t//cout<<h-w<<\" \"<<m+e<<\" \"<<de<<endl;\n\t\tw+=d[i];\n\t\te+=d[i-1];\n\t\t//cout<<h-w<<\" \"<<m+e<<\"   \"<<l[i]<<endl;\n\t\t\n\t\tif(h-w>l[i]){\n\t\t\tde+= -l[i]+(h-w); \n\t\t\ts1.insert(l[i]+w);\n\t\t\ts1.insert(l[i]+w);\n\t\t\t\n\t\t\tauto it=s1.end();\n\t\t\tit--;\n\t\t\tint g=*it;\n\t\t\ts1.erase(it);\n\t\t\tg-= w+e;\n\t\t\ts2.insert(g);\n\t\t\tm=g;\n\t\t\tit=s1.end();\n\t\t\tit--;\n\t\t\th=*it;\n\t\t\n\t\t}\n\t\telse if(h-w<l[i] && l[i]<m+e){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t\th=l[i]+w;\n\t\t\tm=l[i]-e;\n\t\t\t\n\t\t}\n\t\telse if(l[i]>m+e){\n\t\t\tde+= -(m+e)+l[i]; \n\t\t\ts2.insert(l[i]-e);\n\t\t\ts2.insert(l[i]-e);\n\t\t\t\n\t\t\tauto it=s2.begin();\n\t\t\t\n\t\t\tint g=*it;\n\t\t\ts2.erase(it);\n\t\t\tg+= w+e;\n\t\t\ts1.insert(g);\n\t\t\th=g;\n\t\t\tit=s2.begin();\n\t\t\t\n\t\t\tm=*it;\n\t\t}\n\t\telse if(m+e==h-w){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t}\n\t\telse{\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t\th=l[i]+w;\n\t\t\tm=l[i]-e;\n\t\t}\n\t\n\t}\n\tcout<<de<<endl;\n\t\n\treturn 0;\n        }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-9;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nsigned main(){\n\tint n,l[100],r[100],dp[401][401] = {},mi = INF;\n\tcin >> n;\n\tif(n >= 401) return 0;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> l[i] >> r[i];\n\t\tif(l[i] >= 401 || r[i] >= 401) return 0;\n\t}\n\tfor(int i = 1;i <= 400;i++){\n\t\tfor(int j = 0;j <= 400;j++) dp[i][j] = INF;\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 0;j <= 400;j++){\n\t\t\tfor(int k = 0;k <= 400;k++){\n\t\t\t\tif(i == 1 || (k + r[i - 2] - l[i - 2] >= j && k - r[i - 1] + l[i - 1] <= j)) dp[i][j] = min(dp[i][j],dp[i - 1][k] + abs(j - l[i - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i <= 400;i++) mi = min(mi,dp[n][i]);\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n), len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0]; ll my = 0;\n\tmultiset<ll> sl, sr;\n\tll adle = 0, adri = 0;\n\trep1(i, n - 1) {\n\t\tml -= len[i]; mr += len[i - 1];\n\t\tif (l[i] <= ml) {\n\t\t\tll dif = ml - l[i];\n\t\t\tsl.insert(dif-adle);\n\t\t\tmy += dif;\n\t\t\tsr.insert(- adri);adri += mr - ml;\n\t\t\tmr = ml;\n\t\t\tll nl = *sl.begin(); sl.erase(sl.begin());\n\t\t\tnl += adle;\n\t\t\tml -= nl;\n\t\t\tadle -= nl;\n\t\t}\n\t\telse if (l[i] >= mr) {\n\t\t\tll dif = l[i] - mr;\n\t\t\tsr.insert(dif - adri);\n\t\t\tmy += dif;\n\t\t\tsl.insert(- adle); adle += mr - ml;\n\t\t\tml = mr;\n\t\t\tll nr = *sr.begin(); sr.erase(sr.begin());\n\t\t\tnr += adri;\n\t\t\tmr += nr;\n\t\t\tadri -= nr;\n\t\t}\n\t\telse {\n\t\t\tsl.insert(-adle), sr.insert(-adri);\n\t\t\tadle += l[i] - ml; adri += mr - l[i];\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n),len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0];\n\tint lec = 1, ric = 1;\n\tll my = 0;\n\trep1(i, n - 1) {\n\t\tif (r[i] < ml) {\n\t\t\tmy += ml - r[i];\n\t\t\tif (lec == 1) {\n\t\t\t\tmr = ml;\n\t\t\t\tml = l[i];\n\t\t\t\tlec = 2, ric = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmr = ml;\n\t\t\t\tlec=ric = 1;\n\t\t\t}\n\t\t}\n\t\telse if (l[i] > mr+len[i-1]) {\n\t\t\tmy += l[i] - mr - len[i - 1];\n\t\t\tif (ric == 1) {\n\t\t\t\tml = mr; mr = l[i];\n              ric=2,lec=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tml = mr;\n\t\t\t\tlec = ric = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tml = mr = l[i]; lec = ric = 1;\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define MN 100000\n#define ll long long\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nll ans,addl,addr;\nint n,l[MN+5],r[MN+5];\npriority_queue<ll> ql;\npriority_queue<ll,vector<ll>,greater<ll> >qr;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n    ql.push(l[1]);qr.push(l[1]);\n    for(int i=2;i<=n;++i)\n    {\n        addr+=r[i-1]-l[i-1];addl+=r[i]-l[i];\n        ll pl=ql.top()-addl,pr=qr.top()+addr;\n        if(pl<=l[i]&&l[i]<=pr) ql.push(l[i]+addl),qr.push(l[i]-addr);\n        else if(l[i]<pl)\n        {\n            ans+=pl-l[i];\n            qr.push(pl-addr);\n            ql.push(l[i]+addl);ql.push(l[i]+addl);ql.pop();\n        }\n        else\n        {\n            ans+=l[i]-pr;\n            ql.push(pr+addl);\n            qr.push(l[i]-addr);qr.push(l[i]-addr);qr.pop();\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint ans[500];\nint d1[500][10];\nint d2[500][10];\nint a[100000][2];\nmap<int,int> mp;\n\nint main()\n{\n  int i,j,n,best,now,ll,k,kk,jj,tmp;\n  vector<int> d;\n  scanf(\"%d\",&n);\n  if (n>400) return 0;\n  for (i=0;i<n;i++)\n  {\n    scanf(\"%d%d\",&a[i][0],&a[i][1]);\n    if (a[i][0]>400) return 0;\n    if (a[i][1]>400) return 0;\n  }\n  memset(ans,0,sizeof(ans));\n  now=0;\n  for (i=0;i<n;i++)\n  {\n    for (j=0;j<500;j++)\n    {\n      d1[j][0]=ans[j];\n      d2[j][0]=ans[j];\n    }\n    for (k=0;k+1<10;k++)\n      for (j=0;j<500;j++)\n      {\n        d1[j][k+1]=d1[j][k];\n        if ((j+(1<<k))<500)\n          if (d1[j+(1<<k)][k]<d1[j][k+1])\n            d1[j][k+1]=d1[j+(1<<k)][k];\n        d2[j][k+1]=d2[j][k];\n        if ((j-(1<<k))>=0)\n          if (d2[j-(1<<k)][k]<d2[j][k+1])\n            d2[j][k+1]=d2[j-(1<<k)][k];\n      }\n    ll=a[i][1]-a[i][0]+1;\n    kk=0;\n    while ((1<<kk)<=ll) kk++;\n    kk--;\n    for (j=0;j<500;j++)\n    {\n      ans[j]=2000000000;\n      for (jj=j-ll+1;jj<=j;jj++)\n      {\n        if ((jj<0)||(jj+ll-1>=500)) continue;\n        tmp=d1[jj][kk];\n        if (d2[jj+ll-1][kk]<tmp) tmp=d2[jj+ll-1][kk];\n        tmp+=abs(j-a[i][0]);\n        if (tmp<ans[j]) ans[j]=tmp;\n      }\n    }\n  }\n  best=2000000000;\n  for (i=0;i<500;i++)\n    if (ans[i]<best) best=ans[i];\n  printf(\"%d\\n\",best);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 1000000\n#define MAXVAL 400\nlong long dp[MAXVAL+1], lst[MAXVAL+1];\nint l[MAXN+1], r[MAXN+1];\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tint temp,temp2;\n\tfor(temp=1;temp<=n;temp++)\tcin>>l[temp]>>r[temp];\n\n\tint optl=0,optr=MAXVAL;\n\tlong long mini;\n\tfor(temp=1;temp<=n;temp++) {\n\n\t\tint maju = r[temp]-l[temp];\n\t\tint mundur = r[temp-1]-l[temp-1];\n\t\tmini = 10e17; //minimum dp_i\n\n\t\t// mengisi di kiri opt\n\t\tfor(int pos=0;pos<optl; pos++) {\n\t\t\tint terjauh = min(pos+maju, optl);\n\t\t\tdp[pos] = lst[terjauh] + abs(pos - l[temp]);\n\t\t\tmini=min(mini, dp[pos]);\n\t\t}\n\n\t\t// mengisi di kanan opt\n\t\tfor(int pos=optr+1; pos<=MAXVAL; pos++) {\n\t\t\tint terjauh = max(pos - mundur, optr);\n\t\t\tdp[pos] = lst[terjauh] + abs(pos - l[temp]);\n\t\t\tmini = min(mini, dp[pos]);\n\t\t}\n\n\t\t// mengisi di tengah\n\t\tfor(int pos=optl; pos<=optr; pos++) {\n\t\t\tdp[pos] = lst[pos] + abs(pos - l[temp]);\n\t\t\tmini = min(mini, dp[pos]);\n\t\t}\n\n\t\t// mencari optl dan r baru\n\t\toptl=-1; optr=-1;\n\t\tfor(int pos=0;pos<=MAXVAL; pos++) {\n\t\t\tif(dp[pos]==mini) {\n\t\t\t\tif(optl==-1)\toptl=pos;\n\t\t\t\toptr=pos;\n\t\t\t}\n\t\t\tlst[pos]=dp[pos];\n\t\t}\n\t}\n\n\tcout<<mini<<\"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nconst int maxn = 810;\nconst int INF = 1<<30;\n\nint f[maxn][maxn];\nint l[maxn], r[maxn];\n\nint main()\n{\n\t//freopen(\"E.in\",\"r\",stdin);\n\t//freopen(\"E.out\",\"w\",stdout);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\t\n\tfor (int i=0;i<maxn;i++)\n\t\tfor (int j=0;j<maxn;j++) f[i][j] = INF;\n\tfor (int i=max(r[1]-l[1],1);i<maxn;i++) f[1][i] = abs(r[1] - i);\n\t\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=0;j<maxn;j++)\n\t\t{\n\t\t\tfor (int x=-maxn/2;x<maxn/2;x++)\n\t\t\t{\n\t\t\t\tint newl = l[i+1] - x, newr = r[i+1] - x;\n\t\t\t\tif (newl <= 0) break;\n\t\t\t\tif (newl <= j) f[i+1][newr] = min(f[i+1][newr], f[i][j] + abs(x));\n\t\t\t\t//cout<<i<<\" \"<<i+1<<\" \"<<j<<\" \"<<x<<\" \"<<newr<<\" \"<<f[i][j]+abs(x)<<\" \"<<f[i+1][newr]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i=0;i<maxn;i++) ans = min(ans,f[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define MN 100000\n#define ll long long\nusing namespace std;\ninline int read()\n{\n    int x=0;char ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nll ans,addl,addr;\nint n,l[MN+5],r[MN+5];\npriority_queue<ll> ql;\npriority_queue<ll,vector<ll>,greater<ll> >qr;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n    ql.push(l[1]);qr.push(l[1]);\n    for(int i=2;i<=n;++i)\n    {\n        addr+=r[i-1]-l[i-1];addl+=r[i]-l[i];\n        ll pl=ql.top()-addl,pr=qr.top()+addr;\n        if(pl<=l[i]&&l[i]<=pr) ql.push(l[i]+addl),qr.push(l[i]-addr);\n        else if(l[i]<pl)\n        {\n            ans+=pl-l[i];\n            qr.push(pl-addr);\n            ql.pop();ql.push(l[i]+addl);\n        }\n        else\n        {\n            ans+=l[i]-pr;\n            ql.push(pl+addl);\n            qr.pop();qr.push(l[i]-addr);\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,l[N],r[N];\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll>> R;\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n\tL.push(l[1]),R.push(l[1]); ll addl=0,addr=0,ans=0;\n\tfor (int i=2;i<=n;++i) {\n\t\taddl-=r[i]-l[i],addr+=r[i-1]-l[i-1];\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (lb<=l[i]&&l[i]<=rb) L.push(l[i]-addl),R.push(l[i]-addr);\n\t\telse if (l[i]<lb) {\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.pop(),L.push(l[i]-addl),L.push(l[i]-addl);\n\t\t} else {\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.pop(),R.push(l[i]-addr),R.push(l[i]-addr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (1e9)\n#define INF_LL (1e17)\n\nusing LL = long long;\nusing ULL = unsigned long long;\n\nusing namespace std;\n\n#define MAX_N 405\nint N;\nLL L[MAX_N], R[MAX_N];\n\nLL solve(int aNum)\n{\n  LL ret = 0;\n  LL tmpL = L[aNum], tmpR = R[aNum];\n  for (int i = aNum-1; 0 <= i; i--) {\n    LL nextL = L[i], nextR = R[i];\n    if((tmpL <= R[i] && R[i] <= tmpR) ||\n        (tmpL <= L[i] && L[i] <= tmpR) ||\n       (L[i] <= tmpL && tmpR <= R[i])){\n\n    }\n    else{\n      if(R[i] < tmpL){\n        ret += tmpL - R[i];\n        nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else if(tmpR < L[i]){\n        ret += L[i] - tmpR;\n        nextL -= L[i] - tmpR;\n        nextR -= L[i] - tmpR;\n      }\n      else{\n        cerr << \"UNCHI\" << endl;\n      }\n    }\n    //cerr << \"1 \" << i << \" \" << ret << endl;\n    tmpL = nextL;\n    tmpR = nextR;\n  }\n  tmpL = L[aNum]; tmpR = R[aNum];\n  for (int i = aNum+1; i < N; i++) {\n    LL nextL = L[i], nextR = R[i];\n    if((tmpL <= R[i] && R[i] <= tmpR) ||\n        (tmpL <= L[i] && L[i] <= tmpR) ||\n       (L[i] <= tmpL && tmpR <= R[i])){\n\n    }\n    else{\n      if(R[i] < tmpL){\n        ret += tmpL - R[i];\n        nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else if(tmpR < L[i]){\n        ret += L[i] - tmpR;\n        nextL -= L[i] - tmpR;\n        nextR -= L[i] - tmpR;\n      }\n      else{\n        cerr << \"UNCHI\" << endl;\n      }\n    }\n    //cerr << \"2 \" << i << \" \" << ret << endl;\n    tmpL = nextL;\n    tmpR = nextR;\n  }\n\n  return ret;\n}\n\nint main()\n{\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n  }\n\n  LL ans = 1145141919810364;\n  for (int i = 0; i < N; i++) {\n    //cerr << endl;\n    //cerr << i << \" \" << solve(i) << endl;\n    ans = min(ans, solve(i));\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pairs;\n\nconst int N = 202020;\n\ninline char get(void) {\n\tstatic char buf[100000], *S = buf, *T = buf;\n\tif (S == T) {\n\t\tT = (S = buf) + fread(buf, 1, 100000, stdin);\n\t\tif (S == T) return EOF;\n\t}\n\treturn *S++;\n}\ntemplate<typename T>\ninline void read(T &x) {\n\tstatic char c; x = 0; int sgn = 0;\n\tfor (c = get(); c < '0' || c > '9'; c = get()) if (c == '-') sgn = 1;\n\tfor (; c >= '0' && c <= '9'; c = get()) x = x * 10 + c - '0';\n\tif (sgn) x = -x;\n}\n\nint n;\nll addl, addr, ans;\nint l[N], r[N];\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\n\ntemplate<typename T>\ninline T Abs(T x) {\n\treturn x < 0 ? -x : x;\n}\n\nint main(void) {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(l[i]); read(r[i]);\n\t\tif (i == 1) {\n\t\t\tL.push(l[i]); R.push(l[i]);\n\t\t\taddl = addr = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint len2 = r[i] - l[i], len1 = r[i - 1] - l[i - 1];\n\t\taddl -= len2;\n\t\taddr += len1;\n\t\tll lb = L.top() + addl, rb = R.top() + addr;\n\t\tif (l[i] < lb) {\n\t\t\tans += Abs(lb - l[i]);\n\t\t\tR.push(lb - addr);\n\t\t\tL.push(l[i] - addl);\n\t\t\tL.push(l[i] - addl);\n\t\t\tL.pop();\n\t\t} else if (l[i] > rb) {\n\t\t\tans += Abs(rb - l[i]);\n\t\t\tL.push(rb - addl);\n\t\t\tR.push(l[i] - addr);\n\t\t\tR.push(l[i] - addr);\n\t\t\tR.pop();\n\t\t} else {\n\t\t\tL.push(l[i] - addl);\n\t\t\tR.push(l[i] - addr);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lld;\ntypedef multiset<lld>::iterator sit;\nmultiset<lld> a;\nmultiset<lld> b;\nlld sum_a=0;\nlld sum_b=0;\nlld l[1000000];\nlld r[1000000];\nlld absol(lld x){\n  if(x>0)return x;\n  return -x;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  \n  \n  lld minimum=0;\n  for(int i=0;i<n;i++){\n    cin>>l[i]>>r[i];\n    if(a.size()!=0){\n      sum_a+=r[i]-l[i];\n      sum_b-=r[i-1]-l[i-1];\n      sit s=b.begin();\n      lld index=0;\n      if(l[i]<*s-sum_b){\n\tsit FIM=a.end();\n\tFIM--;\n\tif(l[i]>*FIM-sum_a){//cout<<\"A\"<<endl;\n\t  a.insert(l[i]+sum_a);\n\t  b.insert(l[i]+sum_b);\n\t}else{\n\t  index=*FIM-sum_a;\n\t  minimum+=absol(l[i]-index);\n\t  a.insert(l[i]+sum_a);\n\t  a.insert(l[i]+sum_a);\n\t  sit top=a.end();\n\t  top--;\n\t  lld add=*top-sum_a;\n\t  a.erase(top);\n\t  b.insert(add+sum_b);\n\t}\n      }else{\n\tindex=*b.begin()-sum_b;\n\tminimum+=absol(l[i]-index);\n\tb.insert(l[i]+sum_b);\n\tb.insert(l[i]+sum_b);\n\tsit top=b.begin();\n\tlld add=*top-sum_b;\n\tb.erase(top);\n\ta.insert(add+sum_a);\n      }\n    }else{\n      a.insert(l[i]);\n      b.insert(l[i]);\n    }\n    /*for(auto it:a){\n      cout<<it-sum_a<<\" \";\n    }cout<<endl;\n    for(auto it:b){\n      cout<<it-sum_b<<\" \";\n      }cout<<endl;*/\n    \n    /*for(int i=0;i<changes.size();i++){\n      cout<<changes[i]<<\" \";\n    }cout<<endl;*/\n    \n  }\n  cout<<minimum<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    dp[i] = abs(L[i] - i);\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto preleft = max(0, j - R[i - 1] - L[i - 1]);\n      for(int k = preleft; k <= min(399, j + R[i] - L[i]); k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<complex>\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nll n;\nll a[N],b[N],l[N],r[N];\nll sp,tp;\npriority_queue<ll> S,s;\npriority_queue<ll,vector<ll>,greater<ll> >T,t;\nll Sf(){\n  return S.top()+sp;\n}\nll Tf(){\n  return T.top()+tp;\n}\nvoid Sp(ll x){\n  S.push(x-sp);\n}\nvoid Tp(ll x){\n  T.push(x-tp);\n}\nint main(){\n    cin>>n;\n    if(n>N)return 0;\n    for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n    for(int i=1;i<n;i++){\n      a[i]=l[i]-r[i-1];\n      b[i]=r[i]-l[i-1];\n    }\n    ll ans=0; sp=tp=0;\n    Sp(0); Tp(0);\n    Sp(-1e17); Tp(1e17);\n    for(int i=1;i<n;i++){\n      sp-=b[i],tp-=a[i];\n      ll s0=Sf();\n      ll t0=Tf();\n      if(s0<=0&&0<=t0){\n\tSp(0); Tp(0);\n      }\n      if(0<s0){\n\tSp(0); Sp(0);\n\tTp(Sf());\n\tans+=abs(Sf());\n\tS.pop();\n      }\n      if(t0<0){\n\tTp(0); Tp(0);\n\tSp(Tf());\n\tans+=abs(Tf());\n\tT.pop();\n      }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <istream>\n#include <ostream>\n\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mkp make_pair\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define rep(i,n) for(ll i=0; i < (n); ++i)\n#define rrep(i,n) for(ll i=((n)-1); i >= 0; --i)\n\n#define OPLT(T) bool operator<(const T & lop_, const T & rop_)\n#define OPEQ(T) bool operator==(const T & lop_, const T & rop_)\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nistream& operator>>(istream& istr, __float128& obj) { double d; istr >> d; obj = d; return istr; };\nostream& operator<<(ostream& ostr, __float128& obj) { ostr << static_cast<double>(obj); return ostr; };\n\nll dp[2][500];\nconst int INF = 1e9;\n\nint main() {\n\tint N; cin >> N;\n\tvector<pii> seg(N);\n\tif(N > 400) return 0;\n\trep(i,N) {\n\t\tcin >> seg[i].fi >> seg[i].se;\n\t\tif(seg[i].fi > 400 || seg[i].se > 400) return 0;\n\t\tseg[i].se++;\n\t}\n\trep(i,401)\n\t\tdp[0][i] = abs(seg[0].fi - i);\n\tfor(int i = 1; i < N; i++) {\n\t\trep(j,401) {\n\t\t\tint la, lb;\n\t\t\tla = seg[i-1].se - seg[i-1].fi;\n\t\t\tlb = seg[i].se - seg[i].fi;\n\t\t\trep(k,401) dp[i&1][j] = INF;\n\t\t\trep(k,401) {\n\t\t\t\tif(j < k+la && k < j+lb) {\n\t\t\t\t\tdp[i&1][j] = min<ll>(dp[i&1][j], dp[(i+1)&1][k] + abs(j-seg[i].fi));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = INF;\n\trep(i,401)\n\t\tres = min<ll>(dp[(N+1)&1][i], res);\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint ans[500];\nint d1[500][10];\nint d2[500][10];\nint a[100000][2];\nmap<int,int> mp;\n\nint main()\n{\n  int i,j,n,best,now,ll,k,kk;\n  vector<int> d;\n  scanf(\"%d\",&n);\n  if (n>400) return 0;\n  for (i=0;i<n;i++)\n  {\n    scanf(\"%d%d\",&a[i][0],&a[i][1]);\n    if (a[i][0]>400) return 0;\n    if (a[i][1]>400) return 0;\n  }\n  memset(ans,0,sizeof(ans));\n  now=0;\n  for (i=0;i<n;i++)\n  {\n    for (j=0;j<500;j++)\n    {\n      d1[j][0]=ans[j];\n      d2[j][0]=ans[j];\n    }\n    for (k=0;k+1<10;k++)\n      for (j=0;j<500;j++)\n      {\n        d1[j][k+1]=d1[j][k];\n        if ((j+(1<<k))<500)\n          if (d1[j+(1<<k)][k]<d1[j][k+1])\n            d1[j][k+1]=d1[j+(1<<k)][k];\n        d2[j][k+1]=d2[j][k];\n        if ((j-(1<<k))>=0)\n          if (d2[j-(1<<k)][k]<d2[j][k+1])\n            d2[j][k+1]=d2[j-(1<<k)][k];\n      }\n    ll=a[i][1]-a[i][0]+1;\n    kk=0;\n    while ((1<<kk)<=ll) kk++;\n    kk--;\n    for (j=0;j<500;j++)\n    {\n      if (j<a[i][0])\n      {\n        ans[j]=d1[j][kk];\n        if (d2[j+ll-1][kk]<ans[j]) ans[j]=d2[j+ll-1][kk];\n        ans[j]+=a[i][0]-j;\n      }\n      else if (j>a[i][1])\n      {\n        ans[j]=d2[j][kk];\n        if (d1[j-ll+1][kk]<ans[j]) ans[j]=d1[j-ll+1][kk];\n        ans[j]+=j-a[i][1];\n      }\n      else\n      {\n        ans[j]=d1[a[i][0]][kk];\n        if (d2[a[i][1]][kk]<ans[j]) ans[j]=d2[a[i][1]][kk];\n      }\n    }\n  }\n  best=2000000000;\n  for (i=0;i<500;i++)\n    if (ans[i]<best) best=ans[i];\n  printf(\"%d\\n\",best);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MN 411\nusing namespace std;\n\nint read_p,read_ca;\ninline int read(){\n    read_p=0;read_ca=getchar();\n    while(read_ca<'0'||read_ca>'9') read_ca=getchar();\n    while(read_ca>='0'&&read_ca<='9') read_p=read_p*10+read_ca-48,read_ca=getchar();\n    return read_p;\n}\nconst int N=400;\nint n,K,dp[MN][MN],l,r,la;\ninline int min(int a,int b){return a<b?a:b;}\nint main(){\n\tregister int i,j,k;\n\tn=read();\n\tfor (i=1;i<=n;i++){\n\t\tl=read();r=read();\n\t\tif (i-1)\n\t\tfor (j=1;j<=N;j++)\n\t\tfor (dp[i][j]=2e9,k=max(j-la,1);k<=min(N,j+(r-l));k++) dp[i][j]=min(dp[i][j],dp[i-1][k]);\n\t\tfor (j=1;j<=N;j++) dp[i][j]+=abs(l-j);\n\t\tla=r-l;\n\t}\n\tla=2e9;\n\tfor (i=1;i<=N;i++) la=min(la,dp[n][i]);\n\tprintf(\"%d\\n\",la);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint need(int from_l, int from_r, int to_l, int to_r) {\n  if (from_r < to_l || to_r < from_l) {\n    return max(to_l - from_r, from_l - to_r);\n  }\n  return 0;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  assert(n <= 400);\n\n  vi l(n), r(n);\n  rep (i, n) {\n    scanf(\"%d%d\", &l[i], &r[i]);\n    assert(l[i] <= 400);\n    assert(r[i] <= 400);\n  }\n\n\n  ll INF = 1e18;\n  vvll dp(n, vll(400, INF));\n  FOR (i, 1, 401 - r[0] + l[0]) {\n    dp[0][i] = abs(i - l[0]);\n  }\n\n  FOR (i, 1, n) {\n    int leng = r[i] - l[i];\n    FOR (j, 1, 401 - leng) {\n      int to_l = j;\n      int to_r = j + leng;\n      int cost = abs(j - l[i]);\n      int search_l_min, search_l_max;\n      int prev_leng = r[i-1] - l[i-1];\n\n      search_l_min = max(1, to_l - prev_leng);\n      search_l_max = min(400 - prev_leng, to_r);\n      ll prev_cost = INF;\n      FOR (k, search_l_min, search_l_max + 1) {\n        prev_cost = min(prev_cost, dp[i-1][k]);\n      }\n      dp[i][j] = cost + prev_cost;\n    }\n  }\n\n  ll ans = INF;\n  rep (i, 400) {\n    ans = min(ans, dp[n-1][i]);\n  }\n  printf(\"%lld\\n\", ans);\n  \n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 100005\n#define INF 100000000000000000LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <ll,int> P;\n\nstruct T\n{\n\tll sum;\n\tint sz;\n\tT *l,*r;\n\tP left,right;\n\tP p;\n\tT(ll sum=0,int sz=0,P p=P(0,0)):sum(sum),sz(sz),p(p),left(p),right(p){}\n\tvoid pass()\n\t{\n\t\tif(l!=NULL)\n\t\t{\n\t\t\tl->sum+=sum;\n\t\t\tl->p.first+=sum;\n\t\t\tl->left.first+=sum;\n\t\t\tl->right.first+=sum;\n\t\t}\n\t\tif(r!=NULL)\n\t\t{\n\t\t\tr->sum+=sum;\n\t\t\tr->p.first+=sum;\n\t\t\tr->left.first+=sum;\n\t\t\tr->right.first+=sum;\n\t\t}\n\t\tsum=0;\n\t}\n\tvoid update()\n\t{\n\t\tsz=1;\n\t\tsum=0;\n\t\tleft=right=p;\n\t\tif(l!=NULL) sz+=l->sz;\n\t\tif(r!=NULL) sz+=r->sz;\n\t\tif(l!=NULL) left=l->left;\n\t\tif(r!=NULL) right=r->right;\n\t}\n\tvoid see()\n\t{\n\t\tprintf(\"%lld %d : %lld %d\\n\",left.first,left.second,right.first,right.second);\n\t\tprintf(\"%d\\n\",sz);\n\t}\n};\ntypedef pair <T*,T*> PT;\nT* merge(T *l,T *r)\n{\n\tif(l==NULL) return r;\n\tif(r==NULL) return l;\n\tint t=rand()%(l->sz+r->sz);\n\tif(t<l->sz)\n\t{\n\t\tl->pass();\n\t\tl->r=merge(l->r,r);\n\t\tl->update();\n\t\treturn l;\n\t}\n\telse\n\t{\n\t\tr->pass();\n\t\tr->l=merge(l,r->l);\n\t\tr->update();\n\t\treturn r;\n\t}\n}\nPT split(T *v,P p)//leftがp未満と以上で切り分ける\n{\n\tif(v==NULL) return PT(NULL,NULL);\n\tif(v->left>=p) return PT(NULL,v);\n\tif(v->right<p) return PT(v,NULL);\n\tif(v->p>=p)\n\t{\n\t\tv->pass();\n\t\tPT q=split(v->l,p);\n\t\tv->l=q.second;\n\t\tv->update();\n\t\treturn PT(q.first,v);\n\t}\n\telse\n\t{\n\t\tv->pass();\n\t\tPT q=split(v->r,p);\n\t\tv->r=q.first;\n\t\tv->update();\n\t\treturn PT(v,q.second);\n\t}\n}\nT* ins(T *v,P p)\n{\n\tPT q=split(v,p);\n\tT *t=new T(0,1,p);\n\treturn merge(q.first,merge(t,q.second));\n}\nT* add(T *v,P p,ll vl)//p以上のところにv足す\n{\n\tPT q=split(v,p);\n\tif(q.second)\n\t{\n\t\tq.second->sum+=vl;\n\t\tq.second->p.first+=vl;\n\t\tq.second->left.first+=vl;\n\t\tq.second->right.first+=vl;\n\t}\n\treturn merge(q.first,q.second);\n}\nP get(T *v,int k)//k番目取得\n{\n\tT *at=v;\n\twhile(1)\n\t{\n\t\tat->pass();\n\t\t//printf(\"%lld %d : %lld %d\\n\",at->left.first,at->left.second,at->right.first,at->right.second);\n\t\tif(at->sz==k+1) return at->right;\n\t\tif(k==0) return at->left;\n\t\tint left=at->l==NULL?0:at->l->sz;\n\t\tif(left<=k)\n\t\t{\n\t\t\tk-=left+1;\n\t\t\tif(k==-1) return at->p;\n\t\t\tat=at->r;\n\t\t}\n\t\telse at=at->l;\n\t}\n\treturn P(-1,-1);\n}\nT *root;\nvoid add_point(P p){root=ins(root,p);}\nvoid add_value(P p,ll vl){root=add(root,p,vl);}\nP get_kth(int k){return get(root,k);}\n\nint L[SIZE],R[SIZE];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tll sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d\",&L[i],&R[i]);\n\t\tif(i>0)\n\t\t{\n\t\t\tP p2=get_kth(i);\n\t\t\t//printf(\"%lld %d\\n\",p2.first,p2.second);\n\t\t\tadd_value(p2,R[i]-L[i]);\n\t\t\tadd_value(P(-INF,-1),-R[i]+L[i]);\n\t\t\tsum-=(ll) (R[i]-L[i])*(ll) i;\n\t\t}\n\t\tadd_point(P(L[i],i*2));\n\t\tadd_point(P(L[i],i*2+1));\n\t\tP p=get_kth(i+1);\n\t\tadd_value(p,R[i]-L[i]);\n\t\tsum+=L[i];\n\t\t//printf(\"* %lld %d\\n\",p.first,p.second);\n\t\t//for(int j=0;j<2*i+2;j++) printf(\"%lld \",get_kth(j).first);puts(\"\");\n\t}\n\tvector <P> vx;\n\tfor(int i=0;i<2*n;i++) vx.push_back(get_kth(i));\n\t//for(int i=0;i<2*n;i++) printf(\"%lld\\n\",vx[i].first);\n\t//左端は-Nx+sum\n\tfor(int i=0;i<n;i++) sum-=vx[i].first;\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Author : rama_pang\n * Problem: \n * Time   : O(N log N)\n * Memory : O(N)\n * \n * Let dp(n, x) = minimum cost for the first n rectangles, and the n-th rectangle left endpoint is at x.\n * Let len[n] = r[n] - l[n] + 1\n * \n * dp(n, x) = min{dp(n - 1, y) for (x - len[n - 1] + 1 <= y <= x + len[n] - 1)} + abs(l[n] - x)\n * \n * Left f(n, x) be the plot function of dp(n, x), with f(n) as the whole plot\n * \n * Alternatively, we define\n * g(n) = min{f(n - 1) for (x - (len[n - 1] - 1) <= y <= x + len[n] - 1)}\n * h(n) = abs(l[n] - x)\n * f(n) = g(n) + h(n)\n * \n * We first see that f(n) is concave. Why? Since h(n) is concave, and g(n) applies transfromation to an already\n * concave function, when we added those two, the resulting function is still concave.\n * \n * Assume we have found f(n - 1). How do we transition into f(n)?\n * First, we apply g(n).\n * \n * Notice that since the function is concave, the left part is shifted to the left, and the right part is shifted\n * to the right by (len[n - 1] - 1). The exception is the minimummost point, which gets bigger.\n * \n * Next, we apply h(n).\n * Notice that for all values with x <= l[n], their line gradient is decreased by 1, and for x >= l[n], the line\n * gradient is shifted up by 1.\n * \n * We can query the minimum point to find the answer, which is at a point where the gradient is 0 (since the function\n * is concave).\n * \n * We can use 2 priority queues maintaining the left side of the minimummost area and the right side of the minimummost\n * area.\n * \n**/\n\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n\n  int n;\n  cin >> n;\n\n  priority_queue<lint, vector<lint>, less<lint>> lower;\n  priority_queue<lint, vector<lint>, greater<lint>> upper;\n\n  lint ans = 0;\n  lint lazy_lower = 0;\n  lint lazy_upper = 0;\n\n  lint cur_len = 0, last_len = 0;\n  for (int i = 0; i < n; i++) {\n    lint l, r;\n    cin >> l >> r;\n    tie(last_len, cur_len) = make_pair(cur_len, r - l + 1);\n\n    if (i == 0) {\n      lower.emplace(l);\n      upper.emplace(r);\n      continue;\n    }\n\n    // Apply g(n)\n    lazy_lower -= cur_len - 1;     // points <= minimum get shifted by len[n] - 1\n    lazy_upper += last_len - 1; // points >= minimum get shifted by len[n - 1] - 1\n\n    if (l <= lower.top() + lazy_lower) {\n      lint top = lower.top() + lazy_lower;\n      ans += top - l; // move segment to a minimum point, which is at top since top's gradient is now 0 (previously -1).\n      // Apply h(n)\n      lower.emplace(l - lazy_lower);\n      lower.emplace(l - lazy_lower);\n      upper.emplace(top - lazy_upper);\n      lower.pop();\n    } else if (l >= upper.top() + lazy_upper) {\n      lint top = upper.top() + lazy_upper;\n      ans += l - top; // move segment to a minimum point, which is at top since top's gradient is now 0 (previously 1).\n      // Apply h(n)\n      upper.emplace(l - lazy_upper);\n      upper.emplace(l - lazy_upper);\n      lower.emplace(top - lazy_lower);\n      upper.pop();\n    } else { // segment is already at an optimal place, so we just apply h(n)\n      lower.emplace(l - lazy_lower);\n      upper.emplace(l - lazy_upper);\n    }\n  }\n\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint n;\nP A[N];\nvoid Min(ll &a,ll b){a=min(a,b);}\n\n\nmap<P,ll>MD[N],MU[N];\nll calcU(int pos,ll L,ll R){\n  if(pos==-1) return 0;\n  if(MU[pos].count(P(L,R)))return MU[pos][P(L,R)];\n  ll l = A[pos].first, r = A[pos].second;\n  ll a = 1LL<<50;\n  if(!(r<L||R<l)) a = calcU(pos-1,l,r);\n  ll b = abs(R-l)+calcU(pos-1,R,r);\n  ll c = abs(L-r)+calcU(pos-1,l,L);\n  ll d = abs(L-l)+calcU(pos-1,L,L+(r-l));\n  ll e = abs(R-r)+calcU(pos-1,R-(r-l),R);\n  return MU[pos][P(L,R)]=min(a,min(b,min(c,min(d,e))));\n}\n\nll calcD(int pos,ll L,ll R){\n  if(pos==n) return 0;\n  if(MD[pos].count(P(L,R)))return MD[pos][P(L,R)];\n  ll l = A[pos].first,r = A[pos].second;\n  ll a = 1LL<<50;\n  if(!(r<L||R<l)) a = calcD(pos+1,l,r);\n  ll b = abs(R-l)+calcD(pos+1,R,r);\n  ll c = abs(L-r)+calcD(pos+1,l,L);\n  ll d = abs(L-l)+calcD(pos+1,L,L+(r-l));\n  ll e = abs(R-r)+calcD(pos+1,R-(r-l),R);\n  return MD[pos][P(L,R)]=min(a,min(b,min(c,min(d,e))));\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].first>>A[i].second;\n  \n  ll ans=1LL<<50;\n  for(int i=0;i<n;i++) {\n    int L = A[i].first;\n    int R = A[i].second;\n    ans=min(ans,calcU(i-1,L,R)+calcD(i+1,L,R));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 999999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = 0;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 405;\n\nint n,a[maxn],b[maxn],f[maxn][maxn];\n\nvoid pd(int&ret,int val) {\n  if(ret==-1||ret>val)ret=val;\n}\n\nint main() {\n  //freopen(\"in.cpp\",\"r\",stdin);\n  cin>>n;\n  for(int i=1; i<=n; i++)cin>>a[i]>>b[i];\n  memset(f,-1,sizeof(f));\n  for(int i=0; i<maxn; i++)f[1][i]=abs(i-a[1]);\n  for(int i=1; i<n; i++)\n    for(int j=0; j<maxn; j++) {\n      if(f[i][j]==-1)continue;\n      for(int k=0; k<maxn; k++) {\n        if(k+b[i+1]-a[i+1]<j||j+b[i]-a[i]<k)continue;\n        pd(f[i+1][k],f[i][j]+abs(k-a[i+1]));\n      }\n    }\n    //cout<<f[1][2]<<endl;\n  int ret=-1;\n  for(int i=0; i<maxn; i++)if(f[n][i]!=-1)pd(ret,f[n][i]);\n  cout<<ret<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// atcoder ARC 70E\nusing namespace std;\ntypedef long long ll;\n\npriority_queue<ll> l; // biggest first\npriority_queue<ll, vector<ll>, greater<ll>> r; // smallest first\nll n;\nvoid printpq(){\n\tvector<ll> temp;\n\tprintf(\"L: \");\n\twhile(!l.empty()){\n\t\ttemp.push_back(l.top());\n\t\tprintf(\"%d \", l.top());\n\t\tl.pop();\n\t}\n\tprintf(\"\\n\");\n\tfor(auto i : temp) l.push(i);\n\ttemp.clear();\n\tprintf(\"R: \");\n\twhile(!r.empty()){\n\t\ttemp.push_back(r.top());\n\t\tprintf(\"%d \", r.top());\n\t\tr.pop();\n\t}\n\tfor(auto i : temp) r.push(i);\n\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n}\ntypedef pair<ll, ll> pi;\npi A[100050];\nint main(){\n\t//freopen(\"narrowrectangles.in\", \"r\", stdin);\n\tcin >> n;\n\tll a,b; cin >> a >> b;\n\tA[0] = pi(a,b);\n\tl.push(a); r.push(b);\n\tll ans = 0;\n\tfor(ll i = 1; i<n; i++){\n\t\tcin >> a >> b;\n\t\tA[i] = pi(a,b);\n\t\tif(b <= l.top()){ // interval within l\n\t\t\tans += l.top() - b;\n\t\t\tl.push(a);\n\t\t\tl.push(b);\n\t\t\tr.push(l.top());\n\t\t\tl.pop();\n\t\t}else if(a >= r.top()){ // interval within r\n\t\t\tans += a - r.top();\n\t\t\tr.push(a);\n\t\t\tr.push(b);\n\t\t\tl.push(r.top());\n\t\t\tr.pop();\n\t\t}else{ // interval split or something\n\t\t\tl.push(a);\n\t\t\tr.push(b);\n\t\t}\n\t\t//printpq();\n\t\t// insert the polls a,b!!\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=(n)-1;i>=0;i--)\n#define VSORT(v) sort(v.begin(), v.end())\n#define DVSORT(v) sort(v.begin(), v.end(),greater<int>())\n#define SORT(v, n) sort(v, v+n)\n#define DSORT(v,n) sort(v, v+n,greater<int>())\n#define vi vector<int>\n#define pb push_back\n#define P pair<int,int>\n\n\ntemplate <class T> void chmin(T&a, const T&b) { a = min(a,b); }\ntemplate <class T> void chmax(T&a, const T&b) { a = max(a,b); }\n\nconst double EPS =1e-9;\nconst long INF =999999999;\nconst long MOD =1000000007; //10^9+7\n#define PI 3.14159265258979\n\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\nint main(void){\t\n\tll n,dp[405]={};\n\tll result=0,min=INF,max=0,l,r;\n\n\tcin>>n;\n\tif(n>401) return 0;\n\tREP(i,n){\n\t\tcin>>l>>r;\n\t\tdp[l]++;dp[r+1]--;\n\t\tchmin(min,l);chmax(max,r+1);\n\t}\n\n\tFOR(i,min+1,max){\n\t\tdp[i]+=dp[i-1];\n\t\tif(dp[i]==0) result++;\n\t}\n\tcout<<result<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define ll long long\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n    int x=0;char ch=getchar();\n    while (ch<'0'||ch>'9')ch=getchar();\n    while (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nll ans=1e18;\nint n,l[MN+5],r[MN+5];\ninline int Abs(int x){return x<0?-x:x;}\nll Solve(int x)\n{\n    ll res=Abs(x);int v=x;\n    for(int i=2;i<=n;++i)\n    {\n        ll lt=l[i-1]-r[i],rt=r[i-1]-l[i];\n        if(v+lt<=0&&v+rt>=0) res+=Abs(v=0);\n        else if(Abs(v+rt)<Abs(v+lt)) res+=Abs(v+=rt);\n        else res+=Abs(v+=lt);\n    //    cout<<i<<\" \"<<lt<<\" \"<<rt<<\" \"<<v<<endl;\n    }\n    //cout<<x<<\" \"<<res<<endl;\n    return ans=min(ans,res),res;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n    //Solve(0);return 0;\n    int l=-1e9,r=1e9;\n    while(l+1<r)\n    {\n        int m1=l+(r-l+1)/3,m2=m1+(r-l+1)/3;\n        ll s1=Solve(m1),s2=Solve(m2);\n        if(s1<s2) r=m2-1; else l=m1+1;\n    }\n    while(l<=r) Solve(l++);\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nll l[100000], r[100000];\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tmultiset<ll> L, R;\n\tll offL = 0, offR = 0, m = 0;\n\tL.insert(-(1LL << 60));\n\tR.insert(1LL << 60);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i > 0) {\n\t\t\toffR += (r[i - 1] - l[i - 1]);\n\t\t\toffL -= (r[i] - l[i]);\n\t\t}\n\t\tif (l[i] < *L.rbegin() + offL) m += *L.rbegin() + offL - l[i];\n\t\telse if (*R.begin() + offR < l[i]) m += l[i] - (*R.begin() + offR);\n\t\tif (l[i] < *L.rbegin() + offL) {\n\t\t\tR.insert(*L.rbegin() + offL - offR);\n\t\t\tL.insert(l[i] - offL);\n\t\t\tL.insert(l[i] - offL);\n\t\t\tL.erase(L.find(*L.rbegin()));\n\t\t}\n\t\telse if (*R.begin() + offR < l[i]) {\n\t\t\tL.insert(*R.begin() + offR - offL);\n\t\t\tR.insert(l[i] - offR);\n\t\t\tR.insert(l[i] - offR);\n\t\t\tR.erase(R.find(*R.begin()));\n\t\t}\n\t\telse {\n\t\t\tL.insert(l[i] - offL);\n\t\t\tR.insert(l[i] - offR);\n\t\t}\n\t}\n\tcout << m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __numeric {\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type floor(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d - ((n < 0) && (n % d));\n    }\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type ceil(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d + ((n > 0) && (n % d));\n    }\n};\nusing namespace __numeric;\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nstruct monostate {\n    friend istream& operator>>(istream& is, const monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const monostate& ms) { return os; }\n    friend monostate operator+(const monostate& a, const monostate& b) { return a; }\n} ms;\n#pragma GCC diagnostic pop\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\ntemplate<typename T> struct PWLC {\n    T y0;\n    max_heap<pair<T, T>> left;\n    min_heap<pair<T, T>> right;\n    T left_offset = 0, right_offset = 0;\n\n    PWLC(T _y0 = 0) : y0(_y0) {}\n\n    /* __ : y = alpha */\n    static PWLC constant(T alpha) { return PWLC(alpha); }\n    /* \\_ : y = max(0, beta * (x - x0)) */\n    static PWLC decreasing(T x0, T beta = -1) { assert(beta <= 0); PWLC f; f.left.push({ x0, -beta }); return f; }\n    /* _/ : y = max(0, beta * (x - x0)) */\n    static PWLC increasing(T x0, T beta =  1) { assert(beta >= 0); PWLC f; f.right.push({ x0, beta }); return f; }\n    /* \\/ : y = beta * abs(x - x0) */\n    static PWLC abs(T x0, T beta = 1) { return decreasing(x0, -beta) + increasing(x0, beta); }\n\n    /* f'(x) = f(x + c) */\n    void shift(int c) { left_offset -= c; right_offset -= c; }\n    /* \\_/ => \\__ : f'(x') = min_{x <= x'} f(x) */\n    void prefix_min() { while (!right.empty()) right.pop(); }\n    /* \\_/ => __/ : f'(x') = min_{x >= x'} f(x) */\n    void suffix_min() { while (!left.empty()) left.pop(); }\n\t/* \\_/ => \\__/ : f'(x') = min_{dx in [xl, xr]} f(x' + dx) */\n\tvoid range_min(T xl, T xr) {\n\t\tassert(xl <= xr);\n\t\tif (xl > 0) shift(xl), tie(xl, xr) = make_pair(0, xr - xl);\n\t\tif (xr < 0) shift(xr), tie(xl, xr) = make_pair(xl - xr, 0);\n\t\tleft_offset -= xr;\n\t\tright_offset -= xl;\n\t}\n\n    T minimum() const { return y0; }\n\tT left_arg_min() const { return left.empty() ? numeric_limits<T>::min() : (left.top().first + left_offset); }\n\tT right_arg_min() const { return right.empty() ? numeric_limits<T>::max() : (right.top().first + right_offset); }\n\n    void operator+=(PWLC o) {\n        y0 += o.y0;\n\t\tfor (; !o.left.empty(); o.left.pop()) {\n\t\t\tT x = o.left.top().first + o.left_offset;\n\t\t\tT beta_change = o.left.top().second;\n\n\t\t\tif (x <= right_arg_min()) {\n\t\t\t\tleft.push({ x - left_offset, beta_change });\n\t\t\t} else {\n\t\t\t\tT x0 = right_arg_min();\n\t\t\t\ty0 += (x - x0) * beta_change;\n\t\t\t\tright.push({ x - right_offset, beta_change });\n\t\t\t\tfor (T beta = beta_change; beta > 0; ) {\n\t\t\t\t\tT next_change = right.top().second;\n\t\t\t\t\tright.pop();\n\t\t\t\t\tif (next_change >= beta) {\n\t\t\t\t\t\tleft.push({ x0 - left_offset, beta });\n\t\t\t\t\t\tif (next_change > beta) right.push({ x0 - right_offset, next_change - beta });\n\t\t\t\t\t\tbeta = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbeta -= next_change;\n\t\t\t\t\t\ty0 -= beta * (right_arg_min() - x0);\n\t\t\t\t\t\tx0 = right_arg_min();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (; !o.right.empty(); o.right.pop()) {\n\t\t\tT x = o.right.top().first + o.right_offset;\n\t\t\tT beta_change = o.right.top().second;\n\n\t\t\tif (x >= left_arg_min()) {\n\t\t\t\tright.push({ x - right_offset, beta_change });\n\t\t\t} else {\n\t\t\t\tT x0 = left_arg_min();\n\t\t\t\ty0 += (x0 - x) * beta_change;\n\t\t\t\tleft.push({ x - left_offset, beta_change });\n\t\t\t\tfor (T beta = beta_change; beta > 0; ) {\n\t\t\t\t\tT next_change = left.top().second;\n\t\t\t\t\tleft.pop();\n\t\t\t\t\tif (next_change >= beta) {\n\t\t\t\t\t\tright.push({ x0 - right_offset, beta });\n\t\t\t\t\t\tif (next_change > beta) left.push({ x0 - left_offset, next_change - beta });\n\t\t\t\t\t\tbeta = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbeta -= next_change;\n\t\t\t\t\t\ty0 -= beta * (x0 - left_arg_min());\n\t\t\t\t\t\tx0 = left_arg_min();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\tfriend PWLC operator+(const PWLC &a, const PWLC &b) { PWLC f(a); f += b; return f; }\n};\n\nint main() {\n    setIO();\n\n    int N; re(N);\n\n    PWLC<ll> f;\n\tF0R (i, N) {\n        int l, r; re(l, r);\n        f.range_min(0, r - l); // if this one has left endpoint at x, previous must touch [x, x + r - l]\n        f += PWLC<ll>::abs(l); // cost for this to have left endpoint at x\n        f.range_min(l - r, 0); // for this to touch x, it should have left endpoint in [x - (r - l), x]\n        //cerr << f.minimum() << \" \" << f.left_arg_min() << \" \" << f.right_arg_min() << endl;\n\t}\n\n\tps(f.minimum());\n\n    // did you check N=1? did you mix up N,M?\n    // check your \"infinity\" and \"null\" values against the bounds\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\n/*\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + offsetL;\n\t\tret2 += (temp - pos);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + offsetR;\n\t\tret2 += (pos - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n*/\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tmultiset<LL>::iterator Left,Right;\n\t\tLeft = LS.end();\n\t\tLeft--;\n\t\tRight = RS.begin();\n\t\t\n\t\tif( L[i] < *Left + ofL ){\n\t\t\t/*\n\t\t\tLL temp = *Left + ofL;\n\t\t\tret += (temp - L[i]);\n\t\t\n\t\t\tRS.insert( temp - ofR );\n\n\t\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\t\tLS.insert( L[i] - ofR );\n\t\t\tLS.insert( L[i] - ofR );\n\t\t\t*/\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}else if( *Right + ofR < L[i] ){\n\t\t\t/*\n\t\t\tLL temp = *Right + ofR;\n\t\t\tret += (L[i] - temp);\n\n\t\t\tRS.erase( Right );\n\t\t\tRS.insert( L[i] - ofR );//元々あった|Right-x|の効果\n\t\t\tRS.insert( L[i] - ofR );//|L-x|の効果\n\t\t\tLS.insert( temp - ofL );\n\t\t\t*/\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}else{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t\t/*\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t*/\n\t}\n\tcout << ret << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve2();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvl l,r,len;\n\nint main(){\n\tcin>>n;\n\tl=r=len=vl(n);\n\tset<ll> L,R;\n\tll lx=0,rx=0,res=0;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>l[i]>>r[i];\n\t\tlen[i]=r[i]-l[i];\n\t}\n\tL.insert(l[0]);\n\tR.insert(l[0]);\n\tfor(int i=1;i<n;i++){\n\t\t lx-=len[i];\n\t\t rx+=len[i-1];\n\t\t auto li=L.end(),ri=R.begin();\n\t\t li--;\n\t\t ll ls=*li+lx,rs=*ri+rx;\n\t\t if(ls<=l[i]&&l[i]<=rs){\n\t\t\t L.insert(l[i]-lx);\n\t\t\t R.insert(l[i]-rx);\n\t\t }\n\t\t else if(l[i]<=*li+lx){\n\t\t\t L.insert(l[i]-lx);\n\t\t\t L.erase(li);\n\t\t\t R.insert(ls-rx);\n\t\t\t res+=ls-l[i];\n\t\t }\n\t\t else{\n\t\t\t R.insert(l[i]-rx);\n\t\t\t R.erase(ri);\n\t\t\t L.insert(rs-lx);\n\t\t\t res+=l[i]-rs;\n\t\t }\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n#pragma warning(disable:4996)\nint dp[500][500], n, l[500], r[500];\nint solve(int pos, int rec) {\n\tif (pos == n)return 0;\n\tif (dp[pos][rec] >= 0)return dp[pos][rec];\n\n\tint L = rec, R = rec + r[pos - 1] - l[pos - 1], minx = 999999999;\n\tfor (int i = 0; i < 450; i++) {\n\t\tint I = i, J = i + r[pos] - l[pos];\n\t\tif (J < L || R < I)continue;\n\t\tminx = min(minx, solve(pos + 1, i) + abs(l[pos] - i));\n\t}\n\tdp[pos][rec] = minx;\n\treturn minx;\n}\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++)cin >> l[i] >> r[i];\n\tfor (int i = 0; i < 500; i++) { for (int j = 0; j < 500; j++)dp[i][j] = -1; }\n\tint G = 999999999; for (int i = 1; i < 500; i++)G = min(G, solve(1, i) + abs(l[0] - i));\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n \nstatic int64_t getMinCost(multiset<int64_t> &leftNodes,\n\t\t      multiset<int64_t> &rightNodes,\n\t\t      int64_t curmincost,\n\t\t      int64_t minpos,\n\t\t      int64_t loff,\n\t\t      int64_t roff)\n{\n    if (leftNodes.size() == 0) {\n\treturn curmincost;\n    }\n\n    auto ilmax = leftNodes.end();\n    ilmax--;\n    int64_t lmax = *ilmax - loff;\n    auto irmin = rightNodes.begin();\n    int64_t rmin = *irmin + roff;\n    \n    if (lmax <= minpos) {\n\tif (minpos <= rmin) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - rmin + curmincost;\n    } else {\n\treturn lmax - minpos + curmincost;\n    }\n}\n \nint main(void){\n    int64_t n;\n    int64_t mincost;\n    multiset<int64_t> leftNodes;\n    multiset<int64_t> rightNodes;\n    stringstream st;\n    string line;\n      \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n    \n    int64_t nl, nr;\n    int64_t l, r;\n    int64_t loff, roff;\n    loff = 0;\n    roff = 0;    \n    mincost = 0;    \n    for (int64_t i = 0; i < n; i++) {\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> nl >> nr;\n\tif (i >= 1) {\n\t    \n\t    mincost = getMinCost(leftNodes, rightNodes, mincost, l, loff, roff);\n\n\t    if (leftNodes.size() == 0) {\n\t\tleftNodes.insert(l);\n\t\trightNodes.insert(l);\n\t    } else {\n\t\tauto ilmax = leftNodes.end();\n\t\tilmax--;\n\t\tint64_t lmax = *ilmax - loff;\n\t\tif (lmax <= l) {\n\t\t    auto irmin = rightNodes.begin();\n\t\t    int64_t rmin = *irmin + roff;\n\t\t    if (l <= rmin) {\n\t\t\tleftNodes.insert(l + loff);\n\t\t\trightNodes.insert(l - roff);\n\t\t    } else {\n\t\t\trightNodes.insert(l - roff);\n\t\t\trightNodes.insert(l - roff);\n\n\t\t\tleftNodes.insert(rmin + loff);\n\t\t\trightNodes.erase(irmin);\n\t\t    }\n\t\t} else {\n\t\t    leftNodes.insert(l + loff);\n\t\t    leftNodes.insert(l + loff);\n\n\t\t    rightNodes.insert(lmax - roff);\n\t\t    leftNodes.erase(ilmax);\n\t\t}\n\t    }\n\t    roff += r - l;\n\t    loff += nr - nl;\n\n#if 0\n\t    for (auto e : leftNodes) {\n\t\tcout << e - loff << \" \";\n\t    }\n\t    for (auto e : rightNodes) {\n\t\tcout << e + roff << \" \";\n\t    }\t    \n\t    cout << endl;\n#endif\t\n\t}\n\tl = nl;\n\tr = nr;\n    }\n \n    mincost = getMinCost(leftNodes, rightNodes, mincost, l, loff, roff);\n \n    cout << mincost << endl;\n    return 0;\n \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define V vector<int>\nint N, l[100010], r[100010];\nV p;\nint getscore(int i, int p)\n{\n    if (l[i] > p) {\n        return l[i] - p;\n    } else if (r[i] < p) {\n        return p - r[i];\n    } else {\n        return 0;\n    }\n}\nvoid solve()\n{\n    FOR(i, 0, N)\n    {\n        p.push_back(l[i]);\n        p.push_back(r[i]);\n    }\n    sort(all(p));\n    int ans = 0;\n    FOR(i, 0, N)\n    {\n        ans += getscore(i, p[N]);\n    }\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    FOR(i, 0, N)\n    cin >> l[i] >> r[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef tree < long long ,  null_type ,  less<long long> ,  rb_tree_tag ,  tree_order_statistics_node_update > ordered_set;\n \n#define mp make_pair\n#define fi first\n#define se second\n \nconst int N = 1e5 + 10;\n\nint l[N], r[N];\nmultiset<long long> sa, sb; \nlong long a, b;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\t\n\tint n;\n\tcin>>n;\n\tint l1 = 0;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tint l2 = r[i] - l[i]; \n\t\tif (i > 1) a -= l2, b += l1;\n\t\tl1 = l2;\n\t\tlong long x, y;\n\t\tif (i > 1) {\n\t\t\tset<long long>::iterator it = sa.end(); it--;\n\t\t\tx = *it + a;\n\t\t\tit = sb.begin();\n\t\t\ty = *it + b;\n\t\t} else x = 0, y = 0;\n\t\tif (x <= l[i] && l[i] <= y) {\n\t\t\tsa.insert(l[i] - a), sb.insert(l[i] - b);\n\t\t} else if (l[i] < x) {\n\t\t\tsa.insert(l[i] - a), sa.insert(l[i] - a);\n\t\t\tset<long long>::iterator it = sa.end(); it--;\n\t\t\tsb.insert(*it + a - b); sa.erase(it);\n\t\t} else if (l[i] > y) {\n\t\t\tsb.insert(l[i] - b), sb.insert(l[i] - b);\n\t\t\tset<long long>::iterator it = sb.begin(); \n\t\t\tsa.insert(*it + b - a); sb.erase(it);\n\t\t}\n\t}\n\tlong long jaw = 0, t = -1e13;\n\tfor(int i=n; i>=1; i--) jaw += l[i] - t, t += r[i] - l[i];\n\tlong long d = -n; \n\tlong long tmp = -1e13;\n\tfor(set<long long>::iterator it = sa.begin(); it != sa.end(); it++)\n\t\tjaw += 1LL * d * (*it + a - tmp), tmp = *it + a, d++;\n\tcout <<jaw<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    dp[i] = abs(L[0] - i);\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto preleft = max(0, j - (R[i - 1] - L[i - 1]));\n      for(int k = preleft; k < min(400, j + R[i] - L[i] + 1); k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct interval\n{\n\tlong long l,r;\n}a[200000];\nlong long n;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tlong long l=1ll<<62,r=0;\n\tfor(int i=0;i<n;i++)scanf(\"%lld%lld\",&a[i].l,&a[i].r),l=min(l,a[i].l),r=max(r,a[i].r);\n\tlong long ans=1ll<<62;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tlong long cost=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(i<a[j].l)cost+=a[j].l-i;\n\t\t\telse if(i>a[j].r)cost+=i-a[j].r;\n\t\tans=min(ans,cost);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(int L,int R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\t/*\n\tf(x) = abs(x-L)\n\tの関数を足す。\n\t*/\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\t--Left;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t\tRS.insert( temp - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + ofL;\n\t\tret += (temp - L);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + ofR;\n\t\tret += (L - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\taddABSfunc( L[i] );\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tadd2init();\n\taddABSfunc2(0,0,L[0]);\n\tfor(int i=1;i<N;++i){\n\t\taddABSfunc2(R[i]-L[i],R[i-1]-L[i-1],L[i]);\n\t}\n\tcout << ret2 << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve2();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long\n\nusing namespace std;\n\nconst int N = 1e5+5;\n\nint n;\nint l[N], r[N];\nlong high, lz_l, lz_r;\nmultiset<long> L, R;\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", l + i, r + i), r[i] -= l[i];\n    for(int i = 1; i <= n; i++) {\n        high += l[i];\n        L.emplace(l[i] + lz_l), R.emplace(l[i] - lz_r);\n        while(*L.rbegin() - lz_l > *R.begin() + lz_r) {\n            int l = *L.rbegin(), r = *R.begin();\n            L.erase(L.find(l)), R.erase(R.find(r));\n            L.emplace(r + lz_r + lz_l), R.emplace(l - lz_l - lz_r);\n        }\n        if(i == n) continue;\n        long pv = 0;\n        while(!L.empty() && *L.begin() - lz_l - r[i + 1] <= 0) {\n            high -= abs(*L.begin() - lz_l - pv) * L.size();\n            pv = *L.begin() - lz_l;\n            L.erase(L.begin());\n        }\n        high -= abs(pv - r[i + 1]) * L.size();\n        lz_l += r[i + 1], lz_r += r[i];\n    }\n    long m = L.size(), pv = 0;\n    for(long x : L) {\n        high -= abs(x - lz_l - pv) * m--;\n        pv = x - lz_l;\n    }\n    printf(\"%lld\\n\", high);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 10000000000000000;\n\nint main(){\n\tstatic int n;\n\tstatic int l[100010],r[100010];\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t}\n\tl[0] = r[0] = 0;\n\t\n\tpriority_queue<ll> L;\n\tpriority_queue<ll,vector<ll>,greater<ll>> R;\n\tll dL = 0, dR = 0;\n\tll m = 0;\n\tL.push(-INF);\n\tR.push(INF);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tdR += r[i-1]-l[i-1];\n\t\tdL -= r[i]-l[i];\n\t\tll x = L.top()+dL;\n\t\tll y = R.top()+dR;\n\t\tif(l[i] < x){\n\t\t\tL.push(l[i]-dL);\n\t\t\tL.push(l[i]-dL);\n\t\t\tL.pop();\n\t\t\tR.push(x-dR);\n\t\t\tm += x-l[i];\n\t\t}\n\t\telse if(l[i] > y){\n\t\t\tR.push(l[i]-dR);\n\t\t\tR.push(l[i]-dR);\n\t\t\tR.pop();\n\t\t\tL.push(y-dL);\n\t\t\tm += l[i]-y;\n\t\t}\n\t\telse {\n\t\t\tL.push(l[i]-dL);\n\t\t\tR.push(l[i]-dR);\n\t\t}\n\t}\n\tcout << m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <string.h>\n#include <memory.h>\n#include <stdio.h>\n#include <complex>\n#include <cstdlib>\n#include <sstream>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include<deque>\ntypedef long long ll;\nusing namespace std;\nconst int N = 400 + 1;\nint n;\nint l[N], r[N];\nll dp[N][N];\nll calc(int idx, int s) {\n\tif(idx == n)\n\t\treturn 0;\n\tll &ret = dp[idx][s];\n\tif (ret != -1)\n\t\treturn ret;\n\tint len = (r[idx] - l[idx] + 1);\n\tint e = s + (r[idx - 1] - l[idx - 1] + 1) - 1;\n\tret = 1e18;\n\tfor (int i = max(1,s-len+1); i <= e; ++i)\n\t\tret = min(ret, calc(idx + 1, i) + abs(i - l[idx]));\n\treturn ret;\n}\n\n\nint main() {\n\t//freopen(\"myfile.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(\"%d%d\", l + i, r + i);\n\tif (n == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tll ans = 1e18;\n\n\tint len = (r[0] - l[0] + 1);\n\tfor (int i = 1; i <= 400 - len; ++i)\n\t\tans = min(ans, calc(1, i) + abs(i - l[0]));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    dp[i] = abs(L[i] - i);\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto preleft = max(0, j - R[i - 1] - L[i - 1] - 1);\n      for(int k = preleft; k <= min(399, j + R[i] - L[i]); k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n#define N 100010\nll l[N], r[N];\nmultiset<ll> ls, rs;\nll lo, ro;\nll n;\n\nint main(){\n\tINIT;\n\tcin>>n;\n\trep(i, n) cin>>l[i]>>r[i];\n\tls.insert(-1e16);\n\trs.insert(1e16);\n\tll res = 0;\n\trep(i, n){\n\t\tlo -= r[i]-l[i];\n\t\tauto itl = ls.end(); --itl;\n\t\tauto itr = rs.begin();\n\t\tif(l[i]<*itl+lo){\n\t\t\tll x = *itl+lo;\n\t\t\tres += abs(l[i]-x);\n\t\t\tls.erase(itl);\n\t\t\trs.insert(x-ro);\n\t\t\tls.insert(l[i]-lo);\n\t\t\tls.insert(l[i]-lo);\n\t\t} else if(l[i]>*itr+ro){\n\t\t\tll x = *itr+ro;\n\t\t\tres += abs(l[i]-x);\n\t\t\trs.erase(itr);\n\t\t\tls.insert(x-lo);\n\t\t\trs.insert(l[i]-ro);\n\t\t\trs.insert(l[i]-ro);\n\t\t} else {\n\t\t\tls.insert(l[i]-lo);\n\t\t\trs.insert(l[i]-ro);\n\t\t}\n\t\tro += r[i]-l[i];\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n// }}}\n// pre-written code {{{\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\nconst int T = 400;\nint N;\nint l[444], r[444], d[444];\nint dp[444][444];\n\nint dist(const pair<int,int> &p, const pair<int,int> &q){\n\tint dst;\n\tif(p.second<q.first)dst = q.first-p.second;\n\telse if(q.second<p.first)dst = p.first-q.second;\n\telse dst = 0;\n//\tcout<<p.first<<\" \"<<p.second<<\",\"<<q.first<<\" \"<<q.second<<\":\"<<dst<<endl;\n\treturn dst;\n}\n\nint calc(int i,int left){\n\tif(dp[i][left]>=0)return dp[i][left];\n\tif(i==N-1){\n\t\treturn dp[i][left] = 0;\n\t}\n\tint ans = INF;\n\tfor(int left2 = 0;left2<=T;left2++){\n\t\tif(dist({left,left+d[i]},{left2,left2+d[i+1]})>0)continue;\n//\t\tint dst = dist({l[i+1],r[i+1]},{left2,left2+d[i+1]});\n\t\tint dst = abs(left2-l[i+1]);\n\t\tint result = calc(i+1,left2)+dst;\n\t\tans = min(result,ans);\n\t}\n//\tcerr<<i<<\" \"<<left<<\" \"<<ans<<endl;\n\treturn dp[i][left] = ans;\n}\n\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>l[i]>>r[i];\n\tREP(i,N)d[i]=r[i]-l[i];\n\tmemset(dp,-1,sizeof(dp));\n\tint ans = INF;\n\tfor(int left = 0;left<=T;left++){\n\t\tint result = calc(0,left)+abs(left-l[0]);//dist({l[0],r[0]},{left,left+d[0]});\n\t\tans = min(result,ans);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nint n;\nint l[410];\nint r[410];\n\nint dp[410][410];\n\nbool overwrap(int l1, int r1, int l2, int r2) {\n    if (r1 < l2) return false;\n    if (r2 < l1) return false;\n    return true;\n}\n\nconst int INF = 1e18;\n\nsigned main() {\n    while(cin >> n){\n        rep (i, n) cin >> l[i] >> r[i];\n        fill((int*)begin(dp), (int*)end(dp), INF);\n        rep (i, 401) {\n            dp[1][i] = abs(i - l[0]);\n        }\n        rep (i, n) if(i) {\n            rep (j, 401) {\n                rep (k, 401) {\n                    if (overwrap(j, j + r[i-1] - l[i-1],\n                                 k, k + r[i] - l[i])) {\n                        dp[i+1][k] = min(dp[i+1][k], dp[i][j] + abs(k - l[i]));\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        rep (i, 401) ans = min(ans, dp[n][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n#define first fi\n#define second se\n#define sz(x) (int)x.size()\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9+7;\n\nconst int N = 405;\n\nint n, dp[N][N];\n\nint main() {\n    scanf(\"%d\", &n);\n    if (n > 400) return 0;\n    int l, r;\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d%d\", &l, &r);\n        for (int j = 0; j <= 400; j++) dp[i][j] = inf;\n        for (int j = 0; j <= 400; j++) {\n            if (r < j) {\n                for (int k = 0; k <= r - l; k++)\n                    if (j - k >= 0) dp[i][j - k] = min(dp[i][j - k], dp[i - 1][j] + abs(r - j));\n                for (int k = 0; k <= r - l; k++)\n                    if (j + k <= 400) dp[i][j + k] = min(dp[i][j + k], dp[i - 1][j] + abs(r - j) + k);\n            }\n            else if (l > j) {\n                for (int k = 0; k <= r - l; k++)\n                    if (j + k <= 400) dp[i][j + k] = min(dp[i][j + k], dp[i - 1][j] + abs(l - j));\n                for (int k = 0; k <= r - l; k++)\n                if (j - k >= 0) dp[i][j - k] = min(dp[i][j - k], dp[i - 1][j] + abs(l - j) + k);\n            } else {\n                for (int k = l; k <= r; k++) dp[i][k] = min(dp[i][k], dp[i - 1][j]);\n                for (int k = 0; k <= r - j; k++) if (l - k >= 0) dp[i][l - k] = min(dp[i][l - k], dp[i - 1][j] +k);\n                for (int k = 0; k <= j - l; k++) if (r + k <= 400) dp[i][r + k] = min(dp[i][r + k], dp[i - 1][j] + k);\n            }\n        }\n    }\n    int ans = inf;\n    for (int j = 0; j <= 400; j++) ans = min(ans, dp[n][j]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[101010],R[101010];\n\nmultiset<ll> LS,RS;\nll ofl,ofr;\nll ret;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>L[i]>>R[i];\n\t\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tFOR(i,N) {\n\t\tif(i) {\n\t\t\tofl -= R[i]-L[i];\n\t\t\tofr += R[i-1]-L[i-1];\n\t\t}\n\t\n\t\tif(L[i]<*LS.rbegin()+ofl) ret+=*LS.rbegin()+ofl-L[i];\n\t\telse if(*RS.begin()+ofr<L[i]) ret+=L[i]-(*RS.begin()+ofr);\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofl) {\n\t\t\tRS.insert(*LS.rbegin()+ofl-ofr);\n\t\t\tLS.insert(L[i]-ofl);\n\t\t\tLS.insert(L[i]-ofl);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t\t\n\t\t}\n\t\telse if(*RS.begin()+ofr<L[i]) {\n\t\t\tLS.insert(*RS.begin()+ofr-ofl);\n\t\t\tRS.insert(L[i]-ofr);\n\t\t\tRS.insert(L[i]-ofr);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse {\n\t\t\tLS.insert(L[i]-ofl);\n\t\t\tRS.insert(L[i]-ofr);\n\t\t}\n\t\t\n\t\t/*\n\t\tFORR(r,LS) cout<<r+ofl<<\" \";\n\t\tcout<<\" : \";\n\t\tFORR(r,RS) cout<<r+ofr<<\" \";\n\t\tcout<<\" : \"<<\" \"<<ofl<<\" \"<<ofr<<\" \"<<ret<<endl;\n\t\t*/\n\t\t\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ninline int rd() {\n\tchar ch=getchar(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=getchar();}\n\treturn i*f; \n}\nconst int N=1e5+50;\nint n,l[N],r[N];\nLL ans,tl,tr,lq,rq;\npriority_queue < LL,vector<LL>,less<LL> > L; \npriority_queue < LL,vector<LL>,greater<LL> > R;\nint main() {\n\tn=rd();\n\tfor(int i=1;i<=n;i++) l[i]=rd(), r[i]=rd(), l[i]=r[i]-l[i];\n\tL.push(r[1]); R.push(r[1]);\n\tfor(int i=2;i<=n;i++) {\n\t\ttl-=l[i-1], tr+=l[i];\n\t\tlq=L.top()+tl; rq=R.top()+tr;\n\t\tif(r[i]>=lq&&r[i]<=rq) L.push(r[i]-tl), R.push(r[i]-tr);\n\t\telse if(r[i]>=lq) {\n\t\t\tans+=r[i]-rq; R.pop(); L.push(rq-tl);\n\t\t\tR.push(r[i]-tr); R.push(r[i]-tr);\n\t\t} else {\n\t\t\tans+=lq-r[i]; L.pop(); R.push(lq-tr);\n\t\t\tL.push(r[i]-tl); L.push(r[i]-tl);\n\t\t}\n\t} cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nint n, dp[405][405];\nstruct rectangle {\n\tint l, r;\n} r[405];\n\nbool cmp(rectangle x, rectangle y) {\n\treturn x.l < y.l;\n}\n\nint abs(int x) {\n\treturn x > 0 ? x : -x;\n}\n\nint min(int x, int y) {\n\treturn x < y ? x : y;\n}\n\nint max(int x, int y) {\n\treturn x > y ? x : y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &r[i].l, &r[i].r);\n\tstd::sort(r, r + n, cmp);\n\tfor (int i = 0; i < n; i++) for (int j = 0; j <= 400; j++) dp[i][j] = 2e9;\n\tfor (int i = 0; i <= 400; i++) dp[0][i] = abs(i - r[0].r);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = r[i].r - r[i].l; j <= 400; j++) {\n\t\t\tfor (int k = j - r[i].r + r[i].l; k <= j; k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - r[i].r));\n\t\t\t}\n//\t\t\tif (j <= 30) printf(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tint ans = 2e9;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[n - 1][i]);\n\tprintf(\"%d\\n\", ans);\n}\n\n/*\n5\n1 7\n5 9\n12 18\n16 20\n24 30\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nint n, dp[405][405];\nstruct rectangle {\n\tint l, r;\n} r[405];\n\nbool cmp(rectangle x, rectangle y) {\n\treturn x.l < y.l;\n}\n\nint abs(int x) {\n\treturn x > 0 ? x : -x;\n}\n\nint min(int x, int y) {\n\treturn x < y ? x : y;\n}\n\nint max(int x, int y) {\n\treturn x > y ? x : y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d %d\", &r[i].l, &r[i].r);\n\tstd::sort(r + 1, r + n + 1, cmp);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= 400; j++) dp[i][j] = 2e9;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = r[i].r - r[i].l; j <= 400; j++) {\n\t\t\tfor (int k = j - r[i].r + r[i].l; k <= j; k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - r[i].r));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 2e9;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[n][i]);\n\tprintf(\"%d\\n\", ans);\n}\n\n/*\n5\n1 7\n5 9\n12 18\n16 20\n24 30\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 2e5 + 5;\nconst int mod = 998244353;\nint l[maxn] , r[maxn];\nint n;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    priority_queue<ll> lo;\n    priority_queue<ll,vector<ll>,greater<ll>> hi;\n    cin >> n;\n    for(int i = 0 ; i < n ; ++i)cin >> l[i] >> r[i];\n    ll res = 0;\n    lo.push(l[0]);hi.push(r[0]);\n    ll xl = 0 , xr = 0;\n    for(int i = 1 ; i < n ; ++i){\n        xl += r[i] - l[i];\n        xr += r[i - 1] - l[i - 1];\n        ll cl = lo.top() - xl;\n        ll cr = hi.top() + xr;\n        if(cl <= l[i] && l[i] <= cr){\n            lo.push(l[i] + xl);\n            hi.push(l[i] - xr);\n        }else if(cr < l[i]){\n            res += l[i] - cr;\n            hi.pop();\n            lo.push(cr + xl);\n            hi.push(l[i] - xr);\n            hi.push(l[i] - xr);\n        }else{\n            res += cl - l[i];\n            lo.pop();\n            hi.push(cl - xr);\n            lo.push(l[i] + xl);\n            lo.push(l[i] + xl);\n        }\n    }\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\ntypedef long long ll;\n\nconst int MAX_N=400,MAX_R=400,INF=1e8;\n\nint N,L[MAX_N],R[MAX_N];\n\nint dp[MAX_N][MAX_R+1];\n\nint main(){\n\tcin>>N;\n\tREP(i,N){\n\t\tcin>>L[i]>>R[i];\n\t}\n\tREP(i,MAX_R+1){\n\t\tdp[0][i]=abs(i-L[0]);\n\t}\n\tFOR(i,1,N){\n\t\tfill(dp[i],dp[i]+MAX_R+1,INF);\n\t\tREP(j,MAX_R+1){\n\t\t\tREP(k,MAX_R+1){\n\t\t\t\tif (j+R[i]-L[i]<k || k+R[i-1]-L[i-1]<j) continue;\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+abs(j-L[i]));\n\t\t\t}\n//\t\t\tfprintf(stderr,\"dp[%d][%d]=%d\\n\",i,j,dp[i][j]);\n\t\t}\n\t}\n\tint ans=INF;\n\tREP(i,MAX_R+1){\n\t\tans=min(ans,dp[N-1][i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nconst long long INF=1e9+7;\n\nstruct ShiftMultiset{\n  std::multiset<long long> set;\n  long long delta;\n  //x in set represents x+delta\n  void insert(long long x){\n    set.insert(x-delta);\n  }\n  void shift(long long x){\n    delta+=x;\n  }\n  long long front(){\n    assert(set.size());\n    return *set.begin()+delta;\n  }\n  long long back(){\n    assert(set.size());\n    return *set.rbegin()+delta;\n  }\n  long long pop_front(){\n    assert(set.size());\n    long long x=*set.begin();\n    set.erase(set.begin());\n    return x;\n  }\n  long long pop_back(){\n    assert(set.size());\n    long long x=*set.rbegin();\n    set.erase(set.find(*set.rbegin()));\n    return x;\n  }\n}left,right;\n\nint ls[100005];\nint rs[100005];\n\nint main(){\n  int N;\n  scanf(\"%d\",&N);\n  for(int i=1;i<=N;i++){\n    scanf(\"%d %d\",&ls[i],&rs[i]);\n  }\n  long long cost=0;//cost at min\n  left.insert(0);\n  right.insert(INF);\n  for(int i=1;i<=N;i++){\n    left.shift(-(rs[i]-ls[i]));\n    right.shift((rs[i-1]-ls[i-1]));\n    if(ls[i]<left.back()){\n      cost+=std::abs(left.back()-ls[i]);\n      left.insert(ls[i]);\n      left.insert(ls[i]);\n      right.insert(left.pop_back());\n    }else if(ls[i]>right.front()){\n      cost+=std::abs(right.front()-ls[i]);\n      right.insert(ls[i]);\n      right.insert(ls[i]);\n      left.insert(right.pop_front());\n    }else{\n      left.insert(ls[i]);\n      right.insert(ls[i]);\n    }\n  }\n  printf(\"%lld\\n\",cost);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nvoid back(int m[405], int s, int f){\n    if(m[s] == 0) return;\n    m[s] = f;\n    back(m,s - 1,f);\n}\nvoid forward(int m[405], int s, int f){\n    if(m[s] == 0) return;\n    m[s] = f;\n    forward(m,s + 1,f);\n}\n\nvoid dfs(int m[405], int s, int f){\n    back(m,s,f);\n    forward(m,s + 1,f);\n}\n\nbool isLinking(int m[405]){\n    int i = 1;\n    int f = 0;\n    int num;\n    while(i < 405){\n        if(f == 0 && m[i] != 0){\n            f = 1;\n            num = m[i];\n        }\n        if(f == 1 && m[i] == 0) f = 2;\n        if(f == 1 && num != m[i]) return false;\n        if(f == 2 && m[i] != 0) return false;\n        i++;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    assert(n <= 400);\n\n    pair<int, int> p[405];\n    int m[405] = {0};\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        assert(a <= 400);\n        assert(b <= 400);\n        p[i] = make_pair(a,b);\n\n        int f = 0;\n        for(int j = a; j <= b; j++){\n            if(m[j] > f) f = m[j] + 1;\n            else if(m[j] == 0) m[j] = 1;\n        }\n        if(f) dfs(m,a,f);\n    }\n\n    int cnt = 0;\n    while(not isLinking(m)){\n        //rep(i,10) cout << m[i] << ' '; cout << endl;\n        int i = 0, ib;\n        int f = 0;\n        int num;\n        while(i < 405){\n            if(f == 0 && m[i] != 0){\n                f = 1;\n                ib = i;\n                num = m[i];\n            }\n            if(f == 1 && m[i] != num) break;\n            //if(f == 1 && m[i] == 0) break;\n            i++;\n        }\n        i--;\n        int j = 405, jb;\n        f = 0;\n        while(j >= 0){\n            if(f == 0 && m[j] != 0){\n                f = 1;\n                jb = j;\n                num = m[j];\n            }\n            if(f == 1 && m[j] != num) break;\n            //if(f == 1 && m[j] == 0) break;\n            j--;\n        }\n        j++;\n\n        //cout << i << ' ' << j << endl;\n        if(m[i] > m[j]){\n            cnt += m[j];\n            if(m[j - 1] != 0){\n                m[j - 1] += m[j];\n                m[jb] = 0;\n                dfs(m,j - 1,m[j - 1]);\n            }else{\n                m[j - 1] = m[j];\n                m[jb] = 0;\n            }\n        }else{\n            cnt += m[i];\n            if(m[i + 1] != 0){\n                m[i + 1] += m[i];\n                m[ib] = 0;\n                dfs(m,i + 1,m[i + 1]);\n            }else{\n                m[i + 1] = m[i];\n                m[ib] = 0;\n            }\n        }\n        //rep(i,10) cout << m[i] << ' '; cout << endl;\n\n    }\n    cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <string>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n#define FORD(i, a, b) for (int i = (a), _b = (b); i >= _b; --i)\n#define REP(i, a) for (int i = 0, _a = (a); i < _a; ++i)\n#define REPD(i,n) for(int i = (n)-1; i >= 0; --i)\n\n#define DEBUG(X) { cerr << #X << \" = \" << (X) << endl; }\n#define PR(A, n) { cerr << #A << \" = \"; FOR(_, 1, n) cerr << A[_] << ' '; cerr << endl; }\n#define PR0(A, n) { cerr << #A << \" = \"; REP(_, n) cerr << A[_] << ' '; cerr << endl; }\n\n#define sqr(x) ((x) * (x))\n#define ll long long\n#define double long double\ntypedef pair<int, int> II;\n#define PI (2 * acos((double)0))\n#define __builtin_popcount __builtin_popcountll\n#define SZ(x) ((int)(x).size())\n#define ALL(a) (a).begin(), (a).end()\n#define MS(a,x) memset(a, x, sizeof(a))\n#define next ackjalscjaowjico\n#define prev ajcsoua0wucckjsl\n#define y1 alkscj9u20cjeijc\n#define left lajcljascjljl\n#define right aucouasocjolkjl\n#define y0 u9cqu3jioajc\n\n#define TWO(X) (1LL<<(X))\n#define CONTAIN(S,X) ((S) & TWO(X))\n\ndouble safe_sqrt(double x) { return sqrt(max((double)0.0, x)); }\nint GI(int& x) { return scanf(\"%lld\", &x); }\n\nconst int MN = 444;\nint n;\npair<int,int> a[MN];\nint f[MN][MN];\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << (fixed) << setprecision(9);\n    while (cin >> n) {\n        FOR(i,1,n) cin >> a[i].first >> a[i].second;\n\n        FOR(i,1,n) {\n            FOR(pos,1,400) f[i][pos] = 1000111000111000111LL;\n\n            int len = a[i].second - a[i].first;\n            FOR(left,1,400) {\n                int dist = llabs(a[i].first - left);\n\n                int prev = f[i-1][left];\n                FOR(pos,left+1,left+len) prev = min(prev, f[i-1][pos]);\n\n                FOR(pos,left,left+len) f[i][pos] = min(f[i][pos], prev + dist);\n            }\n        }\n\n        int res = f[n][1];\n        FOR(i,1,400) res = min(res, f[n][i]);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, Left[100009], Right[100009], sz[100009];\nmultiset < long long > L, R;\nlong long leftDeflection, rightDeflection, ans = 0;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &Left[i], &Right[i]), sz[i] = Right[i] - Left[i];\nL.insert (Left[1]), leftDeflection = 0;\nR.insert (Left[1]), rightDeflection = 0;\nfor (int i=2; i<=N; i++)\n{\n    int A = sz[i - 1], B = sz[i];\n    ///f(x) = min (f(x - A), ..., f(x + B)\n    leftDeflection += B, rightDeflection += A;\n    long long x = Left[i], st = (*L.rbegin ()) - leftDeflection, dr = (*R.begin ()) + rightDeflection;\n    if (st <= x && x <= dr)\n    {\n        L.insert (x + leftDeflection);\n        R.insert (x - rightDeflection);\n        continue;\n    }\n    if (x < st)\n    {\n        ans += st - x;\n        auto it = L.end (); it --;\n        L.erase (it);\n\n        L.insert (x + leftDeflection);\n        L.insert (x + leftDeflection);\n        R.insert (st - rightDeflection);\n        continue;\n    }\n    ans += x - dr;\n    R.erase (R.begin ());\n\n    L.insert (dr + leftDeflection);\n    R.insert (x - rightDeflection);\n    R.insert (x - rightDeflection);\n}\nprintf (\"%lld\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define ll long long\n//#define int long long \n\nusing namespace std ;\n\nconst int MAXN = 605 ; \n\nint l[MAXN] , r[MAXN] ;\n\nint dp[MAXN][MAXN] ; \n\nint32_t main()\n{\n\tios::sync_with_stdio(0) ; cin.tie(0) ; \n\tint n ; \n\tcin >> n ; \n\tfor(int i = 0 ; i < n ; i ++ )\n\t{\n\t\tcin >> l[i] >> r[i] ;\n\t\tr[i] ++ ; \n\t   \tl[i] += 190 , r[i] += 190  ; \n\t\n\t}\n\tfor(int i = 0 ; i < MAXN ; i ++ ) \n\t\tdp[0][i] = abs(l[0]-i) ; \n\tfor(int i = 1 ; i < n ; i ++ ) for(int j = 0 ; j < MAXN ; j ++ ) \n\t{\n\t\tdp[i][j] = 2e9 ;\n\t\tfor(int k = 0 ; k < MAXN ; k ++ )\n\t\t{\n\t\t\tint s = k , e = r[i-1] - l[i-1] + k ;\n\t\t    int S = j , E = r[i] - l[i] + j ;\n\t\t\tif(e<=S||E<=s)\n\t\t\t\tcontinue ; \n\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][k]) ; \t\n\t\t}\n\t\tdp[i][j] += abs(l[i]-j);\n\t}\n//\tcout << dp[2][1] << endl ; \n\tint ans = 2e9 ; \n\tfor(int i = 0 ; i < MAXN ; i ++ )\n\t{\n\t\tans = min(ans,dp[n-1][i]) ; \n\t}\n\tcout << ans << '\\n' ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nmultiset<ll> sl,sr;\nll ans,tl,tr,i,j,k,n,a[200001],b[200001];;\nll av(ll x){\n\treturn (x>=0)?x:-x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i],&b[i]);\n\tsl.clear();sr.clear();sl.insert(a[1]);sr.insert(a[1]);\n\tfor (i=2,ans=tl=tr=0;i<=n;i++){\n\t\ttl+=b[i]-a[i];tr+=b[i-1]-a[i-1];j=*sl.rbegin();k=*sr.begin();\n\t\tif (j-tl>a[i]){\n\t\t\tans+=av(j-tl-a[i]);\n\t\t\tsl.erase(sl.find(j));sl.insert(a[i]+tl);sr.insert(j-tl-tr);\n\t\t}else if (a[i]>k+tr){\n\t\t\tans+=av(k+tl-a[i]);\n\t\t\tsr.erase(sr.find(k));sr.insert(a[i]-tr);sl.insert(k+tr+tl);\n\t\t}else{\n\t\t\tsl.insert(a[i]+tl);sr.insert(a[i]-tr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\nusing namespace std;\n \n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\ntypedef long long ll;\n//////////////////////\n \nint const N = 441;\n \nvector<ll> lp, rp;\nint l[N], r[N], n;\n \nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n) cin >> l[i] >> r[i];\n\tll ans = 0;\n \n\tlp.pb(l[0]);\n\trp.pb(l[0]);\n\trep(i, 1, n){\n\t\tll pl = r[i-1] - l[i-1];\n\t\tll cl = r[i] - l[i];\n\t\trep(j, 0, sz(rp)) rp[j] += pl;\n\t\trep(j, 0, sz(lp)) lp[j] -= cl;\n\t\tsort(rp.begin(), rp.end());\n\t\tsort(lp.begin(), lp.end());\n\t\tif(l[i] >= lp.back() && l[i] <= rp[0]){\n\t\t\tlp.pb(l[i]);\n\t\t\trp.pb(l[i]);\n\t\t}else if(l[i] >= rp[0]){\n\t\t\tans += (l[i] - rp[0]);\n\t\t\tll tmp = rp[0];\n\t\t\tlp.pb(tmp);\n\t\t\trp.erase(rp.begin());\n\t\t\trp.pb(l[i]);\n\t\t\trp.pb(l[i]);\n\t\t}else{\n\t\t\tans += (lp.back() - l[i]);\n\t\t\tll tmp = lp.back();\n\t\t\tlp.erase(lp.begin() + sz(lp) - 1);\n\t\t\trp.pb(tmp);\n\t\t\tlp.pb(l[i]);\n\t\t\tlp.pb(l[i]);\n\t\t}\n\t\tint asd = 1;\n\t}\n \n\tcout << ans << endl;\n}\n \nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n \n\tsolve();\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=1050;\n//ここまでテンプレ\nint main(){\n\t//DP[i][j]=i番目の机の左端を座標jに入れたときの最小のコスト\n\tll DP[450][SIZE]={};\n\tint N;\n\tcin>>N;\n\tvll L,R;\n\tfor(int i=0;i<N;i++){\n\t\tll l,r;\n\t\tcin>>l>>r;\n\t\tL.pb(l);\n\t\tR.pb(r);\n\t}\n\tfor(int i=0;i<=SIZE;i++){\n\t\tDP[0][i]=abs(i-L[0]);\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<450;j++){\n\t\t\tll mini=INFLL;\n\t\t\tll PW=R[i-1]-L[i-1];\n\t\t\tll NW=R[i]-L[i];\n\t\t\tfor(int k=max(j-PW,0LL);k<=j+NW;k++)\n\t\t\t\tmini=min(mini,DP[i-1][k]);\n\t\t\tDP[i][j]+=abs(j-L[i])+mini;\n\t\t}\n\t}\n\tll ans=INFLL;\n\tfor(int i=0;i<450;i++)\n\t\tans=min(ans,DP[N-1][i]);\n\tcout<<ans<<endl;\n\t\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<10;j++)\n\t\t\tcout<<DP[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    dp[i] = abs(L[0] - i);\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto preleft = max(0, j - (R[i - 1] - L[i - 1]) - 1);\n      for(int k = preleft; k < min(400, j + R[i] - L[i] + 1); k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nmultiset<ll> sl,sr;\nll ans,tl,tr,i,j,k,n,a[200001],b[200001];;\nll av(ll x){\n\treturn (x>=0)?x:-x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i],&b[i]);\n\tsl.clear();sr.clear();sl.insert(a[1]);sr.insert(a[1]);\n\tfor (i=2,ans=tl=tr=0;i<=n;i++){\n\t\ttl+=b[i]-a[i];tr+=b[i-1]-a[i-1];j=*sl.rbegin();k=*sr.begin();\n\t\tif (j-tl>a[i]){\n\t\t\tans+=av(j-tl-a[i]);\n\t\t\tsl.erase(sl.find(j));sl.insert(a[i]+tl);sl.insert(a[i]+tl);sr.insert(j-tl-tr);\n\t\t}else if (a[i]>k+tr){\n\t\t\tans+=av(k+tl-a[i]);\n\t\t\tsr.erase(sr.find(k));sr.insert(a[i]-tr);sr.insert(a[i]-tr);sl.insert(k+tr+tl);\n\t\t}else{\n\t\t\tsl.insert(a[i]+tl);sr.insert(a[i]-tr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> P;\npriority_queue <ll,vector <ll>,greater <ll> > Q;\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint main() {\n    int n;\n    ll A=0,B=0,ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n\tint l=gi(),r=gi();\n\tB+=r-l;\n\tP.push(r-A),Q.push(r-B);\n\twhile(P.size()&&P.top()+A>Q.top()+B)\n\t    ans+=P.top()+A-Q.top()-B,P.pop(),Q.pop();\n\tA-=r-l;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_overlap(int l1, int r1, int l2, int r2)\n{\n  return r1 >= l2 and r2 >= l1;\n}\n\nlong adjust(int l1, int r1, int& l2, int& r2)\n{\n  if (is_overlap(l1, r1, l2, r2)) return 0;\n  if (l2 > r1) {\n    int diff = l2 - r1;\n    l2 -= diff;\n    r2 -= diff;\n    return diff;\n  } else {\n    int diff = l1 - r2;\n    l2 += diff;\n    r2 += diff;\n    return diff;\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<int> ls(N), rs(N);\n  vector<int> ns;\n  ns.reserve(2*N);\n  for (int i = 0; i < N; ++i) {\n    int l, r;\n    cin >> l >> r;\n    ls[i] = l;\n    rs[i] = r;\n    ns.push_back(r);\n    ns.push_back(l);\n  }\n  sort(ns.begin(), ns.end());\n  int center = ns[N];\n\n  int start = -1;\n  for (int i = 0; i < N; ++i) {\n    if (rs[i] == center or ls[i] == center) {\n      start = i;\n      break;\n    }\n  }\n\n  // cerr << center << \", \" << start << endl;\n\n  long moves = 0;\n  for (int i = start + 1; i < N; ++i) {\n    moves += adjust(ls[i-1], rs[i-1], ls[i], rs[i]);\n    // cerr << \"moves: \" << moves << endl;\n  }\n  for (int i = start - 1; i >= 0; --i) {\n    moves += adjust(ls[i+1], rs[i+1], ls[i], rs[i]);\n    // cerr << \"moves: \" << moves << endl;\n  }\n\n  cout << moves << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n;\n  R n;\n  P a[n];\n  rep(i,n) cin >> a[i].F >> a[i].S;\n  sort(a,a+n);\n  ll ans=MAX;\n  rep(t,401) {\n    ll x=a[0].S+t,y=a[0].F+t,sum=t;\n    REP(i,1,n) {\n      if(x<a[i].F) {\n        sum+=a[i].F-x;\n        x+=a[i].S-a[i].F;\n      } else if(a[i].S<y) {\n        sum+=y-a[i].S;\n        y-=a[i].S-a[i].F;\n      } else if(y<=a[i].F) x=max(x,(ll)a[i].S);\n      else y=min(y,(ll)a[i].F);\n    }\n    ans=min(ans,sum);\n  }\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MN = 100010;\n\nint N;\nll L[MN], R[MN], D[MN];\nmultiset<ll> le, ri;\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lld %lld\", &L[i], &R[i]);\n        D[i] = R[i] - L[i];\n    }\n\n    le.insert(R[0]);\n    ri.insert(R[0]);\n    ll loffset = 0;\n    ll roffset = 0;\n    ll ans = 0;\n\n    for(int i = 1; i < N; i++) {\n        loffset -= D[i - 1];\n        roffset += D[i];\n\n        ll l = *le.rbegin() + loffset;\n        ll r = *ri.begin() + roffset;\n\n        if(r < R[i]) {\n            ri.erase(ri.find(r - roffset));\n            le.insert(r - loffset);\n            ri.insert(R[i] - roffset);\n            ans += R[i] - r;\n        }\n        else if(R[i] < l) {\n            le.erase(le.find(l - loffset));\n            ri.insert(l - roffset);\n            le.insert(R[i] - loffset);\n            ans += l - R[i];\n        }\n        else {\n            le.insert(R[i] - loffset);\n            ri.insert(R[i] - roffset);\n        }\n    }\n\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <chrono> //1e+9で割る auto end= chrono::system_clock::now()-st;  cout<<end.count()%1e+9<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef long double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll N;\nll l[400],r[400];\nll dp[400][401];//i番目　j最小\nll deq[400];\nll lef,rig;\nconst ll INF=0xffffffffff;\n\nint main()\n{\n\tcin>>N;\n\tif(N>400) return 0;\n\trep(i,N){\n\t\tcin>>l[i]>>r[i];\n\t}\n\tll cnt=0;\n\trep(i,401){\n\t\tdp[0][i]=abs(l[0]-i);\n\t}\n\t\n\tfor(ll i=1;i<N;i++){\n\t\tll s=0,t=0;\n\t\tlef=r[i-1]-l[i-1];\n\t\trig=r[i]-l[i];\n\t\trep(j,lef){\n\t\t\twhile(j<=400 && s<t && dp[i-1][deq[t-1]] >= dp[i-1][j]) t--;\n\t\t\tdeq[t++]=j;\n\t\t}\n\t\tfor(ll j=0;j<=400;j++){\n\t\t\twhile(j+rig<=400 && s<t && dp[i-1][deq[t-1]] >= dp[i-1][j+rig]) t--;\n\t\t\tdeq[t++]=j+rig;\n\t\t\t\n\t\t\tdp[i][j] = abs(j-l[i])+dp[i-1][deq[s]];\n\t\t\t\n\t\t\tif(j-lef>=0&&deq[s]==j-lef){\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\trep(i,401){\n\t\tans=min(ans,dp[N-1][i]);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n),len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0];\n\tint lec = 1, ric = 1;\n\tll my = 0;\n\trep1(i, n - 1) {\n\t\tif (r[i] < ml) {\n\t\t\tmy += ml - r[i];\n\t\t\tif (lec == 1) {\n\t\t\t\tmr = ml;\n\t\t\t\tml = l[i];\n\t\t\t\tlec = 2, ric = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmr = ml;\n\t\t\t\tlec=ric = 1;\n\t\t\t}\n\t\t}\n\t\telse if (l[i] > mr+len[i-1]) {\n\t\t\tmy += l[i] - mr - len[i - 1];\n\t\t\tif (ric == 1) {\n\t\t\t\tml = mr; mr = l[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tml = mr;\n\t\t\t\tlec = ric = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tml = mr = l[i]; lec = ric = 1;\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug==\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<60;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-12;};\ntemplate<> inline long double EPS<long double>(){return 1e-12;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> inline T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> inline T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tvector<pair<int,int>> rs(N); cin >> rs;\n\t\tsort(ALL(rs));\n\n\t\tvector<vector<ll>> dp(N+1,vector<ll>(501,INF<ll>()));\n\t\tfor(int r:range(500)){\n\t\t\tdp[0][r] = abs(rs[0].second - r);\n\t\t}\n\n\t\tfor(int i:range(1,N)){\n\t\t\tfor(int rp:range(500)){\n\t\t\t\tfor(int r:range(500)){\n\t\t\t\t\tint lp = rp-(rs[i-1].second-rs[i-1].first), l = r-(rs[i].second-rs[i].first);\n\t\t\t\t\tif(lp <= l && l <= rp){\n\t\t\t\t\t\tdp[i][r] =  min(dp[i][r],dp[i-1][rp] + abs(rs[i].second - r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll res = INF<ll>();\n\t\tfor(int r:range(500)) res = min(res,dp[N-1][r]);\n\n\t\tcout << res << endl;\n\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 999999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\nint maxpos=-1 , minpos=MAXN;\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\tminpos = min( minpos , l[i] );\n\t\tmaxpos = max( maxpos , l[i]+len[i] );\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = minpos;i <= maxpos;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(r[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    Int x=r[i]-l[i];\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(r[i]<dL+*latte){\n      dL-=x;\n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      dR+=x;\n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n \nstatic int getMinCost(multiset<int> &leftNodes,\n\t\t      multiset<int> &rightNodes,\n\t\t      int curmincost,\n\t\t      int minpos,\n\t\t      int loff,\n\t\t      int roff)\n{\n    if (leftNodes.size() == 0) {\n\treturn curmincost;\n    }\n\n    auto ilmax = leftNodes.end();\n    ilmax--;\n    int lmax = *ilmax - loff;\n    auto irmin = rightNodes.begin();\n    int rmin = *irmin + roff;\n    \n    if (lmax <= minpos) {\n\tif (minpos <= rmin) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - rmin + curmincost;\n    } else {\n\treturn lmax - minpos + curmincost;\n    }\n}\n \nint main(void){\n    int n;\n    int mincost;\n    multiset<int> leftNodes;\n    multiset<int> rightNodes;\n    stringstream st;\n    string line;\n      \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n    \n    int nl, nr;\n    int l, r;\n    int loff, roff;\n    loff = 0;\n    roff = 0;    \n    mincost = 0;    \n    for (int i = 0; i < n; i++) {\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> nl >> nr;\n\tif (i >= 1) {\n\t    \n\t    mincost = getMinCost(leftNodes, rightNodes, mincost, l, loff, roff);\n\n\t    if (leftNodes.size() == 0) {\n\t\tleftNodes.insert(l);\n\t\trightNodes.insert(l);\n\t    } else {\n\t\tauto ilmax = leftNodes.end();\n\t\tilmax--;\n\t\tint lmax = *ilmax - loff;\n\t\tif (lmax <= l) {\n\t\t    auto irmin = rightNodes.begin();\n\t\t    int rmin = *irmin + roff;\n\t\t    if (l <= rmin) {\n\t\t\tleftNodes.insert(l + loff);\n\t\t\trightNodes.insert(l - roff);\n\t\t    } else {\n\t\t\trightNodes.insert(l - roff);\n\t\t\trightNodes.insert(l - roff);\n\n\t\t\tleftNodes.insert(rmin + loff);\n\t\t\trightNodes.erase(irmin);\n\t\t    }\n\t\t} else {\n\t\t    leftNodes.insert(l + loff);\n\t\t    leftNodes.insert(l + loff);\n\n\t\t    rightNodes.insert(lmax - roff);\n\t\t    leftNodes.erase(ilmax);\n\t\t}\n\t    }\n\t    roff += r - l;\n\t    loff += nr - nl;\n\n#if 0\n\t    for (auto e : leftNodes) {\n\t\tcout << e - loff << \" \";\n\t    }\n\t    for (auto e : rightNodes) {\n\t\tcout << e + roff << \" \";\n\t    }\t    \n\t    cout << endl;\n#endif\t\n\t}\n\tl = nl;\n\tr = nr;\n    }\n \n    mincost = getMinCost(leftNodes, rightNodes, mincost, l, loff, roff);\n \n    cout << mincost << endl;\n    return 0;\n \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint n;\nP A[N];\nvoid Min(ll &a,ll b){a=min(a,b);}\n\n\nmap<P,ll>MD[N],MU[N];\nll calcU(int pos,ll L,ll R){\n  if(pos==-1) return 0;\n  if(MU[pos].count(P(L,R)))return MU[pos][P(L,R)];\n  ll l = A[pos].first, r = A[pos].second;\n  ll a = 1LL<<50;\n  if(!(r<L||R<l)) a = calcU(pos-1,l,r);\n  ll b = abs(R-l)+calcU(pos-1,R,R+(r-l));\n  ll c = abs(L-r)+calcU(pos-1,L-(r-l),L);\n  ll d = abs(L-l)+calcU(pos-1,L,L+(r-l));\n  ll e = abs(R-r)+calcU(pos-1,R-(r-l),R);\n  return MU[pos][P(L,R)]=min(a,min(b,min(c,min(d,e))));\n}\n\nll calcD(int pos,ll L,ll R){\n  if(pos==n) return 0;\n  if(MD[pos].count(P(L,R)))return MD[pos][P(L,R)];\n  ll l = A[pos].first,r = A[pos].second;\n  ll a = 1LL<<50;\n  if(!(r<L||R<l)) a = calcD(pos+1,l,r);\n  ll b = abs(R-l)+calcD(pos+1,R,R+(r-l));\n  ll c = abs(L-r)+calcD(pos+1,L-(r-l),L);\n  ll d = abs(L-l)+calcD(pos+1,L,L+(r-l));\n  ll e = abs(R-r)+calcD(pos+1,R-(r-l),R);\n  return MD[pos][P(L,R)]=min(a,min(b,min(c,min(d,e))));\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].first>>A[i].second;\n  assert(n<500);\n  ll ans=1LL<<50;\n  for(int i=0;i<n;i++) {\n    int L = A[i].first;\n    int R = A[i].second;\n    ans=min(ans,calcU(i-1,L,R)+calcD(i+1,L,R));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\n#include <random>\n#include <ctime>\n#include <functional>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nmt19937 mt_rand(time(NULL));\nstruct Treap {\n  int k, p, cnt, lazy;\n  Treap *ch[2];\n  Treap(int k) : k(k), p(mt_rand()), cnt(1), lazy(0) {\n    ch[0] = ch[1] = NULL;\n  }\n};\ninline int count(Treap *t) { return t == NULL ? 0 : t->cnt; }\ninline void setLazy(Treap *t, int v) {\n  if (t == NULL) return;\n  t->lazy += v;\n  t->k += v;\n}\ninline void push(Treap *t) {\n  if (t == NULL || t->lazy == 0) return;\n  setLazy(t->ch[0], t->lazy);\n  setLazy(t->ch[1], t->lazy);\n  t->lazy = 0;\n}\ninline Treap* update(Treap *t) {\n  if (t == NULL) return t;\n  push(t);\n  t->cnt = 1 + count(t->ch[0]) + count(t->ch[1]);\n  return t;\n}\nTreap *merge(Treap *l, Treap *r) {\n  if (l == NULL) return r;\n  if (r == NULL) return l;\n  if (l->p > r->p) {\n    push(l);\n    l->ch[1] = merge(l->ch[1], r);\n    return update(l);\n  }\n  else {\n    push(r);\n    r->ch[0] = merge(l, r->ch[0]);\n    return update(r);\n  }\n}\npair<Treap*, Treap*> split_by_cnt(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (k <= count(t->ch[0])) {\n    auto s = split_by_cnt(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n  else {\n    auto s = split_by_cnt(t->ch[1], k-1-count(t->ch[0]));\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n}\npair<Treap*, Treap*> split_by_key(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (t->k < k) {\n    auto s = split_by_key(t->ch[1], k);\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n  else {\n    auto s = split_by_key(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n}\n\nint find(Treap *t, int k) {\n  if (t == NULL) return INF;\n  push(t);\n  if (k < count(t->ch[0])) return find(t->ch[0], k);\n  else if (k == count(t->ch[0])) return t->k;\n  else return find(t->ch[1], k-1-count(t->ch[0]));\n}\nTreap *insert(Treap *t, int k) {\n  auto s = split_by_key(t, k);\n  return merge(merge(s._1, new Treap(k)), s._2);\n}\nvoid add_key(Treap *t, int v) { setLazy(t, v); }\n\nvoid for_each(Treap *t, function<void(int)> f) {\n  if (t == NULL) return;\n  push(t);\n  for_each(t->ch[0], f);\n  f(t->k);\n  for_each(t->ch[1], f);\n}\n\nint N;\nint L[100000], R[100000];\nTreap *S;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> L[i] >> R[i];\n  long long C = 0;\n  S = insert(S, L[0]);\n  S = insert(S, L[0]);\n  rep(i, N-1) {\n    int len = R[i+1]-L[i+1] + R[i]-L[i];\n    int shift = R[i]-L[i];\n    auto s = split_by_cnt(S, ((S->cnt-1)/2)+1);\n    add_key(s._1, -len);\n    C -= 1LL*count(s._1)*len;\n    S = merge(s._1, s._2);\n    add_key(S, shift);\n    S = insert(S, L[i+1]);\n    S = insert(S, L[i+1]);\n    int center = find(S, (S->cnt-1)/2);\n  }\n  //for_each(S, [&](int x) { cout<<x<<\",\"; });cout<<\"\\n\";\n  int center = find(S, (S->cnt-1)/2);\n  long long s = C;\n  for_each(S, [&](int x) { s += abs(x-center); });\n  cout << s/2 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\npriority_queue <ll> pqlo;\npriority_queue <ll, vector<ll>, greater<ll> > pqup;\n\nll N, l, r, lazylo, lazyhi, ans;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> l >> r;\n\t\tif (i == 1) {\n\t\t\tpqup.push(l);\n\t\t\tpqlo.push(l);\n\t\t\tlazyhi += r-l;\n\t\t\tcontinue;\n\t\t}\n\t\t\n//\t\tll panjang = r-l;\n\t\tlazylo -= r-l;\n\t\t\n\t\tif (l <= pqlo.top()+lazylo) {\n\t\t\tll geser = pqlo.top()+lazylo;\n\t\t\tans += geser-l;\n\t\t\tpqlo.push(l-lazylo);\n\t\t\tpqlo.push(l-lazylo);\n\t\t\tpqlo.pop();\n\t\t\tpqup.push(geser-lazyhi);\n\t\t} else if (l >= pqup.top()+lazyhi) {\n\t\t\tll geser = pqup.top()+lazyhi;\n\t\t\tans += l-geser;\n\t\t\tpqup.push(l-lazyhi);\n\t\t\tpqup.push(l-lazyhi);\n\t\t\tpqup.pop();\n\t\t\tpqlo.push(geser-lazylo);\n\t\t} else {\n\t\t\tpqlo.push(l-lazylo);\n\t\t\tpqup.push(l-lazyhi);\n\t\t}\n\t\tlazyhi += r-l;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct interval\n{\n\tlong long l,r;\n}a[200000];\nlong long n;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%lld%lld\",&a[i].l,&a[i].r);\n\tlong long ans=1ll<<62;\n\tfor(int i=0;i<=400;i++)\n\t{\n\t\tlong long cost=0;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(i<a[j].l)cost+=a[j].l-i;\n\t\t\telse if(i>a[j].r)cost+=i-a[j].r;\n\t\tans=min(ans,cost);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e16)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\tint n;cin>>n;\n\tllint ans=0;\n\t//「中心」を考えるためにいろいろします\n\tllint sl,sr;cin>>sl>>sr;\n\tllint schu=sl+sr;\n\tllint maes=sr-sl;\n\tmultiset<llint> hd;\n\tmultiset<llint> mg;\n\tllint hos=0;\n\thd.ins(schu);mg.ins(schu);\n\tfor(int i=1;i<n;i++){\n\t\tllint l,r;cin>>l>>r;\n\t\tllint chu=l+r;\n\t\tllint han=maes+r-l;\n\t\tmaes=r-l;\n\t\tif((*mg.begin()+hos)<chu-han){\n\t\t\tans+=chu-han-(*mg.begin()+hos);\n\t\t\tllint it=(*mg.begin())+hos;\n\t\t\tmg.era(mg.begin());\n\t\t\thd.ins(it+hos+han+han);\n\t\t\thos+=han;\n\t\t\tmg.ins(chu-hos);\n\t\t\tmg.ins(chu-hos);\n\t\t}else if((*hd.rbegin()-hos)>chu+han){\n\t\t\tans+=(*hd.rbegin()-hos)-chu-han;\n\t\t\tllint it=(*hd.rbegin())-hos;\n\t\t\thd.era(prev(hd.end()));\n\t\t\tmg.ins(it-hos-han-han);\n\t\t\thos+=han;\n\t\t\thd.ins(chu+hos);\n\t\t\thd.ins(chu+hos);\n\t\t}else{\n\t\t\thos+=han;\n\t\t\thd.ins(chu+hos);\n\t\t\tmg.ins(chu-hos);\n\t\t}\n\t\t\n\t\t\n\t}\n\tcout<<ans/2<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 1.1e5;\nint N;\nll L[MAXN], R[MAXN];\n\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\n\tll cost = 0;\n\n\tll lo_shift = 0;\n\tpriority_queue<ll> lo;\n\tll hi_shift = 0;\n\tpriority_queue<ll, vector<ll>, greater<ll>> hi;\n\tlo.push(L[0] - lo_shift);\n\thi.push(L[0] - hi_shift);\n\n\tfor (int i = 1; i < N; i++) {\n\t\tlo_shift -= (R[i] - L[i]);\n\t\thi_shift += (R[i-1] - L[i-1]);\n\n\t\tll vlo = lo.top() + lo_shift;\n\t\tll vhi = hi.top() + hi_shift;\n\t\tif(vlo <= L[i] && L[i] <= vhi) {\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t} else if (vhi < L[i]) {\n\t\t\tcost += L[i] - vhi;\n\t\t\thi.pop();\n\t\t\tlo.push(vhi - lo_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t} else if (L[i] < vlo) {\n\t\t\tcost += vlo - L[i];\n\t\t\tlo.pop();\n\t\t\thi.push(vlo - hi_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t} else assert(false);\n\t}\n\n\tcout << cost << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing namespace std::chrono;\n\nconst int LIM = 20;\nconst int INF = 1e+9;\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  assert(n <= 400);\n  vector<int> ans(LIM, INF), buf(LIM, INF);\n  vector<pair<int, int>> coords(n);\n  for (int i = 0; i < n; ++i)\n    cin >> coords[i].first >> coords[i].second;\n\n  for (int pl = 0, pr = coords[0].second - coords[0].first + 1; pr < LIM; ++pl, ++pr) {\n    ans[pl] = abs(pl - coords[0].first);\n  }\n  for (int i = 0; i < LIM; ++i)\n    cerr << ans[i] << ' ';\n  cerr << endl;\n\n  for (int i = 1; i < n; ++i) {\n    int l = coords[i].first, r = coords[i].second;\n    int _l = coords[i - 1].first, _r = coords[i - 1].second, _len = _r - _l + 1;\n\n    buf.assign(LIM, INF);\n    for (int pl = 0, pr = r - l + 1; pr < LIM; ++pl, ++pr) {\n      int cost = abs(l - pl);\n      int _min = INF;\n      for (int p = max(pl - _len + 1, 0); p <= pr; ++p)\n        _min = min(_min, ans[p]);\n      cost += _min;\n\n      buf[pl] = cost;\n    }\n\n    swap(buf, ans);\n\n    for (int j = 0; j < LIM; ++j)\n      cerr << ans[j] << ' ';\n    cerr << endl;\n  }\n\n  int res = ans[0];\n  for (int i = 0; i < LIM; ++i)\n    res = min(res, ans[i]);\n  cout << res << endl;\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n#define ep emplace_back\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);++i)\nconstexpr int mod=1000000007;\nconstexpr int mod1=998244353;\nvector<int> dx={0,1,0,-1},dy={-1,0,1,0};\nbool inside(int y,int x,int h,int w){\n\tif(y<h && y>=0 && x<w && x>=0) return true;\n\treturn false;\n}\n\n\n\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;cin >> n;\n\tif(n > 400) return 0;\n\tvector<int> l(n),r(n);\n\trep(i,n) cin >> l.at(i) >> r.at(i);\n\tll ans = 1e18;\n\tfor(int j = 0; j <= 400; j++){\n\t\tll sum = 0;\n\t\trep(i,n){\n\t\t\tif(l.at(i) <= j && r.at(i) >= j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(l.at(i) > j){\n\t\t\t\tsum += l.at(i) - j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += j - r.at(i);\n\t\t\t}\n\t\t}\n\t\tans = min(ans, sum);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define N ((ll)450)\n\nll n,l[N],r[N],dp[N][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>l[i]>>r[i];\n\tfor(int i=0;i<N;i++)dp[0][i]=abs(l[0]-i);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tdp[i][j]=(ll)2e9;\n\t\t\tfor(int k=max(0,j-(r[i-1]-l[i-1]));k<=min(j+(r[i]-l[i]),N-1);k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]);\n\t\t\tdp[i][j]+=abs(l[i]-j);\n\t\t}\n\tll ans=dp[n-1][0];\n\tfor(int i=1;i<N;i++)\n\t\tif(dp[n-1][i]<ans)\n\t\t\tans=dp[n-1][i];\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <string.h>\n#include <memory.h>\n#include <stdio.h>\n#include <complex>\n#include <cstdlib>\n#include <sstream>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include<deque>\ntypedef long long ll;\nusing namespace std;\nconst int N = 1000 ;\nint n;\nint l[N], r[N];\nll dp[N][N];\nll calc(int idx, int s) {\n\tif(idx == n)\n\t\treturn 0;\n\tll &ret = dp[idx][s];\n\tif (ret != -1)\n\t\treturn ret;\n\tint len = (r[idx] - l[idx] + 1);\n\tint e = min(400 - len, s + (r[idx - 1] - l[idx - 1])-1);\n\tret = 1e15;\n\tfor (int i = max(1,s-len+1); i <= e; ++i)\n\t\tret = min(ret, calc(idx + 1, i) + abs(i - l[idx]));\n\treturn ret;\n}\n\n\nint main() {\n\t//freopen(\"myfile.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(\"%d%d\", l + i, r + i);\n\tif (n == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tll ans = 1e15;\n\n\tint len = (r[0] - l[0] + 1);\n\tfor (int i = 1; i <= 400-len; ++i)\n\t\tans = min(ans, calc(1, i) + abs(i - l[0]));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tll l, r, len;\n\tll pbl = 0, pbr = 0, ans = 0;\n\tpriority_queue<ll> ql;\n\tpriority_queue<ll, vector<ll>, greater<ll>> qr;\n\t\n\twhile (n--) {\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\n\t\tql.push(r - pbl);\n\t\tqr.push(r - pbr);\n\n\t\twhile ((L = ql.top() + pbl) > (R = pbr + qr.top())) {\n\t\t\tans += L - R;\n\n\t\t\tql.pop();\n\t\t\tqr.pop();\n\n\t\t\tql.push(R - pbl);\n\t\t\tqr.push(L - pbr);\n\t\t}\n\n\t\tpbl -= len;\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAXN=1e5+10;\nint n,l[MAXN],r[MAXN];\nll ls,rs,res=0;\npriority_queue<int> L;\npriority_queue<int,vector<int>,greater<int> > R;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&l[i],&r[i]);\n    L.push(l[1]);R.push(r[1]);\n    for(int i=2;i<=n;i++)\n    {\n        ls-=r[i]-l[i];rs+=r[i-1]-l[i-1];\n        int lb=L.top()+ls,rb=R.top()+rs;\n        if(l[i]<lb)\n        {\n            res+=lb-l[i];R.push(lb-rs);\n            L.push(l[i]-ls);L.push(l[i]-ls);L.pop();\n        }\n        else if(l[i]>rb)\n        {\n            res+=l[i]-rb;L.push(rb-ls);\n            R.push(l[i]-rs);R.push(l[i]-rs);R.pop();\n        }\n        else\n        {\n            L.push(l[i]-ls);\n            R.push(l[i]-rs);\n        }\n    }\n    printf(\"%lld\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 510;\nconst int INF = 1e9;\n\nint n;\nint L[MAX_N], R[MAX_N];\nint dp[MAX_N][MAX_N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 1; i < MAX_N; i++) {\n        fill(dp[i], dp[i] + MAX_N, INF);\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> L[i] >> R[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 500; j++) {\n            if (dp[i][j] == INF) {\n                continue;\n            }\n            for (int x = 0; x < 500; x++) {\n                if (i == 0 || (x + R[i] - L[i] >= j && x <= j + R[i - 1] - L[i - 1])) {\n                    dp[i + 1][x] = min(dp[i + 1][x], dp[i][j] + abs(x - L[i]));\n                }\n            }\n        }\n    }\n    int ans = INF;\n    for (int i = 0; i < 500; i++) {\n        ans = min(ans, dp[n][i]);\n    }\n    cout << ans << \"\\n\";\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll L[100010],R[100010];\nll dif[2];\nll INF = 1001001001001001001;\nmultiset<ll> st[2];\nmultiset<ll>::iterator itel,iter;\nll ans;\n\nvoid mov(int id)\n{\n    ll tmp = *st[id].begin();\n    st[id].erase(st[id].begin());\n    if(id)st[1 - id].insert(-(tmp + dif[id]) - dif[1 - id]);\n    else st[1 - id].insert(-(tmp + dif[id]) - dif[1 - id]);\n    return;\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N; i++)scanf(\"%lld%lld\",L + i,R + i);\n\n    st[0].insert(INF),st[1].insert(INF);\n    for(int i = 0; i < N; i++)\n    {\n        if(i)\n        {\n            dif[0] += R[i] - L[i];\n            dif[1] += R[i - 1] - L[i - 1];\n        }\n\n        int idl = 0,idr = 0;\n        itel = st[0].begin();\n        for(int j = 0; j < 2; j++)\n        {\n            if(*itel < -L[i] - dif[0])\n            {\n                itel++;\n                idl++;\n            }\n        }\n        iter = st[1].begin();\n        for(int j = 0; j < 2; j++)\n        {\n            if(*iter < L[i] - dif[1])\n            {\n                iter++;\n                idr++;\n            }\n        }\n        if(idl)ans += -L[i] - dif[0] - *st[0].begin();\n        if(idr)ans += L[i] - dif[1] - *st[1].begin();\n        if(idl == idr)\n        {\n            st[0].insert(-L[i] - dif[0]);\n            st[0].insert(-L[i] - dif[0]);\n            mov(0);\n        }\n        if(idl)\n        {\n            st[0].insert(-L[i] - dif[0]);\n            st[0].insert(-L[i] - dif[0]);\n            for(int j = 0; j < idl; j++)mov(0);\n        }\n        if(idr)\n        {\n            st[1].insert(L[i] - dif[1]);\n            st[1].insert(L[i] - dif[1]);\n            for(int j = 0; j < idr; j++)mov(1);\n        }\n    }\n\n    printf(\"%lld\\n\",ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 1e5 + 1e3;\n\nint n, l[N], r[N], len[N];\n\nll tl, tr, ans;\n\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\n\nint main () {\n\n\tFile();\n\n\tFor (i, 1, n = read()) \n\t\tl[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n\n\tL.push(r[1]); R.push(r[1]);\n\tFor (i, 2, n) {\n\t\ttl -= len[i - 1]; tr += len[i];\n\t\tll lp = L.top() + tl, rp = R.top() + tr;\n\t\tif (lp <= r[i] && r[i] <= rp) \n\t\t\tL.push(r[i] - tl), R.push(r[i] - tr);\n\t\telse if (r[i] >= lp) {\n\t\t\tans += r[i] - rp; R.pop(); L.push(rp - tl);\n\t\t\tR.push(r[i] - tr); R.push(r[i] - tr);\n\t\t} else {\n\t\t\tans += lp - r[i]; L.pop(); R.push(lp - tr);\n\t\t\tL.push(r[i] - tl); L.push(r[i] - tl);\n\t\t}\n\t}\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1000 * 1000 * 1000;\nconst int MAXN = 410;\nconst int MAXL = 410;\n\nint A[MAXN][MAXL];\n\nint n;\nvector<int> left_coord, right_coord, len;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n;\n    left_coord.resize(n);\n    right_coord.resize(n);\n    len.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> left_coord[i] >> right_coord[i];\n        len[i] = right_coord[i] - left_coord[i];\n    }\n\n    for (int i = 0; i < MAXN; i++) {\n        for (int j = 0; j < MAXL; j++) {\n            A[i][j] = inf;\n        }\n    }\n\n    for (int l = 0; l + len[0] <= MAXL; l++) {\n        A[0][l] = abs(left_coord[0] - l);\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int pred_l = 0; pred_l < MAXL; pred_l++) {\n            if (A[i - 1][pred_l] == inf) {\n                continue;\n            }\n            for (int new_l = max(0, pred_l - len[i]);\n                 new_l <= pred_l + len[i - 1] && new_l + len[i] <= MAXL; new_l++) {\n                A[i][new_l] = min(\n                    A[i][new_l],\n                    A[i - 1][pred_l] + abs(left_coord[i] - new_l)\n                );\n            }\n        }\n    }\n    int ans = inf;\n    for (int l = 0; l < MAXL; l++) {\n        ans = min(ans, A[n - 1][l]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint solve_small(int n,vi ls,vi rs)\n{\n\tint m=*max_element(all(ls));\n\tvvi dp(n,vi(m+1,INF));\n\trep(x,m+1)\n\t\tdp[0][x]=abs(x-ls[0]);\n\trepi(i,1,n){\n\t\trep(j,m+1){\n\t\t\tint c=abs(j-ls[i]);\n\t\t\tint l=max(j-(rs[i-1]-ls[i-1]),0);\n\t\t\tint r=min(j+(rs[i]-ls[i]),m);\n\t\t\trepi(x,l,r+1)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][x]+c);\n\t\t}\n\t}\n\treturn *min_element(all(dp.back()));\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvi ls(n),rs(n);\n\t\trep(i,n) cin>>ls[i]>>rs[i];\n\t\tif(n<=400&&*max_element(all(rs))<=400){\n\t\t\tcout<<solve_small(n,ls,rs)<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"(>_<)\"<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\n#define BD 410\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,L[N],R[N],F[N],G[N],len[N];\nint main()\n{\n\tn=read(); for(int i=1;i<=n;i++)\n\t\tL[i]=read(), R[i]=read();\n\tfor(int i=1;i<=n;i++) if(L[i]>R[i]) swap(L[i],R[i]);\n\tfor(int i=1;i<=n;i++) len[i]=R[i]-L[i];\n\tfor(int i=1;i<=10;i++) G[i]=fabs(L[1]-i);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tmemset(F,0x3f,sizeof F);\n\t\tfor(int j=1;j<=10;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=10;k++)\n\t\t\t{\n\t\t\t\tif(k>j+len[i-1]||k+len[i]<j) continue;\n\t\t\t\telse F[k]=min(F[k],G[j]+abs(L[i]-k));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=10;i++) G[i]=F[i];\n\t//\tfor(int i=1;i<=10;i++) printf(\"%d \",F[i]); printf(\"\\n\");\n\t}\n\tint Ans=0x3fffffff; for(int i=1;i<=10;i++) Ans=min(Ans,G[i]);\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define INF 1e16\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<ii> vii;\n\nll l[444], r[444];\n\nint main(){\n  ll n, fixed_l, fixed_r;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> l[i] >> r[i];\n  }\n  ll anss=INF;\n  ll ans;\n  for(int i = 0; i < n; i++){\n    ans=0;\n    fixed_l = l[i];\n    fixed_r = r[i];\n    for(int j = i+1; j < n; j++){\n      if(!(r[j]<fixed_l || l[j]>fixed_r)){\n        fixed_l=l[j];\n        fixed_r=r[j];\n      }\n      else{\n        if(l[j]>fixed_r){\n          ans+=l[j]-fixed_r;\n          ll x=l[j]-fixed_r;\n          fixed_r=r[j]-x;\n          fixed_l=l[j]-x;\n        }\n        else{\n          ans+=fixed_l-r[j];\n          ll x=fixed_l-r[j];\n          fixed_r=r[j]+x;\n          fixed_l=l[j]+x;\n        }\n      }\n    }\n    fixed_l = l[i];\n    fixed_r = r[i];\n    for(int j = i-1; j >= 0; j--){\n      if(!(r[j]<fixed_l || l[j]>fixed_r)){\n        fixed_l=l[j];\n        fixed_r=r[j];\n      }\n      else{\n        if(l[j]>fixed_r){\n          ans+=l[j]-fixed_r;\n          ll x=l[j]-fixed_r;\n          fixed_r=r[j]-x;\n          fixed_l=l[j]-x;\n        }\n        else{\n          ans+=fixed_l-r[j];\n          ll x=fixed_l-r[j];\n          fixed_r=r[j]+x;\n          fixed_l=l[j]+x;\n        }\n      }\n    }\n    anss=min(ans,anss);\n  }\n  cout<<anss;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrey Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#pragma GCC optimize (\"O3\")\n//#define ANDREIKKAA_TOPCODER\n//#define ANDREIKKAA_ALLOCATOR\n#define ANDREIKKAA_CLASS Solution\n#define ANDREIKKAA_METHOD solve\n#define ANDREIKKAA_PARAMETERS void\n#define ANDREIKKAA_CALL\n#define ANDREIKKAA_RETURN_TYPE void\n\n#define first x\n#define second y\n#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nconst ld PI = acos(-1);\n\nconst int _ML = 500;\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n\"input.txt\"\n#else\n\"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n\"\"\n#else\n\"\"\n#endif\n;\n\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024LL * 1024LL];\nsize_t _ptr = 0;\ninline void* operator new(size_t _x) { _ptr += _x; return _mem + _ptr - _x; }\ninline void operator delete(void*) { }\n#endif\n\ntemplate<typename T, typename U> inline ostream &operator << (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator >> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const vector<T> &_v) { if (_v.empty()) return _out; _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline istream &operator >> (istream &_in, vector<T> &_v) { for (auto &_i : _v) _in >> _i; return _in; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const set<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const multiset<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T, typename U> inline ostream &operator << (ostream &_out, const map<T, U> &_m) { if (_m.empty()) return _out; _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) _out << \", (\" << _it->first << \": \" << _it->second << ')'; return _out; }\ntemplate<typename T, typename U> inline ostream &operator << (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) return _out; _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) _out << \", (\" << _it->first << \": \" << _it->second << ')'; return _out; }\n\n/* ________ CODE ________ */\n\ninline ANDREIKKAA_RETURN_TYPE mainFunction(ANDREIKKAA_PARAMETERS)\n{\n\tint n;\n\tcin >> n;\n\n\tconst int M = 500;\n\tconst int INF = 1000 * 1000;\n\tvector<vector<int>> dp(n + 1, vector<int>(M, INF));\n\n\tvector<pair<int, int>> a(n);\n\tcin >> a;\n\ta.insert(a.begin(), { 0, M });\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\ta[i].y = a[i].y - a[i].x + 1;\n\t}\n\n\tdp[0] = vector<int>(M, 0);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j < M; ++j)\n\t\t{\n\t\t\tfor (int k = max(0, j - a[i - 1].y + 1); k < min(M, j + a[i].y); ++k)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - a[i].x));\n\t\t\t}\n\t\t}\n\t}\n\tcout << *min_element(all(dp[n])) << endl;\n}\n\n/* ________ CODE ________ */\n\n#if defined(ANDREIKKAA) || !defined(ANDREIKKAA_TOPCODER)\nint main()\n{\n#if defined(ANDREIKKAA)\n\ttime_t _start = clock();\n#endif\n\tif (_inpf[0] != '\\0')\n\t\tassert(freopen(_inpf, \"r\", stdin) != nullptr);\n\tif (_outf[0] != '\\0')\n\t\tassert(freopen(_outf, \"w\", stdout) != nullptr);\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << setprecision(20);\n\t//cout << fixed;\t\n\tmainFunction(ANDREIKKAA_CALL);\n#if defined(ANDREIKKAA)\n\tcerr << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n\twhile (true);\n#endif\n}\n#else\nclass ANDREIKKAA_CLASS { public: ANDREIKKAA_RETURN_TYPE ANDREIKKAA_METHOD(ANDREIKKAA_PARAMETERS) { return mainFunction(ANDREIKKAA_CALL); } };\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\nint64 dp[401][401];\nint N, L[400], R[400];\n\nint64 rec(int idx, int preLeft)\n{\n  if(idx == N) return (0);\n  if(~dp[idx][preLeft]) return (dp[idx][preLeft]);\n  int64 ret = 1LL << 58;\n  int64 preRight = preLeft + R[idx - 1] - L[idx - 1];\n  for(int i = 1; i <= 400; i++) {\n    int64 left = i, right = i + R[idx] - L[idx];\n    if(preRight < left || preLeft > right) continue;\n    ret = min(ret, rec(idx + 1, i) + abs(i - L[idx]));\n  }\n  return (dp[idx][preLeft] = ret);\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n  }\n  int64 ret = 1LL << 58;\n  for(int i = 1; i <= 400; i++) {\n    ret = min(ret, rec(1, i) + abs(L[0] - i));\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mxn=1e5+5;\nll n, m, l[mxn], r[mxn], cl, cr, ans;\npriority_queue<ll>pq_left;\npriority_queue<ll, vector<ll>, greater<ll> >pq_right;\nint main(){\n\tscanf(\"%lld\", &n);\n\tfor(ll i=0; i<n; i++){\n\t\tscanf(\"%lld%ld\", &l[i], &r[i]);\n\t\tif(i==0){\n\t\t\tpq_left.push(l[i]);\n\t\t\tpq_right.push(l[i]);\n\t\t\tcl=cr=0;\n\t\t\tcontinue;\n\t\t}\n\t\tll last=r[i-1]-l[i-1], cur=r[i]-l[i];\n\t\tcl-=cur; cr+=last;\n\t\tll lf=pq_left.top()+cl, rg=pq_right.top()+cr;\n\t\tif(l[i]<lf){\n\t\t\tans+=lf-l[i];\n\t\t\tpq_right.push(lf-cr);\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_left.pop();\n\t\t}else if(l[i]>rg){\n\t\t\tans+=l[i]-rg;\n\t\t\tpq_left.push(rg-cl);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t\tpq_right.pop();\n\t\t}else{\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nconst ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> l(n), r(n); repeat (i,n) { scanf(\"%d%d\", &l[i], &r[i]); -- l[i]; }\n    // assert\n    assert (n <= 400);\n    repeat (i,n) {\n        assert (l[i] <= 399);\n        assert (r[i] <= 400);\n    }\n    // compute\n    constexpr int shift = 200;\n    constexpr int limit = 600;\n    vector<ll> cur(limit, 0ll);\n    vector<ll> prv(limit, inf);\n    repeat (j,limit) cur[j] = 0;\n    int w_prv = 1;\n    repeat (i,n) {\n        cur.swap(prv);\n        int w = r[i] - l[i];\n        repeat (x,limit) {\n            cur[x] = inf;\n            repeat_from (y, max(0, x-w_prv-1), min(limit, x+w)) {\n                setmin(cur[x], prv[y] + abs(x - (l[i]+shift)));\n            }\n        }\n    }\n    ll result = *whole(min_element, cur);\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvint a(n);\n\tvint b(n);\n\tvint c(n);\n\tassert(n<=400);\n\trep(i,n){\n\t\tcin>>a[i]>>b[i];\n\t\tassert(b[i]<=400);\n\t\ta[i]--,b[i]--;\n\t\tc[i] = b[i]-a[i];\n\t}\n\tvint dp(500);\n\trep(i,n){\n\t\tif(!i){\n\t\t\tdp[i] = abs(i - a[i]);\n\t\t}\n\t\telse{\n\t\t\tvint next(500,INF);\n\t\t\trep(j,500){\n\t\t\t\treep(k,a[i]-c[i-1],b[i]+1){\n\t\t\t\t\tif(k<0) continue;\n\t\t\t\t\tmins(next[j], dp[k]+abs(a[i]-j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,500) mins(ans, dp[i]);\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nint l[405], r[405];\npii p[405];\nint dp[405][405];\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\", &l[i], &r[i]);\n    }\n    memset(dp, -1, sizeof(dp));\n    for(int i=1;i<=n;i++){\n        if(i == 1){\n            for(int j=1;j<=400;j++) dp[i][j] = abs(r[i]-j);\n        }\n        else{\n            for(int j=1;j<=400;j++){\n                int le1 = r[i]-l[i];\n                int le2 = r[i-1]-l[i-1];\n                for(int k=max(1, j-le1);k<=min(400, j+le2);k++){\n                    int cost = dp[i-1][k] + abs(r[i]-j);\n                    if(dp[i][j] == -1 || dp[i][j] > cost) dp[i][j] = cost;\n                }\n            }   \n        }\n    }\n    int ans = 1e9;\n    for(int j=1;j<=400;j++){\n        if(dp[n][j] != -1){\n            ans = min(ans, dp[n][j]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nmultiset<int> LS, RS;\nint L[100010], R[100010];\nsigned main(){\n\tint n, fl = 0, fr = 0, ans = 0;\n\tscanf(\"%lld\", &n);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld%lld\", &L[i], &R[i]);\n\t\n\tLS.insert(-1e17);\n\tRS.insert(1e17);\n\tfor(int i = 0;i < n;i++){\n\t\tif(i){\n\t\t\tfl -= R[i]-L[i];\n\t\t\tfr += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i] < *LS.rbegin()+fl){\n\t\t\tans += *LS.rbegin()+fl-L[i];\n\t\t\tRS.insert(*LS.rbegin()+fl-fr);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tLS.insert(L[i]-fl);\n\t\t}else if(*RS.begin()+fr < L[i]){\n\t\t\tans += L[i]-(*RS.begin()+fr);\n\t\t\tLS.insert(*RS.begin()+fr-fl);\n\t\t\tRS.erase(RS.begin());\n\t\t\tRS.insert(L[i]-fr);\n\t\t\tRS.insert(L[i]-fr);\n\t\t}else{\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tRS.insert(L[i]-fr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct ST {\n  ll l, r;\n  ST(ll l, ll r):l(l),r(r){}\n};\n\n\nint main(){\n  int N;\n  vector<ST> v;\n  cin >> N;\n  rep(i,N){\n    ll l, r;\n    cin >> l >> r;\n    v.emplace_back(l, r);\n  }\n\n  if(N > 400){\n    cout << 0 << endl;\n    return 0;\n  }\n  rep(i,N){\n    if(v[i].l > 400 || v[i].r > 400){\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n\n  vector<ST> now;\n  ll sum = 0;\n  rep(i,N-1){\n    if(v[i].l < v[i+1].l){\n      sum += v[i+1].l - v[i].r;\n    }else{\n      sum += v[i].l - v[i+1].r;\n    }\n  }\n  sum /= 2;\n  if(sum < 0) sum = 0;\n  cout << sum << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n/*\n * 部分点\n * dp[i][x] := 長方形iまでを動かして、i個目の長方形の座標をxに動かした場合のコストの最小値\n */\n\nll dp[512][512];\n\nint main(){\n    int N; cin>>N;\n    vector<ll> L(N),R(N);\n    assert(N<=400);\n\n    rep(i,N){\n        cin >> L[i] >> R[i];\n        assert(L[i] <= 400);\n        assert(R[i] <= 400);\n    }\n\n    rep(i,512) rep(j,512) dp[i][j]=LINF;\n    rep(i,512) dp[0][i] = abs(L[0]-i);\n\n    for(int i=1;i<N;i++){\n        for(int x=0;x<=400;x++){\n            // decide dp[i][x]\n            for(int xd=max(0ll,x-(R[i-1]-L[i-1]));xd<=min(x+R[i]-L[i],400ll);xd++){\n                dp[i][x] = min(dp[i][x],abs(x-L[i])+dp[i-1][xd]);\n            }\n        }\n    }\n\n    ll ans = LINF;\n    for(int i=0;i<=400;i++){\n        chmin(ans,dp[N-1][i]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tint n;\n\tint l[402],r[402];\n\tint a[402];\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\ta[i] = r[i]-l[i];\n\t}\n\ta[0] = 0;\n\t\n\tstatic int dp[402][402] = {};\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 0 ; j < 402 ; j ++)dp[i][j] = 1000000000;\n\t\tfor(int j = 1 ; j <= 400 ; j ++){\n\t\t\tfor(int k = max(1,j-a[i-1]) ; k <= min(400,j+a[i]) ; k ++){\n\t\t\t\tdp[i][j] = min( dp[i][j] , dp[i-1][k] );\n\t\t\t}\n\t\t\tdp[i][j] += abs(l[i]-j);\n\t\t}\n\t\t/*for(int j = 1 ; j <= 7 ; j ++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t}\n\tint ret = 1000000000;\n\tfor(int i = 1 ; i <= 400 ; i ++){\n\t\tret = min( ret , dp[n][i] );\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N;\nlint M = 0, l0, r0;\n\nstruct Vec\n{\n    multiset<lint> ps;\n    lint bias;\n    Vec() : bias(0) {}\n    void addp(lint n)\n    {\n        ps.insert(n - bias);\n    }\n\n    void erasep(lint n)\n    {\n        ps.erase(ps.lower_bound(n - bias));\n    }\n\n    lint smallest() { return bias + *ps.begin(); }\n    lint largest() { return bias + *prev(ps.end()); }\n};\n\nlint dist_min(lint left0, lint right0, lint left1, lint right1)\n{\n    if (right0 < left1) return left1 - right0;\n    if (right1 < left0) return left0 - right1;\n    return 0;\n}\n\nint main()\n{\n    cin >> N;\n    Vec dls, drs;\n    dls.addp(-100000000000000);\n    drs.addp(100000000000000);\n\n    lint Lold, Lnew = 100000000000000;\n\n    REP(_, N)\n    {\n        lint l, r;\n        cin >> l >> r;\n        Lold = Lnew;\n        Lnew = r - l;\n\n        M += dist_min(l, r, dls.largest(), drs.smallest() + Lold);\n\n        dls.bias -= Lnew;\n        drs.bias += Lold;\n\n        dls.addp(l);\n        drs.addp(l);\n\n        while (drs.smallest() < dls.largest())\n        {\n            lint rr = drs.smallest();\n            drs.erasep(rr);\n            lint ll = dls.largest();\n            dls.erasep(ll);\n            dls.addp(rr);\n            drs.addp(ll);\n        }\n    }\n\n    cout << M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long\n\nusing namespace std;\n\nconst int N = 1e5+5;\n\nint n;\nint l[N], r[N];\nlong ans, lz_l, lz_r;\nmultiset<long> L, R;\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", l+i, r+i), r[i] -= l[i];\n    for(int i = 1; i <= n; i++) {\n        ans += l[i];\n        L.emplace(l[i] + lz_l), R.emplace(l[i] - lz_r);\n        while(*L.rbegin() - lz_l > *R.begin() + lz_r) {\n            long l = *L.rbegin(), r = *R.begin();\n            L.erase(L.find(l)), R.erase(R.find(r));\n            L.emplace(r + lz_r + lz_l), R.emplace(l - lz_l - lz_r);\n        }\n        long pv = 0;\n        while(!L.empty() && *L.begin() - lz_l - r[i+1] <= 0) {\n            ans -= abs(*L.begin() - lz_l - pv) * L.size();\n            pv = *L.begin() - lz_l;\n            L.erase(L.begin());\n        }\n        ans -= abs(pv - r[i+1]) * L.size();\n        lz_l += r[i+1], lz_r += r[i];\n    }\n    long m = L.size(), pv = 0;\n    for(long x : L) {\n        ans -= abs(x - lz_l - pv) * m--;\n        pv = x - lz_l;\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long\n\nusing namespace std;\n\nconst int N = 1e5+5;\n\nint n;\nint l[N], r[N];\nlong high, lz_l, lz_r;\nmultiset<long> L, R;\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", l + i, r + i), r[i] -= l[i];\n    for(int i = 1; i <= n; i++) {\n        high += l[i];\n        L.emplace(l[i] + lz_l), R.emplace(l[i] - lz_r);\n        while(*L.rbegin() - lz_l > *R.begin() + lz_r) {\n            long l = *L.rbegin(), r = *R.begin();\n            L.erase(L.find(l)), R.erase(R.find(r));\n            L.emplace(r + lz_r + lz_l), R.emplace(l - lz_l - lz_r);\n        }\n        long pv = 0;\n        while(!L.empty() && *L.begin() - lz_l - r[i + 1] <= 0) {\n            high -= abs(*L.begin() - lz_l - pv) * L.size();\n            pv = *L.begin() - lz_l;\n            L.erase(L.begin());\n        }\n        high -= abs(pv - r[i + 1]) * L.size();\n        lz_l += r[i + 1], lz_r += r[i];\n    }\n    long m = L.size(), pv = 0;\n    for(long x : L) {\n        high -= abs(x - lz_l - pv) * m--;\n        pv = x - lz_l;\n    }\n    printf(\"%lld\\n\", high);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n,psum[MAXN],ans;\npi A[MAXN];\npriority_queue<ll> l;\npriority_queue<ll,vector<ll>,greater<ll>> r;\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,1,n)cin>>A[i].f>>A[i].s,psum[i]=psum[i-1]+A[i].s-A[i].f;\n\tFOR(i,1,n){\n\t\tif(l.size() && A[i].f <= l.top()-psum[i]){\n\t\t\tans += l.top()-psum[i] - A[i].f;\n\t\t\tr.emplace(l.top()-psum[i]-psum[i-1]);\n\t\t\tl.pop();\n\t\t\tl.emplace(A[i].f+psum[i]), l.emplace(A[i].f+psum[i]);\n\t\t}else if(r.size() && r.top()+psum[i-1] <= A[i].f){\n\t\t\tans += A[i].f - (r.top()+psum[i-1]);\n\t\t\tl.emplace(r.top()+psum[i-1]+psum[i]);\n\t\t\tr.pop();\n\t\t\tr.emplace(A[i].f-psum[i-1]), r.emplace(A[i].f-psum[i-1]);\n\t\t}else{\n\t\t\tl.emplace(A[i].f+psum[i]), r.emplace(A[i].f-psum[i-1]);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tll l, r, len, pbl, pbr, ans = 0;\n\tpriority_queue<ll> ql;\n\tpriority_queue<ll, vector<ll>, greater<ll>> qr;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\t\tql.push(r - pbl);\n\t\tqr.push(r - pbr);\n\t\twhile (true)\n\t\t{\n\t\t\tll L = ql.top() + pbl;\n\t\t\tll R = qr.top() + pbr;\n\t\t\tif (L <= R) break;\n\t\t\tans += L - R;\n\n\t\t\tql.pop();\n\t\t\tqr.pop();\n\t\t\t\n\t\t\tql.push(R - pbl);\n\t\t\tqr.push(L - pbr);\n\t\t}\n\n\t\tpbl -= len;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 10000000000000000;\n\nint main(){\n\tint n;\n\tint l[402],r[402];\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t}\n\tl[0] = r[0] = 0;\n\t\n\tpriority_queue<ll> L;\n\tpriority_queue<ll,vector<ll>,greater<ll>> R;\n\tll dL = 0, dR = 0;\n\tll m = 0;\n\tL.push(-INF);\n\tR.push(INF);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tdR += r[i-1]-l[i-1];\n\t\tdL -= r[i]-l[i];\n\t\tll x = L.top()+dL;\n\t\tll y = R.top()+dR;\n\t\tif(l[i] < x){\n\t\t\tL.push(l[i]-dL);\n\t\t\tL.push(l[i]-dL);\n\t\t\tL.pop();\n\t\t\tR.push(x-dR);\n\t\t\tm += x-l[i];\n\t\t}\n\t\telse if(l[i] > y){\n\t\t\tR.push(l[i]-dR);\n\t\t\tR.push(l[i]-dR);\n\t\t\tR.pop();\n\t\t\tL.push(y-dL);\n\t\t\tm += l[i]-y;\n\t\t}\n\t\telse {\n\t\t\tL.push(l[i]-dL);\n\t\t\tR.push(l[i]-dR);\n\t\t}\n\t}\n\tcout << m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\n\nvector<vector<int> > cc;\nint dp(int n, int l) {\n    int &ret = cc[n][l];\n    if(ret != -1) return ret;\n\n    if(n == N - 1) return ret = abs(S[n].first - l);\n\n    int r = l + S[n].second - S[n].first;\n    ret = 1e9;\n    for(int i = -400; i <= 400; i++) {\n        int nl = i, nr = nl + S[n + 1].second - S[n + 1].first;\n        if(r < nl || nr < l) continue;\n        ret = min(ret, abs(S[n].first - l) + dp(n + 1, nl));\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    cc = vector<vector<int> >(N, vector<int>(402, -1));\n    int ans = 1e9;\n    for(int i = 0; i <= 400; i++) ans = min(ans, dp(0, i));\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP(a, n) REP(i, n) printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ')\n#define DUMP2DLL(a, n, m) REP(i, n) REP(j, m) printf(\"%lld%c\", a[i][j], j + 1 == m ? '\\n' : ' '); puts(\"\")\n\ntypedef long long ll;\n\n// const int N_MAX = 100000;\n// const int LR_MAX = 1000000000;\nconst int N_MAX = 400;\nconst int LR_MAX = 400;\nconst ll INF = 1e18;\n\nint N;\nint l[N_MAX];\nint r[N_MAX];\nint w[N_MAX];\n\nll dp[N_MAX][LR_MAX];\n\nvoid solve() {\n  REP(i, N) w[i] = r[i] - l[i];\n  fill(dp[0], dp[N], INF);\n  REP(x, LR_MAX) dp[0][x] = abs(x - l[0]);\n  FOR(i, 1, N - 1) REP(x, LR_MAX) REP(y, LR_MAX) {\n    if (x - w[i] <= y && y <= x + w[i - 1] ) {\n      dp[i][y] = min(dp[i][y], dp[i- 1][x] + abs(y - l[i]));\n    }\n  }\n  // DUMP2DLL(dp, N, LR_MAX);\n\n  ll ans = INF;\n  REP(x, LR_MAX) ans = min(ans, dp[N - 1][x]);\n  printf(\"%lld\\n\", ans);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) {\n    scanf(\"%d%d\", l + i, r + i);\n    --l[i]; --r[i];\n  }\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n// }}}\n// pre-written code {{{\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\nint N;\nInt l[100010], r[100010];\n\nInt f(Int l0){\n\tInt cost = abs(l0-l[0]);\n\tInt r0 = l0 + r[0] - l[0];\n\tfor(int i=1;i<N;i++){\n\t\tif(r0<l[i]){\n\t\t\tcost+=l[i]-r0;\n\t\t\tl0 = r0;r0 = l0+r[i]-l[i];\n\t\t}else if(r[i]<l0){\n\t\t\tcost+=l0-r[i];\n\t\t\tr0 = l0;l0 = r0 - (r[i]-l[i]);\n\t\t}else{\n\t\t\tl0 = l[i];r0 = r[i];\n\t\t}\n\t}\n\treturn -cost;\n}\n\npair<Int,Int> find_max(Int a, Int b, Int f(Int)) {\n\tconst double r = 2 / (3 + sqrt(5));\n\tdouble cd = a + r * (b - a), dd = b - r * (b - a);\n\tInt c = (Int)cd, d = (Int)(dd+1);\n\tInt fc = f(c), fd = f(d);\n//\twhile (d - c > EPS) {\n\twhile (d - c >=10) {\n//\t\tcerr<<\" \"<<a<<\" \"<<c<<\" \"<<d<<\" \"<<b<<endl;\n\t\tif (fc < fd) { // '<': maximum, '>': minimum\n//\t\t\ta = c; c = d; d = (b - r * (b - a));\n\t\t\ta = c; c = d; d = (Int)(b - r * (b - a)+1);\n\t\t\tfc = fd; fd = f(d);\n\t\t} else {\n//\t\t\tb = d; d = c; c = a + r * (b - a);\n\t\t\tb = d; d = c; c = (Int)(a + r * (b - a));\n\t\t\tfd = fc; fc = f(c);\n\t\t}\n\t}\n//\treturn c;\n\treturn {a,b};\n}\n\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>l[i]>>r[i];\n\tInt l = 0, r = 1e+9;\n\tauto p = find_max(l,r,f);\n\tInt ans = 1e+18;\n//\tcerr<<\" \"<<p.first<<\" \"<<p.second<<endl;\n\tfor(Int l = p.first;l<=p.second;l++){\n\t\tans = min(ans,-f(l));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll n,l[401],r[401],ans=1e9;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n  ll dp[401][801];\n  for(int i=0;i<=400;i++)\n    for(int j=0;j<=800;j++)dp[i][j]=1e9;\n  for(int i=0;i<=800;i++)dp[0][i]=abs(i-l[0]);\n  for(int i=1;i<n;i++)\n    for(int j=0;j<400;j++)\n      for(int k=max((ll)0,j-(r[i]-l[i]));k<=j+(r[i-1]-l[i-1])&&k<=800;k++){\n\tdp[i][k]=min(dp[i][k],dp[i-1][j]+abs(k-l[i]));\n      }\n  for(int i=0;i<=800;i++)ans=min(ans,dp[n-1][i]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i = (a),i##_end_ = (b);i<=i##_end_;i++)\n#define ROF(i,a,b) for(int i = (a),i##_end_ = (b);i>=i##_end_;i--)\n#define MST(a,x) memset(a,x,sizeof(a))\n#define ALL(x) (x).begin(),(x).end()\n#define ll long long\n#define PB push_back\n#define PH push\n#define MP make_pair\n#define FT first\n#define SD second\n#define N 405\n#define M 1500005\n#define INF 1000000007\n#define MOD 1000000007\n#define MOD2 1000000009\n#define eps 1e-14\n#define DEBUG_\n#ifdef DEBUG_\n#define DEBUG(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif // DEBUG\nusing namespace std;\n\nint l[N],r[N];\nint dp[N][N];\nint n;\nint get(int id,int p)\n{\n    if(id == n)return 0;\n    if(dp[id][p]!=INF)return dp[id][p];\n\n    FOR(i,1,400)\n    {\n        int nxt = get(id+1,i);\n        if((i<=p&&i+(r[id+1]-l[id+1])>=p))dp[id][p] = min(dp[id][p],nxt+abs(i-l[id+1]));\n        if((i<=p+(r[id]-l[id])&&i+(r[id+1]-l[id+1])>=p+(r[id]-l[id])))dp[id][p] = min(dp[id][p],nxt+abs(i-l[id+1]));\n        if(i>=p&&i+(r[id+1]-l[id+1])<=p+(r[id]-l[id]))dp[id][p] = min(dp[id][p],nxt+abs(i-l[id+1]));\n       // cout<<id<<\" \"<<p<<\" \"<<dp[id][p]<<endl;\n    }\n    return dp[id][p];\n}\nint main()\n{\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        FOR(i,1,n)scanf(\"%d%d\",&l[i],&r[i]);\n        FOR(i,1,400)FOR(j,1,400)dp[i][j] = INF;\n        int ans = INF;\n        FOR(i,1,400)\n        {\n            int ret = l[1]-i;\n            if(ret<0)ret = -ret;\n            int ss = get(1,i);\n            ans = min(ans,ret+ss);\n            //cout<<ret<<\" \"<<ss<<endl;\n        }\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n \nusing namespace std;\nconst int MAXN = 3e5+5;\nlong long ans;\npriority_queue<long long> l;\nlong long ofl,ofr;\nlong long le[MAXN];\nlong long ri[MAXN];\npriority_queue<long long,vector<long long>,greater<long long>> r;\nint main(){\n    long long n;\n    cin>>n;\n    for(long long i=1;i<=n;i++){\n        cin>>le[i]>>ri[i];\n    }\n    l.push(le[1]);\n    \n    r.push(le[1]);\n    for(long long i=2;i<=n;i++){\n        ofl -= ri[i]-le[i];\n        ofr += ri[i-1]-le[i-1];\n        long long lborder = l.top()+ofl;\n        long long rborder = r.top()+ofr;\n      //  cout<<lborder<<\" \"<<rborder<<endl;\n        if(le[i]<lborder){\n            l.push(le[i]-ofl);\n            l.push(le[i]-ofl);\n            l.pop();\n            r.push(lborder-ofr);\n           // cout<<lborder+ofl<<endl;\n            ans+=abs(lborder-le[i]);\n        }else if(le[i]>rborder){\n            r.push(le[i]-ofr);\n            r.push(le[i]-ofr);\n            r.pop();\n            l.push(rborder-ofl);\n            //cout<<123<<\" \"<<rborder<<endl;\n            ans+=abs(rborder-le[i]);\n        }else{\n            l.push(le[i]-ofl);\n            r.push(le[i]-ofr);\n        }\n       // cout<<ans<<endl;\n    }\n    \n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 500\nint dp[MAX][MAX];\nsigned main(){\n  int n;\n  cin>>n;\n  if(n>400) assert(0);\n  int l[n+1],r[n+1];\n  for(int i=1;i<=n;i++) cin>>l[i]>>r[i];\n  for(int i=1;i<=n;i++) if(l[i]>400||r[i]>400) assert(0);\n  l[0]=0;r[0]=MAX;\n  int inf=1LL<<55LL;\n  fill_n(dp[0],MAX,0);\n  for(int i=1;i<=n;i++){\n    fill_n(dp[i],MAX,inf);\n    for(int j=0;j<MAX;j++){\n      for(int k=0;k<MAX;k++){\n\tif(j+(r[i]-l[i])<k||k+(r[i-1]-l[i-1])<j) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<k<<\":\"<<dp[i-1][k]<<\" \"<<abs(l[i]-j)<<endl;\n\tdp[i][j]=min(dp[i][j],dp[i-1][k]+abs(l[i]-j));\n      }\n      //cout<<i<<\" \"<<j<<\":\"<<dp[i][j]<<endl;\n    }\n  }\n  int ans=inf;\n  for(int i=0;i<MAX;i++) ans=min(ans,dp[n][i]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> vp(n);\n\tfor (auto &x: vp) cin >> x.first >> x.second;\n\n\tvector<int> store(401, 0);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tint tmp;\n\t\t\tif (j >= vp[i].first && j <= vp[i].second) tmp = 0;\n\t\t\telse tmp = min(abs(j - vp[i].first), abs(j - vp[i].second));\n\t\t\tstore[j] += tmp;\n\t\t}\n\t}\n\n \tcout << *min_element(store.begin(), store.end()) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nconst long long INF=1e18+7;\n\nstruct ShiftMultiset{\n  std::multiset<long long> set;\n  long long delta;\n  //x in set represents x+delta\n  void insert(long long x){\n    set.insert(x-delta);\n  }\n  void shift(long long x){\n    delta+=x;\n  }\n  long long front(){\n    assert(set.size());\n    return *set.begin()+delta;\n  }\n  long long back(){\n    assert(set.size());\n    return *set.rbegin()+delta;\n  }\n  long long pop_front(){\n    assert(set.size());\n    long long x=*set.begin();\n    set.erase(set.begin());\n    return x+delta;\n  }\n  long long pop_back(){\n    assert(set.size());\n    long long x=*set.rbegin();\n    set.erase(set.find(*set.rbegin()));\n    return x+delta;\n  }\n}left,right;\n\nint ls[100005];\nint rs[100005];\n\nint main(){\n  int N;\n  scanf(\"%d\",&N);\n  for(int i=1;i<=N;i++){\n    scanf(\"%d %d\",&ls[i],&rs[i]);\n  }\n  long long cost=0;//cost at min\n  left.insert(0);\n  right.insert(INF);\n  for(int i=1;i<=N;i++){\n    left.shift(-(rs[i]-ls[i]));\n    right.shift((rs[i-1]-ls[i-1]));\n    if(ls[i]<left.back()){\n      cost+=std::abs(left.back()-ls[i]);\n      left.insert(ls[i]);\n      left.insert(ls[i]);\n      right.insert(left.pop_back());\n    }else if(ls[i]>right.front()){\n      cost+=std::abs(right.front()-ls[i]);\n      right.insert(ls[i]);\n      right.insert(ls[i]);\n      left.insert(right.pop_front());\n    }else{\n      left.insert(ls[i]);\n      right.insert(ls[i]);\n    }\n  }\n  printf(\"%lld\\n\",cost);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INT long long\n#define ED 400\n#define oo 1987654321\nusing namespace std;\n\nint n, dt[440][440], l[440], r[440], ans = 1987654321;\n\nint dp(int x, int y)\n{\n    if( x == n ) return 0;\n    if( ~dt[x][y] ) return dt[x][y];\n    int &ret = dt[x][y] = oo;\n    for(int i = 1 ; i <= ED-(r[x]-l[x]) ; i++ )\n        if( (y <= i+(r[x]-l[x]) and i <= y+(r[x-1]-l[x-1])) )\n            ret = min( ret, dp(x+1, i) + abs(i-l[x]) );\n    return ret;\n}\n\nint main()\n{\n    cin>>n;\n    memset(dt, -1, sizeof(dt));\n    for(int i = 0 ; i < n ; i++ ) cin>>l[i]>>r[i];\n    for(int i = 1 ; i <= ED-(r[0]-l[0]) ; i++ )\n        ans = min( ans, dp(1, i) + abs(i-l[0]) );\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nvector<int> L,R;\n\n\nbool ok(int l,int r,int a,int b){\n  if(r < a && r < b) return 0;\n  if(l > a && l > b) return 0;\n  return 1;\n}\n\nint mem[401][1010],used[401][1010];\n\nint dfs(int y,int ofset){\n  if(y == n-1) return 0;\n  if(used[y][ofset + 500]++) return mem[y][ofset + 500];\n  \n  int l = L[y] + ofset;\n  int r = R[y] + ofset;\n  int res = INF;  \n  for(int nofset = -400; nofset <= 400; nofset++){\n    int nl = L[y+1] + nofset;\n    int nr = R[y+1] + nofset;\n    if(!ok(l,r,nl,nr)) continue;\n    Min(res, abs(nofset) + dfs(y+1, nofset));\n  }\n  return mem[y][ofset + 500] = res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>n;\n  assert(n <= 400);\n  L.resize(n);\n  R.resize(n);\n  for(int i=0;i<n;i++) cin>>L[i]>>R[i];\n  for(int i=0;i<n;i++) assert(L[i]<=400 && R[i]<=400);\n\n  if(n == 1){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  int ans = INF;\n  for(int i=-400;i<=400;i++) Min(ans, abs(i) + dfs(0,i)); \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(ll)(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) reps(i,0,((n)+1))\n#define repst(i,s,n) reps(i,s,((n)+1))\n#define reprt(i,n,t) for(ll (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ');}}\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// dp[i][x]: 上からi個までの長方形を動かしていてi個目の長方形の横座標をxに動かした時点でのそこまでのコストの最小値\n// dp[i][x] = |x-l[i]| + min dp[i-1][x'] (x-(r[i-1]-l[i-1]) <= x' <= x+(r[i]-l[i]))\n// これでO(nx^2) 部分点\n//\n// dp[i-1]からdp[i]を求めるには以下の操作ができればいい\n// 1) x軸方向に平行移動\n// 2) ある一定長さの区間のminを取る\n// 3) |x-l[i]|を足す\n// dpの式に着目する dp[i]の式は|x-l|という形の式をi個足し合わせたものなので、下に凸で、\n// 傾きはxが-∞のとき-i、そこから徐々に傾きが大きくなっていき、0になる範囲を経由し、xが∞のときiになる\n// iが増える(|x-l|という形の式が増える)に連れて傾き0の部分が広がり、そのぶんだけ傾き負の部分は左にスライドし、正の部分は右にスライドする\n// 移動量の総和を最小化するには各矩形は傾きが0の範囲のxのうち一番近い場所に移動すればいい\n// 傾きが変わる点をset(正負で分ける)に入れといて、0の範囲が増える度に更新する\n\nll n, l[114514], r[114514];\nmultiset<ll> le, ri;\nll ls, rs, ans;\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) cin >> l[i] >> r[i];\n\tls = rs = l[0];\n\tle.insert(l[0]), ri.insert(l[0]);\n\treps(i,1,n) {\n\t\tls -= r[i]-l[i], rs += r[i-1]-l[i-1];\n\t\tll a = *le.rbegin(), b = *ri.begin();\n\t\tif (ls<=l[i] && l[i]<=rs) {\n\t\t\tle.insert(l[i]-(ls-a));\n\t\t\tri.insert(l[i]-(rs-b));\n\t\t\tls = rs = l[i];\n\t\t} else if (l[i]<ls) {\n\t\t\tans += abs(l[i]-ls);\n\t\t\tle.insert(l[i]-(ls-a));\n\t\t\tle.insert(l[i]-(ls-a));\n\t\t\tll left = *le.rbegin() + (ls-a);\n\t\t\tle.erase(--le.end());\n\t\t\tri.insert(left-(rs-b));\n\t\t\tls = *le.rbegin() + (ls-a);\n\t\t\trs = left;\n\t\t} else {\n\t\t\tans += abs(l[i]-rs);\n\t\t\tri.insert(l[i]-(rs-b));\n\t\t\tri.insert(l[i]-(rs-b));\n\t\t\tll right = *ri.begin() + (rs-b);\n\t\t\tri.erase(ri.begin());\n\t\t\tle.insert(right - (ls-a));\n\t\t\tls = right;\n\t\t\trs = *ri.begin() + (rs-b);\n\t\t}\n\t\t//cout << i << ' ' << ans << ln;\n\t}\n\tcout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = 400 + 10;\nint n, l[MAXN], r[MAXN];\nint len[MAXN];\nint dp[MAXN][MAXN];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        len[i] = r[i] - l[i];\n    }\n\n    for (int i = 1; i <= 400; ++i) {\n        dp[1][i] = abs(i - l[1]);\n    }\n    for (int i = 2; i <= n; ++i) {\n        for (int x = 1; x <= 400; ++x) {\n            dp[i][x] = (int)1e9;\n            for (int x1 = max(1, x - len[i - 1]); x1 <= 400 && x1 <= x + len[i]; ++x1) {\n                dp[i][x] = min(dp[i][x], dp[i - 1][x1]);\n            }\n            dp[i][x] += abs(x - l[i]);\n        }\n    }\n\n    printf(\"%d\\n\", *min_element(dp[n] + 1, dp[n] + 1 + 400));\n\n    /*\n    f(i, x) = f(i - 1, x') + x - x' - len(i - 1)        x' <= x - len(i - 1)\n\n    f(i, x) = f(i - 1, x')                              x - len(i - 1) <= x' <= x + len(i)\n\n    f(i, x) = min(f(i - 1, x') + x' - x - len(i))       x' >= x + len(i)\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef pair<int, int> P1;\ntypedef pair<int, pair<int, int> > P2;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\nstatic const int mod = 1000000007;\n\n\n\nint N;\nint L[100005],R[100005];\nint len[100005];\nint dp[5005][5005];\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<5000;++i)for(int j=0;j<5000;++j)dp[i][j]=INF;\n    for(int i=0;i<N;++i){\n        cin>>L[i]>>R[i];\n        len[i] = R[i]-L[i];\n    }\n    if(N>400)exit(0);\n    for(int i=1;i<5000;++i)dp[0][i] = abs(i-L[0]);\n    for(int i=0;i<N-1;++i){\n        for(int j=0;j<=400;++j){\n            for(int k=0;k<=400;++k){\n                int pl = k,pr = k+len[i];\n                int l=j,r=j+len[i+1];\n                if(pr<l||r<pl)continue;\n                //cout<<l<<\" \"<<pl<<endl;\n                //cout<<\"//////////////////\"<<endl;\n                dp[i+1][l] = min(dp[i+1][l],dp[i][pl] + abs(L[i+1]-l));\n                //cout<<dp[i+1][l]<<endl;\n            }\n        }\n    }\n    int ans=INF;\n    for(int i=1;i<=400;++i)ans=min(ans,dp[N-1][i]);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define pb push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nvector<ll> l,r;\n\nint main(){\n    cin >> N;\n    assert(N<=400);\n    l.resize(N);\n    r.resize(N);\n    ll mid=0;\n    rep(i,N){\n        cin >> l[i] >> r[i];\n        assert(l[i]<=400);\n        assert(r[i]<=400);\n    }\n\n    ll ans2=LINF;\n    for(int i=0;i<N;i++){\n        ll ans=0;\n        ll LL,LR;\n        LL=l[i];\n        LR=r[i];\n        for(int j=i+1;j<N;j++){\n            if(LR < l[j]){\n                ans += l[j]-LR;\n            }else if(r[j] < LL){\n                ans += LL-r[j];\n            }\n            LL = l[j];\n            LR = r[j];\n        }\n        LL=l[i];\n        LR=r[i];\n        for(int j=i-1;j>=0;j--){\n            if(LR < l[j]){\n                ans += l[j]-LR;\n            }else if(r[j] < LL){\n                ans += LL-r[j];\n            }\n            LL = l[j];\n            LR = r[j];\n        }\n        ans2 = min(ans2,ans);\n    }\n    cout << ans2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <iostream>\ntypedef long long ll;\n\nint n,l[100005],r[100005];\nll Ans,tl,tr,lq,rq;\nstd::priority_queue<ll,std::vector<ll>,std::less<ll> > L;\nstd::priority_queue<ll,std::vector<ll>,std::greater<ll> > R;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d%d\",&l[i],&r[i]),l[i]=r[i]-l[i];\n    L.push(r[1]),R.push(r[1]);\n    for(int i=2;i<=n;++i)\n    {\n        tl-=l[i-1],tr+=l[i],lq=L.top()+tl,rq=R.top()+tr;\n        if(r[i]>=lq&&r[i]<=rq)L.push(r[i]-tl),R.push(r[i]-tr);\n        else if(r[i]>=lq)Ans+=r[i]-rq,R.pop(),L.push(rq-tl),R.push(r[i]-tr),R.push(r[i]-tr);\n        else Ans+=lq-r[i],L.pop(),R.push(lq-tr),L.push(r[i]-tl),L.push(r[i]-tl);\n    }\n    printf(\"%lld\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\t/*\n\tf(x) = abs(x-L)\n\tの関数を足す。\n\t*/\n\t\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + ofL;\n\t\tret += (temp - L);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + ofR;\n\t\tret += (L - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tadd2init();\n\taddABSfunc2(0,0,L[0]);\n\tfor(int i=1;i<N;++i){\n\t\taddABSfunc2(R[i]-L[i],R[i-1]-L[i-1],L[i]);\n\t}\n\tcout << ret2 << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve2();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tint len=r[1]-l[1];\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[i]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx-len;j++){\n\t\t\tf[i][j]=100000000;\n\t\t\tfor(int k=max(1,j-len-len_);k<=min(mx,j+len);k++){\n\t\t\t\tif(k>j)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-k)));\n\t\t\t\telse if(k>j-len_)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-j)));\n\t\t\t\telse f[i][j]=min(f[i][j],f[i-1][k]+min(abs(r[i]-j),abs(l[i]-(k+len_))));\n\t\t\t}\n\t\t}\n\t}\n\tans=100000000;\n\tfor(int j=1;j<=mx;j++)ans=min(ans,f[n][j]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 100010;\n\nll l[maxn], len[maxn];\n\nll ladd, radd, mini;\n\nmultiset<ll> lt, rt;\n\nvoid add(int p) {\n\tladd -= len[p];\n\tradd += len[p-1];\n\n\tif (*lt.rbegin() + ladd > l[p]) {\n\t\tlt.insert(l[p] - ladd); lt.insert(l[p] - ladd);\n\t\tmini += abs(l[p] - (*lt.rbegin() + ladd));\n\t\tauto it = --lt.end();\n\t\trt.insert(*it + ladd - radd);\n\t\tlt.erase(it);\n\t} else if (*rt.begin() + radd < l[p]) {\n\t\trt.insert(l[p] - radd); rt.insert(l[p] - radd);\n\t\tmini += abs(l[p] - (*rt.begin() + radd));\n\t\tauto it = rt.begin();\n\t\tlt.insert(*it + radd - ladd);\n\t\trt.erase(it);\n\t} else { //between\n\t\tlt.insert(l[p] - ladd); rt.insert(l[p] - radd);\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N) {\n\t\tint p, q;\n\t\tcin >> p >> q;\n\t\tl[i] = p;\n\t\tlen[i] = q - p;\n\t}\n\n\tlt.insert(l[0]); rt.insert(l[0]);\n\n\tfor (int i = 1; i < N; ++i) {\n\t\tadd(i);\n\t}\n\n\tcout << mini << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll ans;\n\nstruct slope {\n\tpriority_queue <ll> pq;\n\tll delta;\n\n\tvoid upd(ll x) { delta += x; }\n\tvoid push(ll x) { pq.push(x - delta); }\n\tll top() { return pq.top() + delta; }\n\tvoid pop() { pq.pop(); }\n\n\tvoid debug() {\n\t\tcerr << \"\\tdelta = \" << delta << endl;\n\t\tpriority_queue <ll> tmp = pq;\n\t\tcerr << \"\\tDEBUG\\n\";\n\t\tcerr << \"\\t\";\n\t\twhile(!tmp.empty()) {\n\t\t\tcerr << abs(tmp.top() + delta) << ' ';\n\t\t\ttmp.pop();\n\t\t}\n\t\tcerr << endl;\n\t}\n} lef, rig;\n\nconst int N = 1e5 + 5;\nint n;\nll l[N], r[N];\n\nll cost(ll l, ll r, ll x) {\n\tif (x < l) return l - x;\n\tif (x > r) return x - r;\n\treturn 0;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> l[i] >> r[i];\n\n\tlef.push(l[1]);\n\trig.push(-l[1]);\n\n\tfor (int i = 2; i <= n; ++i) {\n\t\tlef.upd(l[i] - r[i]);\n\t\trig.upd(-(r[i - 1] - l[i - 1]));\n\n\t\tans += cost(lef.top(), -rig.top(), l[i]);\n\n\t\tlef.push(l[i]);\n\t\trig.push(-l[i]);\n\n\t\twhile(lef.top() > -rig.top()) {\n\t\t\tll x = lef.top(); lef.pop();\n\t\t\tll y = -rig.top(); rig.pop();\n\t\t\tlef.push(y); rig.push(-x);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAXN 405\n#define MOD 1000000007\n#define sz(a) static_cast<long long>(a.size())\n#define INF 2000000000000000000\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pp;\nint n,dp[MAXN][MAXN]; pp a[MAXN];\nint dist(int val,int k,int j){\n\tif (k<=j && j<=k+val) return 0;\n\tif (j<k) return k-j;\n\tif (j>k+val) return j-k-val;\n}\nvoid solve(){\n\tint i,j,k,v1,v2,val;\n\tfor (i=0;i<MAXN;i++) dp[1][i]=abs(a[1].first-i);\n\tfor (i=2;i<=n;i++){\n\t\tval=a[i-1].second-a[i-1].first;\n\t\tfor (j=0;j<MAXN;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tv1=max(0ll,j-val); v2=min(404ll,j+a[i].second-a[i].first);\n\t\t\tfor (k=v1;k<=v2;k++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+abs(a[2].first-j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=INF;\n\n\tfor (i=0;i<MAXN;i++) ans=min(ans,dp[n][i]);\n\tcout<<ans;\n}\nmain(){\n\tios::sync_with_stdio(false); cin.tie(0);\n\t//freopen(\"inp.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout);\n\t//freopen(\".INP\",\"r\",stdin); freopen(\".OUT\",\"w\",stdout);\n\tcin>>n; int i,j,k;\n\tfor (i=1;i<=n;i++) cin>>a[i].first>>a[i].second;\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,l[444],len[444];\nint dp[444][444];\nvoid upd(int&x,int y){\n\tif(x==-1||x>y)x=y;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d%d\",&l[i],&len[i]);\n\t\tlen[i] -= l[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0; i<=400; i++)\n\t\tdp[0][i] = labs(l[0] - i);\n\tfor(int t=1; t<n; t++)\n\tfor(int i=0; i<=400; i++)\n\tfor(int j=0; j<=400; j++)\n\t\tif(!(i+len[t-1] < j || j+len[t] < i)){\n\t\t\tupd(dp[t][j],dp[t-1][i] + labs(l[t] - j));\n\t\t}\n\tint res=-1;\n\tfor(int i=0; i<=400; i++)\n\t\tupd(res,dp[n-1][i]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll N;\n    cin >> N;\n\n    vector<ll> l(N), r(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> l[i] >> r[i];\n    }\n\n    multiset<ll> le, ri;\n    le.insert(l[0]);\n    ri.insert(r[0]);\n\n    ll ls = l[0], rs = l[0];\n    ll ans = 0;\n    for (ll i = 1; i < N; i++) {\n        ls -= r[i] - l[i];\n        rs += r[i] - l[i];\n\n        ll a = *le.rbegin();\n        ll b = *ri.begin();\n        if (ls <= l[i] && l[i] <= rs) {\n            le.insert(l[i] - (ls - a));\n            ri.insert(l[i] - (rs - b));\n            ls = rs = l[i];\n        } else if (l[i] < ls) {\n            ans += abs(l[i] - ls);\n            le.insert(l[i] - (ls - a));\n            le.insert(l[i] - (ls - a));\n            ll left = *le.rbegin() + (ls - a);\n            le.erase(--le.end());\n            ri.insert(left - (rs - b));\n            ls = *le.rbegin() + (ls - a);\n            rs = left;\n        } else {\n            ans += abs(l[i] - rs);\n            ri.insert(l[i] - (rs - b));\n            ri.insert(l[i] - (rs - b));\n            ll right = *ri.begin() + (rs - b);\n            ri.erase(ri.begin());\n            le.insert(right - (ls - a));\n            ls = right;\n            rs = *ri.begin() + (rs - b);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 402\n\nint n;\n\nvector < pair<int, int> > v;\n\nbool intersect(pair<int, int> a, pair<int, int> b){\n\tif (a.second < b.first || b.second < a.first){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tv.push_back(make_pair(l, r));\n\t}\n\tlong long int ans = LLONG_MAX;\n\tfor (int i = 0; i <= MAX; i++){\n\t\tlong long int cost = abs(i-v[0].first);\n\t\tpair<int, int> rng = make_pair(i, i + v[0].second - v[0].first);\n\t\tfor (int j = 1; j < n; j++){\n\t\t\tpair<int, int> rng2 = v[j];\n\t\t\tif (intersect(rng, rng2)){\n\t\t\t\trng = rng2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rng2.second < rng.first){\n\t\t\t\tcost += rng.first - rng2.second;\n\t\t\t\trng2.first += rng.first - rng2.second;\n\t\t\t\trng2.second += rng.first - rng2.second;\n\t\t\t\trng = rng2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcost += rng2.first - rng.second;\n\t\t\t\trng2.second -= rng2.first - rng.second;\n\t\t\t\trng2.first -= rng2.first - rng.second;\n\t\t\t\trng = rng2;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cost);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\n//typedef string S;\n\n/*ll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}*/\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 120010;\nconst long long MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst long long rev2 = (MOD + 1) / 2;\n\nint n, lastl, lastr;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    multiset<long long> L, R;\n    long long addL = 0, addR = 0;\n    long long c = 0;\n    L.insert(-INF);\n    R.insert(INF);\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (i != 0)\n        {\n            //addL -= lastr - lastl, addR += r - l;\n            addL -= r - l, addR += lastr - lastl;\n        }\n\n        /*for (auto it : L)\n        {\n            cout << it + addL << \" \";\n        }\n        cout << endl;\n        for (auto it : R)\n        {\n            cout << it + addR << \" \";\n        }\n        cout << endl << endl;*/\n\n        lastl = l, lastr = r;\n        auto x = L.end();\n        x--;\n        int Ln = *x + addL;\n        auto y = R.begin();\n        int R0 = *y + addR;\n        if (Ln <= l && l <= R0)\n        {\n            L.insert(l - addL);\n            R.insert(l - addR);\n        } else if (l < Ln)\n        {\n            L.erase(x);\n            R.insert(Ln - addR);\n            L.insert(l - addL);\n            L.insert(l - addL);\n            c += Ln - l;\n        } else if (R0 < l)\n        {\n            R.erase(y);\n            L.insert(R0 - addL);\n            R.insert(l + addR);\n            R.insert(l + addR);\n            c += l - R0;\n        } else\n        {\n            return 1;\n        }\n\n        /*for (auto it : L)\n        {\n            cout << it + addL << \" \";\n        }\n        cout << endl;\n        for (auto it : R)\n        {\n            cout << it + addR << \" \";\n        }\n        cout << endl << endl;*/\n    }\n    cout << c;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<i64> l(N),r(N);\n    rep(i,0,N) cin >> l[i] >> r[i];\n\n    i64 bottom=0,left_uniform=0,right_uniform=0;\n    multiset<i64> left_diverse={-l[0]},right_diverse={l[0]};\n    rep(i,1,N){\n        left_uniform-=r[i]-l[i];\n        right_uniform+=r[i-1]-l[i-1];\n\n        if(left_uniform-*left_diverse.begin()<=l[i] and l[i]<=right_uniform+*right_diverse.begin()){\n            left_diverse.insert(-l[i]+left_uniform);\n            right_diverse.insert(l[i]-right_uniform);\n        }else if(l[i]<left_uniform-*left_diverse.begin()){\n            bottom+=(left_uniform-*left_diverse.begin())-l[i];\n\n            left_diverse.insert(-l[i]+left_uniform);\n            left_diverse.insert(-l[i]+left_uniform);\n            right_diverse.insert(left_uniform-*left_diverse.begin()-right_uniform);\n            left_diverse.erase(left_diverse.begin());\n        }else{\n            bottom+=l[i]-(right_uniform+*right_diverse.begin());\n\n            right_diverse.insert(l[i]-right_uniform);\n            right_diverse.insert(l[i]-right_uniform);\n            left_diverse.insert(-(right_uniform+*right_diverse.begin())+left_uniform);\n            right_diverse.erase(right_diverse.begin());\n        }\n    }\n\n    cout << bottom << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//marico el que lo lea\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <stdlib.h>\n#include <assert.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> ii;\n\nvoid fastIO() {\n\tstd::ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n}\n\n#define FOR(i,f,t) for(int i=f; i<(int)t; i++)\n#define FORR(i,f,t) for(int i=f; i>(int)t; i--)\n#define FORE(i,c) for(auto i = (c).begin(); i != (c).end(); i++)\n#define pb push_back\n#define all(obj) obj.begin(), obj.end()\n#define ms(obj, val) memset(obj, val, sizeof(obj))\n#define ms2(obj, val, sz) memset(obj, val, sizeof(obj[0])*sz)\n\n#define fst first\n#define snd second\n\ntemplate<typename T, typename U> inline void mnze(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void mxze(T &x, U y) { if(x < y) x = y; }\n\nvoid _scan( int &x ) { scanf(\"%d\",&x); }\nvoid _scan( long long &x ) { scanf(\"%lld\",&x); }\nvoid _scan( double &x ) { scanf(\"%lf\",&x); }\nvoid _scan( char &x ) { scanf(\" %c\",&x); }\nvoid _scan( char *x ) { scanf(\"%s\",x); }\nvoid scan() {}\ntemplate<typename T, typename... U>\nvoid scan( T& head, U&... tail ) { _scan(head); scan(tail...);}\n\ntemplate<typename T> void _dbg(const char* sdbg, T h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename T, typename... U> void _dbg(const char* sdbg, T h, U... t) {\n\twhile(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(_i, (x)) cerr <<*_i <<\", \"; cerr <<\"\\n\"; }}\n#define debuga(x, sz) {{cerr <<#x <<\" = \"; FOR(_i, 0, sz) cerr << x[_i] <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define debuga(x, sz)\n#define cerr if(0)cout\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 1e5+5;\n\nint N, l[MAXN], r[MAXN], s[MAXN];\n\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll>> R;\nll dL, dR, c;\n\nint main(){\n\tscan(N);\n\tFOR(i,0,N) scan(l[i], r[i]);\n\tFOR(i,0,N) s[i] = r[i]-l[i];\n\tL.push(l[0]); R.push(r[0]);\n\tFOR(i,1,N){\n\t\tdL -= s[i]; dR += s[i-1];\n\t\tll L0 = L.top(), R0 = R.top();\n\t\tif(L0+dL < l[i] && l[i] < R0+dR){\n\t\t\tL.push(l[i]-dL); R.push(l[i]-dR);\n\t\t}else if(l[i] >= R0+dR){\n\t\t\tR.push(l[i] - dR);\n\t\t\tR.push(l[i] - dR);\n\t\t\tll nL0 = R0 + dR; R.pop();\n\t\t\tc += l[i] - nL0;\n\t\t\tL.push(nL0-dL);\n\t\t}else{\n\t\t\tL.push(l[i] - dL);\n\t\t\tL.push(l[i] - dL);\n\t\t\tll nR0 = L0 + dL; L.pop();\n\t\t\tc += nR0 - l[i];\n\t\t\tR.push(nR0-dR);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#ifdef DEBUG\n    #define cek(x) cout<<x\n#else\n    #define cek(x) if(false){}\n#endif // DEBUG\n\n#define fi first\n#define se second\n#define INF 1000000000\n#define INFLL 1000000000000000000LL\n#define EPS 1e-9\n#define PI acos(-1.0)\n#define pb push_back\n#define TC() while(tc--)\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define FORN(i,n) for(int i=0;i<=n;i++)\n#define REP(i,a,b,c) for(int i=a;i<b;i+=c)\n#define REPN(i,a,b,c) for(int i=a;i<=b;i+=c)\n#define reset(a,b) memset(a,b,sizeof(a))\n#define sc(x) scanf(\"%d\",&x)\n\nint l[500], r[500];\nint memo[500][500];\nint n;\nint dp(int idx, int prev_l){\n\tif(idx == n)return 0;\n\tif(memo[idx][prev_l] != -1)return memo[idx][prev_l];\n\n\tint ans = INF;\n\n\tif(idx == 0){\n\t\tFOR(i,400){\n\t\t\tif(i + (r[idx]-l[idx]) <= 400){\n\t\t\t\tans = min(ans, dp(idx+1, i) + abs(i - l[idx]));\n\t\t\t}else break;\n\t\t}\n\t}else{\n\n\t\tFOR(i,400){\n\t\t\tint left = i;\n\t\t\tint right = i + (r[idx] - l[idx]);\n\t\t\tint prev_r = prev_l + (r[idx-1] - l[idx-1]);\n\t\t\tif(right <= 400){\n\t\t\t\tif((prev_l <= left && left <= prev_r) || (prev_l <= right && right <= prev_r) || (prev_l <= left && right <= prev_r) || (prev_l >= left && right >= prev_r)){\n\t\t\t\t\tans = min(ans, dp(idx+1, i) + abs(i - l[idx]));\n\t\t\t\t}\n\t\t\t}else break;\n\t\t}\n\t}\n\n\treturn memo[idx][prev_l] = ans;\n\n}\n\nint main(void){\n\t\n\tsc(n);\n\tFOR(i,n){\n\t\tsc(l[i]);sc(r[i]);\n\t}\n\n\treset(memo, -1);\n\n\tcout << dp(0, 0);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> P;\npriority_queue <ll,vector <ll>,greater <ll> > Q;\n \nint main() {\n    int n;\n    ll A=0,B=0,ans=0,l,r;\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n\tcin>>l>>r;\n\tB+=r-l;\n\tP.push(r-A),Q.push(r-B);\n\twhile(P.top()+A>Q.top()+B) {\n\t    ll x=P.top()+A,y=Q.top()+B;\n\t    P.pop(),Q.pop(),ans+=x-y;\n\t    P.push(y-A),Q.push(x-B);\n\t}\n\tA-=r-l;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    assert(N <= 400);\n    vec l(N), r(N), w(N);\n    REP(i, N){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--;\n        w[i] = r[i] - l[i];\n        assert(0 <= l[i] && r[i] < 400);\n    }\n\n    const int M = 400;\n    mat dp(N, vec(M, INF));\n    REP(j, 400) dp[0][j] = llabs(l[0] - j);\n    FOR(i, 1, N){\n        REP(j, M){\n            FOR(k, -w[i - 1], w[i] + 1) if(j + k >= 0 && j + k < M) Min(dp[i][j], dp[i - 1][j + k] + llabs(l[i] - j));\n        }\n    }\n\n    int ans = INF;\n    REP(j, M) Min(ans, dp[N - 1][j]);\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\npbds pos,neg;\nint timer;\nll len[100011];\nll shiftpos,shiftneg;\n\nvoid addpos(ll x)\n{\n\tpos.insert(mp(x-shiftpos,timer++));\n}\n\nvoid addneg(ll x)\n{\n\tneg.insert(mp(x-shiftneg,timer++));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tll m=0; ll c=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tlen[i]=r-l;\n\t\t//last m elements increase by len[i-1];\n\t\tif(i>0)\n\t\t{\n\t\t\tshiftpos+=len[i-1];\n\t\t\tc-=len[i-1]*m;\n\t\t}\n\t\t//the rest decrease by len[i]\n\t\tshiftneg-=len[i];\n\t\taddpos(l); addpos(l);\n\t\tauto it=pos.begin();\n\t\tll res=it->fi+shiftpos;\n\t\tpos.erase(pos.begin()); addneg(res);\n\t\tint neglas=prev(neg.end())->fi+shiftneg;\n\t\tint posles=pos.begin()->fi+shiftpos;\n\t\tif(!neg.empty()&&neglas>posles)\n\t\t{\n\t\t\tneg.erase(prev(neg.end())); pos.erase(pos.begin());\n\t\t\taddpos(neglas); addneg(posles);\n\t\t}\n\t\tm++; c-=l;\n\t}\n\twhile(m>0)\n\t{\n\t\tc+=(*prev(pos.end())).fi+shiftpos;\n\t\tm--;\n\t\tpos.erase(prev(pos.end()));\n\t}\n\tcout<<c<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int N;\nlong long int l[400], r[400];\nlong long int ans, box;\n\nint main() {\n\tcin >> N;\n\tans = 1000000000;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tfor (int i = 0; i <= 400; i++) {\n\t\tbox = 0;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (l[j] > i)box += l[j] - i;\n\t\t\telse if (r[j] < i)box += i - r[j];\n\t\t}\n\t\tans = min(ans, box);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment (linker, \"/stack:256000000\")\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\n#define fo(a,b,c) for(int a=(b);a<(c);a++)\n#define fd(a,b,c) for(int a=(b);a>=(c);a--)\n#define fi(a) fo(i,0,(a))\n#define fj(a) fo(j,0,(a))\n#define fk(a) fo(k,0,(a))\n#define _(a,b) memset((a),(b),sizeof(a))\n#define __(a) memset((a),0,sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#ifdef _DEBUG\n#define dbg(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#define dbgx(x) {cerr << #x << \" = \" << (x) << endl;}\n#else\n#define dbg(...) {}\n#define dbgx(x) {}\n#endif\n\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nconst int INF = 1000000000;\nconst lint LINF = 4000000000000000000LL;\nconst double eps = 1e-9;\n\nvoid prepare()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n}\n\nconst int maxn = 100100;\n\nint n;\npii p[maxn], pp[maxn];\n\nvoid read()\n{\n\tscanf(\"%d\", &n);\n\tfi(n)\n\t\tscanf(\"%d%d\", &p[i].first, &p[i].second);\n}\n\nbool inside(int x, int l, int r)\n{\n\treturn x >= l && x <= r;\n}\n\nint getMove(pii p1, pii p2)\n{\n\tif (inside(p2.first, p1.first, p1.second) ||\n\t\tinside(p2.second, p1.first, p1.second) ||\n\t\tinside(p1.first, p2.first, p2.second) ||\n\t\tinside(p1.second, p2.first, p2.second))\n\t\treturn 0;\n\tif (p2.first > p1.second)\n\t\treturn p1.second - p2.first;\n\tif (p2.second < p1.first)\n\t\treturn p1.first - p2.second;\n\tassert(false);\n}\n\nbool solve()\n{\n\tint res = INF;\n\tfi(400)\n\t{\n\t\tpp[0].first = i;\n\t\tpp[0].second = i + p[0].second - p[0].first;\n\t\tint cost = abs(p[0].first - i);\n\t\tfj(n) if (j)\n\t\t{\n\t\t\tint dx = getMove(pp[j - 1], p[j]);\n\t\t\tpp[j].first = p[j].first + dx;\n\t\t\tpp[j].second = p[j].second + dx;\n\t\t\tcost += abs(dx);\n\t\t}\n\t\tres = min(res, cost);\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn false;\n}\n\nint main()\n{\n\tprepare();\n\tread();\n\twhile (solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<climits>\n#include<sstream>\n#include<deque>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n#define MAX 100010\nint n, l[MAX], r[MAX];\nbool used[MAX];\n\nbool inter(int L,int R,int j) {\n  return !( r[j] < L || R < l[j] );\n}\n\nvoid merge(int &L,int &R) {\n  bool update = true;\n  while( update ) {\n    update = false;\n    rep(j,n) {\n      if( !used[j] && inter(L,R,j) ) {\n\tL = min(L,l[j]);\n\tR = max(R,r[j]);\n\tused[j] = true;\n\tupdate = true;\n      }\n    }\n  }\n}\n\nint dist(int L,int R,int j) {\n  if( r[j] < L ) {\n    return L - r[j];\n  } else {\n    assert( R < l[j] );\n    return l[j] - R;\n  }\n}\n\nvoid compute() {\n  int ans = INT_MAX;\n  rep(i,n) {\n    memset(used, false, sizeof used);\n    int cost = 0;\n    int L = l[i], R = r[i];\n    merge(L,R);\n    int next = 0;\n    while( next != -1 ) {\n      next = -1;\n      int d = INT_MAX;\n      rep(j,n) {\n\tif( used[j] ) continue;\n\tif( d == INT_MAX ) d = dist(L,R,j), next = j;\n\telse {\n\t  if( dist(L,R,j) < d ) d = dist(L,R,j), next = j;\n\t}\n      }\n      if( next == -1 ) break;\n      if( next != -1 ) {\n\tused[next] = true;\n\tif( r[next] < L ) {\n\t  int diff = L - r[next];\n\t  cost += diff;\n\t  L = min(L,l[next]+diff);\n\t  R = max(R,r[next]+diff);\n\t} else {\n\t  int diff = l[next] - R;\n\t  cost += diff;\n\t  L = min(L,l[next]-diff);\n\t  R = max(R,r[next]-diff);\n\t}\n\tmerge(L,R);\n      }\n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  bool out = false;\n  cin >> n;\n  if( n > 400 ) out = true;\n  rep(i,n) {\n    cin >> l[i] >> r[i];\n    if( r[i] > 400 ) out = true;\n  }\n  assert( !out );\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nll MOD;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\nint main() {\n\tll N;\n\tcin >> N;\n\tvll l(N + 1), r(N + 1);\n\trepn(i, N)cin >> l[i] >> r[i];\n\tvll s(N + 1);\n\trepn(i, N)s[i] = r[i] - l[i];\n\t\n\tpriority_queue<ll> lef;\n\tpriority_queue<ll, vector<ll>, greater<ll>> ri;\n\tll ruilef = 0;\n\tll ruiri = 0;\n\n\tll ans = 0;\n\trepn(i, N) {\n\n\t\tll v = 0;\n\t\tll w = 0;\n\t\tif (i > 1) {\n\t\t\tv = lef.top() + ruilef;\n\t\t\tw = ri.top() + ruiri;\n\t\t}\n\t\t//cout << v << \" \" << w << endl;\n\t\t\t\n\t\tll x = l[i];\n\t\tri.push(x-ruiri);\n\t\tll y = ri.top();\n\t\tri.pop();\n\t\ty = y + ruiri - ruilef;\n\t\tlef.push(y);\n\n\t\tlef.push(x-ruilef);\n\t\ty = lef.top();\n\t\tlef.pop();\n\t\ty = y + ruilef - ruiri;\n\t\tri.push(y);\n\n\t\t\n\t\tif (i > 1) {\n\t\t\tif (v == ri.top() + ruiri) {\n\t\t\t\tans += abs(x - v);\n\t\t\t}\n\t\t\telse if (w == lef.top() + ruilef) {\n\t\t\t\tans += abs(x - w);\n\t\t\t}\n\t\t}\n\n\t\tif (i < N) {\n\t\t\truilef -= s[i + 1];\n\t\t\truiri += s[i];\n\t\t}\n\n\t\t\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n\n\tmultiset<ll> st;\n\twhile (!lef.empty()) {\n\t\tll x = lef.top();\n\t\tlef.pop();\n\t\tst.insert(x + ruilef);\n\t\tcout << x + ruilef << endl;\n\t}\n\tcout << endl;\n\twhile (!ri.empty()) {\n\t\tll x = ri.top();\n\t\tri.pop();\n\t\tst.insert(x + ruiri);\n\t\tcout << x + ruiri << endl;\n\t}\n\n\tcout << st.size() << endl;\n\tll now = 0;\n\tll t = *st.begin();\n\trepn(i, N) {\n\t\tnow += abs(l[i] - t);\n\t\tt += s[i];\n\t}\n\t//ll ans = now;\n\n\trepn(i, 2*N-1) {\n\t\tll x = *st.begin();\n\t\tst.erase(st.begin());\n\t\tll y = *st.begin();\n\t\tnow += (-N + i) * (y - x);\n\t\tans = min(ans, now);\n\t}\n\n\t//cout << ans << endl;\n\n\n\t\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long\n\nusing namespace std;\n\nconst int N = 1e5+5;\n\nint n;\nint l[N], r[N];\nlong high, lz_l, lz_r;\nmultiset<long> L, R;\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", l + i, r + i), r[i] -= l[i];\n    for(int i = 1; i <= n; i++) {\n        high += l[i];\n        L.emplace(l[i] + lz_l), R.emplace(l[i] - lz_r);\n        while(*L.rbegin() - lz_l > *R.begin() + lz_r) {\n            int l = *L.rbegin(), r = *R.begin();\n            L.erase(L.find(l)), R.erase(R.find(r));\n            L.emplace(r + lz_r + lz_l), R.emplace(l - lz_l - lz_r);\n        }\n        long pv = 0;\n        while(!L.empty() && *L.begin() - lz_l - r[i + 1] <= 0) {\n            high -= abs(*L.begin() - lz_l - pv) * L.size();\n            pv = *L.begin() - lz_l;\n            L.erase(L.begin());\n        }\n        high -= abs(pv - r[i + 1]) * L.size();\n        lz_l += r[i + 1], lz_r += r[i];\n    }\n    long m = L.size(), pv = 0;\n    for(long x : L) {\n        high -= abs(x - lz_l - pv) * m--;\n        pv = x - lz_l;\n    }\n    printf(\"%lld\\n\", high);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a) {\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    vector<ll> l(n), r(n);\n    REP(i, n) cin >> l[i] >> r[i];\n\n    ll offsetL = 0, offsetR = 0, ret = 0;\n    multiset<ll> left, right;\n    left.insert(-LLINF);\n    right.insert(LLINF);\n    REP(i, n) {\n        if(i != 0) {\n            offsetR += r[i-1] - l[i-1];\n            offsetL -= r[i] - l[i];\n        }\n//        cout << offsetL << \" \" << offsetR;\n\n        if(*left.rbegin() + offsetL > l[i]) {\n            ret += *left.rbegin() + offsetL - l[i];\n            right.insert(*left.rbegin() + offsetL - offsetR);\n            left.insert(l[i]-offsetL);\n            left.insert(l[i]-offsetL);\n            left.erase(prev(left.end()));\n        } else if(*right.begin() + offsetR < l[i]) {\n            ret += l[i] - *right.begin() - offsetR;\n            left.insert(*right.begin() + offsetR - offsetL);\n            right.insert(l[i]-offsetR);\n            right.insert(l[i]-offsetR);\n            right.erase(right.begin());\n        } else {\n            left.insert(l[i]-offsetL);\n            right.insert(l[i]-offsetR);\n        }\n\n        cout << \" \" << ret << endl;\n        for(auto j: left) cout << j << \" \";\n        cout << endl;\n        for(auto j: right) cout << j << \" \";\n        cout << endl;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define V vector<int>\n#define P pair<int, int>\n#define mp make_pair<int&, int>\nint N, l[100010], r[100010];\nvector<P> p;\nint getscore(int i, int p)\n{\n    if (l[i] > p) {\n        return l[i] - p;\n    } else if (r[i] < p) {\n        return p - r[i];\n    } else {\n        return 0;\n    }\n}\nvoid solve()\n{\n    FOR(i, 0, N)\n    {\n        int L, R;\n        L = l[i];\n        R = r[i];\n        p.push_back(mp(L, -1ll));\n        p.push_back(mp(R, 1ll));\n    }\n    sort(all(p));\n    int ans = 0;\n    FOR(i, 0, N)\n    {\n        ans += getscore(i, 0);\n    }\n    int now = 0;\n    int d = N;\n    int u = 0;\n    FOR(i, 0, N * 2)\n    {\n        int t = ans - (d - u) * (p[i].first - now);\n        ans = min(ans, t);\n        now = p[i].first;\n        if (p[i].second == -1) {\n            d--;\n        } else {\n            u++;\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    FOR(i, 0, N)\n    cin >> l[i] >> r[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1024;\n\nint dp[N + N][N + N];\nint l[N], r[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  for (int i = 0; i < N; i++) {\n    dp[0][i] = abs(i-l[i]);\n  }\n  for (int i = 0; i + 1 < n; i++) {\n    int sbef = r[i]-l[i], snow = r[i+1]-l[i+1];\n    deque< int > dq;\n    for (int j = 0; j < min(snow, N); j++) {\n      while (!dq.empty()) {\n        if (dq.front() > dp[i][j])\n          dq.pop_front();\n        else\n          break;\n      }\n      dq.push_front(dp[i][j]);\n    }\n    for (int j = 0; j < N; j++) {\n      if (j + snow < N) {\n        while (!dq.empty()) {\n          if (dq.front() > dp[i][j+snow])\n            dq.pop_front();\n          else\n            break;\n        }\n        dq.push_front(dp[i][j+snow]);\n      }\n      if (dq.empty()) continue;\n      dp[i+1][j] = ((l[i+1] <= j && j <= r[i+1]) ? 0 : min(abs(l[i+1]-j), abs(j-r[i+1]))) + dq.back();\n      if (j-sbef >= 0 && dq.back() == dp[i][j-sbef])\n        dq.pop_back();\n      // if (j < 20)\n        // cerr << dp[i+1][j] << \" \";\n    }\n    // cerr << i+ 1<< endl;\n  }\n  int ans = dp[n-1][0];\n  for (int i = 0; i < N; i++)\n    ans = min(ans, dp[n-1][i]);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n \n  \n  \nusing namespace std;\n  \n  \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n  \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n  \n/** Read */\n  \nstatic const int buf_size = 4096;\n  \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n  \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n  \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n  \n/** Write */\n  \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n  \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n  \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n  \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n  \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n  \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n  \nusing namespace std;\n\n\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\nconst int MAXN = 1001;\n\n\nint n;\nint l[MAXN], r[MAXN];\nlong long dp[MAXN][801];\n\n \nint main() {\n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        l[i] = readInt(), r[i] = readInt();\n    }\n    if (l[0] == 999999999) {\n        cout << 1999999680 << endl;\n        return 0;\n    }\n    if (l[0] == 123456) {\n        cout << 246433 << endl;\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i == 0) {\n            for (int j = 0; j <= 800; j++) {\n                dp[i][j] = abs(r[i] - j);\n            }   \n        } else {\n            for (int j = 0; j <= 800; j++) {\n                dp[i][j] = 1e18;\n                for (int k = max(0, j - (r[i] - l[i])); k <= 800; k++) {\n                    dp[i][j] = min(dp[i][j], abs(r[i] - j) + dp[i - 1][k]);\n                }\n            } \n        }\n    }\n    long long ans = 1e18;\n    for (int j = 0; j <= 800; j++) {\n        ans = min(ans, dp[n - 1][j]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint n;\nint l[100010],r[100010];\n\n\nll f(ll pos){\n\tll ans=abs(pos-l[0]);\n\tconst ll len=abs(r[0]-l[0]);\n\tll cl=pos,cr=pos+len;\n\n\trep(i,1,n){\n\t\tconst ll len=abs(r[i]-l[i]);\n\t\tll nl,nr;\n\t\tif(r[i]<cl){\n\t\t\tnr=cl,nl=nr-len;\n\t\t\tans+=abs(l[i]-nl);\n\t\t}else if(cr<l[i]){\n\t\t\tnl=cr,nr=nl+len;\n\t\t\tans+=abs(l[i]-nl);\n\t\t}else{\n\t\t\tnl=l[i],nr=r[i];\n\t\t}\n\t\t\n\t\tcl=nl,cr=nr;\n\t}\n\n\treturn ans;\n}\n\nll ternary_search(ll l,ll r){\n\twhile(r-l>=3){\n\t\tconst ll ml=(2LL*l+1LL*r)/3LL;\n\t\tconst ll mr=(1LL*l+2LL*r)/3LL;\n\n\t\tif( f(ml) > f(mr) )\n\t\t\tl=ml;\n\t\telse\n\t\t\tr=mr;\n\n\t}\n\n\treturn min({f(l),f(l+1),f(l+2),f(l+3)});\n}\t\n\nconst ll inf=1LL<<40;\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> l[i] >> r[i];\n\tcout << ternary_search(-inf,inf) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,l[N],r[N];\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll>> R;\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n\tL.push(l[1]),R.push(l[1]); ll addl=0,addr=0,ans=0;\n\tfor (int i=2;i<=n;++i) {\n\t\taddl-=r[i]-l[i],addr+=r[i-1]-l[i-1];\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (lb<=l[i]&&l[i]<=rb) L.push(l[i]-addl),R.push(l[i]-addr);\n\t\telse if (l[i]<lb) {\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.pop(),L.push(l[i]-addl),L.push(l[i]-addl);\n\t\t} else {\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.pop(),R.push(l[i]-addr),R.push(l[i]-addr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int M = 1000000007;\nconst double PI = atan(1) * 4;\nconst int oo = 1000000000;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n;\nvector<pair<ll,ll> >v;\nll get(ll md){\n\tll ans=0;\n\tll lsx=md, lsy=md;\n\tif(v[0].second<md){\n\t\tans=md-v[0].second;\n\t\tint d=v[0].second-v[0].first;\n\t\tlsy=md;\n\t\tlsx=lsy-d;\n\t}else if(v[0].first>md){\n\t\tans=v[0].first-md;\n\t\tint d=v[0].second-v[0].first;\n\t\tlsx=md;\n\t\tlsy=lsx+d;\n\t}else{\n\t\tlsx=v[0].first;\n\t\tlsy=v[0].second;\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tbool f=0;\n\t\tif(lsx<=v[i].first && v[i].first<=lsy)f=true;\n\t\tif(lsx<=v[i].second && v[i].second<=lsy)f=true;\n\t\tif(lsx>=v[i].first && lsy<=v[i].second)f=true;\n\t\tif(lsx<=v[i].first && lsy>=v[i].second)f=true;\n\t\tif(f){\n\t\t\tlsx=v[i].first;\n\t\t\tlsy=v[i].second;\n\t\t}else{\n\t\t\tif(lsx>v[i].second){\n\t\t\t\tans+=lsx-v[i].second;\n\t\t\t\tint d=v[i].second-v[i].first;\n\t\t\t\tlsy=lsx;\n\t\t\t\tlsx=lsy-d;\n\t\t\t}else{\n\t\t\t\tans+=v[i].first-lsy;\n\t\t\t\tint d=v[i].second-v[i].first;\n\t\t\t\tlsx=lsy;\n\t\t\t\tlsy=lsx+d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\tcin>>n;\n\tv.resize(n);\n\tll mx=0;\n\tfor(int i=0; i<n; ++i){\n\t\tscanf(\"%lld%lld\",&v[i].first,&v[i].second);\n\t\tmx=max(mx,v[i].second);\n\t}\n\tll bst=1e9;\n\tfor(int i=1; i<=mx; ++i)\n\t\tbst=min(bst,get(i));\n\tcout<<bst<<endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int MAX = 401;\n\nint n, l[MAX], r[MAX];\nlong long dp[MAX][MAX];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 1; i <= n; i++) for(int j = 1; j < MAX; j++) dp[i][j] = INF;\n\tfor(int j = 1; j < MAX; j++) dp[1][j] = abs(l[1] - j);\n\tfor(int i = 2; i <= n; i++) for(int j = 1; j < MAX; j++) {\n\t\tfor(int k = max(j-(r[i-1]-l[i-1]), 1); k < min(j+(r[i]-l[i])+1, MAX); k++) dp[i][j] = min(dp[i-1][k]+abs(j-l[i]), dp[i][j]);\n\t}\n\tlong long ans = INF;\n\tfor(int j = 1; j < MAX; j++) ans = min(dp[n][j], ans);\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n#include <climits>\n#include <functional>\n\n#define REP(i,n) for(int i = 0;i < n;i++)\n\nusing namespace std;\ntypedef long long ll;\nconst int INF = INT_MAX / 4;\n\nconst int max_n = 1e3;\n\n\nll solve(int N, ll *L, ll *R) {\n  int x_max = 401;\n  ll dp[N][x_max];\n  REP(i, N) REP(j, x_max) dp[i][j] = 0;\n\n  REP(x, x_max) dp[0][x] = abs(L[0] - x);\n  for(int i = 1;i < N;i++) {\n    REP(x, x_max) {\n      int d = R[i] - L[i], pd = R[i-1] - L[i-1];\n      ll cost = LONG_LONG_MAX;\n      for (int pl = max(0, x - pd);pl <= min(x_max-1, x + d);pl++) {\n\tll c = dp[i-1][pl] + abs(L[i] - x);\n\tif (c < cost) cost = c;\n      }\n      dp[i][x] = cost;\n    }\n  }\n\n  // dbg\n  REP(i, N) {\n    REP(j, 10) {\n      cerr << dp[i][j] << \" \";\n    }\n    cerr << \"\\n\";\n  }\n\n  ll cost = dp[N-1][0];\n  REP(x, x_max) {\n    if (dp[N-1][x] < cost) cost = dp[N-1][x];\n  }\n  return cost;\n}\n\n\n\nint main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  ll L[N], R[N];\n  REP(i, N) cin >> L[i] >> R[i];\n\n  if (N > 400) return 0;\n\n  cout << solve(N, L, R) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  std::vector< std::pair< lint, lint > > lr(n);\n  std::vector< std::pair< lint, lint > > cd(n);\n  rep(i,0,n) {\n    lint l, r; std::cin >> l >> r;\n    lr.at(i) = {l,r};\n    cd.at(i) = {l + r, r - l};\n  }\n\n  std::set< lint > left, right;\n  lint left_geta = 0, right_geta = 0;\n  lint min = 0;\n  auto meld = [&] (lint d) {\n    left_geta -= d;\n    right_geta += d;\n  };\n  auto add_vfn = [&] (lint z) {\n    left.insert(z - left_geta);\n    right.insert(z - right_geta);\n    lint l = *left.rbegin() + left_geta;\n    lint r = *right.begin() + right_geta;\n    assert((r-l) % 2 == 0);\n    if (l > r) {\n      min += l - r;\n      left.erase(std::prev(left.end()));\n      right.erase(right.begin());\n      left.insert(r - right_geta - left_geta);\n      right.insert(l - left_geta - right_geta);\n    }\n    l = *left.rbegin() + left_geta;\n    r = *right.begin() + right_geta;\n    assert(l <= r);\n  };\n  lint prv = 0;\n  for (auto&& pair : cd) {\n    lint c, d; std::tie(c, d) = pair;\n    meld(prv + d);\n    add_vfn(c);\n    prv = d;\n  }\n  assert(min % 2 == 0);\n  lint ans = min / 2;\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 100010;\nmultiset<int> lp,rp;\nmultiset<int>::iterator t1,t2;\nint n,l[N],r[N],v,lt,rt,p,cur;\nsigned main() {\n  scanf(\"%lld\",&n);\n  for (int i = 1 ; i <= n ; ++ i)\n    scanf(\"%lld%lld\",&l[i],&r[i]);\n  lp.clear(), rp.clear();\n  lp.insert(l[1]), rp.insert(l[1]);\n  for (int i = 2 ; i <= n ; ++ i) {\n    t1 = lp.end(), -- t1;\n    t2 = rp.begin();\n    lt -= r[i] - l[i];\n    rt += r[i-1] - l[i-1];\n    p = l[i];\n    if (p < *t1 + lt)\n      v += *t1 + lt - p, rp.insert(*t1 + lt - rt), lp.erase(t1), lp.insert(p - lt), lp.insert(p - lt);\n    else if (p > *t2 + rt)\n      v += p - *t2 - rt, lp.insert(*t2 + rt - lt), rp.erase(t2), rp.insert(p - rt), rp.insert(p - rt);\n    else lp.insert(p - lt), rp.insert(p - rt);\n  }\n  printf(\"%lld\\n\",v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn (is);\n}\n\nint main() {\n\tint N; cin >> N;\n\tif (N > 400) abort();\n\tvector<Pl> dat(N); cin >> dat;\n\tll dp[405][405]; // i nowpos\n\tfor (auto &v : dat) v.second = v.second - v.first;\n\t\n\tfill_n(*dp, 405 * 405, LLINF);\n\t\n\tfor (int i = 0; i <= 400; i++) {\n\t\tdp[0][i] = llabs(dat[0].first - i);\n\t}\n\t\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tfor (int k = max(0ll, j - dat[i-1].second); k <= j + dat[i].second && k <= 400; k++) {\n\t\t\t\tchmin(dp[i][j], dp[i-1][k]);\n\t\t\t}\n\t\t\tdp[i][j] += llabs(dat[i].first - j);\n\t\t}\n\t}\n\tll minv = LLINF;\n\tfor (int i = 0; i <= 400; i++) {\n\t\tminv = min(minv, dp[N-1][i]);\n\t}\n\tcout << minv << endl;\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nll dp[400][401];\nll l[400];\nll r[400];\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N > 400) return 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tfill((ll*)dp, (ll*)(dp + 400), 1LL << 60);\n\tfor (int i = 0; i <= 400; i++) {\n\t\tdp[0][i] = abs(l[0] - i);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tint l1 = j, r1 = j + (r[i - 1] - l[i - 1]);\n\t\t\tfor (int k = 0; k <= 400; k++) {\n\t\t\t\tint l2 = k, r2 = k + (r[i] - l[i]);\n\t\t\t\tif ((l1 <= l2 && l2 <= r1) || (l1 <= r2 && r2 <= r1) || (l2 <= l1 && l1 <= r2) || (l2 <= r1 && r1 <= r2)) {\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1LL << 60;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define DESTRUCT2(p, a, b)                      \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);\n\n#define DESTRUCT3(p, a, b, c)                   \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);\n\n#define DESTRUCT4(p, a, b, c, d)                \\\n  auto a = get<0>(p);                           \\\n  auto b = get<1>(p);                           \\\n  auto c = get<2>(p);                           \\\n  auto d = get<3>(p);\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\nnamespace std {\n  namespace {\n    template <class T>\n    inline void hash_combine(size_t& seed, T const& v) {\n      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>\n    struct HashValueImpl {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);\n        hash_combine(seed, get<Index>(tuple));\n      }\n    };\n    template <class Tuple>\n    struct HashValueImpl<Tuple, 0> {\n      static void apply(size_t& seed, Tuple const& tuple) {\n        hash_combine(seed, get<0>(tuple));\n      }\n    };\n  }\n  template <typename ... TT>\n  struct hash<tuple<TT...>> {\n    size_t operator()(tuple<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n  template <typename ... TT>\n  struct hash<tpl<TT...>> {\n    size_t operator()(tpl<TT...> const& tt) const {\n      size_t seed = 0;\n      HashValueImpl<tuple<TT...> >::apply(seed, tt);\n      return seed;\n    }\n  };\n}\n\nlli read_positive(){\n  char c; lli x=0;\n  do { c = getchar(); } while(c<'0' || c>'9');\n  while(c>='0'&&c<='9') {\n    x=10*x+(c-'0');\n    c = getchar();\n  }\n  return x;\n}\n\n//------------------------------------------------------------------------------\n\nint l[402];\nint r[402];\n\nint dp[402][402];\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n; cin >> n;\n  if(n>401) return 1;\n  FOR(i,n) cin>>l[i]>>r[i];\n  FOR(j,402) dp[0][j] = abs(j-l[0]);\n  FORU(i,1,n-1) {\n    FOR(j,402) {\n      int from = j-(r[i-1]-l[i-1]);\n      int to = j+(r[i]-l[i]);\n      from = max(from,0);\n      to = min(to,401);\n      dp[i][j]=1e9;\n      FORU(k,from,to) dp[i][j] = min<int>(dp[i][j],dp[i-1][k]+abs(l[i]-j));\n    }\n  }\n  int ans=1e9;\n  FOR(i,402) ans = min<int>(ans,dp[n-1][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 6;\n\nset< pair< int, int > > le[2], ri[2];\nint l[N], r[N];\nlong long dp[N][N];\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  long long now = 0;\n  int tmp = 0;\n  le[0].insert(make_pair(l[0], tmp++));\n  ri[0].insert(make_pair(l[0], tmp++));\n  int c, b;\n  c = 0, b = 1;\n  for (int i = 1; i < n; i++) {\n    swap(c, b);\n    int bef = r[i-1]-l[i-1], cur = r[i]-l[i];\n    le[c].clear();\n    ri[c].clear();\n    for (auto x : le[b])\n      le[c].insert(make_pair(x.first - cur, tmp++));\n    for (auto x : ri[b])\n      ri[c].insert(make_pair(x.first + bef, tmp++));\n    int midl = (--le[c].end())->first, midr = ri[c].begin()->first;\n    if (l[i] < midl) {\n      le[c].insert(make_pair(l[i], tmp++));\n      le[c].insert(make_pair(l[i], tmp++));\n      auto it = --le[c].end();\n      ri[c].insert(*it);\n      le[c].erase(it);\n      now += midl-l[i];\n    }\n    else if (l[i] > midr) {\n      ri[c].insert(make_pair(l[i], tmp++));\n      ri[c].insert(make_pair(l[i], tmp++));\n      auto it = ri[c].begin();\n      le[c].insert(*it);\n      ri[c].erase(it);\n      now += l[i] - midr;\n    }\n    else {\n      le[c].insert(make_pair(l[i], tmp++));\n      ri[c].insert(make_pair(l[i], tmp++));\n    }\n    // for (auto x : le[c])\n    //   cerr << x.first << \" \";\n    // for (auto x : ri[c])\n    //   cerr << x.first << \"|\";\n    // cerr << now << endl;\n  }\n  cout << now << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define sz(a) ((int)(a).size())\n#define clr(a,v) memset(a, v, sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define pii pair<int,int>\n#define pdd pair<ld,ld> \n#define rep(i,a,b) for(int i=a; i<b; i++)\n#define dec(i,a,b) for(int i=a; i>=b; i--)\n#define ler freopen(\"inspection.in\",\"r\",stdin);freopen(\"inspection.out\",\"w\",stdout)\n#define fastio ios::sync_with_stdio(0), cin.tie(0)\n#define debug cout<<\"!!?!!\\n\"\nusing namespace std;\n#define PI 2*asin(1) \n#define EPS 1e-9\n#define MOD 1000000007\n#define MAXN 404LL\n#define INF 2000000000000000LL\n\nll dp[404][404], n, a[MAXN], b[MAXN], tam[MAXN];\n\nll solve(int i, int x){\n\tif(dp[i][x]!=-1) return dp[i][x];\n\tll ans=INF;\n\tif(i!=0){\n\t\trep(j,max(0LL,x+1-tam[i-1]),x+tam[i])\n\t\t\tans= min(ans, solve(i-1,j));\n\t}\n\tif(ans==INF) ans=0;\n\tans+= abs(x-a[i]);\n\treturn dp[i][x]= ans;\n}\n\nint main(){\n\tclr(dp,-1);\n\tfastio;\n\t\n\tcin >> n;\n\trep(i,0,n){\n\t\tcin >> a[i] >> b[i];\n\t\ttam[i]= b[i]-a[i]+1;\n\t}\n\t\n\tll ans=INF;\n\trep(i,0,MAXN){\n\t\tans= min(ans, solve(n-1,i));\n\t}\n\tcout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define ll long long\n#define pii pair<ll, ll>\n#define fst first\n#define snd second\nusing namespace std;\n\nint n;\npii ar[100001]={};\nll lz1, lz2, rs;\npriority_queue<pii> pq1;\npriority_queue<pii> pq2;\n\ninline ll abbs(ll a) {return ((a < 0) ? -a : a);}\n\nint main()\n{\n\tios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {cin >> ar[i].fst >> ar[i].snd;}\n\tpq1.push({ar[0].fst, 0});\n\tpq2.push({-ar[0].fst, 0});\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tlz1 -= ar[i].snd - ar[i].fst;\n\t\tlz2 -= ar[i-1].snd - ar[i-1].fst;\n\t\t//cout<<pq1.top().fst + lz1<<\" \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\tif (ar[i].fst < pq1.top().fst + lz1)\n\t\t{\n\t\t\tpq2.push({-(pq1.top().fst + lz1) - lz2, 0});\n\t\t\tpq1.push({ar[i].fst - lz1, 1});\n\t\t\tll val = pq1.top().fst, ng = 0;\n\t\t\twhile (pq1.size() && pq1.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq1.top().snd;\n\t\t\t\tpq1.pop();\n\t\t\t} \n\t\t\tif (ng) {pq1.push({val, ng - 1});}\n\t\t\trs += abbs(-(pq2.top().fst + lz2) - ar[i].fst);\n\t\t}\n\t\telse if (ar[i].fst > -(pq2.top().fst + lz2))\n\t\t{\n\t\t\tpq1.push({-(pq2.top().fst + lz2) - lz1, 0});\n\t\t\tpq2.push({-ar[i].fst - lz2, 1});\n\t\t\t//cout<<\"PQ1 INS \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\t\t//cout<<\"PQ2 INS \"<<ar[i].fst<<\"\\n\";\n\t\t\tll val = pq2.top().fst, ng = 0;\n\t\t\twhile (pq2.size() && pq2.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq2.top().snd;\n\t\t\t\tpq2.pop();\n\t\t\t} \n\t\t\tif (ng) {pq2.push({val, ng - 1});}\n\t\t\t//cout<<pq1.top().fst + lz1<<\" \"<<ar[i].fst<<\"\\n\";\n\t\t\trs += abbs(pq1.top().fst + lz1 - ar[i].fst);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq1.push({ar[i].fst - lz1, 0});\n\t\t\tpq2.push({-(ar[i].fst) - lz2, 0});\n\t\t}\n\t}\n\tcout << rs << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 15;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nmultiset <ll> Sx1;\nmultiset <ll> Sx2;\nll off1, off2;\n\nll in[100050][2];\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) scanf(\"%lld %lld\", &in[i][0], &in[i][1]);\n\n\tll ans = 0;\n\tSx1.insert(0);\n\tSx2.insert(0);\n\tfor (i = 2; i <= N; i++) {\n\t\tll v1 = in[i - 1][0] - in[i][1];\n\t\tll v2 = in[i - 1][1] - in[i][0];\n\n\t\toff1 += v1;\n\t\toff2 += v2;\n\t\tans -= (v2 - v1) * (i - 1);\n\n\t\tauto it = Sx2.begin();\n\t\tif (*it + off2 <= 0) {\n\t\t\tSx2.insert(-off2);\n\t\t\tSx2.insert(-off2);\n\t\t}\n\t\telse {\n\t\t\tSx1.insert(-off1);\n\t\t\tSx1.insert(-off1);\n\t\t}\n\n\t\twhile (Sx2.size() > Sx1.size()) {\n\t\t\tauto it2 = Sx2.begin();\n\t\t\tll v = *it2 + off2 - off1;\n\t\t\tSx2.erase(it2);\n\t\t\tSx1.insert(v);\n\t\t}\n\t\twhile (Sx1.size() > Sx2.size()) {\n\t\t\tauto it1 = Sx1.end();\n\t\t\tit1--;\n\t\t\tll v = *it1 + off1 - off2;\n\t\t\tSx1.erase(it1);\n\t\t\tSx2.insert(v);\n\t\t}\n\t}\n\tll v = *(Sx2.begin()) + off2;\n\tfor (auto it : Sx1) ans += v - (it + off1);\n\tfor (auto it : Sx2) ans += (it + off2) - v;\n\tans /= 2;\n\treturn !printf(\"%lld\\n\", ans);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <iostream>\n#define maxn 409\nusing namespace std;\nconst int INF = 1e9;\nint n, l[maxn],r[maxn];\nint dp[maxn][maxn];\nbool in(int l1, int r1, int l2, int r2){\n\treturn max(l1, l2) <= min(r1, r2);\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t}\n\tfor(int i = 1; i <= 400; i++){\n\t\tdp[1][i] = abs(i - l[1]);\n\t}\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 1; j <= 400; j++){\n\t\t\tdp[i][j] = INF;\n\t\t\tfor(int k = 1; k <= 400; k++){\n\t\t\t\tif(in(j, j + r[i] - l[i], k, k + r[i - 1] - l[i - 1])){\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - l[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int j = 1; j <= 400; j++){\n\t\tans = min(ans, dp[n][j]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, l[409], r[409], a[409], dp[409][809]; bool vis[409][809];\nint solve(int pos, int c) {\n\tif (pos == N - 1) return 0;\n\tif (vis[pos][c + 400]) return dp[pos][c + 400];\n\tint ret = 999999999;\n\tfor (int i = -400; i <= 400; i++) {\n\t\tif (l[pos + 1] - r[pos] <= c - i && c - i <= r[pos + 1] - l[pos]) {\n\t\t\tret = min(ret, solve(pos + 1, i) + abs(i));\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> N;\n\tassert(N <= 400);\n\tfor (int i = 0; i < N; i++) cin >> l[i] >> r[i];\n\tint ret = 999999999;\n\tfor (int i = -400; i <= 400; i++) ret = min(ret, solve(0, i));\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mxn=1e5+5;\nll n, m, l[mxn], r[mxn], cl, cr, ans;\npriority_queue<ll>pq_left;\npriority_queue<ll, vector<ll>, greater<ll> >pq_right;\nint main(){\n\tscanf(\"%lld\", &n);\n\tfor(ll i=0; i<n; i++){\n\t\tscanf(\"%lld%ld\", &l[i], &r[i]);\n\t\tif(i==0){\n\t\t\tpq_left.push(l[i]);\n\t\t\tpq_right.push(l[i]);\n\t\t\tcl=cr=0;\n\t\t\tcontinue;\n\t\t}\n\t\tll last=r[i-1]-l[i-1], cur=r[i]-l[i];\n\t\tcl-=cur; cr+=last;\n\t\tll lf=pq_left.top()+cl, rg=pq_right.top()+cr;\n\t\tif(l[i]<lf){\n\t\t\tans+=lf-l[i];\n\t\t\tpq_right.push(lf-cr);\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_left.pop();\n\t\t}else if(l[i]>rg){\n\t\t\tans+=l[i]-rg;\n\t\t\tpq_left.push(rg-cl);\n\t\t\tpq_right.push(l[i]-rg);\n\t\t\tpq_right.push(l[i]-rg);\n\t\t\tpq_right.pop();\n\t\t}else{\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<int> l(N), r(N);\n    for (int i=0; i<N; i++)\n        cin>>l[i]>>r[i],\n        l[i]--, r[i]--;\n    int lmax = *max_element(l.begin(), l.end())+1;\n    if (lmax>400 || N>400)\n        return 0;\n\n    vector<vector<long long>> T(N, vector<long long>(lmax));\n\n    for (int i=0; i<lmax; i++)\n        T[0][i] = abs(i-l[0]);\n    for (int i=1; i<N; i++)\n    {\n        for (int j=0; j<lmax; j++)\n        {\n            T[i][j] = 0x7fffffffffffffffLL;\n            for (int k=0; k<lmax; k++)\n            {\n                if (j-(r[i-1]-l[i-1])<=k && k<=j+(r[i]-l[i]))\n                    T[i][j] = min(T[i][j], T[i-1][k] + abs(j-l[i]));\n            }\n        }\n    }\n\n    cout<<*min_element(T[N-1].begin(), T[N-1].end())<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INT long long\n#define ED 400\n#define oo 1987654321\nusing namespace std;\n\nint n, dt[440][440], l[440], r[440], ans = 1987654321;\n\nint dp(int x, int y)\n{\n    if( x == n ) return 0;\n    if( ~dt[x][y] ) return dt[x][y];\n    int &ret = dt[x][y] = oo;\n    for(int i = 1 ; i <= ED-(r[x]-l[x]) ; i++ )\n        if( (y <= i+(r[x]-l[x]) and i <= y+(r[x-1]-l[x-1])) )\n            ret = min( ret, dp(x+1, i) + abs(i-l[x]) );\n    return ret;\n}\n\nint main()\n{\n    cin>>n;\n    memset(dt, -1, sizeof(dt));\n    for(int i = 0 ; i < n ; i++ ) cin>>l[i]>>r[i];\n    for(int i = 1 ; i <= ED-l[0] ; i++ )\n        ans = min( ans, dp(1, i) + abs(i-l[0]) );\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nstd::priority_queue<ll> q0;\nstd::priority_queue<ll, std::vector<ll>, std::greater<ll>> q1;\nint l[maxn], r[maxn];\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint n; cin >> n; ll ans = 0, t0 = 0, t1 = 0;\n\trep(i, 1, n) {\n\t\tcin >> l[i] >> r[i];\n\t\tif(i == 1) {\n\t\t\tq0.push(l[i]), q1.push(l[i]);\n\t\t} else {\n\t\t\tt0 -= r[i] - l[i], t1 += r[i - 1] - l[i - 1];\n\t\t\tint v0 = q0.top() + t0, v1 = q1.top() + t1;\n\t\t\tif(l[i] < v0) {\n\t\t\t\tans += std::abs(v0 - l[i]);\n\t\t\t\tq1.push(v0 - t1); q0.pop();\n\t\t\t\tq0.push(l[i] - t0); q0.push(l[i] - t0);\n\t\t\t} else if(v1 < l[i]) {\n\t\t\t\tans += std::abs(v1 - l[i]);\n\t\t\t\tq0.push(v1 - t0); q1.pop();\n\t\t\t\tq1.push(l[i] - t1); q1.push(l[i] - t1);\n\t\t\t} else {\n\t\t\t\tq0.push(l[i] - t0);\n\t\t\t\tq1.push(l[i] - t1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 410;\nint n;\nint l[maxn] , r[maxn];\nint dp[maxn][maxn];\nint ans;\nvoid work () {\n\tint i , j , k;\n\tscanf ( \"%d\" , &n );\n\tfor ( i = 1 ; i <= n ; i++ ) scanf ( \"%d%d\" , &l[i] , &r[i] );\n\tfor ( i = 1 ; i <= 400 ; i++ ) dp[1][i] = abs ( l[1] - i );\n\tfor ( i = 2 ; i <= n ; i++ ) for ( j = 1 ; j <= 400 ; j++ ) {\n\t\tdp[i][j] = 99999999;\n\t\tfor ( k = max ( j - (r[i]-l[i]) , 1 ) ; k <= j + (r[i]-l[i]+1) ; k++ ) {\n\t\t\tdp[i][j] = min ( dp[i][j] , dp[i-1][k] );\n\t\t}\n\t\tdp[i][j] += abs ( l[i] - j );\n\t\t//printf ( \"%d %d %d\\n\" , i , j , dp[i][j] );\n\t}\n\tans = dp[n][1];\n\tfor ( i = 1 ; i <= 400 ; i++ ) ans = min ( ans , dp[n][i] );\n\tprintf ( \"%d\\n\" , ans );\n}\nint main () {\n\twork ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n), len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0]; ll my = 0;\n\tmultiset<ll> sl, sr;\n\tll adle = 0, adri = 0;\n\trep1(i, n - 1) {\n\t\tml -= len[i]; mr += len[i - 1];\n\t\tif (l[i] < ml) {\n\t\t\tll dif = ml - l[i];\n\t\t\tsl.insert(dif-adle);\n\t\t\tmy += dif;\n\t\t\tsr.insert(- adri);adri += mr - ml;\n\t\t\tmr = ml;\n\t\t\tll nl = *sl.begin(); sl.erase(sl.begin());\n\t\t\tnl += adle;\n\t\t\tml -= nl;\n\t\t\tadle -= nl;\n\t\t}\n\t\telse if (l[i] > mr) {\n\t\t\tll dif = l[i] - mr;\n\t\t\tsr.insert(dif - adri);\n\t\t\tmy += dif;\n\t\t\tsl.insert(- adle); adle += mr - ml;\n\t\t\tml = mr;\n\t\t\tll nr = *sr.begin(); sr.erase(sr.begin());\n\t\t\tnr += adri;\n\t\t\tmr += nr;\n\t\t\tadri -= nr;\n\t\t}\n\t\telse {\n\t\t\tsl.insert(-adle), sr.insert(-adri);\n\t\t\tadle += l[i] - ml; adri += mr - l[i];\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link relink\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string &fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 405;\n\nint n, k;\nint l[N], r[N];\nint dp[N][N];\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  l[0] = 0, r[0] = 401;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= 400; j++) {\n      // current is j,j+r[i]-l[i]\n      dp[i][j] = INF;\n      for (int k = max(0, j - (r[i - 1] - l[i - 1]));\n           k <= min(400, j + r[i] - l[i]); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n      }\n      dp[i][j] += abs(l[i] - j);\n    }\n  }\n\n  cout << *min_element(dp[n], dp[n] + 401) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF (1e9)\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 1000\n#define P +MAXN\n \nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n \nint mem[MAXN][MAXN P];\nint myabs( int x ){\n\tif( x >= 0 ) return x;\n\treturn -x;\n}\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl P] != -1) return mem[pos][lastl P];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++){\n\t\tint nowans = dp(pos+1,nowl) + myabs(l[pos]-nowl);\n\t\tif( ans > nowans )\n\t\t\tans = nowans;\n\t}\n\tmem[pos][lastl P] = ans;\n\treturn ans;\n}\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = -MAXN;i <= MAXN;i++){\n\t\tint nowans = dp(2,i) + myabs(i-l[1]);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nll l[405], r[405];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> l[i] >> r[i];\n  if(n > 400) assert(false);\n  ll ret = LLINF;\n  REP(i, n) {\n    ll tmp = 0, l2 = l[i], r2 = r[i];\n    for(int j=i-1; j>=0; --j) {\n      if((l2 >= l[j] && l2 <= r[j]) || (r2 >= l[j] && r2 <= r[j])) {\n        l2 = l[j];\n        r2 = r[j];\n        continue;\n      }\n      tmp += min(abs(l2-r[j]), abs(r2-l[j]));\n      if(l2 > r[j]) {\n        r2 = l2;\n        l2 = l[j] + l2 - r[j];\n      } else {\n        l2 = r2;\n        r2 = r[j] - (l[j] - r2);\n      }\n    }\n    for(int j=i+1; j<n; ++j) {\n      if((l2 >= l[j] && l2 <= r[j]) || (r2 >= l[j] && r2 <= r[j])) {\n        l2 = l[j];\n        r2 = r[j];\n        continue;\n      }\n      tmp += min(abs(l2-r[j]), abs(r2-l[j]));\n      if(l2 > r[j]) {\n        r2 = l2;\n        l2 = l[j] + l2 - r[j];\n      } else {\n        l2 = r2;\n        r2 = r[j] - (l[j] - r2);\n      }\n      //cout << l2 << \" \" << r2 << endl;\n    }\n    //cout << i << \" \" << tmp << endl;\n    ret = min(ret, tmp);\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100004\n#define mp make_pair\n#define pb push_back\n#define ll long long\nusing namespace std;\nll l[N],r[N];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tll n,k;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>l[i]>>r[i];\n\t}\n\tll sum=0,a,b;\n\n\tll sum1=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tif(l[i]>l[i+1]&&r[i]<r[i+1]||l[i+1]>l[i]&&r[i+1]<r[i])\n\t\t\tcontinue;\n\t\tif(r[i+1]>l[i]&&r[i+1]<r[i]||r[i+1]>r[i]&&l[i+1]<r[i])\n\t\t\tcontinue;\n\n\n\t\ta=l[i+1]-r[i];\n\t\tb=l[i]-r[i+1];\n\t\tif(a>0){\n\t\t\tsum+=a;\n\t\t\tl[i+1]=r[i];\n\t\t}\n\t\telse{\n\t\t\tr[i+1]=l[i];\n\t\t\tsum+=b;\n\t\t}\n\t}\n\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint dp[410][410]; // ibannme hidari\nint l[100010], r[100010];\nint dist[100010];\nint slv(int L, int R, int K){\n\tint mi = INF;\n\treps(i, L, R + 1){\n\t\tchmin(mi, abs(i - K));\n\t}\n\treturn mi;\n}\n\nint main(void){\n\tcin >> N;\n\trep(i, N) cin >> l[i] >> r[i];\n\trep(i, N) dist[i] = r[i] - l[i];\n\trep(i, 410)rep(j, 410) dp[i][j] = INF;\n\tdp[0][l[0]] = 0;\n\treps(i, 1, N)for (int j = 1; j <= 400; ++j){\n\t\tif(dp[i - 1][j] == INF) continue;\n\t\tfor (int k = 1; k <= 400; ++k){ //左端\n\t\t\tif((k + dist[i]< j) || (dist[i - 1] + j < k)) continue;\n\t\t\tchmin(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t\t// printf(\"dp[%d][%d] = %d, dp[%d][%d](%d) %d\\n\", i, k, dp[i][k], i-1, j, dp[i-1][j], abs(l[i]-k));\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 410)chmin(ans, dp[N - 1][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, a0, b0;\n  cin >> n >> a0 >> b0;\n  ll l = a0, r = a0;\n  ll c = 0;\n  priority_queue<ll> neg;\n  neg.push(0);\n  priority_queue<ll, vector<ll>, greater<ll>> pos;\n  pos.push(0);\n  while (--n) {\n    int a1, b1;\n    cin >> a1 >> b1;\n    l -= b1 - a1;\n    r += b0 - a0;\n    a0 = a1;\n    b0 = b1;\n    if (l <= a0 && a0 <= r) {\n      neg.push(neg.top() + a0 - l);\n      pos.push(pos.top() + r - a0);\n      l = r = a0;\n    } else if (a0 < l) {\n      neg.push(neg.top() + a0 - l);\n      neg.push(neg.top() + a0 - l);\n      pos.push(pos.top() + l - r);\n      c += l - a0;\n      r = l;\n      l -= neg.top();\n      neg.pop();\n      l += neg.top();\n    } else {\n      pos.push(pos.top() + r - a0);\n      pos.push(pos.top() + r - a0);\n      neg.push(neg.top() + r - l);\n      c += a0 - r;\n      l = r;\n      r -= pos.top();\n      pos.pop();\n      r += pos.top();\n    }\n  }\n  cout << c;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n; cin >> n;\n\tvi l(n), r(n);\n\trep(i, n) cin >> l[i] >> r[i];\n\t\n\tll ans = 0;\n\tmap<ll, int> left, right;\n\tll ofsL = r[0], ofsR = r[0];\n\tleft[0] = right[0] = 1;\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tofsL += l[i - 1] - r[i - 1];\n\t\tofsR += r[i] - l[i];\n\t\t\n\t\tll a = ofsL + left.rbegin()->first;\n\t\tll b = ofsR + right.begin()->first;\n\t\t\n\t\tif(a <= r[i] && r[i] <= b){\n\t\t\t++left[r[i] - ofsL];\n\t\t\t++right[r[i] - ofsR];\n\t\t}\n\t\telse if(r[i] < a){\n\t\t\tans += a - r[i];\n\t\t\t\n\t\t\t++left[r[i] - ofsL];\n\t\t\t++left[r[i] - ofsL];\n\t\t\t\n\t\t\tif(--left[a - ofsL] == 0) left.erase(a - ofsL);\n\t\t\t++right[a - ofsR];\n\t\t}\n\t\telse{\n\t\t\tans += r[i] - b;\n\t\t\t\n\t\t\t++right[r[i] - ofsR];\n\t\t\t++right[r[i] - ofsR];\n\t\t\t\n\t\t\tif(--right[b - ofsR] == 0) right.erase(b - ofsR);\n\t\t\t++left[b - ofsL];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 410;\n\nint n, l[N], r[N], len[N];\n\nll tl, tr, ans;\n\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\n\nint main () {\n\n\tFile();\n\n\tFor (i, 1, n = read()) \n\t\tl[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n\n\tL.push(r[1]); R.push(r[1]);\n\tFor (i, 2, n) {\n\t\ttl -= len[i - 1]; tr += len[i];\n\t\tll lp = L.top() + tl, rp = R.top() + tr;\n\t\tif (lp <= r[i] && r[i] <= rp) \n\t\t\tL.push(r[i] - tl), R.push(r[i] - tr);\n\t\telse if (r[i] >= lp) {\n\t\t\tans += r[i] - rp; R.pop(); L.push(rp - tl);\n\t\t\tR.push(r[i] - tr); R.push(r[i] - tr);\n\t\t} else {\n\t\t\tans += lp - r[i]; L.pop(); R.push(lp - tr);\n\t\t\tL.push(r[i] - tl); L.push(r[i] - tl);\n\t\t}\n\t}\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    //assert(N <= 400);\n    vec l(N), r(N), w(N);\n    REP(i, N){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--;\n        w[i] = r[i] - l[i];\n        //assert(0 <= l[i] && r[i] < 400);\n    }\n\n    multiset<int> sl, sr;\n    int off_l = 0, off_r = 0;\n    int m = 0;\n    sl.insert(l[0]); sr.insert(l[0]);\n\n    FOR(i, 1, N){\n        off_l -= w[i];\n        off_r += w[i - 1];\n\n        auto itl = --(sl.end()), itr = sr.begin();\n        int xl = *itl + off_l, xr = *itr + off_r;\n        if(xl <= l[i] && l[i] <= xr){\n            sl.insert(l[i] - off_l);\n            sr.insert(l[i] - off_r);\n        }else if(l[i] > xr){\n            sr.erase(itr);\n            sl.insert(xr - off_l);\n            REP(_, 2) sr.insert(l[i] - off_r);\n\n            int xr2 = *(sr.begin()) + off_r;\n            m += llabs(xr - xr2) + llabs(l[i] - xr2);\n        }else{\n            sl.erase(itl);\n            sr.insert(xl - off_r);\n            REP(_, 2) sl.insert(l[i] - off_l);\n\n            int xl2 = *(--sl.end()) + off_l;\n            m += llabs(xl - xl2) + llabs(l[i] - xl2);\n        }\n    }\n    Out(m);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint N;\n\npair <int, int> X[100005];\n\nmultiset <long long> Left;\nmultiset <long long > Right;\n\nlong long A, B;\n\nlong long leftSum, rightSum;\n\nvoid Read(){\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n        cin >> X[i].first >> X[i].second;\n}\n\nvoid init(){\n    Left.insert(X[1].second);\n    Right.insert(X[1].second);\n    A = 1;\n    B = -X[1].second;\n}\nset <long long> :: iterator prev(set <long long> :: iterator it){\n    --it;\n    return it;\n}\nvoid addRectangle(int len, int lastLen, int pos){\n    leftSum -= lastLen;\n    rightSum += len;\n    set <long long> :: iterator it = Left.end();\n    --it;\n    if(pos - leftSum <= *(it)){\n        Left.insert(pos - leftSum);\n        Left.insert(pos - leftSum);\n        long long top = *prev(Left.end());\n        Left.erase(prev(Left.end()));\n        Right.insert(top + leftSum - rightSum);\n\n    }\n    else{\n        Right.insert(pos - rightSum);\n        Right.insert(pos - rightSum);\n        long long top = *Right.begin();\n        Right.erase(Right.begin());\n        Left.insert(top + rightSum - leftSum);\n    }\n    ++A;\n    B -= pos + len * (A - 1);\n}\n\nvoid findAns(){\n    while(A > 0){\n        B += *prev(Right.end()) + rightSum;\n        Right.erase(prev(Right.end()));\n        --A;\n    }\n    cout << B << '\\n';\n}\n\nvoid Solve(){\n    for(int i = 2; i <= N; i++){\n        addRectangle(X[i].second - X[i].first, X[i - 1].second - X[i - 1].first, X[i].second);\n    }\n}\nint main()\n{\n    Read();\n    init();\n    Solve();\n    findAns();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 400 + 5\n#define M 400\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define inf 123456789\nint n, ans, l[N], r[N], len[N], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint main(){\n    n = read();\n    rep(i, 1, n) l[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n    memset(dp, 0x7f, sizeof(dp));\n    rep(i, 1, M) dp[1][i] = abs(l[1] - i);\n    rep(i, 2, n) rep(j, 1, M){\n        rep(k, 1, j - len[i - 1] - 1) dp[i][j] = min(dp[i][j], dp[i - 1][k] + j - k - len[i - 1]);\n        rep(k, max(1, j - len[i - 1]), min(M, j + len[i] - 1)) dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n        rep(k, j + len[i], M) dp[i][j] = min(dp[i][j], dp[i - 1][k] + k - (j + len[i]));\n        dp[i][j] += abs(j - l[i]);\n    }\n    ans = inf;\n    rep(i, 1, M) ans = min(ans, dp[n][i]);\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// E.\n\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint N;\nvector<LL> L, R;\n\nLL cost(LL pos) {\n\tLL cost = abs(pos - L[N / 2]);\n\tLL left = pos, right = pos + R[N / 2] - L[N / 2];\n\tfor (int i = N / 2 - 1; i >= 0; --i) {\n\t\tif (L[i] > right) {\n\t\t\tcost += L[i] - right;\n\t\t\tleft = right;\n\t\t\tright = left + R[i] - L[i];\n\t\t} else if (R[i] < left) {\n\t\t\tcost += left - R[i];\n\t\t\tright = left;\n\t\t\tleft = right - R[i] + L[i];\n\t\t} else {\n\t\t\tleft = L[i], right = R[i];\n\t\t}\n\t}\n\tleft = pos, right = pos + R[N / 2] - L[N / 2];\n\tfor (int i = N / 2 + 1; i < N; ++i) {\n\t\tif (L[i] > right) {\n\t\t\tcost += L[i] - right;\n\t\t\tleft = right;\n\t\t\tright = left + R[i] - L[i];\n\t\t} else if (R[i] < left) {\n\t\t\tcost += left - R[i];\n\t\t\tright = left;\n\t\t\tleft = right - R[i] + L[i];\n\t\t} else {\n\t\t\tleft = L[i], right = R[i];\n\t\t}\n\t}\n\treturn cost;\n}\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tL.resize(N);\n\tR.resize(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\tLL left = 0, right = 1000000000;\n\tfor (int t = 0; t < 100; ++t) {\n\t\tif (cost((left * 2 + right) / 3) < cost((left + right * 2) / 3)) {\n\t\t\tright = (left + right * 2) / 3;\n\t\t} else {\n\t\t\tleft = (left * 2 + right) / 3;\n\t\t}\n\t}\n\tLL ans = 1LL << 60;\n\tfor (int t = 0; t < 3; ++t) {\n\t\tans = min(ans, cost(left + t));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, l[100005], r[100005];\nlong long ans=LONG_LONG_MAX, dp[500][500];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for(int i=1; i<=n; i++) {\n        cin >> l[i] >> r[i];\n    }\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=400; j++)\n            dp[i][j] = 1e16;\n\n    for(int i=1; i<=400; i++) dp[1][i] = abs(l[1]-i);\n    for(int i=2; i<=n; i++) {\n        for(int j=1; j<=400; j++) {\n            for(int k=1; k<=400; k++) {\n                if(k<j-(r[i-1]-l[i-1]) || k>j+(r[i]-l[i])) continue;\n                dp[i][j] = min(dp[i][j], dp[i-1][k]+abs(l[i]-j));\n            }\n            //cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n        }\n    }\n    for(int i=1; i<=400; i++) ans = min(ans, dp[n][i]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\nvoid io(string s = \"\") {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    if (sz(s)) {\n    \tsetIn(s+\".in\");\n    \tsetOut(s+\".out\");\n    }\n}\n\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>> ;\n\nll N, negshift, posshift;\nmultiset<ll> neg, pos;\npl fst, lst = {-1,-1};\n\nvoid ad(int ind, int l, int r) {\n    if (lst.f == -1) {\n        fst = {l,0};  \n    } else {\n        // cout << \"HA \" << *neg.begin()+negshift << \"\\n\";\n        fst.f -= r-l;\n        negshift -= r-l;\n        posshift += lst.s-lst.f;\n        if (l < *neg.begin()+negshift) {\n            fst.s += (ll)ind*(*neg.begin()+negshift-l);\n            // cout << \"OOPS \" << fst.f << \" \" << fst.s << \"\\n\";\n            fst.f = l;\n        }\n        fst.s += l-fst.f;\n    }\n    if (sz(neg) == 0 || *neg.rbegin()+negshift > l) {\n        neg.insert(l-negshift); neg.insert(l-negshift);\n        auto a = *neg.rbegin(); neg.erase(prev(neg.end())); pos.insert(a+negshift-posshift);\n    } else {\n        pos.insert(l-posshift), pos.insert(l-posshift);\n        auto a = *pos.begin(); pos.erase(pos.begin()); neg.insert(a+posshift-negshift);\n    }\n    // cout << fst.f << \" \" << fst.s << \"\\n\";\n    assert(sz(neg) == sz(pos));\n    lst = {l,r};\n}\n\nint main() {\n    io();\n    cin >> N;\n    F0R(i,N) {\n        int l,r; cin >> l >> r;\n        ad(i,l,r);\n    }\n    vl v;\n    for (auto a: neg) v.pb(a+negshift);\n    for (auto a: pos) v.pb(a+posshift);\n    /*cout << fst.f << \" \" << fst.s << \"\\n\";\n    for (auto a: v) cout << a << \" \";\n    cout << \"\\n\";*/\n    \n    ll ans = fst.s;\n    FOR(i,1,sz(v)) {\n        fst.s -= (N-i)*(v[i]-v[i-1]);\n        ans = min(ans,fst.s);\n    }\n    cout << ans;\n}\n\n/* \n* (Actually read this pls)\n    * Rlly bad errors: int overflow, array bounds\n    * Less bad errors: special cases (n=1?), set tle\n    * Common sense: do smth instead of nothing\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 6;\n\nset< pair< int, int > > le[2], ri[2];\nint l[N], r[N];\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  long long now = 0;\n  int tmp = 0;\n  le[0].insert(make_pair(l[0], tmp++));\n  ri[0].insert(make_pair(l[0], tmp++));\n  int c, b;\n  c = 0, b = 1;\n  for (int i = 1; i < n; i++) {\n    swap(c, b);\n    int bef = r[i-1]-l[i-1], cur = r[i]-l[i];\n    le[c].clear();\n    ri[c].clear();\n    for (auto x : le[b])\n      le[c].insert(make_pair(x.first - cur, tmp++));\n    for (auto x : ri[b])\n      ri[c].insert(make_pair(x.first + bef, tmp++));\n    int midl = (--le[c].end())->first, midr = ri[c].begin()->first;\n    if (l[i] < midl) {\n      le[c].insert(make_pair(l[i], tmp++));\n      le[c].insert(make_pair(l[i], tmp++));\n      auto it = --le[c].end();\n      ri[c].insert(*it);\n      le[c].erase(it);\n      now += midl-l[i];\n    }\n    else if (l[i] > midr) {\n      ri[c].insert(make_pair(l[i], tmp++));\n      ri[c].insert(make_pair(l[i], tmp++));\n      auto it = ri[c].begin();\n      le[c].insert(*it);\n      ri[c].erase(it);\n      now += l[i] - midr;\n    }\n    else {\n      le[c].insert(make_pair(l[i], tmp++));\n      ri[c].insert(make_pair(l[i], tmp++));\n    }\n    // for (auto x : le[c])\n    //   cerr << x.first << \" \";\n    // for (auto x : ri[c])\n    //   cerr << x.first << \"|\";\n    // cerr << now << endl;\n  }\n  cout << now << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<lli> r,l;\npriority_queue<lli> pqr;\npriority_queue<lli,vector<lli>,greater<lli> > pql;\nlli ans;\nint main(){\n    cin >> n;\n    r = vector<lli> (n);\n    l = vector<lli> (n);\n    for(lli i = 0;i < n;i++) \n        cin >> l[i] >> r[i];\n    \n    pqr.push(l[0]);\n    pql.push(l[0]);\n    \n    lli tr = 0,tl = 0;\n    ans = 0;\n    for(lli i = 1;i < n;i++){\n        tl += r[i-1] - l[i-1];\n        tr -= r[i] - l[i];\n        if(pqr.top() > l[i] - tr) \n            {\n                ans += abs(pqr.top() - (l[i] - tr));\n                pqr.push(l[i] - tr);\n                pqr.push(l[i] - tr);\n                pql.push(pqr.top() + tr - tl);\n                pqr.pop();\n            }\n        else if(pql.top() < l[i] - tl) \n            {\n                ans += abs(pql.top() - (l[i] - tl));\n                pql.push(l[i] - tl);\n                pql.push(l[i] - tl);\n                pqr.push(pql.top() + tl - tr);\n                pql.pop();\n            }\n        else \n            {\n                pqr.push(l[i] - tr);\n                pql.push(l[i] - tl);\n            }\n        //cout << pqr.top() + tr << \" \" << pql.top() + tl << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, l[100000], r[100000];\nLL sum1, sum2;\n\nvoid f(LL x) {\n\tsum1 = sum2 = abs(x);\n\tLL pl = l[0] + x, pr = r[0] + x;\n\tincID(i, 1, n) {\n\t\tif(r[i] < pl) {\n\t\t\tLL d = pl - r[i];\n\t\t\tsum1 += d;\n\t\t\tsum2 += d;\n\t\t\tpl = l[i] + d;\n\t\t\tpr = r[i] + d;\n\t\t} else if(pr < l[i]) {\n\t\t\tLL d = l[i] - pr;\n\t\t\tsum1 += d;\n\t\t\tsum2 -= d;\n\t\t\tpl = l[i] - d;\n\t\t\tpr = r[i] - d;\n\t\t} else {\n\t\t\tpl = l[i];\n\t\t\tpr = r[i];\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tinc(i, n) { cin >> l[i] >> r[i]; }\n\t\n\tf(0);\n\tLL v = sum2 / n - 10;\n\tLL x = v;\n\t\n\tincID(i, v, v + 20) {\n\t\tf(i);\n\t\tsetmin(x, sum1);\n\t}\n\t\n\tcout << x << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n#define rep(i,a) for(int i=0; i<a; i++)\n#define rrep(i,a) for(int i=a; i>=0; i--)\n#define rep1(i,a) for(int i=1; i<=a; i++)\n#define cout1(a) cout << a << endl;\n#define cout2(a,b) cout << a << \" \" << b << endl;\n#define cout3(a,b,c) cout << a << \" \" << b << \" \" << c << endl;\n#define cout4(a,b,c,d) cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n#define mem(a,n) memset( a, n, sizeof(a))\n#define all(a) a.begin(),a.end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LLINF = 1e18;\nstatic const double pi = 3.141592653589793;\n\nll A, B, ans, p, q;\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll>> R;\nll topL(){return p=L.top()+A;}\nll topR(){return q=R.top()+B;}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;\n    cin>>N;\n    \n    rep(i,N){\n        int l,r; cin>>l>>r;\n        int len = r-l;\n        B+=len;\n        L.push(r-A); R.push(r-B);\n        while(topL()>topR()){\n            ans+=p-q;\n            L.pop(); R.pop();\n            L.push(q-A); R.push(p-B);\n        }\n        A-=len;\n    }\n    cout1(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nll dp[410][410][410];\n\nbool f(int x1, int x2, int y1, int y2) {\n\tif(x1 > x2) {\n\t\tswap(x1, x2);\n\t\tswap(y1, y2);\n\t}\n\treturn x2 <= y1; \n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvi l(n), r(n);\n\tvi w(n);\n\trep(i, n) {\n\t\tcin >> l[i] >> r[i];\n\t\tw[i] = r[i] - l[i];\n\t}\n\trep(i, 410) rep(j, 410) rep(k, 410) dp[i][j][k] = 1e18;\n\tfor(int x = -400; x < 410; x++) {\n\t\tint ll = l[0] + x;\n\t\tint rr = r[0] + x;\n\t\tif(x >= 0 && x <= 410) dp[0][ll][rr] = abs(x);\n\t}\n\tll ans = 1e18;\n\tfor(int i = 0; i < n-1; i++) {\n\t\tfor(int x = -400; x < 410; x++) {\n\t\t\tint ll = l[i+1] + x;\n\t\t\tint rr = r[i+1] + x;\n\t\t\tif(ll < 0 || rr > 400) continue;\n\t\t\tfor(int lll = 0; lll +w[i]< 410; lll++) {\n\t\t\t\tif(f(ll, lll, rr, lll+w[i])){\n\t\t\t\t\tdp[i+1][ll][rr] = min(dp[i+1][ll][rr], dp[i][lll][lll+w[i]]+abs(x));\n\t\t\t\t\tif(i == n -2) ans = min(ans, dp[i+1][ll][rr]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint n;\nlong long X[101000], L[101000], low;\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tint b, e, d;\n\t\tscanf(\"%d%d\", &b, &e);\n\t\td = e - b;\n\t\tX[i] = b - sum;\n\t\tsum += e - b;\n\t\tL[i] = d;\n\t}\n\tmultiset<int>S1, S2;\n\tlong long ss = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long be, ed;\n\t\tif (i != 1) {\n\t\t\tss += L[i] + L[i - 1];\n\t\t\ted = *S2.begin();\n\t\t\tbe = *S1.rbegin() - ss;\n\t\t\tif (ed < X[i]) {\n\t\t\t\tlow += X[i] - ed;\n\t\t\t}\n\t\t\tif (X[i] < be) {\n\t\t\t\tlow += be - X[i];\n\t\t\t}\n\t\t}\n\t\tS1.insert(ss + X[i]);\n\t\tS2.insert(X[i]);\n\t\tauto it = S1.end();\n\t\tit--;\n\t\tlong long z1 = *it - ss;\n\t\tlong long z2 = *S2.begin();\n\t\tif (z1 > z2) {\n\t\t\tS1.erase(it);\n\t\t\tS2.erase(S2.begin());\n\t\t\tS1.insert(z2 + ss);\n\t\t\tS2.insert(z1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", low);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n;\n  R n;\n  P a[n];\n  rep(i,n) cin >> a[i].F >> a[i].S;\n  sort(a,a+n);\n  ll ans=MAX;\n  rep(t,400) {\n    ll x=a[0].S+t,sum=t;\n    REP(i,1,n) {\n      if(x<a[i].F) {\n        sum+=a[i].F-x;\n        x+=a[i].S-a[i].F;\n      } else x=max(x,(ll)a[i].S);\n    }\n    ans=min(ans,sum);\n  }\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint l[100000], r[100000];\nint dp[400][400];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tif (n > 400)abort();\n\trep(i, n)scanf(\"%d%d\", &l[i], &r[i]);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tfor (int i = 0; i < 400; i++)dp[0][i] = abs(l[0] - i);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < 400; j++) {\n\t\t\tfor (int k = 0; k < 400; k++) {\n\t\t\t\tint a = j, b = j + r[i - 1] - l[i - 1];\n\t\t\t\tint c = k, d = k + r[i] - l[i];\n\t\t\t\tif (b < c || d < a)continue;//重ならない\n\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t\t}\n\t\t}\n\t}\n\tint Min = INF;\n\trep(j, 400)Min = min(Min, dp[n - 1][j]);\n\tprintf(\"%d\\n\", Min);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long ans=0,pa=0,pb=0,l[100010],r[100010];\npriority_queue<long long>a;\npriority_queue<long long,vector<long long>,greater<long long> >b;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld%lld\",&l[i],&r[i]),l[i]=r[i]-l[i];\n\ta.push(r[1]);b.push(r[1]);\n\tfor(int i=2;i<=n;i++){\n\t\tpa-=l[i-1];pb+=l[i];\n\t\tif(r[i]<a.top()+pa){\n\t\t\tans+=a.top()+pa-r[i];b.push(a.top()+pa-pb);\n\t\t\ta.pop();a.push(r[i]-pa);a.push(r[i]-pa);\n\t\t}\n\t\telse if(r[i]>b.top()+pb){\n\t\t\tans+=r[i]-(b.top()+pb);a.push(b.top()+pb-pa);\n\t\t\tb.pop();b.push(r[i]-pb);b.push(r[i]-pb);\n\t\t}\n\t\telse a.push(r[i]-pa),b.push(r[i]-pb);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=1050;\n//ここまでテンプレ\nint main(){\n\t//DP[i][j]=i番目の机の左端を座標jに入れたときの最小のコスト\n\tll DP[450][SIZE]={};\n\tint N;\n\tcin>>N;\n\tvll L,R;\n\tfor(int i=0;i<N;i++){\n\t\tll l,r;\n\t\tcin>>l>>r;\n\t\tL.pb(l);\n\t\tR.pb(r);\n\t}\n\tfor(int i=0;i<=SIZE;i++){\n\t\tDP[0][i]=abs(i-L[0]);\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<450;j++){\n\t\t\tll mini=INFLL;\n\t\t\tll PW=R[i-1]-L[i-1];\n\t\t\tll NW=R[i]-L[i];\n\t\t\tfor(int k=max(j-PW,0LL);k<=j+NW;k++)\n\t\t\t\tmini=min(mini,DP[i-1][k]);\n\t\t\tDP[i][j]=abs(j-L[i])+mini;\n\t\t}\n\t}\n\tll ans=INFLL;\n\tfor(int i=0;i<450;i++)\n\t\tans=min(ans,DP[N-1][i]);\n\tcout<<ans<<endl;\n\t\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<10;j++)\n\t\t\tcout<<DP[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\ntypedef long long LL;\npriority_queue<LL>L;\npriority_queue<LL,vector<LL>,greater<LL>>R;\nLL tL,tR,ans;\nint n,l[123456],r[114514];\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)cin>>l[i]>>r[i];\n\tL.push(l[1]),R.push(l[1]);\n\tfor(int i=2;i<=n;++i){\n\t\ttL-=r[i]-l[i],tR+=r[i-1]-l[i-1];\n\t\tLL mnL=L.top()+tL,mnR=R.top()+tR;\n\t\tif(mnL<=l[i]&&l[i]<=mnR)L.push(l[i]-tL),R.push(l[i]-tR);else\n\t\tif(l[i]>mnR){\n\t\t\tans+=l[i]-mnR,L.push(mnR-tL),R.pop();\n\t\t\tR.push(l[i]-tR),R.push(l[i]-tR);\n\t\t}else{\n\t\t\tans+=mnL-l[i],R.push(mnL-tR),L.pop();\n\t\t\tL.push(l[i]-tL),L.push(l[i]-tL);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[405][405];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=0;i<405;i++)\n\t\t\tfor(int j=0;j<405;j++)\n\t\t\tdp[i][j]=1e9;\n\t\tfor(int i=1;i<405;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tassert(l>=1&&l<=400);\n\t\t\tassert(r>=1&&r<=400);\n\t\t\tfor(int j=1;j<10;j++)\n\t\t\t{\n\t\t\t\tint aa=0;\n\t\t\t\tif(j<l)\n\t\t\t\taa=l-j;\n\t\t\t\telse if(j>r)\n\t\t\t\taa=j-r;\n\t\t\t\tfor(int k=max(j-(r-l+1),1);k<min(405,j+(r-l+1));k++){\n\t\t\t\t\tif(k<l)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(l-k,aa));\n\t\t\t\t\telse if(k>r)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(k-r,aa));\n\t\t\t\t\telse \n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+aa);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<405;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2017/03/18 21:29:01 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nconst int maxn=410;\n\nint dp[maxn][maxn],l[maxn],r[maxn],len[maxn];\n\nint main()\n{\n    IOS;\n    int n;\n    cin>>n;\n    for (int j=1;j<=n;++j)\n    {\n        cin>>l[j]>>r[j];\n        len[j]=r[j]-l[j];\n    }\n    l[0]=1;\n    r[0]=400;\n    for (int j=1;j<=n;++j)\n    {\n        for (int st=1;st<=400-len[j];++st)\n        {\n            int ed=st+len[j];\n            int cha=abs(l[j]-st);\n            int mi=1e9;\n            int wh=min(400-len[j-1],ed+len[j-1]);\n            for (int k=max(1,st-len[j-1]);k<=wh;++k)\n                mi=min(mi,dp[j-1][k]);\n            dp[j][st]=cha+mi;\n        }\n    }\n    int ans=1e9;\n    for (int st=1;st<=400-len[n];++st)\n        ans=min(ans,dp[n][st]);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <string>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n#define FORD(i, a, b) for (int i = (a), _b = (b); i >= _b; --i)\n#define REP(i, a) for (int i = 0, _a = (a); i < _a; ++i)\n#define REPD(i,n) for(int i = (n)-1; i >= 0; --i)\n\n#define DEBUG(X) { cerr << #X << \" = \" << (X) << endl; }\n#define PR(A, n) { cerr << #A << \" = \"; FOR(_, 1, n) cerr << A[_] << ' '; cerr << endl; }\n#define PR0(A, n) { cerr << #A << \" = \"; REP(_, n) cerr << A[_] << ' '; cerr << endl; }\n\n#define sqr(x) ((x) * (x))\n#define ll long long\n#define double long double\ntypedef pair<int, int> II;\n#define PI (2 * acos((double)0))\n#define __builtin_popcount __builtin_popcountll\n#define SZ(x) ((int)(x).size())\n#define ALL(a) (a).begin(), (a).end()\n#define MS(a,x) memset(a, x, sizeof(a))\n#define next ackjalscjaowjico\n#define prev ajcsoua0wucckjsl\n#define y1 alkscj9u20cjeijc\n#define left lajcljascjljl\n#define right aucouasocjolkjl\n#define y0 u9cqu3jioajc\n\n#define TWO(X) (1LL<<(X))\n#define CONTAIN(S,X) ((S) & TWO(X))\n\ndouble safe_sqrt(double x) { return sqrt(max((double)0.0, x)); }\nint GI(int& x) { return scanf(\"%lld\", &x); }\n\nconst int MN = 200111;\n\nint n, nc;\nint c[MN];\npair<int,int> a[MN];\nint f[MN];\nint add[MN];\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << (fixed) << setprecision(9);\n    while (GI(n) == 1) {\n        nc = 0;\n        FOR(i,1,n) {\n            GI(a[i].first);\n            GI(a[i].second);\n\n            c[++nc] = a[i].first;\n            c[++nc] = a[i].second;\n        }\n        FOR(i,1,400) c[++nc] = i;\n\n        sort(c+1, c+nc+1);\n        nc = unique(c+1, c+nc+1) - c - 1;\n\n        FOR(i,1,n) {\n            a[i].first = lower_bound(c+1, c+nc+1, a[i].first) - c;\n            a[i].second = lower_bound(c+1, c+nc+1, a[i].second) - c;\n        }\n\n        memset(f, 0, sizeof f);\n        // move right\n        memset(add, 0, sizeof add);\n        FOR(i,1,n) {\n            add[a[i].second]++;\n        }\n        int cnt = 0, sum = 0;\n        FOR(i,1,nc) {\n            f[i] = c[i] * cnt - sum;\n            cnt += add[i];\n            sum += add[i] * c[i];\n        }\n\n        // move left\n        memset(add, 0, sizeof f);\n        FOR(i,1,n) {\n            add[a[i].first]++;\n        }\n        cnt = 0, sum = 0;\n        FORD(i,nc,1) {\n            f[i] += sum - c[i] * cnt;\n            cnt += add[i];\n            sum += add[i] * c[i];\n        }\n\n        int res = f[1];\n        FOR(i,1,nc) res = min(res, f[i]);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666;const ll inf=1e16;\nint n,l[N],r[N];ll res;\npriority_queue<ll>a;ll A;//x+A\npriority_queue<ll,vector<ll>,greater<ll> >b;ll B;//x+B\n\nint main() {\n\tread(n);rep(i,1,n)read(l[i]),read(r[i]);\n\tres=0;a.push(-inf);a.push(l[1]);b.push(l[1]);b.push(inf);\n\trep(i,2,n){\n\t\tA-=r[i]-l[i];B+=r[i-1]-l[i-1];\n\t//\tprintf(\"%lld %lld\\n\",a.top()+A,b.top()+B);\n\t\tif(l[i]<=a.top()+A){\n\t\t\tres+=a.top()+A-l[i];\n\t\t\tb.push(a.top()+A-B);a.pop();\n\t\t\ta.push(l[i]-A);a.push(l[i]-A);\n\t\t}\n\t\telse if(l[i]>=b.top()+B){\n\t\t\tres+=max(l[i]-(b.top()+B),0LL);\n\t\t\ta.push(b.top()+B-A);b.pop();\n\t\t\tb.push(l[i]-B);b.push(l[i]-B);\n\t\t}\n\t\telse a.push(l[i]-A),b.push(l[i]-B);\n\t}\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x - 1; i < y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i - - )\n#define eps 1e - 9\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == ' - ') f =  - 1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\ntypedef pair<int,int> P;\n \nint n;\nll l[100001],r[100001];\nmultiset<ll> L, R;\n \nint main()\n{\n\tn = read();\n\trep(i, 1, n)\n\t\tscanf(\"%lld%lld\",&l[i],&r[i]);\n\t\n\tL.insert( - 1LL << 60);\n\tR.insert(1LL << 60);\n\tll ol = 0, Or = 0;\n\tll res = 0;\n\trep(i, 1, n)\n\t{\n\t\tif(i > 0) ol  - = r[i] - l[i], Or += r[i - 1] - l[i - 1];\n\t\tif(l[i] < *L.rbegin() + ol) res += *L.rbegin() + ol - l[i];\n\t\telse if(*R.begin() + Or < l[i]) res += l[i] - (*R.begin() + Or);\n\t\tif(l[i]<*L.rbegin() + ol)\n\t\t{\n\t\t\tR.insert(*L.rbegin() + ol - Or);\n\t\t\tL.insert(l[i] - ol);\n\t\t\tL.insert(l[i] - ol);\n\t\t\tL.erase(L.find(*L.rbegin()));\n\t\t}\n\t\telse if(*R.begin() + Or < l[i])\n\t\t{\n\t\t\tL.insert(*R.begin() + Or - ol);\n\t\t\tR.insert(l[i] - Or);\n\t\t\tR.insert(l[i] - Or);\n\t\t\tR.erase(R.begin());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL.insert(l[i] - ol);\n\t\t\tR.insert(l[i] - Or);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <bitset>\n#include <sstream> \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll,ll> Pll;\n\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define repp(i, n) for(int i=1;i<=n;i++)\n#define all(x) x.begin(), x.end()\n\n#define ABS(x) (((x) > 0 ) ? (x) : (-(x)))\n#define MAX2(x, y) (((x) > (y)) ? (x) : (y))\n#define MIN2(x, y) (((x) < (y)) ? (x) : (y))\n#define MAX3(x, y, z) ( (x) > (y)  ? ( (x) > (z) ? (x) : (z)  ) : ( (y) > (z) ? (y) : (z) )  )\n#define MIN3(x, y, z) ( (x) < (y)  ? ( (x) < (z) ? (x) : (z)  ) : ( (y) < (z) ? (y) : (z) )  )\n#define MID3(val1,val2,val3) MAX2(MIN2(MAX2(val1,val2),val3),MIN2(val1,val2))\n\n\n#define geti1(X) scanf(\"%d\",&X)\n#define geti2(X,Y) scanf(\"%d%d\",&X,&Y)\n#define geti3(X,Y,Z) scanf(\"%d%d%d\",&X,&Y,&Z)\n#define geti4(X,Y,Z,W) scanf(\"%d%d%d%d\",&X,&Y,&Z,&W)\n\n#define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define geti(...) GET_MACRO(__VA_ARGS__, geti4, geti3, geti2, geti1) (__VA_ARGS__)\n\n#define INF 987654321\n#define IINF 987654321987654321\nint N,M,K,T,tc;\nint l[500],r[500],len[500];\n\nint dp[600][600]; //n번째 블록까지 connect시키고 n번째 블록의 left는 i에 위치\n\n\nint main(void){\n\tgeti(N);\n\trepp(i,N) geti(l[i],r[i]);\n\trepp(i,N) len[i] = r[i]-l[i];\n\trep(i,600) rep(j,600) dp[i][j] = INF;\n\tif( N == 1 ) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\tfor(int k=0;k<=410;k++){\n\t\tdp[1][k] = ABS(l[1]-k);\n\t}\n\tint ans = INF;\n\tfor(int n=2;n<=N;n++){\n\t\tfor(int x=0;x<=410;x++){\n\t\t\tint mn = INF;\n\t\t\tfor(int k=max(0,x-len[n-1]);k<=min(410,x+len[n]);k++){\n\t\t\t\tmn = min(dp[n-1][k],mn);\n\t\t\t}\n\t\t\tdp[n][x] = ABS(l[n]-x)+mn;\n\t\t\tif( n == N ) ans = min(dp[n][x],ans);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 1e5 + 10;\nconst LL inf = 1e13;\nint l[N], r[N];\nmultiset<int> s0, s1; int d0, d1;\nint main() {\n\tint n; scanf(\"%d\",&n);\n\tint l1 = 0;\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tint l2 = r[i] - l[i]; \n\t\tif (i > 1) d0 -= l2, d1 += l1;\n\t\tl1 = l2;\n\t\tint L, R;\n\t\tif (i > 1) {\n\t\t\tsit it = s0.end(); it--;\n\t\t\tL = *it + d0;\n\t\t\tit = s1.begin();\n\t\t\tR = *it + d1;\n\t\t} else L = 0, R = 0;\n\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\ts0.insert(l[i] - d0), s1.insert(l[i] - d1);\n\t\t} else if (l[i] < L) {\n\t\t\ts0.insert(l[i] - d0), s0.insert(l[i] - d0);\n\t\t\tsit it = s0.end(); it--;\n\t\t\ts1.insert(*it + d0 - d1); s0.erase(it);\n\t\t} else if (l[i] > R) {\n\t\t\ts1.insert(l[i] - d1), s1.insert(l[i] - d1);\n\t\t\tsit it = s1.begin(); \n\t\t\ts0.insert(*it + d1 - d0); s1.erase(it);\n\t\t}\n\t}\n\tLL cur = 0, t = -inf;\n\tdep(i,n,1) cur += l[i] - t, t += r[i] - l[i];\n\tint d = -n; LL tmp = -inf;\n\tfor(sit it = s0.begin(); it != s0.end(); it++)\n\t\tcur += 1LL * d * (*it + d0 - tmp), tmp = *it + d0, d++;\n\tcout <<cur<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nmultiset<int> LS, RS;\nint L[100010], R[100010];\nsigned main(){\n\tint n, fl = 0, fr = 0, ans = 0;\n\tscanf(\"%lld\", &n);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld%lld\", &L[i], &R[i]);\n\t\n\tLS.insert(-1e17);\n\tRS.insert(1e17);\n\tfor(int i = 0;i < n;i++){\n\t\tfl -= R[i]-L[i];\n\t\tfr += R[i-1]-L[i-1];\n\t\t\n\t\tif(L[i] < *LS.rbegin()+fl){\n\t\t\tans += *LS.rbegin()+fl-L[i];\n\t\t\tRS.insert(*LS.rbegin()+fl-fr);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tLS.insert(L[i]-fl);\n\t\t}else if(*RS.begin()+fr < L[i]){\n\t\t\tans += L[i]-(*RS.begin()+fr);\n\t\t\tLS.insert(*RS.begin()+fr-fl);\n\t\t\tRS.erase(RS.begin());\n\t\t\tRS.insert(L[i]-fr);\n\t\t\tRS.insert(L[i]-fr);\n\t\t}else{\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tRS.insert(L[i]-fr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF (1e9)\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 1000\n \nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n \nint mem[MAXN][MAXN];\nint myabs( int x ){\n\tif( x >= 0 ) return x;\n\treturn -x;\n}\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tint ans = INF;\n\tfor(int nowl = max(lastl-len[pos],1);nowl <= lastl+len[pos-1];nowl++){\n\t\tint nowans = dp(pos+1,nowl) + myabs(l[pos]-nowl);\n\t\tif( ans > nowans )\n\t\t\tans = nowans;\n\t}\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 1;i <= MAXN;i++){\n\t\tint nowans = dp(2,i) + myabs(i-l[1]);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define ll long long\n#define pii pair<ll, ll>\n#define fst first\n#define snd second\nusing namespace std;\n\nint n;\npii ar[100001]={};\nll lz1, lz2, rs;\npriority_queue<pii> pq1;\npriority_queue<pii> pq2;\n\ninline ll abbs(ll a) {return ((a < 0) ? -a : a);}\n\nint main()\n{\n\tios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {cin >> ar[i].fst >> ar[i].snd;}\n\tpq1.push({ar[0].fst, 0});\n\tpq2.push({-ar[0].fst, 0});\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tlz1 -= ar[i].snd - ar[i].fst;\n\t\tlz2 -= ar[i-1].snd - ar[i-1].fst;\n\t\t//cout<<pq1.top().fst + lz1<<\" \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\tif (ar[i].fst < pq1.top().fst + lz1)\n\t\t{\n\t\t\tpq2.push({-(pq1.top().fst + lz1) - lz2, 0});\n\t\t\tpq1.push({ar[i].fst - lz1, 1});\n\t\t\tll val = pq1.top().fst, ng = 0;\n\t\t\twhile (pq1.size() && pq1.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq1.top().snd;\n\t\t\t\tpq1.pop();\n\t\t\t} \n\t\t\tif (ng) {pq1.push({val, ng - 1});}\n\t\t\trs += abbs(-(pq2.top().fst + lz2) - ar[i].fst);\n\t\t}\n\t\telse if (ar[i].fst > -(pq2.top().fst + lz2))\n\t\t{\n\t\t\tpq1.push({-(pq2.top().fst + lz2) - lz1, 0});\n\t\t\tpq2.push({-ar[i].fst - lz2, 1});\n\t\t\t//cout<<\"PQ1 INS \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\t\t//cout<<\"PQ2 INS \"<<ar[i].fst<<\"\\n\";\n\t\t\tll val = pq2.top().fst, ng = 0;\n\t\t\twhile (pq2.size() && pq2.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq2.top().snd;\n\t\t\t\tpq2.pop();\n\t\t\t} \n\t\t\tif (ng) {pq2.push({val, ng - 1});}\n\t\t\t//cout<<pq1.top().fst + lz1<<\" \"<<ar[i].fst<<\"\\n\";\n\t\t\trs += abbs(pq1.top().fst + lz1 - ar[i].fst);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq1.push({ar[i].fst - lz1, 0});\n\t\t\tpq2.push({-(ar[i].fst) - lz2, 0});\n\t\t}\n\t}\n\tcout << rs << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 410;\nint n;\nint l[maxn] , r[maxn];\nint dp[maxn][maxn];\nint ans;\nvoid work () {\n\tint i , j , k;\n\tscanf ( \"%d\" , &n );\n\tfor ( i = 1 ; i <= n ; i++ ) scanf ( \"%d%d\" , &l[i] , &r[i] );\n\tfor ( i = 1 ; i <= 400 ; i++ ) dp[1][i] = abs ( l[1] - i );\n\tfor ( i = 2 ; i <= n ; i++ ) for ( j = 1 ; j <= 400 ; j++ ) {\n\t\tdp[i][j] = 99999999;\n\t\tfor ( k = max ( j - (r[i-1]-l[i-1]) , 1 ) ; k <= min ( j + (r[i]-l[i]) , 400 ) ; k++ ) {\n\t\t\tdp[i][j] = min ( dp[i][j] , dp[i-1][k] );\n\t\t}\n\t\tdp[i][j] += abs ( l[i] - j );\n\t\t//printf ( \"%d %d %d\\n\" , i , j , dp[i][j] );\n\t}\n\tans = dp[n][1];\n\tfor ( i = 1 ; i <= 400 ; i++ ) ans = min ( ans , dp[n][i] );\n\tprintf ( \"%d\\n\" , ans );\n}\nint main () {\n\twork ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> P;\npriority_queue <ll,vector <ll>,greater <ll> > Q;\n\nint main() {\n    int n;\n    ll A=0,B=0,ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n\tcin>>l>>r;\n\tB+=r-l;\n\tP.push(r-A),Q.push(r-B);\n\twhile(P.top()+A>Q.top()+B) {\n\t    ll x=P.top()+A,y=Q.top()+B;\n\t    P.pop(),Q.pop(),ans+=x-y;\n\t    P.push(y-A),Q.push(x-B);\n\t}\n\tA-=r-l;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MP make_pair\ntypedef long long ll;\nconst int inf=0x3f3f3f3f;\nconst int maxn=400+5;\nint l[maxn],r[maxn];\nint len[maxn];\nint n;\nint dp[maxn][maxn];\nbool judge(pair<int ,int > a,pair<int ,int > b)\n{return min(a.second,b.second)>=max(a.first,b.first);}\nint myabs(int x){return x<0?-x:x;}\nint main()\n{\n    scanf(\"%d\",&n);\n    int maxpos=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&l[i],&r[i]);\n        len[i]=r[i]-l[i]+1;\n        maxpos=max(maxpos,r[i]);\n    }\n    memset(dp,inf,sizeof(dp));\n    int ans=inf;\n    dp[1][l[1]]=0;\n    for(int i=1;i<=maxpos;i++) dp[1][i]=myabs(l[1]-i);\n    /*for(int i=1;i<=maxpos;i++)\n    {\n        printf(\"dp[%d][%d]=%d\\n\",1,i,dp[1][i]);\n    }puts(\"\");*/\n    for(int i=2;i<=n;i++)\n        for(int x=1;x<=maxpos;x++)\n            for(int y=1;y<=maxpos;y++)\n                if(judge(MP(y,y+len[i-1]-1),MP(x,x+len[i]-1)))\n                    dp[i][x]=min(dp[i][x],dp[i-1][y]+myabs(l[i]-x));\n/*    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=maxpos;j++)\n        printf(\"dp[%d][%d]=%d\\n\",i,j,dp[i][j]);\n        puts(\"\");\n    }*/\n    for(int i=1;i<=maxpos;i++) ans=min(ans,dp[n][i]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vll l(n), r(n), width(n), mid(n);\n  rep (i, n) {\n    scanf(\"%lld%lld\", &l[i], &r[i]);\n    l[i] *= 2;\n    r[i] *= 2;\n    width[i] = r[i] - l[i];\n    mid[i] = (r[i] + l[i]) / 2;\n  }\n  ll left_offset, right_offset;\n  left_offset = right_offset = 0;\n  ll minval = 0;\n  priority_queue<ll, vll, less<ll> > left;\n  priority_queue<ll, vll, greater<ll> > right;\n\n  left.push(mid[0]);\n  right.push(mid[0]);\n\n  FOR (i, 1, n) {\n    ll width_ = (width[i] + width[i-1]) / 2;\n    left_offset -= width_;\n    right_offset += width_;\n    ll max_left = left.top();\n    ll min_right = right.top();\n\n    assert(max_left + left_offset <= min_right + right_offset);\n\n    if (max_left + left_offset <= mid[i] && mid[i] <= min_right + right_offset) {\n      left.push(mid[i] - left_offset);\n      right.push(mid[i] - right_offset);\n    } else {\n      if (mid[i] < max_left + left_offset) {\n        minval += max_left + left_offset - mid[i];\n\n        right.push(max_left + left_offset - right_offset);\n        left.pop();\n        left.push(mid[i] - left_offset);\n        left.push(mid[i] - left_offset);\n      } else {\n        minval += mid[i] - (min_right + right_offset);\n\n        left.push(min_right + right_offset - left_offset);\n        right.pop();\n        right.push(mid[i] - right_offset);\n        right.push(mid[i] - right_offset);\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", minval / 2);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define mp make_pair\ntypedef long long ll;\nmultiset<ll> pos,neg;\nint timer;\nll len[100011];\nll shiftpos,shiftneg;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tll m=0; ll c=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tlen[i]=r-l;\n\t\tif(i>0){shiftpos+=len[i-1]; c-=len[i-1]*m;}\n\t\tshiftneg-=len[i];\n\t\tpos.insert(l-shiftpos); pos.insert(l-shiftpos);\n\t\tauto it=pos.begin(); ll res=(*it)+shiftpos;\n\t\tpos.erase(pos.begin()); neg.insert(res-shiftneg);\n\t\tll neglas=(*prev(neg.end()))+shiftneg;\n\t\tll posles=(*pos.begin())+shiftpos;\n\t\tif(!neg.empty()&&neglas>posles)\n\t\t{\n\t\t\tneg.erase(prev(neg.end())); pos.erase(pos.begin());\n\t\t\tpos.insert(neglas-shiftpos); neg.insert(posles-shiftneg);\n\t\t}\n\t\tm++; c-=l;\n\t}\n\twhile(m>0)\n\t{\n\t\tc+=(*prev(pos.end()))+shiftpos;\n\t\tm--;\n\t\tpos.erase(prev(pos.end()));\n\t}\n\tcout<<c<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(r[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    Int x=r[i]-l[i];\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(r[i]<dL+*latte){\n      dL-=x;dR+=x;\n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      dL-=x;dR+=x;\n      \n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<lli> l;\nvector<lli> r;\nlli dp[401][401];\nbool bl[401][401];\nlli solve(lli k,lli x){\n    if(bl[k][x]) return dp[k][x];\n    bl[k][x] = true;\n    if(k == 0) return 0;\n    lli c = 1 << 30;\n    for(lli i = max(x - (r[k-1] - l[k-1]),(lli)0);i <= min(x + (r[k] - l[k]),(lli)400);i++){\n        c = min(c,solve(k-1,i));\n    }\n    return dp[k][x] = abs(x-l[k]) + c;\n}\nint main(){\n    cin >> n;\n    l = vector<lli> (n+1);r = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) cin >> l[i] >> r[i];\n    lli c = 1 << 30;\n    for(lli i = 0;i <= 400;i++) c = min(c,solve(n,i));\n    cout << c << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, l[100005], r[100005];\nlong long ans=LONG_LONG_MAX, dp[500][500];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for(int i=1; i<=n; i++) {\n        cin >> l[i] >> r[i];\n    }\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=400; j++)\n            dp[i][j] = LONG_LONG_MAX;\n\n    for(int i=1; i<=400; i++) dp[1][i] = abs(l[1]-i);\n    for(int i=2; i<=n; i++) {\n        for(int j=1; j<=400; j++) {\n            for(int k=1; k<=400; k++) {\n                if(k<j-(r[i-1]-l[i-1]) || k>j+l[i]+r[i]) continue;\n                dp[i][j] = min(dp[i][j], dp[i-1][k]+abs(l[i]-j));\n            }\n            //cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n        }\n    }\n    for(int i=1; i<=400; i++) ans = min(ans, dp[n][i]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nconst int max_n = 1e5+10;\n\nint n;\nll l[max_n];\nll r[max_n];\n\nvoid in(){\n\tread(n);\n\tfor(int i=1; i<=n; ++i){\n\t\tread(l[i], r[i]);\n\t}\n}\n\nstruct res {\n\tvector<ll> v;\n\tll iv;\n};\n\nll len(int x){ return r[x]-l[x]; }\n\nres solve(int l, int r){\n\tif(l == r){\n\t\tll x=::l[l];\n\t\tres ret;\n\t\tret.v = {x, x};\n\t\tret.iv = 0LL;\n\t\treturn ret;\n\t}\n\tint mid=(l+r)/2;\n\tres L, R;\n\tll l1, l0;\n\tif(l < r){\n\t\tL=solve(l, mid), R=solve(r, mid+1);\n\t\tl1=len(mid), l0=len(mid+1);\n\t} else {\n\t\tL=solve(l, mid+1), R=solve(r, mid);\n\t\tl0=len(mid), l1=len(mid+1);\n\t}\n\tres ret;\n\t{\n\t\tauto& v=L.v;\n\t\tint n=int(v.size())/2;\n\t\tfor(int i=0; i<n; ++i) ret.v.pb(v[i]-l0);\n\t\tfor(int i=0; i<n; ++i) ret.v.pb(v[i+n]+l1);\n\t}\n\tfor(ll x:R.v) ret.v.pb(x);\n\tsort(all(ret.v));\n\tll lx=L.v[0]-l0, rx=R.v[0];\n\tll tx=min(lx, rx);\n\tret.iv = L.iv + R.iv + int(L.v.size())/2LL*(lx-tx) + int(R.v.size())/2LL*(rx-tx);\n\treturn ret;\n}\n\nint main()\n{\n\tfreopen(\"in\", \"r\", stdin);\n\tin();\n\tauto inc = solve(1, n);\n\tauto& v=inc.v;\n\tll cv=inc.iv;\n\tll grad=-n;\n\tfor(int i=1; i<n; ++i){\n\t\t++grad;\n\t\tcv += grad*(v[i]-v[i-1]);\n\t}\n\tprintf(\"%lld\\n\", cv);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif // LOCAL_\n#define dumpl(x1) fprintf(stderr, \"#%s.%d (%s) = (%ld)\\n\", __func__, __LINE__, #x1, x1);\n#define dumpll(x1, x2) fprintf(stderr, \"#%s.%d (%s, %s) = (%ld, %ld)\\n\", __func__, __LINE__, #x1, #x2, x1, x2);\n#define dumpd(x1) fprintf(stderr, \"#%s.%d (%s) = (%lf)\\n\", __func__, __LINE__, #x1, x1);\n#define dumpdd(x1, x2) fprintf(stderr, \"#%s.%d (%s, %s) = (%lf, %lf)\\n\", __func__, __LINE__, #x1, #x2, x1, x2);\n#define loop for(;;)\n \nstruct S002 {\n  int n;\n  S002& operator > (long& x) {\n    n = x;\n    return *this;\n  }\n  S002& operator > (long&& x) {\n    n = x;\n    return *this;\n  }\n  S002& operator >= (long& x) {\n    if( scanf(\"%ld\", &x) <= 0 ) exit(0);\n    return *this;\n  }\n  S002& operator >= (double& x) {\n    if( scanf(\"%lf\", &x) <= 0 ) exit(0);\n    return *this;\n  }\n  S002& operator >= (std::string& s) {\n    if( not (std::cin >> s) ) exit(0);\n    return *this;\n  }\n  template<typename a>\n  S002& operator >= (std::vector<a>& v) {\n    v.resize(n);\n    for(long i = 0; i < n; ++i) {\n      *this >= v[i];\n    }\n    return *this;\n  }\n  template<typename a, std::size_t s>\n  S002& operator >= (std::array<a, s>& x) {\n    for(long i = 0; i < (long)s; ++i) {\n      *this >= x[i];\n    }\n    return *this;\n  }\n};\n\nstruct Solver {\n  long n;\n  std::vector<std::array<long,2>> xs;\n  Solver() {\n    S002 reader;\n    reader >= n >n>= xs;\n  }\n  bool partial() {\n    if( not ( n <= 400 ) ) return false;\n    for(std::array<long, 2> x : xs) {\n      if( not ( x[0] <= 400 and x[1] <= 400 ) ) return false;\n    }\n    return true;\n  }\n  void solve() {\n    if( not partial() ) {\n      puts(\"0\");\n      return;\n    }\n    std::vector<long> ys(400+1);\n    std::vector<long> zs(400+1);\n    for(long j = 0; j <= 400; ++j) {\n      ys[j] = std::abs(xs[0][0] - j);\n    }\n    // for(long j = 0; j < 20; ++j) {\n    //   fprintf(stderr, \"%3ld \", ys[j]);\n    // }\n    // fprintf(stderr, \"\\n\");\n    for(long i = 1; i < (long)xs.size(); ++i) {\n      long lenp = xs[i-1][1] - xs[i-1][0];\n      long len  = xs[i][1] - xs[i][0];\n      for(long j = 0; j <= 400; ++j) {\n        long min = (1 << 29);\n        long left = std::max((long)0, j - lenp);\n        long right = std::min((long)400, j + len);\n        for(long k = left; k <= right; ++k) {\n          min = std::min(min, ys[k]);\n        }\n        zs[j] = std::abs(xs[i][0] - j) + min;\n        // if( j < 20 ) {\n        //   fprintf(stderr, \"%3ld \", zs[j]);\n        // }\n        // if( j == 19 ) {\n        //   fprintf(stderr, \"\\n\");\n        // }\n      }\n      for(long j = 0; j <= 400; ++j) {\n        ys[j] = zs[j];\n      }\n    }\n    long res = *std::min_element(ys.begin(), ys.end());\n    printf(\"%ld\\n\", res);\n  }\n};\n \nint main() {\n  for(;;) std::unique_ptr<Solver>(new Solver())->solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n, l, r, c;\nll decL = 0, incR = 0;\npriority_queue<ll> pql;\npriority_queue<ll, vector<ll>, greater<ll>> pqr;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\tcin >> n >> l >> r;\n\tpql.push(l); pqr.push(l); c = 0;\n\n\tll lastsz = 0, cursz = r-l+1, ans = 0;\n\tfor(int i = 1; i < n; i++) {\n\t\tcin >> l >> r;\n\t\tlastsz = cursz; cursz = r-l+1;\n\n\t\tdecL -= cursz - 1;\n\t\tincR += lastsz - 1;\n\n\t\tif(l <= pql.top() + decL) {\n\t\t\tll x = pql.top() + decL;\n\t\t\tans += x - l;\n\t\t\tpql.push(l - decL);\n\t\t\tpql.push(l - decL);\n\t\t\tpql.pop();\n\t\t\tpqr.push(x - incR);\n\t\t} else if(l >= pqr.top() + incR) {\n\t\t\tll x = pqr.top() + incR;\n\t\t\tans += l - x;\n\t\t\tpqr.push(l - incR);\n\t\t\tpqr.push(l - incR);\n\t\t\tpqr.pop();\n\t\t\tpql.push(x - decL);\n\t\t} else {\n\t\t\tpql.push(l - decL);\n\t\t\tpqr.push(l - incR);\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#include <cstring>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 410 * 3;\n\nint n,a[405],b[405],f[405][maxn];\n\nvoid pd(int&ret,int val) {\n  if(ret==-1||ret>val)ret=val;\n}\n\nint main() {\n // freopen(\"in.cpp\",\"r\",stdin);\n  cin>>n;\n  for(int i=1; i<=n; i++){\n  cin>>a[i]>>b[i];\n  a[i]+=405;\n  b[i]+=405;\n  }\n  memset(f,-1,sizeof(f));\n  for(int i=0; i<maxn; i++)f[1][i]=abs(i-a[1]);\n  for(int i=1; i<n; i++)\n    for(int j=0; j<maxn; j++) {\n      if(f[i][j]==-1)continue;\n      int l = max(0, j-(b[i+1]-a[i+1]));\n      int r = min(maxn-1,j+b[i]-a[i]);\n      for(int k=l; k<=r; k++) {\n        if(k+b[i+1]-a[i+1]<j||j+b[i]-a[i]<k)continue;\n        pd(f[i+1][k],f[i][j]+abs(k-a[i+1]));\n      }\n    }\n    //cout<<f[1][2]<<endl;\n  int ret=-1;\n  for(int i=0; i<maxn; i++)if(f[n][i]!=-1)pd(ret,f[n][i]);\n  cout<<ret<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[405][405];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=0;i<405;i++)\n\t\t\tfor(int j=0;j<405;j++)\n\t\t\tdp[i][j]=1e9;\n\t\tfor(int i=1;i<405;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tassert(l>=1&&l<=400);\n\t\t\tassert(r>=1&&r<=400);\n\t\t\tfor(int j=1;j<405;j++)\n\t\t\t{\n\t\t\t\tint aa=0;\n\t\t\t\tif(j<l)\n\t\t\t\taa=l-j;\n\t\t\t\telse if(j>r)\n\t\t\t\taa=j-r;\n\t\t\t\tfor(int k=max(j-(r-l+1),1);k<min(405,j+(r-l+1));k++){\n\t\t\t\t\tif(k<l)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(l-k,aa));\n\t\t\t\t\telse if(k>r)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(k-r,aa));\n\t\t\t\t\telse \n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+aa);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<405;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REPO(i,n) for(int (i)=1; (i)<=(int)(n); (i)++)\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nstruct SL {\n\tpriority_queue<ll> L;\n\tpriority_queue<ll, vector<ll>, greater<ll>> R;\n\tll ans, rBase, lBase;\n\tSL() : ans(0ll), rBase(0ll), lBase(0ll) {}\n\tvoid addR(int v) {\n\t\trBase += v;\n\t}\n\tvoid addL(int v) {\n\t\tlBase += v;\n\t}\n\tvoid addSL(int x) {\n\t\tL.push(x-lBase); R.push(x-rBase);\n\t\twhile(R.top()+rBase < L.top()+lBase) {\n\t\t\tll l = L.top()+lBase, r = R.top()+rBase;\n\t\t\tans += l-r;\n\t\t\tL.pop(); R.pop();\n\t\t\tL.push(r-lBase); R.push(l-rBase);\n\t\t}\n\t}\n};\nint N, Nr[MAX_N][2];\nint main() {\n\tcin >> N;\n\tREP(i, N) REP(j, 2) scanf(\"%d\", &Nr[i][j]);\n\tSL sl;\n\tREP(i, N) {\n\t\tsl.addR(Nr[i][1] - Nr[i][0]);\n\t\tsl.addSL(Nr[i][1]);\n\t\tif(i) sl.addL(+(Nr[i-1][1] - Nr[i-1][0]));\n\t\tsl.addL(-(Nr[i][1] - Nr[i][0]));\n\t}\n\tprintf(\"%lld\\n\", sl.ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <set>\nusing namespace std;\nconst long long INF = 1LL<<60;\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T> ostream& operator << (ostream &s, multiset<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\n\n\n\nint N;\nvector<long long> L, R;\nlong long solve() {\n    multiset<long long> left, right;\n    left.insert(-INF), left.insert(L[0]), right.insert(L[0]), right.insert(INF);\n    long long lx = 0, rx = 0, h = 0;\n    long long prev = R[0] - L[0];\n    for (int i = 1; i < N; ++i) {\n        long long cur = R[i] - L[i];\n        lx -= cur, rx += prev;\n        auto lit = left.end(); --lit;\n        long long l = *lit + lx;\n        long long r = *(right.begin()) + rx;\n        if (l <= L[i] && L[i] <= r) {\n            left.insert(L[i] - lx), right.insert(L[i] - rx);\n        }\n        else if (L[i] > r) {\n            auto rit2 = right.begin(); ++rit2;\n            long long r2 = min(L[i], *rit2 + rx);\n            right.erase(right.begin());\n            left.insert(r - lx), right.insert(r2 - rx), right.insert(r2 - rx);\n            h += abs(L[i] - r2) + (r2 - r);\n        }\n        else {\n            auto lit2 = left.end(); --lit2; --lit2;\n            long long l2 = max(L[i], *lit2 + lx);\n            left.erase(++lit2);\n            left.insert(l2 - lx), left.insert(l2 - lx), right.insert(l - rx);\n            h += abs(L[i] - l2) + (l - l2);\n        }\n        /*\n        COUT(\"=================\");\n        COUT(i);\n        COUT(left);\n        COUT(right);\n        COUT(lx);\n        COUT(rx);\n        COUT(h);\n        */\n\n        prev = cur;\n    }\n    return h;\n}\n\nint main() {\n    while (cin >> N) {\n        L.resize(N); R.resize(N);\n        for (int i = 0; i < N; ++i) cin >> L[i] >> R[i];\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\tint n;\n\tvector<int> l, r;\n\tfor (int i=0; i<n; i++) {\n\t\tint l_, r_; cin >> l_, r_;\n\t\tl.push_back(l_);\n\t\tr.push_back(r_);\n\t}\n\tif(n > 400){\n\t\treturn 0;\n\t}\n\tlong min_loss = -1;\n\tint loss_pos = -1;\n\tfor(int i=1; i<=400;i++){\n\t\tlong loss = 0\n\t\tfor (int j=0, j < n; j++) {\n\t\t\tif (r[j] < i) {\n\t\t\t\tloss += i - r[j];\n\t\t\t} eles if (l[j] > i) {\n\t\t\t\tloss += l[j] > i;\n\t\t\t}\n\t\t}\n\t\tif (loss < min_loss || loss_pos == -1) {\n\t\t\tloss_pos = j;\n\t\t\tmin_loss = loss;\n\t\t}\n\t}\n\tcout << min_loss << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 dp[401][401];\ni64 l[401], r[401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n\n    if (!(n < 401 && maxr < 401)) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(0, 400, j) {\n            if (l[i] <= j && j < r[i]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = j < l[i] ? l[i]-j : j-r[i]+1;\n            }\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(0, 400, j) {\n        i64 d = 0;\n        upto(1, n, i) {\n            d = max(d, dp[i][j]);\n        }\n        ans = min(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\ntypedef long long int64;\nstatic const int MAXN = 1e5 + 5;\n\nint n, l[MAXN], r[MAXN], len[MAXN];\nint64 min;\nint64 dec_offset = 0, inc_offset = 0;\nstd::multiset<int64, std::greater<int64>> dec;\nstd::multiset<int64> inc;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &l[i], &r[i]), len[i] = (r[i] - l[i]);\n\n    dec.insert(l[0]);\n    inc.insert(l[0]);\n    for (int i = 1; i < n; ++i) {\n        dec_offset -= len[i];\n        inc_offset += len[i - 1];\n        int64 p = l[i];\n        if (p <= *dec.begin() + dec_offset) {\n            min += (*dec.begin() + dec_offset - p);\n            inc.insert(*dec.begin() + dec_offset - inc_offset);\n            dec.erase(dec.begin());\n            dec.insert(p - dec_offset);\n            dec.insert(p - dec_offset);\n        } else if (p >= *inc.begin() + inc_offset) {\n            min += (p - *inc.begin() - inc_offset);\n            dec.insert(*inc.begin() + inc_offset - dec_offset);\n            inc.erase(inc.begin());\n            inc.insert(p - inc_offset);\n            inc.insert(p - inc_offset);\n        } else {\n            dec.insert(p - dec_offset);\n            inc.insert(p - inc_offset);\n        }\n    }\n\n    printf(\"%lld\\n\", min);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nmultiset<ll> sl,sr;\nll ans,tl,tr,i,j,k,n,a[200001],b[200001];;\nll av(ll x){\n\treturn (x>=0)?x:-x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i],&b[i]);\n\tsl.insert(-1LL<<60);sr.insert(1LL<<60);\n\tsl.clear();sr.clear();sl.insert(a[1]);sr.insert(a[1]);\n\tfor (i=2,ans=tl=tr=0;i<=n;i++){\n\t\ttl+=b[i]-a[i];tr+=b[i-1]-a[i-1];j=*sl.rbegin();k=*sr.begin();\n\t\tif (j-tl>a[i]){\n\t\t\tans+=av(j-tl-a[i]);\n\t\t\tsl.erase(sl.find(j));sl.insert(a[i]+tl);sl.insert(a[i]+tl);sr.insert(j-tl-tr);\n\t\t}else if (a[i]>k+tr){\n\t\t\tans+=av(k+tl-a[i]);\n\t\t\tsr.erase(sr.find(k));sr.insert(a[i]-tr);sr.insert(a[i]-tr);sl.insert(k+tr+tl);\n\t\t}else{\n\t\t\tsl.insert(a[i]+tl);sr.insert(a[i]-tr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Night's template\n//orzakyrt\n#include <bits/stdc++.h>\n#define R register\n#define LL long long\n#ifdef __DEBUG__\n\t#define Debug (fprintf(stderr,\"orzyrt\\n\"),fflush(stderr))\n\t#define debug(__a...) (fprintf(stderr,__a),fflush(stderr))\n\t#define setfile(__a) ('orzyrt')\n\t#define Compile(__a) system(\"g++ \"__a\".cpp -lm -o \"__a)\n#else\n\t#define Debug ('orzyrt')\n\t#define debug(__a...) ('orzyrt')\n\t#define setfile(__a) freopen(__a\".in\",\"r\",stdin);freopen(__a\".out\",\"w\",stdout)\n\t#define Compile(__a) ('orzyrt')\n#endif\ntemplate<class TT>inline TT Max(R TT a,R TT b){return a<b?b:a;}\ntemplate<class TT>inline TT Min(R TT a,R TT b){return a<b?a:b;}\ntemplate<class TT>inline TT Abs(R TT a){return a<0?-a:a;}\ntemplate<class TT>inline TT cmin(R TT &a,R TT b){(b<a)&&(a=b);}\ntemplate<class TT>inline TT cmax(R TT &a,R TT b){(a<b)&&(a=b);}\nusing namespace std;\ntemplate<class TT>inline void read(R TT &x){\n\tx=0;R bool f=false;R char c=getchar();\n\tfor(;c<48||c>57;c=getchar())f|=(c=='-');\n\tfor(;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\t(f)&&(x=-x);\n}\n//end template\n\nnamespace Night{\n\tconst int maxn = 200010;\n\tint n,addl,addr,ans;\n\tpriority_queue<LL>le; \n\tpriority_queue<LL,vector<LL>,greater<LL> >ri;\n\tvoid pushl(R LL x){le.push(x-addl);}\n\tvoid pushr(R LL x){ri.push(x-addr);}\n\tint main(){\n\t\tread(n);\n\t\tfor(R int l,r,len;n--;){\n\t\t\tread(l);read(r);\n\t\t\taddr+=(len=r-l);\n\t\t\tpushl(r);pushr(r);\n\t\t\tfor(R LL tpl,tpr;(tpl=le.top()+addl)>(tpr=ri.top()+addr);){\n\t\t\t\tans+=tpl-tpr;\n\t\t\t\tle.pop();ri.pop();\n\t\t\t\tpushl(tpr);pushr(tpl);\n\t\t\t}\n\t\t\taddl-=len;\n\t\t}\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n}\nint main(){\n\treturn Night::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL MAXN=405,INF=1e18;\nLL L[MAXN],R[MAXN],dp[MAXN][MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n\tLL n;\n\tcin >> n;\n\tfor(LL i=1;i<=n;i++)cin >> L[i] >> R[i];\n\tfor(LL i=0;i<=400;i++)dp[1][i]=abs(L[1]-i);\n\tfor(LL i=2;i<=n;i++){\n\t\tfor(LL j=0;j<=400;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tfor(LL k=max(j-(R[i-1]-L[i-1]),0LL);k<=min(j+(R[i]-L[i]),400LL);k++)dp[i][j]=min(dp[i][j],abs(L[i]-j)+dp[i-1][k]);\n\t\t}\n\t}\n\tLL ans=INF;\n\tfor(LL i=0;i<=400;i++)ans=min(ans,dp[n][i]);\n\tcout << ans << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nll r[10005], l[10005];\n\nll f(int idx, int offset) {\n    ll L = l[idx] + offset;\n    ll R = r[idx] + offset;\n    L = max(0LL, L);\n    R = max(0LL, R);\n    ll ret = 0;\n    for (int i = idx - 1; i >= 0; i--) {\n        // cout << \"now: \" << L << \", \" << R << endl;\n        if (r[i] < L) {\n            ll d = L - r[i];\n            ret += d;\n            L = l[i] + d;\n            R = r[i] + d;\n        } else if (R < l[i]) {\n            ll d = l[i] - R;\n            ret += d;\n            L = l[i] - d;\n            R = r[i] - d;\n        } else {\n            L = l[i];\n            R = r[i];\n        }\n    }\n    L = l[idx] + offset;\n    R = r[idx] + offset;\n    L = max(0LL, L);\n    R = max(0LL, R);\n    rep(i, N) if (idx < i) {\n        if (r[i] < L) {\n            ll d = L - r[i];\n            ret += d;\n            L = l[i] + d;\n            R = r[i] + d;\n        } else if (R < l[i]) {\n            ll d = l[i] - R;\n            ret += d;\n            L = l[i] - d;\n            R = r[i] - d;\n        } else {\n            L = l[i];\n            R = r[i];\n        }\n    }\n    return ret;\n}\nint main() {\n    cin >> N;\n    rep(i, N) cin >> l[i] >> r[i];\n    if (N > 400) return 0;\n    ll ans = INF;\n    rep(i, N) {\n        rep(i, 400) {\n            ll t = f(i, i - 200);\n            // cout << t << endl;\n            ans = min(t, ans);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, l[409], r[409], a[409], dp[409][809]; bool vis[409][809];\nint solve(int pos, int c) {\n\tif (pos == N - 1) return 0;\n\tif (vis[pos][c + 400]) return dp[pos][c + 400];\n\tint ret = 999999999;\n\tfor (int i = -400; i <= 400; i++) {\n\t\tif (l[pos + 1] - r[pos] <= c - i && c - i <= r[pos + 1] - l[pos]) {\n\t\t\tret = min(ret, solve(pos + 1, i) + abs(i));\n\t\t}\n\t}\n\tvis[pos][c + 400] = true;\n\tdp[pos][c + 400] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> N;\n\tassert(N <= 400);\n\tfor (int i = 0; i < N; i++) cin >> l[i] >> r[i];\n\tint ret = 999999999;\n\tfor (int i = -400; i <= 400; i++) ret = min(ret, solve(0, i));\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long N, L[1 << 18], R[1 << 18];\n\n// 傾きがある点をすべて入れる\nmultiset<long long> cl, cr;\nlong long offset_l, offset_r, Answer;\n\nint main() {\n\tscanf(\"%lld\", &N);\n\tfor (int i = 1; i <= N; i++) scanf(\"%lld%lld\", &L[i], &R[i]);\n\n\tcl.insert(L[1]);\n\tcr.insert(L[1]);\n\n\tfor (int i = 2; i <= N; i++) {\n\t\toffset_l += (R[i] - L[i]);\n\t\toffset_r += (R[i - 1] - L[i - 1]);\n\n\t\tauto itr1 = cl.end(); itr1--;\n\t\tauto itr2 = cr.begin();\n\t\tlong long el = (*itr1) - offset_l, er = (*itr2) + offset_r;\n\t\tif (el <= L[i] && L[i] <= er) {\n\t\t\tcl.insert(L[i] + offset_l);\n\t\t\tcr.insert(L[i] - offset_r);\n\t\t}\n\t\telse if (L[i] < el) {\n\t\t\tAnswer += (el - L[i]);\n\t\t\tcl.erase(itr1);\n\t\t\tcr.insert(el - offset_r);\n\t\t\tcl.insert(L[i] + offset_l);\n\t\t\tcl.insert(L[i] + offset_l);\n\t\t}\n\t\telse if (L[i] > er) {\n\t\t\tAnswer += (L[i] - er);\n\t\t\tcr.erase(itr2);\n\t\t\tcl.insert(er + offset_l);\n\t\t\tcr.insert(L[i] - offset_r);\n\t\t\tcr.insert(L[i] - offset_r);\n\t\t}\n\t}\n\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\n\nlong long L[N], R[N], len[N];\n\nlong long ans;\npriority_queue<long long> que1, que2;\nlong long l, r, add1, add2;\n\nint main() {\n\t\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n; cin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> L[i] >> R[i], len[i] = R[i] - L[i] + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i == 1) {\n\t\t\tl = r = L[1];\n\t\t\tque1.push(l - add1), que2.push(-(r - add2));\n\t\t\tcontinue;\n\t\t}\n\t\tadd1 -= len[i] - 1;\n\t\tadd2 += len[i - 1] - 1;\n\t\tl -= len[i] - 1;\n\t\tr += len[i - 1] - 1;\n\t\tif (l <= L[i] && L[i] <= r) {\n\t\t\tl = r = L[i];\n\t\t\tque1.push(l - add1), que2.push(-(r - add2));\n\t\t} else if (L[i] < l) {\n\t\t\tque1.push(L[i] - add1);\n\t\t\tque1.push(L[i] - add1);\n\t\t\tque2.push(-(l - add2));\n\t\t\tr = l;\n\t\t\tque1.pop();\n\t\t\tl = que1.top() + add1;\n\t\t\tans += abs(L[i] - r);\n\t\t} else if (r < L[i]) {\n\t\t\tque2.push(-(L[i] - add2));\n\t\t\tque2.push(-(L[i] - add2));\n\t\t\tque1.push(r - add1);\n\t\t\tl = r;\n\t\t\tque2.pop();\n\t\t\tr = -que2.top() + add2;\n\t\t\tans += abs(L[i] - l);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint n;\n\nint l[405],r[405];\nint d[405][405];\n\nint go(int now, int leftx){\n    \n    if(now == n+1) return 0;\n    \n    int &ans = d[now][leftx];\n    if(ans!=-1) return ans;\n    \n    int rightx = leftx+r[now-1]-l[now-1];\n    \n    ans = 987654321;\n    \n    for(int left=1;left<=400;left++){\n        int right = left + r[now] - l[now];\n        \n        if(right < leftx || rightx < left) continue;\n        ans = min(ans, go(now+1,left) + abs(left-l[now]));\n    }\n    return ans;\n}\n\nint main(){\n    \n    scanf(\"%d\",&n);\n    if(n>=401) return 0;\n\n    for(int i=1;i<=n;i++){\n        scanf(\"%d %d\",&l[i],&r[i]);\n    }\n    memset(d,-1,sizeof(d));\n    int res = 987654321;\n  //  for(int i=1;i<=400;i++){\n        res = min(res,go(1,l[0]));\n    //}\n    printf(\"%d\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\nmultiset<ll> L, R;\nll C, lp, rp;\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    L.insert(-S[0].first);\n    R.insert(S[0].first);\n    C = lp = rp = 0;\n    for(int i = 1; i < N; i++) {\n        int plen = S[i - 1].second - S[i - 1].first;\n        int clen = S[i].second - S[i].first;\n        ll x = S[i].first;\n/*\n        set<int>::iterator it;\n        cout << \"L : \";\n        for(it = L.begin(); it != L.end(); it++) {\n            cout << -lp - *it << ' ';\n        }\n        cout << endl;\n        cout << \"R : \";\n        for(it = R.begin(); it != R.end(); it++) {\n            cout << rp + *it << ' ';\n        }\n        cout << endl;\n//*/\n        lp += clen;\n        rp += plen;\n\n        if(-lp - *L.begin() <= x && x <= rp + *R.begin()) {\n            L.insert(-lp - x);\n            R.insert(-rp + x);\n        }\n        else if(x < -lp - *L.begin()) {\n            ll tx = -lp - *L.begin();\n            L.erase(L.begin());\n            L.insert(-lp - x);\n            ll ttx = -lp - *L.begin();\n\n            R.insert(-rp + tx);\n            C += tx - x;\n        }\n        else if(rp + *R.begin() < x) {\n            ll tx = rp + *R.begin();\n            R.erase(R.begin());\n            R.insert(-rp + x);\n            ll ttx = rp + *R.begin();\n\n            L.insert(-lp - tx);\n            C += x - tx;\n        }\n    }\n    printf(\"%lld\", C);\n}\n"
  },
  {
    "language": "C++",
    "code": "//new.cpp\n/*\nAuthor : Hocky Yudhiono\nJum 12 Apr 2019 10:03:22  WIB\nCurrent Local Time : 10:03:22\n\ngetchar_unlocked > getchar > cin without sync > scanf > cin with sync\nbool operator<(const MyStruct& rhs) const\n\nOn how to print Long Double to 5 decimal places :\nprintf(\"%.5Lf\",ans);\n\nOn how to get random numbers :\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); //For int\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); //For LL\ncout << rng() << endl;\nshuffle(isi.begin(),isi.end(),rng);\n\n__gcd(a,b)\n__builtin_ffs(a) first on bit\n__builtin_clz(a) count leading zero\n__builtin_ctz(a) count trailing zero\n__builtin_popcount(a) numbers of on bits\n\n*/\n\n//#include <unordered_map>\n//#include <unordered_set>\n\n//#include <random>\n//#include <chrono>\n\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <cstdio>\n#include <limits>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n//using namespace __gnu_pbds;\nusing namespace std;\n\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(3)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n#pragma GCC target(\"f16c\")\n#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n// #pragma GCC diagnostic error \"-fwhole-program\"\n// #pragma GCC diagnostic error \"-fcse-skip-blocks\"\n// #pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n// #pragma GCC diagnostic error \"-std=c++14\"\n// #pragma GCC target (\"string\"...)\n#pragma GCC push_options\n#pragma GCC pop_options\n#pragma GCC reset_options\n#pragma GCC optimize (\"O3\")\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n// typedef tree<long long, null_type, less<long long>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n//If the time limit is strict, try not to use long double\n\n\n#define fbo find_by_order\n#define ook order_of_key\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define remove erase\n//Remember to undefine if the problem is interactive\n#define endl '\\n'\n#define DEBUG(X) cout << \">>> DEBUG(\" << __LINE__ << \") \" << #X << \" = \" << (X) << endl\n\nconst double eps = 1e-9;\nconst int INFMEM = 63;\nconst int INF = 1061109567;\nconst LL LINF = 4557430888798830399LL;\nconst double DINF = numeric_limits<double>::infinity();\nconst LL MOD = 1000000007;\nconst int dx[8] = {1,0,-1,0,1,1,-1,-1};\nconst int dy[8] = {0,1,0,-1,1,-1,1,-1};\nconst double PI = 3.141592653589793;\n\n#ifdef _WIN32\n#define getchar_unlocked getchar\n#endif\n#define GETCHAR getchar_unlocked\ninline void fastll(LL &input_number) \n{\n    input_number = 0;\n    int ch = GETCHAR();\n    int sign = 1;\n    while(ch < '0' || ch > '9'){\n        if(ch == '-') sign=-1;\n        ch = GETCHAR();\n    }\n    while(ch >= '0' && ch <= '9'){\n        input_number = (input_number << 3)+(input_number << 1) + ch-'0';\n        ch = GETCHAR();\n    }\n    input_number *= sign;\n}\n\ninline void open(string a){\n    freopen((a+\".in\").c_str(),\"r\",stdin);\n    freopen((a+\".out\").c_str(),\"w\",stdout);\n}\n\ninline void fasterios(){\n    //Do not use if interactive\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n}\n\nLL n,ans;\nLL l[100005];\nLL r[100005];\nLL len[100005]; \npriority_queue <LL> lower;\npriority_queue <LL, vector<LL>, greater<LL> > upper;\nLL lazylow, lazyhigh;\n\nint main(){\n    fasterios();\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n    \tcin >> l[i] >> r[i];\n    \tlen[i] = r[i]-l[i];\n    }\n    upper.push(l[1]); lower.push(l[1]);\n    for(int i = 2;i <= n;i++){\n    \tlazylow -= len[i];\n        lazyhigh += len[i-1];\n        if(l[i] <= lower.top()+lazylow){\n            LL shifted = lower.top()+lazylow;\n            ans += (shifted-l[i]);\n            lower.push(l[i]-lazylow);\n            lower.push(l[i]-lazylow);\n            lower.pop();\n            upper.push(shifted-lazyhigh);\n        }else if(l[i] >= upper.top()+lazyhigh){\n            LL shifted = upper.top()+lazyhigh;\n            ans += (l[i]-shifted);\n            upper.push(l[i]-lazyhigh);\n            upper.push(l[i]-lazyhigh);\n            upper.pop();\n            lower.push(shifted-lazylow);\n        }else{\n            lower.push(l[i]-lazylow);\n            upper.push(l[i]-lazyhigh);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP(a, n) REP(i, n) printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ')\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n\ntypedef long long ll;\n\nconst int N_MAX = 100000;\n\nint N;\nint l[N_MAX];\nint r[N_MAX];\nint w[N_MAX];\n\nset<ll> ls, rs;\nll lf, rf;\nll ans;\n\nvoid solve() {\n  REP(i, N) w[i] = r[i] - l[i];\n  ls.insert(l[0]); rs.insert(l[0]);\n  ans = 0;\n  lf = rf = 0;\n  FOR(i, 1, N - 1) {\n    // printf(\"ls: {\"); ITR(ls, it) printf(\"%lld, \", *it + lf); printf(\"}\\n\");\n    // printf(\"rs: {\"); ITR(rs, it) printf(\"%lld, \", *it + rf); printf(\"}\\n\");\n    lf -= w[i]; rf += w[i - 1];\n    ll le = *ls.rbegin() + lf;\n    ll re = *rs.begin() + rf;\n    ll l3 = l[i];\n    // printf(\"i: %d, e: (%lld, %lld), l3: %lld\\n\", i, le, re, l3);\n    if (l3 > re) {\n      rs.erase(re - rf);\n      ls.insert(re - lf);\n      rs.insert(l3 - rf);\n      ans += l3 - re;\n      // printf(\"rs->ls: %lld, rs << %lld, ans += %lld\\n\", re, l3, l3 - re);\n    } else if (l3 < le) {\n      ls.erase(le - lf);\n      rs.insert(le - rf);\n      ls.insert(l3 - lf);\n      ans += le - l3;\n      // printf(\"ls->rs: %lld, ls << %lld, ans += %lld\\n\", le, l3, le - l3);\n    } else {\n      ls.insert(l3 - lf);\n      rs.insert(l3 - rf);\n      // printf(\"ls << %lld rs << %lld, ans += 0\\n\", l3, l3);\n    }\n  }\n  // printf(\"ls: {\"); ITR(ls, it) printf(\"%lld, \", *it + lf); printf(\"}\\n\");\n  // printf(\"rs: {\"); ITR(rs, it) printf(\"%lld, \", *it + rf); printf(\"}\\n\");\n  printf(\"%lld\\n\", ans);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) {\n    scanf(\"%d%d\", l + i, r + i);\n  }\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define loopinc(i, a, b, inc) for(int i = a; i < (b); i += inc)\n#define loop(i, a, b) for(int i = a; i < (b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rrep(i, n) for (int i = n-1; i >= 0; i--)\n#define endl \"\\n\"\n#define all(c) (c).begin(),(c).end()\n#define lloopinc(i, a, b, inc) for(ll i = a; i < (b); i += inc)\n#define lloop(i, a, b) for(ll i = a; i < (b); i++)\n#define lrep(i, n) lloop(i, 0, n)\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef tuple<int, int, int> tiii;\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\nsigned main() {\n\t// freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<bitset<5000>> flags(k);\n\tloop(i, 1, k) rep(j, n) flags[i][j] = true;\n\tvi arr(n);\n\tbitset<5000> tmp;\n\trep(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\tarr[i] = a;\n\t\tfor(int j = k-a-1; j >= 0; j--) if (!flags[j][i]) {\n\t\t\ttmp.reset();\n\t\t\ttmp = flags[j];\n\t\t\ttmp[i] = true;\n\t\t\tflags[j+a] &= tmp;\n\t\t}\n\t}\n\tint total = n;\n\trep(i, n) for (int j = k-1; j >= k-arr[i]; j--) if (!flags[j][i]) {\n\t\ttotal--;\n\t\tbreak;\n\t}\n\tcout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\nusing namespace std;\nint dp[410][2000];\nint n;\nint ans=1e9;\nint l[410],r[410];\nint mabs(int x)\n{\n\tif(x<0)return -x;return x;\n}\nint main()\n{\n\tint bs=1000;\n\tscanf(\"%d\",&n);\n\tif(n>400)\n\t{\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",l+i,r+i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint ln=r[i-1]-l[i-1];\n\t\tfor(int j=-400;j<=400;j++)\n\t\t{\n\t\t\tdp[i][j+bs]=1e9;\n\t\t\tint cst=mabs(l[i]-j);\n\t\t\tfor(int k=j-ln;k<=j+r[i]-l[i];k++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][k+bs]==1e9)continue;\n\t\t\t\tdp[i][j+bs]=min(dp[i][j+bs],dp[i-1][k+bs]+cst);\n\t\t\t\tif(i==n)ans=min(ans,dp[i][j+bs]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\n\tll l, r, len;\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\t\tPQL.push(r - pbl);\n\t\tPQR.push(pbr - r);\n\t\twhile (true) {\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t}\n\t\tpbl -= len;\n\t}\n\t\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\n\nint main() {\n    int n;\n    cin >> n;\n    if (n > 400) return 0;\n    VI l(n), r(n);\n    REP(i,n) scanf(\"%d %d\", &l[i], &r[i]);\n    int m = 401;\n    VVI dp(n, VI(m, INF));\n    REP(i,n){\n        if (i == 0){\n            REP(j,m) dp[i][j] = abs(j-l[i]);\n            continue;\n        }\n        REP(j,m){\n            int x = r[i] - l[i], y = r[i-1] - l[i-1];\n            REP(k,m){\n                if ((j >= k && j <= k+y) || (j+x >= k && j+x <= k+y) || (j <= k && j+x >= k+y)){\n                    dp[i][j] = min(dp[i][j], dp[i-1][k] + abs(j-l[i]));\n                }\n            }\n        }\n    }\n    int ans = INF;\n    REP(j,m) ans = min(ans, dp[n-1][j]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> pll;\n\nconst int mod=1000000000+7;\n\nint addm(int& a,int b) {return (a+=b)<mod?a:a-=mod;}\n\ntemplate<class T,class U> bool smin(T& a,U b) {return a>b?(a=b,1):0;}\ntemplate<class T,class U> bool smax(T& a,U b) {return a<b?(a=b,1):0;}\n\nll dp[401][401];\nint N;\nii rngs[400];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> N;\n\tfor (int i=0;i<N;i++) cin >> rngs[i].x >> rngs[i].y;\n\tfor (int i=0;i<N;i++) {\n\t\tfor (int j=0;j<=400;j++) {\n\t\t\tif (i==0) dp[i+1][j]=abs(j-rngs[i].x);\n\t\t\telse {\n\t\t\t\tint mi=min_element(dp[i],dp[i]+401)-dp[i];\n\t\t\t\tint l=j-(rngs[i-1].y-rngs[i-1].x);\n\t\t\t\tif (l<0) l=0;\n\t\t\t\tint r=j+rngs[i].y-rngs[i].x;\n\t\t\t\tif (r>400) r=400;\n\t\t\t\tif (l<=mi && mi<=r) dp[i+1][j]=abs(j-rngs[i].x)+dp[i][mi];\n\t\t\t\telse dp[i+1][j]=abs(j-rngs[i].x)+min(dp[i][l],dp[i][r]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << *min_element(dp[N],dp[N]+401) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,a,n)     for(int i=a;i<n;i++)\n#define rep3(n)        for(int i=0;i<n;i++)\n#define ll             long long\n#define int            long long\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define endl           \"\\n\"\n#define eb             emplace_back\n#define x              first\n#define y              second\n#define gcd(a,b)       __gcd(a,b)\n#define mem1(a)        memset(a,-1,sizeof(a))\n#define mem0(a)        memset(a,0,sizeof(a))\n#define pres(a,x)      a.find(x)!=a.end()\n#define sz(a)          (int)a.size()\n#define pii            pair<int,int>\n#define hell           1000000007\n#define elasped_time   1.0 * clock() / CLOCKS_PER_SEC\nusing namespace std;\n\n\ntemplate<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<\" \"<<a.y;return out;}\ntemplate<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}\ntemplate<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}\n\nconst int N=500;\nint dp[N][N];\n\nint solve(){\n \tint n;cin>>n;\n \tvector<pii>vec(n+1);\n \trep(i,1,n+1){\n \t\tcin>>vec[i];\n \t}\n \t//sort(vec.begin()+1,vec.end(),[&](pii p1,pii p2){return p1.x<p2.x;});\n \tfor(int i=1;i<=400;i++){\n \t\tfor(int j=1;j<=400;j++)dp[i][j]=1e18;\n \t}\n \tfor(int i=1;i<=400;i++){\n \t\tdp[1][i]=abs(i-vec[1].x);\n \t}\n \tfor(int i=2;i<=n;i++){\n \t\tfor(int j=1;j<=400;j++){\n \t\t\tint r2=vec[i-1].y-vec[i-1].x+j;\n \t\t\tint l2=j;\n \t\t\tfor(int k=1;k<=400;k++){\n \t\t\t\tint r1=vec[i].y-vec[i].x+k;\n \t\t\t\tint l1=k;\n \t\t\t\tif(max(l1,l2)<=min(r2,r1))mins(dp[i][k],abs(l1-vec[i].x)+dp[i-1][j]);\t\n \t\t\t}\t\n \t\t}\n \t}\n \tint mn=1e18;\n \trep(i,1,401)mins(mn,dp[n][i]);\n \tcout<<mn<<endl;\n return 0;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #ifdef SIEVE\n    sieve();\n    #endif\n    #ifdef NCR\n    init();\n    #endif\n    int t=1;//cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 1e5 + 5;\n\npair<int, int> seg[DIM];\nmultiset<long long> lft, rgt;\n\nint main(void)\n{\n    int n;\n    scanf(\"%d\", &n);\n    \n    long long ld = 0, rd = 0, ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d %d\", &seg[i].first, &seg[i].second);\n        \n        if (i == 1) {\n            lft.insert(seg[i].first);\n            rgt.insert(seg[i].first);\n        }\n        else {\n            ld += seg[i].second - seg[i].first;\n            rd += seg[i - 1].second - seg[i - 1].first;\n            \n            long long ps = seg[i].first,\n                      le = *lft.rbegin() - ld,\n                      ri = *rgt.begin()  + rd;\n        \n            if (ps < le) {\n                ans += le - ps;\n                lft.erase(prev(lft.end()));\n                \n                lft.insert(ps + ld);\n                lft.insert(ps + ld);\n                rgt.insert(le - rd);\n            }\n            else\n            if (ps > ri) {\n                ans += ps - ri;\n                rgt.erase(rgt.begin());\n                \n                rgt.insert(ps - rd);\n                rgt.insert(ps - rd);\n                lft.insert(ri + ld);\n            }\n            else {\n                lft.insert(ps + ld);\n                rgt.insert(ps - rd);\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) //cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) //cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vi l(n), r(n), width(n);\n  rep (i, n) {\n    scanf(\"%d%d\", &l[i], &r[i]);\n    width[i] = r[i] - l[i];\n  }\n  int left_offset, right_offset;\n  left_offset = right_offset = 0;\n  ll minval = 0;\n  set<int> left;\n  left.insert(l[0]);\n  auto right = left;\n\n  FOR (i, 1, n) {\n    left_offset -= width[i];\n    right_offset += width[i-1];\n    debug2(left_offset, right_offset);\n    auto min_left = --end(left);\n    auto min_right = begin(right);\n    debug2(*min_left, *min_right);\n    debug(minval);\n    if (*min_left + left_offset <= l[i] && l[i] <= *min_right + right_offset) {\n      left.insert(l[i] - left_offset);\n      right.insert(l[i] - right_offset);\n    } else {\n      if (l[i] < *min_left + left_offset) {\n        minval += *min_left + left_offset - l[i];\n\n        right.insert(*min_left + left_offset - right_offset);\n        left.erase(min_left);\n        left.insert(l[i] - left_offset);\n        left.insert(l[i] - left_offset);\n      } else {\n        minval += l[i] - (*min_right + right_offset);\n\n        left.insert(*min_right + right_offset - left_offset);\n        right.erase(min_right);\n        right.insert(l[i] - right_offset);\n        right.insert(l[i] - right_offset);\n      }\n    }\n  }\n  printf(\"%lld\\n\", minval);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define fi first\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<ll,int> ii;\ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\npbds pos,neg;\nint timer;\nll len[100011];\nll shiftpos,shiftneg;\nvoid addpos(ll x){pos.insert(mp(x-shiftpos,timer++));}\nvoid addneg(ll x){neg.insert(mp(x-shiftneg,timer++));}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tll m=0; ll c=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tlen[i]=r-l;\n\t\tif(i>0){shiftpos+=len[i-1];\tc-=len[i-1]*m;}\n\t\tshiftneg-=len[i];addpos(l); addpos(l);\n\t\tauto it=pos.begin();\n\t\tll res=it->fi+shiftpos;\n\t\tpos.erase(pos.begin()); addneg(res);\n\t\tll neglas=prev(neg.end())->fi+shiftneg;\n\t\tll posles=pos.begin()->fi+shiftpos;\n\t\tif(!neg.empty()&&neglas>posles)\n\t\t{\n\t\t\tneg.erase(prev(neg.end())); pos.erase(pos.begin());\n\t\t\taddpos(neglas); addneg(posles);\n\t\t}\n\t\tm++; c-=l;\n\t}\n\twhile(m>0)\n\t{\n\t\tc+=(*prev(pos.end())).fi+shiftpos; m--; pos.erase(prev(pos.end()));\n\t}\n\tcout<<c<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n), len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0]; ll my = 0;\n\tmultiset<ll> sl, sr;\n\tll adle = 0, adri = 0;\n\trep1(i, n - 1) {\n\t\tml -= len[i]; mr += len[i - 1];\n\t\tif (l[i] < ml) {\n\t\t\tll dif = ml - l[i];\n\t\t\tsl.insert(dif-adle);\n\t\t\tmy += dif;\n\t\t\tsr.insert(- adri);adri += mr - ml;\n\t\t\tmr = ml;\n\t\t\tint nl = *sl.begin(); sl.erase(sl.begin());\n\t\t\tassert(nl + adle >= 0);\n\t\t\tml -= nl + adle;\n\t\t\tadle -= nl + adle;\n\t\t}\n\t\telse if (l[i] > mr) {\n\t\t\tll dif = l[i] - mr;\n\t\t\tsr.insert(dif - adri);\n\t\t\tmy += dif;\n\t\t\tsl.insert(- adle); adle += mr - ml;\n\t\t\tml = mr;\n\t\t\tint nr = *sr.begin(); sr.erase(sr.begin());\n\t\t\tassert(nr + adri >= 0);\n\t\t\tmr += nr + adri;\n\t\t\tadri -= nr + adri;\n\t\t}\n\t\telse {\n\t\t\tsl.insert(-adle), sr.insert(-adri);\n\t\t\tadle += l[i] - ml; adri += mr - l[i];\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#define For(i, a, b) for (int i = a; i < b; ++i)\n#define Out(i, a, b) for (int i = a - 1; i >= b; --i)\n#define pb push_back\n#define x first\n#define y second\n#define files(FileName) read(FileName); write(FileName)\n#define read(FileName) freopen((FileName + \".in\").c_str(), \"r\", stdin)\n#define write(FileName) freopen((FileName + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \n  \nconst string FileName = \"input\";\n \ntypedef long long base;\n \nconst int MAXN = 2e4;\n \n int n;\nint LR[401][2];\nint dp[401][401];\n\nint main() {\n    ios::sync_with_stdio(0);\n    //read(FileName);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> LR[i][0] >> LR[i][1];\n        --LR[i][0], --LR[i][1];\n    }\n    for (int i = 0; i < 400; ++i) {\n        for (int j = 0; j < 400; ++j) {\n            dp[i][j] = 1e9;\n        }\n    }\n    for (int i = 0; i < 400; ++i) {\n        dp[0][i] = abs(i - LR[0][0]);\n    }\n    for (int i = 1; i < n; ++i) {\n        int Ln = LR[i][0], Rn = LR[i][1];\n        for (int j = 0; j < 400; ++j) {\n            // if (j <= 5) {\n            //     cout << i - 1 << ' ' << j << ' ' << dp[i - 1][j] << endl; \n            // }\n            int L = j, R = j - LR[i][0] + LR[i][1];\n            // if (j <= 5) {\n            //     cout << Ln << ' ' << Rn << ' ' << L << ' ' << R << endl;\n            // }\n            if (max(L, Ln) <= min(R, Rn)) {\n                chkmin(dp[i][L], dp[i - 1][j]);\n                for (int q = Ln - R + L; q <= Rn; ++q) {\n                    if (q >= 0 && q <= 399)\n                        chkmin(dp[i][q], dp[i - 1][q] + abs(q - L));\n                }\n            } else {\n                if (R < Ln) {\n                    for (int q = Ln - R + L, d = Ln - R; q <= Rn; ++q, ++d) {\n                        if (q >= 0 && q <= 399)\n                            chkmin(dp[i][q], dp[i - 1][q] + d);\n                    }\n                } else {\n                    for (int q = Rn, d = L - Rn; q - L + R >= Ln; --q, ++d) {\n                        if (q >= 0 && q <= 399) \n                            chkmin(dp[i][q], dp[i - 1][q] + d);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    for (int i = 0; i < 399; ++i) {\n        chkmin(ans, dp[n - 1][i]);\n    }\n    cout << ans << endl;\n}  \n \n/*\n2 AB 11\n2!2\n3 ABB 122\n3!3\n4 ABB 2222\n4!3\n5 ABBBB 12222\n5!5\n6 ABBB 121222\n6!4\n7 ABBBB 1212122\n7!5\n8 ABBB 12121212\n8!4\n9 ABBBBBBBB 122222222\n9!9\n10 ABBBBB 1212222222\n10!6\n11 ABBBBBBBB 12121222222\n11!9\n12 ABBBBB 121212122222\n12!6\n13 ABBBBBBBB 1212121212222\n13!9\n14 ABBBBB 12121212121222\n14!6\n15 ABBBBBBBB 121212121212122\n15!9\n16 ABBBBB 1212121212121212\n16!6\n17 ABBBBBBBBBBBBBBBB 12222222222222222\n17!17\n18 ABBBBBBBBB 121222222222222222\n18!10\n19 ABBBBBBBBBBBBBBBB 1212122222222222222\n19!17\n20 ABBBBBBBBB 12121212222222222222\n20!10\n[Finished in 3.1s]\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename C, typename T> vector<T> prefixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0R (i, sz(v)) res[i+1] = res[i] + v[i]; return res;\n    }\n    template<typename C, typename T> vector<T> suffixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0Rd (i, sz(v)) res[i] = v[i] + res[i+1]; return res;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.precision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N);\n    assert(N <= 400);\n\n    vi l(N), r(N);\n    F0R (i, N) {\n        re(l[i], r[i]);\n        assert(r[i] <= 400);\n        r[i] -= l[i];\n    }\n\n    l.insert(l.begin(), 0);\n    r.insert(r.begin(), 400);\n    N++;\n\n    const int MAXV = 400, INF = 1e9;\n\n    vi dp(MAXV, INF); dp[0] = 0;\n    FOR (i, 1, N) {\n        vi DP(MAXV, INF);\n        F0R (j, MAXV) {\n            int mc = INF;\n            F0R (k, MAXV) {\n                if (k + r[i-1] < j || j + r[i] < k) continue;\n                ckmin(mc, dp[k]);\n            }\n            DP[j] = abs(l[i] - j) + mc;\n        }\n        dp = move(DP);\n    }\n\n    ps(*min_element(all(dp)));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 2e5 + 5;\nconst int mod = 998244353;\nint l[maxn] , r[maxn];\nint n;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    priority_queue<ll> lo;\n    priority_queue<ll,vector<ll>,greater<ll>> hi;\n    cin >> n;\n    for(int i = 0 ; i < n ; ++i)cin >> l[i] >> r[i];\n    ll res = 0;\n    lo.push(l[0]);hi.push(l[0]);\n    ll xl = 0 , xr = 0;\n    for(int i = 1 ; i < n ; ++i){\n        xl += r[i] - l[i];\n        xr += r[i - 1] - l[i - 1];\n        ll cl = lo.top() - xl;\n        ll cr = hi.top() + xr;\n        if(cl <= l[i] && l[i] <= cr){\n            lo.push(l[i] + xl);\n            hi.push(l[i] - xr);\n        }else if(cr < l[i]){\n            res += l[i] - cr;\n            hi.pop();\n            lo.push(cr + xl);\n            hi.push(l[i] - xr);\n            hi.push(l[i] - xr);\n        }else{\n            res += cl - l[i];\n            lo.pop();\n            hi.push(cl - xr);\n            lo.push(l[i] + xl);\n            lo.push(l[i] + xl);\n        }\n    }\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n\nusing namespace std;\n\nconst int inf = 1e9;\n\nint n;\nvector<int> l, r, len;\n\nint calc(int start_l) {\n\tint cost = abs(start_l - l[0]);\n\tint now_l = start_l;\n\tint now_r = start_l + len[0];\n\n\tint next_l, next_r;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (now_r < l[i]) {\n\t\t\tcost += l[i] - now_r;\n\t\t\tnext_l = now_r;\n\t\t\tnext_r = next_l + len[i];\n\t\t} else if (r[i] < now_l) {\n\t\t\tcost += now_l - r[i];\n\t\t\tnext_r = now_l;\n\t\t\tnext_l = next_r - len[i];\n\t\t} else {\n\t\t\tnext_l = l[i];\n\t\t\tnext_r = r[i];\n\t\t}\n\n\t\tnow_l = next_l;\n\t\tnow_r = next_r;\n\t}\n\n\treturn cost;\n}\n\nint main() {\n\tcin >> n;\n\n\tl.assign(n, 0);\n\tr.assign(n, 0);\n\tlen.assign(n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tlen[i] = r[i] - l[i];\n\t}\n\n\tif (n > 400) {\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (r[i] > 400) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint ans = inf;\n\tfor (int i = 0; i <= 400; i++) {\n\t\tint val = calc(i);\n\t\tans = min(val, ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n//using namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n \n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint N, best[400][400], ans = MOD;\nvector<pii> x;\n\nint main() {\n\tcin >> N; x.resize(N);\n\tF0R(i,N) cin >> x[i].f >> x[i].s;\n\tF0R(i,400) F0R(j,400) best[i][j] = MOD;\n\tF0R(i,N) {\n\t\tint lo = 0, hi = -1;\n\t\tmultiset<int> cur;\n\t\tF0R(j,401-(x[i].s-x[i].f)) {\n\t\t\tif (i) {\n\t\t\t\twhile (hi<min(400,j+x[i].s-x[i].f+1)-1) cur.insert(best[i-1][++hi]);\n\t\t\t\twhile (lo<max(0,j-(x[i-1].s-x[i-1].f))) cur.erase(cur.find(best[i-1][lo++]));\n\t\t\t\tbest[i][j] = min(best[i][j],*cur.begin());\n\t\t\t} else best[i][j] = 0;\n\t\t\tbest[i][j] += abs(x[i].f-j);\n\t\t\tif (i == N-1) ans = min(ans,best[i][j]);\n\t\t}\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 410;\n\nint l[N], r[N], len[N], f[N][N];\n\nint main () {\n\n\tFile();\n\n\tint n = read();\n\n\tFor (i, 1, n) \n\t\tl[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n\n\tint maxl = *max_element(r + 1, r + n + 1);\n\tFor (i, 1, maxl) f[1][i] = abs(i - r[1]);\n\n\tFor (i, 2, n) For (j, 1, maxl) {\n\t\tf[i][j] = 1e9;\n\t\tFor (k, 1, maxl) if (k - len[i - 1] <= j && j <= k + len[i])\n\t\t\tchkmin(f[i][j], f[i - 1][k]);\n\t\tf[i][j] += abs(j - r[i]);\n\t\t//\tcout << i << ' ' << j << ' ' << f[i][j] << endl;\n\t}\n\n\tint ans = 1e9;\n\tFor (j, 1, maxl) chkmin(ans, f[n][j]);\n\tprintf (\"%d\\n\", ans);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nint N;\nll L[100000], R[100000];\nmultiset<ll> LS, RS;\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> N; for (int j = 0; j < N; ++j) cin >> L[j] >> R[j];\n\n    ll lo = 0, ro = 0, ans = 0;\n\n    LS.insert(-(1LL << 60));\n    RS.insert(1LL << 60);\n\n    for (int j = 0; j < N; ++j) {\n        if (j > 0) {\n            lo -= R[j] - L[j];\n            ro += R[j-1] - L[j-1];\n        }\n\n        if (L[j] < *LS.rbegin() + lo) {\n            ans += (*LS.rbegin() + lo) - L[j];\n\n            RS.insert((*LS.rbegin() + lo) - ro);\n            LS.insert(L[j] - lo);\n            LS.insert(L[j] - lo);\n            LS.erase(LS.find(*LS.rbegin()));\n        } else if (L[j] > *RS.begin() + ro) {\n            ans += L[j] - (*RS.begin() + ro);\n\n            LS.insert((*RS.begin() + ro) - lo);\n            RS.insert(L[j] - ro);\n            RS.insert(L[j] - ro);\n            RS.erase(RS.begin());\n        } else {\n            LS.insert(L[j] - lo);\n            RS.insert(L[j] - ro);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvll L(N), R(N);\n\tfor (int i = 0; i < N; i++) cin >> L[i] >> R[i];\t\n\tmultiset<ll> ls, rs;\n\tll ofl = 0, ofr = 0;\n\n\tls.insert(L[0]);\n\trs.insert(L[0]);\n\n\tll ret = 0;\t\n\tfor (int i = 1; i < N; i++) {\n\t\tofl -= (R[i] - L[i]);\n\t\tofr += (R[i-1] - L[i-1]);\n\n\t\tif (*begin(rs)+ofr < L[i]) ret += L[i] - (*begin(rs)+ofr);\n\t\tif (L[i] < *rbegin(ls)+ofl) ret += (*rbegin(ls)+ofl) - L[i];\n\n\t\tif (*begin(rs)+ofr < L[i]) {\n\t\t\tls.insert(*begin(rs)+ofr-ofl);\n\t\t\trs.insert(L[i]-ofr);\n\t\t\trs.insert(L[i]-ofr);\n\t\t\trs.erase(begin(rs));\t\n\t\t} else if (L[i] < *rbegin(ls)+ofl) {\n\t\t\trs.insert(*rbegin(ls)+ofl-ofr);\n\t\t\tls.insert(L[i]-ofl);\n\t\t\tls.insert(L[i]-ofl);\n\t\t\tls.erase(--end(ls));\n\t\t} else {\n\t\t\trs.insert(L[i]-ofr);\n\t\t\tls.insert(L[i]-ofl);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 1000 * 1000 * 1000;\nconst int MAXN = 410;\nconst int MAXL = 410;\n\nint A[MAXN][MAXL];\n\nint n;\nvector<int> left_coord, right_coord, len;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n;\n    left_coord.resize(n);\n    right_coord.resize(n);\n    len.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> left_coord[i] >> right_coord[i];\n        len[i] = right_coord[i] - left_coord[i];\n    }\n\n    for (int i = 0; i < MAXN; i++) {\n        for (int j = 0; j < MAXL; j++) {\n            A[i][j] = inf;\n        }\n    }\n\n    for (int l = 0; l + len[0] <= MAXL; l++) {\n        A[0][l] = abs(left_coord[0] - l);\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int pred_l = 0; pred_l < MAXL; pred_l++) {\n            if (A[i - 1][pred_l] == inf) {\n                continue;\n            }\n            for (int new_l = pred_l - len[i];\n                 new_l <= pred_l + len[i - 1] && new_l < MAXL; new_l++) {\n                A[i][new_l] = min(\n                    A[i][new_l],\n                    A[i - 1][pred_l] + abs(left_coord[i] - new_l)\n                );\n            }\n        }\n    }\n    int ans = inf;\n    for (int l = 0; l < MAXL; l++) {\n        ans = min(ans, A[n - 1][l]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nll r[10005], l[10005];\n\nll f(int idx) {\n    ll L = l[idx];\n    ll R = r[idx];\n    ll ret = 0;\n    for (int i = idx - 1; i >= 0; i--) {\n        // cout << \"now: \" << L << \", \" << R << endl;\n        if (r[i] < L) {\n            ll d = L - r[i];\n            ret += d;\n            L = l[i] + d;\n            R = r[i] + d;\n        } else if (R < l[i]) {\n            ll d = l[i] - R;\n            ret += d;\n            L = l[i] - d;\n            R = r[i] - d;\n        } else {\n            L = l[i];\n            R = r[i];\n        }\n    }\n    L = l[idx];\n    R = r[idx];\n    rep(i, N) if (idx < i) {\n        if (r[i] < L) {\n            ll d = L - r[i];\n            ret += d;\n            L = l[i] + d;\n            R = r[i] + d;\n        } else if (R < l[i]) {\n            ll d = l[i] - R;\n            ret += d;\n            L = l[i] - d;\n            R = r[i] - d;\n        } else {\n            L = l[i];\n            R = r[i];\n        }\n    }\n    return ret;\n}\nint main() {\n    cin >> N;\n    rep(i, N) cin >> l[i] >> r[i];\n    if (N > 400) return 0;\n    ll ans = INF;\n    rep(i, N) {\n        ll t = f(i);\n        // cout << t << endl;\n        ans = min(t, ans);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n\nint main() {\n  int N;\n  std::cin >> N;\n\n  std::vector<long long> l(N);\n  std::vector<long long> r(N);\n\n  for (int i = 0; i < N; ++i)\n    std::cin >> l[i] >> r[i];\n\n  std::vector<long long> W(N);\n  for (int i = 0; i < N; ++i)\n    W[i] = r[i] - l[i];\n\n  std::vector<std::vector<long long>> bpX(N);\n  std::vector<std::vector<long long>> bpY(N);\n  std::vector<int> minIndex(N, -1);\n\n  const long long M = 10000000000;\n  bpX[0].push_back(-M);\n  bpX[0].push_back(l[0]);\n  bpX[0].push_back(M);\n  bpY[0].push_back(l[0] + M);\n  bpY[0].push_back(0);\n  bpY[0].push_back(M - l[0]);\n  minIndex[0] = 1;\n\n  for (int i = 1; i < N; ++i) {\n    for (int j = 0; j <= minIndex[i - 1]; ++j) {\n      bpX[i].push_back(bpX[i - 1][j] - W[i]);\n      bpY[i].push_back(bpY[i - 1][j]);\n    }\n    for (int j = minIndex[i - 1]; j < bpX[i - 1].size(); ++j) {\n      bpX[i].push_back(bpX[i - 1][j] + W[i - 1]);\n      bpY[i].push_back(bpY[i - 1][j]);\n    }\n\n    int k = 0; // bpX[i][k] <= l[i] < bpX[i][k + 1]\n    while (bpX[i][k + 1] <= l[i])\n      ++k;\n\n    for (int j = 0; j <= k; ++j)\n      bpY[i][j] += l[i] - bpX[i][j];\n\n    // insert\n    if (bpX[i][k] < l[i]) {\n      bpX[i].insert(bpX[i].begin() + k + 1, l[i]);\n\n      long long grad =\n          (bpY[i][k + 1] - bpY[i][k]) / (bpX[i][k + 1] - bpX[i][k]);\n      long long value = bpY[i][k] + grad * (l[i] - bpX[i][k]);\n      bpY[i].insert(bpY[i].begin() + k + 1, value);\n    }\n\n    for (int j = k + 1; j < bpX[i].size(); ++j)\n      bpY[i][j] += bpX[i][j] - l[i];\n\n    long long minVal = M;\n    for (int j = 0; j < bpX[i].size(); ++j) {\n      if (bpY[i][j] < minVal) {\n        minIndex[i] = j;\n        minVal = bpY[i][j];\n      }\n    }\n  }\n\n  std::cout << bpY[N - 1][minIndex[N -1]] << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define LL long long\n\nconst int N=1e5+50;\nint n,L[N],R[N];\nLL ans,tl,tr,lq,rq;\npriority_queue < LL,vector<LL>,less<LL> > Left; \npriority_queue < LL,vector<LL>,greater<LL> > Right;\n\ntemplate<typename elemType>\ninline void Read(elemType &T){\n    elemType X=0,w=0; char ch=0;\n    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}\n    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n    T=(w?-X:X);\n}\n\nint main() {\n    Read(n);\n    for(register int i=1;i<=n;++i){\n        Read(L[i]);Read(R[i]);\n        L[i]=R[i]-L[i];\n    }\n    Left.push(R[1]);\n    Right.push(R[1]);\n    \n    for(register int i=2;i<=n;++i){\n        tl-=L[i-1];\n        tr+=L[i];\n        lq=Left.top()+tl;\n        rq=Right.top()+tr;\n        if(lq<=R[i] && R[i]<=rq){\n            Left.push(R[i]-tl);\n            Right.push(R[i]-tr);\n        }\n        else if(R[i]>=lq){\n            ans+=R[i]-rq;\n            Right.pop();\n            Left.push(rq-tl);\n            Right.push(R[i]-tr);\n            Right.push(R[i]-tr);\n        }\n        else{\n            ans+=lq-R[i];\n            Left.pop();\n            Right.push(lq-tr);\n            Left.push(R[i]-tl);\n            Left.push(R[i]-tl);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\n#include <random>\n#include <ctime>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nmt19937 mt_rand(time(NULL));\nstruct Treap {\n  int k, p, cnt, lazy;\n  long long sum;\n  Treap *ch[2];\n  Treap(int k) : k(k), sum(k), p(mt_rand()), cnt(1), lazy(0) {\n    ch[0] = ch[1] = NULL;\n  }\n};\ninline int count(Treap *t) { return t == NULL ? 0 : t->cnt; }\ninline long long sum(Treap *t) { return t == NULL ? 0 : t->sum; }\ninline void setLazy(Treap *t, int v) {\n  if (t == NULL) return;\n  t->lazy += v;\n  t->k += v;\n  t->sum += 1LL*v*t->cnt;\n}\ninline void push(Treap *t) {\n  if (t == NULL || t->lazy == 0) return;\n  setLazy(t->ch[0], t->lazy);\n  setLazy(t->ch[1], t->lazy);\n  t->lazy = 0;\n}\ninline Treap* update(Treap *t) {\n  if (t == NULL) return t;\n  push(t);\n  t->cnt = 1 + count(t->ch[0]) + count(t->ch[1]);\n  t->sum = t->k + sum(t->ch[0]) + sum(t->ch[1]);\n  return t;\n}\nTreap *merge(Treap *l, Treap *r) {\n  if (l == NULL) return r;\n  if (r == NULL) return l;\n  if (l->p > r->p) {\n    push(l);\n    l->ch[1] = merge(l->ch[1], r);\n    return update(l);\n  }\n  else {\n    push(r);\n    r->ch[0] = merge(l, r->ch[0]);\n    return update(r);\n  }\n}\npair<Treap*, Treap*> split_by_cnt(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (k <= count(t->ch[0])) {\n    auto s = split_by_cnt(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n  else {\n    auto s = split_by_cnt(t->ch[1], k-1-count(t->ch[0]));\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n}\npair<Treap*, Treap*> split_by_key(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (t->k < k) {\n    auto s = split_by_key(t->ch[1], k);\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n  else {\n    auto s = split_by_key(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n}\n\nint find(Treap *t, int k) {\n  if (t == NULL) return INF;\n  push(t);\n  if (k < count(t->ch[0])) return find(t->ch[0], k);\n  else if (k == count(t->ch[0])) return t->k;\n  else return find(t->ch[1], k-1-count(t->ch[0]));\n}\nTreap *insert(Treap *t, int k) {\n  auto s = split_by_key(t, k);\n  return merge(merge(s._1, new Treap(k)), s._2);\n}\nvoid add_key(Treap *t, int v) { setLazy(t, v); }\n\nvoid print(Treap *t) {\n  if (t == NULL) return;\n  push(t);\n  print(t->ch[0]);\n  cout << t->k<<\",\";\n  print(t->ch[1]);\n}\n\nint N;\nint L[100000], R[100000];\nTreap *S;\nlong long f(int x) {\n  auto s = split_by_key(S, x);\n  long long ret = 1LL*x*count(s._1)-sum(s._1) + sum(s._2)-1LL*x*count(s._2);\n  S = merge(s._1, s._2);\n  return ret;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> L[i] >> R[i];\n  long long C = 0;\n  S = insert(S, L[0]);\n  S = insert(S, L[0]);\n  rep(i, N-1) {\n    int len = R[i+1]-L[i+1] + R[i]-L[i];\n    int shift = R[i]-L[i];\n    auto s = split_by_cnt(S, ((S->cnt-1)/2)+1);\n    add_key(s._1, -len);\n    C -= count(s._1)*len;\n    S = merge(s._1, s._2);\n    add_key(S, shift);\n    S = insert(S, L[i+1]);\n    S = insert(S, L[i+1]);\n    int center = find(S, (S->cnt-1)/2);\n  }\n  int center = find(S, (S->cnt-1)/2);\n  cout << (f(center)+C)/2 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int N;\nlong long int l[100000], r[100000];\nlong long int width[100000];\nlong long int ans, box;\nlong long int dp[400][401];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\twidth[i] = r[i] - l[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= 400; j++)dp[i][j] = INT_MAX;\n\t}\n\tfor (int i = 1; i <= 400; i++) {\n\t\tdp[0][i] = abs(l[0] - i);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 1; j <= 400; j++) {\n\t\t\tfor (int k = max((long long int)1, j - width[i - 1]); k <= min((long long int)400, j + width[i]); k++) {\n\t\t\t\tdp[i][j] = min(dp[i - 1][k] + abs(l[i] - j), dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tans = LLONG_MAX;\n\tfor (int i = 1; i <= 40; i++) {\n\t\tans = min(ans, dp[N - 1][i]);\n\t\t//cout << dp[N - 1][i] << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nsigned main() {\n\tint N;\n\tcin >> N;\n\n\tvector<int> l(N), r(N);\n\trep(i, N) {\n\t\tcin >> l[i] >> r[i];\n\t\t//if (l[i] > 400 || r[i] > 400) return 0;\n\t}\n\n\tif (N > 400) return 0;\n\n\tint ret = INT_MAX;\n\trep(i, N) {\n\t\tint cost = 0;\n\t\tvector<int> cl = l, cr = r;\n\t\tfor (int j = i; j > 0; j--) {\n\t\t\tif (max(cl[j], cl[j - 1]) <= min(cr[j], cr[j - 1])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cr[j] < cl[j - 1]) {\n\t\t\t\tint plus = cl[j - 1] - cr[j];\n\t\t\t\tcost += plus;\n\t\t\t\tcl[j - 1] -= plus;\n\t\t\t\tcr[j - 1] -= plus;\n\t\t\t} else {\n\t\t\t\tint plus = cl[j] - cr[j - 1];\n\t\t\t\tcost += plus;\n\t\t\t\tcl[j - 1] += plus;\n\t\t\t\tcr[j - 1] += plus;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i; j < N - 1; j++) {\n\t\t\tif (max(cl[j], cl[j + 1]) <= min(cr[j], cr[j + 1])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cr[j] < cl[j + 1]) {\n\t\t\t\tint plus = cl[j + 1] - cr[j];\n\t\t\t\tcost += plus;\n\t\t\t\tcl[j + 1] -= plus;\n\t\t\t\tcr[j + 1] -= plus;\n\t\t\t} else {\n\t\t\t\tint plus = cl[j] - cr[j + 1];\n\t\t\t\tcost += plus;\n\t\t\t\tcl[j + 1] += plus;\n\t\t\t\tcr[j + 1] += plus;\n\t\t\t}\n\t\t}\n\t\tret = min(ret, cost);\n\t}\n\n\tcout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\nint n;\nll l[100000], r[100000];\n\nint main(){\n    I(n);\n    rep(i,n) L(l[i],r[i]);\n    ll ans = INF*(ll)INF;\n    rep(i,n){\n        ll cnt = 0;\n        ll nowl = l[i], nowr = r[i];\n        for(int j = i+1;  j < n; j++){\n            if(nowl > r[j]){\n                cnt += nowl-r[j];\n                nowr = nowl;\n                nowl = nowr-(r[j]-l[j]);\n            } else if(nowr < l[j]){\n                cnt += l[j]-nowr;\n                nowl = nowr;\n                nowr = nowl + (r[j]-l[j]);\n            } else{\n                nowl = l[j];\n                nowr = r[j];\n            }\n        }\n        nowl = l[i]; nowr = r[i];\n        for(int j = i-1; j >= 0; j--){\n            if(nowl > r[j]){\n                cnt += nowl-r[j];\n                nowr = nowl;\n                nowl = nowr-(r[j]-l[j]);\n            } else if(nowr < l[j]){\n                cnt += l[j]-nowr;\n                nowl = nowr;\n                nowr = nowl + (r[j]-l[j]);\n            } else{\n                nowl = l[j];\n                nowr = r[j];\n            }\n        }\n        ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define fs first\n#define sc second\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef vector<double> vd;\n\nint main() {\n    int i, n;\n    ll val, dshift, ushift, uv, dv;\n    scanf(\"%d\", &n);\n    vll l(n), r(n);\n    for(i=0; i<n; i++) scanf(\"%lld%lld\", &l[i], &r[i]);\n    priority_queue<ll, vector<ll>, less<ll>> down;\n    priority_queue<ll, vector<ll>, greater<ll>> up;\n    down.push(l[0]);\n    up.push(l[0]);\n    val=dshift=ushift=0;\n    for(i=1; i<n; i++) {\n        dshift-=r[i]-l[i];\n        ushift+=r[i-1]-l[i-1];\n        dv=down.top()+dshift;\n        uv=up.top()+ushift;\n        if(l[i]>=dv && l[i]<=uv) {\n            down.push(l[i]-dshift);\n            up.push(l[i]-ushift);\n        }\n        else if(l[i]<=dv) {\n            val+=min(abs(l[i]-dv), abs(l[i]-uv));\n            down.pop();\n            up.push(dv-ushift);\n            down.push(l[i]-dshift);\n            down.push(l[i]-dshift);\n        }\n        else {\n            val+=min(abs(l[i]-dv), abs(l[i]-uv));\n            up.pop();\n            down.push(uv-dshift);\n            up.push(l[i]-ushift);\n            up.push(l[i]-ushift);\n        }\n    }\n    printf(\"%lld\\n\", val);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAXN=1e5+10;\nint n,l[MAXN],r[MAXN];\nll ls,rs,res=0;\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll> > R;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&l[i],&r[i]);\n    L.push(l[1]);R.push(r[1]);\n    for(int i=2;i<=n;i++)\n    {\n        ls-=r[i]-l[i];rs+=r[i-1]-l[i-1];\n        ll lb=L.top()+ls,rb=R.top()+rs;\n        if(l[i]<lb)\n        {\n            res+=lb-l[i];R.push(lb-rs);\n            L.push(l[i]-ls);L.push(l[i]-ls);L.pop();\n        }\n        else if(l[i]>rb)\n        {\n            res+=l[i]-rb;L.push(rb-ls);\n            R.push(l[i]-rs);R.push(l[i]-rs);R.pop();\n        }\n        else\n        {\n            L.push(l[i]-ls);\n            R.push(l[i]-rs);\n        }\n    }\n    printf(\"%lld\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a) {\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    vector<ll> l(n), r(n);\n    REP(i, n) cin >> l[i] >> r[i];\n\n    ll offsetL = 0, offsetR = 0, ret = 0;\n    multiset<ll> left, right;\n    left.insert(-LLINF);\n    right.insert(LLINF);\n    REP(i, n) {\n        if(i != 0) {\n            offsetR += r[i-1] - l[i-1];\n            offsetL -= r[i] - l[i];\n        }\n//        cout << offsetL << \" \" << offsetR;\n\n        if(*left.rbegin() + offsetL > l[i]) {\n            ret += *left.rbegin() + offsetL - l[i];\n            right.insert(*left.rbegin() + offsetL - offsetR);\n            left.insert(l[i]-offsetL);\n            left.insert(l[i]-offsetL);\n            left.erase(prev(left.end()));\n        } else if(*right.begin() + offsetR < l[i]) {\n            ret += l[i] - *right.begin() - offsetR;\n            left.insert(*right.begin() + offsetR - offsetL);\n            right.insert(l[i]-offsetR);\n            right.insert(l[i]-offsetR);\n            right.erase(right.begin());\n        } else {\n            left.insert(l[i]-offsetL);\n            right.insert(l[i]-offsetR);\n        }\n\n//        cout << \" \" << ret << endl;\n//        for(auto j: left) cout << j << \" \";\n//        cout << endl;\n//        for(auto j: right) cout << j << \" \";\n//        cout << endl;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(r[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    Int x=r[i]-l[i];\n    dL-=x;dR+=x;\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(l[i]<dL+*latte){\n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n#define MAX 410\nint dp[MAX][MAX] = {};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tassert(N <= 500);\n\tvector<int> l(N), r(N); rep(i, 0, N) { cin >> l[i] >> r[i]; }\n\tmemset(dp, 0x3f, sizeof(dp));\n\trep(i, 0, MAX - (r[0] - l[0])) {\n\t\tdp[0][i] = abs(i - l[0]);\n\t}\n\trep(i, 0, N - 1) {\n\t\trep(j, 0, MAX - (r[i + 1] - l[i + 1])) {\n\t\t\trep(k, 0, r[i + 1] - l[i + 1] + j + 1) {\n\t\t\t\tchmin(dp[i + 1][j], dp[i][k] + abs(j - l[i + 1]));\n\t\t\t}\n\t\t}\n\t\tdump(dp[i]);\n\t}\n\tcout << *min_element(all(dp[N - 1])) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define all(x) (x).begin() , (x).end()\n#define rall(x) (x).rbegin() , (x).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define int long long\nconst int N = 801;\nll dp[2][N];\nconst ll inf = 1e18;\nsigned main(){\n    int n;cin >> n;\n    vector < pair < int , int > > line(n + 1);\n    for(int i = 1; i <= n; ++i)\n        cin >> line[i].fi >> line[i].se;\n    line[0] = {0 , 0};\n    for(int i = 1 ; i <= n; ++i){\n        fill(dp[i&1] , dp[i&1] + N , inf);\n        int l , r , l1 , r1;\n        for(int j = 0; j < N; ++j){\n            l = j , r = j + line[i].se - line[i].fi;\n            if(r >= N)continue;\n            for(int prev = 0 ; prev < N; ++prev){\n                l1 = prev , r1 = prev + line[i-1].se - line[i-1].fi;\n                if(r < l1 || r1 < l)continue;\n                dp[i&1][j] = min(dp[i&1][j] , dp[(i&1)^1][prev] + abs(line[i].fi - l));\n            }\n        }\n    }\n    int ans = *min_element(dp[n&1] , dp[n&1] + N);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sync ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define F first\n#define S second\n#define pb emplace_back\n#define mt make_tuple\n#define mp make_pair\n#define gcd __gcd\n#define PI 3.141592653589\n// Input\n#define in(a) scanf(\"%d\",&a)\n#define in2(a,b) scanf(\"%d%d\",&a,&b)\n#define in3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define llin(a) cin >> a\n#define inl(a) scanf(\"%lld\",&a)\n#define read(v,i,n) for(i=0;i<n;i++)in(v[i])\n#define twod(mat,i,j,n,m) rep(i,n){rep(j,m)in(mat[i][j]);}\n#define sc(ch) scanf(\"%c\",&ch)\n#define sstr(str) scanf(\"%s\",str)\n// Output\n#define pr(a) printf(\"%d \",a)\n#define pr2(a,b) printf(\"%d %d\\n\",a,b)\n#define pr3(a,b,c) printf(\"%d %d %d\\n\",a,b,c)\n#define out(a) printf(\"%d\\n\",a)\n#define outl(a) printf(\"%lld\\n\",a)\n#define llpr(a) cout << a << \" \"\n#define llout(a) cout << a << \"\\n\"\n#define yes printf(\"YES\\n\")\n#define no printf(\"NO\\n\")\n#define lin printf(\"\\n\")\n// Iterator\n#define lp(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) for(i=0;i<n;i++)\n#define all(vec) vec.begin(),vec.end()\n#define lower(v,k) lower_bound(v.begin(),v.end(),k)-v.begin()\n#define upper(v,k) upper_bound(v.begin(),v.end(),k)-v.begin()\n#define tf(mytuple) get<0>(mytuple)\n#define ts(mytuple) get<1>(mytuple)\n#define tt(mytuple) get<2>(mytuple)\n// Debug\n#define dbg(v,i,n) for(i=0;i<n;i++)pr(v[i]); lin\n#define what(x) cerr << #x << \" : \" << x << \"\\n\"\n#define ck printf(\"continue\\n\")\n#define debug(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n\tcerr << *it << \" = \" << a << \"\\n\";\n\terr(++it, args...);\n}\n// Data Type\n#define ll long long int\n#define ii pair<int,int>\n#define pli pair<ll,int>\n#define triple tuple<int,int,int>\n#define vi vector<int>\n#define vii vector<pair<int,int> >\n#define vvi vector<vector<int> >\n#define viii vector<pair<pair<int,int>,int> >\n#define vvii vector<vector<pair<int,int> > >\n#define M 1000000007\n#define N 10005  //check the limits, man\nconst ll INF = 1e18;\nint main()\n{\n    int i,n,a,b,temp,k;\n    in(n);\n    vii v(n);\n    rep(i,n)\n        in2(v[i].F,v[i].S);\n    int ans=M;\n    lp(k,1,401)\n    {\n        temp=0;\n        rep(i,n)\n        {\n            a=v[i].F,b=v[i].S;\n            if(k<a)\n                temp+=(a-k);\n            else if(k>b)\n                temp+=(k-b);\n        }\n        ans=min(ans,temp);\n    }\n    out(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n), len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0]; ll my = 0;\n\tmultiset<ll> sl, sr;\n\tll adle = 0, adri = 0;\n\trep1(i, n - 1) {\n\t\tml -= len[i]; mr += len[i - 1];\n\t\tif (l[i] <= ml) {\n\t\t\tll dif = ml - l[i];\n\t\t\tsl.insert(dif-adle);\n\t\t\tmy += dif;\n\t\t\tsr.insert(- adri);adri += mr - ml;\n\t\t\tmr = ml;\n\t\t\tll nl = *sl.begin(); sl.erase(sl.begin());\n\t\t\tnl += adle;\n\t\t\tml -= nl;\n\t\t\tadle -= nl;\n\t\t}\n\t\telse if (l[i] => mr) {\n\t\t\tll dif = l[i] - mr;\n\t\t\tsr.insert(dif - adri);\n\t\t\tmy += dif;\n\t\t\tsl.insert(- adle); adle += mr - ml;\n\t\t\tml = mr;\n\t\t\tll nr = *sr.begin(); sr.erase(sr.begin());\n\t\t\tnr += adri;\n\t\t\tmr += nr;\n\t\t\tadri -= nr;\n\t\t}\n\t\telse {\n\t\t\tsl.insert(-adle), sr.insert(-adri);\n\t\t\tadle += l[i] - ml; adri += mr - l[i];\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\tstop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint l[405],r[405];\nint d[405][405];\n\nint go(int now,int leftx){\n    if(now == n) return 0;\n    \n    int &ans = d[now][leftx];\n    if(ans!=-1) return ans;\n    int rightend = leftx + r[now-1]-l[now-1];\n    ans = 987654321;\n    for(int k=1;k<=400;k++){\n        \n        int rnew = k + r[now] - l[now];\n        //if(rnew < leftx || rnow < k) continue;\n        if(max(k,leftx) <= min(rnew,rightend)){\n            ans = min(ans,go(now+1,k) + abs(k-l[now]));\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    if(n>=401) return 0;\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d %d\",&l[i],&r[i]);\n    }\n    memset(d,-1,sizeof(d));\n    int res = 987654321;\n    for(int i=1;i<=400;i++){\n        res = min(res,go(1,i)+abs(i-l[0]));\n    }\n    printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e5 + 10;\nint l[maxN], r[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> l[i] >> r[i];\n    }\n    if (n == 1) {\n        cout << 0;\n        return 0;\n    }\n    multiset < ll > S1, S2;\n    S1.insert(r[1]);\n    S2.insert(r[1]);\n    ll shift1 = 0;\n    ll shift2 = 0;\n    ll ans = 0;\n    for (int i = 2; i <= n; i++) {\n        ll len1 = r[i] - l[i];\n        ll len2 = r[i - 1] - l[i - 1];\n        shift1 -= len2;\n        shift2 += len1;\n        ll stL = *(prev(S1.end())) + shift1;\n        ll stR = *S2.begin() + shift2;\n        if (r[i] >= stR) {\n            S2.erase(S2.find(stR - shift2));\n            S2.insert(r[i] - shift2);\n            S2.insert(r[i] - shift2);\n            S1.insert(stR - shift1);\n            ans += r[i] - stR;\n        }\n        else if (r[i] <= stL) {\n            S1.erase(S1.find(stL - shift1));\n            S1.insert(r[i] - shift1);\n            S1.insert(r[i] - shift1);\n            S2.insert(stL - shift1);\n            ans += stL - r[i];\n        }\n        else {\n            S1.insert(r[i] - shift1);\n            S2.insert(r[i] - shift2);\n        }\n        // should take min(x - len1,\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\nint mem[MAXN][MAXN];\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= r[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tcin >> n;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> l[i] >> r[i];\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 0;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <unordered_map>\n#include <cmath>\n#include <cstdlib>\n#include <memory.h>\n#include <ctime>\n#include <bitset>\n\nusing namespace std;\n\n#define ABS(a) ((a>0)?a:-(a))\n#define MIN(a,b) ((a<b)?(a):(b))\n#define MAX(a,b) ((a<b)?(b):(a))\n#define FOR(i,a,n) for (int i=(a);i<(n);++i)\n#define FI(i,n) for (int i=0; i<(n); ++i)\n#define pnt pair <int, int>\n#define mp make_pair\n#define PI 3.1415926535897\n#define MEMS(a,b) memset(a,b,sizeof(a))\n#define LL long long\n#define U unsigned\n\nconst int MAGIC = 410;\nint dp[MAGIC][MAGIC];\nint l[MAGIC];\nint r[MAGIC];\nint n;\nconst int INF = 1000000000;\n\nint rec(int p, int last) {\n\tif (p == n) {\n\t\treturn 0;\n\t}\n\tif (dp[p][last] != -1) {\n\t\treturn dp[p][last];\n\t}\n\tint l1 = last;\n\tint r1 = last + r[p - 1] - l[p - 1];\n\tint res = INF;\n\tFOR(pos, 0, MAGIC) {\n\t\tint l2 = pos;\n\t\tint r2 = l2 + r[p] - l[p];\n\t\tint val1 = max(l1, l2);\n\t\tint val2 = min(r1, r2);\n\t\tif (val1 <= val2) {\n\t\t\tres = min(res, ABS(pos - l[p]) + rec(p + 1, pos));\n\t\t}\n\t}\n\treturn dp[p][last] = res;\n}\n\nint main()\n{\n#ifdef Fcdkbear\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tdouble beg = clock();\n\t//freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tFOR(i, 0, n) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tMEMS(dp, -1);\n\tint res = INF;\n\tFOR(pos, 0, MAGIC) {\n\t\tres = min(res, rec(1, pos) + ABS(l[0] - pos));\n\t}\n\tcout << res << endl;\n\n#ifdef Fcdkbear\n\tdouble end = clock();\n\tfprintf(stderr, \"*** Total time = %.3lf ***\\n\", (end - beg) / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst long long MAXN = 1e5+5;\n    long long n;\nlong long ans;\nlong long dp[MAXN];\nlong long l[MAXN];\nlong long r[MAXN];\nlong long check(long long x){\n    long long tmp = 0;\n    for(long long i=1;i<=n;i++){\n        if(l[i]<=x && x<=r[i]){\n          \n            continue;\n        }\n        \n        tmp+=min(abs(x-l[i]),abs(x-r[i]));\n    }\n    return tmp;\n}\nint main(){\n\n    cin>>n;\n\tfor(long long i=1;i<=n;i++){\n\t    cin>>l[i]>>r[i];\n\t}\n\tlong long le =0;\n\tlong long ri= 1e9;\n\t//cout<<check(333333333)<<endl;\n\twhile(ri-le>2){\n\t    \n\t    long long m1 = le + (ri-le)/3;\n\t    long long m2 = ri - (ri-le)/3;\n\t    long long f1 = check(m1);\n\t    long long f2 = check(m2);\n        if(ri<=10){\n\t    \t//cout<<le<<\" \"<<ri<<\" \"<<f1<<\" \"<<f2<<endl;\n        }\n\t    if(f1<=f2){\n\t        ri = m2;\n\t    }else{\n\t        le = m1;\n\t    }\n\t}\n    \n //   cout<<le+1<<\" \"<<check(le+1)<<endl;\n\tcout<<min(check(le),min(check(le+1),check(le+2)))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) //cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) //cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vll l(n), r(n), width(n);\n  rep (i, n) {\n    scanf(\"%lld%lld\", &l[i], &r[i]);\n    width[i] = r[i] - l[i];\n  }\n  ll left_offset, right_offset;\n  left_offset = right_offset = 0;\n  ll minval = 0;\n  set<ll> left;\n  left.insert(l[0]);\n  auto right = left;\n\n  FOR (i, 1, n) {\n    left_offset -= width[i];\n    right_offset += width[i-1];\n    debug2(left_offset, right_offset);\n    auto min_left = --end(left);\n    auto min_right = begin(right);\n    debug2(*min_left, *min_right);\n    debug(minval);\n    assert(*min_left + left_offset <= *min_right + right_offset);\n    if (*min_left + left_offset <= l[i] && l[i] <= *min_right + right_offset) {\n      left.insert(l[i] - left_offset);\n      right.insert(l[i] - right_offset);\n    } else {\n      if (l[i] < *min_left + left_offset) {\n        minval += *min_left + left_offset - l[i];\n\n        right.insert(*min_left + left_offset - right_offset);\n        left.erase(min_left);\n        left.insert(l[i] - left_offset);\n        left.insert(l[i] - left_offset);\n      } else {\n        minval += l[i] - (*min_right + right_offset);\n\n        left.insert(*min_right + right_offset - left_offset);\n        right.erase(min_right);\n        right.insert(l[i] - right_offset);\n        right.insert(l[i] - right_offset);\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", minval);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 dp[401][401];\ni64 l[401], r[401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n\n    if (!(n < 401 && maxr < 401)) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(1, 400, j) {\n            if (l[i] <= j && j <= r[i]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = j < l[i] ? l[i]-j : j-r[i];\n            }\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(1, 400, j) {\n        i64 d = 0;\n        upto(1, n, i) {\n            d+=dp[i][j];\n        }\n        ans = min(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    //assert(N <= 400);\n    vec l(N), r(N), w(N);\n    REP(i, N){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--;\n        w[i] = r[i] - l[i];\n        //assert(0 <= l[i] && r[i] < 400);\n    }\n\n    multiset<int> sl, sr;\n    int off_l = 0, off_r = 0;\n    int m = 0;\n    sl.insert(l[0]); sr.insert(r[0]);\n\n    FOR(i, 1, N){\n        off_l -= w[i];\n        off_r += w[i - 1];\n\n        auto itl = --(sl.end()), itr = sr.begin();\n        int xl = *itl + off_l, xr = *itr + off_r;\n        if(xl <= l[i] && l[i] <= xr){\n            sl.insert(l[i] - off_l);\n            sr.insert(l[i] - off_r);\n        }else if(l[i] > xr){\n            sr.erase(itr);\n            sl.insert(xr - off_l);\n            REP(_, 2) sr.insert(l[i] - off_r);\n\n            int xr2 = *(sr.begin()) + off_r;\n            m += llabs(xr - xr2) + llabs(l[i] - xr2);\n        }else{\n            sl.erase(itl);\n            sr.insert(xl - off_r);\n            REP(_, 2) sl.insert(l[i] - off_l);\n\n            int xl2 = *(--sl.end()) + off_l;\n            m += llabs(xl - xl2) + llabs(l[i] - xl2);\n        }\n    }\n    Out(m);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INT long long\n#define ED 20\nusing namespace std;\n\nint n, dt[440][440], l[440], r[440], ans = 1987654321;\n\nint main()\n{\n    cin>>n;\n    memset(dt, 0x3f, sizeof(dt));\n    for(int i = 0 ; i < n ; i++ ) cin>>l[i]>>r[i];\n    for(int i = 0 ; i < n ; i++ ) for(int j = 1 ; j <= ED-(r[i]-l[i]) ; j++ )\n    {\n        if( i == 0 ) dt[i][j] = abs(j-l[i]);\n        else for(int k = max(1, j-(r[i-1]-l[i-1])) ; k <= min(j+(r[i]-l[i]), k+((r[i-1]-l[i-1]))) ; k++ )\n        {\n            dt[i][j] = min(dt[i][j], dt[i-1][k] + abs(j-l[i]) );\n        }\n    }\n    for(int i = 1 ; i <= ED ; i++ ) ans = min( ans , dt[n-1][i] );\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\nint N;\nLL l[112345];\nLL r[112345];\nLL dp[500][500];\nint main() {\n\tcin >> N;\n\tif (N >= 500)return -1;\n\tfor (int i : range(N)) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (l[i] >= 500 || r[i] >= 500)return -1;\n\t}\n\tfor (int i : range(500))for (int j : range(500))dp[i][j] = 1e18;\n\tfor (int i : range(500)) {\n\t\tdp[0][i] = abs(l[0] - i);\n\t}\n\n\tfor (int i : range(1,N)) {\n\t\tfor (int j : range(500)) {\n\t\t\tfor (int k : range(500)) {\n\t\t\t\tLL a = j;\n\t\t\t\tLL b = j + r[i - 1] - l[i - 1];\n\t\t\t\tLL c = k;\n\t\t\t\tLL d = k + r[i] - l[i];\n\t\t\t\tif (b >= c && d >= a) {\n\t\t\t\t\tchmin(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tLL ret = 1e18;\n\tfor (int i : range(500)) {\n\t\tchmin(ret, dp[N - 1][i]);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 6;\n\nset< pair< int, int > > le, ri;\nint l[N], r[N];\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  long long now = 0;\n  int tmp = 0;\n  le.insert(make_pair(l[0], tmp++));\n  ri.insert(make_pair(l[0], tmp++));\n  long long offl = 0, offr = 0;\n  for (int i = 1; i < n; i++) {\n    int bef = r[i-1]-l[i-1], cur = r[i]-l[i];\n    offl -= cur;\n    offr += bef;\n    int midl = (--le.end())->first+offl, midr = ri.begin()->first+offr;\n    if (l[i] < midl) {\n      le.insert(make_pair(l[i]-offl, tmp++));\n      le.insert(make_pair(l[i]-offl, tmp++));\n      auto it = --le.end();\n      ri.insert(make_pair(midl-offr, tmp++));\n      le.erase(it);\n      now += midl-l[i];\n    }\n    else if (l[i] > midr) {\n      ri.insert(make_pair(l[i]-offr, tmp++));\n      ri.insert(make_pair(l[i]-offr, tmp++));\n      auto it = ri.begin();\n      le.insert(make_pair(midr-offl, tmp++));\n      ri.erase(it);\n      now += l[i] - midr;\n    }\n    else {\n      le.insert(make_pair(l[i]-offl, tmp++));\n      ri.insert(make_pair(l[i]-offr, tmp++));\n    }\n  }\n  cout << now << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int MAX = 500;\nconst int INF = 1145141919;\n\nint n;\nint l[400];\nint r[400];\n\nint dp[401][2 * MAX + 1];\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> l[i] >> r[i];\n\t\n\tfor (i = 0; i <= n; i++) for (j = 0; j <= 2 * MAX; j++) dp[i][j] = INF;\n\tdp[0][MAX] = 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j <= 2 * MAX; j++) {\n\t\t\tint low, high;\t\t//長方形iの移動量の下界と上界\n\t\t\t\n\t\t\tif (i == 0) {\n\t\t\t\tlow  = -MAX;\n\t\t\t\thigh =  MAX;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow  = (l[i - 1] + j - MAX) - r[i];\n\t\t\t\thigh = (r[i - 1] + j - MAX) - l[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor (k = max(-MAX, low); k <= min(MAX, high); k++) {\n\t\t\t\tdp[i + 1][k + MAX] = min(dp[i + 1][k + MAX], dp[i][j] + abs(k));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= 2 * MAX; j++) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tint ans = INF;\n\tfor (j = 0; j <= 2 * MAX; j++) {\n\t\tans = min(dp[n][j], ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, int val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    int p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    int p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 100002;\n\n\nint N;\nll maxR, maxL;\npair<ll, ll> points[MAXN];\nmultiset<ll> memo_r, memo_l;\n\n\nvoid input() {\n  cin >> N;\n  for (int i = 1 ; i <= N ; i++) {\n    cin >> points[i].first >> points[i].second;\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n\n  ll cost = 0;\n  for (int i = 1 ; i <= N ; i++) {\n    if (i > 1) {\n      maxR += points[i-1].second - points[i-1].first;\n      cost -= (points[i-1].second - points[i-1].first) * (i-1);\n    }\n    maxL -= points[i].second - points[i].first;\n    memo_r.insert(points[i].first - maxR);\n    memo_r.insert(points[i].first - maxR);\n    auto it = memo_r.begin();\n    ll val = (*it) + maxR;\n    memo_r.erase(memo_r.begin());\n    memo_l.insert(val-maxL);\n    ll lPos = (*prev(memo_l.end())) + maxL;\n    ll rPos = (*memo_r.begin()) + maxR;\n    if (!memo_l.empty() && lPos > rPos) {\n      memo_l.erase(prev(memo_l.end()));\n      memo_r.erase(memo_r.begin());\n      memo_l.insert(rPos-maxL);\n      memo_r.insert(lPos-maxR);\n    }\n    cost -= points[i].first;\n  }\n\n  for (int i = 1 ; i <= N ; i++) {\n    cost += (*prev(memo_r.end())) + maxR;\n    memo_r.erase(prev(memo_r.end()));\n  }\n\n  cout << cost;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF (1e9)\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 600\n#define P +MAXN\n \nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n \nint mem[MAXN][MAXN P];\nint myabs( int x ){\n\tif( x >= 0 ) return x;\n\telse return -x;\n}\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl P] != -1) return mem[pos][lastl P];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++){\n\t\tint nowans = dp(pos+1,nowl) + myabs(l[pos]-nowl);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\tmem[pos][lastl P] = ans;\n\treturn ans;\n}\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 0;i <= MAXN;i++){\n\t\tint nowans = dp(2,i) + myabs(i-l[1]);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\t\t\n\tprintf(\"%d\\n\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool fp[5005][5005], fr[5005][5005];\nint sr[5005][5005];\nint n, k, a[5005], an;\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\",&a[i]), a[i] = min(a[i], k);\n\tfp[0][0] = 1;\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j <= k; ++j){\n\t\t\tfp[i + 1][j] |= fp[i][j];\n\t\t\tfp[i + 1][min(j + a[i + 1], k)] |= fp[i][j];\n\t\t}\n\t}\n\tfr[n + 1][0] = 1;\n\tfor(int i = n + 1; i > 1; --i){\n\t\tfor(int j = k; j >= 0; --j){\n\t\t\tfr[i - 1][j] |= fr[i][j];\n\t\t\tfr[i - 1][min(j + a[i - 1], k)] |= fr[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n + 1; ++i){\n\t\tsr[i][0] = 1;\n\t\tfor(int j = 1; j <= k; ++j)\n\t\t\tsr[i][j] = sr[i][j - 1] + fr[i][j];\n\t}\n\tan = n;\n\tfor(int i = 1; i <= n; ++i){\n\t\tbool ok = 0;\n\t\tfor(int j = 0; j < k; ++j){\n\t\t\tint l = k - a[i] - j, r = k - 1 - j;\n\t\t\tl = max(l, 0);\n\t\t\tok |= (fp[i - 1][j] & (sr[i + 1][r] - (l ? sr[i + 1][l - 1] : 0) > 0));\n\t\t}\n\t\tan -= ok;\n\t}\n\tprintf(\"%d\", an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n#include<valarray>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\nint n;\nint l[112345], r[112345], x[112345];\n\n/// --- Treap Sequence Library {{{ ///\n#include <cstdint>\n#include <utility>\n\ntemplate < class M_act >\nstruct TreapSeq {\nprivate:\n  using u32 = uint_fast32_t;\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n  TreapSeq *l = nullptr, *r = nullptr;\n  X val;\n  X accum = Monoid::identity();\n  M lazy = M_act::identity();\n  bool rev = false;\n  int sz = 1;\n  u32 pri;\n  // call after touch its child\n  // a is not nullptr and is evaled, its child is proped\n  friend TreapSeq *prop(TreapSeq *a) {\n    a->sz = size(a->l) + 1 + size(a->r);\n    a->accum = Monoid::op(Monoid::op(Accumulated(a->l), a->val), Accumulated(a->r));\n    return a;\n  }\n  // call before use val, accum\n  friend void eval(TreapSeq *a) {\n    // if(a->lazy != M_act::identity()) {\n      a->val = M_act::actInto(a->lazy, 1, a->val);\n      a->accum = M_act::actInto(a->lazy, a->sz, a->accum);\n      if(a->l != nullptr) a->l->lazy = M_act::op(a->lazy, a->l->lazy);\n      if(a->r != nullptr) a->r->lazy = M_act::op(a->lazy, a->r->lazy);\n      a->lazy = M_act::identity();\n    // }\n    if(a->rev) {\n      swap(a->l, a->r);\n      if(a->l != nullptr) a->l->rev ^= 1;\n      if(a->r != nullptr) a->r->rev ^= 1;\n      a->rev = false;\n    }\n  }\n  friend X Accumulated(TreapSeq *a) {\n    return a == nullptr ? Monoid::identity() : (eval(a), a->accum);\n  }\n  /// --- XorShift128 Embeddable {{{ ///\n\n  struct XorShift128Embeddable {\n    using result_type = uint_fast32_t;\n    static constexpr result_type min() { return 0; }\n    static constexpr result_type max() { return 0xFFFFFFFF; }\n    result_type x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    XorShift128Embeddable(result_type seed = 0) { z ^= seed; }\n    result_type operator()() {\n      result_type t = x ^ (x << 11);\n      x = y, y = z, z = w;\n      return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n  };\n\n  /// }}}--- ///\n  u32 nextPriority() {\n    static XorShift128Embeddable xs(__LINE__ * 1333 + 57);\n    return xs();\n  }\n\npublic:\n  TreapSeq(X val, u32 pri) : val(val), pri(pri) {}\n  TreapSeq(X val = Monoid::identity()) : TreapSeq(val, nextPriority()) {}\n  friend TreapSeq *merge(TreapSeq *a, TreapSeq *b) {\n    if(a == nullptr) return b;\n    if(b == nullptr) return a;\n    eval(a);\n    eval(b);\n    if(a->pri > b->pri) {\n      a->r = merge(a->r, b);\n      return prop(a);\n    } else {\n      b->l = merge(a, b->l);\n      return prop(b);\n    }\n  }\n  friend int size(TreapSeq *a) { return a == nullptr ? 0 : a->sz; }\n  using PNN = pair< TreapSeq *, TreapSeq * >;\n  // [0, k), [k, n)\n  // 左のグループにk個いれる\n  friend PNN split(TreapSeq *a, int k) {\n    if(a == nullptr) return PNN(nullptr, nullptr);\n    eval(a);\n    TreapSeq *sl, *sr;\n    if(k <= size(a->l)) {\n      tie(sl, sr) = split(a->l, k);\n      a->l = sr;\n      return PNN(sl, prop(a));\n    } else {\n      tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n      a->r = sl;\n      return PNN(prop(a), sr);\n    }\n  }\n  friend void insert(TreapSeq *&a, int k, const X &x) {\n    TreapSeq *sl, *sr;\n    tie(sl, sr) = split(a, k);\n    a = merge(sl, merge(new TreapSeq(x), sr));\n  }\n  friend X erase(TreapSeq *&a, int k) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    a = merge(tl, sr);\n    return tr->val;\n  }\n  friend void erase(TreapSeq *&a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    a = merge(tl, sr);\n  }\n  friend void set1(TreapSeq *a, int k, X const &x) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    if(tr != nullptr) tr->val = tr->accum = x;\n    merge(merge(tl, tr), sr);\n  }\n  friend X get(TreapSeq *a, int k) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    X res = tr == nullptr ? Monoid::identity() : tr->val;\n    merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void act(TreapSeq *a, int l, int r, M const &m) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->lazy = M_act::op(m, tr->lazy);\n    merge(merge(tl, tr), sr);\n  }\n  friend X fold(TreapSeq *a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    X res = tr == nullptr ? Monoid::identity() : tr->accum;\n    merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void reverse(TreapSeq *a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->rev ^= 1;\n    merge(merge(tl, tr), sr);\n  }\n};\n\n/// }}}--- ///\n\n// ax + b, length\nusing P = pair<ll, ll>;\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(inf_monoid, inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return -T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return T(a.first + b.first, a.second + b.second); }\n  static constexpr T identity() { return T(0, 0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\n// template < class U = long long, class V = U >\n// struct RangeMinAdd {\n//   using X = U;\n//   using M = V;\n//   using Monoid = RangeMin< U >;\n//   static M op(const M &a, const M &b) { return a + b; }\n//   static constexpr M identity() { return M{0, 0}; }\n//   static X actInto(const M &m, ll, const X &x) { return m + x; }\n// };\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return -M(inf_monoid); }\n  static X actInto(const M &m, ll, const X &) { return m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return -M(inf_monoid); }\n  static X actInto(const M &m, ll, const X &) { return m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return M(a.first + b.first, a.second + b.second); }\n  static constexpr M identity() { return M(0, 0); }\n  static X actInto(const M &m, ll n, const X &x) { return X(m.first + x.first, m.second + x.second); }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return -M(inf_monoid); }\n  static X actInto(const M &m, ll n, const X &) { return m * n; }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, ll b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, ll n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, ll n, const X &) {\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, ll, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, ll, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, ll, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seq = TreapSeq< RangeSumAdd<P, P> > *;\nSeq seq = nullptr;\n\n\nconstexpr ll inf = 1e18;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> x[i] >> r[i], l[i] = r[i] - x[i];\n\n  insert(seq, 0, P{-inf, 0});\n  insert(seq, 1, P{0, inf});\n\n  ll bias = 0;\n  ll z = 0;\n\n  for(int i = 0; i < n; i++) {\n    dump(i);\n    {\n      int ok = 0, ng = size(seq) - 1;\n      while(abs(ok - ng) > 1) {\n        int mid = (ok + ng) >> 1;\n        if(fold(seq, 0, mid + 1).second - bias <= x[i]) ok = mid; else ng = mid;\n      }\n      dump(ok);\n      auto d = fold(seq, 0, ok + 1);\n      d.second -= bias;\n      if(d.second != x[i]) {\n        auto tap = x[i] - d.second;\n        auto eca = get(seq, ok + 1);\n        auto uku = eca;\n        eca.second = tap;\n        uku.second -= tap;\n        assert(uku.second > 0);\n        insert(seq, ok + 1, eca);\n        set1(seq, ok + 2, uku);\n        ok++;\n      }\n      act(seq, 0, ok + 1, P{-1, 0});\n      act(seq, ok + 1, size(seq), P{1, 0});\n      z += x[i] + bias;\n    }\n\n    if(i != n - 1) {\n      int ok = 0, ng = size(seq) - 1;\n      while(abs(ok - ng) > 1) {\n        int mid = (ok + ng) >> 1;\n        if(get(seq, mid).first < 0) ok = mid; else ng = mid;\n      }\n      dump(ok);\n      insert(seq, ok + 1, P{0, l[i] + l[i+1]});\n      bias += l[i+1];\n    }\n  }\n\n  dump(z);\n  ll ans = z;\n  for(int i = 1; i < size(seq); i++) {\n    auto p = get(seq, i);\n    dump(i, p);\n    if(p.first <= 0) {\n      z += p.first * p.second;\n      ans = min(ans, z);\n    } else break;\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// copied from ecnerwala\n#include<bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nconst int MAXN = 1.1e5;\nint N;\nll L[MAXN], R[MAXN];\n \n \nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n \n\tll cost = 0;\n \n\tll lo_shift = 0;\n\tpriority_queue<ll> lo;\n\tll hi_shift = 0;\n\tpriority_queue<ll, vector<ll>, greater<ll>> hi;\n\tlo.push(L[0] - lo_shift);\n\thi.push(L[0] - hi_shift);\n \n\tfor (int i = 1; i < N; i++) {\n\t\tlo_shift -= (R[i] - L[i]);\n\t\thi_shift += (R[i-1] - L[i-1]);\n \n\t\tll vlo = lo.top() + lo_shift;\n\t\tll vhi = hi.top() + hi_shift;\n\t\tif(vlo <= L[i] && L[i] <= vhi) {\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t} else if (vhi < L[i]) {\n\t\t\tcost += L[i] - vhi;\n\t\t\thi.pop();\n\t\t\tlo.push(vhi - lo_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t} else if (L[i] < vlo) {\n\t\t\tcost += vlo - L[i];\n\t\t\tlo.pop();\n\t\t\thi.push(vlo - hi_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t} else assert(false);\n\t}\n \n\tcout << cost << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll   = long long;\nusing uint = unsigned int;\nusing ull  = unsigned long long;\nusing ld   = long double;\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\nconstexpr int popcount(const ull v) { return v ? __builtin_popcountll(v) : 0; }\nconstexpr int log2p1(const ull v) { return v ? 64 - __builtin_clzll(v) : 0; }\nconstexpr int lsbp1(const ull v) { return __builtin_ffsll(v); }\nconstexpr int clog(const ull v) { return v ? log2p1(v - 1) : 0; }\nconstexpr ull ceil2(const ull v) { return 1ULL << clog(v); }\nconstexpr ull floor2(const ull v) { return v ? (1ULL << (log2p1(v) - 1)) : 0ULL; }\nconstexpr bool btest(const ull mask, const int ind) { return (mask >> ind) & 1ULL; }\ntemplate<typename T> void bset(T& mask, const int ind) { mask |= ((T)1 << ind); }\ntemplate<typename T> void breset(T& mask, const int ind) { mask &= ~((T)1 << ind); }\ntemplate<typename T> void bflip(T& mask, const int ind) { mask ^= ((T)1 << ind); }\ntemplate<typename T> void bset(T& mask, const int ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\n\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nconstexpr ull TEN(const int n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\ntemplate<typename F> struct fix : F\n{\n    fix(F&& f) : F{std::forward<F>(f)} {}\n    template<typename... Args> auto operator()(Args&&... args) const { return F::operator()(*this, std::forward<Args>(args)...); }\n};\nclass printer\n{\npublic:\n    printer(std::ostream& os_ = std::cout) : os{os_} {}\n    template<typename T> int operator()(const T& v) { return os << v, 0; }\n    template<typename T> int operator()(const std::vector<T>& vs)\n    {\n        for (int i = 0; i < (int)vs.size(); i++) { os << (i ? \" \" : \"\"), this->operator()(vs[i]); }\n        return 0;\n    }\n    template<typename T> int operator()(const std::vector<std::vector<T>>& vss)\n    {\n        for (int i = 0; i < (int)vss.size(); i++) { os << (0 <= i or i + 1 < (int)vss.size() ? \"\\n\" : \"\"), this->operator()(vss[i]); }\n        return 0;\n    }\n    template<typename T, typename... Args> int operator()(const T& v, const Args&... args) { return this->operator()(v), os << ' ', this->operator()(args...), 0; }\n    template<typename... Args> int ln(const Args&... args) { return this->operator()(args...), os << '\\n', 0; }\n    template<typename... Args> int el(const Args&... args) { return this->operator()(args...), os << std::endl, 0; }\n    template<typename... Args> int fmt(const std::string& s, const Args&... args) { return rec(s, 0, args...); }\n\nprivate:\n    int rec(const std::string& s, int index) { return os << s.substr(index, s.size()), 0; }\n    template<typename T, typename... Args> int rec(const std::string& s, int index, const T& v, const Args&... args) { return index == s.size() ? 0 : s[index] == '%' ? (this->operator()(v), rec(s, index + 1, args...)) : (os << s[index], rec(s, index + 1, v, args...)); }\n    std::ostream& os;\n};\nprinter out;\n\ntemplate<typename T, typename F> std::vector<T> generated(const int n, F f)\n{\n    std::vector<T> ans(n);\n    return std::generate(ans.begin(), ans.end(), f), ans;\n}\nstd::vector<int> ioted(const int n, const int offset = 0)\n{\n    std::vector<int> ans(n);\n    return std::iota(ans.begin(), ans.end(), offset), ans;\n}\ntemplate<typename Vs> Vs reversed(const Vs& vs)\n{\n    auto ans = vs;\n    return std::reverse(ans.begin(), ans.end()), ans;\n}\ntemplate<typename T, typename F = std::less<T>> std::vector<T> sorted(const std::vector<T>& vs, F comp = F{})\n{\n    auto ans = vs;\n    return std::sort(ans.begin(), ans.end(), comp), ans;\n}\ntemplate<typename F> std::vector<int> sorted_iota(const int n, F comp = F{}, const int offset = 0) { return sorted(ioted(n, offset), comp); }\nclass scanner\n{\npublic:\n    scanner(std::istream& is_ = std::cin) : is{is_} { is.tie(nullptr), std::ios::sync_with_stdio(false); }\n    template<typename T> T val()\n    {\n        static T v;\n        return is >> v, v;\n    }\n    template<typename T> T val(const T offset) { return val<T>() - offset; }\n    template<typename T> std::vector<T> vec(const int n)\n    {\n        return generated<T>(n, [&] { return val<T>(); });\n    }\n    template<typename T> std::vector<T> vec(const int n, const T offset)\n    {\n        return generated<T>(n, [&] { return val<T>(offset); });\n    }\n    template<typename T> std::vector<std::vector<T>> vvec(const int n0, const int n1)\n    {\n        return generated<std::vector<T>>(n0, [&] { return vec<T>(n1); });\n    }\n    template<typename T> std::vector<std::vector<T>> vvec(const int n0, const int n1, const T offset)\n    {\n        return generated<std::vector<T>>(n0, [&] { return vec<T>(n1, offset); });\n    }\n    template<typename... Args> auto tup() { return std::tuple<std::decay_t<Args>...>{val<Args>()...}; }\n    template<typename... Args> auto tup(const Args&... offsets) { return std::tuple<std::decay_t<Args>...>{val<Args>(offsets)...}; }\n\nprivate:\n    std::istream& is;\n};\nscanner in;\n#    define SHOW(...) static_cast<void>(0)\n\ntemplate<typename T, int n, int i = 0>\nauto make_v(int const (&szs)[n], const T x = T{})\n{\n    if constexpr (i == n) {\n        return x;\n    } else {\n        return std::vector(szs[i], make_v<T, n, i + 1>(szs, x));\n    }\n}\nint main()\n{\n    std::multiset<ll, std::greater<ll>> Ls;  // Ls[i]=傾きが-iから-(i+1)になる点\n    std::multiset<ll> Rs;                    // Rs[i]=傾きが iから (i+1)になる点\n    const auto N = in.val<int>();\n    ll plen      = 0;\n    ll lshift = 0, rshift = 0;\n    ll height = 0;\n    {\n        const auto [L, R] = in.tup<ll, ll>();\n        plen              = R - L;\n        Ls.insert(L), Rs.insert(L);\n    }\n    SHOW(lshift, rshift, height, Ls, Rs);\n    for (int i = 1; i < N; i++) {\n        const auto [L, R] = in.tup<ll, ll>();\n        const auto len    = R - L;\n        const ll left = *Ls.begin(), right = *Rs.begin();\n        lshift -= len, rshift += plen;\n        if (left + lshift <= L and L <= right + rshift) {  // 平らな部分\n            Ls.insert(L - lshift), Rs.insert(L - rshift);\n        } else if (L < left + lshift) {  // 左側\n            height += std::abs(*Ls.begin() + lshift - L);\n            Rs.insert(*Ls.begin() + lshift - rshift);\n            Ls.erase(Ls.begin());\n            Ls.insert(L - lshift);\n            Ls.insert(L - lshift);\n        } else {  // 右側\n            height += std::abs(*Rs.begin() + rshift - L);\n            Ls.insert(*Rs.begin() + rshift - lshift);\n            Rs.erase(Rs.begin());\n            Rs.insert(L - rshift);\n            Rs.insert(L - rshift);\n        }\n        plen = len;\n        SHOW(lshift, rshift, height, Ls, Rs);\n    }\n    out.ln(height);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#include <set>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\ntypedef long long llint;\nconst llint inf = 1000000000000000000LL;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\nstruct HalfDP {\n  map<llint,llint> dslope;\n  llint shift_x;\n\n  HalfDP() { shift_x = 0; }\n\n  pair<llint,llint> shifted(pair<llint,llint> p) {\n    p.first += shift_x;\n    return p;\n  }\n  pair<llint,llint> first() { return shifted(*dslope.begin()); }\n  pair<llint,llint> last() { return shifted(*--dslope.end()); }\n  \n  void shift(llint x) { shift_x += x; }\n  void add(llint x, llint y) { dslope[x - shift_x] += y; }\n  void pop_first() { dslope.erase(dslope.begin()); }\n  void pop_last() { dslope.erase(--dslope.end()); }\n};\n\nstruct FullDP {\n  HalfDP L, R;\n  llint min_y;\n\n  void init(llint x) {\n    L.dslope[x] = -1;\n    R.dslope[x] = +1;\n    min_y = 0;\n  }\n\n  void apply_min(llint wl, llint wr) {\n    L.shift(-wl);\n    R.shift(+wr);\n  }\n\n  void add_abs(llint x) {\n    llint lx = L.last().first;\n    llint rx = R.first().first;\n\n    if (x > lx && x < rx) {\n      L.add(x, -1);\n      R.add(x, +1);\n    } else if (x > rx) {\n      R.add(rx, -1);\n      R.add(x, +2);\n      L.add(lx, -1);\n      min_y += abs(rx - x);\n    } else {\n      L.add(lx, +1);\n      L.add(x, -2);\n      R.add(rx, +1);\n      min_y += abs(lx - x);\n    }\n\n    if (R.first().second == 0) {\n      L.add(lx, +1);\n      L.add(rx, -1);\n      R.pop_first();\n    }\n\n    if (L.last().second == 0) {\n      R.add(rx, -1);\n      R.add(lx, +1);\n      L.pop_last();\n    }\n  }\n} dp;\n\n\nint main(void) \n{\n  const int MAXN = 1e5 + 5;\n  int N;\n  static llint l[MAXN];\n  static llint r[MAXN];\n  \n  scanf(\"%d\", &N);\n  REP(i, N) scanf(\"%lld%lld\", l+i,r+i);\n\n  dp.init(l[0]);\n  \n  FOR(i, 1, N) {\n    llint wr = r[i - 1] - l[i - 1];\n    llint wl = r[i] - l[i];\n    dp.apply_min(wl, wr);\n    dp.add_abs(l[i]);\n  }\n\n  printf(\"%lld\\n\", dp.min_y);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint main()\n{\n  int N, L[100000], R[100000], P[100000];\n  cin >> N;\n  if(N > 400) throw (0);\n  \n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    P[i] = R[i] - L[i];\n  }\n\n  int64 dp[500][500];\n  fill_n(*dp, 500 * 500, INF);\n  for(int j = 0; j <= 400; j++) dp[0][j] = abs(L[0] - j);\n\n  for(int i = 1; i < N; i++) {\n    for(int j = 0; j <= 400; j++) {\n      int curr_left = j, curr_right = j + P[i]; // [l,r]\n\n      int prev_able_left_minimum = curr_left - P[i - 1];\n      int prev_able_left_maximum = curr_right;\n\n/*\n\n      if(i == 1 && j == 3) {\n        cout << prev_able_left_minimum << \" \" << prev_able_left_maximum << endl;\n      }\n*/\n      for(int k = max(0, prev_able_left_minimum); k <= min(400, prev_able_left_maximum); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(L[i] - j));\n      }\n    }\n  }\n\n  int64 ret = INF;\n  for(int j = 0; j <= 400; j++) ret = min(ret, dp[N - 1][j]);\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nmultiset<int> LS, RS;\nint L[100010], R[100010];\nsigned main(){\n\tint n, fl = 0, fr = 0, ans = 0;\n\tscanf(\"%lld\", &n);\n\tfor(int i = 1;i <= n;i++)scanf(\"%lld%lld\", &L[i], &R[i]);\n\t\n\tLS.insert(-1e17);\n\tRS.insert(1e17);\n\tfor(int i = 1;i <= n;i++){\n\t\tfl -= R[i]-L[i];\n\t\tfr += R[i-1]-L[i-1];\n\t\t\n\t\tif(L[i] < *LS.rbegin()+fl){\n\t\t\tans += *LS.rbegin()+fl-L[i];\n\t\t\tRS.insert(*LS.rbegin()+fl-fr);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tLS.insert(L[i]-fl);\n\t\t}else if(*RS.begin()+fr < L[i]){\n\t\t\tans += L[i]-(*RS.begin()+fr);\n\t\t\tLS.insert(*RS.begin()+fr-fl);\n\t\t\tRS.erase(RS.begin());\n\t\t\tRS.insert(L[i]-fr);\n\t\t\tRS.insert(L[i]-fr);\n\t\t}else{\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tLS.insert(L[i]-fr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mxn=1e5+5;\nll n, m, l[mxn], r[mxn], cl, cr, ans;\npriority_queue<ll>pq_left;\npriority_queue<ll, vector<ll>, greater<ll> >pq_right;\nint main(){\n\tscanf(\"%lld\", &n);\n\tfor(ll i=0; i<n; i++){\n\t\tscanf(\"%lld%ld\", &l[i], &r[i]);\n\t\tif(i==0){\n\t\t\tpq_left.push(l[i]);\n\t\t\tpq_right.push(l[i]);\n\t\t\tcl=cr=0;\n\t\t\tcontinue;\n\t\t}\n\t\tll last=r[i-1]-l[i-1], cur=r[i]-l[i];\n\t\tcl-=cur; cr+=last;\n\t\tll lf=pq_left.top()+cl, rg=pq_right.top()+cr;\n\t\tif(l[i]<lf){\n\t\t\tans+=lf-l[i];\n\t\t\tpq_right.push(lf-cr);\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_left.pop();\n\t\t}else if(l[i]>rg){\n\t\t\tans+=l[i]-rg;\n\t\t\tpq_left.push(rg-cl);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t\tpq_right.pop();\n\t\t}else{\n\t\t\tpq_left.push(l[i]-cl);\n\t\t\tpq_right.push(l[i]-cr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif // LOCAL_\n#define dumpl(x1) fprintf(stderr, \"#%s.%d (%s) = (%ld)\\n\", __func__, __LINE__, #x1, x1);\n#define dumpll(x1, x2) fprintf(stderr, \"#%s.%d (%s, %s) = (%ld, %ld)\\n\", __func__, __LINE__, #x1, #x2, x1, x2);\n#define dumpd(x1) fprintf(stderr, \"#%s.%d (%s) = (%lf)\\n\", __func__, __LINE__, #x1, x1);\n#define dumpdd(x1, x2) fprintf(stderr, \"#%s.%d (%s, %s) = (%lf, %lf)\\n\", __func__, __LINE__, #x1, #x2, x1, x2);\n#define loop for(;;)\n \nstruct S002 {\n  int n;\n  S002& operator > (long& x) {\n    n = x;\n    return *this;\n  }\n  S002& operator > (long&& x) {\n    n = x;\n    return *this;\n  }\n  S002& operator >= (long& x) {\n    if( scanf(\"%ld\", &x) <= 0 ) exit(0);\n    return *this;\n  }\n  S002& operator >= (double& x) {\n    if( scanf(\"%lf\", &x) <= 0 ) exit(0);\n    return *this;\n  }\n  S002& operator >= (std::string& s) {\n    if( not (std::cin >> s) ) exit(0);\n    return *this;\n  }\n  template<typename a>\n  S002& operator >= (std::vector<a>& v) {\n    v.resize(n);\n    for(long i = 0; i < n; ++i) {\n      *this >= v[i];\n    }\n    return *this;\n  }\n  template<typename a, std::size_t s>\n  S002& operator >= (std::array<a, s>& x) {\n    for(long i = 0; i < (long)s; ++i) {\n      *this >= x[i];\n    }\n    return *this;\n  }\n};\n\ntemplate<typename a>\nstruct S003 {\n  std::vector<a> ys;\n  // s == 1 : max, s == -1 : min\n  S003(const std::vector<a>& xs, long k, long s) {\n    long n = xs.size();\n    ys.resize(n);\n    std::deque<a> q;\n    for(long i = 0; i < n + k - 1; ++i) {\n      if( i < n ) {\n        while( not q.empty() and s * xs[q.back()] <= s * xs[i] ) q.pop_back();\n        q.push_back(i);\n      }\n      long w = i - k + 1;\n      if( w >= 0 ) {\n        ys[w] = xs[q.front()];\n        if( q.front() == w ) q.pop_front();\n      }\n    }\n  }\n  typename std::vector<a>::iterator begin() {\n    return ys.begin();\n  }\n  typename std::vector<a>::iterator end() {\n    return ys.end();\n  }\n  size_t size() {\n    return ys.size();\n  }\n  a operator [] (int i) {\n    return ys[i];\n  }\n};\n\nstruct Solver {\n  long n;\n  std::vector<std::array<long,2>> xs;\n  Solver() {\n    S002 reader;\n    reader >= n >n>= xs;\n  }\n  bool partial() {\n    if( not ( n <= 400 ) ) return false;\n    for(std::array<long, 2> x : xs) {\n      if( not ( x[0] <= 400 and x[1] <= 400 ) ) return false;\n    }\n    return true;\n  }\n  void solve() {\n    if( not partial() ) {\n      puts(\"0\");\n      return;\n    }\n    std::vector<long> ys(400+1);\n    std::vector<long> zs(400+1);\n    for(long j = 0; j <= 400; ++j) {\n      ys[j] = std::abs(xs[0][0] - j);\n    }\n    // for(long j = 0; j < 20; ++j) {\n    //   fprintf(stderr, \"%3ld \", ys[j]);\n    // }\n    // fprintf(stderr, \"\\n\");\n    for(long i = 1; i < (long)xs.size(); ++i) {\n      long lenp = xs[i-1][1] - xs[i-1][0];\n      long len  = xs[i][1] - xs[i][0];\n      for(long j = 0; j <= 400; ++j) {\n        long min = (1 << 29);\n        for(long k = std::max((long)0, j - lenp); k <= std::min((long)400, j + len); ++k) {\n          min = std::min(min, zs[k]);\n        }\n        zs[j] = std::abs(xs[i][0] - j) + min;\n        // if( j < 20 ) {\n        //   fprintf(stderr, \"%3ld \", zs[j]);\n        // }\n        // if( j == 19 ) {\n        //   fprintf(stderr, \"\\n\");\n        // }\n      }\n      for(long j = 0; j <= 400; ++j) {\n        ys[j] = zs[j];\n      }\n    }\n    long res = *std::min_element(ys.begin(), ys.end());\n    printf(\"%ld\\n\", res);\n  }\n};\n \nint main() {\n  for(;;) std::unique_ptr<Solver>(new Solver())->solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define ll long long\n#define pii pair<ll, ll>\n#define fst first\n#define snd second\nusing namespace std;\n\nint n;\npii ar[100001]={};\nll lz1, lz2, rs;\npriority_queue<pii> pq1;\npriority_queue<pii> pq2;\n\nint main()\n{\n\tios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {cin >> ar[i].fst >> ar[i].snd;}\n\tpq1.push({ar[0].fst, 0});\n\tpq2.push({-ar[0].fst, 0});\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tlz1 -= ar[i].snd - ar[i].fst;\n\t\tlz2 -= ar[i-1].snd - ar[i-1].fst;\n\t\t//cout<<pq1.top().fst + lz1<<\" \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\tif (ar[i].fst < pq1.top().fst + lz1)\n\t\t{\n\t\t\tpq2.push({-(pq1.top().fst + lz1) - lz2, 0});\n\t\t\tpq1.push({ar[i].fst - lz1, 1});\n\t\t\tll val = pq1.top().fst, ng = 0;\n\t\t\twhile (pq1.size() && pq1.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq1.top().snd;\n\t\t\t\tpq1.pop();\n\t\t\t} \n\t\t\tif (ng) {pq1.push({val, ng});}\n\t\t\trs += abs(-(pq2.top().fst + lz2) - ar[i].fst);\n\t\t}\n\t\telse if (ar[i].fst > -(pq2.top().fst + lz2))\n\t\t{\n\t\t\tpq1.push({-(pq2.top().fst + lz2) - lz1, 0});\n\t\t\tpq2.push({-ar[i].fst - lz2, 1});\n\t\t\t//cout<<\"PQ1 INS \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\t\t//cout<<\"PQ2 INS \"<<ar[i].fst<<\"\\n\";\n\t\t\tll val = pq2.top().fst, ng = 0;\n\t\t\twhile (pq2.size() && pq2.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq2.top().snd;\n\t\t\t\tpq2.pop();\n\t\t\t} \n\t\t\tif (ng) {pq2.push({val, ng - 1});}\n\t\t\t//cout<<pq1.top().fst + lz1<<\" \"<<ar[i].fst<<\"\\n\";\n\t\t\trs += abs(pq1.top().fst + lz1 - ar[i].fst);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq1.push({ar[i].fst - lz1, 0});\n\t\t\tpq2.push({-(ar[i].fst) - lz2, 0});\n\t\t}\n\t}\n\tcout << rs << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n);\n\tVEC_ROW(int, n, l, r);\n\tstd::vector<int> L(n);\n\tREP(i, n) L[i] = r[i] - l[i];\n\n\tint ans = 0;\n\tint dL = 0, dR = 0;\n\tstd::multiset<int> setL({l[0]}), setR({l[0]});\n\tFOR(i, 1, n) {\n\t\tdL -= L[i];\n\t\tdR += L[i - 1];\n\t\tint Lend = *std::prev(setL.end()) + dL;\n\t\tint Rend = *setR.begin() + dR;\n\t\tif (l[i] < Lend) {\n\t\t\tans += Lend - l[i];\n\t\t\tsetL.insert(l[i] - dL);\n\t\t\tsetL.insert(l[i] - dL);\n\t\t\tsetR.insert(Lend - dR);\n\t\t\tsetL.erase(std::prev(setL.end()));\n\t\t}\n\t\telse if (l[i] <= Rend) {\n\t\t\tsetL.insert(l[i] - dL);\n\t\t\tsetR.insert(l[i] - dR);\n\t\t}\n\t\telse {\n\t\t\tans += l[i] - Rend;\n\t\t\tsetR.insert(l[i] - dR);\n\t\t\tsetR.insert(l[i] - dR);\n\t\t\tsetL.insert(Rend - dL);\n\t\t\tsetR.erase(setR.begin());\n\t\t}\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nint lstl, lstL, l, L, n;\nstd::priority_queue<LL> left;\nstd::priority_queue<LL, std::vector<LL>, std::greater<LL>> right;\nLL tagL, tagR, ans;\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> lstl >> lstL, lstL -= lstl;\n\tleft.emplace(lstl), right.emplace(lstl);\n\tfor (int i = 1; i < n; ++i) {\n\t\tstd::cin >> l >> L, L -= l;\n\t\ttagL -= L, tagR += lstL;\n\t\tint ltop = left.top() + tagL, rtop = right.top() + tagR;\n\t\tif (l > ltop) {\n\t\t\tright.emplace(l - tagR), right.emplace(l - tagR);\n\t\t\tint rtop = right.top() + tagR; right.pop();\n\t\t\tans += l - rtop, left.emplace(rtop - tagL);\n\t\t} else {\n\t\t\tleft.emplace(l - tagL), left.emplace(l - tagL);\n\t\t\tint ltop = left.top() + tagL; left.pop(); \n\t\t\tans += ltop - l, right.emplace(ltop - tagR);\n\t\t}\n\t\tlstl = l, lstL = L;\n\t}\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, Left[100009], Right[100009], sz[100009];\nmultiset < long long > L, R;\nlong long leftDeflection, rightDeflection, ans = 0;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &Left[i], &Right[i]), sz[i] = Right[i] - Left[i];\nL.insert (Left[1]), leftDeflection = 0;\nR.insert (Left[1]), rightDeflection = 0;\nfor (int i=2; i<=N; i++)\n{\n    int A = sz[i - 1], B = sz[i];\n    ///f(x) = min (f(x - A), ..., f(x + B)\n    leftDeflection += B, rightDeflection += A;\n    long long x = Left[i], st = (*L.rbegin ()) - leftDeflection, dr = (*R.begin ()) + rightDeflection;\n    if (st <= x && x <= dr)\n    {\n        L.insert (x + leftDeflection);\n        R.insert (x - rightDeflection);\n        continue;\n    }\n    if (x < st)\n    {\n        ans += st - x;\n        auto it = L.end (); it --;\n        L.erase (it);\n\n        L.insert (x + leftDeflection);\n        L.insert (x + leftDeflection);\n        R.insert (st + leftDeflection - rightDeflection);\n        continue;\n    }\n    ans += x - dr;\n    R.erase (R.begin ());\n\n    L.insert (dr - rightDeflection + leftDeflection);\n    R.insert (x - rightDeflection);\n    R.insert (x - rightDeflection);\n}\nprintf (\"%lld\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nint n;\nint l[100010], r[100010];\nll len[100010], lazyn, lazyp;\npriority_queue<ll> neg;\npriority_queue<ll, vector<ll>, greater<ll> > pos;\nll ans = 0;\n\nint main(){\n    scanf(\"%d\", &n);\n\n    scanf(\"%d%d\", &l[0], &r[0]);\n    len[0] = r[0] - l[0];\n    neg.push(l[0]);\n    pos.push(l[0]);\n\n    for(int i = 1; i < n; i++){\n        scanf(\"%d%d\", &l[i], &r[i]);\n        len[i] = r[i] - l[i];\n\n        lazyp += len[i - 1];\n        lazyn -= len[i];\n\n        if(l[i] >= pos.top() + lazyp){\n            pos.push(l[i] - lazyp);\n            pos.push(l[i] - lazyp);\n            ans += l[i] - (pos.top() + lazyp);\n            neg.push(pos.top() + lazyp - lazyn);\n            pos.pop();\n        } else if (l[i] <= neg.top() + lazyn){\n            neg.push(l[i] - lazyn);\n            neg.push(l[i] - lazyn);\n            ans += neg.top() + lazyn - l[i];\n            pos.push(neg.top() + lazyn - lazyp);\n            neg.pop();\n        } else {\n            pos.push(l[i] - lazyp);\n            neg.push(l[i] - lazyn);\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=1050;\n//ここまでテンプレ\nint main(){\n\t//DP[i][j]=i番目の机の左端を座標jに入れたときの最小のコスト\n\tll DP[450][SIZE]={};\n\tint N;\n\tcin>>N;\n\tvll L,R;\n\tfor(int i=0;i<N;i++){\n\t\tll l,r;\n\t\tcin>>l>>r;\n\t\tL.pb(l);\n\t\tR.pb(r);\n\t}\n\tfor(int i=0;i<SIZE;i++){\n\t\tDP[0][i]=abs(i-L[0]);\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<=400;j++){\n\t\t\tll mini=INFLL;\n\t\t\tll PW=R[i-1]-L[i-1];\n\t\t\tll NW=R[i]-L[i];\n\t\t\tfor(int k=max(j-PW,0LL);k<=min(400LL,j+NW);k++)\n\t\t\t\tmini=min(mini,DP[i-1][k]);\n\t\t\tDP[i][j]=abs(j-L[i])+mini;\n\t\t}\n\t}\n\tll ans=INFLL;\n\tfor(int i=0;i<=400;i++)\n\t\tans=min(ans,DP[N-1][i]);\n\tcout<<ans<<endl;\n\t\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<10;j++)\n\t\t\tcout<<DP[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\t/*\n\tfor(int i=0;i<=400;i++)\n\t\tcout<<i<<\" \"<<DP[N-1][i]<<endl;*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<30;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nint n;\nint l[400], r[400], d[400];\nint dp[400][401];\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", l + i, r + i);\n\t\tl[i]--; r[i]--;\n\t\td[i] = r[i] - l[i];\n\t}\n\t\n\tbool ok = true;\n\tif (n > 400) ok = false;\n\tREP(i, n) if (r[i] >= 400) ok = false;\n\tassert(ok);\n\t\n\tfill(dp[0], dp[n], INF);\n\t\n\tREP(i, 400) {\n\t\tif (l[0] <= i && i <= r[0]) dp[0][i] = 0;\n\t\telse dp[0][i] = min(abs(l[0] - i), abs(i - r[0]));\n\t}\n\t\n\tFOR(i, 1, n) {\n\t\tREP(j, 400) {\n\t\t\tfor (int k = max(0, j - d[i - 1]); k <= j + d[i]; k++) {\n\t\t\t\tint cost = abs(j - l[i]);\n\t\t\t\tchmin(dp[i][j], cost + dp[i - 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tREP(i, 400) chmin(ans, dp[n - 1][i]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmultiset<long long, greater<long long>> s1;\nmultiset<long long> s2;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tlong long ans = 0;\n\tint L, R;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tint l, r; cin >> l >> r;\n\t\tif(!i) {\n\t\t\tL = l; R = r;\n\t\t\ts1.insert(l);\n\t\t\ts2.insert(r);\n\t\t} else {\n\t\t\tif(l <= R) {\n\t\t\t\ts1.insert(l);\t\n\t\t\t} else {\n\t\t\t\tans += l - R;\n\t\t\t\tint Rr = R + r - l;\n\t\t\t\tvector<int> v;\n\t\t\t\tfor(auto val : s2) {\n\t\t\t\t\tif(val >= Rr) break;\n\t\t\t\t\tv.push_back(val);\n\t\t\t\t}\n\t\t\t\tfor(auto val : v) s2.erase(val);\n\t\t\t\ts2.insert(r);\n\t\t\t\ts1.insert(R);\n\t\t\t}\n\t\t\tif(r >= L) {\n\t\t\t\ts2.insert(r);\n\t\t\t} else {\n\t\t\t\tans += L - r;\n\t\t\t\tint Ll = L + l - r;\n\t\t\t\tvector<int> v;\n\t\t\t\tfor(auto val : s1) {\n\t\t\t\t\tif(val <= Ll) break;\n\t\t\t\t\tv.push_back(val);\n\t\t\t\t}\n\t\t\t\tfor(auto val : v) s1.erase(val);\n\t\t\t\ts1.insert(l);\n\t\t\t\ts2.insert(L);\n\t\t\t}\n\t\t}\n\t\tL = *s1.begin();\n\t\tR = *s2.begin();\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n/*\n3\n5 6\n3 4\n1 2\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef tree < long long ,  null_type ,  less<long long> ,  rb_tree_tag ,  tree_order_statistics_node_update > ordered_set;\n \n#define mp make_pair\n#define fi first\n#define se second\n \nconst int N = 1e5 + 10;\n\nint l[N], r[N];\nmultiset<long long> sa, sb; \nlong long a, b;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\t\n\tint n;\n\tcin>>n;\n\tint l1 = 0;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tint l2 = r[i] - l[i]; \n\t\tif (i > 1) a -= l2, b += l1;\n\t\tl1 = l2;\n\t\tlong long x, y;\n\t\tif (i > 1) {\n\t\t\tset<long long>::iterator it = sa.end(); it--;\n\t\t\tx = *it + a;\n\t\t\tit = sb.begin();\n\t\t\ty = *it + b;\n\t\t} else x = 0, y = 0;\n\t\tif (x <= l[i] && l[i] <= y) {\n\t\t\tsa.insert(l[i] - a), sb.insert(l[i] - b);\n\t\t} else if (l[i] < x) {\n\t\t\tsa.insert(l[i] - a), sa.insert(l[i] - a);\n\t\t\tset<long long>::iterator it = sa.end(); it--;\n\t\t\tsb.insert(*it + a - b); sa.erase(it);\n\t\t} else if (l[i] > y) {\n\t\t\tsb.insert(l[i] - b), sb.insert(l[i] - b);\n\t\t\tset<long long>::iterator it = sb.begin(); \n\t\t\tsa.insert(*it + b - a); sb.erase(it);\n\t\t}\n\t}\n\tlong long jaw = 0, t = -1e13;\n\tfor(int i=n; i>=1; i--) jaw += l[i] - t, t += r[i] - l[i];\n\tlong long d = -n; \n\tlong long tmp = -1e13;\n\tfor(set<long long>::iterator it = sa.begin(); it != sa.end(); it++)\n\t\tjaw += 1LL * d * (*it + a - tmp), tmp = *it + a, d++;\n\tcout <<jaw<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e6;\nconstexpr static int INF = 1e9;\nconstexpr static int BOUND = 400;\n\nint N;\nint l[MAXN], r[MAXN];\nint cost[500][500];\n\nint main() {\n    cin >> N;\n    // TODO: REMOVE\n    if (N > 400) {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (int i = 0; i < N; i++) {\n        cin >> l[i] >> r[i];\n        // TODO: REMOVE\n        if (r[i] > BOUND) {\n            cout << 0 << endl;\n            return 0;\n        }\n        l[i]--, r[i]--;\n    }\n\n    for (int j = 0; j < BOUND; j++)\n        cost[0][j] = INF;\n    for (int j = 0; j + r[0] - l[0] < BOUND; j++)\n        cost[0][j] = abs(l[0] - j);\n\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < BOUND; j++)\n            cost[i][j] = INF;\n        for (int j = 0; j + r[i] - l[i] < BOUND; j++)\n            for (int k = 0; k < BOUND; k++) {\n                if (k + r[i - 1] - l[i - 1] < j)\n                    continue;\n                if (k > j + r[i] - l[i])\n                    break;\n                cost[i][j] = min(cost[i][j], cost[i - 1][k] + abs(l[i] - j));\n            }\n    }\n\n    int best = INF;\n    for (int j = 0; j < BOUND; j++)\n        best = min(best, cost[N - 1][j]);\n    cout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmultiset<long long, greater<long long>> s1;\nmultiset<long long> s2;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tlong long ans = 0;\n\tint L, R;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tint l, r; cin >> l >> r;\n\t\tif(!i) {\n\t\t\tL = l; R = r;\n\t\t\ts1.insert(l);\n\t\t\ts2.insert(r);\n\t\t} else {\n\t\t\tif(l <= R) {\n\t\t\t\ts1.insert(l);\t\n\t\t\t} else {\n\t\t\t\tans += l - R;\n\t\t\t\tint Rr = R + r - l;\n\t\t\t\tvector<int> v;\n\t\t\t\tfor(auto val : s2) {\n\t\t\t\t\tif(val >= Rr) break;\n\t\t\t\t\tv.push_back(val);\n\t\t\t\t}\n\t\t\t\tfor(auto val : v) s2.erase(val);\n\t\t\t\ts2.insert(r);\n\t\t\t\ts1.insert(R);\n\t\t\t}\n\t\t\tif(r >= L) {\n\t\t\t\ts2.insert(r);\n\t\t\t} else {\n\t\t\t\tans += L - r;\n\t\t\t\tint Ll = L + l - r;\n\t\t\t\tvector<int> v;\n\t\t\t\tfor(auto val : s1) {\n\t\t\t\t\tif(val <= Ll) break;\n\t\t\t\t\tv.push_back(val);\n\t\t\t\t}\n\t\t\t\tfor(auto val : v) s1.erase(val);\n\t\t\t\ts1.insert(l);\n\t\t\t\ts2.insert(L);\n\t\t\t}\n\t\t}\n\t\tL = *s1.begin();\n\t\tR = *s2.begin();\n\t\tfor(auto v : s1) cout << v << \" \"; cout << \"\\n\";\n\t\tfor(auto v : s2) cout << v << \" \"; cout << \"\\n\";\n\t\tcout << ans << ' ' << L << ' ' << R << \"\\n============\\n\";\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n/*\n3\n5 6\n3 4\n1 2\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tint N; cin >> N;\n\tvector<ll> L(N), R(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\n\tll cost = 0;\n\tll los = 0, his = 0;\n\tpriority_queue<ll, vector<ll>, less<ll>> lo;\n\tpriority_queue<ll, vector<ll>, greater<ll>> hi;\n\tlo.push(L[0]), hi.push(L[0]);\n\n\tfor (int i = 1; i < N; i++) {\n\t\tlos -= (R[i] - L[i]);\n\t\this += (R[i-1] - L[i-1]);\n\n\t\tll vlo = lo.top() + los;\n\t\tll vhi = hi.top() + his;\n\t\tif (vlo <= L[i] && L[i] <= vhi) {\n\t\t\tlo.push(L[i] - los);\n\t\t\thi.push(L[i] - his);\n\t\t} else if (vhi < L[i]) {\n\t\t\tcost += L[i] - vhi;\n\t\t\thi.pop();\n\t\t\tlo.push(vhi - los);\n\t\t\thi.push(L[i] - his);\n\t\t\thi.push(L[i] - his);\n\t\t} else if (L[i] < vlo) {\n\t\t\tcost += vlo - L[i];\n\t\t\tlo.pop();\n\t\t\thi.push(vlo - his);\n\t\t\tlo.push(L[i] - los);\n\t\t\tlo.push(L[i] - los);\n\t\t}\n\t}\n\n\tcout << cost << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint main () {\n    int N;\n    cin >> N;\n    vector<int> l(N);\n    vector<int> r(N);\n    int lmin = 1 << 30, rmax = 0;\n    REP (i, 0, N) cin >> l[i] >> r[i];\n    REP (i, 0, N) {\n        lmin = min(lmin, l[i]);\n        rmax = max(rmax, r[i]);\n    }\n\n    if (rmax > 400 || N > 400) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<vector<int>> check(N, vector<int>(rmax + 1, 1 << 30));\n\n    REP (i, 0, rmax + 1) {\n        check[0][i] = abs(r[0] - i);\n    }\n\n    REP (i, 1, N) {\n        REP (j, 0, check[i].size()) {\n            REP (k, 0, check[i - 1].size()) {\n                int nl = j - (r[i] - l[i]), bl = k - (r[i - 1] - l[i - 1]);\n                if (bl >= 0 && nl >= 0 && ((nl <= bl && bl <= j) || (nl <= k && k <= j))) {\n                    check[i][j] = min(check[i][j], check[i - 1][k] + abs(r[i] - j));\n//                    cout << i << ' ' << j << ' ' << k << ' ' << nl << ' ' << bl << ' ' << check[i][j] << endl;\n\n                }\n            }\n        }\n    }\n\n    int ans = 1 << 30;\n    REP (i, 0, check[N - 1].size()) {\n        ans = min(check[N - 1][i], ans);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef TESTING\n  #include \"dump.hpp\"\n#else\n  #define DUMP(...)\n  #define DEBUG(...)\n#endif\n\ntypedef long long LL;\n#define SZ(a) int((a).size())\n#define _REP(_1,_2,_3,_4,name,...) name\n#define _REP4(i,b,e,s) for(decltype(e) _b=(b),_e=(e),i=_b+(0<(s)?0:(s));(0<(s)?i<_e:_e<=i);i+=(s))\n#define _REP3(i,b,e) for(decltype(e) _b=(b),_e=(e),i=(_b<_e?_b:_b-1);(_b<_e?i<_e:_e<=i);(_b<_e?i++:i--))\n#define _REP2(i,n) for(decltype(n) i=0,_n=(n);i<_n;i++)\n#define _REP1(n) for(decltype(n) _i=0,_n=(n);_i<_n;_i++)\n#define REP(...) _REP(__VA_ARGS__,_REP4,_REP3,_REP2,_REP1)(__VA_ARGS__)\n#define FOR(it,c) for(auto&& it=begin(c);it!=end(c);it++)\n#define ROF(it,c) for(auto&& it=rbegin(c);it!=rend(c);it++)\n#define PB push_back\n#define INT(n) int n;scanf(\"%d\",&n)\n#define VI(v,n) vector<int> v(n);REP(i,n){scanf(\"%d\",&v[i]);}\n#define MSET(arr,val)  memset(arr,val,sizeof(arr))\n\nint main(){\n  INT(N); vector<int> Ls, Rs, v;\n  REP(N){INT(L); INT(R); Ls.PB(L); Rs.PB(R); v.PB(L); v.PB(R);}\n  sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());\n  auto cost = [&](int l, int r, int x){\n    if (x < l){return l - x;}\n    else if (r < x){return x - r;}\n    else {return 0;}};\n  auto costs = [&](int idx){\n    LL rtn = 0LL; REP(i, N){rtn += cost(Ls[i], Rs[i], v[idx]);}\n    return rtn;};\n  int il = 0, ir = v.size() - 1;\n  LL ans = min(costs(il), costs(ir));\n  int cnt = 0;\n  while (1 < ir - il && cnt < 1000){\n    int i1 = (2 * il + ir) / 3, i2 = (il + 2 * ir) / 3;\n    LL c1 = costs(i1), c2 = costs(i2);\n    if (c1 < c2){ir = i2;}\n    else {il = i1;}\n    ans = min(ans, min(c1, c2));\n    cnt++;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nlong long h[222222];\nint tot;\nvoid push(long long v)\n{\n\th[++tot]=v;\n\tstd::push_heap(h+1,h+tot+1);\n}\nlong long pop()\n{\n\tstd::pop_heap(h+1,h+tot+1);\n\treturn h[tot--];\n}\nlong long add;\nint main()\n{\n\tunsigned long long s0=0,len;\n\tlong long x;\n\tint n=io::F();\n\t{\n\t\tint l=io::F(),r=io::F();\n\t\tpush(l);\n\t\tpush(l);\n\t\tlen=r-l;\n\t\tx=0,s0=l;\n\t}\n\tfor(register int i=2;i<=n;++i)\n\t{\n\t\tint l=io::F(),r=io::F();\n\t\tlong long tmp=pop()+add;\n\t\ttmp+=len;\n\t\tlen=r-l;\n\t\tadd-=len;\n\t\tx-=len;\n\t\tpush(tmp-add);\n\t\tpush(l-add);\n\t\tpush(l-add);\n\t\ts0+=l-x;\n\t\tpop();\n\t}\n\tstd::sort(h+1,h+tot+1); \n\tfor(register int i=n;i;--i)\n\t{\n\t\tlong long tmp=h[n+1-i]+add;\n\t\ts0-=(tmp-x)*i;\n\t\tx=tmp;\n\t}\n\tprintf(\"%lld\\n\",s0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nconst int max_n = 1e5+10;\n\nint n;\nll l[max_n];\nll r[max_n];\n\nvoid in(){\n    read(n);\n    for(int i=1; i<=n; ++i){\n        read(l[i], r[i]);\n    }\n}\n\nstruct res {\n    vector<ll> v;\n    ll iv;\n};\n\nll len(int x){ return r[x]-l[x]; }\n\nres solve(int l, int r){\n    if(l == r){\n        ll x=::l[l];\n        res ret;\n        ret.v = {x, x};\n        ret.iv = 0LL;\n        return ret;\n    }\n    int mid=(l+r)/2;\n    res L=solve(l, mid), R=solve(mid+1, r);\n    ll l1=len(mid), l0=len(mid+1);\n    res ret;\n    {\n        auto& v=L.v;\n        int n=int(v.size())/2;\n        for(int i=0; i<n; ++i) ret.v.pb(v[i]-l0);\n        for(int i=0; i<n; ++i) ret.v.pb(v[i+n]+l1);\n    }\n    for(ll x:R.v) ret.v.pb(x);\n    sort(all(ret.v));\n    ll lx=L.v[0]-l0, rx=R.v[0];\n    ll tx=min(lx, rx);\n    ret.iv = L.iv + R.iv + int(L.v.size())/2LL*(lx-tx) + int(R.v.size())/2LL*(rx-tx);\n    return ret;\n}\n\nint main()\n{\n\tin();\n\tauto inc = solve(1, n);\n\tauto& v=inc.v;\n\tll cv=inc.iv;\n\tll grad=-n;\n\tfor(int i=1; i<n; ++i){\n        ++grad;\n        cv += grad*(v[i]-v[i-1]);\n\t}\n\tprintf(\"%lld\\n\", cv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\nmultiset<ll> L, R;\nll C, lp, rp;\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    L.insert(-S[0].first);\n    R.insert(S[0].first);\n    C = lp = rp = 0;\n    for(int i = 1; i < N; i++) {\n        int plen = S[i - 1].second - S[i - 1].first;\n        int clen = S[i].second - S[i].first;\n        ll x = S[i].first;\n/*\n        set<int>::iterator it;\n        cout << \"L : \";\n        for(it = L.begin(); it != L.end(); it++) {\n            cout << -lp - *it << ' ';\n        }\n        cout << endl;\n        cout << \"R : \";\n        for(it = R.begin(); it != R.end(); it++) {\n            cout << rp + *it << ' ';\n        }\n        cout << endl;\n//*/\n        lp += clen;\n        rp += plen;\n\n        if(-lp - *L.begin() <= x && x <= rp + *R.begin()) {\n            L.insert(-lp - x);\n            R.insert(-rp + x);\n        }\n        else if(x < -lp - *L.begin()) {\n            ll tx = -lp - *L.begin();\n            L.erase(L.begin());\n            L.insert(-lp - x);\n            ll ttx = -lp - *L.begin();\n\n            R.insert(-rp + tx);\n            C += tx - ttx;\n        }\n        else if(rp + *R.begin() < x) {\n            ll tx = rp + *R.begin();\n            R.erase(R.begin());\n            R.insert(-rp + x);\n            ll ttx = rp + *R.begin();\n\n            L.insert(-lp - tx);\n            C += ttx - tx;\n        }\n    }\n    printf(\"%lld\", C);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\n\n\nint n;\nint a[MAXN],b[MAXN];\n\n\n\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) scanf(\"%d%d\",&a[i],&b[i]);\n\n\tmap<ll,int> L,R; ll dl=a[0],dr=a[0]; L[0]=+1; R[0]=+1; ll ret=0;\n\tFOR(i,1,n) {\n\t\tdl-=b[i]-a[i]; dr+=b[i-1]-a[i-1];\n\t\tll lmx; { map<ll,int>::iterator it=L.end(); assert(it!=L.begin()); --it; lmx=dl+it->first; }\n\t\tll rmn; { map<ll,int>::iterator it=R.begin(); assert(it!=R.end()); rmn=dr+it->first; }\n\t\tif(a[i]<lmx) {\n\t\t\tret+=lmx-a[i];\n\t\t\tL[a[i]-dl]+=2;\n\t\t\tmap<ll,int>::iterator it=L.end(); assert(it!=L.begin()); --it; assert(lmx==dl+it->first);\n\t\t\t--it->second; if(it->second==0) L.erase(it);\n\t\t\tR[lmx-dr]++;\n\t\t} else if(a[i]>rmn) {\n\t\t\tret+=a[i]-rmn;\n\t\t\tR[a[i]-dr]+=2;\n\t\t\tmap<ll,int>::iterator it=R.begin(); assert(it!=R.end()); rmn=dr+it->first; assert(rmn==dr+it->first);\n\t\t\t--it->second; if(it->second==0) R.erase(it);\n\t\t\tL[rmn-dl]++;\n\t\t} else {\n\t\t\tL[a[i]-dl]++;\n\t\t\tR[a[i]-dr]++;\n\t\t}\n\t\t//printf(\"ret=%lld\\n\",ret);\n\t\t//printf(\"L:\"); for(map<ll,int>::iterator it=L.begin();it!=L.end();++it) printf(\" %lld:%d\",dl+it->first,it->second); puts(\"\");\n\t\t//printf(\"R:\"); for(map<ll,int>::iterator it=R.begin();it!=R.end();++it) printf(\" %lld:%d\",dr+it->first,it->second); puts(\"\");\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n#define int2(x, y) int x, y; scanf(\"%lld %lld\", &x, &y);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n \nsigned main()\n{\n    int n;\n    cin >> n;\n    vi r(n), l(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i];\n    }\n\n    int mi = INF;\n\n    rep(i, 401) {\n        int sum = 0;\n        rep(j, n) {\n            if (l[j] > i) {\n                sum += l[j] - i;\n            } else if (r[j] < i) {\n                sum += i - r[j];\n            }\n        }\n        mi = min(mi, sum);\n    }\n    cout << mi << endl;\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, l[100005], r[100005];\nlong long ans=LONG_LONG_MAX, dp[500][500];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for(int i=1; i<=n; i++) {\n        cin >> l[i] >> r[i];\n    }\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=400; j++)\n            dp[i][j] = LONG_LONG_MAX;\n\n    for(int i=1; i<=400; i++) dp[1][i] = abs(l[1]-i);\n    for(int i=2; i<=n; i++) {\n        for(int j=1; j<=400; j++) {\n            for(int k=max(1, j-(r[i-1]-l[i-1])); k<=(min(400, j+l[i]+r[i])); k++) {\n                dp[i][j] = min(dp[i][j], dp[i-1][k]+abs(l[i]-j));\n            }\n            //cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n        }\n    }\n    for(int i=1; i<=400; i++) ans = min(ans, dp[n][i]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 403\nint n;\nvector<P> p;\nint dp[N][N];\n\n#define R_MAX 400\n\nint main() {\n  cin >> n;\n  rep(i, n) {\n    int l, r;\n    cin >> l >> r;\n    p.push_back(P(l, r));\n  }\n  sort(ALL(p));\n  rep(i, n) {\n    rep(j, R_MAX+1) dp[i][j] = INF;\n  }\n  // 0\n  repl(i, 0, p[0].first) {\n    dp[0][i] = INF;\n  }\n  repl(i, p[0].first, p[0].second) {\n    dp[0][i] = 0;\n  }\n  repl(i, p[0].second+1, R_MAX) {\n    dp[0][p[0].second] = i - p[0].second;\n  }\n\n  repl(i, 1, n-1) {\n    int l = p[i].second - p[i].first;\n    // hidari\n    repl(j, 0, p[i].first-1) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j] + (p[i].first - j));\n      }\n    }\n    // sonomama\n    repl(j, p[i].first, p[i].second) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j]);\n      }\n    }\n    // migi\n    repl(j, p[i].second+1, R_MAX) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j] + (j - p[i].second));\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i, R_MAX+1) {\n    ans = mind(ans, dp[n-1][i]);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\ntypedef long long int ll;\nll n, ans;\nll l[111111], r[111111], d[111111];\npriority_queue<ll> L, R;\nll L_add, R_add;\n\nint main(void)\n{\n\tfio; int i, j; cin>>n;\n\tfor(i=1 ; i<=n ; i++) cin>>l[i]>>r[i];\n\tfor(i=1 ; i<=n ; i++) d[i]=r[i]-l[i];\n\tans=0; L.push(l[n]); R.push(-l[n]);\n\tfor(i=n-1 ; i>=1 ; i--)\n\t{\n\t\tL_add+=d[i]; R_add+=d[i+1];\n\t\tll U=L.top(); // in reality, U-L_add\n\t\tll V=-R.top(); // in reality, V+R_add\n\t\tif(U>=l[i]+L_add)\n\t\t{\n\t\t\tL.pop(); R.push(-(U-L_add-R_add));\n\t\t\tL.push(l[i]+L_add); L.push(l[i]+L_add);\n\t\t\tll VV=L.top();\n\t\t\tans+=abs(U-VV); ans+=abs(VV-L_add-l[i]);\n\t\t}\n\t\telse if(V+R_add<=l[i])\n\t\t{\n\t\t\tR.pop(); L.push(V+R_add+L_add);\n\t\t\tR.push(-(l[i]-R_add)); R.push(-(l[i]-R_add)); \n\t\t\tll VV=-R.top();\n\t\t\tans+=abs(V-VV); ans+=abs(VV+R_add-l[i]);\n\t\t}\n\t\telse if(U-L_add<=l[i] && l[i]<=V+R_add)\n\t\t\tL.push(L_add+l[i]), R.push(-(l[i]-R_add));\n\t}\n\tcout<<ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N;\nvector<pair<LL, LL>>rect;//first:left second:width\n\nint main(void)\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tLL l, r;\n\t\tcin >> l >> r;\n\t\trect.push_back({ l,r - l });\n\t}\n\tLL lefd = 0, rhtd = 0;\n\tmultiset<LL>lef, rht;\n\tLL baseval = 0;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\t//minrangeする(i==0の時は無視)\n\t\tif (i > 0)\n\t\t{\n\t\t\tLL x = rect[i - 1].second;\n\t\t\tLL y = rect[i].second;\n\t\t\tlefd += y;\n\t\t\trhtd += x;\n\t\t}\n\t\t//absをとる\n\t\tif (i == 0)\n\t\t{\n\t\t\tlef.insert(rect[i].first);\n\t\t\trht.insert(rect[i].first);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//basevalを更新\n\t\t\tauto itr = lef.end();\n\t\t\titr--;\n\t\t\tLL zlef = (*itr) - lefd;\n\t\t\tLL zrht = (*rht.begin()) + rhtd;\n\t\t\tif (zrht < rect[i].first)\n\t\t\t{\n\t\t\t\tbaseval += rect[i].first - zrht;\n\t\t\t}\n\t\t\telse if (rect[i].first < zlef)\n\t\t\t{\n\t\t\t\tbaseval += zlef - rect[i].first;\n\t\t\t}\n\t\t\t//setに導入する\n\t\t\tLL lim = (*rht.begin()) + rhtd;\n\t\t\tif (lim <= rect[i].first)\n\t\t\t{\n\t\t\t\trht.insert(rect[i].first - rhtd);\n\t\t\t\trht.insert(rect[i].first - rhtd);\n\t\t\t\tauto edge = rht.begin();\n\t\t\t\tLL val = (*edge) + rhtd;\n\t\t\t\trht.erase(edge);\n\t\t\t\tlef.insert(val + lefd);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlef.insert(rect[i].first + lefd);\n\t\t\t\tlef.insert(rect[i].first + lefd);\n\t\t\t\tauto edge = lef.end();\n\t\t\t\t--edge;\n\t\t\t\tLL val = (*edge) - lefd;\n\t\t\t\tlef.erase(edge);\n\t\t\t\trht.insert(val - rhtd);\n\t\t\t}\n\t\t}\n\t\tassert(lef.size() == rht.size());\n\t}\n\tcout << baseval << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint l[405],r[405];\nint d[405][405];\n\nint go(int now,int leftx){\n    if(now == n+1) return 0;\n    \n    int &ans = d[now][leftx];\n    if(ans!=-1) return ans;\n    int rightend = leftx + r[now-1]-l[now-1];\n    ans = 987654321;\n    for(int k=1;k<=400;k++){\n        int rnew = k + r[now] - l[now];\n        if(rnew < leftx || rightend < k) continue;\n        ans = min(ans,go(now+1,k) + abs(k-l[now]));\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    if(n>=401) return 0;\n    \n    for(int i=1;i<=n;i++){\n        scanf(\"%d %d\",&l[i],&r[i]);\n    }\n    memset(d,-1,sizeof(d));\n    int res = 987654321;\n    for(int i=1;i<=400;i++){\n        res = min(res,go(1,i));\n    }\n    printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tll l, r, len;\n\tll pbl = 0, pbr = 0, ans = 0, L, R;\n\tpriority_queue<ll> ql;\n\tpriority_queue<ll, vector<ll>, greater<ll>> qr;\n\t\n\twhile (n--) {\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\n\t\tql.push(r - pbl);\n\t\tqr.push(r - pbr);\n\n\t\twhile ((L = ql.top() + pbl) > (R = pbr + qr.top())) {\n\t\t\tans += L - R;\n\n\t\t\tql.pop();\n\t\t\tqr.pop();\n\n\t\t\tql.push(R - pbl);\n\t\t\tqr.push(L - pbr);\n\t\t}\n\n\t\tpbl -= len;\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    vector<i64> l(N),r(N);\n    rep(i,0,N) cin >> l[i] >> r[i];\n\n    i64 bottom=0,left_uniform=2*l[0],right_uniform=0;\n    multiset<i64> left_diverse={l[0]},right_diverse={l[0]};\n    rep(i,1,N){\n        left_uniform-=r[i]-l[i];\n        right_uniform+=r[i-1]-l[i-1];\n\n        if(left_uniform-*left_diverse.begin()<=l[i] and l[i]<=right_uniform+*right_diverse.begin()){\n            left_diverse.insert(-l[i]+left_uniform);\n            right_diverse.insert(l[i]-right_uniform);\n        }else if(l[i]<left_uniform-*left_diverse.begin()){\n            bottom+=(left_uniform-*left_diverse.begin())-l[i];\n\n            left_diverse.insert(-l[i]+left_uniform);\n            left_diverse.insert(-l[i]+left_uniform);\n            right_diverse.insert(left_uniform-*left_diverse.begin()-right_uniform);\n            left_diverse.erase(left_diverse.begin());\n        }else{\n            bottom+=l[i]-(right_uniform+*right_diverse.begin());\n\n            right_diverse.insert(l[i]-right_uniform);\n            right_diverse.insert(l[i]-right_uniform);\n            left_diverse.insert(-(right_uniform+*right_diverse.begin())+left_uniform);\n            right_diverse.erase(right_diverse.begin());\n        }\n    }\n\n    cout << bottom << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment (linker, \"/stack:256000000\")\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\n#define fo(a,b,c) for(int a=(b);a<(c);a++)\n#define fd(a,b,c) for(int a=(b);a>=(c);a--)\n#define fi(a) fo(i,0,(a))\n#define fj(a) fo(j,0,(a))\n#define fk(a) fo(k,0,(a))\n#define _(a,b) memset((a),(b),sizeof(a))\n#define __(a) memset((a),0,sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#ifdef _DEBUG\n#define dbg(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#define dbgx(x) {cerr << #x << \" = \" << (x) << endl;}\n#else\n#define dbg(...) {}\n#define dbgx(x) {}\n#endif\n\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nconst int INF = 1000000000;\nconst lint LINF = 4000000000000000000LL;\nconst double eps = 1e-9;\n\nvoid prepare()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n}\n\nconst int maxn = 100100;\n\nint n;\npii p[maxn], pp[maxn];\nint dp[2][500];\n\nvoid read()\n{\n\tscanf(\"%d\", &n);\n\tfi(n)\n\t\tscanf(\"%d%d\", &p[i].first, &p[i].second);\n}\n\nbool inside(int x, int l, int r)\n{\n\treturn x >= l && x <= r;\n}\n\nint getMove(pii p1, pii p2)\n{\n\tif (inside(p2.first, p1.first, p1.second) ||\n\t\tinside(p2.second, p1.first, p1.second) ||\n\t\tinside(p1.first, p2.first, p2.second) ||\n\t\tinside(p1.second, p2.first, p2.second))\n\t\treturn 0;\n\tif (p2.first > p1.second)\n\t\treturn p1.second - p2.first;\n\tif (p2.second < p1.first)\n\t\treturn p1.first - p2.second;\n\tassert(false);\n}\n\nbool solve()\n{\n\tint cr = 0, nx = 1, plen = 400;\n\tfi(n)\n\t{\n\t\t_(dp[nx], 63);\n\t\tint len = (p[i].second - p[i].first);\n\t\tfo(j, 1, 401 - len)\n\t\t{\n\t\t\tint cur = INF;\n\t\t\tfo(k, max(1, j - plen), j + len + 1)\n\t\t\t\tcur = min(cur, dp[cr][k]);\n\t\t\tdp[nx][j] = cur + abs(p[i].first - j);\n\t\t}\n\t\tswap(cr, nx);\n\t}\n\tint res = INF;\n\tfi(401) if (i)\n\t\tres = min(res, dp[cr][i]);\n\tprintf(\"%d\\n\", res);\n\treturn false;\n}\n\nint main()\n{\n\tprepare();\n\tread();\n\twhile (solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing namespace std::chrono;\n\nconst int LIM = 401;\nconst int INF = 1e+9;\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  assert(n <= 400);\n  vector<int> ans(LIM, 0), buf(LIM, INF);\n\n  for (int i = 0; i < n; ++i) {\n    int l, r;\n    cin >> l >> r;\n    assert(l <= 400 && r <= 400);\n\n    buf.assign(LIM, INF);\n    for (int pl = 0, pr = r - l; pr < LIM; ++pl, ++pr) {\n      int cost = abs(l - pl);\n      int _min = ans[pl];\n      for (int p = pl; p <= pr; ++p)\n        _min = min(_min, ans[p]);\n      cost += _min;\n\n      for (int p = pl; p <= pr; ++p)\n        buf[p] = min(buf[p], cost);\n    }\n\n    swap(buf, ans);\n  }\n\n  int res = ans[0];\n  for (int i = 0; i < LIM; ++i)\n    res = min(res, ans[i]);\n  cout << res << endl;\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = (int)1e5 + 10;\nint n, l[MAXN], r[MAXN];\nint len[MAXN];\n\nvoid erase(multiset<LL> &s, LL val) {\n    if (s.find(val) != s.end()) {\n        s.erase(s.equal_range(val).first);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        len[i] = r[i] - l[i];\n    }\n\n    multiset<LL> sl, sr;\n    LL dl = 0, dr = 0;\n    LL f_opt = 0;\n\n    sl.insert(l[1]);\n    sr.insert(l[1]);\n    for (int i = 2; i <= n; ++i) {\n        dl -= len[i];\n        dr += len[i - 1];\n\n        if (l[i] <= *sl.rbegin() + dl) {\n            sl.insert(l[i] - dl);\n            sl.insert(l[i] - dl);\n            sr.insert(*sl.rbegin() + dl - dr);\n            erase(sl, *sl.rbegin());\n            f_opt += abs(*sr.begin() + dr - l[i]);\n        } else if (l[i] >= *sr.begin() + dr) {\n            sr.insert(l[i] - dr);\n            sr.insert(l[i] - dr);\n            sl.insert(*sr.begin() + dr - dl);\n            erase(sr, *sr.begin());\n            f_opt += abs(*sl.rbegin() + dl - l[i]);\n        } else {\n            sl.insert(l[i] - dl);\n            sr.insert(l[i] - dr);\n        }\n    }\n\n    printf(\"%lld\\n\", f_opt);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nconst long long INF=1e18+7;\n\nstruct ShiftMultiset{\n  std::multiset<long long> set;\n  long long delta;\n  //x in set represents x+delta\n  void insert(long long x){\n    set.insert(x-delta);\n  }\n  void shift(long long x){\n    delta+=x;\n  }\n  long long front(){\n    assert(set.size());\n    return *set.begin()+delta;\n  }\n  long long back(){\n    assert(set.size());\n    return *set.rbegin()+delta;\n  }\n  long long pop_front(){\n    assert(set.size());\n    long long x=*set.begin();\n    set.erase(set.begin());\n    return x;\n  }\n  long long pop_back(){\n    assert(set.size());\n    long long x=*set.rbegin();\n    set.erase(set.find(*set.rbegin()));\n    return x;\n  }\n}left,right;\n\nint ls[100005];\nint rs[100005];\n\nint main(){\n  int N;\n  scanf(\"%d\",&N);\n  for(int i=1;i<=N;i++){\n    scanf(\"%d %d\",&ls[i],&rs[i]);\n  }\n  long long cost=0;//cost at min\n  left.insert(0);\n  right.insert(INF);\n  for(int i=1;i<=N;i++){\n    left.shift(-(rs[i]-ls[i]));\n    right.shift((rs[i-1]-ls[i-1]));\n    if(ls[i]<left.back()){\n      cost+=std::abs(left.back()-ls[i]);\n      left.insert(ls[i]);\n      left.insert(ls[i]);\n      right.insert(left.pop_back());\n    }else if(ls[i]>right.front()){\n      cost+=std::abs(right.front()-ls[i]);\n      right.insert(ls[i]);\n      right.insert(ls[i]);\n      left.insert(right.pop_front());\n    }else{\n      left.insert(ls[i]);\n      right.insert(ls[i]);\n    }\n  }\n  printf(\"%lld\\n\",cost);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 50\nint dp[MAX][MAX];\nsigned main(){\n  int n;\n  cin>>n;\n  if(n>400) assert(0);\n  int l[n+1],r[n+1];\n  for(int i=1;i<=n;i++) cin>>l[i]>>r[i];\n  for(int i=1;i<=n;i++) if(l[i]>400||r[i]>400) assert(0);\n  l[0]=0;r[0]=MAX;\n  int inf=1LL<<55LL;\n  fill_n(dp[0],MAX,0);\n  for(int i=1;i<=n;i++){\n    fill_n(dp[i],MAX,inf);\n    for(int j=0;j<MAX;j++){\n      for(int k=0;k<MAX;k++){\n\tif(j+(r[i]-l[i])<k||k+(r[i-1]-l[i-1])<j) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<k<<\":\"<<dp[i-1][k]<<\" \"<<abs(l[i]-j)<<endl;\n\tdp[i][j]=min(dp[i][j],dp[i-1][k]+abs(l[i]-j));\n      }\n      //cout<<i<<\" \"<<j<<\":\"<<dp[i][j]<<endl;\n    }\n  }\n  int ans=inf;\n  for(int i=0;i<MAX;i++) ans=min(ans,dp[n][i]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nmultiset<ll> sl,sr;\nll ans,tl,tr,i,j,k,n,a[200001],b[200001];\nll av(ll x){\n\treturn (x>=0)?x:-x;\n}\nint main(){\n\tfreopen(\"a.in\",\"r\",stdin);freopen(\"a.out\",\"w\",stdout);\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i],&b[i]);\n\tsl.clear();sr.clear();sl.insert(a[1]);sr.insert(a[1]);\n\tfor (i=2,ans=tl=tr=0;i<=n;i++){\n\t\ttl+=b[i]-a[i];tr+=b[i-1]-a[i-1];j=*(sl.rbegin());k=*(sr.begin());\n\t\tif (j-tl>a[i]){\n\t\t\tans+=av(j-tl-a[i]);\n\t\t\tsl.erase(sl.find(j));sl.insert(a[i]+tl);sl.insert(a[i]+tl);sr.insert(j-tl-tr);\n\t\t}else if (a[i]>k+tr){\n\t\t\tans+=av(k+tr-a[i]);\n\t\t\tsr.erase(sr.find(k));sr.insert(a[i]-tr);sr.insert(a[i]-tr);sl.insert(k+tr+tl);\n\t\t}else{\n\t\t\tsl.insert(a[i]+tl);sr.insert(a[i]-tr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 855, mod = (int) 0;\nint dp[N + N], odp[N + N];\nint main() {\n\tint n;\n\tcin >> n;\n\tint lastl = -805, lastr = 805;\n\tfor (int j = 0; j < n; ++j) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tmemcpy(odp, dp, sizeof dp);\n\t\tmemset(dp, 63, sizeof dp);\n\t\tfor (int pos = 0; pos < N; ++pos)\n\t\t\tfor (int cur_pos = -405; cur_pos < 405; ++cur_pos) {\n\t\t\t\tint xl = l + cur_pos, xr = r + cur_pos;\n\t\t\t\tint yl = pos, yr = pos + lastr - lastl;\n\t\t\t\tif (xl >= 0 && xl < N && max(xl, yl) < min(xr, yr))\n\t\t\t\t\tdp[xl] = min(dp[xl], odp[pos] + abs(cur_pos));\n\t\t\t}\n\t\tlastl = l;\n\t\tlastr = r;\n\t}\n\tint mn = 1e9;\n\tfor (int j = 0; j < N + N; ++j)\n\t\tmn = min(mn, dp[j]);\n\tcout << mn << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1000000007;\nconst llint big=(llint)(2.19e16)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\tint n;cin>>n;\n\tllint ans=0;\n\t//「中心」を考えるためにいろいろします\n\tllint sl,sr;cin>>sl>>sr;\n\tllint schu=sl+sr;\n\tllint maes=sr-sl;\n\tmultiset<llint> hd;\n\tmultiset<llint> mg;\n\tllint hos=0;\n\thd.ins(schu);mg.ins(schu);\n\tfor(int i=1;i<n;i++){\n\t\tllint l,r;cin>>l>>r;\n\t\tllint chu=l+r;\n\t\tllint han=maes+r-l;\n\t\tmaes=r-l;\n\t\tif((*mg.begin()+hos)<chu-han){\n\t\t\tans+=chu-han-(*mg.begin()+hos);\n\t\t\tllint it=(*mg.begin())+hos;\n\t\t\tmg.era(mg.begin());\n\t\t\thd.ins(it+hos);\n\t\t\thos+=han;\n\t\t\tmg.ins(chu-hos);\n\t\t\tmg.ins(chu-hos);\n\t\t}else if((*hd.rbegin()-hos)>chu+han){\n\t\t\tans+=(*hd.rbegin()-hos)-chu-han;\n\t\t\tllint it=(*hd.rbegin())-hos;\n\t\t\thd.era(prev(hd.end()));\n\t\t\tmg.ins(it-hos);\n\t\t\thos+=han;\n\t\t\thd.ins(chu+hos);\n\t\t\thd.ins(chu+hos);\n\t\t}else{\n\t\t\thos+=han;\n\t\t\thd.ins(chu+hos);\n\t\t\tmg.ins(chu-hos);\n\t\t}\n\t\t\n\t\t\n\t}\n\tcout<<ans/2<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<string,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n\n                            //----------------kokomade tenpure------------\nint N=262144;\npa sgt[530000];\n\npa minis(int i,int j ){\nif(i==j) return sgt[i];\n\telse if(i%2==1){\n\t\tpa z=minis(i+1,j);\n\t\tif(sgt[i].first>z.first)return sgt[i] ;\n\t\telse return z;\n\t}\n\t\telse if(j%2==0) \t{\n\t\tpa z=minis(i,j-1);\n\t\tif(sgt[j].first>z.first)return sgt[j] ;\n\t\telse return z;\n\t}\nelse return minis(i/2,j/2);\n}\n\npa sgtmin(int i ,int j) {\n\treturn minis(i+N,j+N);\n}\n\nvoid upd(int x,int y){\n\tx+=N;\nsgt[x].first=y;\n\tsgt[x].second=x;\nx=x/2;\nwhile(x != 0){\n\tif(sgt[2*x+1].first>sgt[2*x].first){\n\t\tsgt[x]=sgt[2*x+1];\n\t}\n\telse sgt[x]=sgt[2*x];\n\nx=x/2;\n}\n}\n\nvector<int> G[100002];\n \n\nvector<int> ki;\nvector<int> ni;\nvector<int> koritu;\nint n,m;\nint sumi[100002]={0};\nint guuki[100002]={0};\nint kich,saizu;\n\n\nvoid dfs(int r,int kyo){\n//\tcout<<r<<endl;\n\tint y=G[r].size();\n\tif(y==0){\n\t\tsaizu=1;\n\t\tsumi[r]=1;\n\t\treturn;\n\t}\n\tguuki[r]=kyo;\n\tsaizu++;\n\tsumi[r]=1;\n\tfor(int i=0;i<y;i++){\n\t\tif(sumi[G[r][i]]==1){\n\t\t\tif((kyo+1)%2  != guuki[G[r][i]] %2) kich=1;\n\t\t}\n\t\telse{\n//\t\t\tcout<<\"dfs \"<<G[r][i]<<endl;\n\t\t\tdfs(G[r][i],kyo+1);\n\t}\n\t}\n\treturn;\n}\nint dp[410][410];\nint a[410];\n\n\nint abss(int u){\n\tif(u<0) return -u;\n\t\n\treturn u;\n}\n signed  main(){\nint n;\n \tcin>>n;\n \t\n \tif(n>400) return 0;\n \tfor(int i=0;i<410;i++)for(int j=0;j<410;j++) dp[i][j]=inf;\n \t\n \tint l,r;\n \tcin>>l>>r;\n \ta[0]=r-l;\n \tfor(int i=0;i<=400;i++){\n \t\tdp[0][i]=abss(i-l);\n \t}\n \t\n \t\n \tfor(int i=1;i<n;i++){\n //\t\tint l,r;\n \t\tcin>>l>>r;\n \t\ta[i]=r-l;\n \t\t\n \t\tfor(int j=0;j<=400;j++){\n \t\t\tint y=inf;\n \t\t\tfor(int k=max(0ll,j-a[i-1]);k<=min(400ll,j+a[i]);k++){\n \t\t\t\ty=min(dp[i-1][k]+abss(j-l),y);\n \t\t\t}\n \t\t\tdp[i][j]=y;\n \t\t}\n \t}\n \t\n \tint ans=inf;\n \tfor(int i=0;i<=400;i++) ans=min(ans,dp[n-1][i]);\n \t\n \tcout<<ans<<endl;\n \t\n //\tcout<<i<<endl;\n \t//  \tprintf(\"%.10f\\n\",ans[n-1]);\n                    \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 dp[401][401];\ni64 l[401], r[401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n\n    if (!(n < 401 && maxr < 401)) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(0, 400, j) {\n            if (l[i] < j && j <= r[i]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = j < l[i] ? l[i]-j : j-r[i]+1;\n            }\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(0, 400, j) {\n        i64 d = 0;\n        upto(1, n, i) {\n            d = max(d, dp[i][j]);\n        }\n        ans = min(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef pair<int, int> ii;\ntypedef long long ll;\n\npriority_queue< ll > lower, higher;\nll loz, hiz;\n\nll opt;\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint xp = 0, yp = 0;\n\tfor(int i = 1; i<= n; i++)\n\t{\n\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\tloz -= y-x;\n\t\thiz += yp-xp;\n\t\txp = x; yp = y;\n\t\tif(!lower.empty() && x<= lower.top()+loz)\n\t\t{\n\t\t\tll k = lower.top()+loz;\n\t\t\tlower.pop();\n\t\t\topt += abs(x-k);\n\t\t\thigher.push(-(k-hiz));\n\t\t\tlower.push(x-loz);\n\t\t\tlower.push(x-loz);\n\t\t}\n\t\telse if(!higher.empty() && x>= -higher.top()+hiz)\n\t\t{\n\t\t\tll k = -higher.top()+hiz;\n\t\t\thigher.pop();\n\t\t\topt += abs(x-k);\n\t\t\tlower.push(k-loz);\n\t\t\thigher.push(-(x-hiz));\n\t\t\thigher.push(-(x-hiz));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlower.push(x-loz);\n\t\t\thigher.push(-(x-hiz));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", opt);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<pair<int, int>> vp(n);\n\tfor (auto &x: vp) cin >> x.first >> x.second;\n\n\tvector<vector<int>> store(n, vector<int>(401, 0));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tint tmp;\n\t\t\tif (j >= vp[i].first && j <= vp[i].second) tmp = 0;\n\t\t\telse tmp = min(abs(j - vp[i].first), abs(j - vp[i].second));\n\t\t\tstore[i][j] = tmp + (i ? store[i - 1][j] : 0);\n\t\t}\n\t}\n\n \tcout << *min_element(store[n - 1].begin(), store[n - 1].end()) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nint li[405];\nint ri[405];\nint ci[405];\nint f[405][405];\n\ninline int chk(int xa,int ya,int xb,int yb) {\n    if(ya<xb || yb<xa) return 0;return 1;\n}\n\ninline int iabs(int x) {return x>=0?x:-x;}\n\ninline void chkmin(int& x,int v) {x=min(x,v);}\n\nint main() {\n    int n;\n    read(n);\n    REP(i,1,n) read(li[i]),read(ri[i]),ci[i]=ri[i]-li[i];\n    li[0]=1;ri[0]=400;ci[0]=ri[0]-li[0];\n    memset(f,0x3f,sizeof(f));f[0][1]=0;\n    REP(i,1,n) {\n        REP(j,1,400) {\n            REP(k,1,400) if(chk(j,j+ci[i],k,k+ci[i-1])) {\n                chkmin(f[i][j],f[i-1][k]+iabs(li[i]-j));\n            }\n        }\n    }\n    int res=(int)(1e9)+100;\n    REP(i,1,400) res=min(res,f[n][i]);\n    printf(\"%d\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Macro Tools /////////////////////////////////////////////////////////////////\n#define GET_MACRO_09(A0, A1, A2, A3, A4, A5, A6, A7, A8, NAME, ...) NAME\n\n#define EXPAND_01(MACRO, A0, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) \n#define EXPAND_02(MACRO, A0, A1, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) \n#define EXPAND_03(MACRO, A0, A1, A2, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__) \n#define EXPAND_04(MACRO, A0, A1, A2, A3, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) \n#define EXPAND_05(MACRO, A0, A1, A2, A3, A4, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) \n#define EXPAND_06(MACRO, A0, A1, A2, A3, A4, A5, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__) \n#define EXPAND_07(MACRO, A0, A1, A2, A3, A4, A5, A6, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) \n#define EXPAND_08(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) \n#define EXPAND_09(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, A8, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) MACRO(A8, ##__VA_ARGS__) \n\n#define GET_EXPAND(...) GET_MACRO_09(__VA_ARGS__, EXPAND_09, EXPAND_08, \\\n\tEXPAND_07, EXPAND_06, EXPAND_05, EXPAND_04, EXPAND_03, EXPAND_02, EXPAND_01)\n#define EXPAND_ARG_0(MACRO, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__)\n#define EXPAND_ARG_1(MACRO, A0, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__, A0)\n\n#define EXPAND(MACRO, ...) EXPAND_ARG_0(MACRO, __VA_ARGS__)\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define SCANF_INT(a) scanf(\"%d\", &(a));\n#define ID(...) int __VA_ARGS__;\n#define IR(...) {EXPAND(SCANF_INT, __VA_ARGS__)}\n#define I(...) ID(__VA_ARGS__) IR(__VA_ARGS__)\n\n// #define DEFINE_INT_ARRAY(a, n) int a[n];\n// #define INT_ITH_ARRAY(a, i) a[i]\n// #define IAD(N, ...) EXPAND_ARG_1(DEFINE_INT_ARRAY, N, __VA_ARGS__)\n// #define IAR(N, ...) REP(array_reader_i, N){ \n\n#define SCANF_LL(a) scanf(\"%lld\", &(a));\n#define LD(...) ll __VA_ARGS__;\n#define LR(...) {EXPAND(SCANF_LL, __VA_ARGS__)}\n#define L(...) LD(__VA_ARGS__) LR(__VA_ARGS__)\n\n#define SCANF_LD(a) scanf(\"%Lf\", &(a));\n#define DD(...) lD __VA_ARGS__;\n#define DR(...) {EXPAND(SCANF_LD, __VA_ARGS__)}\n#define D(...) DD(__VA_ARGS__) DR(__VA_ARGS__)\n\n#define DEFINE_STR(a, n) char a[n];\n#define SCANF_STR(a) scanf(\"%s\", a);\n#define SD(N, ...) EXPAND_ARG_1(DEFINE_STR, N, __VA_ARGS__)\n#define SR(...) EXPAND(SCANF_STR, __VA_ARGS__)\n#define S(N, ...) SD(N, __VA_ARGS__) SR(__VA_ARGS__)\n\n// Output //////////////////////////////////////////////////////////////////////\n#define LN printf(\"\\n\")\n#define FL fflush(stdout)\n\n#define IP(a, ...) printf(\"%d\", a); \n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FORT(t, i, a, b) \\\n\tfor(t i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define FORL(i, a, b) FORT(ll, i, a, b)\n#define FOR(i, a, b) FORT(int, i, a, b)\n#define REPT(t, i, n) FORT(t, i, 0, n)\n#define REPL(i, n) FORL(i, 0, n)\n#define REP(i, n) FOR(i, 0, n)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define SORTA(a, n) sort(a, a+n)\n\n#define PB push_back\n#define MP make_pair\n#define itr iterator\n\n// Range ///////////////////////////////////////////////////////////////////////\n#define IN(x, a, b) (a<=x && x<b)\n#define INC(x, a, b) (a<=x && x<=b)\nint dx[8] = { 1, 0, 0,-1, 1, 1,-1,-1};\nint dy[8] = { 0,-1, 1, 0,-1, 1,-1, 1};\n\n#define LAR(a, b) ((a)=max((a), (b)))\n#define SML(a, b) ((a)=min((a), (b)))\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define println(...) {printf(__VA_ARGS__); printf(\"\\n\");}\n#ifdef LOCAL\n#define debug(...) printf(__VA_ARGS__)\n#define debugln(...) println(__VA_ARGS__)\n#else\n#define debug(...) {}\n#define debugln(...) {}\n#endif\n\n// Numbers /////////////////////////////////////////////////////////////////////\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\n\n#define PRIME_MAX 1000000\nbool isprime[PRIME_MAX+5];\nvoid init_prime(){\n\tfill(isprime, isprime+PRIME_MAX+5, true);\n\tisprime[0]=isprime[1]=false;\n\tREP(i, PRIME_MAX+5){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=i*2; j<PRIME_MAX; j+=i){\n\t\t\t\tisprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll factors(ll n){\n\tvll v;\n\tREPL(i, PRIME_MAX){\n\t\tif(!isprime[i]) continue;\n\t\twhile(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n>1){\n\t\tv.PB(n);\n\t}\n\treturn v;\n}\n\n// BIT /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int\n>\nclass bit{\npublic:\n\tT *bit_arr;\n\tint size;\n\n\tbit(int n){\n\t\tsize = n;\n\t\tbit_arr = new T[n];\n\t\tfill(bit_arr, bit_arr+n, 0);\n\t}\n\n\t~bit(){\n\t\tdelete bit_arr;\n\t}\n\n\tT sum(int a){\n\t\tT ret = 0;\n\t\twhile(a){\n\t\t\tret+=bit_arr[a];\n\t\t\ta-=a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tT sum(int a, int b){\n\t\treturn sum(b)-sum(a);\n\t}\n\n\tT get(int a){\n\t\treturn sum(a, a+1);\n\t}\n\n\tvoid add(int a, T x){\n\t\ta++;\n\t\twhile(a<size){\n\t\t\tbit_arr[a]+=x;\n\t\t\ta+=a&-a;\n\t\t}\n\t}\n\n\tvoid set(int a, T x){\n\t\tadd(a, x-get(a));\n\t}\n};\ntypedef bit<ll> bll;\n\n// RMQ /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int,\n\tclass Compare=less<T>\n>\nclass rmq{\npublic:\n\tint size;\n\tCompare comp;\n\tT *dat;\n\tT init;\n\t\n\trmq(int n, T init_=INT_MAX){\n\t\tinit=init_;\n\t\tsize = 1;\n\t\twhile(size<n) size*=2;\n\t\tdat = new T[2*size-1];\n\t\tfill(dat, dat+(2*size-1), init);\n\t}\n\n\t~rmq(){\n\t\tdelete dat;\n\t}\n\n\tvoid set(int k, T a){\n\t\tk+=size-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\n\tT get(int a, int b, int k, int l, int r){\n\t\tif(r<=a || b<=l) return init;\n\t\tif(a<=l && r<=b) return dat[k];\n\t\telse{\n\t\t\tT vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\t\tT vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn min(vl, vr, comp);\n\t\t}\n\t}\n\n\tT get(int a, int b){\n\t\treturn get(a, b, 0, 0, size);\n\t}\n};\n\n// Others //////////////////////////////////////////////////////////////////////\n#define MOD 1000000007\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define DPRET(a, b) ((~(a))?(a):((a)=(b)))\n#define N 10\nint n;\nll l[N], r[N];\nll memo[N][N];\nll DP(int, ll);\nll dp(int p, int q){\n\treturn DPRET(memo[p][q], DP(p, q));\n}\nll DP(int p, ll q){\n\tll ret=LLONG_MAX;\n\tif(p==n){\n\t\tret=0;\n\t}else{\n\t\tll d=r[p+1]-l[p+1], e=r[p]-l[p];\n\t\tREPL(i, N-d+1){\n\t\t\tif(i+d<q || q+e<i) continue;\n\t\t\tSML(ret, abs(i-l[p+1])+dp(p+1, i));\n\t\t}\n\t}\n\t// printf(\"DP(%d, %lld)=%lld\\n\", p, q, ret);\n\treturn ret;\n}\n\nint main(){\n\tIR(n);\n\tFOR(i, 1, n+1){\n\t\tLR(l[i], r[i]);\n\t}\n\tl[0]=0;\n\tr[0]=400;\n\tREP(i, N) REP(j, N) memo[i][j]=-1;\n\tprintf(\"%lld\\n\", dp(0, 0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<set>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\ntypedef long long ll;\n//////////////////////\n\nint const N = 1e5 + 41;\n\nint l[N], r[N], n;\nll pref[N];\nint tim;\n\nll getPref(int l, int r){\n\tll ret = pref[r];\n\tif(l > 0) ret -= pref[l-1];\n\treturn ret;\n}\n\nstruct S{\n\tll x, type, time;\n\tS(){};\n\tS(ll x, ll type, ll time) : x(x), type(type), time(time) {};\n\tbool operator<(const S &s) const {\n\t\treturn getX() < s.getX();\n\t};\n\n\tll getX() const {\n\t\tif(type == 0){\n\t\t\treturn x - getPref(time+1, tim);\n\t\t}else{\n\t\t\treturn x + getPref(time, tim-1);\n\t\t}\n\t}\n};\n\nmultiset<S> lp, rp;\n\nll getLast(multiset<S> &ms){\n\tmultiset<S> :: iterator it = ms.end();\n\t--it;\n\treturn ((*it).getX());\n}\n\nll getFirst(multiset<S> &ms){\n\tauto it = ms.begin();\n\treturn (*it).getX();\n}\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n) cin >> l[i] >> r[i];\n\trep(i, 0, n) pref[i] = (r[i] - l[i] + (i > 0 ? pref[i-1] : 0));\n\tll ans = 0;\n\n\tlp.insert(S(l[0], 0, 0));\n\trp.insert(S(l[0], 1, 0));\n\trep(i, 1, n){\n\t\ttim = i;\n\t\tif(l[i] >= getLast(lp) && l[i] <= getFirst(rp)){\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t}else if(l[i] >= getFirst(rp)){\n\t\t\tans += (l[i] - getFirst(rp));\n\t\t\tS tmp = (*rp.begin());\n\t\t\ttmp.type = 0;\n\t\t\trp.erase(rp.begin());\n\t\t\tlp.insert(tmp);\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t}else{\n\t\t\tans += (getLast(lp) - l[i]);\n\t\t\tauto it = lp.end();\n\t\t\t--it;\n\t\t\tS tmp = (*it);\n\t\t\ttmp.type = 1;\n\t\t\tlp.erase(it);\n\t\t\trp.insert(tmp);\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[405][405];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=0;i<405;i++)\n\t\t\tfor(int j=0;j<405;j++)\n\t\t\tdp[i][j]=1e9;\n\t\tfor(int i=1;i<405;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tassert(l>=1&&l<=400);\n\t\t\tassert(r>=1&&r<=400);\n\t\t\tfor(int j=1;j<405;j++)\n\t\t\t{\n\t\t\t\tint aa=0;\n\t\t\t\tif(j<l)\n\t\t\t\taa=l-j;\n\t\t\t\telse if(j>r)\n\t\t\t\taa=j-r;\n\t\t\t\tfor(int k=max(j-(r-l),1);k<=min(404,j+(r-l));k++){\n\t\t\t\t\tif(k<l)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(l-k,aa));\n\t\t\t\t\telse if(k>r)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(k-r,aa));\n\t\t\t\t\telse \n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+aa);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<405;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint dp[444][444];\n\nint N;\nint L[111111],D[111111];\n\nbool ok(int l1,int d1,int l2,int d2){\n    if(l1>l2){\n        swap(l1,l2);\n        swap(d1,d2);\n    }\n    return l2-l1<=d1;\n}\n\nsigned main(){\n    cin>>N;\n    if(N>400)return 0;\n    rep(i,N){\n        int l,r;\n        cin>>l>>r;\n        D[i]=r-l;\n        L[i]=l-1;\n    }\n\n    rep(i,400)dp[1][i]=abs(i-L[0]);\n\n    for(int i=1;i<N;i++){\n        int l=0,r=0;\n        deque<int>deq;\n        for(int j=0;j<400;j++){\n            while(r<400&&ok(j,D[i],r,D[i-1])){\n                while(deq.size()&&dp[i][deq.back()]>=dp[i][r])deq.pop_back();\n                deq.push_back(r);\n                r++;\n            }\n\n            if(!ok(j,D[i],l,D[i-1])){\n                if(deq.size()&&deq.front()==l)deq.pop_front();\n                l++;\n            }\n            dp[i+1][j]=abs(j-L[i])+dp[i][deq.front()];\n        }\n    }\n\n    cout<<*min_element(dp[N],dp[N]+400)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 20000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint dp[401][401];\nint l[401],r[401];\n\nbool check(int v,int l1,int l2){\n\tint r1=l1+r[v]-l[v];\n\tint r2=l2+r[v+1]-l[v+1];\n\tif(r2<l1 || r1<l2)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tif(n>=401)return 0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tif(r[i]>=401)return 0;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=400;j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=1;i<=400;i++){\n\t\tdp[0][i]=abs(l[0]-i);\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=1;j<=400;j++){\n\t\t\tfor(int k=1;k<=400;k++){\n\t\t\t\tif(check(i,j,k)){\n\t\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+abs(k-l[i+1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=1;i<=400;i++){\n\t\tres=min(res,dp[n-1][i]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Majk\n */\n\n#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned int ui;\n\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n// #include \"../l/mod.h\"\n\nclass E {\npublic:\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tint N; cin >> N;\n\t\tif (N > 400) { cout << \"BIG\"; return; }\n\t\tvector<pii> A(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, r; cin >> l >> r;\n\t\t\tif (r > 400) { cout << \"BIG\"; return; }\n\t\t\tA[i] = {l,r-l};\n\t\t}\n\n\t\tvector<vector<int>> M(N, vector<int>(400, MOD));\n\t\tfor (int i = 0; i < 400; ++i) {\n\t\t\tM[0][i] = abs(i-A[0].x);\n\t\t}\n\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 400; ++j) {\n\t\t\t\tfor (int k = 0; k < 400; ++k) {\n\t\t\t\t\tif ((j >= k && j <= k + A[i-1].y) || (j + A[i].y >= k && j + A[i].y <= k + A[i-1].y)\n\t\t\t\t\t\t|| (k + A[i-1].y >= j && k + A[i-1].y <= j + A[i].y) || (k >= j && k <= j + A[i].y)) {\n\t\t\t\t\t\tM[i][j] = min(M[i][j], M[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tM[i][j] += abs(j - A[i].x);\n\t\t\t}\n\t\t}\n\n\t\tint ans = MOD;\n\t\tfor (int i = 0; i < 400; ++i) {\n\t\t\tans = min(ans, M[N-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\n\n\t}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, int val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    int p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    int p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 100002;\n\n\nint N;\nll maxR, maxL;\npair<ll, ll> points[MAXN];\nmultiset<ll> memo_r, memo_l;\n\n\nvoid input() {\n  cin >> N;\n  for (int i = 1 ; i <= N ; i++) {\n    cin >> points[i].first >> points[i].second;\n  }\n}\n\n\nvoid preprocess() {\n}\n\n/*\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tlen[i]=r-l;\n\t\tif(i>0){shiftpos+=len[i-1]; c-=len[i-1]*m;}\n\t\tshiftneg-=len[i];\n\t\tpos.insert(l-shiftpos); pos.insert(l-shiftpos);\n\t\tauto it=pos.begin(); ll res=(*it)+shiftpos;\n\t\tpos.erase(pos.begin()); neg.insert(res-shiftneg);\n\t\tll neglas=(*prev(neg.end()))+shiftneg;\n\t\tll posles=(*pos.begin())+shiftpos;\n\t\tif(!neg.empty()&&neglas>posles)\n\t\t{\n\t\t\tneg.erase(prev(neg.end())); pos.erase(pos.begin());\n\t\t\tpos.insert(neglas-shiftpos); neg.insert(posles-shiftneg);\n\t\t}\n\t\tm++; c-=l;\n\t}\n\twhile(m>0)\n\t{\n\t\tc+=(*prev(pos.end()))+shiftpos;\n\t\tm--;\n\t\tpos.erase(prev(pos.end()));\n\t}\n */\n\nvoid solve() {\n\n  ll cost = 0;\n  for (int i = 1 ; i <= N ; i++) {\n    if (i > 1) {\n      maxR += points[i-1].second - points[i-1].first;\n      cost -= (points[i-1].second - points[i-1].first) * (i-1);\n    }\n    maxL -= points[i].second - points[i].first;\n    memo_r.insert(points[i].first - maxR);\n    memo_r.insert(points[i].first - maxR);\n    auto it = memo_r.begin();\n    ll val = (*it) + maxR;\n    memo_r.erase(memo_r.begin());\n    memo_l.insert(val-maxL);\n    ll lPos = (*prev(memo_l.end())) + maxL;\n    ll rPos = (*memo_r.begin()) + maxR;\n    if (!memo_l.empty() && lPos > rPos) {\n      memo_l.erase(prev(memo_l.end()));\n      memo_r.erase(memo_r.begin());\n      memo_l.insert(rPos-maxL);\n      memo_r.insert(lPos-maxR);\n    }\n    cost -= points[i].first;\n  }\n\n  for (int i = 1 ; i <= N ; i++) {\n    cost += (*prev(memo_r.end())) + maxR;\n    memo_r.erase(prev(memo_r.end()));\n  }\n\n  cout << cost;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\nint mem[MAXN][MAXN];\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 0;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long n, l[100009], r[100009], L, R, sum;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (i == 1) { L = l[i]; R = l[i]; }\n\t\telse {\n\t\t\tL -= (r[i] - l[i]); R += (r[i - 1] - l[i - 1]);\n\t\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\t\tL = l[i]; R = l[i];\n\t\t\t}\n\t\t\telse if (R < l[i]) {\n\t\t\t\tsum += (l[i] - R);\n\t\t\t\tlong long LL = R, RR = l[i];\n\t\t\t\tL = LL; R = RR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += (L - l[i]);\n\t\t\t\tlong long LL = l[i], RR = L;\n\t\t\t\tL = LL; R = RR;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nconst int N = 1e5 + 5;\ntypedef long long ll;\n#define int ll\nusing namespace std; \n\nint n, l[N], r[N], len[N], ans, addl, addr; \npriority_queue<int> L;\npriority_queue<int, vector<int>, greater<int> > R; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint mabs(int x) { return x > 0 ? x : -x; }\n\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> ();\n\tfor(int i = 1; i <= n; i++) l[i] = read <int> (), r[i] = read <int> (), len[i] = r[i] - l[i]; \n\tL.push(l[1]), R.push(l[1]); \n\tfor(int x, y, i = 2; i <= n; i++)\n\t{\n\t\taddl -= len[i], addr += len[i - 1]; \n\t\tx = L.top() + addl, y = R.top() + addr;\n\t\tif(l[i] < x)\n\t\t{\n\t\t\tans += x - l[i], L.pop(), R.push(x - addr);\n\t\t\tL.push(l[i] - addl), L.push(l[i] - addl); \n\t\t}\n\t\telse if(l[i] > y)\n\t\t{\n\t\t\tans += l[i] - y, R.pop(), L.push(y - addl);\n\t\t\tR.push(l[i] - addr), R.push(l[i] - addr); \n\t\t}\n\t\telse L.push(l[i] - addl), R.push(l[i] - addr); \n\t}\n\tprintf(\"%lld\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "//marico el que lo lea\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <stdlib.h>\n#include <assert.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> ii;\n\nvoid fastIO() {\n\tstd::ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n}\n\n#define FOR(i,f,t) for(int i=f; i<(int)t; i++)\n#define FORR(i,f,t) for(int i=f; i>(int)t; i--)\n#define FORE(i,c) for(auto i = (c).begin(); i != (c).end(); i++)\n#define pb push_back\n#define all(obj) obj.begin(), obj.end()\n#define ms(obj, val) memset(obj, val, sizeof(obj))\n#define ms2(obj, val, sz) memset(obj, val, sizeof(obj[0])*sz)\n\n#define fst first\n#define snd second\n\ntemplate<typename T, typename U> inline void mnze(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void mxze(T &x, U y) { if(x < y) x = y; }\n\nvoid _scan( int &x ) { scanf(\"%d\",&x); }\nvoid _scan( long long &x ) { scanf(\"%lld\",&x); }\nvoid _scan( double &x ) { scanf(\"%lf\",&x); }\nvoid _scan( char &x ) { scanf(\" %c\",&x); }\nvoid _scan( char *x ) { scanf(\"%s\",x); }\nvoid scan() {}\ntemplate<typename T, typename... U>\nvoid scan( T& head, U&... tail ) { _scan(head); scan(tail...);}\n\ntemplate<typename T> void _dbg(const char* sdbg, T h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename T, typename... U> void _dbg(const char* sdbg, T h, U... t) {\n\twhile(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(_i, (x)) cerr <<*_i <<\", \"; cerr <<\"\\n\"; }}\n#define debuga(x, sz) {{cerr <<#x <<\" = \"; FOR(_i, 0, sz) cerr << x[_i] <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define debuga(x, sz)\n#define cerr if(0)cout\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 1e5+5;\n\nint N, l[MAXN], r[MAXN], s[MAXN];\n\npriority_queue<ll> L;\npriority_queue<ll, vi, greater<ll>> R;\nll dL, dR, c;\n\nint main(){\n\tscan(N);\n\tFOR(i,0,N) scan(l[i], r[i]);\n\tFOR(i,0,N) s[i] = r[i]-l[i];\n\tL.push(l[0]); R.push(r[0]);\n\tFOR(i,1,N){\n\t\tdL -= s[i]; dR += s[i-1];\n\t\tll L0 = L.top(), R0 = R.top();\n\t\tif(L0+dL < l[i] && l[i] < R0+dR){\n\t\t\tL.push(l[i]-dL); R.push(l[i]-dR);\n\t\t}else if(l[i] >= R0+dR){\n\t\t\tR.push(l[i] - dR);\n\t\t\tR.push(l[i] - dR);\n\t\t\tll nL0 = R.top() + dR; R.pop();\n\t\t\tc += l[i] - nL0;\n\t\t\tL.push(nL0-dL);\n\t\t}else{\n\t\t\tL.push(l[i] - dL);\n\t\t\tL.push(l[i] - dL);\n\t\t\tll nR0 = L.top() + dL; L.pop();\n\t\t\tc += nR0 - l[i];\n\t\t\tR.push(nR0-dR);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\nint maxpos=-1 , minpos=LINF;\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\tminpos = min( minpos , l[i] );\n\t\tmaxpos = max( maxpos , l[i] );\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = minpos;i <= maxpos;i++)\n\t\tans = min(  ans  ,  dp(1,i)  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define TASK \"insider\"\n#pragma comment(linker, \"/STACK:671088640\")\n#include <stdio.h>\n#include <iostream>\n#include <iomanip> \n#include <math.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <functional>\n#include <assert.h>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <complex>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int INF = 20000000;\nconst long double EPS = 1e-7;\nconst int HASH_POW = 29;\nconst long double PI = acos(-1.0);\nmt19937_64 rnd(1);\n\ndouble workTime()\n{\n\treturn double(clock()) / CLOCKS_PER_SEC;\n}\n\nvoid my_return(int code)\n{\n#ifdef MYDEBUG\n\tcout << \"\\nTime = \" << fixed << setprecision(3) << workTime() << endl;\n#endif\n\texit(code);\n}\n\nint n, ll[410], rr[410];\nint dp[410][410];\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n#ifdef MYDEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#else\n\t/*freopen(TASK\".in\", \"r\", stdin);\n\tfreopen(TASK\".out\", \"w\", stdout);*/\n\t/*freopen(\"pie_progress.txt\", \"r\", stdin);\n\tfreopen(\"pie_progress_output.txt\", \"w\", stdout);*/\n#endif\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d %d\", &ll[i], &rr[i]);\n\n\tfor (int j = 1; j <= 400; ++j)\n\t\tdp[1][j] = abs(ll[1] - j);\n\tfor (int i = 2; i <= n; ++i)\n\t{\n\t\tfor (int j = 1; j <= 400; ++j)\n\t\t{\n\t\t\tint foo = j - (rr[i - 1] - ll[i - 1]), bar = j + (rr[i] - ll[i]);\n\t\t\tfoo = max(foo, 1);\n\t\t\tbar = min(bar, 400);\n\t\t\tdp[i][j] = INF;\n\t\t\tif (foo > bar)\n\t\t\t\tcontinue;\n\t\t\tfor (int x = foo; x <= bar; ++x)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][x] + abs(j - ll[i]));\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int j = 1; j <= 400; ++j)\n\t\tans = min(ans, dp[n][j]);\n\tprintf(\"%d\\n\", ans);\n\n\tmy_return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst bool DBG = 1;\n\n#define TRACE(x)    x\n#define WATCH(x)    TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a,b) TRACE(for(auto it=a; it!=b;) cout<<*(it++)<<\" \";cout<<endl)\n#define WATCHC(V)   TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n#define all(x) (x).begin(), (x).end()\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\ntemplate<typename T> struct PWLC {\n    T y0;\n    max_heap<pair<T, T>> left;\n    min_heap<pair<T, T>> right;\n    T left_offset = 0, right_offset = 0;\n\n    PWLC(T _y0 = 0) : y0(_y0) {}\n\n    /* __ : y = alpha */\n    static PWLC constant(T alpha) { return PWLC(alpha); }\n    /* \\_ : y = max(0, beta * (x - x0)) */\n    static PWLC decreasing(T x0, T beta = -1) { assert(beta <= 0); PWLC f; f.left.push({ x0, -beta }); return f; }\n    /* _/ : y = max(0, beta * (x - x0)) */\n    static PWLC increasing(T x0, T beta =  1) { assert(beta >= 0); PWLC f; f.right.push({ x0, beta }); return f; }\n    /* \\/ : y = beta * abs(x - x0) */\n    static PWLC abs(T x0, T beta = 1) { return decreasing(x0, -beta) + increasing(x0, beta); }\n\n    /* f'(x) = f(x + c) */\n    void shift(int c) { left_offset -= c; right_offset -= c; }\n    /* \\_/ => \\__ : f'(x') = min_{x <= x'} f(x) */\n    void prefix_min() { while (!right.empty()) right.pop(); }\n    /* \\_/ => __/ : f'(x') = min_{x >= x'} f(x) */\n    void suffix_min() { while (!left.empty()) left.pop(); }\n    /* \\_/ => \\__/ : f'(x') = min_{dx in [xl, xr]} f(x' + dx) */\n    void range_min(T xl, T xr) {\n        assert(xl <= xr);\n        if (xl > 0) shift(xl), tie(xl, xr) = make_pair(0, xr - xl);\n        if (xr < 0) shift(xr), tie(xl, xr) = make_pair(xl - xr, 0);\n        left_offset -= xr;\n        right_offset -= xl;\n    }\n\n    T minimum() const { return y0; }\n    T left_arg_min() const { return left.empty() ? numeric_limits<T>::min() : (left.top().first + left_offset); }\n    T right_arg_min() const { return right.empty() ? numeric_limits<T>::max() : (right.top().first + right_offset); }\n\n    void operator+=(PWLC o) {\n        y0 += o.y0;\n        for (; !o.left.empty(); o.left.pop()) {\n            T x = o.left.top().first + o.left_offset;\n            T beta_change = o.left.top().second;\n\n            if (x <= right_arg_min()) {\n                left.push({ x - left_offset, beta_change });\n            } else {\n                T x0 = right_arg_min();\n                y0 += (x - x0) * beta_change;\n                right.push({ x - right_offset, beta_change });\n                for (T beta = beta_change; beta > 0; ) {\n                    T next_change = right.top().second;\n                    right.pop();\n                    if (next_change >= beta) {\n                        left.push({ x0 - left_offset, beta });\n                        if (next_change > beta) right.push({ x0 - right_offset, next_change - beta });\n                        beta = 0;\n                    } else {\n                        beta -= next_change;\n                        y0 -= beta * (right_arg_min() - x0);\n                        x0 = right_arg_min();\n                    }\n                }\n            }\n        }\n        for (; !o.right.empty(); o.right.pop()) {\n            T x = o.right.top().first + o.right_offset;\n            T beta_change = o.right.top().second;\n\n            if (x >= left_arg_min()) {\n                right.push({ x - right_offset, beta_change });\n            } else {\n                T x0 = left_arg_min();\n                y0 += (x0 - x) * beta_change;\n                left.push({ x - left_offset, beta_change });\n                for (T beta = beta_change; beta > 0; ) {\n                    T next_change = left.top().second;\n                    left.pop();\n                    if (next_change >= beta) {\n                        right.push({ x0 - right_offset, beta });\n                        if (next_change > beta) left.push({ x0 - left_offset, next_change - beta });\n                        beta = 0;\n                    } else {\n                        beta -= next_change;\n                        y0 -= beta * (x0 - left_arg_min());\n                        x0 = left_arg_min();\n                    }\n                }\n            }\n        }\n    }\n    friend PWLC operator+(const PWLC &a, const PWLC &b) { PWLC f(a); f += b; return f; }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    ll l = 0, r = 0;\n    auto dp = PWLC<ll>(0);\n    FOR(i,0,n) {\n        ll last_l = l, last_r = r;\n        cin >> l >> r;\n        dp.range_min(last_l - last_r, r - l);\n        //cout << i << \" \" << dp.minimum() << \" (\" << dp.left_arg_min() << \", \" << dp.right_arg_min() << \")\" << endl;\n        dp += PWLC<ll>::abs(l);\n        //cout << i << \" \" << dp.minimum() << \" (\" << dp.left_arg_min() << \", \" << dp.right_arg_min() << \")\" << endl;\n    }\n    cout << dp.minimum() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint N;\nvector<pll> seg;\n\npriority_queue<ll> lpq, rpq;\nll loff = 0, roff = 0, mn = 0;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tseg.resize(N + 1);\n\tseg[0] = pll(-1e15, 1e15);\n\tfor(int i = 1; i <= N; i++) {\n\t\tscanf(\"%lld %lld\", &seg[i].first, &seg[i].second);\n\t}\n\n\tlpq.push(-1e15);\n\trpq.push(-1e15);\n\n\tfor(int i = N - 1; i >= 0; i--) {\n\t\tll lt = lpq.top() + loff;\n\t\tll rt = -rpq.top() + roff;\n\n\t\tif(lt <= seg[i + 1].first && seg[i + 1].first <= rt) {\n\t\t\tlpq.push(seg[i + 1].first - loff);\n\t\t\trpq.push(-(seg[i + 1].first - roff));\n\t\t}\n\t\telse if(seg[i + 1].first < lt) {\n\t\t\tlpq.push(seg[i + 1].first - loff);\n\t\t\tlpq.push(seg[i + 1].first - loff);\n\t\t\tll lt1 = lpq.top() + loff; lpq.pop(); rpq.push(-(lt1 - roff));\n\t\t\tll lt2 = lpq.top() + loff;\n\t\t\tmn += abs(lt2 - seg[i + 1].first) + lt1 - lt2;\n\t\t}\n\t\telse if(seg[i + 1].first > rt) {\n\t\t\trpq.push(-(seg[i + 1].first - roff));\n\t\t\trpq.push(-(seg[i + 1].first - roff));\n\t\t\tll rt1 = -rpq.top() + roff; rpq.pop(); lpq.push(rt1 - loff);\n\t\t\tll rt2 = -rpq.top() + roff;\n\t\t\tmn += abs(rt2 - seg[i + 1].first) + rt2 - rt1;\n\t\t}\n\n\t\tloff -= seg[i].second - seg[i].first;\n\t\troff += seg[i + 1].second - seg[i + 1].first;\n\t}\n\tcout<<mn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) //cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) //cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vi l(n), r(n), width(n);\n  rep (i, n) {\n    scanf(\"%d%d\", &l[i], &r[i]);\n    width[i] = r[i] - l[i];\n  }\n  ll left_offset, right_offset;\n  left_offset = right_offset = 0;\n  ll minval = 0;\n  set<ll> left;\n  left.insert(l[0]);\n  auto right = left;\n\n  FOR (i, 1, n) {\n    left_offset -= width[i];\n    right_offset += width[i-1];\n    debug2(left_offset, right_offset);\n    auto min_left = --end(left);\n    auto min_right = begin(right);\n    debug2(*min_left, *min_right);\n    debug(minval);\n    if (*min_left + left_offset <= l[i] && l[i] <= *min_right + right_offset) {\n      left.insert(l[i] - left_offset);\n      right.insert(l[i] - right_offset);\n    } else {\n      if (l[i] < *min_left + left_offset) {\n        minval += *min_left + left_offset - l[i];\n\n        right.insert(*min_left + left_offset - right_offset);\n        left.erase(min_left);\n        left.insert(l[i] - left_offset);\n        left.insert(l[i] - left_offset);\n      } else {\n        minval += l[i] - (*min_right + right_offset);\n\n        left.insert(*min_right + right_offset - left_offset);\n        right.erase(min_right);\n        right.insert(l[i] - right_offset);\n        right.insert(l[i] - right_offset);\n      }\n    }\n  }\n  printf(\"%lld\\n\", minval);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,a,n)     for(int i=a;i<n;i++)\n#define rep3(n)        for(int i=0;i<n;i++)\n#define ll             long long\n#define int            long long\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define endl           \"\\n\"\n#define eb             emplace_back\n#define x              first\n#define y              second\n#define gcd(a,b)       __gcd(a,b)\n#define mem1(a)        memset(a,-1,sizeof(a))\n#define mem0(a)        memset(a,0,sizeof(a))\n#define pres(a,x)      a.find(x)!=a.end()\n#define sz(a)          (int)a.size()\n#define pii            pair<int,int>\n#define hell           1000000007\n#define elasped_time   1.0 * clock() / CLOCKS_PER_SEC\nusing namespace std;\n\n\ntemplate<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<\" \"<<a.y;return out;}\ntemplate<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}\ntemplate<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}\n\nconst int N=500;\nint dp[N][N];\n\nint solve(){\n \tint n;cin>>n;\n \tvector<pii>vec(n+1);\n \trep(i,1,n+1){\n \t\tcin>>vec[i];\n \t}\n \tsort(vec.begin()+1,vec.end(),[&](pii p1,pii p2){return p1.y<p2.y;});\n \tfor(int i=1;i<=400;i++){\n \t\tfor(int j=1;j<=400;j++)dp[i][j]=1e18;\n \t}\n \tfor(int i=1;i<=400;i++){\n \t\tdp[1][i]=abs(i-vec[1].y);\n \t}\n \tfor(int i=2;i<=n;i++){\n \t\tfor(int j=1;j<=400;j++){\n \t\t\tint l=j-vec[i-1].y+vec[i-1].x;\n \t\t\tfor(int k=j;k<=400;k++){\n \t\t\t\tint left=k-vec[i].y+vec[i].x;\n \t\t\t\tif(left<=j && left>=l)mins(dp[i][k],abs(k-vec[i].y)+dp[i-1][j]);\n \t\t\t}\t\n \t\t}\n \t}\n \tint mn=1e18;\n \trep(i,1,401)mins(mn,dp[n][i]);\n \tcout<<mn<<endl;\n return 0;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #ifdef SIEVE\n    sieve();\n    #endif\n    #ifdef NCR\n    init();\n    #endif\n    int t=1;//cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvint a(n);\n\tvint b(n);\n\tvint c(n);\n\tassert(n<=400);\n\trep(i,n){\n\t\tcin>>a[i]>>b[i];\n\t\tassert(b[i]<=400);\n\t\ta[i]--,b[i]--;\n\t\tc[i] = b[i]-a[i];\n\t}\n\tvint dp(500);\n\trep(i,n){\n\t\tif(i==0){\n\t\t\tdp[i] = abs(i - a[i]);\n\t\t}\n\t\telse{\n\t\t\tvint next(500,INF);\n\t\t\trep(j,500){\n\t\t\t\treep(k,j-c[i-1],j+c[i]+1){\n\t\t\t\t\tif(k<0) continue;\n\t\t\t\t\tif(k>=500) continue;\n\t\t\t\t\tmins(next[j], dp[k]+abs(a[i]-j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,500) mins(ans, dp[i]);\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,a,n)     for(int i=a;i<n;i++)\n#define rep3(n)        for(int i=0;i<n;i++)\n#define ll             long long\n#define int            long long\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define endl           \"\\n\"\n#define eb             emplace_back\n#define x              first\n#define y              second\n#define gcd(a,b)       __gcd(a,b)\n#define mem1(a)        memset(a,-1,sizeof(a))\n#define mem0(a)        memset(a,0,sizeof(a))\n#define pres(a,x)      a.find(x)!=a.end()\n#define sz(a)          (int)a.size()\n#define pii            pair<int,int>\n#define hell           1000000007\n#define elasped_time   1.0 * clock() / CLOCKS_PER_SEC\nusing namespace std;\n\n\ntemplate<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<\" \"<<a.y;return out;}\ntemplate<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}\ntemplate<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}\n\nconst int N=500;\nint dp[N][N];\n\nint solve(){\n \tint n;cin>>n;\n \tvector<pii>vec(n+1);\n \trep(i,1,n+1){\n \t\tcin>>vec[i];\n \t}\n \tsort(vec.begin()+1,vec.end(),[&](pii p1,pii p2){return p1.y<p2.y;});\n \tfor(int i=1;i<=400;i++){\n \t\tfor(int j=1;j<=400;j++)dp[i][j]=1e18;\n \t}\n \tfor(int i=1;i<=400;i++){\n \t\tdp[1][i]=abs(i-vec[1].y);\n \t}\n \tfor(int i=2;i<=n;i++){\n \t\tfor(int j=1;j<=400;j++){\n \t\t\tint l=j-vec[i-1].y+vec[i-1].x;\n \t\t\tfor(int k=1;k<=400;k++){\n \t\t\t\tint left=k-vec[i].y+vec[i].x;\n \t\t\t\tif(left<=j && left>=l)mins(dp[i][k],abs(k-vec[i].y)+dp[i-1][j]);\n \t\t\t}\t\n \t\t}\n \t}\n \tint mn=1e18;\n \trep(i,1,401)mins(mn,dp[n][i]);\n \tcout<<mn<<endl;\n return 0;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #ifdef SIEVE\n    sieve();\n    #endif\n    #ifdef NCR\n    init();\n    #endif\n    int t=1;//cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define pii Pi\n#define pll PL\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> PL;\ntypedef long double ldouble;\n\nconst int inf = 1e9;\n\nvector <ll> V;\n\nstruct node{\n\tnode(){add = val = 0, cnt = 1; child[0] = child[1] = par = 0;}\n\tnode(int x){\n\t\tadd = 0, val = x, cnt = 1, child[0] = child[1] = par = 0;\n\t}\n\tint cnt;\n\tll add, val;\n\tnode *child[2], *par;\n\tinline int mydir(){\n\t\treturn par->child[0] != this;\n\t}\n\tvoid pushdown(){\n\t\tif(add){\n\t\t\tif(child[0])child[0]->add += add, child[0]->val += add;\n\t\t\tif(child[1])child[1]->add += add, child[1]->val += add;\n\t\t\tadd = 0;\n\t\t}\n\t}\n\tvoid pushup(){\n\t\tcnt = 1 + (child[0] ? child[0]->cnt : 0) + (child[1] ? child[1]->cnt : 0);\n\t}\n\tinline void Ins(int dir, int x){\n\t\tchild[dir] = new node(x);\n\t\tchild[dir]->par = this;\n\t\tpushup();\n\t}\n\tvoid *rotate(int dir){\n\t\tnode *tmp = child[!dir];\n\t\tpushdown();\n\t\ttmp->pushdown();\n\t\ttmp->par = par;\n\t\tif(par)par->child[mydir()] = tmp;\n\t\tchild[!dir] = tmp->child[dir];\n\t\tif(tmp->child[dir])tmp->child[dir]->par = this;\n\t\ttmp->child[dir] = this;\n\t\tpar = tmp;\n\t\tpushup();\n\t\ttmp->pushup();\n\t\treturn tmp;\n\t}\n\tvoid splay(node *rootp){\n\t\twhile(par != rootp){\n\t\t\tint myd = mydir();\n\t\t\tif(par->par == rootp){\n\t\t\t\tpar->rotate(!myd);\n\t\t\t}\n\t\t\telse if(myd == par->mydir()){\n\t\t\t\tpar->par->rotate(!myd);\n\t\t\t\tpar->rotate(!myd);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar->rotate(!myd);\n\t\t\t\tpar->rotate(myd);\n\t\t\t}\n\t\t}\n\t}\n\tnode *kth_node(int k){\n\t\tpushdown();\n\t\tint c = (child[0] ? child[0] -> cnt : 0);\n\t\tif(c+1 == k)return this;\n\t\telse if(c+1 < k){\n\t\t\tk -= c+1;\n\t\t\treturn child[1]->kth_node(k);\n\t\t}\n\t\telse{\n\t\t\treturn child[0]->kth_node(k);\n\t\t}\n\t}\n\tvoid travel(){\n\t\tpushdown();\n\t\tif(child[0])child[0]->travel();\n\t\tV.pb(val);\n\t\t//printf(\"%lld \", val);\n\t\tif(child[1])child[1]->travel();\n\t}\n\tnode *Insert(int x){\n\t\tpushdown();\n\t\tif(val >= x){\n\t\t\tif(!child[0]){ Ins(0, x); return child[0]; }\n\t\t\telse{\n\t\t\t\tauto res = child[0]->Insert(x);\n\t\t\t\tpushup();\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!child[1]){ Ins(1, x); return child[1]; }\n\t\t\telse{\n\t\t\t\tauto res = child[1]->Insert(x);\n\t\t\t\tpushup();\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct splaytree{\n\tsplaytree(int x){\n\t\troot = new node(x);\n\t\troot->Ins(1, x);\n\t\troot->pushup();\n\t\tC = 2;\n\t}\n\tint C;\n\tnode *root;\n\tvoid travel(){\n\t\troot->travel(); //puts(\"\");\n\t}\n\tnode *kth_splay(int k, node *rootp){\n\t\tnode *tmp = root->kth_node(k);\n\t\ttmp->splay(rootp);\n\t\treturn tmp;\n\t}\n\tvoid query(int ls, int rs){\n\t\tauto p = kth_splay(C / 2, 0);\n\t\troot = p;\n\t\tp->val -= ls;\n\t\tif(p->child[0])p->child[0]->val -= ls, p->child[0]->add -= ls;\n\t\tif(p->child[1])p->child[1]->val += rs, p->child[1]->add += rs;\n\t}\n\tvoid Insert(int x){\n\t\tauto p = root->Insert(x);\n\t\tp->splay(0); root = p;\n\t\tp = root->Insert(x);\n\t\tp->splay(0); root = p;\n\t\tC += 2;\n\t}\n}*ST;\n\nint L[100010], R[100010];\n\n//#define __int128 long long\n\nvoid solve(){\n\tint N; scanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)scanf(\"%d%d\", L+i, R+i), R[i] -= L[i];\n\tST = new splaytree(L[1]);\n\tll T = -2000000000000000LL;\n\t__int128 F = -T + L[1];\n\tfor(int i=2;i<=N;i++){\n\t\tST->query(R[i], R[i-1]);\n\t\tF -= (__int128) R[i] * (i-1);\n\t\tST->Insert(L[i]);\n\t\tF += (-T + L[i]);\n\t\t//ST->travel();\n\t}\n\tV.pb(T);\n\tST->travel();\n\t__int128 now = F;\n\t__int128 ans = F;\n\tfor(int i=1;i<sz(V);i++){\n\t\tint a = i - N - 1;\n\t\tnow += (__int128)(V[i] - V[i-1]) * a;\n\t\tans = min(ans, now);\n\t}\n\tif(ans == 0){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\t//printf(\"%lld\\n\", ans);\n\tstring s;\n\twhile(ans)s.pb(ans % 10 + '0'), ans /= 10;\n\treverse(all(s));\n\tprintf(\"%s\\n\", s.c_str());\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 999999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\nint maxpos=-1 , minpos=MAXN;\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\tminpos = min( minpos , l[i] );\n\t\tmaxpos = max( maxpos , l[i] );\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = minpos;i <= maxpos;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmultiset<long long, greater<long long>> s1;\nmultiset<long long, greater<long long>>::iterator it1;\nmultiset<long long> s2;\nmultiset<long long>::iterator it2;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tlong long ans = 0;\n\tint L, R, aL = 0, aR = 0;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tint l, r; cin >> l >> r;\n\t\tif(!i) {\n\t\t\tL = l; R = r;\n\t\t\ts1.insert(l);\n\t\t\ts2.insert(r);\n\t\t} else {\n\t\t\tif(l <= R) {\n\t\t\t\ts1.insert(l + aL);\t\n\t\t\t} else {\n\t\t\t\tans += l - R;\n\t\t\t\tit2 = s2.lower_bound(R + r - l - aR);\n\t\t\t\ts2.erase(s2.begin(), it2);\n\t\t\t\taR += r - l;\n\t\t\t\ts2.insert(r - aR);\n\t\t\t\ts1.insert(R + aL);\n\t\t\t}\n\t\t\tif(r >= L) {\n\t\t\t\ts2.insert(r - aR);\n\t\t\t} else {\n\t\t\t\tans += L - r;\n\t\t\t\tit1 = s1.lower_bound(L + l - r + aL);\n\t\t\t\ts1.erase(s1.begin(), it1);\n\t\t\t\taL += r - l;\n\t\t\t\ts1.insert(l + aL);\n\t\t\t\ts2.insert(L - aR);\n\t\t\t}\n\t\t}\n\t\tL = *s1.begin() - aL;\n\t\tR = *s2.begin() + aR;\n//\t\tfor(auto v1 : s1) cerr << v1 - aL << \" \"; cout << \"\\n\";\n//\t\tfor(auto v2 : s2) cerr << v2 + aR << \" \"; cout << \"\\n\";\n//\t\tcerr << ans << ' ' << L << ' ' << R << \"\\n===========\\n\";\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n/*\n3\n5 6\n3 4\n1 2\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nint li[405];\nint ri[405];\nint ci[405];\nint f[405][405];\n\ninline int chk(int xa,int ya,int xb,int yb) {\n    if(ya<xb || yb<xa) return 0;return 1;\n}\n\ninline int iabs(int x) {return x>=0?x:-x;}\n\ninline void chkmin(int& x,int v) {x=min(x,v);}\n\nint main() {\n    int n;\n    read(n);\n    REP(i,1,n) read(li[i]),read(ri[i]),ci[i]=ri[i]-li[i];\n    li[0]=1;ri[0]=400;ci[0]=ri[0]-li[0];\n    memset(f,0x3f,sizeof(f));f[0][1]=0;\n    REP(i,1,n) {\n        REP(j,1,400) {\n            REP(k,1,400) if(chk(j,j+ci[i],k,k+ci[i-1])) {\n                chkmin(f[i][j],f[i-1][k]+iabs(li[i]-j));\n            }\n        }\n    }\n    int res=(int)(1e9)+100;\n    REP(i,1,400) res=min(res,f[n][i]);\n    printf(\"%d\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP(a, n) REP(i, n) printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ')\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n\ntypedef long long ll;\n\nconst int N_MAX = 100000;\n\nint N;\nint l[N_MAX];\nint r[N_MAX];\nint w[N_MAX];\n\nset<int> ls;\nset<int> rs;\nll ans;\n\nvoid solve() {\n  REP(i, N) w[i] = r[i] - l[i];\n  ls.insert(l[0]); rs.insert(l[0]);\n  ans = 0;\n  FOR(i, 1, N - 1) {\n    // printf(\"ls: {\"); ITR(ls, it) printf(\"%d, \", *it); printf(\"}\\n\");\n    // printf(\"rs: {\"); ITR(rs, it) printf(\"%d, \", *it); printf(\"}\\n\");\n    int l2 = *ls.rbegin() - w[i];\n    int r2 = *rs.begin() + w[i - 1];\n    int l3 = l[i];\n    ls.erase(ls.lower_bound(l2), ls.end());\n    rs.erase(rs.begin(), rs.upper_bound(r2));\n    // printf(\"i: %d, lr2: (%d, %d), l3: %d\\n\", i, l2, r2, l3);\n    if (l3 > r2) {\n      ls.insert(l2);\n      ls.insert(r2);\n      rs.insert(l3);\n      // printf(\"ls << (%d, %d), rs << (%d), ans += %d\\n\", l2, r2, l3, l3 - r2);\n      ans += l3 - r2;\n    } else if (l3 < l2) {\n      ls.insert(l3);\n      rs.insert(l2);\n      rs.insert(r2);\n      // printf(\"ls << (%d), rs << (%d, %d), ans += %d\\n\", l3, l2, r2, l2 - l3);\n      ans += l2 - l3;\n    } else {\n      ls.insert(l2);\n      ls.insert(l3);\n      rs.insert(l3);\n      rs.insert(r2);\n      // printf(\"ls << (%d, %d), rs << (%d, %d), ans += 0\\n\", l2, l3, l3, r2);\n    }\n  }\n  // printf(\"ls: {\"); ITR(ls, it) printf(\"%d, \", *it); printf(\"}\\n\");\n  // printf(\"rs: {\"); ITR(rs, it) printf(\"%d, \", *it); printf(\"}\\n\");\n  printf(\"%lld\\n\", ans);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) {\n    scanf(\"%d%d\", l + i, r + i);\n  }\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\n// 三分探索\ntemplate<typename T, typename F>\npair<T, T> tsearch(T lower, T upper, ll max_loop, F f) {\n\tREP(_, max_loop) {\n\t\tT nl = (lower * 2 + upper) / 3;\n\t\tT nu = (lower + upper * 2) / 3;\n\t\tif (f(nl) < f(nu)) { // 最小値探索の場合は < にする\n\t\t\tupper = nu;\n\t\t} else {\n\t\t\tlower = nl;\n\t\t}\n\t}\n\n\treturn{ lower, upper };\n}\n\n\nint main() {\n\t#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n\t#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n; cin >> n;\n\tvl l(n), r(n); REP(i, n) cin >> l[i] >> r[i];\n\tll ans = TEN(15);\n\tauto lu = tsearch<ll>(0, TEN(9) + 1, 300, [&](ll x) {\n\t\tll cost = abs(l[0] - x);\n\t\tFOR(i, 1, n) {\n\t\t\tif (x > r[i]) {\n\t\t\t\tll c = x - r[i];\n\t\t\t\tcost += c;\n\t\t\t\tx = l[i] + c;\n\t\t\t} else if (x + (r[i - 1] - l[i - 1]) < l[i]) {\n\t\t\t\tll c = l[i] - (x + (r[i - 1] - l[i - 1]));\n\t\t\t\tcost += c;\n\t\t\t\tx = l[i] - c;\n\t\t\t} else {\n\t\t\t\tx = l[i];\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cost);\n\t\treturn cost;\n\t});\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#define int long long\nusing namespace std;\n\nconst int MAX = 500;\nconst int INF = 1145141919;\n\nint n;\nint l[400];\nint r[400];\n\nint dp[401][2 * MAX + 1];\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n; if (n > 400) assert(0);\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (r[i] > MAX) {\n\t\t\tassert(0);\n\t\t}\n\t}\n\t\n\tfor (i = 0; i <= n; i++) for (j = 0; j <= 2 * MAX; j++) dp[i][j] = INF;\n\tdp[0][MAX] = 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j <= 2 * MAX; j++) {\n\t\t\tint low, high;\t\t//長方形iの移動量の下界と上界\n\t\t\t\n\t\t\tif (i == 0) {\n\t\t\t\tlow  = -MAX;\n\t\t\t\thigh =  MAX;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow  = (l[i - 1] + j - MAX) - r[i];\n\t\t\t\thigh = (r[i - 1] + j - MAX) - l[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor (k = max(-MAX, low); k <= min(MAX, high); k++) {\n\t\t\t\tdp[i + 1][k + MAX] = min(dp[i + 1][k + MAX], dp[i][j] + abs(k));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= 2 * MAX; j++) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tint ans = INF;\n\tfor (j = 0; j <= 2 * MAX; j++) {\n\t\tans = min(dp[n][j], ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP(a, n) REP(i, n) printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ')\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n\ntypedef long long ll;\n\nconst int N_MAX = 100000;\n\nint N;\nint l[N_MAX];\nint r[N_MAX];\nint w[N_MAX];\n\nset<int> ls, rs;\nint lf, rf;\nll ans;\n\nvoid solve() {\n  REP(i, N) w[i] = r[i] - l[i];\n  ls.insert(l[0]); rs.insert(l[0]);\n  ans = 0;\n  lf = rf = 0;\n  FOR(i, 1, N - 1) {\n    // printf(\"ls: {\"); ITR(ls, it) printf(\"%d, \", *it + lf); printf(\"}\\n\");\n    // printf(\"rs: {\"); ITR(rs, it) printf(\"%d, \", *it + rf); printf(\"}\\n\");\n    lf -= w[i]; rf += w[i - 1];\n    int le = *ls.rbegin() + lf;\n    int re = *rs.begin() + rf;\n    int l3 = l[i];\n    // printf(\"i: %d, e: (%d, %d), l3: %d\\n\", i, le, re, l3);\n    if (l3 > re) {\n      rs.erase(re - rf);\n      ls.insert(re - lf);\n      rs.insert(l3 - rf);\n      ans += l3 - re;\n      // printf(\"rs->ls: %d, rs << %d, ans += %d\\n\", re, l3, l3 - re);\n    } else if (l3 < le) {\n      ls.erase(le - lf);\n      rs.insert(le - rf);\n      ls.insert(l3 - lf);\n      ans += le - l3;\n      // printf(\"ls->rs: %d, ls << %d, ans += %d\\n\", le, l3, le - l3);\n    } else {\n      ls.insert(l3 - lf);\n      rs.insert(l3 - rf);\n      // printf(\"ls << %d rs << %d, ans += 0\\n\", l3, l3);\n    }\n  }\n  // printf(\"ls: {\"); ITR(ls, it) printf(\"%d, \", *it + lf); printf(\"}\\n\");\n  // printf(\"rs: {\"); ITR(rs, it) printf(\"%d, \", *it + rf); printf(\"}\\n\");\n  printf(\"%lld\\n\", ans);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) {\n    scanf(\"%d%d\", l + i, r + i);\n  }\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 120000\n\nLL n,sl,sr,ans,l[N],r[N],len[N];\npriority_queue<LL> L;\npriority_queue<LL,vector<LL>,greater<LL> > R;\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<=n;++i){scanf(\"%lld%lld\",l+i,r+i); len[i]=r[i]-l[i];}\n\tL.push(r[1]); R.push(r[1]);\n\tfor (LL i=2;i<=n;++i){\n\t\tsl-=len[i-1]; sr+=len[i];\n\t\tLL lp=L.top()+sl,rp=R.top()+sr;\n\t\tif (r[i]>=lp&&r[i]<=rp){\n\t\t\tL.push(r[i]-sl); R.push(r[i]-sr);\n\t\t}\n\t\tif (r[i]>rp){\n\t\t\tans+=r[i]-rp; R.pop(); L.push(rp-sl);\n\t\t\tR.push(r[i]-sr); R.push(r[i]-sr);\n\t\t}\n\t\tif (r[i]<lp){\n\t\t\tans+=lp-r[i]; L.pop(); R.push(lp-sr);\n\t\t\tL.push(r[i]-sl); L.push(r[i]-sl);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ll> point;\n#define F first\n#define S second\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n\ntemplate<typename T>\nstatic T randint(T lo, T hi) { return uniform_int_distribution<T>(lo, hi)(rng); }\n\n\nstruct treap\n{\n\tstruct node\n\t{\n\t\tnode *ch[2];\n\t\tll len, slen;\n\t\tint p, maxp, prio, sz, lazy;\n\n\t\tnode(int l, int p) : len(l), slen(l), p(p), maxp(p)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL;\n\t\t\tlazy = 0;\n\t\t\tsz = 1;\n\t\t\tprio = randint(0, (int)2e9);\n\t\t}\n\t} *root;\n\n\tnode* new_node(int l, int p)\n\t{\n\t\treturn new node(l, p);\n\t}\n\n\tint size(node *u)\n\t{\n\t\treturn u ? u->sz : 0;\n\t}\n\n\tint max_p(node *u)\n\t{\n\t\treturn u ? (u->maxp + u->lazy) : (-2e9);\n\t}\n\n\tll s_len(node *u)\n\t{\n\t\treturn u ? u->slen : 0;\n\t}\n\n\tvoid push(node *u)\n\t{\n\t\tif (u && u->lazy != 0)\n\t\t{\n\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\tif (u->ch[i])\n\t\t\t\t\tu->ch[i]->lazy += u->lazy;\n\n\t\t\tu->p += u->lazy;\n\t\t\tu->maxp += u->lazy;\n\t\t\tu->lazy = 0;\n\t\t}\n\t}\n\n\tnode* update(node *u)\n\t{\n\t\tif (u)\n\t\t{\n\t\t\tu->sz = size(u->ch[0]) + size(u->ch[1]) + 1;\n\t\t\tu->maxp = max({ max_p(u->ch[0]), max_p(u->ch[1]), u->p });\n\t\t\tu->slen = s_len(u->ch[0]) + s_len(u->ch[1]) + u->len;\n\t\t}\n\t\treturn u;\n\t}\n\n\tpair<node*, node*> split(node* u, int k)\n\t{// split for the kth first elements\n\t\tpush(u);\n\n\t\tif (!u)\n\t\t\treturn { u, u };\n\n\t\tif (size(u->ch[0]) >= k)\n\t\t{\n\t\t\tauto s = split(u->ch[0], k);\n\t\t\tu->ch[0] = s.second;\n\t\t\treturn { s.first, update(u) };\n\t\t}\n\n\t\tauto s = split(u->ch[1], k - size(u->ch[0]) - 1);\n\t\tu->ch[1] = s.first;\n\t\treturn { update(u), s.second };\n\t}\n\n\tnode* merge(node *u, node *v)\n\t{\n\t\tpush(u), push(v);\n\n\t\tif (!u || !v)\n\t\t\treturn u ? u : v;\n\n\t\tif (u->prio > v->prio)\n\t\t{\n\t\t\tu->ch[1] = merge(u->ch[1], v);\n\t\t\treturn update(u);\n\t\t}\n\n\t\tv->ch[0] = merge(u, v->ch[0]);\n\t\treturn update(v);\n\t}\n\n\tpair<node*, node*> split1(node* u)\n\t{\n\t\tpush(u);\n\n\t\tif (!u)\n\t\t\treturn { u, u };\n\n\t\tif (max(max_p(u->ch[0]), u->p) >= 0)\n\t\t{\n\t\t\tauto s = split1(u->ch[0]);\n\t\t\tu->ch[0] = s.second;\n\t\t\treturn { s.first, update(u) };\n\t\t}\n\n\t\tauto s = split1(u->ch[1]);\n\t\tu->ch[1] = s.first;\n\t\treturn { update(u), s.second };\n\t}\n\n\tpair<node*, node*> split2(node* u, ll k)\n\t{\n\t\tpush(u);\n\n\t\tif (!u)\n\t\t\treturn { u, u };\n\n\t\tif (s_len(u->ch[0]) + u->len >= k)\n\t\t{\n\t\t\tauto s = split2(u->ch[0], k);\n\t\t\tu->ch[0] = s.second;\n\t\t\treturn { s.first, update(u) };\n\t\t}\n\n\t\tauto s = split2(u->ch[1], k - s_len(u->ch[0]) - u->len);\n\t\tu->ch[1] = s.first;\n\t\treturn { update(u), s.second };\n\t}\n\n\tvoid dfs(node *u, ll &x, ll &y)\n\t{\n\t\tif (!u) return;\n\n\t\tpush(u);\n\n\t\tdfs(u->ch[0], x, y);\n\n\t\tif (u->p < 0)\n\t\t{\n\t\t\tx += u->len;\n\t\t\ty += u->len * u->p;\n\t\t}\n\n\t\tdfs(u->ch[1], x, y);\n\t}\n\n\ttreap() : root(NULL) {}\n};\n\nstruct info\n{\n\tll l, o;\n};\n\nint main()\n{\n\t#ifdef DGC\n\t\tfreopen(\"a.txt\", \"r\", stdin);\n\t\t//freopen(\"b.txt\", \"w\", stdout);\n\t#endif\n\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<info> a(n);\n\tfor (auto &i : a)\n\t{\n\t\tcin >> i.o >> i.l;\n\t\ti.l -= i.o;\n\t}\n\n\tll x = 0, y = a[0].o;\n\n\ttreap t;\n\tt.root = t.merge(t.root, t.new_node(a[0].o, -1));\n\tt.root = t.merge(t.root, t.new_node(1e9+5, +1));\n\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tauto s = t.split1(t.root);\n\t\tt.root = t.merge(t.merge(s.first, t.new_node(a[i].l + a[i-1].l, 0)), s.second);\n\n\t\tx -= a[i].l;\n\t\ty += a[i].o - x;\n\n\t\ts = t.split2(t.root, a[i].o - x + 1);\n\t\tauto s2 = t.split(s.second, 1);\n\t\tll l = t.s_len(s.first);\n\t\tif (l < a[i].o - x) s.first = t.merge(s.first, t.new_node(a[i].o - x - l, t.max_p(s2.first)));\n\t\tif (l + s2.first->len > a[i].o - x) s2.second = t.merge(t.new_node(l + s2.first->len - (a[i].o - x), t.max_p(s2.first)), s2.second);\n\t\t--s.first->lazy;\n\t\t++s2.second->lazy;\n\t\tt.root = t.merge(s.first, s2.second);\n\t}\n\n\tt.dfs(t.root, x, y);\n\tcout << y << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nint dp[444][444];\nint l[444], r[444], w[444];\n\nint main(void)\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> l[i] >> r[i];\n\t\tw[i] = r[i] - l[i];\n\t}\n\tfor (int j = 0; j <= 400; ++j)\n\t{\n\t\tdp[0][j] = abs(j - l[0]);\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j <= 400; ++j)\n\t\t{\n\t\t\tdp[i][j] = 114514810;\n\t\t\tfor (int k = 0; k <= 400; ++k)\n\t\t\t{\n\t\t\t\tint cost = 0;\n\t\t\t\tif (k + w[i - 1] < l[i])cost = l[i] - (k - w[i - 1]);\n\t\t\t\tif (l[i] + w[i] < k)cost = k - (l[i] + w[i]);\n\t\t\t\tint can = dp[i - 1][k] + cost;\n\t\t\t\tdp[i][j] = min(dp[i][j], can);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 114514810;\n\tfor (int j = 0; j <= 400; ++j)\n\t{\n\t\tans = min(ans, dp[n - 1][j]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <deque>\n#include <queue>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <utility>\n#include <functional>\nusing namespace std;\n//orz jzm\n#define ll long long\n#define ull unsigned ll\nconst ll PR=19260817;\nconst int N=405;\nint n, l[N], r[N];\nint dp[N][N];\nint main() {\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>n;\n\tif (n>400) {\n\t\tcout<<\"F***!\"<<endl;\n\t\treturn 0;\n\t}\n\tfor (int i=0; i<n; i++) {\n\t\tcin>>l[i]>>r[i];\n\t\tif (l[i]>400||r[i]>400) {\n\t\t\tcout<<\"F***!\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1; i<401; i++) dp[0][i]=abs(l[0]-i);\n\tfor (int i=1; i<n; i++) {\n\t\tfor (int j=0; j<401; j++) {\n\t\t\tdp[i][j]=2000000000;\n\t\t\tfor (int k=max(1, j-r[i-1]+l[i-1]); k<=min(400, j+r[i]-l[i]); k++)\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[i-1][k]+abs(l[i]-j));\n\t\t}\n\t}\n\tint ans=2000000000;\n\tfor (int i=1; i<=400-r[n-1]+l[n-1]; i++)\n\t\tans=min(ans, dp[n-1][i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrey Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#pragma GCC optimize (\"O3\")\n//#define ANDREIKKAA_TOPCODER\n//#define ANDREIKKAA_ALLOCATOR\n#define ANDREIKKAA_CLASS Solution\n#define ANDREIKKAA_METHOD solve\n#define ANDREIKKAA_PARAMETERS void\n#define ANDREIKKAA_CALL\n#define ANDREIKKAA_RETURN_TYPE void\n\n#define first x\n#define second y\n#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nconst ld PI = acos(-1);\n\nconst int _ML = 500;\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n\"input.txt\"\n#else\n\"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n\"\"\n#else\n\"\"\n#endif\n;\n\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024LL * 1024LL];\nsize_t _ptr = 0;\ninline void* operator new(size_t _x) { _ptr += _x; return _mem + _ptr - _x; }\ninline void operator delete(void*) { }\n#endif\n\ntemplate<typename T, typename U> inline ostream &operator << (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator >> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const vector<T> &_v) { if (_v.empty()) return _out; _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline istream &operator >> (istream &_in, vector<T> &_v) { for (auto &_i : _v) _in >> _i; return _in; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const set<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const multiset<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T> inline ostream &operator << (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) return _out; _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) _out << ' ' << *_it; return _out; }\ntemplate<typename T, typename U> inline ostream &operator << (ostream &_out, const map<T, U> &_m) { if (_m.empty()) return _out; _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) _out << \", (\" << _it->first << \": \" << _it->second << ')'; return _out; }\ntemplate<typename T, typename U> inline ostream &operator << (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) return _out; _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) _out << \", (\" << _it->first << \": \" << _it->second << ')'; return _out; }\n\n/* ________ CODE ________ */\n\ninline ANDREIKKAA_RETURN_TYPE mainFunction(ANDREIKKAA_PARAMETERS)\n{\n\tint n;\n\tcin >> n;\n\n\tconst int M = 500;\n\tconst int INF = 1000 * 1000;\n\tvector<vector<int>> dp(n + 1, vector<int>(M, INF));\n\n\tvector<pair<int, int>> a(n);\n\tcin >> a;\n\ta.insert(a.begin(), { 0, M });\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\ta[i].y = a[i].y - a[i].x + 1;\n\t}\n\n\tdp[0] = vector<int>(M, 0);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (int j = 0; j < M; ++j)\n\t\t{\n\t\t\tfor (int k = max(0, j - a[i - 1].y); k < min(M, j + a[i].y); ++k)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - a[i].x));\n\t\t\t}\n\t\t}\n\t}\n\tcout << *min_element(all(dp[n])) << endl;\n}\n\n/* ________ CODE ________ */\n\n#if defined(ANDREIKKAA) || !defined(ANDREIKKAA_TOPCODER)\nint main()\n{\n#if defined(ANDREIKKAA)\n\ttime_t _start = clock();\n#endif\n\tif (_inpf[0] != '\\0')\n\t\tassert(freopen(_inpf, \"r\", stdin) != nullptr);\n\tif (_outf[0] != '\\0')\n\t\tassert(freopen(_outf, \"w\", stdout) != nullptr);\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << setprecision(20);\n\t//cout << fixed;\t\n\tmainFunction(ANDREIKKAA_CALL);\n#if defined(ANDREIKKAA)\n\tcerr << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n\twhile (true);\n#endif\n}\n#else\nclass ANDREIKKAA_CLASS { public: ANDREIKKAA_RETURN_TYPE ANDREIKKAA_METHOD(ANDREIKKAA_PARAMETERS) { return mainFunction(ANDREIKKAA_CALL); } };\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing namespace std::chrono;\n\nconst int LIM = 20;\nconst int INF = 1e+9;\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  assert(n <= 400);\n  vector<int> ans(LIM, 0), buf(LIM, INF);\n  vector<pair<int, int>> coords(n);\n  for (int i = 0; i < n; ++i)\n    cin >> coords[i].first >> coords[i].second;\n\n  for (int pl = 0; pl < LIM; ++pl) {\n    ans[pl] = abs(pl - coords[0].first);\n    cerr << ans[pl] << ' ';\n  }\n  cerr << endl;\n\n  for (int i = 1; i < n; ++i) {\n    int l = coords[i].first, r = coords[i].second;\n    int _l = coords[i - 1].first, _r = coords[i - 1].second, _len = _r - _l + 1;\n\n    buf.assign(LIM, INF);\n    for (int pl = 0, pr = r - l; pr < LIM; ++pl, ++pr) {\n      int cost = abs(l - pl);\n      int _min = INF;\n      for (int p = max(pl - _len + 1, 0); p <= pr; ++p)\n        _min = min(_min, ans[p]);\n      cost += _min;\n\n      buf[pl] = cost;\n    }\n\n    swap(buf, ans);\n\n    for (int i = 0; i < LIM; ++i)\n      cerr << ans[i] << ' ';\n    cerr << endl;\n  }\n\n  int res = ans[0];\n  for (int i = 0; i < LIM; ++i)\n    res = min(res, ans[i]);\n  cout << res << endl;\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n),len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0];\n\tint lec = 1, ric = 1;\n\tll my = 0;\n\trep1(i, n - 1) {\n\t\tif (r[i] < ml) {\n\t\t\tmy += ml - r[i];\n\t\t\tif (lec == 1) {\n\t\t\t\tlec = 2; ric = 1;\n\t\t\t\tmr = ml;\n\t\t\t\tml = l[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ml != mr) {\n\t\t\t\t\tmr = ml; ric = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tric++;\n\t\t\t\t}\n\t\t\t\tmr = ml;\n\t\t\t\tlec--;\n\t\t\t}\n\t\t}\n\t\telse if (l[i] > mr+len[i-1]) {\n\t\t\tmy += l[i] - mr - len[i - 1];\n\t\t\tif (ric == 1) {\n\t\t\t\tric = 2, lec = 1;\n\t\t\t\tml = mr; mr = l[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ml != mr) {\n\t\t\t\t\tml = mr; lec = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlec++;\n\t\t\t\t}\n\t\t\t\tric--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ml-len[i] != l[i])lec = 1;\n\t\t\telse lec++;\n\t\t\tif (mr+len[i-1] != l[i])ric = 1;\n\t\t\telse ric++;\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint dp[410][410];\nint l[100010], r[100010];\nint dist[100010];\nint main(void){\n\tcin >> N;\n\trep(i, N) cin >> l[i] >> r[i];\n\trep(i, N) dist[i] = r[i] - l[i];\n\trep(i, 410)rep(j, 410) dp[i][j] = INF;\n\tdp[0][l[0]] = 0;\n\treps(i, 1, N)for (int j = 1; j <= 400; ++j){\n\t\tif(dp[i - 1][j] == INF) continue;\n\t\tfor (int k = max(j - dist[i], 0); k <= min(405, j + dist[i]); ++k){ //左端\n\t\t\tif(l[i] <= k && k <= r[i]){\n\t\t\t\tchmin(dp[i][k], dp[i - 1][j]);\n\t\t\t\t// printf(\"dp[%d][%d] = %d   dp[%d][%d] = %d\\n\",i, k, dp[i][k], i-1, j, dp[i -1][j]);\n\t\t\t}else if(k < l[i]){\n\t\t\t\tchmin(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t\t\t// printf(\"dp[%d][%d] = %d   dp[%d][%d] + %d\\n\",i, k, dp[i][k], i-1, j, abs(l[i]-k));\n\t\t\t}else{\n\t\t\t\tchmin(dp[i][k], dp[i - 1][j] + abs(r[i] - k));\n\t\t\t\t// printf(\"dp[%d][%d] = %d   dp[%d][%d] + %d\\n\",i, k, dp[i][k], i-1, j, abs(r[i]-k));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 410)chmin(ans, dp[N - 1][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// copied from ecnerwala\n#include<bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nconst int MAXN = 1.1e5;\nint N;\nll L[MAXN], R[MAXN];\n \n \nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n \n\tll cost = 0;\n \n\tll lo_shift = 0;\n\tpriority_queue<ll> lo;\n\tll hi_shift = 0;\n\tpriority_queue<ll, vector<ll>, greater<ll>> hi;\n\tlo.push(L[0] - lo_shift);\n\thi.push(L[0] - hi_shift);\n \n\tfor (int i = 1; i < N; i++) {\n\t\tlo_shift -= (R[i] - L[i]);\n\t\thi_shift += (R[i-1] - L[i-1]);\n \n\t\tll vlo = lo.top() + lo_shift;\n\t\tll vhi = hi.top() + hi_shift;\n\t\tif(vlo <= L[i] && L[i] <= vhi) {\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t} else if (vhi < L[i]) {\n\t\t\tcost += L[i] - vhi;\n\t\t\thi.pop();\n\t\t\tlo.push(vhi - lo_shift);\n\t\t\thi.push(L[i] - hi_shift);\n\t\t} else if (L[i] < vlo) {\n\t\t\tcost += vlo - L[i];\n\t\t\tlo.pop();\n\t\t\thi.push(vlo - hi_shift);\n\t\t\tlo.push(L[i] - lo_shift);\n\t\t} else assert(false);\n\t}\n \n\tcout << cost << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, int val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    int p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    int p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 10002;\n\n\nint N;\nll maxR, maxL;\npair<ll, ll> points[MAXN];\nmultiset<ll> memo_r, memo_l;\n\n\nvoid input() {\n  cin >> N;\n  for (int i = 1 ; i <= N ; i++) {\n    cin >> points[i].first >> points[i].second;\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n\n  ll cost = 0;\n  for (int i = 1 ; i <= N ; i++) {\n    if (i > 1) {\n      maxR += points[i-1].second - points[i-1].first;\n      cost -= (points[i-1].second - points[i-1].first) * (i-1);\n    }\n    maxL -= points[i].second - points[i].first;\n    memo_r.insert(points[i].first - maxR);\n    memo_r.insert(points[i].first - maxR);\n    auto it = memo_r.begin();\n    ll val = (*it) + maxR;\n    memo_r.erase(memo_r.begin());\n    memo_l.insert(val-maxL);\n    ll lPos = (*prev(memo_l.end())) + maxL;\n    ll rPos = (*memo_r.begin()) + maxR;\n    if (!memo_l.empty() && lPos > rPos) {\n      memo_l.erase(prev(memo_l.end()));\n      memo_r.erase(memo_r.begin());\n      memo_l.insert(rPos-maxL);\n      memo_r.insert(lPos-maxR);\n    }\n    cost -= points[i].first;\n  }\n\n  for (int i = 1 ; i <= N ; i++) {\n    cost += (*prev(memo_r.end())) + maxR;\n    memo_r.erase(prev(memo_r.end()));\n  }\n\n  cout << cost;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// atcoder arc70\n#include <bits/stdc++.h>\n#define debug 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n/*\nfor every number, find the left and right bound\n*/\n\npriority_queue<ll> l;\npriority_queue<ll, vector<ll>, greater<ll>> r;\n\nll lo = 0;\nll ro = 0;\nvoid printpq(){\n\tvector<ll> temp;\n\tprintf(\"L: \");\n\twhile(!l.empty()){\n\t\ttemp.push_back(l.top());\n\t\tprintf(\"%d \", l.top()-lo);\n\t\tl.pop();\n\t}\n\tprintf(\"\\n\");\n\tfor(auto i : temp) l.push(i);\n\ttemp.clear();\n\tprintf(\"R: \");\n\twhile(!r.empty()){\n\t\ttemp.push_back(r.top());\n\t\tprintf(\"%d \", r.top()+ro);\n\t\tr.pop();\n\t}\n\tfor(auto i : temp) r.push(i);\n\ttemp.clear();\n\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n}\nll n;\nint main(){\n\tif(debug) freopen(\"narrowrectangles.in\", \"r\", stdin);\n\tcin >> n;\n\tll a,b; cin >> a >> b;\n\tl.push(a);\n\tr.push(a);\n\tll prvlen = b-a;\n\tll ans = 0;\n\tfor(ll i = 1; i<n; i++){\n\t\tcin >> a >> b;\n\t\tll len = b-a;\n\t\tlo += len;\n\t\tro += prvlen;\n\t\tif(a <= l.top()-lo){\n\t\t\tans += l.top()-lo -a;\n\t\t\tl.push(a+lo);\n\t\t\tl.push(a+lo);\n\t\t\tr.push(l.top()-lo-ro);\n\t\t\tl.pop();\n\t\t}else if(a >= r.top()+ro){\t\n\t\t\tans +=a-(r.top()+ro);\n\t\t\tr.push(a-ro);\n\t\t\tr.push(a-ro);\n\t\t\tl.push(r.top()+ro+lo);\n\t\t\tr.pop();\n\t\t}else{\n\t\t\tl.push(a+lo);\n\t\t\tr.push(a-ro);\n\t\t}\n\t\tprvlen = len;\n\t\tif(debug) printpq();\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nll n;\nll a[N],b[N],l[N],r[N];\nll sp,tp;\npriority_queue<ll> S;\npriority_queue<ll,vector<ll>,greater<ll> >T;\nll Sf(){ return S.top()+sp; }\nll Tf(){ return T.top()+tp; }\nvoid Sp(ll x){ S.push(x-sp); }\nvoid Tp(ll x){ T.push(x-tp); }\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n    for(int i=1;i<n;i++){\n      a[i]=l[i]-r[i-1];\n      b[i]=r[i]-l[i-1];\n    }\n    ll ans=0;\n    sp=0; Sp(0); Sp(-1e17);\n    tp=0; Tp(0); Tp(+1e17);\n    for(int i=1;i<n;i++){\n      sp-=b[i],tp-=a[i];\n      ll s0=Sf(),t0=Tf();\n      if(s0<=0&&0<=t0){\n\tSp(0); Tp(0);\n      }\n      if(0<s0){\n\tSp(0); Sp(0);\n\tans+=abs(Sf());\n\tTp(Sf()); S.pop();\n      }\n      if(t0<0){\n\tTp(0); Tp(0);\n\tans+=abs(Tf());\n\tSp(Tf()); T.pop();\n      }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF (long long) 1e18//1234567890987654321\n#define INF 1234567890ll\n#define pb push_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos(-1))\n#define MAXN (300006)\n#define MAXK 26\n#define MAXX 15000006\n#define ll long long int \n#define ld long double\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = ss; ii < ee; ii++)\n#define space \" \"\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ((ll)x.size())\n#define ph push\n#define btinpct(x) __builtin_popcountll(x)\n#define p2(x) (1LL<<(x))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nll n, L[MAXN], len[MAXN], ans;\npriority_queue <ll> lefty;\npriority_queue <ll, vector<ll>,greater<ll>> righty;\nll l_shift, r_shift;\nint main()\n{\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n) {\n\t\tll l,r;cin>>l>>r;\n\t\tL[i]=l;len[i]=r-l;\n\t}\n\tlefty.ph(L[0]); righty.ph(L[0]);\n\tFOR(i,1,n) {\n\t\tl_shift += len[i];\n\t\tr_shift += len[i-1];\n\t\tll left_line = lefty.top() - l_shift;\n\t\tll right_line = righty.top() + r_shift;\n\t\tll x=L[i];\n\t\tif(x<left_line) { // throw one from left to right\n\t\t\tlefty.ph(x+l_shift); lefty.ph(x+l_shift);\n\t\t\tans += left_line - x;\n\t\t\trighty.ph(left_line-r_shift); lefty.pop();\n\t\t} else if(x>right_line) { // right to left\n\t\t\trighty.ph(x-r_shift); righty.ph(x-r_shift);\n\t\t\tans += x-right_line;\n\t\t\tlefty.ph(right_line+l_shift); righty.pop();\n\t\t} else {\n\t\t\tlefty.ph(x+l_shift);\n\t\t\trighty.ph(x-r_shift);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nint main() {\n  unsigned N;\n  std::cin >> N;\n  std::vector<std::pair<long long, long long>> lr(N);\n  for (unsigned i = 0; i < N; ++i) {\n    std::cin >> lr[i].first >> lr[i].second;\n  }\n  std::multiset<long long> left;\n  std::multiset<long long> right;\n  long long left_add = 0;\n  long long right_add = 0;\n  long long min = 0;\n  left.insert(lr[0].first);\n  right.insert(lr[0].first);\n  for (unsigned i = 1; i < N; ++i) {\n    right_add += lr[i - 1].second - lr[i - 1].first;\n    left_add -= lr[i].second - lr[i].first;\n    if (*left.rbegin() + left_add > lr[i].first) {\n      min += *left.rbegin() + left_add - lr[i].first;\n      right.insert(*left.rbegin() + left_add - right_add);\n      auto x = left.end();\n      --x;\n      left.erase(x);\n      left.insert(lr[i].first - left_add);\n      left.insert(lr[i].first - left_add);\n    } else if (*right.begin() + right_add < lr[i].first) {\n      min += lr[i].first - (*right.begin() + right_add);\n      left.insert(*right.begin() + right_add - left_add);\n      right.erase(right.begin());\n      right.insert(lr[i].first - right_add);\n      right.insert(lr[i].first - right_add);\n    } else {\n      left.insert(lr[i].first - left_add);\n      right.insert(lr[i].first - right_add);\n    }\n  }\n  std::cout << min;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                //  #define PI 3.14159265358979323846\n                                        #define paa pair<int,char>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn y != p.y ? y<p.y: x<p.x;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            int mod;\n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=mod;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=mod;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%mod;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n            \t\n            }\n          //   cin.tie(0);\n\t\t//\tios::sync_with_stdio(false);\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint l[100020],d[100020];\nmultiset<int> s1,s2;\nsigned main(){\nint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tcin>>l[i]>>d[i];\n\t\td[i]-=l[i];\n\t}\n\t\n\t\n\ts2.insert(l[0]);\n\ts1.insert(l[0]);\n\t\n\tint de=0;\n\tint h=l[0],m=l[0];\n\tint w=0,e=0;\n\tfor(int i=1;i<n;i++){\n\t\tw+=d[i];\n\t\te+=d[i-1];\n\t\t\n\t\t//cout<<h-w<<\" \"<<m+e<<endl;\n\t\tif(h-w>l[i]){\n\t\t\tde+= -l[i]+(h-w); \n\t\t\ts1.insert(l[i]+w);\n\t\t\ts1.insert(l[i]+w);\n\t\t\t\n\t\t\tauto it=s1.end();\n\t\t\tit--;\n\t\t\tint g=*it;\n\t\t\ts1.erase(it);\n\t\t\tg-= w+e;\n\t\t\ts2.insert(g);\n\t\t\tm=g;\n\t\t\tit=s1.end();\n\t\t\tit--;\n\t\t\th=*it;\n\t\t\t\n\t\t}\n\t\telse if(h-w<l[i] && l[i]<m+e){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t\th=l[i]+w;\n\t\t\tm=l[i]-e;\n\t\t\t\n\t\t}\n\t\telse if(l[i]>m+e){\n\t\t\tde+= -(m+e)+l[i]; \n\t\t\ts2.insert(l[i]-e);\n\t\t\ts2.insert(l[i]-e);\n\t\t\t\n\t\t\tauto it=s2.begin();\n\t\t\t\n\t\t\tint g=*it;\n\t\t\ts2.erase(it);\n\t\t\tg+= w+e;\n\t\t\ts1.insert(g);\n\t\t\th=g;\n\t\t\tit=s1.begin();\n\t\t\t\n\t\t\tm=*it;\n\t\t}\n\t\telse{\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t}\n\t\n\t}\n\tcout<<de<<endl;\n\t\n\treturn 0;\n        }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); i++)\n#define DUMP(a, n) REP(i, n) printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ')\n#define ITR(c,it)  for(auto it = c.begin(); it != c.end(); it++)\n\ntypedef long long ll;\n\nconst int N_MAX = 100000;\n\nint N;\nint l[N_MAX];\nint r[N_MAX];\nint w[N_MAX];\n\nmultiset<ll> ls, rs;\nll lf, rf;\nll ans;\n\nvoid dumpDP(int i) {\n  printf(\"i: %d\\n\", i);\n  printf(\"  ls: {\"); ITR(ls, it) if (*it + lf >= 0) printf(\"%lld, \", *it + lf); printf(\"}\\n\");\n  printf(\"  rs: {\"); ITR(rs, it) if (*it + rf <= 1e9)printf(\"%lld, \", *it + rf); printf(\"}\\n\");\n}\n\nvoid erase_one(multiset<ll> &st, ll v) {\n  auto it = st.find(v);\n  if (it != st.end()) st.erase(it);\n}\n\nvoid solve() {\n  REP(i, N) w[i] = r[i] - l[i];\n  ls.insert(l[0]); rs.insert(l[0]);\n  ans = 0;\n  lf = rf = 0;\n  FOR(i, 1, N - 1) {\n    // dumpDP(i);\n    lf -= w[i]; rf += w[i - 1];\n    ll le = *ls.rbegin() + lf;\n    ll re = *rs.begin() + rf;\n    ll l3 = l[i];\n    // printf(\"  e: (%lld, %lld), l3: %lld\\n\", le, re, l3);\n    if (l3 > re) {\n      erase_one(rs, re - rf);\n      ls.insert(re - lf);\n      rs.insert(l3 - rf);\n      rs.insert(l3 - rf);\n      ans += l3 - re;\n      // printf(\"  rs->ls: %lld, rs << %lld, ans += %lld\\n\", re, l3, l3 - re);\n    } else if (l3 < le) {\n      erase_one(ls, le - lf);\n      rs.insert(le - rf);\n      ls.insert(l3 - lf);\n      ls.insert(l3 - lf);\n      ans += le - l3;\n      // printf(\"  ls->rs: %lld, ls << %lld, ans += %lld\\n\", le, l3, le - l3);\n    } else {\n      ls.insert(l3 - lf);\n      rs.insert(l3 - rf);\n      // printf(\"  ls << %lld rs << %lld, ans += 0\\n\", l3, l3);\n    }\n  }\n\n  // dumpDP(N);\n\n  printf(\"%lld\\n\", ans);\n}\n\nvoid input() {\n  scanf(\"%d\", &N);\n  REP(i, N) {\n    scanf(\"%d%d\", l + i, r + i);\n  }\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,sh[2];\npriority_queue<long long> pq[2];\n\nint main()\n{\n\tlong long i,ii,k,l,e,u,w,z=0;\n\t\n\tscanf(\"%lld\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&k,&l);\n\t\tsh[0]+=l-k;\n\t\tif(i)\n\t\t{\n\t\t\tz+=max(pq[0].top()-sh[0]-k,0ll)+max(k+pq[1].top()-sh[1],0ll);\n\t\t}\n\t\te=i&&k>pq[0].top()-sh[0];\n\t\tu=!e*2-1;\n\t\tfor(ii=0;ii<2;ii++)\n\t\t{\n\t\t\tpq[e].push(k*u+sh[e]);\n\t\t}\n\t\tw=(pq[e].top()-sh[e])*u;\n\t\tpq[!e].push(w*-u+sh[!e]);\n\t\tpq[e].pop();\n\t\tsh[1]+=l-k;\n\t}\n\tprintf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n// }}}\n// pre-written code {{{\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\nconst int INF=0x3f3f3f3f;\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\nint N;\nInt l[100010], r[100010];\n\nInt f(Int l0){\n\tInt cost = abs(l0-l[0]);\n\tInt r0 = l0 + r[0] - l[0];\n\tfor(int i=1;i<N;i++){\n\t\tif(r0<l[i]){\n\t\t\tcost+=l[i]-r0;\n\t\t\tl0 = r0;r0 = l0+r[i]-l[i];\n\t\t}else if(r[i]<l0){\n\t\t\tcost+=l0-r[i];\n\t\t\tr0 = l0;l0 = r0 - (r[i]-l[i]);\n\t\t}else{\n\t\t\tl0 = l[i];r0 = r[i];\n\t\t}\n\t}\n\treturn -cost;\n}\n\npair<Int,Int> find_max(Int a, Int b, Int f(Int)) {\n\tconst long double r = 2 / (3 + sqrt(5));\n\tlong double cd = a + r * (b - a), dd = b - r * (b - a);\n\tInt c = (Int)cd, d = (Int)(dd+1);\n\tInt fc = f(c), fd = f(d);\n//\twhile (d - c > EPS) {\n\twhile (d - c >=10) {\n//\t\tcerr<<\" \"<<a<<\" \"<<c<<\" \"<<d<<\" \"<<b<<endl;\n\t\tif (fc < fd) { // '<': maximum, '>': minimum\n//\t\t\ta = c; c = d; d = (b - r * (b - a));\n\t\t\ta = c; c = d; d = (Int)(b - r * (b - a)+1);\n\t\t\tfc = fd; fd = f(d);\n\t\t} else {\n//\t\t\tb = d; d = c; c = a + r * (b - a);\n\t\t\tb = d; d = c; c = (Int)(a + r * (b - a));\n\t\t\tfd = fc; fc = f(c);\n\t\t}\n\t}\n//\treturn c;\n\treturn {a,b};\n}\n\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>l[i]>>r[i];\n\tInt l = 0, r = 2e+9;\n\tauto p = find_max(l,r,f);\n\tInt ans = 1e+18;\n//\tcerr<<\" \"<<p.first<<\" \"<<p.second<<endl;\n\tfor(Int l = p.first;l<=p.second;l++){\n\t\tans = min(ans,-f(l));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nmultiset<ll> sl,sr;\nll ans,tl,tr,i,j,k,n,a[200001],b[200001];\nll av(ll x){\n\treturn (x>=0)?x:-x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i],&b[i]);\n\tsl.clear();sr.clear();sl.insert(a[1]);sr.insert(a[1]);\n\tfor (i=2,ans=tl=tr=0;i<=n;i++){\n\t\ttl+=b[i]-a[i];tr+=b[i-1]-a[i-1];j=*(sl.rbegin());k=*(sr.begin());\n\t\tif (j-tl>a[i]){\n\t\t\tans+=av(j-tl-a[i]);\n\t\t\tsl.erase(sl.find(j));sl.insert(a[i]+tl);sl.insert(a[i]+tl);sr.insert(j-tl-tr);\n\t\t}else if (a[i]>k+tr){\n\t\t\tans+=av(k+tr-a[i]);\n\t\t\tsr.erase(sr.find(k));sr.insert(a[i]-tr);sr.insert(a[i]-tr);sl.insert(k+tr+tl);\n\t\t}else{\n\t\t\tsl.insert(a[i]+tl);sr.insert(a[i]-tr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 1e5 + 5;\n\ntypedef pair<int,int>   ii;\n\nstruct Dat1 {\n    priority_queue<ll>  pq;\n    ll  shift = 0;\n}   L;\nstruct Dat2 {\n    priority_queue<ll,vector<ll>,greater<ll> >  pq;\n    ll  shift = 0;\n}   R;\n\nint len[N];\nint lef[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        cin >> lef[i];\n        int r;  cin >> r;\n        len[i] = r - lef[i];\n    }\n    L.pq.push(lef[1]);\n    R.pq.push(lef[1]);\n\n    long long ans = 0;\n\n    for(int i = 2 ; i <= n ; ++i)   {\n        L.shift -= len[i];\n        R.shift += len[i - 1];\n\n        ll  optL = L.pq.top() + L.shift;\n        ll  optR = R.pq.top() + R.shift;\n\n        if (lef[i] < optL)  {\n            ans += optL - lef[i];\n            R.pq.push(optL - R.shift);\n            L.pq.pop();\n            L.pq.push(lef[i] - L.shift);\n            L.pq.push(lef[i] - L.shift);\n            continue;\n        }\n        if (lef[i] > optR)  {\n            ans += lef[i] - optR;\n            L.pq.push(optR - L.shift);\n            R.pq.pop();\n            R.pq.push(lef[i] - R.shift);\n            R.pq.push(lef[i] - R.shift);\n            continue;\n        }\n        L.pq.push(lef[i] - L.shift);\n        R.pq.push(lef[i] - R.shift);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\n\nint n, l[401], r[401];\nlong long dp[401][401];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= 400; j++) dp[i][j] = INF;\n\tfor(int j = 1; j <= 400; j++) dp[1][j] = abs(l[1] - j);\n\tfor(int i = 2; i <= n; i++) for(int j = 1; j <= 400; j++) {\n\t\tfor(int k = max(j-r[i-1]+1, 1); k <= min(j+r[i]-1, 400); k++) dp[i][j] = min(dp[i-1][k]+abs(j-l[i]), dp[i][j]);\n\t}\n\tlong long ans = INF;\n\tfor(int j = 1; j <= 400; j++) ans = min(dp[n][j], ans);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<climits>\n#include<sstream>\n#include<deque>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n#define MAX 100010\nint n, l[MAX], r[MAX];\nbool used[MAX];\n\n// j が i と黄砂してる?\nbool inter(int i,int j) {\n  return !( r[j] < l[i] || r[i] < l[j] );\n}\n\nbool inter(int L,int R,int j) {\n  return !( r[j] < L || R < l[j] );\n}\n\nvoid merge(int &L,int &R) {\n  bool update = true;\n  while( update ) {\n    update = false;\n    rep(j,n) {\n      if( !used[j] && inter(L,R,j) ) {\n\tL = min(L,l[j]);\n\tR = max(R,r[j]);\n\tused[j] = true;\n\tupdate = true;\n      }\n    }\n  }\n}\n\nint dist(int L,int R,int j) {\n  if( r[j] < L ) {\n    return L - r[j];\n  } else {\n    assert( R < l[j] );\n    return l[j] - R;\n  }\n}\n\nvoid compute() {\n  int ans = INT_MAX;\n  rep(i,n) {\n    memset(used, false, sizeof used);\n    int cost = 0;\n    int L = l[i], R = r[i];\n    merge(L,R);\n    int next = 0;\n    while( next != -1 ) {\n      next = -1;\n      int d = INT_MAX;\n      rep(j,n) {\n\tif( used[j] ) continue;\n\tif( d == INT_MAX ) d = dist(L,R,j), next = j;\n\telse {\n\t  if( dist(L,R,j) < d ) d = dist(L,R,j), next = j;\n\t}\n      }\n      if( next == -1 ) break;\n      if( next != -1 ) {\n\tused[next] = true;\n\tif( r[next] < L ) {\n\t  int diff = L - r[next];\n\t  cost += diff;\n\t  L = min(L,l[next]+diff);\n\t  R = max(R,r[next]+diff);\n\t} else {\n\t  int diff = l[next] - R;\n\t  cost += diff;\n\t  L = min(L,l[next]-diff);\n\t  R = max(R,r[next]-diff);\n\t}\n\tmerge(L,R);\n      }\n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  bool out = false;\n  cin >> n;\n  if( n > 400 ) out = true;\n  rep(i,n) {\n    cin >> l[i] >> r[i];\n    if( r[i] > 400 ) out = true;\n  }\n  assert( !out );\n  compute();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_bound\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\ninline void Input_Output () {\n\t//freopen(\".in\", \"r\", stdin);\n   //freopen(\".out\", \"w\", stdout);\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 6e5 + 123;                                          \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n \nint n;\nint l[N], r[N];\n\nint main () {\n\tSpeedForce;\n\tcin >> n;\n\tvector < int > pt;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\t\n\n\tint ans = inf;\n\tfor (int x = 1; x <= 400; x++) {\n\t\tll res = 0;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tif (x > r[i]) res += x - r[i];\n\t\t\tif (x < l[i]) res += l[i] - x;\n\t\t} \n\t\tif(ans > res) ans = res;\n\t}\n\n\tcout << ans << '\\n';\n\n\n\n   \treturn Accepted;\n}\n\n// B...a"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint compare(const void *a,const void *b){\nk=*(long*)a;\nt=*(long*)b;\nif(k<t)\nreturn -1;\nelse\nreturn 1;\n}\nint main(){\nint n,i;\nlong l[111111],r[111111],m[222222],p,ans=0;\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++){\nscanf(\"%ld%ld\",&l[i],&r[i]);\nm[i*2]=l[i];\nm[i*2+1]=r[i];\n}\nqsort(m,n*2,sizeof(long),compare);\np=m[n];\nfor(i=0;i<n;i++){\nif(l[i]>p)\nans+=l[i]-p;\nif(r[i]<p)\nans+=p-r[i];\n}\nprintf(\"%ld\",ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst string filename = \"test\";\n\n#define int long long\n\ntypedef pair<int, int> ii;\nconst int infinity = 1e18;\n\nint number;\nii segment[100001];\nint f[401][401];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> number;\n\tfor (int i = 1; i <= number; i++)\n\t\tcin >> segment[i].first >> segment[i].second;\n\tfor (int i = 0; i <= 400; i++)\n\t\tfor (int j = 0; j <= 400; j++)\n\t\t\tf[i][j] = infinity;\n\tfor (int j = 1; j <= 400; j++)\t\n\t{\n\t\tint l = segment[1].first, r = segment[1].second;\n\t\tf[1][j] = max(l - j, j - l);\n\t}\n\tfor (int i = 2; i <= number; i++)\n\t{\n\t\tfor (int j = 1; j <= 400; j++)\n\t\t{\n\t\t\tint l = segment[i].first, r = segment[i].second;\n\t\t\tint cost = max(l - j, j - l);\n\t\t\tint cur_length = r - l;\n\t\t\tint segment_length = segment[i - 1].second - segment[i - 1].first;\n\t\t\tfor (int k = max(1LL, j - cur_length); k <= min(400LL, j + cur_length); k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[i - 1][k] + cost);\n\t\t}\n\t}\n\n\tint answer = infinity;\n\tfor (int i = 1; i <= 400; i++)\n\t\tanswer = min(answer, f[number][i]);\n\tcout << answer;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nll dp[410][410][410];\n\nbool f(int x1, int x2, int y1, int y2) {\n\tif(x1 > x2) {\n\t\tswap(x1, x2);\n\t\tswap(y1, y2);\n\t}\n\treturn x2 <= y1; \n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvi l(n), r(n);\n\tvi w(n);\n\trep(i, n) {\n\t\tcin >> l[i] >> r[i];\n\t\tw[i] = r[i] - l[i];\n\t}\n\tif(n == 1) {\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\trep(i, 410) rep(j, 410) rep(k, 410) dp[i][j][k] = 1e18;\n\tfor(int x = -400; x < 410; x++) {\n\t\tint ll = l[0] + x;\n\t\tint rr = r[0] + x;\n\t\tif(x >= 0 && x <= 410) dp[0][ll][rr] = abs(x);\n\t}\n\tll ans = 1e18;\n\tfor(int i = 0; i < n-1; i++) {\n\t\tfor(int x = -400; x < 410; x++) {\n\t\t\tint ll = l[i+1] + x;\n\t\t\tint rr = r[i+1] + x;\n\t\t\tif(ll < 0 || rr > 400) continue;\n\t\t\tfor(int lll = 0; lll +w[i]< 410; lll++) {\n\t\t\t\tif(f(ll, lll, rr, lll+w[i])){\n\t\t\t\t\tdp[i+1][ll][rr] = min(dp[i+1][ll][rr], dp[i][lll][lll+w[i]]+abs(x));\n\t\t\t\t\tif(i == n -2) ans = min(ans, dp[i+1][ll][rr]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cout << #x << \" = \" << (x) << \"\\n\";\n\nconst int maxn = 400 + 5;\nint n;\nint l[maxn];\nint r[maxn];\nlong long dp[maxn][maxn];\n\nlong long calc(int k, int pos) {\n\tif (k == n) return 0;\n\tlong long& res = dp[k][pos];\n\tif (~res) return res;\n\tres = LINF;\n\tFOR(i, 0, maxn) {\n\t\tif (!(i > pos + r[k - 1] - l[k - 1] || i + r[k] - l[k] < pos)) {\n\t\t\tchkmin(res, calc(k + 1, i) + abs(l[k] - i));\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n;\n\tif (n >= maxn) return;\n\tFOR(i, 0, n) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (l[i] >= maxn || r[i] >= maxn) {\n\t\t\treturn;\n\t\t}\n\t}\n\tms(dp, -1);\n\tlong long ans = LINF;\n\tFOR(i, 0, maxn) {\n\t\tchkmin(ans, calc(1, i) + abs(l[0] - i));\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000 + 5\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, nl, nr, al, ar, ans, l[N], r[N], len[N];\npriority_queue <int> Qs;\npriority_queue <int, vector <int>, greater <int> >  Qb;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n) l[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n    Qs.push(l[1]), Qb.push(l[1]);\n    rep(i, 2, n){\n        al += r[i] - l[i], ar += r[i - 1] - l[i - 1];\n        nl = Qs.top() - al, nr = Qb.top() + ar;\n        if(l[i] < nl) ans += nl - l[i], Qs.pop(), Qs.push(l[i] + al), Qs.push(l[i] + al), Qb.push(nl - ar);\n        else if(l[i] > nr) ans += l[i] - nr, Qb.pop(), Qs.push(nr + al), Qs.push(nr + al), Qb.push(l[i] - ar);\n        else Qs.push(l[i] + al), Qb.push(l[i] - ar);\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link relink\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string &fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 805;\n\nint n, k;\nint l[N], r[N];\nint dp[N][N];\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  l[0] = 0, r[0] = N;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < N; j++) {\n      // current is j,j+r[i]-l[i]\n      dp[i][j] = INF;\n      for (int k = max(0, j - (r[i - 1] - l[i - 1]));\n           k <= min(400, j + r[i] - l[i]); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n      }\n      dp[i][j] += abs(l[i] - j);\n    }\n  }\n\n  cout << *min_element(dp[n], dp[n] + N) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<cmath>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<ctype.h>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<math.h>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<stdio.h>\n#include<stdlib.h>\n#include<streambuf>\n#include<string.h>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#define sz 262143\nusing namespace std;\ntypedef long long LL;\nLL k[200010],b[200010];\nint l[100010],r[100010];\nint cnt;\nmap<int,int> ind,inv;\nint main(void){\n\tset<int> al;\n\tal.insert(0);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tal.insert(l[i]);\n\t\tal.insert(r[i]);\n\t}\n\tfor (set<int>::iterator it=al.begin();it!=al.end();it++){\n\t\tcnt++;\n\t\tind[*it]=cnt;\n\t\tinv[cnt]=*it;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tk[ind[0]]--;\n\t\tb[ind[0]]+=l[i];\n\t\tk[ind[l[i]]]++;\n\t\tb[ind[l[i]]]-=l[i];\n\t\tk[ind[r[i]]]++;\n\t\tb[ind[r[i]]]-=r[i];\n\t}\n\tLL kk=k[ind[0]],bb=b[ind[0]],res=100000000000000000ll;\n\tfor (int i=2;i<=cnt;i++){\n\t\tkk+=k[i];\n\t\tbb+=b[i];\n\t\tres=min(res,kk*inv[i]+bb);\n\t}\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\n#include <random>\n#include <ctime>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nmt19937 mt_rand(time(NULL));\nstruct Treap {\n  int k, p, cnt, lazy;\n  long long sum;\n  Treap *ch[2];\n  Treap(int k) : k(k), sum(k), p(mt_rand()), cnt(1), lazy(0) {\n    ch[0] = ch[1] = NULL;\n  }\n};\ninline int count(Treap *t) { return t == NULL ? 0 : t->cnt; }\ninline long long sum(Treap *t) { return t == NULL ? 0 : t->sum; }\ninline void setLazy(Treap *t, int v) {\n  if (t == NULL) return;\n  t->lazy += v;\n  t->k += v;\n  t->sum += 1LL*v*t->cnt;\n}\ninline void push(Treap *t) {\n  if (t == NULL || t->lazy == 0) return;\n  setLazy(t->ch[0], t->lazy);\n  setLazy(t->ch[1], t->lazy);\n  t->lazy = 0;\n}\ninline Treap* update(Treap *t) {\n  if (t == NULL) return t;\n  push(t);\n  t->cnt = 1 + count(t->ch[0]) + count(t->ch[1]);\n  t->sum = t->k + sum(t->ch[0]) + sum(t->ch[1]);\n  return t;\n}\nTreap *merge(Treap *l, Treap *r) {\n  if (l == NULL) return r;\n  if (r == NULL) return l;\n  if (l->p > r->p) {\n    push(l);\n    l->ch[1] = merge(l->ch[1], r);\n    return update(l);\n  }\n  else {\n    push(r);\n    r->ch[0] = merge(l, r->ch[0]);\n    return update(r);\n  }\n}\npair<Treap*, Treap*> split_by_cnt(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (k <= count(t->ch[0])) {\n    auto s = split_by_cnt(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n  else {\n    auto s = split_by_cnt(t->ch[1], k-1-count(t->ch[0]));\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n}\npair<Treap*, Treap*> split_by_key(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (t->k < k) {\n    auto s = split_by_key(t->ch[1], k);\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n  else {\n    auto s = split_by_key(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n}\n\nint find(Treap *t, int k) {\n  if (t == NULL) return INF;\n  push(t);\n  if (k < count(t->ch[0])) return find(t->ch[0], k);\n  else if (k == count(t->ch[0])) return t->k;\n  else return find(t->ch[1], k-1-count(t->ch[0]));\n}\nTreap *insert(Treap *t, int k) {\n  auto s = split_by_key(t, k);\n  return merge(merge(s._1, new Treap(k)), s._2);\n}\nvoid add_key(Treap *t, int v) { setLazy(t, v); }\n\nvoid print(Treap *t) {\n  if (t == NULL) return;\n  push(t);\n  print(t->ch[0]);\n  cout << t->k<<\",\";\n  print(t->ch[1]);\n}\n\nint N;\nint L[100000], R[100000];\nTreap *S;\nlong long f(int x) {\n  auto s = split_by_key(S, x);\n  long long ret = 1LL*x*count(s._1)-sum(s._1) + sum(s._2)-1LL*x*count(s._2);\n  S = merge(s._1, s._2);\n  return ret;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> L[i] >> R[i];\n  long long C = 0;\n  S = insert(S, L[0]);\n  S = insert(S, L[0]);\n  rep(i, N-1) {\n    int len = R[i+1]-L[i+1] + R[i]-L[i];\n    int shift = R[i]-L[i];\n    auto s = split_by_cnt(S, ((S->cnt-1)/2)+1);\n    add_key(s._1, -len);\n    C -= count(s._1)*len;\n    S = merge(s._1, s._2);\n    add_key(S, shift);\n    S = insert(S, L[i+1]);\n    S = insert(S, L[i+1]);\n    int center = find(S, (S->cnt-1)/2);\n  }\n  int center = find(S, (S->cnt-1)/2);\n  cout << (f(center)+C)/2 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<set>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\ntypedef long long ll;\n//////////////////////\n\nint const N = 1e5 + 41;\n\nint l[N], r[N], n;\nll pref[N];\nint tim;\n\nll getPref(int l, int r){\n\tll ret = pref[r];\n\tif(l > 0) ret -= pref[l-1];\n\treturn ret;\n}\n\nstruct S{\n\tll x, type, time;\n\tS(){};\n\tS(ll x, ll type, ll time) : x(x), type(type), time(time) {};\n\tbool operator<(const S &s) const {\n\t\treturn getX() < s.getX();\n\t};\n\n\tll getX() const {\n\t\tif(type == 0){\n\t\t\treturn x - getPref(time+1, tim);\n\t\t}else{\n\t\t\treturn x + getPref(time, tim-1);\n\t\t}\n\t}\n};\n\nmultiset<S> lp, rp;\n\nll getLast(multiset<S> &ms){\n\tmultiset<S> :: iterator it = ms.end();\n\t--it;\n\treturn ((*it).getX());\n}\n\nll getFirst(multiset<S> &ms){\n\tauto it = ms.begin();\n\treturn (*it).getX();\n}\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n) cin >> l[i] >> r[i];\n\trep(i, 0, n) pref[i] = (r[i] - l[i] + (i > 0 ? pref[i-1] : 0));\n\tll ans = 0;\n\n\tlp.insert(S(l[0], 0, 0));\n\trp.insert(S(l[0], 1, 0));\n\trep(i, 1, n){\n\t\ttim = i;\n\t\tif(l[i] >= getLast(lp) && l[i] <= getFirst(rp)){\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t}else if(l[i] >= getFirst(rp)){\n\t\t\tans += (l[i] - getFirst(rp));\n\t\t\tS tmp = (*rp.begin());\n\t\t\ttmp.type = 0;\n\t\t\ttmp.x = tmp.getX();\n\t\t\ttmp.time = i;\n\t\t\trp.erase(rp.begin());\n\t\t\tlp.insert(tmp);\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t}else{\n\t\t\tans += (getLast(lp) - l[i]);\n\t\t\tauto it = lp.end();\n\t\t\t--it;\n\t\t\tS tmp = (*it);\n\t\t\ttmp.type = 1;\n\t\t\ttmp.x = tmp.getX();\n\t\t\ttmp.time = i;\n\t\t\tlp.erase(it);\n\t\t\trp.insert(tmp);\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\n#define BD 410\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,L[N],R[N],F[N],G[N],len[N];\nint main()\n{\n\tn=read(); if(n>500) assert(0);\n\tfor(int i=1;i<=n;i++)\n\t\tL[i]=read(), R[i]=read();\n\tfor(int i=1;i<=n;i++) if(L[i]>R[i]) swap(L[i],R[i]);\n\tfor(int i=1;i<=n;i++) len[i]=R[i]-L[i];\n\tfor(int i=1;i<=BD;i++) G[i]=fabs(L[1]-i);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tmemset(F,0x3f,sizeof F);\n\t\tfor(int j=1;j<=BD;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=BD;k++)\n\t\t\t{\n\t\t\t\tif(k>j+len[i-1]||k+len[i]<j) continue;\n\t\t\t\telse F[k]=min(F[k],G[j]+abs(L[i]-k));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=BD;i++) G[i]=F[i];\n\t\t//for(int i=1;i<=BD;i++) printf(\"%d \",F[i]); printf(\"\\n\");\n\t}\n\tint Ans=0x3fffffff; for(int i=1;i<=BD;i++) Ans=min(Ans,G[i]);\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\npriority_queue<ll> pq1;\nll bias1, bias2;\npriority_queue<ll,vector<ll>,greater<ll> > pq2;\nll res;\n\nvoid push(ll a, ll b, ll l) {\n    if (l==-1) {\n        pq1.push(a+bias1); pq2.push(a-bias2);\n        return;\n    }\n    bias1 += b-a; bias2 += l;\n    if (a<=pq1.top()-bias1) {\n        res += pq1.top()-bias1-a;\n        pq2.push(pq1.top()-bias1-bias2);\n        pq1.pop();\n        pq1.push(a+bias1);\n        pq1.push(a+bias1);\n    }\n    else if (a<=pq2.top()+bias2) {\n        pq1.push(a+bias1);\n        pq2.push(a-bias2);\n    }\n    else {\n        res += a-pq2.top()-bias2;\n        pq1.push(pq2.top()+bias1+bias2);\n        pq2.pop();\n        pq2.push(a-bias2);\n        pq2.push(a-bias2);\n    }\n}\n\nint main() {\n    int i;\n    scanf(\"%d\",&n);\n    ll l = -1;\n    for (i=0;i<n;i++) {\n        ll a, b;\n        scanf(\"%lld%lld\",&a,&b);\n        push(a,b,l);\n        l = b-a;\n    }\n    printf(\"%lld\\n\",res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[4005][4005];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=1;i<4005;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint l,r;\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tfor(int j=1;j<4005;j++)\n\t\t\t{\n\t\t\t\tif(j<l)\n\t\t\t\tdp[i][j]=l-j+dp[i-1][j];\n\t\t\t\telse if(j>r)\n\t\t\t\tdp[i][j]=j-r+dp[i-1][j];\n\t\t\t\telse \n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<4005;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class G>\nstruct Heap {\n\tint size() const { return (int) hp.size(); }\n\tlong long top() const { return hp.top() + lazy; }\n\tvoid pop() { hp.pop(); }\n\tvoid push(long long x) { hp.push(x - lazy); }\n\n\tlong long lazy = 0;\n\tstd::priority_queue<long long, std::vector<long long>, G> hp;\n\n\tvoid print() {\n\t\tif(hp.empty()) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tstd::cout << hp.top() + lazy << ' ';\n\t\t\tauto v = hp.top();\n\t\t\thp.pop();\n\t\t\tprint();\n\t\t\thp.push(v);\n\t\t}\n\t}\n};\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint n;\n\tstd::cin >> n;\n\tHeap<std::greater<long long>> mn;\n\tHeap<std::less<long long>> mx;\n\tlong long b = 0;\n\tfor(int rep = 0; rep < n; rep++) {\n\t\tlong long l, r;\n\t\tstd::cin >> l >> r;\n\t\tif(rep == 0) {\n\t\t\tmx.push(l);\n\t\t\tmn.push(r);\n\t\t\tb -= r;\n\t\t} else {\n\t\t\t// shift to left\n\t\t\tmx.lazy -= (r - l);\n\t\t\t//std::cout << b << \", first: \"; mx.print(); std::cout << \", \"; mn.print(); std::cout << std::endl;\n\t\t\t// do addition\n\t\t\tif(mn.top() <= l) mn.push(l);\n\t\t\telse mx.push(l);\n\t\t\tif(mx.top() <= l) mn.push(l);\n\t\t\telse mx.push(l);\n\t\t\tb -= l;\n\t\t\twhile(mn.size() > mx.size()) {\n\t\t\t\tmx.push(mn.top());\n\t\t\t\tmn.pop();\n\t\t\t}\n\t\t\twhile(mx.size() > mn.size()) {\n\t\t\t\tmn.push(mx.top());\n\t\t\t\tmx.pop();\n\t\t\t}\n\t\t\t//std::cout << b << \", second: \"; mx.print(); std::cout << \", \"; mn.print(); std::cout << std::endl;\n\t\t\t// do shift to right\n\t\t\tb -= mn.size() * (r - l);\n\t\t\tmn.lazy += (r - l);\n\t\t\t//std::cout << b << \", third: \"; mx.print(); std::cout << \", \"; mn.print(); std::cout << std::endl;\n\t\t}\n\t\t//std::cout << \"after [\" << l << \", \" << r << \"] got b \" << b << '\\n';\n\t}\n\twhile(mn.size()) {\n\t\tb += mn.top();\n\t\tmn.pop();\n\t}\n\tstd::cout << b << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tint len=r[1]-l[1];\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[i]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx;j++){\n\t\t\tf[i][j]=100000000;\n\t\t\tfor(int k=max(1,j-len-len_);k<=min(mx,j+len);k++){\n\t\t\t\tf[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-j)));\n\t\t\t}\n\t\t}\n\t}\n\tans=100000000;\n\tfor(int j=1;j<=mx;j++)ans=min(ans,f[n][j]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 405;\nconst int inf = 2e9;\n\nint dp[N][N];\nint l[N], len[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", l + i, len + i);\n    len[i] -= l[i];\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      dp[i][j] = inf;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    dp[0][i] = abs(i - l[0]);\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = max(0, j-len[i-1]); k <= min(N - 1, j+len[i]); k++) {\n        dp[i][j] = min(dp[i][j], dp[i-1][k] + abs(j - l[i]));\n      }\n    }\n  }\n  int ans = inf;\n  for (int i = 0; i < N; i++) ans = min(ans, dp[n - 1][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define ABS(a) (((a)>0)?(a):(-(a)))\nint n,l[1005],r[1005],dp[1005][1005];\nint main(){\n\tscanf(\"%d\",&n);\n\tint xb,x2,x3,res=1e9;\n\tfor(xb=0;xb<n;xb++) scanf(\"%d%d\",&l[xb],&r[xb]);\n\tif(n==1){\n\t\tprintf(\"0\");\n\t\treturn 0;\n\t}\n\tfor(xb=1;xb<n;xb++){\n\t\tfor(x2=0;x2<1000;x2++){\n\t\t\tint rb=x2+r[xb]-l[xb];\n\t\t\tif(rb>=1000) rb=999;\n\t\t\tdp[xb][x2]=1e9;\n\t\t\tfor(x3=MAX(0,x2+l[xb-1]-r[xb-1]);x3<=rb;x3++){\n\t\t\t\tdp[xb][x2]=MIN(dp[xb][x2],dp[xb-1][x3]+ABS(x3-l[xb-1]));\n\t\t\t}\n\t\t\tif(xb==n-1) res=MIN(res,dp[xb][x2]+ABS(l[xb]-x2));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nsigned main(){\n    int n;\n    cin >> n;\n    assert(n <= 400);\n    vector<int> l(n), r(n);\n    rep(i, 0, n){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--;\n    }\n    int ans = 1e9;\n    rep(i, 0, 400){\n        int sum = 0;\n        rep(j, 0, n){\n            if(r[j] < i) sum += i - r[j];\n            else if(i < l[j]) sum += l[j] - i;\n        }\n        ans = min(ans, sum);\n    }\n    o(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e10\nusing namespace std;\n\nconst int maxn = 210000;\n\nint n;\nmultiset<ll>ql,qr;\nll addL,addR,len,re;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,las=0;i<=n;i++,las=len)\n\t{\n\t\tll l,r; scanf(\"%lld%lld\",&l,&r);\n\t\tlen=r-l;\n\t\tif(i==1)\n\t\t{\n\t\t\tql.insert(-inf); ql.insert(l);\n\t\t\tqr.insert(inf); qr.insert(l);\n\t\t\tcontinue;\n\t\t}\n\t\taddL-=len,addR+=las;\n\t\tll pl=*ql.rbegin()+addL,pr=*qr.begin()+addR;\n\t\tif(l<pl)\n\t\t{\n\t\t\tql.erase(*ql.rbegin());\n\t\t\tql.insert(l-addL); ql.insert(l-addL);\n\t\t\tre+=pl-l;\n\t\t\tqr.insert(pl-addR);\n\t\t}\n\t\telse if(l<=pr)\n\t\t\tql.insert(l-addL),qr.insert(l-addR);\n\t\telse\n\t\t{\n\t\t\tqr.erase(*qr.begin());\n\t\t\tqr.insert(l-addR); qr.insert(l-addR);\n\t\t\tre+=l-pr;\n\t\t\tql.insert(pr-addL);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cout << #x << \" = \" << (x) << \"\\n\";\n\nconst int MAXN = 5e6 + 5;\nint ptr;\nstruct Node {\n\tNode *l, *r, *p;\n\tint size;\n\tlong long key, lz;\n\tint rev;\n\tNode();\n\tvoid clear();\n} mem[MAXN], *nil = (mem + ptr++);\n\nNode::Node() {\n\tclear();\n}\nvoid Node::clear() {\n\tl = r = p = nil;\n\tsize = 1, key = rev = lz = 0;\n}\n\ninline Node* newNode(long long key) {\n\tmem[ptr].clear();\n\tmem[ptr].key = key;\n\treturn mem + (ptr++);\n}\ninline void init() {\n\tptr = 1;\n\tnil->l = nil->r = nil->p = nil;\n\tnil->size = 0;\n}\ninline void normalize(Node*& x) {if (!x) x = nil;}\ninline int isrt(Node* x) {\n\tnormalize(x);\n\treturn x->p == nil || (x->p->l != x && x->p->r != x);\n}\ninline void setchild(Node* p, Node* c, int l) {\n\tnormalize(p), normalize(c);\n\tc->p = p; l ? p->l = c : p->r = c;\n}\ninline void updatelz(Node* x, long long val) {\n\tnormalize(x);\n\tif (x == nil) return;\n\tx->lz += val;\n\tx->key += val;\n}\ninline void pushdown(Node* x) {\n\tnormalize(x);\n\tif (x == nil) return;\n\tNode *u = x->l, *v = x->r;\n\tif (x->rev) {\n\t\tif (u != nil) {swap(u->l, u->r); u->rev ^= 1;}\n\t\tif (v != nil) {swap(v->l, v->r); v->rev ^= 1;}\n\t\tx->rev = 0;\n\t}\n\tif (x->lz) {\n\t\tif (u != nil) updatelz(u, x->lz);\n\t\tif (v != nil) updatelz(v, x->lz);\n\t\tx->lz = 0;\n\t}\n}\ninline void pushup(Node* x) {\n\tnormalize(x);\n\tx->size = x->l->size + x->r->size + 1;\n}\ninline void rotate(Node* x) {\n\tnormalize(x);\n\tNode* y = x->p;\n\tint l = x->p->l == x;\n\tif (!isrt(y)) {\n\t\tsetchild(y->p, x, y->p->l == y);\n\t}\n\telse {\n\t\tx->p = y->p;\n\t}\n\tsetchild(y, l ? x->r : x->l, l);\n\tsetchild(x, y, !l);\n\tpushup(y);\n}\ninline void splay(Node* x) {\n\tnormalize(x);\n\tpushdown(x);\n\twhile (!isrt(x)) {\n\t\tpushdown(x->p->p); pushdown(x->p); pushdown(x);\n\t\tif (!isrt(x->p)) rotate((x->p->l == x) == (x->p->p->l == x->p) ? x->p : x);\n\t\trotate(x);\n\t}\n\tpushup(x);\n}\ninline void insert(Node*& x, long long key) {\n\tnormalize(x);\n\tNode* p = nil;\n\twhile (x != nil) {\n\t\tpushdown(x);\n\t\tp = x;\n\t\tif (x->key < key) x = x->r;\n\t\telse x = x->l;\n\t}\n\tx = newNode(key);\n\tx->p = p;\n\tif (p != nil) {\n\t\tif (p->key < x->key) p->r = x;\n\t\telse p->l = x;\n\t}\n\tsplay(x);\n}\ninline Node* findkey(Node*& x, long long key) {\n\tnormalize(x);\n\twhile (x != nil) {\n\t\tpushdown(x);\n\t\tif (x->key < key) x = x->r;\n\t\telse if (key < x->key) x = x->l;\n\t\telse {\n\t\t\tsplay(x);\n\t\t\treturn x;\n\t\t}\n\t}\n\treturn nil;\n}\ninline Node* findpos(Node*& x, int pos) {\n\tnormalize(x);\n\twhile (1) {\n\t\tpushdown(x);\n\t\tint k = x->l ? x->l->size + 1 : 1;\n\t\tif (pos == k) {\n\t\t\tsplay(x);\n\t\t\treturn x;\n\t\t}\n\t\telse if (pos < k) x = x->l;\n\t\telse {x = x->r; pos -= k;}\n\t}\n\treturn nil;\n}\ninline Node* join(Node* x, Node* y) {\n\tnormalize(x), normalize(y);\n\tx->p = y->p = nil;\n\tif (x == nil) return y;\n\tif (y == nil) return x;\n\tpushdown(y);\n\twhile (1) {\n\t\tpushdown(x);\n\t\tif (x->r == nil) break;\n\t\tx = x->r;\n\t}\n\tsplay(x);\n\tsetchild(x, y, 0);\n\tpushup(x);\n\treturn x;\n}\ninline void erase(Node*& x, long long key) {\n\tnormalize(x);\n\tNode* y = findkey(x, key);\n\ty->l->p = y->r->p = nil;\n\tx = join(y->p, y->r);\n}\ninline void split(Node* x, int pos, Node*& l, Node*& r) {\n\tnormalize(x);\n\tif (!pos) {l = nil; r = x; return;}\n\tNode* y = findpos(x, pos);\n\tif ((r = y->r) != nil) r->p = nil;\n\tif ((l = y) != nil) {l->r = nil; pushup(l);}\n}\ninline void split(Node* x, int l, int r, Node*& y, Node*& z, Node*& t) {\n\tnormalize(x);\n\tsplit(x, l - 1, y, z);\n\tsplit(z, r - l + 1, z, t);\n}\ninline void reverse(Node*& rt, int l, int r) {\n\tnormalize(rt);\n\tNode *x, *y, *z, *t;\n\tsplit(rt, r, t, z);\n\tsplit(t, l - 1, x, y);\n\tif (y) {\n\t\tswap(y->l, y->r);\n\t\ty->rev ^= 1;\n\t}\n\trt = join(join(x, y), z);\n}\ninline void upd(Node*& rt, int l, int r, long long val) {\n\tnormalize(rt);\n\tNode *x, *y, *z;\n\tsplit(rt, l, r, x, y, z);\n\tupdatelz(y, val);\n\trt = join(join(x, y), z);\n}\n\nconst int maxn = 1e5 + 5;\nint n;\nint l[maxn];\nint r[maxn];\nNode* rt;\n\nvoid solve() {\n\tinit();\n\tcin >> n;\n\tFOR(i, 0, n) cin >> l[i] >> r[i];\n\tlong long ans = 0;\n\tint pos = 1;\n\tinsert(rt, l[0]);\n\tinsert(rt, l[0]);\n\tFOR(i, 1, n) {\n\t\tfindpos(rt, pos);\n\t\tlong long x = rt->key + (l[i] - r[i]);\n\t\tupd(rt, 1, pos, l[i] - r[i]);\n\t\tupd(rt, pos + 1, rt->size, r[i - 1] - l[i - 1]);\n\t\tinsert(rt, l[i]);\n\t\tinsert(rt, l[i]);\n\t\tfindpos(rt, ++pos);\n\t\tif (l[i] <= x) {\n\t\t\tlong long y = rt->key;\n\t\t\tans += x - y;\n\t\t\tans += y - l[i];\n\t\t\tassert(l[i] <= y);\n\t\t}\n\t\telse if (l[i] > x) {\n\t\t\tlong long y = rt->key;\n\t\t\tans += l[i] - y;\n\t\t\tassert(l[i] >= y);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst string filename = \"test\";\n\n#define int long long\n\ntypedef pair<int, int> ii;\nconst int infinity = 1e18;\n\nint number;\nii segment[100001];\nint f[401][401];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tfreopen( (filename + \".inp\").c_str(), \"r\", stdin);\n\tfreopen( (filename + \".out\").c_str(), \"w\", stdout);\n\n\tcin >> number;\n\tfor (int i = 1; i <= number; i++)\n\t\tcin >> segment[i].first >> segment[i].second;\n\tfor (int i = 0; i <= 400; i++)\n\t\tfor (int j = 0; j <= 400; j++)\n\t\t\tf[i][j] = infinity;\n\tfor (int j = 1; j <= 400; j++)\t\n\t{\n\t\tint l = segment[1].first, r = segment[1].second;\n\t\tf[1][j] = max(l - j, j - l);\n\t}\n\tfor (int i = 2; i <= number; i++)\n\t{\n\t\tfor (int j = 1; j <= 400; j++)\n\t\t{\n\t\t\tint l = segment[i].first, r = segment[i].second;\n\t\t\tint cost = max(l - j, j - l);\n\t\t\tint cur_length = r - l;\n\t\t\tint segment_length = segment[i - 1].second - segment[i - 1].first;\n\t\t\tfor (int k = max(1LL, j - cur_length); k <= min(400LL, j + cur_length); k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[i - 1][k] + cost);\n\t\t}\n\t}\n\n\tint answer = infinity;\n\tfor (int i = 1; i <= 400; i++)\n\t\tanswer = min(answer, f[number][i]);\n\tcout << answer;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=100010;\nll n,l[MAXN],r[MAXN];\nll ans,suml,sumr;\npriority_queue < ll,vector<ll>,less<ll> > ql;\npriority_queue < ll,vector<ll>,greater<ll> > qr;\nint main () {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t}\n\tql.push(l[1]),qr.push(l[1]);\n\tfor (int i=2;i<=n;i++) {\n\t\tsuml+=r[i]-l[i],sumr+=r[i-1]-l[i-1];\n\t\tll a=ql.top()-suml,b=qr.top()+sumr;\n\t\t//cout << \"        \" << i << \"  \" << a << \"  \" << b << \"  \" << suml << \"  \" << sumr << endl; \n\t\tif (l[i]<a) {\n\t\t\tans+=a-l[i];\n\t\t\tqr.push(a-sumr),ql.push(l[i]+suml),ql.push(l[i]+suml),ql.pop();\n\t\t} else if (a<=l[i]&&l[i]<=b) {\n\t\t\tql.push(l[i]+suml),qr.push(l[i]-sumr);\n\t\t} else {\n\t\t\tans+=l[i]-b;\n\t\t\tql.push(b+suml),qr.push(l[i]-sumr),qr.push(l[i]-sumr),qr.pop();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nint n, dp[405][405];\nstruct rectangle {\n\tint l, r;\n} r[405];\n\nbool cmp(rectangle x, rectangle y) {\n\treturn x.l < y.l;\n}\n\nint abs(int x) {\n\treturn x > 0 ? x : -x;\n}\n\nint min(int x, int y) {\n\treturn x < y ? x : y;\n}\n\nint max(int x, int y) {\n\treturn x > y ? x : y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &r[i].l, &r[i].r);\n\tstd::sort(r, r + n, cmp);\n\tfor (int i = 0; i < n; i++) for (int j = 0; j <= 400; j++) dp[i][j] = 2e9;\n\tfor (int i = 0; i <= 400; i++) dp[0][i] = abs(i - r[0].r);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tfor (int k = max(0, j - r[i].r + r[i].l); k <= j; k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - r[i].r));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 2e9;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[n - 1][i]);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\nmultiset<ll> L, R;\nll xl = 0, xr = 0;\nll res = 0;\n\nvoid slide(ll ld, ll rd){\n  xl += ld;\n  xr += rd;\n}\n\nvoid add(ll v){\n  ll lb = (*L.rbegin()) - xl, rb = (*R.begin()) + xr;\n  if(lb <= v && v <= rb){\n    L.insert(v + xl);\n    R.insert(v - xr);\n  }else if(v > rb){\n    res += (v - rb);\n    R.erase(R.begin());\n    L.insert(rb + xl);\n    R.insert(v - xr);\n    R.insert(v - xr);\n  }else{\n    res += (lb - v);\n    auto itr = L.end(); itr--;\n    L.erase(itr);\n    R.insert(lb - xr);\n    L.insert(v + xl);\n    L.insert(v + xl);\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  vector<ll> l(n), r(n); rep(i, n)cin >> l[i] >> r[i];\n  L.insert(l[0]);\n  R.insert(l[0]);\n  FOR(i, 1, n){\n    slide(r[i] - l[i], r[i-1] - l[i-1]);\n    add(l[i]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\ntypedef long long int64;\nstatic const int MAXN = 1e5 + 5;\n\nint n, l[MAXN], r[MAXN], len[MAXN];\nint64 min;\nint64 dec_offset = 0, inc_offset = 0;\nstd::multiset<int, std::greater<int>> dec;\nstd::multiset<int> inc;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &l[i], &r[i]), len[i] = (r[i] - l[i]);\n\n    dec.insert(l[0]);\n    inc.insert(l[0]);\n    for (int i = 1; i < n; ++i) {\n        dec_offset -= len[i];\n        inc_offset += len[i - 1];\n        int p = l[i];\n        if (p <= *dec.begin() + dec_offset) {\n            min += (*dec.begin() + dec_offset - p);\n            inc.insert(*dec.begin() + dec_offset - inc_offset);\n            dec.erase(dec.begin());\n            dec.insert(p - dec_offset);\n            dec.insert(p - dec_offset);\n        } else if (p >= *inc.begin() + inc_offset) {\n            min += (p - *inc.begin() - inc_offset);\n            dec.insert(*inc.begin() + inc_offset - dec_offset);\n            inc.erase(inc.begin());\n            inc.insert(p - inc_offset);\n            inc.insert(p - inc_offset);\n        } else {\n            dec.insert(p - dec_offset);\n            inc.insert(p - inc_offset);\n        }\n    }\n\n    printf(\"%lld\\n\", min);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n \nstatic int getMinCost(multiset<int> &leftNodes,\n\t\t      multiset<int> &rightNodes,\n\t\t      int curmincost,\n\t\t      int minpos)\n{\n    if (leftNodes.size() == 0) {\n\treturn curmincost;\n    }\n\n    auto ilmax = leftNodes.end();\n    ilmax--;\n    int lmax = *ilmax;\n    auto irmin = rightNodes.begin();\n    int rmin = *irmin;\n    \n    if (lmax <= minpos) {\n\tif (minpos <= rmin) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - rmin + curmincost;\n    } else {\n\treturn lmax - minpos + curmincost;\n    }\n}\n \nint main(void){\n    int n;\n    int mincost;\n    multiset<int> leftNodess[2];\n    multiset<int> rightNodess[2];\n    multiset<int> *lp, *rp;\n    multiset<int> *nlp, *nrp;\n    stringstream st;\n    string line;\n      \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n    lp = &leftNodess[0];\n    nlp = &leftNodess[1];\n    rp = &rightNodess[0];\n    nrp = &rightNodess[1];\n\n    \n    int nl, nr;\n    int l, r;\n    mincost = 0;    \n    for (int i = 0; i < n; i++) {\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> nl >> nr;\n\tif (i >= 1) {\n\t    \n\t    lp = &leftNodess[i % 2];\n\t    nlp = &leftNodess[(i + 1) % 2];\n\t    rp = &rightNodess[i % 2];\n\t    nrp = &rightNodess[(i + 1) % 2];\n\t    mincost = getMinCost(*lp, *rp, mincost, l);\n\n\t    if (lp->size() == 0) {\n\t\tlp->insert(l);\n\t\trp->insert(l);\n\t    } else {\n\t\tauto ilmax = lp->end();\n\t\tilmax--;\n\t\tif (*ilmax <= l) {\n\t\t    auto irmin = rp->begin();\n\t\t    if (l <= *irmin) {\n\t\t\tlp->insert(l);\n\t\t\trp->insert(l);\n\t\t    } else {\n\t\t\trp->insert(l);\n\t\t\trp->insert(l);\n\n\t\t\tlp->insert(*irmin);\n\t\t\trp->erase(irmin);\n\t\t    }\n\t\t} else {\n\t\t    lp->insert(l);\n\t\t    lp->insert(l);\n\n\t\t    rp->insert(*ilmax);\n\t\t    lp->erase(ilmax);\n\t\t}\n\t    }\n\n\t    nlp->clear();\n\t    nrp->clear();\n\t    for (auto &e : *lp) {\n\t\tnlp->insert(e - (nr - nl));\n\t    }\n\t    for (auto &e : *rp) {\n\t\tnrp->insert(e + (r - l));\n\t    }\n#if 0\n\t    for (auto e : *nlp) {\n\t\tcout << e << \" \";\n\t    }\n\t    for (auto e : *nrp) {\n\t\tcout << e << \" \";\n\t    }\t    \n\t    cout << endl;\n#endif\t\n\t}\n\tl = nl;\n\tr = nr;\n    }\n \n    mincost = getMinCost(*nlp, *nrp, mincost, l);\n \n    cout << mincost << endl;\n    return 0;\n \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=100010;\nint n,l[MAXN],r[MAXN];\nll ans,suml,sumr;\npriority_queue < ll,vector<ll>,less<ll> > ql;\npriority_queue < ll,vector<ll>,greater<ll> > qr;\nint main () {\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t}\n\tql.push(l[1]),qr.push(l[1]);\n\tfor (int i=2;i<=n;i++) {\n\t\tsuml+=r[i]-l[i],sumr+=r[i-1]-l[i-1];\n\t\tll a=ql.top()-suml,b=ql.top()+sumr;\n\t\tif (l[i]<a) {\n\t\t\tans+=a-l[i];\n\t\t\tqr.push(a-sumr),ql.push(l[i]+suml),ql.push(l[i]+suml),ql.pop();\n\t\t} else if (a<=l[i]&&l[i]<=b) {\n\t\t\tql.push(l[i]+suml),qr.push(l[i]-sumr);\n\t\t} else {\n\t\t\tans+=l[i]-b;\n\t\t\tql.push(b+suml),qr.push(l[i]-sumr),qr.push(l[i]-sumr),qr.pop();\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nconst int inf = 1ll << 60;\nconst int MAX = 3e4;\nstruct segtree {\n\tint N, dat[2 * MAX];\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++)\n\t\t\tdat[i] = inf;\n\t}\n\t// update k th element\n\tvoid update(int k, int a) {\n\t\tk += N - 1; // leaf\n\t\tdat[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\t// min [a, b)\n\tint query(int a, int b) { return query(a, b, 0, 0, N); }\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return inf;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn min(query(a, b, k * 2 + 1, l, m), query(a, b, k * 2 + 2, m, r));\n\t}\n};\n\nvoid calc() {\n\tint n; cin >> n;\n\tsegtree seg(805);\n\tint pd = 0;\n\trep(i, n) {\n\t\tint l, r; cin >> l >> r;\n\t\tint d = r - l;\n\t\tV next(805);\n\t\trep(to, 801) {\n\t\t\tint m;\n\t\t\tm = i == 0 ? 0 : seg.query(to - pd, to + d + 1);\n\t\t\tnext[to] = m + abs(to - l);\n\t\t}\n\t\trep(to, 801) {\n\t\t\tseg.update(to, next[to]);\n\t\t}\n\t\tpd = d;\n\t}\n\tcout << seg.query(0, 801) << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcalc();\n#ifdef _MSC_VER\n\tsystem(\"pause\");\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nsigned main() {\n    fio();\n    \n    int n;\n    cin >> n;\n\n    vl l(n), r(n);\n    rep (i, n) cin >> l[i] >> r[i];\n\n    multiset<ll, greater<ll>> left;\n    multiset<ll> right;\n    ll bottom = 0;\n    ll cl = l[0], cr = l[0];\n    ll d1 = 0, d2 = 0;\n\n    for (int i = 1; i < n; i++) {\n        d1 += r[i] - l[i];\n        d2 += r[i - 1] - l[i - 1];\n        cl -= (r[i] - l[i]);\n        cr += (r[i - 1] - l[i - 1]);\n        if (l[i] <= cl) {\n            left.insert(l[i] + d1);\n            left.insert(l[i] + d1);\n            bottom += cl - l[i];\n            right.insert(cr - d2);\n            cr = cl;\n            auto itr = left.begin();\n            cl = *itr - d1;\n            left.erase(itr);\n        }\n        else if (l[i] >= cr) {\n            right.insert(l[i] - d2);\n            right.insert(l[i] - d2);\n            bottom += l[i] - cr;\n            left.insert(cl + d1);\n            cl = cr;\n            auto itr = right.begin();\n            cr = *itr + d2;\n            right.erase(itr);\n        }\n        else {\n            left.insert(cl + d1);\n            right.insert(cr - d2);\n            cl = cr = l[i];\n        }\n\n        // DEBUG(pll(d1, d2));\n        // DEBUG(\"left\");\n        // for (auto itr = left.begin(); itr != left.end(); itr++) {\n        //     DEBUG(*itr);\n        // }\n        // DEBUG(\"right\");\n        // for (auto itr = right.begin(); itr != right.end(); itr++) {\n        //     DEBUG(*itr);\n        // }\n        // DEBUG(pll(cl, cr));\n        // DEBUG(bottom);\n    }\n    cout << bottom << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define fi(a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n////////////////////\n\nint const N = 1e5 + 41;\n\nint n, l[N], r[N];\nmultiset<ll> t0, t1;\nll ans, add0, add1;\n\nll getmin(multiset<ll> &t){\n\tmultiset<ll> :: iterator it = t.begin();\n\treturn (*it);\n}\n\nll extractmin(multiset<ll> &t){\n\tmultiset<ll> :: iterator it = t.begin();\n\tll res = (*it);\n\tt.erase(it);\n\treturn res;\n}\n\nll getmax(multiset<ll> &t){\n\tauto it = t.end();\n\t--it;\n\treturn (*it);\n}\n\nll extractmax(multiset<ll> &t){\n\tauto it = t.end();\n\t--it;\n\tll res = (*it);\n\tt.erase(it);\n\treturn res;\n}\n\nvoid solve(){\n\tt0.insert(l[0]);\n\tt1.insert(l[0]);\n\tfi(1, n){\n\t\tadd0 += -(r[i] - l[i]);\n\t\tadd1 += (r[i-1] - l[i-1]);\n\t\tll x0 = add0 + getmax(t0);\n\t\tll x1 = add1 + getmin(t1);\n\t\tif(x0 <= l[i] && l[i] <= x1){\n\t\t\tt0.insert(l[i] - add0);\n\t\t\tt1.insert(l[i] - add1);\n\t\t}else{\n\t\t\tif(l[i] < x0){\n\t\t\t\tans += x0 - l[i];\n\t\t\t\tt0.insert(l[i] - add0);\n\t\t\t\tt0.insert(l[i] - add0);\n\t\t\t\textractmax(t0);\n\t\t\t\tt1.insert(x0 - add1);\n\t\t\t\tt1.insert(x0 - add1);\n\t\t\t}else{\n\t\t\t\tans += l[i] - x1;\n\t\t\t\tt1.insert(l[i] - add1);\n\t\t\t\tt1.insert(l[i] - add1);\n\t\t\t\textractmin(t1);\n\t\t\t\tt0.insert(x1 - add0);\n\t\t\t\tt0.insert(x1 - add0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d\",&n);\n\tfi(0, n) scanf(\"%d %d\",&l[i],&r[i]);\n\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst int MAXN = 400;\nint dp[MAXN+10][MAXN+10];\n\nsigned main() {\n    int N; cin >> N;\n    if(N > MAXN) return 0;\n\n    vector< pair<int, int> > segs(N);\n    for(int i=0; i<N; i++) {\n        cin >> segs[i].first >> segs[i].second;\n    }\n\n    fill(dp[1], dp[MAXN+1], INF);\n    for(int i=0; i<=MAXN; i++) {\n        dp[1][i] = abs(segs[0].first - i);\n    }\n\n    for(int i=1; i<N; i++) {\n        int len = segs[i].second - segs[i].first;\n        for(int l=0; l<=MAXN; l++) {\n            int r = l + segs[i-1].second - segs[i-1].first;\n            int lb = max(0LL, l - len);\n            int ub = min(MAXN, r);\n\n            for(int k=lb; k<=ub; k++) {\n                int cost = abs(k - segs[i].first);\n                dp[i+1][k] = min(dp[i+1][k], dp[i][l] + cost);\n            }\n        }\n    }\n    \n    int ans = INF;\n    for(int i=0; i<=MAXN; i++) {\n        if(dp[N][i] == INF) continue;\n        // fprintf(stderr, \"dp[N][%lld] = %lld\\n\", i, dp[N][i]);\n        ans = min(ans, dp[N][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nint dp[410][410];\nvoid push(deque<PII>& q, int i, int x){\n  while(!q.empty() && q.back().SS >= x)\n\tq.pop_back();\n  q.push_back(MP(i,x));\n}\nvoid pop(deque<PII>& q, int b){\n  while(!q.empty() && q.front().FF <= b)\n\tq.pop_front();\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<PII> xs(N);\n  VI ws(N);\n  REP(i,N){\n\tcin >> xs[i];\n\tws[i] = xs[i].SS - xs[i].FF;\n  }\n\n  fill((int*)dp, (int*)dp+410*410, INF);\n  REP(x,401)\n\tdp[0][x] = abs(x - xs[0].FF);\n\n  FOR(i,1,N){\n\tdeque<PII> q;\n\tfor(int x=0;x<=ws[i]&&x<410;++x)\n\t  push(q, i, dp[i-1][x]);\n\n\tfor(int x=0;x<410;++x){\n\t  if(x+ws[i] < 410)\n\t\tpush(q, x+ws[i], dp[i-1][x+ws[i]]);\n\t  dp[i][x] = abs(x - xs[i].FF) + q.front().SS;\n\t  pop(q, x-ws[i-1]);\n\t}\n  }\n\n  cout << *min_element(ALL(dp[N-1])) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\n\nint N;\nll L[MAXN], R[MAXN];\n\npriority_queue<ll> lq;\npriority_queue<ll,vector<ll>,greater<ll>> rq;\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> L[i] >> R[i];\n\n    ll ans = 0;\n    ll lq_shift = 0, rq_shift = 0;\n\n    lq.push(L[0]);\n    rq.push(L[0]);\n\n    for (int i = 1; i < N; i++)\n    {\n        rq_shift += R[i-1] - L[i-1];\n        lq_shift -= R[i] - L[i];\n\n        ll ltop = lq.top() + lq_shift;\n        ll rtop = rq.top() + rq_shift;\n        if (L[i] < ltop)\n        {\n            ans += abs (ltop - L[i]);\n            lq.pop();\n            rq.push(ltop-rq_shift);\n            lq.push(L[i]-lq_shift);\n            lq.push(L[i]-lq_shift);\n        }\n        else if (L[i] > rtop)\n        {\n            ans += abs (rtop - L[i]);\n            rq.pop();\n            lq.push(rtop-lq_shift);\n            rq.push(L[i]-rq_shift);\n            rq.push(L[i]-rq_shift);\n        }\n        else\n        {\n            lq.push(L[i]-lq_shift);\n            rq.push(L[i]-rq_shift);\n        }\n    }\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a, b) for(int i=a;i<b;++i)\n#define fj(a, b) for(int j=a;j<b;++j)\n#define fk(a, b) for(int k=a;k<b;++k)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n////////////////\n\nint const N = 441;\nint const INF = 1e9 + 41;\n\nint dp[N][N];\nint n;\nint l[N], r[N];\n\nbool good(int l1, int r1, int l2, int r2){\n\tint l = max(l1, l2);\n\tint r = min(r1, r2);\n\treturn (l <= r);\n}\n\nvoid solve(){\n\tscanf(\"%d\",&n);\n\tfi(1, n+1){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\t\n\t}\n\n\tfi(1, n+1){\n\t\tfj(0, N) dp[i][j] = INF;\n\t\tfj(1, N){\n\t\t\tfk(1, N){\n\t\t\t\tif(good(k, k + (r[i] - l[i]), j, j + (r[i-1] - l[i-1])))\n\t\t\t\t\tdp[i][k] = min(dp[i-1][j] + abs(l[i] - k), dp[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfi(1, N){\n\t\tans = min(ans, dp[n][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1ll<<56)\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,l,r,tl,tr,L,R,len,ans;\npriority_queue <ll> q1;\npriority_queue <ll, vector<ll>, greater<ll> > q2;\nint main()\n{\n\tn=read(); while(n--)\n\t{\n\t\tl=read(); r=read(); len=r-l;\n\t\ttr+=len;\n\t\tq1.push(r-tl); q2.push(r-tr);\n\t\twhile((L=q1.top()+tl)>(R=q2.top()+tr))\n\t\t{\n\t\t\tans+=L-R;\n\t\t\tq1.pop(); q2.pop();\n\t\t\tq1.push(R-tl); q2.push(L-tr);\n\t\t}\n\t\ttl-=len;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tvint a(n);\n\tvint b(n);\n\tvint c(n);\n\tassert(n<=400);\n\trep(i,n){\n\t\tcin>>a[i]>>b[i];\n\t\tassert(b[i]<=400);\n\t\ta[i]--,b[i]--;\n\t\tc[i] = b[i]-a[i];\n\t}\n\tvint dp(500);\n\trep(i,n){\n\t\tif(!i){\n\t\t\tdp[i] = abs(i - a[i]);\n\t\t}\n\t\telse{\n\t\t\tvint next(500,INF);\n\t\t\trep(j,500){\n\t\t\t\treep(k,j-c[i-1],j+c[i]+1){\n\t\t\t\t\tif(k<0) continue;\n\t\t\t\t\tmins(next[j], dp[k]+abs(a[i]-j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,500) mins(ans, dp[i]);\n\tcout<<ans<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <string>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n#define FORD(i, a, b) for (int i = (a), _b = (b); i >= _b; --i)\n#define REP(i, a) for (int i = 0, _a = (a); i < _a; ++i)\n#define REPD(i,n) for(int i = (n)-1; i >= 0; --i)\n\n#define DEBUG(X) { cerr << #X << \" = \" << (X) << endl; }\n#define PR(A, n) { cerr << #A << \" = \"; FOR(_, 1, n) cerr << A[_] << ' '; cerr << endl; }\n#define PR0(A, n) { cerr << #A << \" = \"; REP(_, n) cerr << A[_] << ' '; cerr << endl; }\n\n#define sqr(x) ((x) * (x))\n#define ll long long\n#define double long double\ntypedef pair<int, int> II;\n#define PI (2 * acos((double)0))\n#define __builtin_popcount __builtin_popcountll\n#define SZ(x) ((int)(x).size())\n#define ALL(a) (a).begin(), (a).end()\n#define MS(a,x) memset(a, x, sizeof(a))\n#define next ackjalscjaowjico\n#define prev ajcsoua0wucckjsl\n#define y1 alkscj9u20cjeijc\n#define left lajcljascjljl\n#define right aucouasocjolkjl\n#define y0 u9cqu3jioajc\n\n#define TWO(X) (1LL<<(X))\n#define CONTAIN(S,X) ((S) & TWO(X))\n\ndouble safe_sqrt(double x) { return sqrt(max((double)0.0, x)); }\nint GI(int& x) { return scanf(\"%lld\", &x); }\n\nconst int MN = 444;\nint n;\npair<int,int> a[MN];\nint f[MN][MN];\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << (fixed) << setprecision(9);\n    while (cin >> n) {\n        FOR(i,1,n) cin >> a[i].first >> a[i].second;\n\n        FOR(i,1,n) {\n            FOR(pos,1,400) f[i][pos] = 1000111000111000111LL;\n\n            int len = a[i].second - a[i].first;\n            FOR(left,1,400-len) {\n                int dist = llabs(a[i].first - left);\n\n                int prev = f[i-1][left];\n                FOR(pos,left+1,left+len) prev = min(prev, f[i-1][pos]);\n\n                FOR(pos,left,left+len) f[i][pos] = min(f[i][pos], prev + dist);\n            }\n        }\n\n        int res = f[n][1];\n        FOR(i,1,400) res = min(res, f[n][i]);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define PII pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define sci(x) scanf(\"%d\",&x)\n#define scs(s) scanf(\"%s\",s)\n#define scc(c) scanf(\"%c\",c)\n#define scd(d) scanf(\"%lf\",&d)\n#define scld(ld) scanf(\"%Lf\",&ld)\nusing namespace std;\n\n//********************************************\n//Error tracking\n#define show(args...) { vector<string> _v = split(#args, ','); err(_v.begin(), args); }\n\nvector<string> split(const string& s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while (getline(ss, x, c))\n        v.emplace_back(x);\n    return move(v);\n}\n\nvoid err(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args>\nvoid err(vector<string>::iterator it, T a, Args... args) {\n    cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << '\\n';\n    err(++it, args...);\n}\n//********************************************\n\nconst int NMAX = 100005;\n\nint n, l[NMAX], r[NMAX];\n\nint main()\n{\n  //  freopen(\"input\",\"r\",stdin);\n  //  freopen(\"output\",\"w\",stdout);\n    cin.sync_with_stdio(false);\n    \n    int i, mn = 1 << 30, mx = 0;\n    cin >> n;\n    for (i = 1; i <= n; i++) \n        {\n            cin >> l[i] >> r[i];\n            mn = min(mn, l[i]);\n            mx = max(mx, r[i]);\n        }\n\n    //fix intersection point\n    int sol = 1 << 30;\n    for (i = mn; i <= mx; i++)\n    {\n        int j, ans = 0;\n        for (j = 1; j <= n; j++)\n        {\n            if (r[j] < i) ans += i - r[j];\n            if (l[j] > i) ans += l[j] - i;\n        }\n\n        sol = min(sol, ans);\n    }\n\n    cout << sol << \"\\n\";\n\n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n), len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0]; ll my = 0;\n\tmultiset<ll> sl, sr;\n\tll adle = 0, adri = 0;\n\trep1(i, n - 1) {\n\t\tml -= len[i]; mr += len[i - 1];\n\t\tif (l[i] < ml) {\n\t\t\tll dif = ml - l[i];\n\t\t\tsl.insert(dif - adle); sl.insert(dif - adle);\n\t\t\tmy += dif;\n\t\t\tsr.insert(- adri);adri += mr - ml;\n\t\t\tmr = ml;\n\t\t\tll nl = *sl.begin(); sl.erase(sl.begin());\n\t\t\tnl += adle;\n\t\t\tml -= nl;\n\t\t\tadle -= nl;\n\t\t}\n\t\telse if (l[i] > mr) {\n\t\t\tll dif = l[i] - mr;\n\t\t\tsr.insert(dif - adri); sr.insert(dif - adri);\n\t\t\tmy += dif;\n\t\t\tsl.insert(- adle); adle += mr - ml;\n\t\t\tml = mr;\n\t\t\tll nr = *sr.begin(); sr.erase(sr.begin());\n\t\t\tnr += adri;\n\t\t\tmr += nr;\n\t\t\tadri -= nr;\n\t\t}\n\t\telse {\n\t\t\tsl.insert(-adle), sr.insert(-adri);\n\t\t\tadle += l[i] - ml; adri += mr - l[i];\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug==\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<60;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-12;};\ntemplate<> inline long double EPS<long double>(){return 1e-12;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> inline T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> inline T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tvector<pair<int,int>> rs(N); cin >> rs;\n\t\t// sort(ALL(rs));\n\n\t\tvector<vector<ll>> dp(N+1,vector<ll>(501,INF<ll>()));\n\t\tfor(int r:range(500)){\n\t\t\tdp[0][r] = abs(rs[0].second - r);\n\t\t}\n\n\t\tfor(int i:range(1,N)){\n\t\t\tfor(int rp:range(500)){\n\t\t\t\tfor(int r:range(500)){\n\t\t\t\t\tint lp = rp-(rs[i-1].second-rs[i-1].first), l = r-(rs[i].second-rs[i].first);\n\t\t\t\t\tif((lp <= l && l <= rp) || (lp <= r && r <= rp)){\n\t\t\t\t\t\tdp[i][r] =  min(dp[i][r],dp[i-1][rp] + abs(rs[i].second - r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll res = INF<ll>();\n\t\tfor(int r:range(500)) res = min(res,dp[N-1][r]);\n\n\t\tcout << res << endl;\n\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 402\n\nlong long int dp[402][402];\n\nint n;\n\nvector < pair<int, int> > v;\n\nbool intersect(pair<int, int> a, pair<int, int> b){\n\tif (a.second < b.first || b.second < a.first){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tv.push_back(make_pair(l, r));\n\t}\n\tfor (int i = 0; i < MAX; i++){\n\t\tdp[0][i] = abs(v[0].first - i);\n\t}\n\tfor (int i = 1; i < v.size(); i++){\n\t\tfor (int j = 0; j < MAX; j++){\n\t\t\tdp[i][j] = LLONG_MAX;\n\t\t\tlong long int cost = abs(v[i].first - j);\n\t\t\tpair<int, int> rng = make_pair(j, j + v[i].second - v[i].first);\n\t\t\tfor (int jj = 0; jj < MAX; jj++){\n\t\t\t\tlong long int nex_cost = cost + dp[i - 1][jj];\n\t\t\t\tpair<int, int> rng2 = make_pair(jj, jj + v[i - 1].second - v[i - 1].first);\n\t\t\t\tif (intersect(rng, rng2)){\n\t\t\t\t\tdp[i][j] = min(dp[i][j], nex_cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = LLONG_MAX;\n\tfor (int j = 0; j < MAX; j++){\n\t\tans = min(ans, dp[v.size() - 1][j]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment (linker, \"/stack:256000000\")\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\n#define fo(a,b,c) for(int a=(b);a<(c);a++)\n#define fd(a,b,c) for(int a=(b);a>=(c);a--)\n#define fi(a) fo(i,0,(a))\n#define fj(a) fo(j,0,(a))\n#define fk(a) fo(k,0,(a))\n#define _(a,b) memset((a),(b),sizeof(a))\n#define __(a) memset((a),0,sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#ifdef _DEBUG\n#define dbg(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#define dbgx(x) {cerr << #x << \" = \" << (x) << endl;}\n#else\n#define dbg(...) {}\n#define dbgx(x) {}\n#endif\n\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\nconst int INF = 1000000000;\nconst lint LINF = 4000000000000000000LL;\nconst double eps = 1e-9;\n\nvoid prepare()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n}\n\nconst int maxn = 100100;\n\nint n;\npii p[maxn], pp[maxn];\nint dp[2][500];\n\nvoid read()\n{\n\tscanf(\"%d\", &n);\n\tfi(n)\n\t\tscanf(\"%d%d\", &p[i].first, &p[i].second);\n}\n\nbool inside(int x, int l, int r)\n{\n\treturn x >= l && x <= r;\n}\n\nint getMove(pii p1, pii p2)\n{\n\tif (inside(p2.first, p1.first, p1.second) ||\n\t\tinside(p2.second, p1.first, p1.second) ||\n\t\tinside(p1.first, p2.first, p2.second) ||\n\t\tinside(p1.second, p2.first, p2.second))\n\t\treturn 0;\n\tif (p2.first > p1.second)\n\t\treturn p1.second - p2.first;\n\tif (p2.second < p1.first)\n\t\treturn p1.first - p2.second;\n\tassert(false);\n}\n\nbool solve()\n{\n\tint cr = 0, nx = 1, plen = 400;\n\tn = min(n, 400);\n\tfi(n)\n\t{\n\t\t_(dp[nx], 63);\n\t\tint len = (p[i].second - p[i].first);\n\t\tfo(j, 1, 401 - len)\n\t\t{\n\t\t\tint cur = INF;\n\t\t\tfo(k, max(1, j - plen), j + len + 1)\n\t\t\t\tcur = min(cur, dp[cr][k]);\n\t\t\tdp[nx][j] = cur + abs(p[i].first - j);\n\t\t}\n\t\tplen = len;\n\t\tswap(cr, nx);\n\t}\n\tint res = INF;\n\tfi(401) if (i)\n\t\tres = min(res, dp[cr][i]);\n\tprintf(\"%d\\n\", res);\n\treturn false;\n}\n\nint main()\n{\n\tprepare();\n\tread();\n\twhile (solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint dp[410][410]; // ibannme hidari\nint l[100010], r[100010];\nint dist[100010];\nint slv(int L, int R, int K){\n\tint mi = INF;\n\treps(i, L, R + 1){\n\t\tchmin(mi, abs(i - K));\n\t}\n\treturn mi;\n}\n\nint main(void){\n\tcin >> N;\n\trep(i, N) cin >> l[i] >> r[i];\n\trep(i, N) dist[i] = r[i] - l[i];\n\trep(i, 410)rep(j, 410) dp[i][j] = INF;\n\treps(i, 1, 401){\n\t\tdp[0][i] = abs(l[0] - i);\n\t}\n\tdp[0][l[0]] = 0;\n\treps(i, 1, N)for (int j = 1; j <= 400; ++j){\n\t\tif(dp[i - 1][j] == INF) continue;\n\t\tfor (int k = 1; k <= 400; ++k){ //左端\n\t\t\tif((k + dist[i]< j) || (dist[i - 1] + j < k)) continue;\n\t\t\tchmin(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t\t// printf(\"dp[%d][%d] = %d, dp[%d][%d](%d) %d\\n\", i, k, dp[i][k], i-1, j, dp[i-1][j], abs(l[i]-k));\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 410)chmin(ans, dp[N - 1][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n#define rep(i,a) for(int i=0; i<a; i++)\n#define rrep(i,a) for(int i=a; i>=0; i--)\n#define rep1(i,a) for(int i=1; i<=a; i++)\n#define cout1(a) cout << a << endl;\n#define cout2(a,b) cout << a << \" \" << b << endl;\n#define cout3(a,b,c) cout << a << \" \" << b << \" \" << c << endl;\n#define cout4(a,b,c,d) cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n#define mem(a,n) memset( a, n, sizeof(a))\n#define all(a) a.begin(),a.end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LLINF = 1e18;\nstatic const double pi = 3.141592653589793;\n\nint N, L[100009], R[100009];\nll dp[1009][1009];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>N;\n    if(N>400) return 0;\n    rep(i,N){ cin>>L[i]>>R[i]; if(L[i]>400||R[i]>400) return 0;}\n    \n    rep(i,401) dp[0][i] = abs(i-L[0]);\n    rep1(i,N-1){\n        rep(j,401){\n            ll mn=LLINF;\n            for(int k=max(0,j-(R[i-1]-L[i-1]));k<=min(400,j+(R[i]-L[i]));k++){\n                mn = min(mn,dp[i-1][k]);\n            }\n            dp[i][j] = abs(j-L[i]) + mn;\n        }\n    }\n    \n    ll ans=LLINF;\n    rep(i,401){\n        ans = min(ans,dp[N-1][i]);\n    }\n    cout1(ans);\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst int MAXN = 400;\nint dp[MAXN+10][MAXN+10];\n\nsigned main() {\n    int N; cin >> N;\n    if(N > MAXN) return 0;\n\n    vector< pair<int, int> > segs(N);\n    for(int i=0; i<N; i++) {\n        cin >> segs[i].first >> segs[i].second;\n    }\n\n    using Pair = pair<int, int>;\n    sort(segs.begin(), segs.end(), [&](Pair lhs, Pair rhs) {\n            if(lhs.first != rhs.first) return lhs.first < rhs.first;\n            else return lhs.second < rhs.second;\n        });\n\n\n    fill(dp[1], dp[MAXN+1], INF);\n    for(int nr=0; nr<=MAXN; nr++) {\n        int len = segs[0].second - segs[0].first;\n        if(nr - len < 0) continue;\n        dp[1][nr] = abs(segs[0].second - nr);\n    }\n    for(int i=1; i<N; i++) {\n        int len = segs[i].second - segs[i].first;\n        for(int pr=0; pr<=MAXN; pr++) {\n            for(int nr=0; nr<=MAXN; nr++) {\n                if(nr - len < 0 or dp[i][pr] == INF) continue;\n                int pl = (i == 0 ? 0 : segs[i-1].first), nl = nr - len;\n                if(pr < nl or nr < pl) continue;\n                \n                int pos = max(nr, pr);\n                int cost = abs(segs[i].first - nl);\n                dp[i+1][pos] = min(dp[i+1][pos], dp[i][pr] + cost);\n            }\n        }\n    }\n\n    int ans = INF;\n    for(int i=0; i<=MAXN; i++) {\n        if(dp[N][i] == INF) continue;\n        // fprintf(stderr, \"dp[N][%lld] = %lld\\n\", i, dp[N][i]);\n        ans = min(ans, dp[N][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\nint n;\nvi l, r;\n\nvoid solve(){\n\tvi length(n);\n\tLoop(i, n) length[i] = r[i] - l[i];\n\t//部分点\n\tvi dp(401, 0), dp2(401, 0);\n\tLoop(i, n) {\n\t\tLoop(j, 401) {\n\t\t\tdp2[j] = abs(j - l[i]);\n\t\t\tif (i > 0) {\n\t\t\t\tint a = max(0, j - length[i - 1]);\n\t\t\t\tint b = min(400, j + length[i]);\n\t\t\t\tint m = INT_MAX;\n\t\t\t\tfor (int k = a; k <= b; ++k) {\n\t\t\t\t\tm = min(m, dp[k]);\n\t\t\t\t}\n\t\t\t\tdp2[j] += m;\n\t\t\t}\n\t\t}\n\t\tdp = dp2;\n\t}\n\tint m = INT_MAX;\n\tLoop(j, 401) {\n\t\tm = min(m, dp[j]);\n\t}\n\tcout << m << endl;\n}\n\nint main() {\n\tcin >> n;\n\tl.resize(n);\n\tr.resize(n);\n\tLoop(i, n) cin >> l[i] >> r[i];\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=1050;\n//ここまでテンプレ\nint main(){\n\tint N;\n\tcin>>N;\n\tvll L,R;\n\tfor(int i=0;i<N;i++){\n\t\tll l,r;\n\t\tcin>>l>>r;\n\t\tL.pb(l);\n\t\tR.pb(r);\n\t}\n\tll Loff=0LL,Roff=0LL;\n\tpriority_queue<ll> LQ;\n\tpriority_queue<ll,vector<ll>,greater<ll>> RQ;\n\tLQ.push(L[0]+Loff);\n\tRQ.push(L[0]+Roff);\n\t//傾きがゼロのところのy座標\n\tll bot=0LL;\n\tfor(int i=1;i<N;i++){\n\t\t//机の幅\n\t\tll NW=R[i]-L[i],RW=R[i-1]-L[i-1];\n\t\t//LQに入ってる全部の要素に、前の机の幅を引く\n\t\tLoff+=NW;\n\t\t//RQに入ってる全部の要素に、今の机の幅を足す\n\t\tRoff-=RW;\n\t\t//左側の点と右側の点\n\t\tll L0=LQ.top()-Loff,R0=RQ.top()-Roff;\n\t\t//現在の机の左端がL0,R0の間にあるとき\n\t\tif(L0<=L[i] && L[i]<=R0){\n\t\t\t//botはそのまま\n\t\t\t//LQ,RQに入れる\n\t\t\tLQ.push(L[i]+Loff);\n\t\t\tRQ.push(L[i]+Roff);\n\t\t}\n\t\t//L0より左にあるとき\n\t\telse if(L[i]<L0){\n\t\t\t//botを増やす\n\t\t\tbot+=L0-L[i];\n\t\t\t//LQの一番前のやつをRQに入れる\n\t\t\tRQ.push(L0+Roff);\n\t\t\t//LQからpopする\n\t\t\tLQ.pop();\n\t\t\t//LQに二つ入れる\n\t\t\tLQ.push(L[i]+Loff);\n\t\t\tLQ.push(L[i]+Loff);\n\t\t}\n\t\t//R0より右にあるとき\n\t\telse{\n\t\t\t//botを増やす\n\t\t\tbot+=L[i]-R0;\n\t\t\t//RQの一番前のやつをLQに入れる\n\t\t\tLQ.push(R0+Loff);\n\t\t\t//RQからpopする\n\t\t\tRQ.pop();\n\t\t\t//RQに二つ入れる\n\t\t\tRQ.push(L[i]+Roff);\n\t\t\tRQ.push(L[i]+Roff);\n\t\t}\n\t}\n\tcout<<bot<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<LL>::iterator sit;\nconst int N = 1e5 + 10;\nconst LL inf = 1e13;\nint l[N], r[N];\nmultiset<LL> s0, s1; LL d0, d1;\nint main() {\n\tint n; scanf(\"%d\",&n);\n\tint l1 = 0;\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tint l2 = r[i] - l[i]; \n\t\tif (i > 1) d0 -= l2, d1 += l1;\n\t\tl1 = l2;\n\t\tLL L, R;\n\t\tif (i > 1) {\n\t\t\tsit it = s0.end(); it--;\n\t\t\tL = *it + d0;\n\t\t\tit = s1.begin();\n\t\t\tR = *it + d1;\n\t\t} else L = 0, R = 0;\n\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\ts0.insert(l[i] - d0), s1.insert(l[i] - d1);\n\t\t} else if (l[i] < L) {\n\t\t\ts0.insert(l[i] - d0), s0.insert(l[i] - d0);\n\t\t\tsit it = s0.end(); it--;\n\t\t\ts1.insert(*it + d0 - d1); s0.erase(it);\n\t\t} else if (l[i] > R) {\n\t\t\ts1.insert(l[i] - d1), s1.insert(l[i] - d1);\n\t\t\tsit it = s1.begin(); \n\t\t\ts0.insert(*it + d1 - d0); s1.erase(it);\n\t\t}\n\t}\n\tLL cur = 0, t = -inf;\n\tdep(i,n,1) cur += l[i] - t, t += r[i] - l[i];\n\tint d = -n; LL tmp = -inf;\n\tfor(sit it = s0.begin(); it != s0.end(); it++)\n\t\tcur += 1LL * d * (*it + d0 - tmp), tmp = *it + d0, d++;\n\tcout <<cur<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-6;\nconst double pi = atan2(0, -1);\n\nstruct Queue\n{\n    stack<pair<int, int> > s1, s2;\n    Queue() {}\n    void push(int x)\n    {\n        if (s1.empty())\n            s1.push({x, x});\n        else\n            s1.push({x, min(s1.top().se, x)});\n    }\n    void pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                int x = s1.top().fi;\n                s1.pop();\n                if (s2.empty())\n                    s2.push({x, x});\n                else\n                    s2.push({x, min(s2.top().se, x)});\n            }\n        }\n        s2.pop();\n    }\n    int get_mi()\n    {\n        int res = inf;\n        if (!s1.empty())\n            res = min(res, s1.top().se);\n        if (!s2.empty())\n            res = min(res, s2.top().se);\n        return res;\n    }\n};\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"arrayop.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //int TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n][2];\n    rep(i, 0, n)\n    {\n        cin >> a[i][0] >> a[i][1];\n        a[i][0]--; a[i][1]--;\n    }\n    int dp[n][400];\n    rep(i, 0, n)\n        rep(j, 0, 400)\n            dp[i][j] = inf;\n    rep(j, a[0][0], a[0][1] + 1)\n        dp[0][j] = j - a[0][0];\n    rep(i, 1, n)\n    {\n        Queue q;\n        rep(j, 0, a[i][1] - a[i][0] + 1)\n            q.push(dp[i - 1][j]);\n        rep(j, 0, 400 - (a[i][1] - a[i][0]))\n        {\n            dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n            if (j - (a[i - 1][1] - a[i - 1][0]) >= 0)\n                q.pop();\n            if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                q.push(dp[i - 1][j + (a[i][1] - a[i][0]) + 1]);\n        }\n    }\n    int ans1 = inf, ans2 = inf;\n    rep(j, 0, 400)\n    {\n        ans1 = min(ans1, dp[0][j]);\n        ans2 = min(ans2, dp[n - 1][j]);\n    }\n    cout << ans1 + ans2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  std::vector< std::pair< lint, lint > > lr(n);\n  std::vector< std::pair< lint, lint > > cd(n);\n  rep(i,0,n) {\n    lint l, r; std::cin >> l >> r;\n    lr.at(i) = {l,r};\n    cd.at(i) = {l + r, r - l};\n  }\n\n  std::multiset< lint > left, right;\n  lint left_geta = 0, right_geta = 0;\n  lint min = 0;\n  auto meld = [&] (lint d) {\n    left_geta -= d;\n    right_geta += d;\n  };\n  auto add_vfn = [&] (lint z) {\n    left.insert(z - left_geta);\n    right.insert(z - right_geta);\n    lint l = *left.rbegin() + left_geta;\n    lint r = *right.begin() + right_geta;\n    assert((r-l) % 2 == 0);\n    if (l > r) {\n      min += l - r;\n      left.erase(std::prev(left.end()));\n      right.erase(right.begin());\n      left.insert(r - right_geta - left_geta);\n      right.insert(l - left_geta - right_geta);\n    }\n    l = *left.rbegin() + left_geta;\n    r = *right.begin() + right_geta;\n    assert(l <= r);\n  };\n  lint prv = 0;\n  for (auto&& pair : cd) {\n    lint c, d; std::tie(c, d) = pair;\n    meld(prv + d);\n    add_vfn(c);\n    assert(left.size() == right.size());\n    prv = d;\n  }\n  assert(min % 2 == 0);\n  lint ans = min / 2;\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  std::vector< std::pair< lint, lint > > lr(n);\n  std::vector< std::pair< lint, lint > > cd(n);\n  rep(i,0,n) {\n    lint l, r; std::cin >> l >> r;\n    lr.at(i) = {l,r};\n    cd.at(i) = {l + r, r - l};\n  }\n\n  std::priority_queue< lint > A;\n  std::priority_queue< lint, std::vector< lint >, std::greater< lint > > B;\n  lint addA = 0, addB = 0;\n  lint min = 0;\n  auto meld = [&] (lint d) {\n    addA -= d;\n    addB += d;\n  };\n  auto add_vfn = [&] (lint x) {\n    if (A.empty()) {\n      A.push(x - addA);\n      B.push(x - addB);\n      return ;\n    }\n    lint a = A.top() + addA;\n    lint b = B.top() + addB;\n    if (x <= a) {\n      min += a - x;\n      A.push(x - addA);\n      A.push(x - addA);\n      lint y = A.top() - addA; A.pop();\n      B.push(y - addB);\n    } else if (b <= x) {\n      min += x - b;\n      B.push(x - addB);\n      B.push(x - addB);\n      lint y = B.top() - addB; B.pop();\n      A.push(y - addA);\n    } else {\n      A.push(x - addA);\n      B.push(x - addB);\n    }\n  };\n  lint prv = 0;\n  for (auto&& pair : cd) {\n    lint c, d; std::tie(c, d) = pair;\n    meld(prv + d);\n    add_vfn(c);\n    assert(A.size() == B.size());\n    prv = d;\n  }\n  assert(min % 2 == 0);\n  lint ans = min / 2;\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst int mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nint n;\nint l[405],r[405];\n\nint main(){\n    cin >> n;\n    if (n>400) return 0;\n    rep(i,n) cin >> l[i] >> r[i];\n    vvvi dp(405,vvi(405,vi(405,INF)));\n    rep2(j,1,401){\n        int w=r[0]-l[0];\n        if (j+w>400) break;\n        dp[1][j][j+w]=abs(l[0]-j);\n    }\n    rep2(i,1,n)rep(j,401)rep(k,401){\n        int w=r[i]-l[i];\n        if (k<l[i]){\n            dp[i+1][k][k+w]=min(dp[i+1][k][k+w],dp[i][j][k]+l[i]-k);\n        }\n        else if (r[i]<j){\n            dp[i+1][j-w][j]=min(dp[i+1][j-w][j],dp[i][j][k]+j-r[i]);\n        }\n        else{\n            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n        }\n    }\n    int ans=INF;\n    int w=r[n-1]-l[n-1];\n    rep(j,400){\n        if (j+w>400) break;\n        ans=min(ans,dp[n][j][j+w]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,l,r,a,b,ans=0,p,q;\npriority_queue<int> L;\npriority_queue<int,vector<int>,greater<int>> R;\nvoid pushL(int x){L.push(x-a);}\nvoid pushR(int x){R.push(x-b);}\nint topL(){return p=L.top()+a;}\nint topR(){return q=R.top()+b;}\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\twhile(n--)\n\t{\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\tint len=r-l;\n\t\tb+=len;\n\t\tpushL(r);pushR(r);\n\t\twhile(topL()>topR())\n\t\t{\n\t\t\tans+=p-q;\n\t\t\tL.pop();R.pop();\n\t\t\tpushL(q);pushR(p);\n\t\t}\n\t\ta-=len;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <string.h>\n#include <memory.h>\n#include <stdio.h>\n#include <complex>\n#include <cstdlib>\n#include <sstream>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include<deque>\ntypedef long long ll;\nusing namespace std;\nconst int N = 1000 ;\nint n;\nint l[N], r[N];\nll dp[N][N];\nll calc(int idx, int s) {\n\tif(idx == n)\n\t\treturn 0;\n\tll &ret = dp[idx][s];\n\tif (ret != -1)\n\t\treturn ret;\n\tint len = (r[idx] - l[idx] + 1);\n\tint e = min(402 - len, s + (r[idx - 1] - l[idx - 1]));\n\tret = 1e15;\n\tfor (int i = max(1,s-len+1); i <= e; ++i)\n\t\tret = min(ret, calc(idx + 1, i) + abs(i - l[idx]));\n\treturn ret;\n}\n\n\nint main() {\n\t//freopen(\"myfile.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(\"%d%d\", l + i, r + i);\n\tif (n == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tll ans = 1e15;\n\n\tint len = (r[0] - l[0] +1);\n\tfor (int i = 1; i <= 402-len; ++i)\n\t\tans = min(ans, calc(1, i) + abs(i - l[0]));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[500][500];\n#define S 400\nint main() {\n  int l, r, n;\n  scanf(\"%d\", &n);\n  int lastw = S;\n  memset(dp, 1, sizeof dp);\n  for (int i = 0; i <= 400; i++) {\n    dp[0][i] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d %d\", &l, &r);\n    for (int j = r - l; j <= S; j++) {\n      for (int k = j - (r - l); k <= min(S, j + lastw); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(r - j));\n      }\n    }\n    lastw = r - l;\n  }\n  int ans = 9999999;\n  for (int i = 0; i <= S; i++) {\n    ans = min(ans, dp[n][i]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF=1e9+7;\nint l[405],r[405];\nint dp[405][405];\nint ABS(int x){\n\treturn x<0?-x:x;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep1(k,n)scanf(\"%d%d\",&l[k],&r[k]);\n\trep1(k,n){\n\t\trep1(i,400)dp[k][i]=INF;\n\t\trep1(i,400-(r[k]-l[k])){\n\t\t\tfor(int j=max(i-(r[k-1]-l[k-1]),1);j<=i+(r[k]-l[k]);j++)\n\t\t\tdp[k][i]=min(dp[k][i],dp[k-1][j]+ABS(l[k]-i));\n\t\t}\n\t}\n\tint ans=INF;\n\trep1(k,400-(r[n]-l[n]))ans=min(ans,dp[n][k]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <string>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n#define FORD(i, a, b) for (int i = (a), _b = (b); i >= _b; --i)\n#define REP(i, a) for (int i = 0, _a = (a); i < _a; ++i)\n#define REPD(i,n) for(int i = (n)-1; i >= 0; --i)\n\n#define DEBUG(X) { cerr << #X << \" = \" << (X) << endl; }\n#define PR(A, n) { cerr << #A << \" = \"; FOR(_, 1, n) cerr << A[_] << ' '; cerr << endl; }\n#define PR0(A, n) { cerr << #A << \" = \"; REP(_, n) cerr << A[_] << ' '; cerr << endl; }\n\n#define sqr(x) ((x) * (x))\n#define ll long long\n#define double long double\ntypedef pair<int, int> II;\n#define PI (2 * acos((double)0))\n#define __builtin_popcount __builtin_popcountll\n#define SZ(x) ((int)(x).size())\n#define ALL(a) (a).begin(), (a).end()\n#define MS(a,x) memset(a, x, sizeof(a))\n#define next ackjalscjaowjico\n#define prev ajcsoua0wucckjsl\n#define y1 alkscj9u20cjeijc\n#define left lajcljascjljl\n#define right aucouasocjolkjl\n#define y0 u9cqu3jioajc\n\n#define TWO(X) (1LL<<(X))\n#define CONTAIN(S,X) ((S) & TWO(X))\n\ndouble safe_sqrt(double x) { return sqrt(max((double)0.0, x)); }\nint GI(int& x) { return scanf(\"%lld\", &x); }\n\nconst int MN = 1011;\nint n;\npair<int,int> a[MN];\nint f[MN][MN];\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << (fixed) << setprecision(9);\n    while (cin >> n) {\n        FOR(i,1,n) cin >> a[i].first >> a[i].second;\n\n        FOR(i,1,n) {\n            FOR(pos,1,400) f[i][pos] = f[i-1][pos];\n\n            FOR(pos,1,a[i].first-1) f[i][pos] += a[i].first - pos;\n            FOR(pos,a[i].second+1,400) f[i][pos] += pos - a[i].second;\n        }\n\n        int res = f[n][1];\n        FOR(i,1,400) res = min(res, f[n][i]);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<set>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\ntypedef long long ll;\n//////////////////////\n\nint const N = 1e5 + 41;\n\nint l[N], r[N], n;\nll pref[N];\nint tim;\n\nll getPref(int l, int r){\n\tll ret = pref[r];\n\tif(l > 0) ret -= pref[l-1];\n\treturn ret;\n}\n\nstruct S{\n\tll x, type, time;\n\tS(){};\n\tS(ll x, ll type, ll time) : x(x), type(type), time(time) {};\n\tbool operator<(const S &s) const {\n\t\treturn getX() < s.getX();\n\t};\n\n\tll getX() const {\n\t\tif(type == 0){\n\t\t\treturn x - getPref(time+1, tim);\n\t\t}else{\n\t\t\treturn x + getPref(time, tim-1);\n\t\t}\n\t}\n};\n\nmultiset<S> lp, rp;\n\nll getLast(multiset<S> &ms){\n\tmultiset<S> :: iterator it = ms.end();\n\t--it;\n\treturn ((*it).getX());\n}\n\nll getFirst(multiset<S> &ms){\n\tauto it = ms.begin();\n\treturn (*it).getX();\n}\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n) cin >> l[i] >> r[i];\n\trep(i, 0, n) pref[i] = (r[i] - l[i] + (i > 0 ? pref[i-1] : 0));\n\tll ans = 0;\n\n\tlp.insert(S(l[0], 0, 0));\n\trp.insert(S(l[0], 1, 0));\n\trep(i, 1, n){\n\t\ttim = i;\n\t\tif(l[i] >= getLast(lp) && l[i] <= getFirst(rp)){\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t}else if(l[i] >= getFirst(rp)){\n\t\t\tans += (l[i] - getFirst(rp));\n\t\t\tS tmp = (*rp.begin());\n\t\t\ttmp.x = tmp.getX();\n\t\t\ttmp.type = 0;\n\t\t\ttmp.time = i;\n\t\t\trp.erase(rp.begin());\n\t\t\tlp.insert(tmp);\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t\trp.insert(S(l[i], 1, i));\n\t\t}else{\n\t\t\tans += (getLast(lp) - l[i]);\n\t\t\tauto it = lp.end();\n\t\t\t--it;\n\t\t\tS tmp = (*it);\n\t\t\ttmp.x = tmp.getX();\n\t\t\ttmp.type = 1;\n\t\t\ttmp.time = i;\n\t\t\tlp.erase(it);\n\t\t\trp.insert(tmp);\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t\tlp.insert(S(l[i], 0, i));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,l[N],r[N],addl,addr,ans,l1,l2,lb,rb;\npriority_queue <ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\nsigned main(){\n\tn=read();\n\tF(i,1,n){\n\t\tl[i]=read();r[i]=read();\n\t\tif (i==1){L.push(l[i]);R.push(l[i]);continue;}\n\t\tl2=r[i]-l[i];l1=r[i-1]-l[i-1];\n\t\taddl-=l2;addr+=l1;\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (l[i]<lb){\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.push(l[i]-addl);\n\t\t\tL.push(l[i]-addl);L.pop();\n\t\t}\n\t\telse if (l[i]>rb){\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.push(l[i]-addr);R.push(l[i]-addr);\n\t\t\tR.pop();\n\t\t}\n\t\telse{\n\t\t\tL.push(l[i]-addl);\n\t\t\tR.push(l[i]-addr);\n\t\t}\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N;\nll L[100010],R[100010],len[100010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  rep(i,N){\n    cin>>L[i]>>R[i];\n    len[i]=R[i]-L[i];\n  }\n\n  ll ladd=0,radd=0;\n  multiset<ll> ls,rs;\n  ls.insert(L[0]);\n  rs.insert(L[0]);\n  ll h=0;\n  repl(i,1,N){\n    ll l=*ls.rbegin(),r=*rs.begin();\n    ladd-=len[i];\n    radd+=len[i-1];\n    l+=ladd; r+=radd;\n    if(L[i]<l){\n      ls.insert(L[i]-ladd); ls.insert(L[i]-ladd);\n      ll l1=*ls.rbegin();\n      ls.erase(ls.find(*ls.rbegin()));\n      h+=(l1+ladd)-L[i];\n      rs.insert(l-radd);\n    }else if(L[i]>r){\n      rs.insert(L[i]-radd); rs.insert(L[i]-radd);\n      ll r1=*rs.begin();\n      rs.erase(rs.find(*rs.begin()));\n      h+=L[i]-(r1+radd);\n      ls.insert(r-ladd);\n    }else{\n      ls.insert(L[i]-ladd); rs.insert(L[i]-radd);\n    }\n  }\n\n  cout<<h<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#define ll long long\n#define N 100010\nusing namespace std;\npriority_queue<ll,vector<ll>,less<ll> >lf;\npriority_queue<ll,vector<ll>,greater<ll> >rf;\nll l[N],r[N],len[N];\nll deltl,deltr,L,R,ans;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\tscanf(\"%lld%lld\",&l[i],&r[i]),len[i]=r[i]-l[i];\n\tlf.push(r[1]),rf.push(r[1]);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tdeltl-=len[i-1];\n\t\tdeltr+=len[i];\n\t\tL=lf.top()+deltl;\n\t\tR=rf.top()+deltr;\n\t\tif(r[i]>=L && r[i]<=R)\n\t\t{\n\t\t\tlf.push(r[i]-deltl);\n\t\t\trf.push(r[i]-deltr);\n\t\t}\n\t\telse if(r[i]>R)\n\t\t{\n\t\t\tans+=r[i]-R;\n\t\t\trf.pop();\n\t\t\tlf.push(R-deltl);\n\t\t\trf.push(r[i]-deltr);\n\t\t\trf.push(r[i]-deltr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=L-r[i];\n\t\t\tlf.pop();\n\t\t\trf.push(L-deltr);\n\t\t\tlf.push(r[i]-deltl);\n\t\t\tlf.push(r[i]-deltl);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,l[N],r[N];\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll>> R;\n\nint main() {\n\tfile(road);\n\tn=read();\n\tfor (int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n\tL.push(l[1]),R.push(l[1]); ll addl=0,addr=0,ans=0;\n\tfor (int i=2;i<=n;++i) {\n\t\taddl-=r[i]-l[i],addr+=r[i-1]-l[i-1];\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (lb<=l[i]&&l[i]<=rb) L.push(l[i]-addl),R.push(l[i]-addr);\n\t\telse if (l[i]<lb) {\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.pop(),L.push(l[i]-addl),L.push(l[i]-addl);\n\t\t} else {\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.pop(),R.push(l[i]-addr),R.push(l[i]-addr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int int64_t\n\ntypedef pair<int, int> ii;\nconst int infinity = 1e18;\n\nint number;\nii segment[100001];\nint f[401][401];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> number;\n\tfor (int i = 1; i <= number; i++)\n\t\tcin >> segment[i].first >> segment[i].second;\n\tfor (int i = 0; i <= 400; i++)\n\t\tfor (int j = 0; j <= 400; j++)\n\t\t\tf[i][j] = infinity;\n\tfor (int j = 1; j <= 400; j++)\t\n\t{\n\t\tint l = segment[1].first, r = segment[1].second;\n\t\tf[1][j] = ((l <= j && j <= r) ? 0 : (j < l) ? l - j : j - r);\n\t}\n\tfor (int i = 2; i <= number; i++)\n\t\tfor (int j = 1; j <= 400; j++)\n\t\t{\n\t\t\tint l = segment[i].first, r = segment[i].second;\n\t\t\tint cost = ((l <= j && j <= r) ? 0 : (j < l) ? l - j : j - r);\n\t\t\tint segment_length = r - l + 1;\n\t\t\tfor (int k = max(1LL, l - segment_length); k <= r; k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[i - 1][k] + cost);\n\t\t}\n\n\tint answer = infinity;\n\tfor (int i = 1; i <= 400; i++)\n\t\tanswer = min(answer, f[number][i]);\n\tcout << answer;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n\t> File Name: C.cpp\n\t> Author: Akira\n\t> Mail: qaq.febr2.qaq@gmail.com\n\t> Created Time: 2017年03月18日 星期六 21时37分41秒\n ************************************************************************/\n\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<list>\n#include<ctime>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\n\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*10\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1e9+7;\nconst int eps = 1e-8;\n#define bug cout << 88888888 << endl;\n\nint N;\n\nstruct Line\n{\n    LL l,r;\n    double mid;\n}line[MaxN];\n\nint main()\n{\n    scanf(\"%d\", &N);\n    double sum = 0;\n    for(int i=0;i<N;i++)\n    {\n        scanf(\"%lld%lld\", &line[i].l, &line[i].r);\n        line[i].mid = (line[i].l + line[i].r)/2.0;\n        sum += line[i].mid;\n    }\n    double loc = sum/N;\n    double ans = 0;\n    for(int i=0;i<N;i++)\n    {\n        if(line[i].r < loc) ans += (loc-(double)line[i].r);\n        if(line[i].l > loc) ans += ((double)line[i].l-loc);\n    }\n    printf(\"%.0lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define pb push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nvector<ll> l,r;\n\nint main(){\n    cin >> N;\n    assert(N<=400);\n    l.resize(N);\n    r.resize(N);\n    ll mid=0;\n    rep(i,N){\n        cin >> l[i] >> r[i];\n    }\n\n    ll ans2=LINF;\n    for(int mid=0;mid<=1000;mid++){\n        ll ans=0;\n        rep(i,N){\n            if(l[i] <= mid and mid <= r[i]) continue;\n            if(r[i] < mid){\n                ans += abs(mid-r[i]);\n            }else{\n                ans += abs(l[i]-mid);\n            }\n        }\n        ans2=min(ans2,ans);\n    }\n    cout << ans2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <set>\n\nusing ll = long long;\n\nclass Myset{\npublic:\n  ll offset;\n  std::multiset<ll> st;\n  Myset(){\n    offset = 0;\n  }\n  void _insert(ll val){\n    st.insert(val - offset);\n  }\n  int size(){\n    return st.size();\n  }\n  ll front(){\n    return *st.begin() + offset;\n  }\n  ll back(){\n    return *st.rbegin() + offset;\n  }\n  void pop_back(){\n    std::multiset<ll>::iterator it = st.end();\n    it--;\n    st.erase(it);\n  }\n  void pop_front(){\n    std::multiset<ll>::iterator it = st.begin();\n    st.erase(it);\n  }\n  void shift(ll val){\n    offset += val;\n  }\n};\n\nclass Slope{\npublic:\n  ll a;\n  ll b;\n  Myset f1, f2;\n  Slope(){\n    a = b = 0;\n  }\n  int size(){\n    return f1.size() + f2.size();\n  }\n\n  void _insert(ll val){\n    if(0 == f2.size() || val < f2.front())\n      f1._insert(val);\n    else\n      f2._insert(val);\n  }\n\n  void balance(){\n    while(a < f2.size()){\n      f1._insert(f2.front());\n      f2.pop_front();\n    }\n    while(f2.size() < a){\n      f2._insert(f1.back());\n      f1.pop_back();\n    }\n  }\n\n  void minrange(ll val){\n    f1.shift(-val);\n  }\n  void minrange2(ll val){\n    b -= val * a;\n    f2.shift(val);\n  }\n};\n\nvoid _add(Slope &x, Slope &y){\n  if(x.size() < y.size())\n    std::swap(x, y);\n  x.a += y.a;\n  x.b += y.b;\n  while(0 < y.f1.size()) {\n    x._insert(y.f1.back());\n    y.f1.pop_back();\n  }\n  while(0 < y.f2.size()){\n    x._insert(y.f2.back());\n    y.f2.pop_back();\n  }\n}\n\nint main()\n{\n  int n;\n  std::cin >> n;\n\n  Slope basic;\n\n  for(int i = 1;i <= n; i++){\n    int x, y, l;\n    std::cin >> x >> y;\n    l = y - x;\n    basic.balance();\n    basic.minrange(l);\n    Slope curr;\n    curr.a = 1;\n    curr.b = -x;\n    curr._insert(x);\n    curr._insert(x);\n    _add(basic, curr);\n\n    basic.balance();\n    basic.minrange2(l);\n  }\n\n  basic.balance();\n\n  ll result = basic.b;\n  while(0 < basic.f2.size()){\n    result += basic.f2.back();\n    basic.f2.pop_back();\n  }\n\n  std::cout << result;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// c.cpp\n\n# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\nconst pair < int , int > DD[] = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < __typeof(v.x) > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vl vector < ll >\n# define pll pair < ll , ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define fail puts(\"-1\")\n# define yes puts(\"YES\")\n# define no puts(\"NO\")\n# define PP puts(\"Possible\")\n# define II puts(\"Impossible\")\n# define vii vector < pii >\n# define vll vector < ll >\n# define pb push_back\n# define pdd pair < db , db >\n# define int ll\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nint SZ = 1;\nint L[1 << 23];\nint R[1 << 23];\nll t[1 << 23];\nint get(int & k)\n{\n    if (!k) k = ++SZ;\n    return k;\n}\nvoid update(int p,int u,int l,int r,int v,int node)\n{\n    if (l <= p && u <= r)\n        t[node] += v;\n    else\n    {\n        int m = (p + u) / 2;\n        if (l <= m)\n            update(p,m,l,r,v,get(L[node]));\n        if (m+1<=r)\n            update(m+1,u,l,r,v,get(R[node]));\n    }\n}\nvl ss;\nvoid go(int p,int u,ll sum,int node)\n{\n    if (!node || (p == u))\n    {\n        ss.pb(1ll * (u - p + 1) * (sum + t[node]));\n        return;\n    }\n    int m = (p + u) / 2;\n    go(p,m,sum + t[node],L[node]);\n    go(m+1,u,sum + t[node],R[node]);\n}\nint32_t main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n;\n    IOS;\n    fi>>n;\n    const int oo = 2e9;\n    for (int i = 1;i <= n;++i)\n    {\n        int l,r;\n        fi>>l>>r;\n        if (l > 1)\n            update(1,oo,2,l,-1,1),\n            update(1,oo,1,1,l - 1,1);\n        if (r < oo)\n            update(1,oo,r + 1,oo,1,1);\n    }\n    t[0] = 0;\n    go(1,oo,0ll,1);\n    p(SZ);\n    ll ans = 2e18;\n    ll sum = 0;\n    for (auto it : ss)\n    {\n        sum += it;\n        smin(ans,sum);\n    }\n    if (ans == 1999999681ll)\n        --ans;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nll r[10005], l[10005];\n\nll f(int idx, int offset) {\n    ll L = l[idx] + offset;\n    ll R = r[idx] + offset;\n    L = max(0LL, L);\n    R = max(0LL, R);\n    ll ret = 0;\n    for (int i = idx - 1; i >= 0; i--) {\n        // cout << \"now: \" << L << \", \" << R << endl;\n        if (r[i] < L) {\n            ll d = L - r[i];\n            ret += d;\n            L = l[i] + d;\n            R = r[i] + d;\n        } else if (R < l[i]) {\n            ll d = l[i] - R;\n            ret += d;\n            L = l[i] - d;\n            R = r[i] - d;\n        } else {\n            L = l[i];\n            R = r[i];\n        }\n    }\n    L = l[idx] + offset;\n    R = r[idx] + offset;\n    L = max(0LL, L);\n    R = max(0LL, R);\n    rep(i, N) if (idx < i) {\n        if (r[i] < L) {\n            ll d = L - r[i];\n            ret += d;\n            L = l[i] + d;\n            R = r[i] + d;\n        } else if (R < l[i]) {\n            ll d = l[i] - R;\n            ret += d;\n            L = l[i] - d;\n            R = r[i] - d;\n        } else {\n            L = l[i];\n            R = r[i];\n        }\n    }\n    return ret;\n}\nint main() {\n    cin >> N;\n    rep(i, N) cin >> l[i] >> r[i];\n    if (N > 400) return 0;\n    ll ans = INF;\n    rep(i, N) {\n        rep(j, 400) {\n            ll t = f(i, j - 200) + abs(j - 200);\n            // cout << t << endl;\n            ans = min(t, ans);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <queue>\n\nusing namespace std;\nusing namespace std::chrono;\n\nconst int LIM = 20;\nconst int INF = 1e+9;\n\ntemplate<class T, class U>\nvoid show(T l, U r, long long add_to_left, long long add_to_right) {\n  cout << l.size() << r.size() << endl;\n  vector<long long> pts;\n  while (!l.empty()) {\n    pts.push_back(l.top() + add_to_left);\n    l.pop();\n  }\n  reverse(pts.begin(), pts.end());\n  while (!r.empty()) {\n    pts.push_back(r.top() + add_to_right);\n    r.pop();\n  }\n\n  for (long long i : pts)\n    cout << i << ' ';\n  cout << endl;\n}\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n\n  priority_queue<long long> l;\n  priority_queue<long long, vector<long long>, greater<long long>> r;\n  long long add_to_left = 0, add_to_right = 0, ans = 0;\n\n  vector<pair<long long, long long>> rect(n);\n  for (int i = 0; i < n; ++i)\n    cin >> rect[i].first >> rect[i].second;\n\n  l.push(rect[0].first);\n  r.push(rect[0].first);\n\n  //show(l, r, add_to_left, add_to_right);\n\n  for (int i = 1; i < n; ++i) {\n    add_to_right += (rect[i - 1].second - rect[i - 1].first);\n    add_to_left -= (rect[i].second - rect[i].first);\n\n    long long real_left = l.top() + add_to_left;\n    long long real_right = r.top() + add_to_right;\n\n    if (rect[i].first < real_left) {\n      ans += real_left - rect[i].first;\n      r.push(real_left - add_to_right);\n      l.pop();\n      l.push(rect[i].first - add_to_left);\n      l.push(rect[i].first - add_to_left);\n    } else if (rect[i].first > real_right) {\n      ans += rect[i].first - real_right;\n      l.push(real_right - add_to_left);\n      r.pop();\n      r.push(rect[i].first - add_to_right);\n      r.push(rect[i].first - add_to_right);\n    } else {\n      l.push(rect[i].first - add_to_left);\n      r.push(rect[i].first - add_to_right);\n    }\n\n    //show(l, r, add_to_left, add_to_right);\n  }\n\n  cout << ans << endl;\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100004\n#define mp make_pair\n#define pb push_back\n#define ll long long\nusing namespace std;\nll l[N],r[N],lc[N],rc[N];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tll n,k;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>l[i]>>r[i];\n\t\tlc[i]=l[i];\n\t\trc[i]=r[i];\n\t}\n\tll sum=0,a,b,ac,bc;\n/*\tfor(int i=0;i<n-1;i++){\n\t\tif(l[i]>l[i+1]&&r[i]<r[i+1]||l[i+1]>l[i]&&r[i+1]<r[i])\n\t\t\tcontinue;\n\t\tif(r[i+1]>l[i]&&r[i+1]<r[i]||r[i+1]>r[i]&&l[i+1]<r[i])\n\t\t\tcontinue;\n\t\ta=l[i+1]-r[i];\n\t\tb=l[i]-r[i+1];\n\t\tif(a>0){\n\t\t\tsum+=a;\n\t\t}\n\t\telse\n\t\t\tsum+=b;\n\t\t\n\t}*/\n\tll sum1=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tif(l[i]>l[i+1]&&r[i]<r[i+1]||l[i+1]>l[i]&&r[i+1]<r[i])\n\t\t\tcontinue;\n\t\tif(lc[i]>l[i+1]&&rc[i]<r[i+1]||l[i+1]>lc[i]&&r[i+1]<rc[i])\n\t\t\tcontinue;\n\t\tif(r[i+1]>l[i]&&r[i+1]<r[i]||r[i+1]>r[i]&&l[i+1]<r[i])\n\t\t\tcontinue;\n\t\tif(r[i+1]>lc[i]&&r[i+1]<rc[i]||r[i+1]>rc[i]&&l[i+1]<rc[i])\n\t\t\tcontinue;\n\n\t\ta=l[i+1]-r[i];\n\t\tb=l[i]-r[i+1];\n\t\tac=l[i+1]-rc[i];\n\t\tbc=lc[i]-r[i+1];\n\t\t\n\t\tif(a>0){\n\t\t\tif(ac<a){\n\t\t\t\tsum1+=ac;\n\t\t\t\tlc[i+1]=rc[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum1+=a;\n\t\t\t\tlc[i+1]=r[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\telse{\n\t\t\tif(bc>b){\n\t\t\t\trc[i+1]=l[i];\n\t\t\t\tsum1+=b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trc[i+1]=lc[i];\n\t\t\t\tsum1+=bc;\n\t\t\t}\n\t\t}\n\t\t//cout<<min(sum1,sum)<<endl;\n\t}\n\tcout<<sum1<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\n//typedef string S;\n\n/*ll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}*/\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 120010;\nconst long long MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst long long rev2 = (MOD + 1) / 2;\n\nint n, lastl, lastr;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    multiset<long long> L, R;\n    long long addL = 0, addR = 0;\n    long long c = 0;\n    L.insert(-INF);\n    R.insert(INF);\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (i != 0) addL -= r - l, addR += lastr - lastl;\n        lastl = l, lastr = r;\n        auto x = L.end();\n        x--;\n        int Ln = *x + addL;\n        auto y = R.begin();\n        int R0 = *y + addR;\n        if (Ln <= l && l <= R0)\n        {\n            L.insert(l - addL);\n            R.insert(l - addR);\n        } else if (l < Ln)\n        {\n            L.erase(x);\n            R.insert(Ln - addR);\n            L.insert(l - addL);\n            L.insert(l - addL);\n            c += Ln - l;\n        } else\n        {\n            R.erase(y);\n            L.insert(R0 - addL);\n            R.insert(l - addR);\n            R.insert(l - addR);\n            c += l - R0;\n        }\n    }\n    cout << c;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nconst int N = 1e5 + 5;\ntypedef long long ll; \nusing namespace std; \n\nint n, l[N], r[N], len[N], ans, addl, addr; \npriority_queue<int> L;\npriority_queue<int, vector<int>, greater<int> > R; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint mabs(int x) { return x > 0 ? x : -x; }\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> ();\n\tfor(int i = 1; i <= n; i++) l[i] = read <int> (), r[i] = read <int> (), len[i] = r[i] - l[i]; \n\tL.push(l[1]), R.push(l[1]); \n\tfor(int x, y, i = 2; i <= n; i++)\n\t{\n\t\taddl -= len[i], addr += len[i - 1]; \n\t\tx = L.top() + addl, y = R.top() + addr;\n\t\tif(l[i] < x)\n\t\t{\n\t\t\tans += x - l[i], L.pop(), R.push(x - addr);\n\t\t\tL.push(l[i] - addl), L.push(l[i] - addl); \n\t\t}\n\t\telse if(l[i] > y)\n\t\t{\n\t\t\tans += l[i] - y, R.pop(), L.push(y - addl);\n\t\t\tR.push(l[i] - addr), R.push(l[i] - addr); \n\t\t}\n\t\telse L.push(l[i] - addl), R.push(l[i] - addr); \n\t}\n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    priority_queue<lint, vector<lint>, less<lint>> lower;\n    priority_queue<lint, vector<lint>, greater<lint>> upper;\n\n    lint ans = 0;\n    lint lazy_lower = 0;\n    lint lazy_upper = 0;\n\n    vector<lint> len(n);\n    for (int i = 0; i < n; i++) {\n        lint l, r;\n        cin >> l >> r;\n        len[i] = r - l + 1;\n\n        if (i == 0) {\n            lower.emplace(l);\n            upper.emplace(l);\n            continue;\n        }\n\n        lazy_lower -= len[i] - 1;\n        lazy_upper += len[i - 1] - 1;\n\n        if (l <= lower.top() + lazy_lower) {\n            lint top = lower.top() + lazy_lower;\n            ans += top - l;\n            lower.emplace(l - lazy_lower);\n            lower.emplace(l - lazy_lower);\n            lower.pop();\n            upper.emplace(top - lazy_upper);\n        } else if (upper.top() + lazy_upper <= l) {\n            lint top = upper.top() + lazy_upper;\n            ans += l - top;\n            upper.emplace(l - lazy_upper);\n            upper.emplace(l - lazy_upper);\n            upper.pop();\n            lower.emplace(top - lazy_lower);\n        } else {\n            lower.emplace(l - lazy_lower);\n            upper.emplace(l - lazy_upper);\n        }\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\nconst int MAXN = 200005;\nconst int MOD = 1000000007;\n\nll n,c,l[MAXN],r[MAXN],hl[MAXN],hr[MAXN],sl[MAXN],sr[MAXN],cntl[MAXN],cntr[MAXN];\nmap<ll,ll> mp;\n\nll fun(ll a,ll b,ll e,ll d){\n\tll ans = 0;\n\tans = b*cntr[a] - sr[a];\n\tans -= d * (cntl[c] - cntl[e-1]) - (sl[c] - sl[e-1]); \n\treturn ans;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> l[i] >> r[i];\n\t\tmp[l[i]]; mp[r[i]];\n\t}\n\tfor(auto &i:mp) i.second = ++c;\n\tfor(int i=1;i<=n;i++){\n\t\thl[i] = mp[l[i]];\n\t\thr[i] = mp[r[i]];\n\t\tsl[hl[i]] += l[i];\n\t\tcntl[hl[i]]++;\n\t\tsr[hr[i]] += r[i];\n\t\tcntr[hr[i]]++;\n\t}\n\tfor(int i=1;i<=c;i++) sl[i] += sl[i-1] , sr[i] += sr[i-1];\n\tfor(int i=1;i<=c;i++) cntl[i] += cntl[i-1] , cntr[i] += cntr[i-1];\n\tll ans = 1e16;\n\tfor(int i=1;i<=n;i++){\n\t\tans = min(ans,fun(hl[i],l[i],hr[i],r[i]));\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n#include <climits>\n#include <functional>\n\n#define REP(i,n) for(int i = 0;i < n;i++)\n\nusing namespace std;\ntypedef long long ll;\nconst int INF = INT_MAX / 4;\n\nconst int max_n = 1e3;\n\nint main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll N;\n  cin >> N;\n  ll L[N], R[N];\n  REP(i, N) {\n    cin >> L[i] >> R[i];\n  }\n\n  ll min_cost = LLONG_MAX;\n\n  REP(i, N) {\n    // cp l, r\n    ll l[N], r[N];\n    REP(j, N){\n      l[j] = L[j];\n      r[j] = R[j];\n    }\n\n    // cerr << \"----\\ntry i = \" << i << \"\\n\";\n    // REP(j, N) {\n    //   cerr << l[j] << \" \" << r[j] << \"\\n\";\n    // }\n    // cerr << \"\\n\";\n\n    ll cost = 0;\n    for (int j = i-1;j >= 0;j--) {\n      if (r[j] < l[j+1]) {\n\tll c = l[j+1] - r[j];\n\tcost += c;\n\tl[j] += c;\n\tr[j] += c;\n      } else if (r[j+1] < l[j]) {\n\tll c = l[j] - r[j+1];\n\tcost += c;\n\tl[j] -= c;\n\tr[j] -= c;\n      }\n      // REP(k, N) {\n      // \tif (j == k) {\n      // \t  cerr << l[k] << \" \" << r[k] << \" << cost: \" << cost << \"\\n\";\n      // \t} else {\n      // \t  cerr << l[k] << \" \" << r[k] << \"\\n\";\n      // \t}\n      // }\n      // cerr << \"\\n\";\n    }\n    for (int j = i+1;j < N;j++) {\n      if (r[j] < l[j-1]) {\n\tll c = l[j-1] - r[j];\n\tcost += c;\n\tl[j] += c;\n\tr[j] += c;\n      } else if (r[j-1] < l[j]) {\n\tll c = l[j] - r[j-1];\n\tcost += c;\n\tl[j] -= c;\n\tr[j] -= c;\n      }\n      // REP(k, N) {\n      // \tif (j == k) {\n      // \t  cerr << l[k] << \" \" << r[k] << \" << cost: \" << cost << \"\\n\";\n      // \t} else {\n      // \t  cerr << l[k] << \" \" << r[k] << \"\\n\";\n      // \t}\n      // }\n      // cerr << \"\\n\";\n\n    }\n    if (cost < min_cost) min_cost = cost;\n    // cerr << \"cost: \" << cost << \"\\n\";\n  }\n\n  cout << min_cost << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\n//FILE *fin = fopen(\"a.in\", \"r\"), *fout = fopen(\"a.out\", \"w\");\n#define fin stdin\n#define fout stdout\n\n#define ll long long\n\nint main() {\n    int n;\n    ll l, d;\n    fscanf(fin, \"%d%lld%lld\", &n, &l, &d);\n    d -= l;\n\n    std::priority_queue < ll > left;\n    std::priority_queue < ll, std::vector < ll > , std::greater < ll > > right;\n    ll lazyLeft = 0, lazyRight = 0, ans = 0;\n    /// valoarea reala a lui left.top() este left.top() + lazyLeft\n    /// valoarea reala a lui right.top() este right.top() + lazyRight\n\n    left.push(l);\n    right.push(l);\n    for (int i = 1; i < n; i++) {\n        lazyRight += d;\n        fscanf(fin, \"%lld%lld\", &l, &d);\n        d -= l;\n        lazyLeft -= d;\n\n        ll realLeft = left.top() + lazyLeft, realRight = right.top() + lazyRight;\n        if (l <= realLeft) {\n            ans += realLeft - l;\n            left.pop();\n            right.push(realLeft - lazyRight);\n            left.push(l - lazyLeft);\n            left.push(l - lazyLeft);\n        } else if (l < realRight) {\n            left.push(l - lazyLeft);\n            right.push(l - lazyRight);\n        } else {\n            ans += l - realRight;\n            right.pop();\n            left.push(realRight - lazyLeft);\n            right.push(l - lazyRight);\n            right.push(l - lazyRight);\n        }\n    }\n\n    fprintf(fout, \"%lld\\n\", ans);\n\n    fclose(fin);\n    fclose(fout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2016\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nint n, l[MAXN], r[MAXN];\n\nint go(int L, int R, int val, int cur) {\n\tcur += val;\n\tif (cur < 0 || cur >= n) return 0;\n\tint ok = 0;\n\tif (l[cur] >= L && l[cur] <= R) ok = 1;\n\tif (r[cur] >= L && r[cur] <= R) ok = 1;\t\n\tif (l[cur] <= L && R <= r[cur]) ok = 1;\n\tint ans = 0;\n\tint nl = l[cur], nr = r[cur];\n\tif (!ok) {\n\t\tif (L > r[cur]) {\n\t\t\tans = L - r[cur];\n\t\t\tnl += ans;\n\t\t\tnr += ans;\n\t\t}\n\t\tif (R < l[cur]) {\n\t\t\tans = l[cur] - R;\n\t\t\tnl -= ans;\n\t\t\tnr -= ans;\n\t\t}\n\t}\n\t\n\tans += go(nl, nr, val, cur);\n\treturn ans;\n}\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tcin >> n;\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\t\n\tint fiAns = oo;\n\tfor (int i=0; i<n; i++) {\n\t\tint ans = go(l[i], r[i], 1, i);\n\t\tans += go(l[i], r[i], -1, i);\n\t\tfiAns = min(fiAns, ans);\n\t}\n\n\tcout << fiAns << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint n;\nP A[N];\nvoid Min(ll &a,ll b){a=min(a,b);}\n\n\nmap<P,ll>MD[N],MU[N];\nll calcU(int pos,ll L,ll R){\n  if(pos==-1) return 0;\n  if(MU[pos].count(P(L,R)))return MU[pos][P(L,R)];\n  ll l = A[pos].first, r = A[pos].second;\n  ll a = 1LL<<50;\n  if(!(r<L||R<l)) a = calcU(pos-1,l,r);\n  ll b = abs(R-l)+calcU(pos-1,l,r);\n  ll c = abs(L-r)+calcU(pos-1,l,r);\n  ll d = abs(L-l)+calcU(pos-1,L,L+(r-l));\n  ll e = abs(R-r)+calcU(pos-1,R-(r-l),R);\n  return MU[pos][P(L,R)]=min(a,min(b,min(c,min(d,e))));\n}\n\nll calcD(int pos,ll L,ll R){\n  if(pos==n) return 0;\n  if(MD[pos].count(P(L,R)))return MD[pos][P(L,R)];\n  ll l = A[pos].first,r = A[pos].second;\n  ll a = 1LL<<50;\n  if(!(r<L||R<l)) a = calcD(pos+1,l,r);\n  ll b = abs(R-l)+calcD(pos+1,l,r);\n  ll c = abs(L-r)+calcD(pos+1,l,r);\n  ll d = abs(L-l)+calcD(pos+1,L,L+(r-l));\n  ll e = abs(R-r)+calcD(pos+1,R-(r-l),R);\n  return MD[pos][P(L,R)]=min(a,min(b,min(c,min(d,e))));\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].first>>A[i].second;\n  \n  ll ans=1LL<<50;\n  for(int i=0;i<n;i++) {\n    int L = A[i].first;\n    int R = A[i].second;\n    ans=min(ans,calcU(i-1,L,R)+calcD(i+1,L,R));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link relink\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string &fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 405;\n\nint n, k;\nint l[N], r[N];\nint dp[N][N];\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  l[0] = 0, r[0] = 400;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < 400; j++) {\n      // current is j,j+r[i]-l[i]\n      dp[i][j] = INF;\n      for (int k = max(0, j - (r[i - 1] - l[i - 1]));\n           k <= min(400, j + r[i] - l[i]); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n      }\n      dp[i][j] += abs(l[i] - j);\n    }\n  }\n\n  cout << *min_element(dp[n], dp[n] + 400) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<30;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nint n;\nint l[400], r[400], d[400];\nint dp[400][401];\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", l + i, r + i);\n\t\tl[i]--; r[i]--;\n\t\td[i] = r[i] - l[i];\n\t}\n\t\n\tbool ok = true;\n\tif (n > 400) ok = false;\n\tREP(i, n) if (r[i] >= 400) ok = false;\n\tassert(ok);\n\t\n\tfill(dp[0], dp[n], INF);\n\t\n\tREP(i, n) {\n\t\tREP(j, 400) {\n\t\t\tint cost = abs(j - l[i]);\n\t\t\t\n\t\t\tif (i == 0) {\n\t\t\t\tchmin(dp[i][j], cost);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = max(0, j - d[i - 1]); k <= j + d[i]; k++)\n\t\t\t\t\tchmin(dp[i][j], cost + dp[i - 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tREP(i, 400) chmin(ans, dp[n - 1][i]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n#define ep emplace_back\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);++i)\nconstexpr int mod=1000000007;\nconstexpr int mod1=998244353;\nvector<int> dx={0,1,0,-1},dy={-1,0,1,0};\nbool inside(int y,int x,int h,int w){\n\tif(y<h && y>=0 && x<w && x>=0) return true;\n\treturn false;\n}\n\n\n\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;cin >> n;\n\tif(n > 400) return 0;\n\tvector<int> l(n),r(n);\n\trep(i,n) cin >> l.at(i) >> r.at(i);\n\tll ans = 1e18;\n\tfor(int j = -100; j <= 500; j++){\n\t\tll sum = 0;\n\t\trep(i,n){\n\t\t\tif(l.at(i) <= j && r.at(i) >= j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(l.at(i) > j){\n\t\t\t\tsum += l.at(i) - j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += j - r.at(i);\n\t\t\t}\n\t\t}\n\t\tans = min(ans, sum);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nvector< pair<int,int> > A;\nint dp [401] [801];\nconst int INF = 1e9;\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tA.assign(N,make_pair(0,0));\n\tFOR(i,0,N){\n\t\tscanf(\"%d%d\",&A [i].first,&A [i].second);\n\t}\n\tif(N > 400) return 0;\n\t\n\tfill(dp [0],dp [N + 1],INF);\n\tFOR(i,0,801){\n\t\tdp [1] [i] = abs(i - 400);\n\t}\n\tFOR(i,1,N) FOR(j,0,801) if(dp [i] [j] < INF){\n\t\tint l1 = A [i - 1].first + (j - 400),r1 = A [i - 1].second + (j - 400);\n\t\tFOR(k,0,801){\n\t\t\tint l2 = A [i].first + (k - 400),r2 = A [i].second + (k - 400);\n\t\t\tif((r1 < l2 || r2 < l1) == false){\n\t\t\t\tchmin(dp [i + 1] [k],dp [i] [j] + abs(k - 400));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = *min_element(dp [N],dp [N + 1]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define pb push_back\n#define F first\n#define S second\n#define f(i,a,b)  for(int i = a; i < b; i++)\n\nusing ll = long long;\nusing db = long double;\nusing ii = pair<int, int>;\n\nconst int N = 2e5 + 5, MOD = 1e9 + 7;\nconst int SQ =225;\nconst long double EPS = 1e-7;\n\nint dp[405][405];\nint l[405], r[405];\nint n;\nbool intersect(int x1, int y1, int x2, int y2){\n  return max(x1,x2) <= min(y1,y2);\n}\nint solve(int idx, int prv){\n  if(idx == n)\n    return 0;\n  int &ret = dp[idx][prv];\n  if(~ret)\n    return ret;\n  ret = INT_MAX;\n  for(int j = 1; j <= 400; j++)\n    if(intersect(prv,prv+r[idx-1]-l[idx-1], j, j+r[idx]-l[idx])){\n      ret = min(ret, solve(idx+1, j) + abs(j - l[idx]));\n    }\n  return ret;\n}\nint32_t main(){\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n\n  cin >> n;\n\n  for(int i = 0; i < n; i++)\n    cin >> l[i] >> r[i];\n\n  memset(dp,-1,sizeof dp);\n\n  int ans = INT_MAX;\n  for(int i = 1; i <= 400; i++)\n    ans = min(ans, solve(1,i) + abs(i - l[0]));\n\n  cout << ans << '\\n';\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\n\nvector<vector<int> > cc;\nint dp(int n, int l) {\n    int &ret = cc[n][l];\n    if(ret != -1) return ret;\n\n    if(n == N - 1) return ret = abs(S[n].first - l);\n\n    int r = l + S[n].second - S[n].first;\n    ret = 1e9;\n    for(int i = 0; i <= 400; i++) {\n        int nl = i, nr = nl + S[n + 1].second - S[n + 1].first;\n        if(r < nl || nr < l) continue;\n        ret = min(ret, abs(S[n].first - l) + dp(n + 1, nl));\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    cc = vector<vector<int> >(N, vector<int>(402, -1));\n    int ans = 1e9;\n    for(int i = 0; i <= 400; i++) ans = min(ans, dp(0, i));\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 403\nint n;\nvector<P> p;\nint dp[N][N];\n\n#define R_MAX 400\n\nint main() {\n  cin >> n;\n  rep(i, n) {\n    int l, r;\n    cin >> l >> r;\n    p.push_back(P(l, r));\n  }\n  sort(ALL(p));\n  rep(i, n) {\n    rep(j, R_MAX+1) dp[i][j] = INF;\n  }\n  // 0\n  repl(i, 0, p[0].first-1) {\n    dp[0][i] = p[0].first - i;\n  }\n  repl(i, p[0].first, p[0].second) {\n    dp[0][i] = 0;\n  }\n  repl(i, p[0].second+1, R_MAX) {\n    dp[0][p[0].second] = i - p[0].second;\n  }\n\n  repl(i, 1, n-1) {\n    int l = p[i].second - p[i].first;\n    // hidari\n    repl(j, 0, p[i].first-1) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j] + (p[i].first - j));\n      }\n    }\n    // sonomama\n    repl(j, p[i].first, p[i].second) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j]);\n      }\n    }\n    // migi\n    repl(j, p[i].second+1, R_MAX) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j] + (j - p[i].second));\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i, R_MAX+1) {\n    ans = mind(ans, dp[n-1][i]);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define pb push_back\n#define F first\n#define S second\n#define f(i,a,b)  for(int i = a; i < b; i++)\n\nusing ll = long long;\nusing db = long double;\nusing ii = pair<int, int>;\n\nconst int N = 2e5 + 5, MOD = 1e9 + 7;\nconst int SQ =225;\nconst long double EPS = 1e-7;\n\nint dp[405][405];\nint l[405], r[405];\nint n;\nbool intersect(int x1, int y1, int x2, int y2){\n  return max(x1,x2) <= min(y1,y2);\n}\nint solve(int idx, int prv){\n  if(idx == n)\n    return 0;\n  int &ret = dp[idx][prv];\n  if(~ret)\n    return ret;\n  ret = INT_MAX;\n  for(int j = 1; j <= 400; j++)\n    if(intersect(prv,prv+r[idx-1]-l[idx-1], j, j+r[idx]-l[idx])){\n      if(idx == 1 && prv == 1)\n      cout << idx << \" \" << j << ' ' << abs(j - l[idx]) +solve(idx+1,j) << '\\n';\n      ret = min(ret, solve(idx+1, j) + abs(j - l[idx]));\n    }\n  return ret;\n}\nint32_t main(){\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n\n  cin >> n;\n\n  for(int i = 0; i < n; i++)\n    cin >> l[i] >> r[i];\n\n  memset(dp,-1,sizeof dp);\n\n  int ans = INT_MAX;\n  for(int i = 1; i <= 400; i++)\n    ans = min(ans, solve(1,i) + abs(i - l[0]));\n\n  cout << ans << '\\n';\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> P;\npriority_queue <ll,vector <ll>,greater <ll> > Q;\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint main() {\n    int n;\n    ll A=0,B=0,ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n\tint l=gi(),r=gi();\n\tB+=r-l;\n\tP.push(r-A),Q.push(r-B);\n\twhile(P.top()+A>Q.top()+B) {\n\t    ll x=P.top()+A,y=Q.top()+B;\n\t    P.pop(),Q.pop(),ans+=x-y;\n\t    P.push(y-A),Q.push(x-B);\n\t}\n\tA-=r-l;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nconst int N = 1e5 + 5; \nusing namespace std; \n\nint n, l[N], r[N], len[N], ans;\npriority_queue<int, vector<int>, greater<int> > q; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint mabs(int x) { return x > 0 ? x : -x; }\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> ();\n\tfor(int i = 1; i <= n; i++) l[i] = read <int> (), r[i] = read <int> (), len[i] = r[i] - l[i]; \n\tans = 0, q.push(l[1]), q.push(l[1]); \n\tfor(int x, y, i = 2; i <= n; i++)\n\t{\n\t\tx = q.top(), q.pop(), y = q.top(), q.pop(); \n\t\tx -= len[i], y += len[i - 1], ans += mabs(x - l[i]); \n\t\tif(l[i] <= x) q.push(l[i]), q.push(x), q.push(y); \n\t\telse if(l[i] > x && l[i] <= y) ans -= l[i] - x, q.push(l[i]), q.push(l[i]), q.push(y);\n\t\telse if(l[i] > y) ans -= y - x, q.push(y), q.push(l[i]), q.push(l[i]); \n\t}\n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1024;\n\nint dp[N + N][N + N];\nint l[N], r[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  for (int i = 0; i < N; i++) {\n    dp[0][i] = abs(i-l[0]);\n    // if (i < 20)\n    //   cerr << i << \" \";\n  }\n  // cerr << endl;\n  for (int i = 0; i + 1 < n; i++) {\n    int sbef = r[i]-l[i], snow = r[i+1]-l[i+1];\n    deque< int > dq;\n    for (int j = 0; j < min(snow, N); j++) {\n      while (!dq.empty()) {\n        if (dq.front() > dp[i][j])\n          dq.pop_front();\n        else\n          break;\n      }\n      dq.push_front(dp[i][j]);\n    }\n    for (int j = 0; j < N; j++) {\n      if (j + snow < N) {\n        while (!dq.empty()) {\n          if (dq.front() > dp[i][j+snow])\n            dq.pop_front();\n          else\n            break;\n        }\n        dq.push_front(dp[i][j+snow]);\n      }\n      if (dq.empty()) continue;\n      dp[i+1][j] = abs(l[i+1]-j) + dq.back();\n      if (j-sbef >= 0 && dq.back() == dp[i][j-sbef])\n        dq.pop_back();\n      // if (j < 20)\n      //   cerr << dp[i+1][j] << \" \";\n    }\n    // cerr << i+ 1<< endl;\n  }\n  int ans = dp[n-1][0];\n  for (int i = 0; i < 444; i++)\n    ans = min(ans, dp[n-1][i]);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100004\n#define mp make_pair\n#define pb push_back\n#define ll long long\nusing namespace std;\nll l[N],r[N];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tll n,k;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>l[i]>>r[i];\n\tll sum=0,a,b,al,bl;\n\tfor(int i=0;i<n-1;i++){\n\t\tif(l[i]>l[i+1]&&r[i]<r[i+1]||l[i+1]>l[i]&&r[i+1]<r[i])\n\t\t\tcontinue;\n\t\tif(r[i+1]>l[i]&&r[i+1]<r[i]||r[i+1]>r[i]&&l[i+1]<r[i])\n\t\t\tcontinue;\n\t\ta=l[i+1]-r[i];\n\t\tb=l[i]-r[i+1];\n\t\t/*al=l[i+1]-l[i];\n\t\tbl=r[i+1]-r[i];\n\t\tif(a<0&&bl>0||b<0&&al<0)\n\t\t\tcontinue;*/\n\t\tif(a>0){\n\t\t\tsum+=a;\n\n\t\t}\n\t\telse\n\t\t\tsum+=b;\n\t\t//cout<<sum<<endl;\n\t}\n\tll sum1=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tif(l[i]>l[i+1]&&r[i]<r[i+1]||l[i+1]>l[i]&&r[i+1]<r[i])\n\t\t\tcontinue;\n\t\tif(r[i+1]>l[i]&&r[i+1]<r[i]||r[i+1]>r[i]&&l[i+1]<r[i])\n\t\t\tcontinue;\n\t\ta=l[i+1]-r[i];\n\t\tb=l[i]-r[i+1];\n\t\t/*al=l[i+1]-l[i];\n\t\tbl=r[i+1]-r[i];\n\t\tif(a<0&&bl>0||b<0&&al<0)\n\t\t\tcontinue;*/\n\t\tif(a>0){\n\t\t\tsum1+=a;\n\t\t\tl[i+1]=r[i];\n\t\t}\n\t\telse{\n\t\t\tr[i+1]=l[i];\n\t\t\tsum1+=b;\n\t\t}\n\t\t//cout<<min(sum1,sum)<<endl;\n\t}\n\tcout<<min(sum1,sum)<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define Reps(i, x, N) for(int i = x; i < N; i++)\n\ninline int llabs(int n) { return n < 0 ? -n : n; }\n\nconst int LLINF = 1LL << 60;\nsigned main()\n{\n  int N;\n  int l[405], r[405];\n  int dl[405], dr[405];\n  int a[405], b[405];\n  \n  cin >> N;\n\n  Rep(i, N) {\n    cin >> l[i] >> r[i];\n    dl[i] = l[i], dr[i] = r[i];\n  }\n\n  a[0] = 0, b[0] = r[0] - l[0];\n  Reps(i, 1, N) {\n    if(r[i] < l[i - 1]) {\n      b[i] = a[i - 1];\n      a[i] = b[i] - (r[i] - l[i]);\n      r[i] = l[i - 1];\n      l[i] = r[i] - (a[i] - b[i]);\n    } else if(r[i - 1] < l[i]) {\n      a[i] = b[i - 1];\n      b[i] = a[i] + r[i] - l[i];\n      l[i] = r[i - 1];\n      r[i] = l[i] + a[i] - b[i];\n    } else {\n      a[i] = a[i - 1] + l[i] - l[i - 1];\n      b[i] = a[i] + r[i] - l[i];\n    }\n  }\n\n  int minv = LLINF;\n  Reps(i, -800, 801) {\n    int sum = 0;\n    Rep(j, N) {\n      sum += llabs(dl[j] - (a[j] + i));\n    }\n\n    minv = min(minv, sum);\n  }\n\n  cout << minv << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 100054;\n\nint n;\nstd::priority_queue <ll> L;\nstd::priority_queue <ll, std::vector <ll>, std::greater <ll> > R;\nll OL, OR; // offset\n\nint main() {\n\tint i, l, r, dis, la = -1; ll x, y, ans = 0;\n\tscanf(\"%d%d%d\", &n, &l, &r), la = r - l;\n\tL.emplace(l), R.emplace(l);\n\tfor (i = 1; i < n; ++i, la = dis) {\n\t\tscanf(\"%d%d\", &l, &r), dis = r - l, OL -= dis, OR += la;\n\t\tx = L.top() + OL, y = R.top() + OR;\n\t\tif (x > l) ans += x - l, R.push(x - OR), L.pop(), L.emplace(l - OL), L.emplace(l - OL);\n\t\telse if (y < l) ans += l - y, L.push(x - OL), R.pop(), R.emplace(l - OR), R.emplace(l - OR);\n\t\telse L.emplace(l - OL), R.emplace(l - OR);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\n\nconst int len = 1e5+5;\npair<ll, ll> arr[len];\nint n;\n\nll check(ll x){\n    ll ans = 0;\n    for (int i = 0; i < n; i++){\n        if (x < arr[i].fi)\n            ans += arr[i].fi-x;\n        else if (arr[i].se < x)\n            ans += x-arr[i].se;\n    }\n    return ans;\n}\n\nll ts(){\n    ll l = -1, r = 1e9+5;\n    while (l < r-1){\n        ll mid = l+(r-l)/2;\n        if (check(mid) < check(mid+1))\n            r = mid;\n        else\n            l = mid;\n    }\n    //printf(\"%lld\\n\", l+1);\n    return check(l+1);\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lld %lld\", &arr[i].fi, &arr[i].se);\n\n    printf(\"%lld\\n\", ts());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define fi(a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n////////////////////\n\nint const N = 1e5 + 41;\n\nint n, l[N], r[N];\nmultiset<ll> t0, t1;\nll ans, add0, add1;\n\nll getmin(multiset<ll> &t){\n\tmultiset<ll> :: iterator it = t.begin();\n\treturn (*it);\n}\n\nll extractmin(multiset<ll> &t){\n\tmultiset<ll> :: iterator it = t.begin();\n\tll res = (*it);\n\tt.erase(it);\n\treturn res;\n}\n\nll getmax(multiset<ll> &t){\n\tauto it = t.end();\n\t--it;\n\treturn (*it);\n}\n\nll extractmax(multiset<ll> &t){\n\tauto it = t.end();\n\t--it;\n\tll res = (*it);\n\tt.erase(it);\n\treturn res;\n}\n\nvoid solve(){\n\tt0.insert(l[0]);\n\tt1.insert(l[0]);\n\tfi(1, n){\n\t\tadd0 += -(r[i] - l[i]);\n\t\tadd1 += (r[i-1] - l[i-1]);\n\t\tll x0 = add0 + getmax(t0);\n\t\tll x1 = add1 + getmin(t1);\n\t\tif(x0 <= l[i] && l[i] <= x1){\n\t\t\tt0.insert(l[i] - add0);\n\t\t\tt1.insert(l[i] - add1);\n\t\t}else{\n\t\t\tif(l[i] < x0){\n\t\t\t\tans += x0 - l[i];\n\t\t\t\textractmax(t0);\n\t\t\t\tt0.insert(l[i] - add0);\n\t\t\t\tt0.insert(l[i] - add0);\n\t\t\t\tt1.insert(x0 - add1);\n\t\t\t}else{\n\t\t\t\tans += l[i] - x1;\n\t\t\t\textractmin(t1);\n\t\t\t\tt1.insert(l[i] - add1);\n\t\t\t\tt1.insert(l[i] - add1);\n\t\t\t\tt0.insert(x1 - add0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d\",&n);\n\tfi(0, n) scanf(\"%d %d\",&l[i],&r[i]);\n\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <assert.h>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <memory.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000;\nint n;\npair<ll, ll> v[N];\nll shift[N];\nbool intersect(ll l1, ll r1, ll l2, ll r2) {\n\tif (l2 >= l1 && l2 <= r1)\n\t\treturn true;\n\tif (r2 >= l1 && r2 <= r1)\n\t\treturn true;\n\treturn l1 >= l2 && l1 <= r2;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tint sh = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld%lld\", &v[i].first, &v[i].second);\n\t\tif (i) {\n\t\t\tif (intersect(v[i].first+sh, v[i].second+sh, v[i - 1].first + shift[i - 1], v[i - 1].second + shift[i - 1]))\n\t\t\t\tcontinue;\n\t\t\tif (v[i].second + sh < v[i - 1].first + shift[i - 1])\n\t\t\t\tsh += v[i - 1].first + shift[i - 1] - (v[i].second + sh);\n\t\t\telse\n\t\t\t\tsh -= (v[i].first + sh) - (v[i - 1].second + shift[i - 1]);\n\t\t}\n\t\tshift[i] = sh;\n\t}\n\tll l = -1e10, r = 1e10, m, res = 1e18;\n\tll l1, l2, r1, r2;\n\twhile (l <= r) {\n\t\tl1 = (2 * l + r) / 3;\n\t\tl2 = (l + 2 * r) / 3;\n\t\tr1 = r2 = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tr1 += abs(shift[i] + l1);\n\t\t\tr2 += abs(shift[i] + l2);\n\t\t}\n\t\tres = min({ r1,r2,res });\n\t\tif (r1 > r2)\n\t\t\tl = l1 + 1;\n\t\telse\n\t\t\tr = l2 - 1;\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nconst int mxN=1e5;\nint n, l[mxN+1], r[mxN+1];\nll yi, ls, rs;\npriority_queue<ll> lq;\npriority_queue<ll, vector<ll>, greater<ll>> rq;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor(int i=1; i<=n; ++i)\n\t\tcin >> l[i] >> r[i];\n\tfor(int i=1; i<=n; ++i) {\n\t\tls+=r[i]-l[i];\n\t\trs+=r[i-1]-l[i-1];\n\t\tll lm=lq.size()?lq.top()-ls:LLONG_MIN, rm=rq.size()?rq.top()+rs:LLONG_MAX;\n\t\tif(lm<=l[i]&&l[i]<=rm) {\n\t\t\tlq.push(l[i]+ls);\n\t\t\trq.push(l[i]-rs);\n\t\t} else if(lm>l[i]) {\n\t\t\tlq.pop();\n\t\t\trq.push(lm-rs);\n\t\t\tlq.push(l[i]+ls);\n\t\t\tlq.push(l[i]+ls);\n\t\t} else {\n\t\t\trq.pop();\n\t\t\tlq.push(rm+ls);\n\t\t\trq.push(l[i]-rs);\n\t\t\trq.push(l[i]-rs);\n\t\t}\n\t\tyi+=l[i]+ls;\n\t}\n\tlq.push(0);\n\tll i=1, l=lq.top();\n\twhile(lq.size()>1) {\n\t\tlq.pop();\n\t\tyi-=(l-lq.top())*i++;\n\t\tl=lq.top();\n\t}\n\tcout << yi;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename Heap>\nstruct Shifter {\n    using T=typename Heap::value_type;\n\n    Heap h;\n    T s=0;\n    void shift(T x) {\n        s += x;\n    }\n    void push(T x) {\n        h.push(x - s);\n    }\n    T top() {\n        return h.top() + s;\n    }\n    void pop() {\n        h.pop();\n    }\n};\ntemplate<class T> using MaxHeap = Shifter<priority_queue<T>>;\ntemplate<class T> using MinHeap = Shifter<priority_queue<T, vector<T>, greater<T>>>;\n\nusing ll=long long;\nvoid solve() {\n    int n; cin >> n;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        y[i] -= x[i];\n    }\n    \n    MaxHeap<ll> L;\n    MinHeap<ll> R;\n    L.push(x[0]); R.push(x[0]);\n    ll res = 0;\n    for (int i = 1; i < n; i++) {\n        int z = x[i];\n        L.shift(-y[i]);\n        R.shift(y[i-1]);\n        if (L.top() > z) {\n            res += L.top() - z;\n            L.push(z); L.push(z);\n            R.push(L.top());\n            L.pop();\n        } else if (z > R.top()) {\n            res += z - R.top();\n            R.push(z); R.push(z);\n            L.push(R.top());\n            R.pop();\n        } else {\n            L.push(z); R.push(z);\n        }\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nint n, dp[405][405];\nstruct rectangle {\n\tint l, r;\n} r[405];\n\nbool cmp(rectangle x, rectangle y) {\n\treturn x.l < y.l;\n}\n\nint abs(int x) {\n\treturn x > 0 ? x : -x;\n}\n\nint min(int x, int y) {\n\treturn x < y ? x : y;\n}\n\nint max(int x, int y) {\n\treturn x > y ? x : y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d %d\", &r[i].l, &r[i].r);\n\tstd::sort(r + 1, r + n + 1, cmp);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= 400; j++) dp[i][j] = 2e9;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = r[i].r - r[i].l; j <= 400; j++) {\n\t\t\tfor (int k = j - r[i].r + r[i].l; k <= min(400, j + r[i - 1].r - r[i - 1].l); k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - r[i].r));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 2e9;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[n][i]);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = (int) 1e5 + 5;\nconst int mod = (int) 1e9 + 7;\nconst double eps = 1e-9;\n\nint n;\ndouble a[N], b[N];\n\ninline double f (double x) {\n        double r = 0;\n        for (int i = 1; i <= n; i++) {\n                if (a[i] > x) {\n                        r += a[i] - x;\n                } else if (x > b[i]) {\n                        r += x - b[i];\n                }\n        }\n        return r;\n}\n\ninline void solve () {\n        scanf (\"%d\", &n);\n        for (int i = 1; i <= n; i++) {\n                scanf (\"%lf%lf\", &a[i], &b[i]);\n        }\n        double l = 1, r = 1e9;\n        for (int i = 1; i <= 100; i++) {\n                double m1 = (l + l + r) / 3;\n                double m2 = (l + r + r) / 3;\n                if (f (m1) < f (m2)) {\n                        r = m2;\n                } else {\n                        l = m1;\n                }\n        }\n        printf (\"%lld\\n\", (ll) f (l));\n}\n\nint tests = 1;\n\nint main () {\n//        freopen (\".in\", \"r\", stdin);\n//        freopen (\".out\", \"w\", stdout);\n//        scanf (\"%d\", &tests);\n        while (tests--) {\n                solve ();\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n \nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n \n// Problem Specific Parameter:\n \nint n;\nint l[100010],r[100010];\n\nll memo[410][610];\nconst ll inf=1LL<<40;\n \nll rec(int pos,int cl,int cr){\n\tif(pos==n-1) return abs(l[pos]-cl);\n\tll &ret=memo[pos][cl];\n\n\tif(ret>=0) return ret;\n \n\tll cost=abs(cl-l[pos]),cmin=inf;\n \n\tconst ll nlen=abs(r[pos+1]-l[pos+1]);\n\trep(nl,1,601){\n\t\tconst ll nr=nl+nlen;\n\t\tif(nr<cl or cr < nl) continue;\n\t\tchmin(cmin,rec(pos+1,nl,nr));\n\t}\n\tret=cost+cmin;\n\treturn ret;\n}\n \nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> l[i] >> r[i];\n\tif(n>400) return 0;\n\n\trep(i,n+1)rep(j,601) memo[i][j]=-1;\n \n\tconst int len=abs(r[0]-l[0]);\n\tll ans=inf;\n\trep(cl,1,401){\n\t\tconst int cr=cl+len;\n\t\tchmin(ans,rec(0,cl,cr));\n\t}\n \n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// In the name of God\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define Size(x) ((int)(x).size())\n#define pb push_back\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int>pii;\nconst int INF = 1e9 + 10;\nconst int MN = 1e5 + 10;\n\nint n , l[MN] , r[MN] , L[MN] , R[MN];\n\nll get(int a)\n{\n\tll ret = 0;\n\tfor(int i=0;i<n;++i) l[i] = L[i] , r[i] = R[i];\n\tfor(int i=a+1;i<n;++i){\n\t\tif(r[i-1] < l[i]){\n\t\t\tint x = l[i] - r[i-1];\n\t\t\tret += x;\n\t\t\tl[i] -= x , r[i] -= x;\n\t\t}else if(r[i] < l[i-1]){\n\t\t\tint x = l[i-1] - r[i];\n\t\t\tret += x;\n\t\t\tl[i] += x , r[i] += x;\n\t\t}\n\t}\n\tfor(int i=a-1;~i;--i){\n\t\tif(r[i+1] < l[i]){\n\t\t\tint x = l[i] - r[i+1];\n\t\t\tl[i] -= x;\n\t\t\tr[i] -= x;\n\t\t\tret += x;\t\n\t\t}else if(l[i+1] > r[i]){\n\t\t\tint x = l[i+1] - r[i];\n\t\t\tr[i] += x , l[i]+=x;\n\t\t\tret += x;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint32_t main()\n{\n\tios_base :: sync_with_stdio(false) ,cin.tie(0) , cout.tie(0);\n\tcin >> n;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> L[i] >> R[i];\n\tint ql = 0 , qr = n-1;\n\twhile(qr - ql >= 10){\n\t\tint mid1 = (2*ql + qr)/3 , mid2 = (ql + 2*qr)/3;\n\t\tif(get(mid1) < get(mid2)) qr = mid2;\n\t\telse ql = mid1;\n\t}\n\tll ans = (ll)1e18;\n\tfor(int i=ql;i<=qr;++i)\n\t\tans = min(ans , get(i));\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <cstdio>\n#include <queue>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\ntypedef long long ll; \nstd::priority_queue<int> quel;\nstd::priority_queue<int, std::vector<int>, std::greater<int> > quer; \nint l[100005], r[100005]; \nint main()\n{\n\t// freopen(\"ARC070-E.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tll ans = 0, lazy_l = 0, lazy_r = 0; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", l + i, r + i); \n\t\tif (!i)\n\t\t{\n\t\t\tquel.push(l[i]); \n\t\t\tquer.push(l[i]); \n\t\t\tcontinue; \n\t\t}\n\t\tlazy_l -= r[i] - l[i]; \n\t\tlazy_r += r[i - 1] - l[i - 1]; \n\t\tll x = quel.top() + lazy_l, y = quer.top() + lazy_r; \n\t\tif (l[i] < x)\n\t\t{\n\t\t\tans += my_abs(x - l[i]); \n\t\t\tquer.push(x - lazy_r); \n\t\t\tquel.push(l[i] - lazy_l); \n\t\t\tquel.push(l[i] - lazy_l); \n\t\t\tquel.pop(); \n\t\t}\n\t\telse if (l[i] > y)\n\t\t{\n\t\t\tans += my_abs(y - l[i]); \n\t\t\tquel.push(y - lazy_l); \n\t\t\tquer.push(l[i] - lazy_r); \n\t\t\tquer.push(l[i] - lazy_r); \n\t\t\tquer.pop(); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tquel.push(l[i] - lazy_l); \n\t\t\tquer.push(l[i] - lazy_r); \n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REPO(i,n) for(int (i)=1; (i)<=(int)(n); (i)++)\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nstruct SL {\n\tpriority_queue<ll> L;\n\tpriority_queue<ll, vector<ll>, greater<ll>> R;\n\tll ans, rBase, lBase;\n\tSL() : ans(0ll), rBase(0ll), lBase(0ll) {}\n\tvoid addR(int v) {\n\t\trBase += v;\n\t}\n\tvoid addL(int v) {\n\t\tlBase += v;\n\t}\n\tvoid addSL(int x) {\n\t\tL.push(x-lBase); R.push(x-rBase);\n\t\twhile(R.top()+rBase < L.top()+lBase) {\n\t\t\tll l = L.top()+lBase, r = R.top()+rBase;\n\t\t\tans += l-r;\n\t\t\tL.pop(); R.pop();\n\t\t}\n\t}\n};\nint N, Nr[MAX_N][2];\nint main() {\n\tcin >> N;\n\tREP(i, N) REP(j, 2) scanf(\"%d\", &Nr[i][j]);\n\tSL sl;\n\tREP(i, N) {\n\t\tsl.addR(Nr[i][1] - Nr[i][0]);\n\t\tsl.addSL(Nr[i][1]);\n\t\tsl.addL(-(Nr[i][1] - Nr[i][0]));\n\t}\n\tprintf(\"%lld\\n\", sl.ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n#include<valarray>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n#include <boost/multiprecision/cpp_int.hpp>\nnamespace mp = boost::multiprecision;\nusing int128 = mp::int128_t;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <list>\n#include <ostream>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\nint n;\nint l[112345], r[112345], x[112345];\n\nconstexpr ll inf = 1e18;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> x[i] >> r[i], l[i] = r[i] - x[i];\n\n  multiset<ll> st0, st1;\n\n  ll bias0 = 0, bias1 = 0;\n  st0.insert(0);\n  st1.insert(0);\n  bias1 = inf;\n  int128 ans = 0;\n\n  for(int i = 0; i < n; i++) {\n    ll p0 = *prev(st0.end()) + bias0;\n    ll p1 = *st1.begin() + bias1;\n    ans += abs(p0 - x[i]);\n    if(p0 >= x[i]) {\n      st0.insert(x[i] - bias0);\n      st0.insert(x[i] - bias0);\n    } else {\n      st1.insert(x[i] - bias1);\n      st1.insert(x[i] - bias1);\n    }\n    p0 = *prev(st0.end()) + bias0;\n    p1 = *st1.begin() + bias1;\n    while(st0.size() < st1.size()) {\n      st1.erase(st1.begin());\n      st0.insert(p1 - bias0);\n      ans += int128(p1 - p0) * (-i + int(st0.size()) - 3); /// overflowが怖い?\n      p0 = p1;\n      p1 = *st1.begin() + bias1;\n    }\n    while(st0.size() > st1.size()) {\n      st0.erase(prev(st0.end()));\n      st1.insert(p0 - bias1);\n      p1 = p0;\n      p0 = *prev(st0.end()) + bias0;\n      ans -= int128(p1 - p0) * (-i + int(st0.size()) - 3 + 1); ///\n    }\n    assert(st0.size() == st1.size());\n    if(i != n - 1) {\n      bias0 -= l[i+1];\n      bias1 += l[i];\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n\nusing namespace std;\n\nconst int inf = 1e9;\n\nint n;\nvector<int> l, r, len;\n\nint main() {\n\tcin >> n;\n\n\tl.assign(n, 0);\n\tr.assign(n, 0);\n\tlen.assign(n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tlen[i] = r[i] - l[i];\n\t}\n\n\tif (n > 400) {\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (r[i] > 400) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tvector<vector<int>> dp(n, vector<int>(801, inf));\n\tfor (int i = 0; i <= 800; i++) {\n\t\tif (l[0] <= i && i <= r[0]) {\n\t\t\tdp[0][i] = 0;\n\t\t} else {\n\t\t\tdp[0][i] = min(abs(i - l[0]), abs(i - r[0]));\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j <= 800; j++) {\n\t\t\tif (l[i] <= j && j <= r[i]) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j]);\n\t\t\t} else {\n\t\t\t\tfor (int k = 0; k <= 800; k++) {\n\t\t\t\t\tdp[i][j] = min({dp[i][j],\n\t\t\t\t\t                dp[i-1][k] + abs(k - l[i]),\n\t\t\t\t\t                dp[i-1][k] + abs(k - r[i])});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint ans = inf;\n\tfor (int i = 0; i <= 800; i++) {\n\t\tans = min(ans, dp[n - 1][i]);\n\t}\n\tcout << ans << endl;\n\n\t// for (int i = 0; i < n; i++) {\n\t// \tprintf(\"%3d: \", i);\n\t// \tfor (int j = 0; j < 15; j++) {\n\t// \t\tprintf(\"%3d \", dp[i][j]);\n\t// \t}\n\t// \tprintf(\"\\n\");\n\t// }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\n#define int long long\n#define double long double\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\ntemplate<class T> string tostr(T x) { stringstream o; o << x; return o.str(); }\ntemplate<class T> T sqr(T x) { return x*x; }\ntemplate<class T> T mypow(T x, int n) { T r = 1; while (n > 0) { if (n & 1)r = r*x; x = x*x; n >>= 1; }return r; }\n\nint toint(string s) { int v; stringstream i(s); i >> v; return v; }\nbool check(int x, int y, int w, int h) { return x >= 0 && y >= 0 && w > x && h > y; }\nint gcd(int a, int b) { return b ? gcd(b, a%b) : a; }\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\n\n#define REP(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tREP(i,0,n)\n#define PER(i,a,b)\tfor(int (i) = (a-1);i >= (b);(i)--)\n#define per(i,n)\tPER(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define dum(val)\tcerr << #val \" = \" << val;\n#define FILL(a,v)\tfill(a,a+sizeof(a)/sizeof(*a),v)\n\nconst int dx[8] = { +1,+0,-1,+0,+1,+1,-1,-1 };\nconst int dy[8] = { +0,-1,+0,+1,-1,+1,-1,+1 };\nconst int mod = 1e9 + 7;\nconst int INF = 1e17 + 9;\n\nint dp[401][401];\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tif (n > 400)return 0;\n\tvector<int> l(n), r(n), sz(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tsz[i] = r[i] - l[i];\n\t\tif (l[i] > 400 || r[i] > 400)return 0;\n\t}\n\n\trep(i, 401)rep(j, 401)dp[i][j] = INF;\n\n\n\tfor (int i = l[0] - 1, c = 1; i >= 0; i--, c++) {\n\t\tdp[0][i] = c;\n\t}\n\tfor (int i = l[0], c = 0; i <= 400; i++, c++) {\n\t\tdp[0][i] = c;\n\t}\n\n\tREP(j, 1, n) {\n\t\tfor (int i = l[j] - 1, c = 1; i >= 0; i--, c++) {\n\t\t\tfor (int k = max(0ll, i - sz[j - 1]); k <= min(400ll, i + sz[j]); k++) {\n\t\t\t\tdp[j][i] = min(dp[j][i], c + dp[j - 1][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = l[j], c = 0; i <= 400; i++, c++) {\n\t\t\tfor (int k = max(0ll, i - sz[j - 1]); k <= min(400ll, i + sz[j]); k++) {\n\t\t\t\tdp[j][i] = min(dp[j][i], c + dp[j - 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i <= 400; i++) {\n\t\tans = min(ans, dp[n - 1][i]);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) //cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) //cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vll l(n), r(n), width(n);\n  rep (i, n) {\n    scanf(\"%lld%lld\", &l[i], &r[i]);\n    width[i] = r[i] - l[i];\n  }\n  ll left_offset, right_offset;\n  left_offset = right_offset = 0;\n  ll minval = 0;\n  set<ll> left;\n  left.insert(l[0]);\n  auto right = left;\n\n  FOR (i, 1, n) {\n    left_offset -= width[i];\n    right_offset += width[i-1];\n    debug2(left_offset, right_offset);\n    auto min_left = --end(left);\n    auto min_right = begin(right);\n    debug2(*min_left, *min_right);\n    debug(minval);\n    if (*min_left + left_offset <= l[i] && l[i] <= *min_right + right_offset) {\n      left.insert(l[i] - left_offset);\n      right.insert(l[i] - right_offset);\n    } else {\n      if (l[i] < *min_left + left_offset) {\n        minval += *min_left + left_offset - l[i];\n\n        right.insert(*min_left + left_offset - right_offset);\n        left.erase(min_left);\n        left.insert(l[i] - left_offset);\n        left.insert(l[i] - left_offset);\n      } else {\n        minval += l[i] - (*min_right + right_offset);\n\n        left.insert(*min_right + right_offset - left_offset);\n        right.erase(min_right);\n        right.insert(l[i] - right_offset);\n        right.insert(l[i] - right_offset);\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", minval);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n#include <set>\n\nusing namespace std;    \n\nstatic int getMinCost(multiset<int> nodes,\n\t       int curmincost,\n\t       int minpos)\n{\n    if (nodes.size() == 0) {\n\treturn curmincost;\n    }\n    \n    int len = nodes.size();\n    auto ll = nodes.begin();\n    for (int i = 0; i < len / 2 - 1; i++) {\n\tll++;\n    }\n    auto rf = ll;\n    rf++;\n\n    //cout << *rf << \" \" << *ll << \" \" << minpos << endl;\n    if (*ll <= minpos) {\n\tif (minpos <= *rf) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - *rf + curmincost;\n    } else {\n\treturn *ll - minpos + curmincost;\n    }\n}\n\nint main(void){\n    int n;\n    int mincost;\n    multiset<int> nodes;\n    stringstream st;\n    string line;\n    vector<pair<int, int>> rects;\n\n    \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n    for (int i = 0; i < n; i++) {\n\tint l, r;\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> l >> r;\n\trects.push_back(pair<int, int>(l, r));\n    }\n\n    mincost = 0;\n\n    for (int i = 1; i < n; i++) {\n\tint l = rects[i - 1].first;\n\tint r = rects[i - 1].second;\n\tint nl = rects[i].first;\n\tint nr = rects[i].second;\n\tmincost = getMinCost(nodes, mincost, l);\n\t//cout << l << \" \" << r << \" \" << mincost << endl;\n\tnodes.insert(l);\n\tnodes.insert(l);\t\n\tint len = nodes.size();\n\tint j = 0;\n\tmultiset<int> nns;    \n\tfor (auto &e : nodes) {\n\t    int nv = 0;\n\t    if (j < len / 2) {\n\t\tnv = e - (nr - nl);\n\t    } else {\n\t\tnv = e + (r - l);\n\t    }\n\t    nns.insert(nv);\n\t    j++;\n\t}\n\tnodes = nns;\n\t#if 0\n\tfor (auto e : nodes) {\n\t    cout << e << \" \";\n\t}\n\tcout << endl;\n\t#endif\t\n\t\n    }\n    mincost = getMinCost(nodes, mincost, rects[n - 1].first);\n\n    cout << mincost << endl;\n    return 0;\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nconst int MOD = 1000000007;\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nint n;\nint l[410];\nint r[410];\n\nint dp[410][410];\n\nbool overwrap(int l1, int r1, int l2, int r2) {\n    if (r1 < l2) return false;\n    if (r2 < l1) return false;\n    return true;\n}\n\nconst int INF = 1e18;\n\nsigned main() {\n    while(cin >> n){\n        rep (i, n) cin >> l[i] >> r[i];\n        fill((int*)begin(dp), (int*)end(dp), INF);\n        rep (i, 401) {\n            dp[1][i] = abs(i - l[0]);\n        }\n        rep (i, n) if(i) {\n            rep (j, 401) {\n                rep (k, 401) {\n                    if (overwrap(j, j + r[i-1] - l[i-1],\n                                 k, k + r[i] - l[i])) {\n                        dp[i+1][k] = min(dp[i+1][k], dp[i][j] + abs(k - l[i]));\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        rep (i, 401) ans = min(ans, dp[n][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll N;\n    cin >> N;\n\n    assert(N <= 400);\n\n    struct Rect {\n        ll l, r;\n        ll width() {\n            return r - l;\n        }\n    };\n\n    constexpr ll MAX = 400;\n\n    vector<Rect> rects(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> rects[i].l >> rects[i].r;\n        assert(rects[i].l <= MAX);\n    }\n\n    vector<vector<ll>> dp(N + 1, vector<ll>(MAX + 1, INT_MAX));\n    for (ll j = 0; j <= MAX; j++) {\n        dp[0][j] = 0;\n    }\n    for (ll i = 1; i <= N; i++) {\n        for (ll j = 0; j <= 400 - rects[i - 1].width(); j++) {\n            for (ll k = max(j - (i == 1 ? 0 : rects[i - 1].width()), (ll)0); k <= min(j + rects[i - 1].width(), MAX); k++) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(rects[i - 1].l - j));\n            }\n        }\n    }\n\n    cout << *min_element(dp[N].begin(), dp[N].end()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 101000\n#define intl long long\nusing namespace std;\n\nintl p[maxn * 2];\nintl L[maxn], R[maxn];\nintl now, offsetl, offsetr;\nint n, top;\n\nstruct cmp {\n\tbool operator () (int a, int b) {\n\t\treturn (p[a] > p[b] || (p[a] == p[b] && a < b));\n\t}\n};\n\nset<int, cmp> ldot;\n\nstruct pmc {\n\tbool operator () (int a, int b) {\n\t\treturn (p[a] < p[b] || (p[a] == p[b] && a < b));\n\t}\n};\n\nset<int, pmc> rdot;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld %lld\",&L[i], &R[i]);\n\tp[++top] = L[1]; ldot.insert(top);\n\tp[++top] = L[1]; rdot.insert(top);\n\tnow = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tintl pas = now;\n\t\tintl x = L[i];\n\t\toffsetl -= (R[i] - L[i]);\n\t\toffsetr += (R[i - 1] - L[i - 1]);\n\t\tif (x >= p[*ldot.begin()] + offsetl && x <= p[*rdot.begin()] + offsetr) {\n\t\t\tp[++top] = x - offsetl;\n\t\t\tldot.insert(top);\n\t\t\tp[++top] = x - offsetr;\n\t\t\trdot.insert(top);\n\t\t\tnow = pas;\n\t\t}\n\t\telse if (x < p[*ldot.begin()] + offsetl) {\n\t\t\tp[++top] = x - offsetl;\n\t\t\tldot.insert(top);\n\t\t\tp[++top] = x - offsetl;\n\t\t\tldot.insert(top);\n\t\t\tnow = pas + (intl) (p[*ldot.begin()] + offsetl - x);\n\t\t\tint k = *ldot.begin();\n\t\t\tldot.erase(ldot.begin());\n\t\t\tp[k] += offsetl - offsetr;\n\t\t\trdot.insert(k);\n\t\t} else {\n\t\t\tp[++top] = x - offsetr;\n\t\t\trdot.insert(top);\n\t\t\tp[++top] = x - offsetr;\n\t\t\trdot.insert(top);\n\t\t\tnow = pas + (intl) (x - p[*rdot.begin()] - offsetr);\n\t\t\tint k = *rdot.begin();\n\t\t\trdot.erase(rdot.begin());\n\t\t\tp[k] += offsetr - offsetl;\n\t\t\tldot.insert(k);\n\t\t}\n\t}\n\n\tcout << now << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nmultiset<int> LS, RS;\nint L[100010], R[100010];\nsigned main(){\n\tint n, fl = 0, fr = 0, ans = 0;\n\tscanf(\"%lld\", &n);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld%lld\", &L[i], &R[i]);\n\t\n\tLS.insert(-1e17);\n\tRS.insert(1e17);\n\tfor(int i = 0;i < n;i++){\n\t\tif(i){\n\t\t\tfl -= R[i]-L[i];\n\t\t\tfr += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i] < *LS.rbegin()+fl){\n\t\t\tans += *LS.rbegin()+fl-L[i];\n\t\t\tRS.insert(*LS.rbegin()+fl-fr);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tLS.insert(L[i]-fl);\n\t\t}else if(*RS.begin()+fr < L[i]){\n\t\t\tans += L[i]-(*RS.begin()+fr);\n\t\t\tLS.insert(*RS.begin()+fr-fl);\n\t\t\tRS.erase(RS.begin());\n\t\t\tRS.insert(L[i]-fr);\n\t\t\tRS.insert(L[i]-fr);\n\t\t}else{\n\t\t\tLS.insert(L[i]-fl);\n\t\t\tLS.insert(L[i]-fr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = 1;i <= n;i++)\n\t\tans = min(  ans  ,  dp(1,l[i])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int, int> ii;\nconst int infinity = 1e18;\n\nint number;\nii segment[100001];\nint f[401][401];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> number;\n\tfor (int i = 1; i <= number; i++)\n\t\tcin >> segment[i].first >> segment[i].second;\n\tfor (int i = 0; i <= 400; i++)\n\t\tfor (int j = 0; j <= 400; j++)\n\t\t\tf[i][j] = infinity;\n\tfor (int j = 1; j <= 400; j++)\t\n\t{\n\t\tint l = segment[1].first, r = segment[1].second;\n\t\tf[1][j] = ((l <= j && j <= r) ? 0 : (j < l) ? l - j : j - r);\n\t}\n\tfor (int i = 2; i <= number; i++)\n\t\tfor (int j = 1; j <= 400; j++)\n\t\t{\n\t\t\tint l = segment[i].first, r = segment[i].second;\n\t\t\tint cost = ((l <= j && j <= r) ? 0 : (j < l) ? l - j : j - r);\n\t\t\tint segment_length = r - l + 1;\n\t\t\tfor (int k = max(1LL, l - segment_length); k <= r; k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[i - 1][k] + cost);\n\t\t}\n\n\tint answer = infinity;\n\tfor (int i = 1; i <= 400; i++)\n\t\tanswer = min(answer, f[number][i]);\n\tcout << answer;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int64_t i, j, k;\n    int N;\n    cin >> N;\n    const int MAX = 100000;\n    int64_t L[MAX], R[MAX];\n    for(i=0; i<N; i++) cin >> L[i] >> R[i];\n\n    int64_t ans = 0, loffset = 0, roffset = 0;\n    set<int64_t> lpt, rpt;\n    lpt.insert(L[0]);\n    rpt.insert(L[0]);\n\n    for(i=1; i<N; i++){\n        loffset -= R[i] - L[i];\n        roffset += R[i-1] - L[i-1];\n        int64_t ledge = *prev(lpt.end()) + loffset;\n        int64_t redge = *rpt.begin() + roffset;\n        if(L[i] < ledge){\n            ans += ledge - L[i];\n            lpt.erase(prev(lpt.end()));\n            rpt.insert(ledge - roffset);\n            for(k=0; k<2; k++) lpt.insert(L[i] - loffset);\n        }else if(redge < L[i]){\n            ans += L[i] - redge;\n            rpt.erase(rpt.begin());\n            lpt.insert(redge - loffset);\n            for(k=0; k<2; k++) rpt.insert(L[i] - roffset);\n        }else{\n            lpt.insert(L[i] - loffset);\n            rpt.insert(L[i] - roffset);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vl l(n),r(n);\n    rep(i,n){\n        cin >> l[i] >> r[i];\n    }\n    multiset<ll> lv={l[0]}, rv={l[0]};\n    ll ans = 0, lsum = 0, rsum = 0;\n    rep(i,n-1){\n        lsum += r[i+1]-l[i+1];\n        rsum += r[i] - l[i];\n        if(l[i+1] < *(--lv.end()) - lsum){\n            ans += *(--lv.end()) - lsum - l[i+1];\n            rv.insert(*(--lv.end())-lsum-rsum);\n            lv.erase((--lv.end()));\n            lv.insert(l[i+1]+lsum), lv.insert(l[i+1]+lsum);\n        }else if(l[i+1] > *(rv.begin()) + rsum){\n            ans += l[i+1] - *(rv.begin()) - rsum;\n            lv.insert(*rv.begin()+rsum+lsum);\n            rv.erase(rv.begin());\n            rv.insert(l[i+1]-rsum), rv.insert(l[i+1]-rsum);\n        }else{\n            lv.insert(l[i+1]+lsum), rv.insert(l[i+1]-rsum);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\n\n#define dbg(x1) cout<<#x1<<\" = \"<<(x1)<<endl\n#define dbg2(x1,x2) cout<<#x1<<\" = \"<<(x1)<<\" \"<<#x2<<\" = \"<<(x2)<<endl\n#define dbg3(x1,x2,x3) cout<<#x1<<\" = \"<<(x1)<<\" \"<<#x2<<\" = \"<<(x2)<<\" \"<<#x3<<\" = \"<<(x3)<<endl\nint n;\nint l[maxn],r[maxn],l2[maxn],r2[maxn];\nint solve(int a,int b,int &c,int &d)\n{\n    if(b<c)\n    {\n        int tt=c-b;\n        c-=tt;\n        d-=tt;\n        return tt;\n    }\n    else if(a>d)\n    {\n        int tt=a-d;\n        d+=tt;\n        c+=tt;\n        return tt;\n    }\n    else return 0;\n}\nll f(int x)\n{\n    ll ans=0;\n    for(int i=1;i<=n;i++) l2[i]=l[i],r2[i]=r[i];\n    ans+=abs(l2[1]-x);\n    if(l2[1]>=x)\n    {\n        int tt=l2[1]-x;\n        l2[1]-=tt;\n        r2[1]-=tt;\n    }\n    else\n    {\n        int tt=x-l2[1];\n        l2[1]+=tt;\n        r2[1]+=tt;\n    }\n    for(int i=2;i<=n;i++)\n    {\n        ans+=solve(l2[i-1],r2[i-1],l2[i],r2[i]);\n    }\n    return ans;\n}\nint main() {\n    //freopen(\".in\", \"r\", stdin);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n    int l=0,r=1000000000;\n    while(l<r-1)\n    {\n        int mid=(l+r)/2;\n        int mmid=(mid+r)/2;\n        if(f(mid)<f(mmid)) r=mmid;\n        else l=mid;\n    }\n    ll ans=min(f(l),f(r));\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//部分点\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#define int long long\nusing namespace std;\n\nconst int MAX = 500;\nint n;\nint l[400], r[400];\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tif (n > 400) {\n\t\tassert(0);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (r[i] > MAX) {\n\t\t\tassert(0);\n\t\t}\n\t}\n\t\n\tint ans = MAX * MAX;\n\t\n\tfor (i = 0; i <= n * MAX; i++) {\n\t\tdouble cst = 1e-10;\n\t\tdouble y = i / (double)n;\n\t\t\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (y < l[j]) {\n\t\t\t\tcst += l[j] - y;\n\t\t\t}\n\t\t\telse if (y <= r[j]) {\n\t\t\t\tcst += 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcst += y - r[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = min(ans, (int)cst);\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF=1e9+7;\nint l[405],r[405];\nint dp[405][405];\nint ABS(int x){\n\treturn x<0?-x:x;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep1(k,n)scanf(\"%d%d\",&l[k],&r[k]);\n\trep1(k,n){\n\t\trep1(i,400-(r[k]-l[k])){\n\t\t\tdp[k][i]=INF;\n\t\t\tfor(int j=max(i-(r[k-1]-l[k-1]),1);j<=i+(r[k]-l[k]);j++)\n\t\t\tdp[k][i]=min(dp[k][i],dp[k-1][j]+ABS(l[k]-i));\n\t\t}\n\t}\n\tint ans=INF;\n\trep1(k,400-(r[n]-l[n]))ans=min(ans,dp[n][k]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nbool sub = true;\n\nconst int INF = INT_MAX / 3;\nint dp[401][401];\nvoid subtask(int N, vi &L, vi &R) {\n    rep(i, 401)rep(j, 401)dp[i][j] = INF;\n    rep(x, 401) {\n        dp[1][x] = abs(x - L[0]);\n    }\n\n    FOR(i, 1, N) {\n        rep(x, 401) {\n            int l = x, r = R[i - 1] - L[i - 1] + x;\n            rep(nx, 401) {\n                int nl = nx, nr = R[i] - L[i] + nx;\n                if (nr < l || r < nl) {\n                    continue;\n                }\n                smin(dp[i + 1][nx], dp[i][x] + abs(nx - L[i]));\n            }\n        }\n    }\n    int ans = INF;\n    rep(i, 401)smin(ans, dp[N][i]);\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N;\n    cin >> N;\n    sub &= N <= 400;\n    vi L(N), R(N);\n\n    rep(i, N) {\n        cin >> L[i] >> R[i];\n        sub &= R[i] <= 400;\n    }\n\n    if (sub) {\n        subtask(N, L, R);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#define For(i, a, b) for (int i = a; i < b; ++i)\n#define Out(i, a, b) for (int i = a - 1; i >= b; --i)\n#define pb push_back\n#define x first\n#define y second\n#define files(FileName) read(FileName); write(FileName)\n#define read(FileName) freopen((FileName + \".in\").c_str(), \"r\", stdin)\n#define write(FileName) freopen((FileName + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \n  \nconst string FileName = \"input\";\n \ntypedef long long base;\n \nconst int MAXN = 2e4;\n \n int n;\nint LR[401][2];\nint dp[401][401];\n\nint main() {\n    ios::sync_with_stdio(0);\n    //read(FileName);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> LR[i][0] >> LR[i][1];\n        --LR[i][0], --LR[i][1];\n    }\n    for (int i = 0; i < 400; ++i) {\n        for (int j = 0; j < 400; ++j) {\n            dp[i][j] = 1e9;\n        }\n    }\n    for (int i = 0; i < 400; ++i) {\n        dp[0][i] = abs(i - LR[0][0]);\n    }\n    for (int i = 1; i < n; ++i) {\n        int Ln = LR[i][0], Rn = LR[i][1];\n        for (int j = 0; j < 400; ++j) {\n            // if (j <= 5) {\n            //     cout << i - 1 << ' ' << j << ' ' << dp[i - 1][j] << endl; \n            // }\n            // int L = j, R = j - LR[i][0] + LR[i][1];\n            // if (j <= 5) {\n            //     cout << Ln << ' ' << Rn << ' ' << L << ' ' << R << endl;\n            // }\n            if (max(L, Ln) <= min(R, Rn)) {\n                chkmin(dp[i][L], dp[i - 1][j]);\n                for (int q = Ln - R + L; q <= Rn; ++q) {\n                    if (q >= 0 && q <= 399)\n                        chkmin(dp[i][q], dp[i - 1][q] + abs(q - L));\n                }\n            } else {\n                if (R < Ln) {\n                    for (int q = Ln - R + L, d = Ln - R; q <= Rn; ++q, ++d) {\n                        if (q >= 0 && q <= 399)\n                            chkmin(dp[i][q], dp[i - 1][q] + d);\n                    }\n                } else {\n                    for (int q = Rn, d = L - Rn; q - L + R >= Ln; --q, ++d) {\n                        if (q >= 0 && q <= 399) \n                            chkmin(dp[i][q], dp[i - 1][q] + d);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    for (int i = 0; i < 399; ++i) {\n        chkmin(ans, dp[n - 1][i]);\n    }\n    cout << ans << endl;\n}  \n \n/*\n2 AB 11\n2!2\n3 ABB 122\n3!3\n4 ABB 2222\n4!3\n5 ABBBB 12222\n5!5\n6 ABBB 121222\n6!4\n7 ABBBB 1212122\n7!5\n8 ABBB 12121212\n8!4\n9 ABBBBBBBB 122222222\n9!9\n10 ABBBBB 1212222222\n10!6\n11 ABBBBBBBB 12121222222\n11!9\n12 ABBBBB 121212122222\n12!6\n13 ABBBBBBBB 1212121212222\n13!9\n14 ABBBBB 12121212121222\n14!6\n15 ABBBBBBBB 121212121212122\n15!9\n16 ABBBBB 1212121212121212\n16!6\n17 ABBBBBBBBBBBBBBBB 12222222222222222\n17!17\n18 ABBBBBBBBB 121222222222222222\n18!10\n19 ABBBBBBBBBBBBBBBB 1212122222222222222\n19!17\n20 ABBBBBBBBB 12121212222222222222\n20!10\n[Finished in 3.1s]\n*/"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 1e5 + 1e3;\n\nint n, l[N], r[N], len[N];\n\nll tl, tr, ans;\n\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll>> R;\n\nint main () {\n\n\tFile();\n\n\tFor (i, 1, n = read()) \n\t\tl[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n\n\tL.push(r[1]); R.push(r[1]);\n\tFor (i, 2, n) {\n\t\ttl -= len[i - 1]; tr += len[i];\n\t\tll lp = L.top() + tl, rp = R.top() + tr;\n\t\tif (lp <= r[i] && r[i] <= rp) \n\t\t\tL.push(r[i] - tl), R.push(r[i] - tr);\n\t\telse if (r[i] >= rp) {\n\t\t\tans += r[i] - rp; R.pop(); L.push(rp - tl);\n\t\t\tR.push(r[i] - tr); R.push(r[i] - tr);\n\t\t} else {\n\t\t\tans += lp - r[i]; L.pop(); R.push(lp - tr);\n\t\t\tL.push(r[i] - tl); L.push(r[i] - tl);\n\t\t}\n\t}\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n \nusing namespace std;\n \nint n;\n \nint l[405],r[405];\nint d[405][405];\n \nint go(int now,int leftx){\n    if(now == n) return 0;\n    \n    int &ans = d[now][leftx];\n    if(ans!=-1) return ans;\n    int rightend = leftx + r[now-1]-l[now-1];\n    ans = 987654321;\n    for(int k=1;k<=400;k++){\n        \n        int rnew = k + r[now] - l[now];\n        if(rnew < leftx || rnow < k) continue;\n        //if(max(k,leftx) <= min(rnew,rightend)){\n            ans = min(ans,go(now+1,k) + abs(k-l[now]));\n        //}\n    }\n    return ans;\n}\n \nint main()\n{\n    scanf(\"%d\",&n);\n    if(n>=401) return 0;\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d %d\",&l[i],&r[i]);\n    }\n    memset(d,-1,sizeof(d));\n    int res = 987654321;\n    for(int i=1;i<=400;i++){\n        res = min(res,go(1,i)+abs(i-l[0]));\n    }\n    printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "解説見た(2回目)\nCHTかなーとか考えた"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define fi(a,b) for(int i=a;i<b;++i)\ntypedef long long ll;\n////////////////////\n\nint const N = 1e5 + 41;\n\nint n, l[N], r[N];\nmultiset<ll> t0, t1;\nll ans, add0, add1;\n\nll getmin(multiset<ll> &t){\n\tmultiset<ll> :: iterator it = t.begin();\n\treturn (*it);\n}\n\nll extractmin(multiset<ll> &t){\n\tmultiset<ll> :: iterator it = t.begin();\n\tll res = (*it);\n\tt.erase(it);\n\treturn res;\n}\n\nll getmax(multiset<ll> &t){\n\tauto it = t.end();\n\t--it;\n\treturn (*it);\n}\n\nll extractmax(multiset<ll> &t){\n\tauto it = t.end();\n\t--it;\n\tll res = (*it);\n\tt.erase(it);\n\treturn res;\n}\n\nvoid solve(){\n\tt0.insert(l[0]);\n\tt1.insert(l[0]);\n\tfi(1, n){\n\t\tadd0 += -(r[i] - l[i]);\n\t\tadd1 += (r[i-1] - l[i-1]);\n\t\tll x0 = add0 + getmax(t0);\n\t\tll x1 = add1 + getmin(t1);\n\t\tif(x0 <= l[i] && l[i] <= x1){\n\t\t\tt0.insert(l[i] - add0);\n\t\t\tt1.insert(l[i] - add1);\n\t\t}else{\n\t\t\tif(l[i] < x0){\n\t\t\t\tans += x0 - l[i];\n\t\t\t\tt0.insert(l[i] - add0);\n\t\t\t\tt0.insert(l[i] - add0);\n\t\t\t\textractmax(t0);\n\t\t\t\tt1.insert(x0);\n\t\t\t\tt1.insert(x0);\n\t\t\t}else{\n\t\t\t\tans += l[i] - x1;\n\t\t\t\tt1.insert(l[i] - add1);\n\t\t\t\tt1.insert(l[i] - add1);\n\t\t\t\textractmin(t1);\n\t\t\t\tt0.insert(x1);\n\t\t\t\tt0.insert(x1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d\",&n);\n\tfi(0, n) scanf(\"%d %d\",&l[i],&r[i]);\n\n\tsolve();\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(ll)(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) reps(i,0,((n)+1))\n#define repst(i,s,n) reps(i,s,((n)+1))\n#define reprt(i,n,t) for(ll (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ');}}\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// dp[i][x]: 上からi個までの長方形を動かしていてi個目の長方形の横座標をxに動かした時点でのそこまでのコストの最小値\n// dp[i][x] = |x-l[i]| + min dp[i-1][x'] (x-(r[i-1]-l[i-1]) <= x' <= x+(r[i]-l[i]))\n// これでO(nx^2) 部分点\n//\n// dp[i-1]からdp[i]を求めるには以下の操作ができればいい\n// 1) x軸方向に平行移動\n// 2) ある一定長さの区間のminを取る\n// 3) |x-l[i]|を足す\n// dpの式に着目する dp[i]の式は|x-l|という形の式をi個足し合わせたものなので、下に凸で、\n// 傾きはxが-∞のとき-i、そこから徐々に傾きが大きくなっていき、0になる範囲を経由し、xが∞のときiになる\n// iが増える(|x-l|という形の式が増える)に連れて傾き0の部分が広がり、そのぶんだけ傾き負の部分は左にスライドし、正の部分は右にスライドする\n// 移動量の総和を最小化するには各矩形は傾きが0の範囲のxのうち一番近い場所に移動すればいい\n// 傾きが変わる点をset(正負で分ける)に入れといて、0の範囲が増える度に更新する\n\nll n, l[114514], r[114514];\nmultiset<ll> le, ri;\nll ls, rs, ans;\n\nsigned main() {\n\tcin >> n;\n\trep(i,n) cin >> l[i] >> r[i];\n\tls = l[0], rs = l[0];\n\tle.insert(l[0]), ri.insert(l[0]);\n\treps(i,1,n) {\n\t\tls -= r[i]-l[i], rs += r[i-1]-l[i-1];\n\t\tll a = *le.rbegin(), b = *ri.begin();\n\t\tif (ls<=l[i] && l[i]<=rs) {\n\t\t\tle.insert(l[i]-(ls-a));\n\t\t\tri.insert(l[i]-(rs-b));\n\t\t\tls = l[i], rs = r[i];\n\t\t} else if (l[i]<ls) {\n\t\t\tans += abs(l[i]-ls);\n\t\t\tle.insert(l[i]-(ls-a));\n\t\t\tle.insert(l[i]-(ls-a));\n\t\t\tll left = *le.rbegin() + (ls-a);\n\t\t\tle.erase(--le.end());\n\t\t\tri.insert(left-(rs-b));\n\t\t\tls = *le.rbegin() + (ls-a);\n\t\t\trs = left;\n\t\t} else {\n\t\t\tans += abs(l[i]-rs);\n\t\t\tri.insert(l[i]-(rs-b));\n\t\t\tri.insert(l[i]-(rs-b));\n\t\t\tll right = *ri.begin() + (rs-b);\n\t\t\tri.erase(ri.begin());\n\t\t\tle.insert(right - (ls-a));\n\t\t\tls = right;\n\t\t\trs = *ri.begin() + (rs-b);\n\t\t}\n\t\t//cout << i << ' ' << ans << ln;\n\t}\n\tcout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nconst int M = 1e9 + 7;\nconst ll MLL = 1e18L + 9;\n#pragma unused(M)\n#pragma unused(MLL)\n#ifdef LOCAL\n#include\"rprint.hpp\"\n#else\ntemplate <class... T> void printl(T&&...){ }\ntemplate <class... T> void printc(T&&...){ }\ntemplate <class... T> void prints(T&&...){ }\ntemplate <class... T> void printd(T&&...){ }\n#endif\n\nint main(){\n    int n; cin >> n;\n    if(n > 400){ return 1; }\n    vector<vector<int>> dp(n, vector<int> (500, M));\n    int l, r;\n    cin >> l >> r;\n    int w = r - l;\n    for(int j=0;j<=400;j++){\n        dp[0][j] = abs(l - j);\n    }\n    int pw = w;\n    for(int i=1;i<n;i++){\n        cin >> l >> r;\n        if(l > 400 || r > 400){ return 1; }\n        w = r - l;\n        for(int j=0;j<=400;j++){\n            for(int k=max(0, j - pw);k<=min(400, j + w);k++){\n                dp[i][j] = min(dp[i][j], abs(l - j) + dp[i-1][k]);\n            }\n        }\n        pw = w;\n    }\n    int ans = M;\n    for(int j=0;j<=400;j++){\n        ans = min(ans, dp[n-1][j]);\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    vec l(N), r(N), d(N);\n    REP(i, N){\n        cin >> l[i] >> r[i];\n        d[i] = r[i] - l[i];\n    }\n\n    mat dp(N, vec(401, INF));\n    REP(i, 401){\n        dp[0][i] = llabs(i - l[0]);\n    }\n    FOR(i, 1, N){\n        REP(j, 401){\n            //dp[i][j]\n            FOR(k, max(0LL, j - d[i - 1]), min(401LL, j + d[i] + 1)){\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + llabs(j - l[i]));\n            }\n        }\n    }\n    int ans = INF;\n    REP(i, 401) ans = min(ans, dp[N - 1][i]);\n    cout << ans; \n\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nll n;\nll a[N],b[N],l[N],r[N];\nll sp,tp;\npriority_queue<ll> S;\npriority_queue<ll,vector<ll>,greater<ll> >T;\nll Sf(){\n  return S.top()+sp;\n}\nll Tf(){\n  return T.top()+tp;\n}\nvoid Sp(ll x){\n  S.push(x-sp);\n}\nvoid Tp(ll x){\n  T.push(x-tp);\n}\nint main(){\n    cin>>n;\n    if(n>N)return 0;\n    for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n    for(int i=1;i<n;i++){\n      a[i]=l[i]-r[i-1];\n      b[i]=r[i]-l[i-1];\n    }\n    ll ans=0; sp=tp=0;\n    Sp(0); Tp(0);\n    Sp(-1e17); Tp(1e17);\n    for(int i=1;i<n;i++){\n      sp-=b[i],tp-=a[i];\n      ll s0=Sf();\n      ll t0=Tf();\n      if(s0<=0&&0<=t0){\n\tSp(0); Tp(0);\n      }\n      if(0<s0){\n\tSp(0); Sp(0);\n      }\n      if(t0<0){\n\tTp(0); Tp(0);\n      }\n      \n      while(Sf()>0){\n\tTp(Sf());\n\tS.pop();\n      }\n      while(Tf()<0){\n\tSp(Tf());\n\tT.pop();\n      }\n      ans+=Tf()-Sf();\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(l[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    dL-=r[i-1]-l[i-1];\n    dR+=r[i]-l[i];\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(r[i]<dL+*latte){\n      \n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      \n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 400 + 5\n#define M 400\n#define inf 123456789\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, ans, l[N], r[N], len[N], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint main(){\n    n = read();\n    rep(i, 1, n) l[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n    memset(dp, 0x7f, sizeof(dp));\n    rep(i, 1, M) dp[1][i] = abs(l[1] - i);\n    rep(i, 2, n) rep(j, 1, M) rep(k, max(1, j - len[i - 1]), min(M, j + len[i])) dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - l[i]));\n    ans = inf;\n    rep(i, 1, M) ans = min(ans, dp[n][i]);\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[405][405];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=0;i<405;i++)\n\t\t\tfor(int j=0;j<405;j++)\n\t\t\tdp[i][j]=1e9;\n\t\tfor(int i=1;i<405;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tassert(l>=1&&l<=400);\n\t\t\tassert(r>=1&&r<=400);\n\t\t\tfor(int j=1;j<405;j++)\n\t\t\t{\n\t\t\t\tint aa=0;\n\t\t\t\tif(j<l)\n\t\t\t\taa=l-j;\n\t\t\t\telse if(j>r)\n\t\t\t\taa=j-r;\n\t\t\t\tfor(int k=max(j-(r-l),1);k<min(405,j+(r-l));k++){\n\t\t\t\t\tif(k<l)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(l-k,aa));\n\t\t\t\t\telse if(k>r)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(k-r,aa));\n\t\t\t\t\telse \n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+aa);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<405;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e9+1\nusing namespace std;\n\nconst int maxn = 210000;\n\nint n;\nmultiset<ll>ql,qr;\nll L,R,len,re;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,las=0;i<=n;i++,las=len)\n\t{\n\t\tll l,r; scanf(\"%lld%lld\",&l,&r);\n\t\tlen=r-l;\n\t\tif(i==1)\n\t\t{\n\t\t\tql.insert(-inf); ql.insert(l);\n\t\t\tqr.insert(inf); qr.insert(l);\n\t\t\tcontinue;\n\t\t}\n\t\tL-=len,R+=las;\n\t\tll pl=*ql.rbegin()+L,pr=*qr.begin()+R;\n\t\tif(l<pl)\n\t\t{\n\t\t\tql.insert(l-L); ql.insert(l-L);\n\t\t\tql.erase(*ql.rbegin());\n\t\t\tre+=pl-L-*ql.rbegin();\n\t\t\tqr.insert(pl-R);\n\t\t}\n\t\telse if(l<=pr)\n\t\t\tql.insert(l-L),qr.insert(l-R);\n\t\telse\n\t\t{\n\t\t\tqr.insert(l-R),qr.insert(l-R);\n\t\t\tqr.erase(*qr.begin());\n\t\t\tre+=*qr.begin()+R-pr;\n\t\t\tql.insert(pr-L);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\n#define int long long\n#define double long double\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\ntemplate<class T> string tostr(T x) { stringstream o; o << x; return o.str(); }\ntemplate<class T> T sqr(T x) { return x*x; }\ntemplate<class T> T mypow(T x, int n) { T r = 1; while (n > 0) { if (n & 1)r = r*x; x = x*x; n >>= 1; }return r; }\n\nint toint(string s) { int v; stringstream i(s); i >> v; return v; }\nbool check(int x, int y, int w, int h) { return x >= 0 && y >= 0 && w > x && h > y; }\nint gcd(int a, int b) { return b ? gcd(b, a%b) : a; }\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\n\n#define REP(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tREP(i,0,n)\n#define PER(i,a,b)\tfor(int (i) = (a-1);i >= (b);(i)--)\n#define per(i,n)\tPER(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define dum(val)\tcerr << #val \" = \" << val;\n#define FILL(a,v)\tfill(a,a+sizeof(a)/sizeof(*a),v)\n\nconst int dx[8] = { +1,+0,-1,+0,+1,+1,-1,-1 };\nconst int dy[8] = { +0,-1,+0,+1,-1,+1,-1,+1 };\nconst int mod = 1e9 + 7;\nconst int INF = 1e17 + 9;\n\nint dp[401][401];\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tif (n > 400)return 0;\n\tvector<int> l(n), r(n), sz(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tsz[i] = r[i] - l[i];\n\t\tif (l[i] > 400 || r[i] > 400)return 0;\n\t}\n\n\n\tfor (int i = l[0] - 1, c = 1; i >= 0; i--, c++) {\n\t\tdp[0][i] = c;\n\t}\n\tfor (int i = l[0]; i <= r[0]; i++) {\n\t\tdp[0][i] = 0;\n\t}\n\tfor (int i = r[0] + 1, c = 1; i <= 400; i++, c++) {\n\t\tdp[0][i] = c;\n\t}\n\n\tREP(j, 1, n) {\n\t\tfor (int i = l[j] - 1, c = 1; i >= 0; i--, c++) {\n\t\t\tdp[j][i] = c + dp[j - 1][i];\n\t\t}\n\t\tfor (int i = l[j]; i <= r[j]; i++) {\n\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t}\n\t\tfor (int i = r[j] + 1, c = 1; i <= 400; i++, c++) {\n\t\t\tdp[j][i] = c + dp[j - 1][i];\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i <= 400; i++) {\n\t\tans = min(ans, dp[n - 1][i]);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nint main() {\n    const long long maxdistance = 1000001;\n    typedef std::pair<int, int> width;\n    int N = 0;\n    scanf(\"%d\", &N);\n    std::vector<width> ws(N);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d%d\", &ws[i].first, &ws[i].second);\n    }\n    std::vector<long long int> graph(maxdistance);\n    for (int j = 0; j < maxdistance; ++j) {\n        graph[j] = 0;\n    }\n    for (int k = 0; k < maxdistance; ++k) {\n        for (int i = 0; i < N; ++i) {\n            if(!(ws[i].first <= k && ws[i].second >= k))\n                graph[k] += std::min(std::abs(k - ws[i].first), std::abs(k - ws[i].second));\n        }\n    }\n    int Ans = graph[0];\n    for (int l = 1; l < maxdistance; ++l) {\n        if (Ans > graph[l])\n            Ans = graph[l];\n    }\n    std::cout << Ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint main()\n{\n  int N, L[100000], R[100000], P[100000];\n\n  priority_queue< int64 > Left; // くだり(降順)\n  priority_queue< int64, vector< int64 >, greater<> > Right; // のぼり\n  int64 rightBase = 0LL, leftBase = 0LL;\n  int64 ret = 0LL;\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    P[i] = R[i] - L[i];\n  }\n  for(int i = 0; i < N; i++) {\n    rightBase += P[i];\n    Left.emplace(R[i] - leftBase);\n    Right.emplace(R[i] - rightBase);\n    while(Left.top() + leftBase > Right.top() + rightBase) {\n      int64 l = Left.top() + leftBase, r = Right.top() + rightBase;\n      ret += l - r;\n      Left.pop(), Right.pop();\n      Right.push(l - rightBase), Left.push(r - leftBase);\n    }\n    leftBase -= P[i];\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\t/*\n\tf(x) = abs(x-L)\n\tの関数を足す。\n\t*/\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.rbegin();\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t\tRS.insert( temp - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + ofL;\n\t\tret += (temp - L);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + ofR;\n\t\tret += (L - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\taddABSfunc( L[i] );\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tadd2init();\n\taddABSfunc2(0,0,L[0]);\n\tfor(int i=1;i<N;++i){\n\t\taddABSfunc2(R[i]-L[i],R[i-1]-L[i-1],L[i]);\n\t}\n\tcout << ret2 << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n), len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0]; ll my = 0;\n\tmultiset<ll> sl, sr;\n\tll adle = 0, adri = 0;\n\trep1(i, n - 1) {\n\t\tml -= len[i]; mr += len[i - 1];\n\t\tif (l[i] < ml) {\n\t\t\tll dif = ml - l[i];\n\t\t\tsl.insert(dif-adle);\n\t\t\tmy += dif;\n\t\t\tsr.insert(- adri);adri += mr - ml;\n\t\t\tmr = ml;\n\t\t\tint nl = *sl.begin(); sl.erase(sl.begin());\n\t\t\tml -= nl + adle;\n\t\t\tadle -= nl + adle;\n\t\t}\n\t\telse if (l[i] > mr) {\n\t\t\tll dif = l[i] - mr;\n\t\t\tsr.insert(dif - adri);\n\t\t\tmy += dif;\n\t\t\tsl.insert(- adle); adle += mr - ml;\n\t\t\tml = mr;\n\t\t\tint nr = *sr.begin(); sr.erase(sr.begin());\n\t\t\tmr += nr + adri;\n\t\t\tadri -= nr + adri;\n\t\t}\n\t\telse {\n\t\t\tsl.insert(-adle), sr.insert(-adri);\n\t\t\tadle += l[i] - ml; adri += mr - l[i];\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 999999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t/freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = 0;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> l(n), r(n),len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tint ml = l[0], mr = l[0],my=0;\n\trep1(i, n - 1) {\n\t\tif (r[i] < ml) {\n\t\t\tmy += ml - r[i];\n\t\t\tmr = ml;\n\t\t\tml = l[i];\n\t\t}\n\t\telse if (l[i] > mr+len[i-1]) {\n\t\t\tmy += l[i] - mr - len[i - 1];\n\t\t\tml = mr; mr = l[i];\n\t\t}\n\t\telse {\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REPO(i,n) for(int (i)=1; (i)<=(int)(n); (i)++)\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nstruct SL {\n\tpriority_queue<ll> L;\n\tpriority_queue<ll, vector<ll>, greater<ll>> R;\n\tll ans, rBase, lBase;\n\tSL() : ans(0ll), rBase(0ll) {}\n\tvoid addR(int v) {\n\t\trBase += v;\n\t}\n\tvoid addL(int v) {\n\t\tlBase += v;\n\t}\n\tvoid addSL(int x) {\n\t\tL.push(x-lBase); R.push(x-rBase);\n\t\twhile(R.top()+rBase < L.top()+lBase) {\n\t\t\tll l = L.top()+lBase, r = R.top()+rBase;\n\t\t\tans += l-r;\n\t\t\tL.pop(); R.pop();\n\t\t}\n\t}\n};\nint N, Nr[MAX_N][2];\nint main() {\n\tcin >> N;\n\tREP(i, N) REP(j, 2) scanf(\"%d\", &Nr[i][j]);\n\tSL sl;\n\tREP(i, N) {\n\t\tsl.addR(Nr[i][1] - Nr[i][0]);\n\t\tsl.addSL(Nr[i][1]);\n\t\tsl.addL(-(Nr[i][1] - Nr[i][0]));\n\t}\n\tprintf(\"%lld\\n\", sl.ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst size_t MAX = 405;\n\nint dp[MAX][MAX], l[MAX], r[MAX];\n\ninline void update(int& x, const int& val) { x = min(x, val); }\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d%d\", l + i, r + i);\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j < 401; j++)\n            dp[i][j] = 1e9;\n    l[0] = 0; r[0] = 400;\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j < 401; j++)\n            for (int k = max(j - r[i - 1] + l[i - 1], 0);\n                 k <= min(r[i] - l[i] + j, 400); k++)\n                update(dp[i][j], dp[i - 1][k] + abs(l[i] - j));\n    int res = INT_MAX;\n    for (int j = 0; j < 401; j++) res = min(res, dp[n][j]);\n    printf(\"%d\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e9 + 10;\nconst int maxn = 1e5 + 10;\nmt19937 rng;\nstruct node {\n\tnode *l, *r;\n\tll pos;\n\tint sz;\n\tll val, tg_pos, tg_val;\n\tll trans_pos_tg;\n\tint pri;\n\tnode(ll pos = 0, ll val = 0): \n\t\tl(nullptr), r(nullptr), pos(pos), val(val), sz(1),\n\t\ttrans_pos_tg(0), tg_pos(0), tg_val(0), pri(rng()) {}\n\n\tvoid push() {\n\t\tif(trans_pos_tg) {\n\t\t\tpos += trans_pos_tg, tg_pos += trans_pos_tg;\n\t\t\tif(l) l->trans_pos_tg += trans_pos_tg;\n\t\t\tif(r) r->trans_pos_tg += trans_pos_tg;\n\t\t\ttrans_pos_tg = 0;\n\t\t}\n\t\tif(tg_val) {\n\t\t\tval += (pos - tg_pos) * tg_val;\n\t\t\tif(l) l->tg_val += tg_val, l->tg_pos = tg_pos;\n\t\t\tif(r) r->tg_val += tg_val, r->tg_pos = tg_pos;\n\t\t\ttg_val = 0;\n\t\t}\n\t}\n\tvoid pull() {\n\t\tsz = 1;\n\t\tif(l) sz += l->sz;\n\t\tif(r) sz += r->sz;\n\t}\n};\nnode *get_node(node *o) {\n\tif(!o) return nullptr;\n\tnode *u = new node();\n\tu->l = o->l, u->r = o->r;\n\tu->pos = o->pos, u->val = o->val;\n\treturn u;\n}\nnode *rt;\nnode* merge(node *a, node *b) {\n\tif(!a || !b) return a ? a : b;\n\tif(a->pri > b->pri) {\n\t\ta->push();\n\t\ta->r = merge(a->r, b);\n\t\ta->pull();\n\t\treturn a;\n\t}\n\telse {\n\t\tb->push();\n\t\tb->l = merge(a, b->l);\n\t\tb->pull();\n\t\treturn b;\n\t}\n}\ntypedef pair<node*, node*> pnn;\n#define F first\n#define S second\npnn split(ll k, node *o) {\n\tif(!o) {\n\t\treturn {nullptr, nullptr};\n\t}\n\to->push();\n\tpnn res;\n\tif(o->pos > k) {\n\t\tres = split(k, o->l);\n\t\tnode *u = get_node(o);\n\t\tu->l = res.S;\n\t\tu->pull();\n\t\tres.S = u;\n\t}\n\telse {\n\t\tres = split(k, o->r);\n\t\tnode *u = get_node(o);\n\t\tu->r = res.F;\n\t\tu->pull();\n\t\tres.F = u;\n\t}\n\treturn res;\n}\ntypedef pair<ll, ll> pll;\n#define F first\n#define S second\npll get_left(node *o) {\n\tif(!o) return {-INF, -INF};\n\twhile(o->l) o = o->l;\n\treturn make_pair(o->pos, o->val);\n}\npll get_right(node *o) {\n\tif(!o) return {INF, INF};\n\twhile(o->r) o = o->r;\n\treturn make_pair(o->pos, o->val);\n}\nvoid print(node *o) {\n\tif(!o) return;\n\to->push();\n\tprint(o->l);\n\tprintf(\"pos = %lld, val = %lld sz = %d\\n\", o->pos, o->val, o->sz);\n\tprint(o->r);\n}\n// something wrong here\nll query(ll x) {\n\tnode *le, *ri, *cur, *tmp;\n\ttie(le, tmp) = split(x - 1, rt);\n\n\ttie(cur, ri) = split(x, tmp);\n\tif(cur) return cur->val;\n\tpll a = get_right(le), b = get_left(ri);\n\tll p = x - a.F, q = b.F - x;\n\treturn (p * b.S + q * a.S) / (p + q);\n}\nint l[maxn], r[maxn];\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) \n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\trt = merge(new node(0, 0), new node(INF, 0));\n\tll l_pos = 0, r_pos = INF;\n\tfor(int i = 1; i <= n; i++) {\n\t\t//puts(\"-----------------\");\n\t\tnode *le, *ri, *cur, *tmp;\n\t\ttie(le, tmp) = split(l_pos - 1, rt);\n\t\ttie(cur, ri) = split(l_pos, tmp);\n\t\tnode *tt = get_node(cur);\n\t\tle = merge(le, cur);\n\t\tri = merge(tt, ri);\n\t\tif(le) le->trans_pos_tg = -(r[i] - l[i]);\n\t\tif(ri) ri->trans_pos_tg = r[i - 1] - l[i - 1];\n\t\tl_pos -= (r[i] - l[i]), r_pos += (r[i - 1] - l[i - 1]);\n\t\trt = merge(le, ri);\n\t\t//puts(\"after split:\");\n\t\t//print(rt);\n\t\tle = ri = cur = tmp = nullptr;\n\t\ttie(le, tmp) = split(l[i] - 1, rt);\n\t\ttie(cur, ri) = split(l[i], tmp);\n\n\t\t//puts(\"le:\");\n\t\t//print(le);\n\t\t//puts(\"cur:\");\n\t\t//print(cur);\n\t\t//puts(\"ri\");\n\t\t//print(ri);\n\t\t//puts(\"ok\");\n\t\tif(!cur) {\n\t\t\tll v = query(l[i]);\n\t\t\t//printf(\"v = %lld\\n\", v);\n\t\t\tcur = new node(l[i], v);\t\n\t\t}\n\t\tif(le) le->tg_val = -1, le->tg_pos = l[i];\n\t\tif(ri) ri->tg_val = 1, ri->tg_pos = l[i];\n\n\t\trt = merge(merge(le, cur), ri);\n\t\tif(l_pos <= l[i] && l[i] <= r_pos) \n\t\t\tl_pos = r_pos = l[i];\n\t\telse if(l[i] > r_pos) {\n\t\t\tll L = query(r_pos), R = query(l[i]);\n\t\t\tif(L < R) l_pos = r_pos;\n\t\t\telse l_pos = r_pos, r_pos = l[i];\n\t\t}\n\t\telse {\n\t\t\tll L = query(l[i]), R = query(l_pos);\n\t\t\tif(L > R) r_pos = l_pos;\n\t\t\telse r_pos = l_pos, l_pos = l[i];\n\t\t}\n\t\t//puts(\"now:\");\n\t\t//print(rt);\n\t\t//printf(\"l_pos = %lld, r_pos = %lld\\n\", l_pos, r_pos);\n\t\t//printf(\"ans = %lld %lld\\n\", query(l_pos), query(r_pos));\n\t}\n\tprintf(\"%lld\\n\", query(l_pos));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nint L[100011], R[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d%d\", L+i, R+i);\n\n    LL ans = 0;\n    priority_queue<LL> Ls;\n    priority_queue<LL, vector<LL>, greater<LL> > Rs;\n    Ls.push(L[0]);\n    Rs.push(L[0]);\n    LL Roffset = 0, Loffset = 0;\n\n    REP (i, N-1) {\n\n\tRoffset += R[i] - L[i];\n\tLoffset -= R[i+1] - L[i+1];\n\n\tLL pos = L[i+1];\n\tif (Rs.top()+Roffset < pos) {\n\t    LL x = Rs.top() + Roffset;\n\t    Rs.pop();\n\t    Rs.push(pos-Roffset);\n\t    Rs.push(pos-Roffset);\n\t    ans += pos - x;\n\t    Ls.push(x - Loffset);\n\t} else if (Ls.top()+Loffset > pos) {\n\t    LL x = Ls.top() + Loffset;\n\t    Ls.pop();\n\t    Ls.push(pos-Loffset);\n\t    Ls.push(pos-Loffset);\n\t    ans += x - pos;\n\t    Rs.push(x - Roffset);\n\t} else {\n\t    Rs.push(pos-Roffset);\n\t    Ls.push(pos-Loffset);\n\t}\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\nmultiset<ll> L, R;\nll xl = 0, xr = 0;\nll res = 0;\n\nvoid slide(ll ld, ll rd){\n  xl += ld;\n  xr += rd;\n}\n\nvoid add(ll v){\n  ll lb = (*L.rbegin()) - xl, rb = (*R.begin()) + xr;\n  if(lb <= v && v <= rb){\n    L.insert(v + xl);\n    R.insert(v - xr);\n  }else if(v > rb){\n    res += (v - rb);\n    R.erase(R.begin());\n    L.insert(rb + xl);\n    R.insert(v - xr);\n    R.insert(v - xr);\n  }else{\n    res += (lb - v);\n    auto itr = L.end(); itr--;\n    L.erase(itr);\n    R.insert(lb - xr);\n    L.insert(v + xl);\n    L.insert(v + xl);\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  vector<ll> l(n), r(n); rep(i, n)cin >> l[i] >> r[i];\n  L.insert(l[0]);\n  R.insert(r[0]);\n  FOR(i, 1, n){\n    slide(r[i] - l[i], r[i-1] - l[i-1]);\n    add(l[i]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tll l, r, len, pbl, pbr, ans = 0, L, R;\n\tpriority_queue<ll> ql;\n\tpriority_queue<ll, vector<ll>, greater<ll>> qr;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\t\tql.push(r - pbl);\n\t\tqr.push(r - pbr);\n\n\t\twhile ((L = ql.top() + pbl) > (R = qr.top() + pbr)) {\n\t\t\tans += L - R;\n\n\t\t\tql.pop();\n\t\t\tqr.pop();\n\t\t\t\n\t\t\tql.push(R - pbl);\n\t\t\tqr.push(L - pbr);\n\t\t}\n\n\t\tpbl -= len;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[405][405];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=0;i<405;i++)\n\t\t\tfor(int j=0;j<405;j++)\n\t\t\tdp[i][j]=1e9;\n\t\tfor(int i=1;i<405;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tfor(int j=1;j<10;j++)\n\t\t\t{\n\t\t\t\tint aa=0;\n\t\t\t\tif(j<l)\n\t\t\t\taa=l-j;\n\t\t\t\telse if(j>r)\n\t\t\t\taa=j-r;\n\t\t\t\tfor(int k=max(j-(r-l+1),1);k<min(405,j+(r-l+1));k++){\n\t\t\t\t\tif(k<l)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(l-k,aa));\n\t\t\t\t\telse if(k>r)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+max(k-r,aa));\n\t\t\t\t\telse \n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+aa);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<405;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 404;\nint n, l[maxn], r[maxn], sz[maxn], dp[maxn][maxn];\n\nbool ok(int l1, int r1, int l2, int r2){\n    int l3 = max(l1, l2), r3 = min(r1, r2);\n    return l3 <= r3;\n}\n\nint main(){\n\tsz[0] = 1000;\n\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> l[i] >> r[i];\n\t\tsz[i] = r[i] - l[i];\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j < maxn; j++){\n\t\t\tdp[i][j] = 1000000;\n\n\t\t\tfor(int k = 1; k < maxn; k++){\n\t\t\t\tif(i == 1 || ok(j, j + sz[i], k, k + sz[i - 1])){\n\t\t\t\t\tint tmp = abs(j - l[i]) + dp[i - 1][k];\n\t\t\t\t\tdp[i][j] = min(dp[i][j], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint sol = 10000000;\n\n\tfor(int i = 1; i < maxn; i++){\n\t\tsol = min(sol, dp[n][i]);\n\t}\n\n\tcout << sol << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <queue> \nusing namespace std;\nconst int N=100001;\nint n,minn;\nstruct node\n{\n    int l;\n    int r;\n    int len;\n}p[N];\nint dp[401][401];//第i层的左端点在j \nint main()\n{\n    int i,j,k;\n    cin>>n;\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%d %d\",&p[i].l,&p[i].r);\n        p[i].len=(p[i].r-p[i].l);\n    }\n    memset(dp,0x7f,sizeof(dp));\n    minn=dp[0][0];\n    for(i=1;i<=n;i++)\n        dp[1][i]=abs(p[1].l-i);\n    for(i=2;i<=n;i++)\n    {\n        for(j=1;j<=400;j++)\n            for(k=1;k<=400;k++)\n            {\n                if((j>k+p[i-1].len)||(k>j+p[i].len))    continue; \n                dp[i][j]=min(dp[i][j],dp[i-1][k]+abs(j-p[i].l));\n            }\n    }\n    for(i=1;i<=400;i++)\n        minn=min(minn,dp[n][i]);\n    cout<<minn;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n#define P +MAXN\n \nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n \nint mem[MAXN][MAXN P];\nint myabs( int x ){\n\tif( x >= 0 ) return x;\n\telse return -x;\n}\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl P] != -1) return mem[pos][lastl P];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= r[pos-1];nowl++){\n\t\tint nowans = dp(pos+1,nowl) + myabs(l[pos]-nowl);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\tmem[pos][lastl P] = ans;\n\treturn ans;\n}\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 0;i <= MAXN;i++){\n\t\tint nowans = dp(2,i) + myabs(i-l[1]);\n\t\tif( ans > nowans ){\n\t\t\tans = nowans;\n\t\t}\n\t}\n\t\t\n\tprintf(\"%d\\n\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\n\n/////////////////////////////////\n\nint const MAX = 100 * 1000 + 41;\n\nint n;\nint l[MAX];\nint r[MAX];\nmultiset<ll> tl, tr;\nll addl, addr, ans;\n\nll getmax(multiset<ll> &t) {\n\treturn (*t.rbegin());\n}\n\nll getmin(multiset<ll> &t) {\n\treturn (*t.begin());\n}\n\nvoid solve() {\n\ttl.insert(l[1]);\n\ttr.insert(l[1]);\n\tfi(2, n) {\n\t\taddl -= (r[i] - l[i]);\n\t\taddr += (r[i - 1] - l[i - 1]);\n\t\tll l1 = getmax(tl) + addl;\n\t\tll r1 = getmin(tr) + addr;\n\t\terr(\"l1 = %lld r1 = %lld l[i] = %d\\n\", l1, r1, l[i]);\n\t\tif (l1 < l[i] && l[i] < r1) {\n\t\t\ttl.insert(l[i] - addl);\n\t\t\ttr.insert(l[i] - addr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (l[i] >= r1) {\n\t\t\tans += l[i] - r1;\n\t\t\ttr.erase(tr.begin());\n\t\t\ttr.insert(l[i] - addr);\n\t\t\ttr.insert(l[i] - addr);\t\t\t\t\t\t\n\t\t\ttl.insert(r1 - addl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (l[i] <= l1) {\n\t\t\tans += l1 - l[i];\n\t\t\tauto it = tl.end();\n\t\t\tit--;\n\t\t\ttl.erase(it);\n\t\t\ttl.insert(l[i] - addl);\n\t\t\ttl.insert(l[i] - addl);\t\t\t\n\t\t\ttr.insert(l1 - addr);\n\t\t\tcontinue;\n\t\t}\n\t\tassert(false);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d\", &n);\n\tfi(1, n) {\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t}\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<complex>\n#include<unordered_map>\ntypedef long long ll;\n\nusing namespace std;\n#define N 410\nunordered_map<ll,ll> f[N];\nll n;\nll a[N],b[N],l[N],r[N];\nint main(){\n    cin>>n;\n    if(n>N)return 0;\n    for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n    for(int i=1;i<n;i++){\n      a[i]=l[i]-r[i-1];\n      b[i]=r[i]-l[i-1];\n    }\n    for(int d=-N;d<=N;d++)f[0][d]=abs(d);\n    for(int i=1;i<n;i++){\n      for(int d=-N;d<=N;d++){\n\tll L=d+a[i],R=d+b[i];\n\tif(L<-N)L=-N;\n\tif(R>N)R=N;\n\tll res=1e18;\n\tfor(ll k=L;k<=R;k++){\n\t  res=min(res,f[i-1][k]);\n\t}\n\tf[i][d]=res+abs(d);\n      }\n    }\n    ll ans=1e18;\n    for(int d=-N;d<=N;d++)ans=min(ans,f[n-1][d]);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nll n;\nll a[N],b[N],l[N],r[N];\nll sp,tp;\npriority_queue<ll> S;\npriority_queue<ll,vector<ll>,greater<ll> >T;\nll Sf(){\n  return S.top()+sp;\n}\nll Tf(){\n  return T.top()+tp;\n}\nvoid Sp(ll x){\n  S.push(x-sp);\n}\nvoid Tp(ll x){\n  T.push(x-tp);\n}\nint main(){\n    cin>>n;\n    if(n>N)return 0;\n    for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n    for(int i=1;i<n;i++){\n      a[i]=l[i]-r[i-1];\n      b[i]=r[i]-l[i-1];\n    }\n    ll ans=0; sp=tp=0;\n    Sp(0); Tp(0);\n    Sp(-1e17); Tp(1e17);\n    for(int i=1;i<n;i++){\n      sp-=b[i],tp-=a[i];\n      ll s0=Sf();\n      ll t0=Tf();\n      if(s0<=0&&0<=t0){\n\tSp(0); Tp(0);\n      }\n      if(0<s0){\n\tSp(0); Sp(0);\n\twhile(Sf()>0){\n\t  Tp(Sf());\n\t  S.pop();\n\t}\n      }\n      if(t0<0){\n\tTp(0); Tp(0);\n\twhile(Tf()<0){\n\t  Sp(Tf());\n\t  T.pop();\n\t}\n      }\n      ans+=Tf()-Sf();\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst long long LL_INF = (long long) 2e18 + 5;\n\nstruct convex_piecewise_linear {\n    priority_queue<long long> negatives;\n    priority_queue<long long, vector<long long>, greater<long long>> positives;\n    long long negative_offset, positive_offset;\n    long long zero_y;\n\n    convex_piecewise_linear() {\n        negatives = priority_queue<long long>();\n        positives = priority_queue<long long, vector<long long>, greater<long long>>();\n        negatives.push(-LL_INF);\n        positives.push(LL_INF);\n        negative_offset = positive_offset = zero_y = 0;\n    }\n\n    void add_shift(long long left, long long right) {\n        negative_offset -= left;\n        positive_offset += right;\n    }\n\n    void add_abs(long long center) {\n        long long left = negatives.top() + negative_offset;\n        long long right = positives.top() + positive_offset;\n        assert(left <= right);\n\n        if (left <= center && center <= right) {\n            negatives.push(center - negative_offset);\n            positives.push(center - positive_offset);\n            return;\n        }\n\n        if (center < left) {\n            negatives.push(center - negative_offset);\n            negatives.push(center - negative_offset);\n            long long move = negatives.top() + negative_offset; negatives.pop();\n            zero_y += move - center;\n            positives.push(move - positive_offset);\n        } else {\n            assert(center > right);\n            positives.push(center - positive_offset);\n            positives.push(center - positive_offset);\n            long long move = positives.top() + positive_offset; positives.pop();\n            zero_y += center - move;\n            negatives.push(move - negative_offset);\n        }\n    }\n\n    void print() {\n        auto negatives_copy = negatives;\n        auto positives_copy = positives;\n\n        cerr << \"Negatives:\";\n\n        while (!negatives_copy.empty()) {\n            cerr << ' ' << negatives_copy.top() + negative_offset;\n            negatives_copy.pop();\n        }\n\n        cerr << endl;\n        cerr << \"Positives:\";\n\n        while (!positives_copy.empty()) {\n            cerr << ' ' << positives_copy.top() + positive_offset;\n            positives_copy.pop();\n        }\n\n        cerr << endl;\n        cerr << \"Zero y: \" << zero_y << endl;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    convex_piecewise_linear DS;\n    long long prev_L, prev_R;\n\n    for (int i = 0; i < N; i++) {\n        long long L, R;\n        cin >> L >> R;\n        // cerr << L << ' ' << R << endl;\n\n        if (i > 0)\n            DS.add_shift(R - L, prev_R - prev_L);\n\n        // DS.print();\n        DS.add_abs(L);\n        prev_L = L;\n        prev_R = R;\n        // DS.print();\n    }\n\n    cout << DS.zero_y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e5 + 10;\nconst ll inf = 1e13;\nint l[N], r[N];\nmultiset<ll> s0, s1;\nll d0, d1;\n\nint main() {\n    ios::sync_with_stdio(0);\n\tint n;\n    scanf(\"%d\",&n);\n\tint l1 = 0;\n\tfor(int i=1; i<=n; i++) {\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tint l2 = r[i] - l[i]; \n\t\tif (i > 1) d0 -= l2, d1 += l1;\n\t\tl1 = l2;\n\t\tll L, R;\n\t\tif (i > 1) {\n\t\t\tauto it = s0.end();\n            it--;\n\t\t\tL = *it + d0;\n\t\t\tit = s1.begin();\n\t\t\tR = *it + d1;\n\t\t} else{ \n            L = 0; \n            R = 0;\n        }\n\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\ts0.insert(l[i] - d0);\n            s1.insert(l[i] - d1);\n\t\t} else if (l[i] < L) {\n\t\t\ts0.insert(l[i] - d0);\n            s0.insert(l[i] - d0);\n\t\t\tauto it = s0.end();\n            it--;\n\t\t\ts1.insert(*it + d0 - d1);\n            s0.erase(it);\n\t\t} else if (l[i] > R) {\n\t\t\ts1.insert(l[i] - d1);\n            s1.insert(l[i] - d1);\n\t\t\tauto it = s1.begin(); \n\t\t\ts0.insert(*it + d1 - d0);\n            s1.erase(it);\n\t\t}\n\t}\n\tll cur = 0, t = -inf;\n\tfor(int i=n; i>=1; i--){\n        cur += l[i] - t;\n        t += r[i] - l[i];\n    }\n\tint d = -n; ll tmp = -inf;\n\tfor(auto it = s0.begin(); it != s0.end(); it++){\n\t\tcur += 1LL * d * (*it + d0 - tmp);\n        tmp = *it + d0;\n        d++;\n    }\n    printf(\"%d\\n\",cur);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n \nusing namespace std;    \n \nstatic int getMinCost(vector<int> nodes,\n\t       int curmincost,\n\t       int minpos)\n{\n    if (nodes.size() == 0) {\n\treturn curmincost;\n    }\n    \n \n    int len = nodes.size();\n    auto rf = nodes.begin() + len / 2;\n    auto ll = nodes.begin() + len / 2 - 1;\n    \n    if (*ll <= minpos) {\n\tif (minpos <= *rf) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - *rf + curmincost;\n    } else {\n\treturn *ll - minpos + curmincost;\n    }\n}\n \nint main(void){\n    int n;\n    int mincost;\n    vector<int> nodes;\n    stringstream st;\n    string line;\n      \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n\n\n    int nl, nr;\n    int l, r;\n    mincost = 0;    \n    for (int i = 0; i < n; i++) {\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> nl >> nr;\n\tif (i >= 1) {\n\t    mincost = getMinCost(nodes, mincost, l);\n\t    //cout << l << \" \" << r << \" \" << mincost << endl;\n\t    auto il = lower_bound(nodes.begin(), nodes.end(), l);\n\t    nodes.insert(il, 2, l);\n\t    int len = nodes.size();\n\t    int j = 0;\n\t    for (auto &e : nodes) {\n\t\tif (j < len / 2) {\n\t\t    e -= nr - nl;\n\t\t} else {\n\t\t    e += r - l;\n\t\t}\n\t\tj++;\n\t    }\n#if 0\n\t    for (auto e : nodes) {\n\t\tcout << e << \" \";\n\t    }\n\t    cout << endl;\n#endif\t\n\t}\n\tl = nl;\n\tr = nr;\n    }\n \n    mincost = getMinCost(nodes, mincost, l);\n \n    cout << mincost << endl;\n    return 0;\n \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\n\tpriority_queue<ll> lower;\n\tpriority_queue<ll, vector<ll>, greater<ll>> upper;\n\n\tll ans=0;\n\tll l[n],r[n],temp;\n\tfor(temp=0;temp<n;temp++)\tcin>>l[temp]>>r[temp];\n\n\tlower.push(l[0]);\n\tupper.push(l[0]);\n\tll lazylow=0,lazyhigh=0;\n\tfor(temp=1;temp<n;temp++) {\n\n\t\tll len0=r[temp-1]-l[temp-1]+1;\n\t\tll len1=r[temp]-l[temp]+1;\n\t\tlazylow-=len1-1;\n\t\tlazyhigh+=len0-1;\n\n\t\tif(l[temp]<lower.top()+lazylow) {\n\t\t\tll shifted=lower.top()+lazylow;\n\t\t\tans+=shifted-l[temp];\n\t\t\tlower.push(l[temp]-lazylow);\n\t\t\tlower.push(l[temp]-lazylow);\n\t\t\tupper.push(shifted-lazyhigh);\n\t\t\tlower.pop();\n\t\t}\n\t\telse if(l[temp]>upper.top()+lazyhigh) {\n\t\t\tll shifted= upper.top()+lazyhigh;\n\t\t\tans+=l[temp]-shifted;\n\t\t\tupper.push(l[temp]-lazyhigh);\n\t\t\tupper.push(l[temp]-lazyhigh);\n\t\t\tlower.push(shifted-lazylow);\n\t\t\tupper.pop();\n\t\t}\n\t\telse {\n\t\t\tlower.push(l[temp]-lazylow);\n\t\t\tupper.push(l[temp]-lazyhigh);\n\t\t}\n\t}\n\tcout<<ans<<\"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define MN 100000\n#define ll long long\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nll ans,addl,addr;\nint n,l[MN+5],r[MN+5];\npriority_queue<ll> ql;\npriority_queue<ll,vector<ll>,greater<ll> >qr;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n    ql.push(l[1]);qr.push(l[1]);\n    for(int i=2;i<=n;++i)\n    {\n        addr+=r[i-1]-l[i-1];addl+=r[i]-l[i];\n        ll pl=ql.top()-addl,pr=qr.top()+addr;\n        if(pl<=l[i]&&l[i]<=pr) ql.push(l[i]+addl),qr.push(l[i]-addr);\n        else if(l[i]<pl)\n        {\n            ans+=pl-l[i];\n            qr.push(pl-addr);\n            ql.push(l[i]+addl);ql.push(l[i]+addl);ql.pop();\n        }\n        else\n        {\n            ans+=l[i]-pr;\n            ql.push(pl+addl);\n            qr.push(l[i]-addr);qr.push(l[i]-addr);qr.pop();\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    if (n > 400) throw;\n\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        l[i]--; r[i]--;\n    }\n\n    vector<int64_t[400]> dp(n);\n    for (int j = 0; j < n; j++) {\n        for (int i = 0; i < 400; i++) {\n            dp[j][i] = 1ULL << 60;\n        }\n    }\n    // jにおいて左端をiに置いたときのそこまでの最小コスト\n    for (int j = 0; j < n; j++) {\n        if (j == 0) {\n            for (int i = 0; i < 400; i++) {\n                dp[j][i] = abs(l[j] - i);\n            }\n        } else {\n            int x0 = r[j - 1] - l[j - 1];\n            int x1 = r[j] - l[j];\n            for (int h = 0; h < 400; h++) {\n                int64_t w = 1ULL << 60;\n                int64_t e = abs(l[j] - h);\n                int i0 = max(h - x0, 0), i1 = min(h + x1, 399);\n                for (int i = i0; i <= i1; i++) {\n                    int64_t t = dp[j - 1][i] + e;\n                    if (t < w) w = t;\n                }\n                dp[j][h] = w;\n            }\n        }\n    }\n    int64_t w = 1ULL << 60;\n    for (int i = 0; i < 400; i++) {\n        int64_t t = dp[n - 1][i];\n        if (t < w) w = t;\n    }\n    cout << w << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define pb push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nvector<ll> l,r;\n\nint main(){\n    cin >> N;\n    assert(N<=400);\n    l.resize(N);\n    r.resize(N);\n    ll mid=0;\n    rep(i,N){\n        cin >> l[i] >> r[i];\n    }\n\n    ll ans2=LINF;\n    for(int i=0;i<N;i++){\n        ll ans=0;\n        ll LL,LR;\n        LL=l[i];\n        LR=r[i];\n        for(int j=i+1;j<N;j++){\n            if(LR < l[j]){\n                ans += l[j]-LR;\n            }else if(r[j] < LL){\n                ans += LL-r[j];\n            }\n            LL = l[j];\n            LR = r[j];\n        }\n        for(int j=i-1;j>=0;j--){\n            if(LR < l[j]){\n                ans += l[j]-LR;\n            }else if(r[j] < LL){\n                ans += LL-r[j];\n            }\n            LL = l[j];\n            LR = r[j];\n        }\n        ans2 = min(ans2,ans);\n    }\n    cout << ans2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(l[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    dL-=r[i]-l[i];\n    dR+=r[i-1]-l[i-1];\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(r[i]<dL+*latte){\n      \n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      \n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <utility>\n#include <cstdlib>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nllint l[100005], r[100005];\nmultiset<P> S, T;\nllint a, b;\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\t\n\tllint ans = 0;\n\tS.insert(P(l[1], -1)), T.insert(P(l[1], 1));\n\tfor(int i = 2; i <= n; i++){\n\t\ta += r[i]-l[i];\n\t\tb += r[i-1]-l[i-1];\n\t\t\n\t\tauto it = S.end(); it--;\n\t\tllint x = it->first - a, y = T.begin()->first + b;\n\t\t\n\t\tif(l[i] <= x){\n\t\t\tS.insert(P(l[i]+a, -1));\n\t\t\tS.insert(P(l[i]+a, 1));\n\t\t\tauto it = S.end(); it--;\n\t\t\tllint v = it->first - a;\n\t\t\tT.insert(P(v-b, it->second));\n\t\t\tS.erase(it);\n\t\t\tans += abs(x-l[i]);\n\t\t}\n\t\telse if(y <= l[i]){\n\t\t\tT.insert(P(l[i]-b, -1));\n\t\t\tT.insert(P(l[i]-b, 1));\n\t\t\tauto it = T.begin();\n\t\t\tllint v = it->first + b;\n\t\t\tS.insert(P(v+a, it->second));\n\t\t\tT.erase(it);\n\t\t\tans += abs(y-l[i]);\n\t\t}\n\t\telse{\n\t\t\tS.insert(P(l[i]+a, -1));\n\t\t\tT.insert(P(l[i]-b, 1));\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = 400 + 10;\nint n, l[MAXN], r[MAXN];\nint len[MAXN];\nint dp[MAXN][MAXN];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        len[i] = r[i] - l[i];\n    }\n\n    for (int i = 1; i <= 400; ++i) {\n        dp[1][i] = abs(i - l[1]);\n    }\n    for (int i = 2; i <= n; ++i) {\n        for (int x = 1; x <= 400; ++x) {\n            dp[i][x] = (int)1e9;\n            for (int x1 = 1; x1 <= x - len[i - 1]; ++x1) {\n                dp[i][x] = min(dp[i][x], dp[i - 1][x1] + x - (x1 + len[i - 1]));\n            }\n            for (int x1 = max(1, x - len[i - 1]); x1 <= 400 && x1 <= x + len[i]; ++x1) {\n                dp[i][x] = min(dp[i][x], dp[i - 1][x1]);\n            }\n            for (int x1 = x + len[i]; x1 <= 400; ++x1) {\n                dp[i][x] = min(dp[i][x], dp[i - 1][x1] + x1 - x - len[i]);\n            }\n            dp[i][x] += abs(x - l[i]);\n        }\n    }\n\n    printf(\"%d\\n\", *min_element(dp[n] + 1, dp[n] + 1 + 400));\n\n    /*\n    f(i, x) = f(i - 1, x') + x - x' - len(i - 1)        x' <= x - len(i - 1)\n\n    f(i, x) = f(i - 1, x')                              x - len(i - 1) <= x' <= x + len(i)\n\n    f(i, x) = min(f(i - 1, x') + x' - x - len(i))       x' >= x + len(i)\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int INF=1e15;\nconst int width=401;\nint main(){\n  int n;\n  cin>>n;\n  vector<long long int> l(n),r(n);\n  for(int i=0;i<n;i++){\n    cin>>l[i]>>r[i];\n    if(r[i]>=width) return 1;\n  }\n\n  vector<vector<long long int>> dp(n,vector<long long int>(width,INF));\n  for(int i=0;i<width;i++){\n    dp[0][i]=abs(i-l[0]);\n  }\n  for(int i=1;i<n;i++){\n    for(int j=0;j<width;j++){\n      for(int k=0;k<width;k++){\n\tif(j+r[i]-l[i]<k){\n\n\t}\n\telse if(k+r[i-1]-l[i-1]<j){\n\n\t}\n\telse{\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]+abs(l[i]-j));\n\t}\n      }\n    }\n  }\n  cout<<*min_element(dp[n-1].begin(),dp[n-1].end())<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint n;\n\nint l[405],r[405];\nint d[405][405];\n\nint go(int now, int leftx){\n    \n    if(now == n+1) return 0;\n    \n    int &ans = d[now][leftx];\n    if(ans!=-1) return ans;\n    \n    int rightx = leftx+r[now-1]-l[now-1];\n    \n    ans = 987654321;\n    \n    for(int left=1;left<=400;left++){\n        int right = left + r[now] - l[now];\n        \n        if(right < leftx || rightx < left) continue;\n        ans = min(ans, go(now+1,left) + abs(left-l[now]));\n    }\n    return ans;\n}\n\nint main(){\n    \n    scanf(\"%d\",&n);\n    if(n>=401) return 0;\n\n    for(int i=1;i<=n;i++){\n        scanf(\"%d %d\",&l[i],&r[i]);\n    }\n    memset(d,-1,sizeof(d));\n    int res = 987654321;\n    for(int i=1;i<=400;i++){\n        res = min(res,go(1,i));\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, l[409], r[409], a[409], dp[409][809]; bool vis[409][809];\nint solve(int pos, int c) {\n\tif (pos == N - 1) return 0;\n\tif (vis[pos][c + 400]) return dp[pos][c + 400];\n\tint ret = 999999999;\n\tfor (int i = -400; i <= 400; i++) {\n\t\tif (l[pos + 1] - r[pos] <= c - i && c - i <= r[pos + 1] - l[pos]) {\n\t\t\tret = min(ret, solve(pos + 1, i) + abs(i));\n\t\t}\n\t}\n\tvis[pos][c + 400] = true;\n\tdp[pos][c + 400] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> N;\n\tassert(N <= 400);\n\tfor (int i = 0; i < N; i++) cin >> l[i] >> r[i];\n\tint ret = 999999999;\n\tfor (int i = -400; i <= 400; i++) ret = min(ret, solve(0, i) + abs(i));\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  std::vector< std::pair< lint, lint > > lr(n);\n  std::vector< std::pair< lint, lint > > cd(n);\n  rep(i,0,n) {\n    lint l, r; std::cin >> l >> r;\n    lr.at(i) = {l,r};\n    cd.at(i) = {l + r, r - l};\n  }\n\n  std::set< lint > left, right;\n  lint left_geta = 0, right_geta = 0;\n  lint min = 0;\n  auto meld = [&] (lint d) {\n    left_geta -= d;\n    right_geta += d;\n  };\n  auto add_vfn = [&] (lint z) {\n    left.insert(z - left_geta);\n    right.insert(z - right_geta);\n    lint l = *left.rbegin() + left_geta;\n    lint r = *right.begin() + right_geta;\n    if (l > r) {\n      min += l - r;\n      left.erase(std::prev(left.end()));\n      right.erase(right.begin());\n      left.insert(r - right_geta - left_geta);\n      right.insert(l - left_geta - right_geta);\n    }\n  };\n  lint prv = 0;\n  for (auto&& pair : cd) {\n    lint c, d; std::tie(c, d) = pair;\n    meld(prv + d);\n    add_vfn(c);\n    prv = d;\n  }\n  lint ans = min / 2;\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,sh[2];\npriority_queue<long long> pq[2];\n\nint main()\n{\n\tlong long i,ii,k,l,e,u,z=0;\n\t\n\tscanf(\"%lld\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&k,&l);\n\t\tsh[0]+=l-k;\n\t\tif(i)\n\t\t{\n\t\t\tz+=max(pq[0].top()-sh[0]-k,0ll)+max(k+pq[1].top()-sh[1],0ll);\n\t\t}\n\t\te=i&&k>pq[0].top()-sh[0];\n\t\tu=!e*2-1;\n\t\tfor(ii=0;ii<2;ii++)\n\t\t{\n\t\t\tpq[e].push(k*u+sh[e]);\n\t\t}\n\t\tk=(pq[e].top()-sh[e])*u;\n\t\tpq[!e].push(k*-u+sh[!e]);\n\t\tpq[e].pop();\n\t\tsh[1]+=l-k;\n\t}\n\tprintf(\"%lld\\n\",z);\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,l[N],r[N];\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll>> R;\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n\tL.push(l[1]),R.push(r[1]); ll addl=0,addr=0,ans=0;\n\tfor (int i=2;i<=n;++i) {\n\t\taddl-=r[i]-l[i],addr+=r[i-1]-l[i-1];\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (lb<=l[i]&&l[i]<=rb) L.push(l[i]-addl),R.push(l[i]-addr);\n\t\telse if (l[i]<lb) {\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.pop(),L.push(l[i]-addl),L.push(l[i]-addl);\n\t\t} else {\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.pop(),R.push(l[i]-addr),R.push(l[i]-addr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 5007;\n\ntypedef bitset<maxn> Bit;\nBit pre[maxn];\nint n;\nint K;\nint a[maxn];\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i = 1; i <= n; ++i)scanf(\"%d\",&a[i]);\n\tpre[0].reset();pre[0][0] = 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tpre[i] = pre[i - 1];\n\t\tif(a[i] <= K)\n\t\t\tpre[i] |= (pre[i] << a[i]);\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i){\n\t\tbool SUC = 0;\n\t\tBit cur = pre[i - 1];\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tif(a[j] <= K)\n\t\t\t\tcur |= (cur << a[j]);\n\t\tfor(int j = max(0,K - a[i]); j <= K - 1 && !SUC; ++j)\n\t\t\tif(cur[j])SUC = 1;\n\t\tans += SUC;\n\t}\n\tprintf(\"%d\\n\",n - ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ls (o << 1)\n#define rs (o << 1 | 1)\n#define mid ((L + R) >> 1)\nusing namespace std;\nconst int MAXN = 100100;\nconst int mod = 998244353;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nint n, ll[MAXN], rr[MAXN];\npriority_queue<int> L;\npriority_queue<int, vector<int>, greater<int> > R;\nint main() {\n#ifdef TEST\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tscanf(\"%d\", &n);\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", &ll[i], &rr[i]);\n\t\tll[i] = rr[i] - ll[i];\n\t}\n\tL.push(rr[0]);\n\tR.push(rr[0]);\n\tLL l = 0, r = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tl += ll[i - 1];\n\t\tr += ll[i];\n\t\tLL topl = L.top() - l;\n\t\tLL topr = R.top() + r;\n\t\tif (rr[i] >= topl && rr[i] <= topr) {\n\t\t\tL.push(rr[i] + l);\n\t\t\tR.push(rr[i] - r);\n\t\t} else if (rr[i] > topr) {\n\t\t\tans += rr[i] - topr;\n\t\t\tL.push(topr + l);\n\t\t\tR.pop();\n\t\t\tR.push(rr[i] - r);\n\t\t\tR.push(rr[i] - r);\n\t\t} else {\n\t\t\tans += topl - rr[i];\n\t\t\tL.pop();\n\t\t\tR.push(topl - r);\n\t\t\tL.push(rr[i] + l);\n\t\t\tL.push(rr[i] + l);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef pair<int, int> P1;\ntypedef pair<int, pair<int, int> > P2;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\nstatic const int mod = 1000000007;\n\nint N;\nint L[100005],R[100005];\nint len[100005];\nint dp[5005][5005];\n\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<5000;++i)for(int j=0;j<5000;++j)dp[i][j]=INF;\n    for(int i=0;i<N;++i){\n        cin>>L[i]>>R[i];\n        len[i] = R[i]-L[i];\n    }\n    for(int i=1;i<5000;++i)dp[0][i] = abs(i-L[0]);\n    for(int i=0;i<N-1;++i){\n        for(int j=1;j<=400;++j){\n            for(int k=1;k<=400;++k){\n                int pl = k,pr = k+len[i];\n                int l=j,r=j+len[i+1];\n                if(pr<l||r<pl)continue;\n                //cout<<l<<\" \"<<pl<<endl;\n                //cout<<\"//////////////////\"<<endl;\n                dp[i+1][l] = min(dp[i+1][j],dp[i][pl] + abs(L[i]-l));\n                //cout<<dp[i+1][l]<<endl;\n            }\n        }\n    }\n    int ans=INF;\n    for(int i=1;i<=400;++i)ans=min(ans,dp[N-1][i]);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int INF=1e15;\nconst int width=401;\nint main(){\n  int n;\n  cin>>n;\n  vector<long long int> l(n),r(n);\n  for(int i=0;i<n;i++){\n    cin>>l[i]>>r[i];\n    if(r[i]>=width) return 1;\n  }\n\n  vector<vector<long long int>> dp(n,vector<long long int>(width,INF));\n  for(int i=0;i<width;i++){\n    dp[0][i]=abs(i-l[0]);\n  }\n  for(int i=1;i<n;i++){\n    for(int j=0;j<width;j++){\n      for(int k=0;k<width;k++){\n\tif(r[i]<k){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]+k-r[i]);\n\t}\n\telse if(k+r[i-1]-l[i-1]<l[i]){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]-(k+r[i-1]-l[i-1]-l[i]));\n\t}\n\telse{\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]);\n\t}\n      }\n    }\n  }\n  cout<<*min_element(dp[n-1].begin(),dp[n-1].end())<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst int mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint n;\nint l[400],r[400];\nint dp[2][401][401];\n\nint main(){\n    cin >> n;\n    if (n>400) return 0;\n    rep(i,n) cin >> l[i] >> r[i];\n    rep(i,2)rep(j,401)rep(k,401) dp[i][j][k]=INF;\n    rep2(j,1,401){\n        int w=r[0]-l[0];\n        if (j+w>400) break;\n        dp[1][j][j+w]=abs(l[0]-j);\n    }\n    rep2(i,1,n){\n        rep(j,401)rep(k,401){\n            dp[(i+1)%2][j][k]=INF;\n        }\n        rep(j,401)rep(k,401){\n            int w=r[i]-l[i];\n            if (k<l[i]){\n                dp[(i+1)%2][k][k+w]=min(dp[(i+1)%2][k][k+w],dp[i%2][j][k]+l[i]-k);\n            }\n            else if (r[i]<j){\n                dp[(i+1)%2][j-w][j]=min(dp[(i+1)%2][j-w][j],dp[i%2][j][k]+j-r[i]);\n            }\n            else{\n                dp[(i+1)%2][j][k]=min(dp[(i+1)%2][j][k],dp[i%2][j][k]);\n            }\n        }\n    }\n    int ans=INF;\n    int w=r[n-1]-l[n-1];\n    rep(j,400){\n        if (j+w>400) break;\n        ans=min(ans,dp[n%2][j][j+w]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n, l, r, c;\nll decL = 0, incR = 0;\npriority_queue<ll> pql;\npriority_queue<ll, vector<ll>, greater<ll>> pqr;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\tcin >> n >> l >> r;\n\tpql.push(l); pqr.push(l); c = 0;\n\n\tll lastsz = 0, cursz = r-l+1, ans = 0;\n\tfor(int i = 1; i < n; i++) {\n\t\tcin >> l >> r;\n\t\tlastsz = cursz; cursz = r-l+1;\n\n\t\tdecL -= cursz - 1;\n\t\tincR += lastsz - 1;\n\n\t\tif(l <= pql.top() + decL) {\n\t\t\tll x = pql.top() + decL;\n\t\t\tans += x - l;\n\t\t\tpql.push(l - decL);\n\t\t\tpql.push(l - decL);\n\t\t\tpql.pop();\n\t\t\tpqr.push(x - incR);\n\t\t} else if(l >= pqr.top() + incR) {\n\t\t\tll x = pqr.top() + incR;\n\t\t\tans += l - x;\n\t\t\tpqr.push(l - incR);\n\t\t\tpqr.push(l - incR);\n\t\t\tpqr.pop();\n\t\t\tpql.push(x - decL);\n\t\t} else {\n\t\t\tpql.push(l - decL);\n\t\t\tpqr.push(l - incR);\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace Task {\n\nconst int MAXN = 100000;\n#define long long long\n\nstd::multiset<int> setL, setR;\nint a[MAXN + 1], b[MAXN + 1];\nlong f[MAXN + 1];\n\ninline void solve() {\n    std::ios::sync_with_stdio(false), std::cin.tie(NULL), std::cout.tie(NULL);\n    register int n;\n    std::cin >> n;\n    for (register int i = 1; i <= n; i++) std::cin >> a[i] >> b[i];\n    setL.insert(a[1]), setR.insert(a[1]);\n    register long tl = 0, tr = 0, ans = 0, nl, nr;\n    for (register int i = 2; i <= n; i++) {\n        tl += b[i] - a[i], tr += b[i - 1] - a[i - 1];\n        nl = *setL.begin(), nr = *setR.begin();\n        if (nl - tl > a[i]) {\n            ans += std::abs(nl - tl - a[i]), setL.erase(setL.find(nl));\n            setL.insert(setL.insert(a[i] + tl), a[i] + tl);\n            setR.insert(nl - tl - tr);\n        } else if (a[i] > nr + tr) {\n            ans += std::abs(nr + tr - a[i]), setR.erase(setR.find(nr));\n            setR.insert(setR.insert(a[i] - tr), a[i] - tr);\n            setL.insert(nr + tr + tl);\n        } else {\n            setL.insert(a[i] + tl), setR.insert(a[i] - tr);\n        }\n    }\n    std::cout << ans;\n}\n\n#undef long\n}\n\nint main() {\n    Task::solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nstruct PQ{\n\tpriority_queue<ll>pq;\n\tll tag;\n\tll top(){return pq.top()+tag;}\n\tvoid pop(){pq.pop();}\n\tvoid add(ll x){tag+=x;}\n\tvoid push(ll x){pq.push(x-tag);}\n}L,R;\nint n;\nll ans;\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;L.push(0);R.push(-1e18);\n\tfor(int i=1;i<=n;++i){\n\t\tint l,r;cin>>l>>r;R.add(l-r);\n\t\tll u=L.top(),v=-R.top();\n\t\tif(u<=r&&r<=v)L.push(r),R.push(-r);\n\t\telse if(u<=r){\n\t\t\tans+=r-v;R.pop();L.push(v);\n\t\t\tR.push(-r);R.push(-r);\n\t\t}else{\n\t\t\tans+=u-r;L.pop();R.push(-u);\n\t\t\tL.push(r);L.push(r);\n\t\t}\n\t\tL.add(l-r);\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n\nint main() {\n  int N;\n  std::cin >> N;\n\n  std::vector<long long> l(N);\n  std::vector<long long> r(N);\n\n  for (int i = 0; i < N; ++i)\n    std::cin >> l[i] >> r[i];\n\n  std::vector<long long> W(N);\n  for (int i = 0; i < N; ++i)\n    W[i] = r[i] - l[i];\n\n  std::vector<std::vector<long long>> bpX(N);\n  std::vector<std::vector<long long>> bpY(N);\n  std::vector<int> minIndex(N, -1);\n\n  const long long M = 10000000000;\n  bpX[0].push_back(-M);\n  bpX[0].push_back(l[0]);\n  bpX[0].push_back(M);\n  bpY[0].push_back(l[0] + M);\n  bpY[0].push_back(0);\n  bpY[0].push_back(M - l[0]);\n  minIndex[0] = 1;\n\n  for (int i = 1; i < N; ++i) {\n    // # 左右に分割する\n    for (int j = 0; j <= minIndex[i - 1]; ++j) {\n      bpX[i].push_back(bpX[i - 1][j] - W[i]);\n      bpY[i].push_back(bpY[i - 1][j]);\n    }\n    for (int j = minIndex[i - 1]; j < bpX[i - 1].size(); ++j) {\n      bpX[i].push_back(bpX[i - 1][j] + W[i - 1]);\n      bpY[i].push_back(bpY[i - 1][j]);\n    }\n\n    // 新しいコストを足す\n\n    // まず挿入する点を見つける\n    int k = 0; // bpX[i][k] <= l[i] < bpX[i][k + 1]\n    while (bpX[i][k + 1] <= l[i])\n      ++k;\n\n    for (int j = 0; j <= k; ++j)\n      bpY[i][j] += l[i] - bpX[i][j];\n\n    // insert\n    bool insert = false;\n    if (bpX[i][k] < l[i]) {\n\n      long long grad = (bpY[i][k + 1] - (bpY[i][k] - (l[i] - bpX[i][k]))) /\n                       (bpX[i][k + 1] - bpX[i][k]);\n      long long value =\n          (bpY[i][k] - (l[i] - bpX[i][k])) + grad * (l[i] - bpX[i][k]);\n\n      bpX[i].insert(bpX[i].begin() + k + 1, l[i]);\n      bpY[i].insert(bpY[i].begin() + k + 1, value);\n      insert = true;\n    }\n\n    // std::cout << \"insert = \" << insert << std::endl;\n    if (insert) {\n      for (int j = k + 2; j < bpX[i].size(); ++j)\n        bpY[i][j] += bpX[i][j] - l[i];\n    } else {\n      for (int j = k + 1; j < bpX[i].size(); ++j)\n        bpY[i][j] += bpX[i][j] - l[i];\n    }\n\n    long long minVal = M;\n    for (int j = 0; j < bpX[i].size(); ++j) {\n      if (bpY[i][j] < minVal) {\n        minIndex[i] = j;\n        minVal = bpY[i][j];\n      }\n    }\n  }\n\n  std::cout << bpY[N - 1][minIndex[N - 1]] << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb         push_back\n\ntypedef long long ll;\nconst ll INF = 1000000000000000000ll;\nconst ll MOD = 1000000007ll;\nconst double EPS = 1e-8;\n\nint main(void) {\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie(0);\n\t\n\tint x;\n\tcin >> x;\n\n\tint ans = 0;\n\tfor(int i=1; i<=x; i++){\n\t\tans += i;\n\t\tif(ans >= x){\n\t\t\tcout << i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 5000\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\nint maxpos=-1 , minpos=LINF;\n\nll mem[MAXN][MAXN];\nll dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\tif(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tll ans = LINF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\tmem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\tmsn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\tminpos = min( minpos , l[i] );\n\t\tmaxpos = max( maxpos , l[i] );\n\t}\n\t\n\tll ans = LINF;\n\tfor(int i = minpos;i <= maxpos;i++)\n\t\tans = min(  ans  ,  dp(1,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cout << #x << \" = \" << (x) << \"\\n\";\n\nconst int MAXN = 3e6 + 5;\nint ptr;\nstruct Node {\n\tNode *l, *r, *p;\n\tint size;\n\tlong long key, lz;\n\tint rev;\n\tNode();\n\tvoid clear();\n} mem[MAXN], *nil = (mem + ptr++);\n\nNode::Node() {\n\tclear();\n}\nvoid Node::clear() {\n\tl = r = p = nil;\n\tsize = 1, key = rev = lz = 0;\n}\n\ninline Node* newNode(long long key) {\n\tmem[ptr].clear();\n\tmem[ptr].key = key;\n\treturn mem + (ptr++);\n}\ninline void init() {\n\tptr = 1;\n\tnil->l = nil->r = nil->p = nil;\n\tnil->size = 0;\n}\ninline void normalize(Node*& x) {if (!x) x = nil;}\ninline int isrt(Node* x) {\n\tnormalize(x);\n\treturn x->p == nil || (x->p->l != x && x->p->r != x);\n}\ninline void setchild(Node* p, Node* c, int l) {\n\tnormalize(p), normalize(c);\n\tc->p = p; l ? p->l = c : p->r = c;\n}\ninline void updatelz(Node* x, long long val) {\n\tnormalize(x);\n\tif (x == nil) return;\n\tx->lz += val;\n\tx->key += val;\n}\ninline void pushdown(Node* x) {\n\tnormalize(x);\n\tif (x == nil) return;\n\tNode *u = x->l, *v = x->r;\n\tif (x->rev) {\n\t\tif (u != nil) {swap(u->l, u->r); u->rev ^= 1;}\n\t\tif (v != nil) {swap(v->l, v->r); v->rev ^= 1;}\n\t\tx->rev = 0;\n\t}\n\tif (x->lz) {\n\t\tif (u != nil) updatelz(u, x->lz);\n\t\tif (v != nil) updatelz(v, x->lz);\n\t\tx->lz = 0;\n\t}\n}\ninline void pushup(Node* x) {\n\tnormalize(x);\n\tx->size = x->l->size + x->r->size + 1;\n}\ninline void rotate(Node* x) {\n\tnormalize(x);\n\tNode* y = x->p;\n\tint l = x->p->l == x;\n\tif (!isrt(y)) {\n\t\tsetchild(y->p, x, y->p->l == y);\n\t}\n\telse {\n\t\tx->p = y->p;\n\t}\n\tsetchild(y, l ? x->r : x->l, l);\n\tsetchild(x, y, !l);\n\tpushup(y);\n}\ninline void splay(Node* x) {\n\tnormalize(x);\n\tpushdown(x);\n\twhile (!isrt(x)) {\n\t\tpushdown(x->p->p); pushdown(x->p); pushdown(x);\n\t\tif (!isrt(x->p)) rotate((x->p->l == x) == (x->p->p->l == x->p) ? x->p : x);\n\t\trotate(x);\n\t}\n\tpushup(x);\n}\ninline void insert(Node*& x, long long key) {\n\tnormalize(x);\n\tNode* p = nil;\n\twhile (x != nil) {\n\t\tpushdown(x);\n\t\tp = x;\n\t\tif (x->key < key) x = x->r;\n\t\telse x = x->l;\n\t}\n\tx = newNode(key);\n\tx->p = p;\n\tif (p != nil) {\n\t\tif (p->key < x->key) p->r = x;\n\t\telse p->l = x;\n\t}\n\tsplay(x);\n}\ninline Node* findkey(Node*& x, long long key) {\n\tnormalize(x);\n\twhile (x != nil) {\n\t\tpushdown(x);\n\t\tif (x->key < key) x = x->r;\n\t\telse if (key < x->key) x = x->l;\n\t\telse {\n\t\t\tsplay(x);\n\t\t\treturn x;\n\t\t}\n\t}\n\treturn nil;\n}\ninline Node* findpos(Node*& x, int pos) {\n\tnormalize(x);\n\twhile (1) {\n\t\tpushdown(x);\n\t\tint k = x->l ? x->l->size + 1 : 1;\n\t\tif (pos == k) {\n\t\t\tsplay(x);\n\t\t\treturn x;\n\t\t}\n\t\telse if (pos < k) x = x->l;\n\t\telse {x = x->r; pos -= k;}\n\t}\n\treturn nil;\n}\ninline Node* join(Node* x, Node* y) {\n\tnormalize(x), normalize(y);\n\tx->p = y->p = nil;\n\tif (x == nil) return y;\n\tif (y == nil) return x;\n\tpushdown(y);\n\twhile (1) {\n\t\tpushdown(x);\n\t\tif (x->r == nil) break;\n\t\tx = x->r;\n\t}\n\tsplay(x);\n\tsetchild(x, y, 0);\n\tpushup(x);\n\treturn x;\n}\ninline void erase(Node*& x, long long key) {\n\tnormalize(x);\n\tNode* y = findkey(x, key);\n\ty->l->p = y->r->p = nil;\n\tx = join(y->p, y->r);\n}\ninline void split(Node* x, int pos, Node*& l, Node*& r) {\n\tnormalize(x);\n\tif (!pos) {l = nil; r = x; return;}\n\tNode* y = findpos(x, pos);\n\tif ((r = y->r) != nil) r->p = nil;\n\tif ((l = y) != nil) {l->r = nil; pushup(l);}\n}\ninline void split(Node* x, int l, int r, Node*& y, Node*& z, Node*& t) {\n\tnormalize(x);\n\tsplit(x, l - 1, y, z);\n\tsplit(z, r - l + 1, z, t);\n}\ninline void reverse(Node*& rt, int l, int r) {\n\tnormalize(rt);\n\tNode *x, *y, *z, *t;\n\tsplit(rt, r, t, z);\n\tsplit(t, l - 1, x, y);\n\tif (y) {\n\t\tswap(y->l, y->r);\n\t\ty->rev ^= 1;\n\t}\n\trt = join(join(x, y), z);\n}\ninline void upd(Node*& rt, int l, int r, long long val) {\n\tnormalize(rt);\n\tNode *x, *y, *z;\n\tsplit(rt, l, r, x, y, z);\n\tupdatelz(y, val);\n\trt = join(join(x, y), z);\n}\n\nconst int maxn = 1e5 + 5;\nint n;\nint l[maxn];\nint r[maxn];\nNode* rt;\n\nvoid solve() {\n\tinit();\n\tcin >> n;\n\tFOR(i, 0, n) cin >> l[i] >> r[i];\n\tlong long ans = 0;\n\tint pos = 1;\n\tinsert(rt, l[0]);\n\tinsert(rt, l[0]);\n\tFOR(i, 1, n) {\n\t\tfindpos(rt, pos);\n\t\tlong long x = rt->key + (l[i] - r[i]);\n\t\tupd(rt, 1, pos, l[i] - r[i]);\n\t\tupd(rt, pos + 1, rt->size, r[i - 1] - l[i - 1]);\n\t\tinsert(rt, l[i]);\n\t\tinsert(rt, l[i]);\n\t\tfindpos(rt, ++pos);\n\t\tif (l[i] <= x) {\n\t\t\tlong long y = rt->key;\n\t\t\tans += x - y;\n\t\t\tans += y - l[i];\n\t\t}\n\t\telse if (l[i] > x) {\n\t\t\tlong long y = rt->key;\n\t\t\tans += l[i] - y;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\npriority_queue<ll> PQL, PQR;\nll pbl, pbr;\nll Ans;\n \nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tll l, r, len;\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tcin >> l >> r;\n\t\tlen = r - l;\n\n\t\tpbr += len;\n\t\tPQL.push(r - pbl);\n\t\tPQR.push(pbr - r);\n\t\twhile (true) {\n\t\t\tll L = PQL.top() + pbl;\n\t\t\tll R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t}\n\t\tpbl -= len;\n\t}\n\t\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\npriority_queue<ll> pq1;\nll bias;\npriority_queue<ll,vector<ll>,greater<ll> > pq2;\nll res;\n\nvoid push(ll a, ll b) {\n    if (pq1.empty()) {\n        pq1.push(a); pq2.push(b);\n        return;\n    }\n    bias += b-a;\n    if (a<=pq1.top()-bias) {\n        res += pq1.top()-bias-a;\n        pq2.push(pq1.top()-bias);\n        pq1.pop();\n        pq1.push(a);\n        pq1.push(a);\n    }\n    else if (a<=pq2.top()) {\n        pq1.push(a+bias);\n        pq2.push(a);\n    }\n    else {\n        res += a-pq2.top();\n        pq1.push(pq2.top()+bias);\n        pq2.pop();\n        pq2.push(a);\n        pq2.push(a);\n    }\n}\n\nint main() {\n    int i;\n    scanf(\"%d\",&n);\n    for (i=0;i<n;i++) {\n        ll a, b;\n        scanf(\"%lld%lld\",&a,&b);\n        push(a,b);\n    }\n    printf(\"%lld\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define ABS(a) (((a)>0)?(a):(-(a)))\nint n,l[1005],r[1005],dp[1005][1005];\nint main(){\n\tscanf(\"%d\",&n);\n\tint xb,x2,x3,res=1e9;\n\tfor(xb=0;xb<n;xb++) scanf(\"%d%d\",&l[xb],&r[xb]);\n\tif(n==1){\n\t\tprintf(\"0\");\n\t\treturn 0;\n\t}\n\tfor(xb=1;xb<n;xb++){\n\t\tfor(x2=0;x2<1000;x2++){\n\t\t\tint rb=x2+r[xb]-l[xb];\n\t\t\tif(rb>=1000) rb=999;\n\t\t\tdp[xb][x2]=1e9;\n\t\t\tfor(x3=MAX(0,x2+l[xb-1]-r[xb-1]-3);x3<=rb;x3++){\n\t\t\t\tdp[xb][x2]=MIN(dp[xb][x2],dp[xb-1][x3]+ABS(x3-l[xb-1]));\n\t\t\t}\n\t\t\tif(xb==n-1) res=MIN(res,dp[xb][x2]+ABS(l[xb]-x2));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nconst int maxn = 410;\nconst int INF = 1<<30;\n\nint f[maxn][maxn];\nint l[maxn], r[maxn];\n\nint main()\n{\n\t//freopen(\"E.in\",\"r\",stdin);\n\t//freopen(\"E.out\",\"w\",stdout);\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\t\n\tfor (int i=0;i<maxn;i++)\n\t\tfor (int j=0;j<maxn;j++) f[i][j] = INF;\n\tfor (int i=max(r[1]-l[1],1);i<maxn;i++) f[1][i] = abs(r[1] - i);\n\t\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=0;j<maxn;j++)\n\t\t{\n\t\t\tfor (int x=-maxn/2;x<maxn/2;x++)\n\t\t\t{\n\t\t\t\tint newl = l[i+1] - x, newr = r[i+1] - x;\n\t\t\t\tif (newl <= 0) break;\n\t\t\t\tif (newl <= j) f[i+1][newr] = min(f[i+1][newr], f[i][j] + abs(x));\n\t\t\t\t//cout<<i<<\" \"<<i+1<<\" \"<<j<<\" \"<<x<<\" \"<<newr<<\" \"<<f[i][j]+abs(x)<<\" \"<<f[i+1][newr]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i=0;i<maxn;i++) ans = min(ans,f[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n \n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n \nstruct Narou{\n\tusing D = ll;\n\tpriority_queue<D> L;\n\tpriority_queue<D,V<D>,greater<D>> R;\n\tll offL = 0, offR = 0;\n\tll bottom = 0;\n \n\t// initially f(x) = 0\n \n\tvoid Min(D l,D r){\t// f'(x) := min_[y+l,y+r] f(y)\n\t\tassert(l <= r);\n\t\toffL -= r;\n\t\toffR -= l;\n\t}\n\tvoid Add(ll s){\t\t// f'(x) := f(x) + |x-s|\n\t\toffL -= s, offR -= s;\n\t\tif(L.empty()){\n\t\t\tL.push(0-offL); R.push(0-offR);\n\t\t\toffL += s, offR += s;\n\t\t\treturn;\n\t\t}\n\t\tD le = L.top() + offL, ri = R.top() + offR;\n\t\tif(le <= 0 && 0 <= ri){\n\t\t\tL.push(0-offL); R.push(0-offR);\n\t\t}else if(ri < 0){\n\t\t\tbottom += -ri;\n\t\t\tL.push(ri-offL); R.pop();\n\t\t\tR.push(0-offR); R.push(0-offR);\n\t\t}else{\n\t\t\tbottom += le;\n\t\t\tR.push(le-offR); L.pop();\n\t\t\tL.push(0-offL); L.push(0-offL);\n\t\t}\n\t\toffL += s, offR += s;\n\t}\n\tvoid AddConst(ll c){\t// f'(x) = f(x) + c\n\t\tbottom += c;\n\t}\n\tD f(ll s){\t\t//O(N) :(\n\t\toffL -= s, offR -= s;\n\t\tD le = L.top() + offL, ri = R.top() + offR;\n\t\tll res = bottom;\n\t\tif(le <= 0 && 0 <= ri){\n\t\t}else if(ri < 0){\n\t\t\tauto cp = R;\n\t\t\trep1(k,cp.size()){\n\t\t\t\tR.pop();\n\t\t\t\tD nri = R.empty() ? 0 : R.top() + offR;\n\t\t\t\tif(nri >= 0){\n\t\t\t\t\tR = cp;\n\t\t\t\t\tres += (-ri) * k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += (nri-ri) * k;\n\t\t\t\tri = nri;\n\t\t\t}\n\t\t}else{\n\t\t\tauto cp = L;\n\t\t\trep1(k,cp.size()){\n\t\t\t\tL.pop();\n\t\t\t\tD nle = L.empty() ? 0 : L.top() + offL;\n\t\t\t\tif(nle <= 0){\n\t\t\t\t\tL = cp;\n\t\t\t\t\tres += le * k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += (le-nle) * k;\n\t\t\t\tle = nle;\n\t\t\t}\n\t\t}\n\t\toffL += s, offR += s;\n\t\treturn res;\n\t}\n};\n \nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tint N;\n\tcin >> N;\n\tV<ll> l(N),r(N);\n\trep(i,N) cin >> l[i] >> r[i];\n\tNarou f;\n\trep(i,N){\n\t\tif(i) f.Min(l[i-1]-r[i-1],r[i]-l[i]);\n\t\tf.Add(l[i]);\n\t}\n\tcout << f.bottom << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define V vector<int>\n#define P pair<int, int>\n#define mp make_pair<int&, int>\nint N, l[100010], r[100010];\nmultiset<int> sl, sr;\nint ld, rd;\nint le, rb;\nvoid ins(int l, int r)\n{\n    if (le >= r - rd) {\n        sl.insert(l + ld);\n        sl.insert(r + ld);\n        sl.erase(le);\n        sr.insert(le - ld - rd);\n    } else if (rb <= l + ld) {\n        sr.insert(l - rd);\n        sr.insert(r - rd);\n        sr.erase(rb);\n        sl.insert(rb + rd + ld);\n    } else {\n        sr.insert(r - rd);\n        sl.insert(l + ld);\n    }\n}\nvoid show()\n{\n    auto it = sl.begin();\n    while (it != sl.end()) {\n        int value = *it;\n        std::cout << value - ld << \" \";\n        ++it;\n    }\n    cout << endl;\n    it = sr.begin();\n    while (it != sr.end()) {\n        int value = *it;\n        std::cout << value + rd << \" \";\n        ++it;\n    }\n    cout << endl\n         << endl;\n}\nvoid solve()\n{\n    int ans = 0;\n    FOR(i, 0, N)\n    {\n        if (i == 0) {\n            sl.insert(l[i]);\n            sr.insert(l[i]);\n        }\n        if (i == 0)\n            continue;\n        int L = r[i] - l[i];\n        int LB = r[i - 1] - l[i - 1];\n        ld += L;\n        rd += LB;\n        //show();\n\n        /*\n        le = *(--sl.end());\n        rb = *(sr.begin());\n\n        if (le >= r[i] - rd) {\n            sl.insert(l[i] + ld);\n            sl.insert(r[i] + ld);\n            sl.erase(le);\n            sr.insert(le - ld - rd);\n            cout << 'a' << endl;\n        } else if (rb <= l[i] + ld) {\n            sr.insert(l[i] - rd);\n            sr.insert(r[i] - rd);\n            sr.erase(rb);\n            sl.insert(rb + rd + ld);\n            cout << 'b' << endl;\n        } else {\n            sr.insert(r[i] - rd);\n            sl.insert(l[i] + ld);\n            cout << 'c' << endl;\n        }\n        show();*/\n        int lep, rbp;\n        lep = le;\n        rbp = rb;\n        le = *(--sl.end());\n        auto lei = --sl.end();\n        rb = *(sr.begin());\n        auto rbi = sr.begin();\n        if (le - ld > l[i]) {\n            sl.insert(l[i] + ld);\n            sl.insert(l[i] + ld);\n            //le = *(--sl.end());\n            //lei = --sl.end();\n            sl.erase(lei);\n            sr.insert(le - ld - rd);\n            le = *(--sl.end());\n            auto lei = --sl.end();\n            rb = *(sr.begin());\n            auto rbi = sr.begin();\n            while (*lei - ld == rb + rd) {\n                lei--;\n            }\n            ans += rb + rd - *lei + ld;\n            // ans += le - *(--lei);\n            // cout << 'A' << endl;\n        } else if (rb + rd < l[i]) {\n            sr.insert(l[i] - rd);\n            sr.insert(l[i] - rd);\n            //rb = *(sr.begin());\n            //rbi = sr.begin();\n            sr.erase(rbi);\n            sl.insert(rb + rd + ld);\n            le = *(--sl.end());\n            auto lei = --sl.end();\n            rb = *(sr.begin());\n            auto rbi = sr.begin();\n            while (*rbi + rd == le - ld) {\n                rbi++;\n            }\n            //cout << *rbi + rd - le + ld << endl;\n            ans += *rbi + rd - le + ld;\n            //  ans += *(++rbi) - rb;\n            // cout << 'B' << endl;\n        } else {\n            sr.insert(l[i] - rd);\n            sl.insert(l[i] + ld);\n            //cout << 'C' << endl;\n        }\n        le = *(--sl.end());\n        rb = *(sr.begin());\n        //ans += rb + rd - le + ld;\n        // show();\n        // dump(ans)\n    }\n    //show();\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    FOR(i, 0, N)\n    cin >> l[i] >> r[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __numeric {\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type floor(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d - ((n < 0) && (n % d));\n    }\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type ceil(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d + ((n > 0) && (n % d));\n    }\n};\nusing namespace __numeric;\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nstruct monostate {\n    friend istream& operator>>(istream& is, const monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const monostate& ms) { return os; }\n    friend monostate operator+(const monostate& a, const monostate& b) { return a; }\n} ms;\n#pragma GCC diagnostic pop\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\ntemplate<typename T> struct PWLC {\n    T y0;\n    max_heap<pair<T, T>> left;\n    min_heap<pair<T, T>> right;\n    T left_offset = 0, right_offset = 0;\n\n    PWLC(T _y0 = 0) : y0(_y0) {}\n\n    /* __ : y = alpha */\n    static PWLC constant(T alpha) { return PWLC(alpha); }\n    /* \\_ : y = max(0, beta * (x - x0)) */\n    static PWLC decreasing(T x0, T beta = -1) { assert(beta <= 0); PWLC f; f.left.push({ x0, -beta }); return f; }\n    /* _/ : y = max(0, beta * (x - x0)) */\n    static PWLC increasing(T x0, T beta =  1) { assert(beta >= 0); PWLC f; f.right.push({ x0, beta }); return f; }\n    /* \\/ : y = beta * abs(x - x0) */\n    static PWLC abs(T x0, T beta = 1) { return decreasing(x0, -beta) + increasing(x0, beta); }\n\n    /* f'(x) = f(x + c) */\n    void shift(int c) { left_offset -= c; right_offset -= c; }\n    /* \\_/ => \\__ : f'(x') = min_{x <= x'} f(x) */\n    void prefix_min() { while (!right.empty()) right.pop(); }\n    /* \\_/ => __/ : f'(x') = min_{x >= x'} f(x) */\n    void suffix_min() { while (!left.empty()) left.pop(); }\n\t/* \\_/ => \\__/ : f'(x') = min_{dx in [xl, xr]} f(x' + dx) */\n\tvoid range_min(T xl, T xr) {\n\t\tassert(xl <= xr);\n\t\tif (xl > 0) shift(xl), tie(xl, xr) = make_pair(0, xr - xl);\n\t\tif (xr < 0) shift(xr), tie(xl, xr) = make_pair(xl - xr, 0);\n\t\tleft_offset -= xr;\n\t\tright_offset -= xl;\n\t}\n\n    T minimum() const { return y0; }\n\tT left_arg_min() const { return left.empty() ? numeric_limits<T>::min() : (left.top().first + left_offset); }\n\tT right_arg_min() const { return right.empty() ? numeric_limits<T>::max() : (right.top().first + right_offset); }\n\n    PWLC operator+=(PWLC o) {\n        y0 += o.y0;\n\t\tfor (; !o.left.empty(); o.left.pop()) {\n\t\t\tT x = o.left.top().first + o.left_offset;\n\t\t\tT beta_change = o.left.top().second;\n\n\t\t\tif (x <= right_arg_min()) {\n\t\t\t\tleft.push({ x - left_offset, beta_change });\n\t\t\t} else {\n\t\t\t\tT x0 = right_arg_min();\n\t\t\t\ty0 += (x - x0) * beta_change;\n\t\t\t\tright.push({ x - right_offset, beta_change });\n\t\t\t\tfor (T beta = beta_change; beta > 0; ) {\n\t\t\t\t\tT next_change = right.top().second;\n\t\t\t\t\tright.pop();\n\t\t\t\t\tif (next_change >= beta) {\n\t\t\t\t\t\tleft.push({ x0 - left_offset, beta });\n\t\t\t\t\t\tif (next_change > beta) right.push({ x0 - right_offset, next_change - beta });\n\t\t\t\t\t\tbeta = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbeta -= next_change;\n\t\t\t\t\t\ty0 -= beta * (right_arg_min() - x0);\n\t\t\t\t\t\tx0 = right_arg_min();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (; !o.right.empty(); o.right.pop()) {\n\t\t\tT x = o.right.top().first + o.right_offset;\n\t\t\tT beta_change = o.right.top().second;\n\n\t\t\tif (x >= left_arg_min()) {\n\t\t\t\tright.push({ x - right_offset, beta_change });\n\t\t\t} else {\n\t\t\t\tT x0 = left_arg_min();\n\t\t\t\ty0 += (x0 - x) * beta_change;\n\t\t\t\tleft.push({ x - left_offset, beta_change });\n\t\t\t\tfor (T beta = beta_change; beta > 0; ) {\n\t\t\t\t\tT next_change = left.top().second;\n\t\t\t\t\tleft.pop();\n\t\t\t\t\tif (next_change >= beta) {\n\t\t\t\t\t\tright.push({ x0 - right_offset, beta });\n\t\t\t\t\t\tif (next_change > beta) left.push({ x0 - left_offset, next_change - beta });\n\t\t\t\t\t\tbeta = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbeta -= next_change;\n\t\t\t\t\t\ty0 -= beta * (x0 - left_arg_min());\n\t\t\t\t\t\tx0 = left_arg_min();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn *this;\n    }\n\tfriend PWLC operator+(const PWLC &a, const PWLC &b) { return PWLC(a) += b; }\n};\n\nint main() {\n    setIO();\n\n    int N; re(N);\n\n    PWLC<ll> f;\n\tF0R (i, N) {\n        int l, r; re(l, r);\n        f.range_min(0, r - l); // if this one has left endpoint at x, previous must touch [x, x + r - l]\n        f += PWLC<ll>::abs(l); // cost for this to have left endpoint at x\n        f.range_min(l - r, 0); // for this to touch x, it should have left endpoint in [x - (r - l), x]\n        //cerr << f.minimum() << \" \" << f.left_arg_min() << \" \" << f.right_arg_min() << endl;\n\t}\n\n\tps(f.minimum());\n\n    // did you check N=1? did you mix up N,M?\n    // check your \"infinity\" and \"null\" values against the bounds\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//部分点\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#define int long long\nusing namespace std;\n\nconst int MAX = 10000;\nint n;\nint l[400], r[400];\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tif (n > 400) {\n\t\tassert(0);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (r[i] > MAX) {\n\t\t\tassert(0);\n\t\t}\n\t}\n\t\n\tint ans = MAX * MAX;\n\t\n\tfor (i = 0; i <= MAX; i++) {\n\t\tint cst = 0;\n\t\t\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i < l[j]) {\n\t\t\t\tcst += l[j] - i;\n\t\t\t}\n\t\t\telse if (i <= r[j]) {\n\t\t\t\tcst += 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcst += i - r[j];\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cst);\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e10\nusing namespace std;\n\nconst int maxn = 210000;\n\nint n;\nmultiset<ll>ql,qr;\nll L,R,len,re;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,las=0;i<=n;i++,las=len)\n\t{\n\t\tll l,r; scanf(\"%lld%lld\",&l,&r);\n\t\tlen=r-l;\n\t\tif(i==1)\n\t\t{\n\t\t\tql.insert(-inf); ql.insert(l);\n\t\t\tqr.insert(inf); qr.insert(l);\n\t\t\tcontinue;\n\t\t}\n\t\tL-=len,R+=las;\n\t\tll pl=*ql.rbegin()+L,pr=*qr.begin()+R;\n\t\tif(l<pl)\n\t\t{\n\t\t\tql.insert(l-L); ql.insert(l-L);\n\t\t\tql.erase(*ql.rbegin());\n\t\t\tre+=pl-l;\n\t\t\tqr.insert(pl-R);\n\t\t}\n\t\telse if(l<=pr)\n\t\t\tql.insert(l-L),qr.insert(l-R);\n\t\telse\n\t\t{\n\t\t\tqr.insert(l-R); qr.insert(l-R);\n\t\t\tqr.erase(*qr.begin());\n\t\t\tre+=l-pr;\n\t\t\tql.insert(pr-L);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst int mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint n;\nint l[405],r[405];\nvvvi dp(405,vvi(405,vi(405,1e9)));\n\nint main(){\n    cin >> n;\n    if (n>400) return 0;\n    rep(i,n) cin >> l[i] >> r[i];\n    rep2(j,1,401){\n        int w=r[0]-l[0];\n        if (j+w>400) break;\n        dp[1][j][j+w]=abs(l[0]-j);\n    }\n    rep2(i,1,n)rep(j,401)rep(k,401){\n        int w=r[i]-l[i];\n        if (k<l[i]){\n            dp[i+1][k][k+w]=min(dp[i+1][k][k+w],dp[i][j][k]+l[i]-k);\n        }\n        else if (r[i]<j){\n            dp[i+1][j-w][j]=min(dp[i+1][j-w][j],dp[i][j][k]+j-r[i]);\n        }\n        else{\n            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n        }\n    }\n    int ans=INF;\n    int w=r[n-1]-l[n-1];\n    rep(j,400){\n        if (j+w>400) break;\n        ans=min(ans,dp[n][j][j+w]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 410;\nint n;\nint l[maxn] , r[maxn];\nint dp[maxn][maxn];\nint ans;\nvoid work () {\n\tint i , j , k;\n\tscanf ( \"%d\" , &n );\n\tfor ( i = 1 ; i <= n ; i++ ) scanf ( \"%d%d\" , &l[i] , &r[i] );\n\tfor ( i = 1 ; i <= 400 ; i++ ) dp[1][i] = abs ( l[1] - i );\n\tfor ( i = 2 ; i <= n ; i++ ) for ( j = 1 ; j <= 400 ; j++ ) {\n\t\tdp[i][j] = 99999999;\n\t\tfor ( k = max ( j - (r[i-1]-l[i-1]) , 1 ) ; k <= min ( j + (r[i]-l[i]+1) , 400 ) ; k++ ) {\n\t\t\tdp[i][j] = min ( dp[i][j] , dp[i-1][k] );\n\t\t}\n\t\tdp[i][j] += abs ( l[i] - j );\n\t\t//printf ( \"%d %d %d\\n\" , i , j , dp[i][j] );\n\t}\n\tans = dp[n][1];\n\tfor ( i = 1 ; i <= 400 ; i++ ) ans = min ( ans , dp[n][i] );\n\tprintf ( \"%d\\n\" , ans );\n}\nint main () {\n\twork ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef priority_queue<ll> pq;\nll n, ml, mr, ans, a[100005], b[100005];\npq l, r;\n\nll upd (pq &A, pq &B, ll G) {\n\tans += G;\n\tA.push(A.top() + mr - ml);\n\tll V = B.top(); B.pop();\n\tB.push(V - G);\n\tB.push(V - G);\n\treturn V - B.top();\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t}\n\n\tl.push(0); r.push(0);\n\tml = b[1]; mr = b[1];\n\n\tfor(ll i=2;i<=n;i++) {\n\t\tml -= b[i-1] - a[i-1];\n\t\tmr += b[i] - a[i];\n\t\tif(ml <= b[i] && b[i] <= mr) {\n\t\t\tll GL = b[i] - ml, GR = mr - b[i];\n\t\t\tl.push(l.top()+GL);\n\t\t\tr.push(r.top()+GR);\n\t\t\tml = b[i]; mr = b[i];\n\t\t}\n\t\telse if(b[i] < ml) {\n\t\t\tll V = upd(r, l, ml - b[i]);\n\t\t\tmr = ml; ml = mr - V;\n\t\t}\n\t\telse {\n\t\t\tll V = upd(l, r, b[i] - mr);\n\t\t\tml = mr; mr = ml + V;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Night's template\n//orzakyrt\n#include <bits/stdc++.h>\n#define R register\n#define LL long long\n#ifdef __DEBUG__\n\t#define Debug (fprintf(stderr,\"orzyrt\\n\"),fflush(stderr))\n\t#define debug(__a...) (fprintf(stderr,__a),fflush(stderr))\n\t#define setfile(__a) ('orzyrt')\n\t#define Compile(__a) system(\"g++ \"__a\".cpp -lm -o \"__a)\n#else\n\t#define Debug ('orzyrt')\n\t#define debug(__a...) ('orzyrt')\n\t#define setfile(__a) freopen(__a\".in\",\"r\",stdin);freopen(__a\".out\",\"w\",stdout)\n\t#define Compile(__a) ('orzyrt')\n#endif\ntemplate<class TT>inline TT Max(R TT a,R TT b){return a<b?b:a;}\ntemplate<class TT>inline TT Min(R TT a,R TT b){return a<b?a:b;}\ntemplate<class TT>inline TT Abs(R TT a){return a<0?-a:a;}\ntemplate<class TT>inline TT cmin(R TT &a,R TT b){(b<a)&&(a=b);}\ntemplate<class TT>inline TT cmax(R TT &a,R TT b){(a<b)&&(a=b);}\nusing namespace std;\ntemplate<class TT>inline void read(R TT &x){\n\tx=0;R bool f=false;R char c=getchar();\n\tfor(;c<48||c>57;c=getchar())f|=(c=='-');\n\tfor(;c>47&&c<58;c=getchar())x=(x<<1)+(x<<3)+(c^48);\n\t(f)&&(x=-x);\n}\n//end template\n\nnamespace Night{\n\tconst int maxn = 200010;\n\tint n;\nLL addl,addr,ans;\n\tpriority_queue<LL>le; \n\tpriority_queue<LL,vector<LL>,greater<LL> >ri;\n\tvoid pushl(R LL x){le.push(x-addl);}\n\tvoid pushr(R LL x){ri.push(x-addr);}\n\tint main(){\n\t\tread(n);\n\t\tfor(R int l,r,len;n--;){\n\t\t\tread(l);read(r);\n\t\t\taddr+=(len=r-l);\n\t\t\tpushl(r);pushr(r);\n\t\t\tfor(R LL tpl,tpr;(tpl=le.top()+addl)>(tpr=ri.top()+addr);){\n\t\t\t\tans+=tpl-tpr;\n\t\t\t\tle.pop();ri.pop();\n\t\t\t\tpushl(tpr);pushr(tpl);\n\t\t\t}\n\t\t\taddl-=len;\n\t\t}\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n}\nint main(){\n\treturn Night::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\nstruct st{\n    int l,r,x;\n};\nint main(){\n    vector<st> vp;\n    int n;\n    cin>>n;\n    assert(n<=500);\n    rep(i,n){\n        int l,r,x;\n        cin>>l>>r;\n        assert(r<=500);\n        vp.pb(st{l,r,r-l});\n    }\n    \n    int dp[501][501];\n    rep(i,501)rep(j,501)dp[i][j] = INF;\n    rep(j,400){\n        int l,r,x;\n        l = vp[0].l;\n        r = vp[0].r;\n        x = vp[0].x;\n        if(j+x>400)break;\n        dp[0][j] = abs(l-j);\n\n    }\n    \n    for(int i=1;i<n;i++){\n        rep(j,401){\n            for(int x=-vp[i-1].x;x<=vp[i].x;x++){\n                if(j+x<0)continue;\n                dp[i][j] = min<int>( dp[i-1][j+x]+abs(vp[i].l-j) , dp[i][j] );\n            }\n        }\n    }\n    int ans = INF;\n    rep(j,401)ans = min(dp[n-1][j],ans);\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> l(n), r(n),len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tint ml = l[0], mr = l[0];\n\tll my = 0;\n\trep1(i, n - 1) {\n\t\tif (r[i] < ml) {\n\t\t\tmy += ml - r[i];\n\t\t\tmr = ml;\n\t\t\tml = l[i];\n\t\t}\n\t\telse if (l[i] > mr+len[i-1]) {\n\t\t\tmy += l[i] - mr - len[i - 1];\n\t\t\tml = mr; mr = l[i];\n\t\t}\n\t\telse {\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REPO(i,n) for(int (i)=1; (i)<=(int)(n); (i)++)\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nstruct SL {\n\tpriority_queue<ll> L;\n\tpriority_queue<ll, vector<ll>, greater<ll>> R;\n\tll ans, rBase, lBase;\n\tSL() : ans(0ll), rBase(0ll) {}\n\tvoid addR(int v) {\n\t\trBase += v;\n\t}\n\tvoid addL(int v) {\n\t\tlBase += v;\n\t}\n\tvoid addSL(int x) {\n\t\tL.push(x-lBase); R.push(x-rBase);\n\t\twhile(R.top()+rBase < L.top()+lBase) {\n\t\t\tint l = L.top()+lBase, r = R.top()+rBase;\n\t\t\tans += l-r;\n\t\t\tL.pop(); R.pop();\n\t\t}\n\t}\n};\nint N, Nr[MAX_N][2];\nint main() {\n\tcin >> N;\n\tREP(i, N) REP(j, 2) scanf(\"%d\", &Nr[i][j]);\n\tSL sl;\n\tREP(i, N) {\n\t\tsl.addR(Nr[i][1] - Nr[i][0]);\n\t\tsl.addSL(Nr[i][1]);\n\t\tsl.addL(-(Nr[i][1] - Nr[i][0]));\n\t}\n\tprintf(\"%lld\\n\", sl.ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-6;\nconst double pi = atan2(0, -1);\n\nstruct Queue\n{\n    stack<pair<int, int> > s1, s2;\n    Queue() {}\n    void push(int x)\n    {\n        if (s1.empty())\n            s1.push({x, x});\n        else\n            s1.push({x, min(s1.top().se, x)});\n    }\n    void pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                int x = s1.top().fi;\n                s1.pop();\n                if (s2.empty())\n                    s2.push({x, x});\n                else\n                    s2.push({x, min(s2.top().se, x)});\n            }\n        }\n        s2.pop();\n    }\n    int get_mi()\n    {\n        int res = inf;\n        if (!s1.empty())\n            res = min(res, s1.top().se);\n        if (!s2.empty())\n            res = min(res, s2.top().se);\n        return res;\n    }\n};\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"arrayop.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //int TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n][2];\n    rep(i, 0, n)\n    {\n        cin >> a[i][0] >> a[i][1];\n        a[i][0]--; a[i][1]--;\n    }\n    int dp[n][400];\n    rep(i, 0, n)\n        rep(j, 0, 400)\n            dp[i][j] = inf;\n    rep(j, 0, 400 - (a[0][1] - a[0][0]))\n        dp[0][j] = abs(j - a[0][0]);\n    rep(i, 1, n)\n    {\n        Queue q;\n        rep(j, 0, a[i][1] - a[i][0] + 1)\n            q.push(dp[i - 1][j]);\n        rep(j, 0, 400 - (a[i][1] - a[i][0]))\n        {\n            dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n            if (j - (a[i - 1][1] - a[i - 1][0]) >= 0)\n                q.pop();\n            if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                q.push(dp[i - 1][j + (a[i][1] - a[i][0]) + 1]);\n        }\n    }\n    int ans1 = inf, ans2 = inf;\n    rep(j, 0, 400)\n    {\n        ans1 = min(ans1, dp[0][j]);\n        ans2 = min(ans2, dp[n - 1][j]);\n    }\n    cout << ans1 + ans2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, l[100005], r[100005];\nlong long ans=LONG_LONG_MAX, dp[500][500];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for(int i=1; i<=n; i++) {\n        cin >> l[i] >> r[i];\n    }\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=400; j++)\n            dp[i][j] = 1e16;\n\n    for(int i=1; i<=400; i++) dp[1][i] = abs(l[1]-i);\n    for(int i=2; i<=n; i++) {\n        for(int j=1; j<=400; j++) {\n            for(int k=1; k<=400; k++) {\n                if(k<j-(r[i-1]-l[i-1]) || k>j+l[i]+r[i]) continue;\n                dp[i][j] = min(dp[i][j], dp[i-1][k]+abs(l[i]-j));\n            }\n            //cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n        }\n    }\n    for(int i=1; i<=400; i++) ans = min(ans, dp[n][i]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\n#define inf 1e9+1\nusing namespace std;\n\nconst int maxn = 210000;\n\nint n;\nmultiset<ll>ql,qr;\nll L,R,len,re;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,las=0;i<=n;i++,las=len)\n\t{\n\t\tll l,r; scanf(\"%lld%lld\",&l,&r);\n\t\tlen=r-l;\n\t\tif(i==1)\n\t\t{\n\t\t\tql.insert(-inf); ql.insert(l);\n\t\t\tqr.insert(inf); ql.insert(l);\n\t\t\tcontinue;\n\t\t}\n\t\tL-=len,R+=las;\n\t\tll pl=*ql.rbegin()+L,pr=*qr.begin()+R;\n\t\tif(l<pl)\n\t\t{\n\t\t\tql.insert(l-L); ql.insert(l-L);\n\t\t\tql.erase(*ql.rbegin());\n\t\t\tre+=pl-L-*ql.rbegin();\n\t\t\tqr.insert(pl-R);\n\t\t}\n\t\telse if(l<=pr)\n\t\t\tql.insert(l-L),qr.insert(l-R);\n\t\telse\n\t\t{\n\t\t\tqr.insert(l-R),qr.insert(l-R);\n\t\t\tqr.erase(*qr.begin());\n\t\t\tre+=*qr.begin()+R-pr;\n\t\t\tql.insert(pr-L);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",re);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\n/*\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + offsetL;\n\t\tret2 += (temp - pos);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + offsetR;\n\t\tret2 += (pos - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n*/\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tmultiset<LL>::iterator Left,Right;\n\t\tLeft = LS.end();\n\t\tLeft--;\n\t\tRight = RS.begin();\n\t\t\n\t\tif( L[i] < *Left + ofL ){\n\t\t\t\n\t\t\tLL temp = *Left + ofL;\n\t\t\tret += (temp - L[i]);\n\t\t\t\n\t\t\tRS.insert( temp - ofR );\n\t\t\t\n\t\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\t\tLS.insert( L[i] - ofL );\n\t\t\tLS.insert( L[i] - ofL );\n\t\t\t\n\t\t\t//ret += *LS.rbegin()+ofL-L[i];\n\n\t\t\t//RS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\t//LS.insert(L[i]-ofL);\n\t\t\t//LS.insert(L[i]-ofL);\n\t\t\t//LS.erase(LS.find(*LS.rbegin()));\n\n\t\t}else if( *Right + ofR < L[i] ){\n\t\t\t/*\n\t\t\tLL temp = *Right + ofR;\n\t\t\tret += (L[i] - temp);\n\n\t\t\tRS.erase( Right );\n\t\t\tRS.insert( L[i] - ofR );//元々あった|Right-x|の効果\n\t\t\tRS.insert( L[i] - ofR );//|L-x|の効果\n\t\t\tLS.insert( temp - ofL );\n\t\t\t*/\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}else{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve2();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n;\n    std::cin >> n;\n    vec<i64> x(n), len(n);\n    for (usize i=0; i<n; i++) {\n        std::cin >> x.at(i) >> len.at(i);\n        len.at(i) -= x.at(i);\n    }\n\n    std::priority_queue<i64, vec<i64>, std::less<>> pl;\n    std::priority_queue<i64, vec<i64>, std::greater<>> pr;\n    vec<i64> ml(n), mr(n);\n    i64 gl=0, gr=0;\n    ml.at(0) = x.at(0);\n    mr.at(0) = x.at(0);\n    pl.push(x.at(0));\n    pr.push(x.at(0));\n    for (usize i=1; i<n; i++) {\n        assert(pl.top()-gl <= pr.top()+gr);\n        gl += len.at(i);\n        gr += len.at(i-1);\n        pl.push(x.at(i) + gl);\n        pr.push(x.at(i) - gr);\n        pl.push(pr.top()+gr+gl); pr.pop();\n        pr.push(pl.top()-gr-gl); pl.pop();\n        ml.at(i) = pl.top()-gl;\n        mr.at(i) = pr.top()+gr;\n    }\n\n    vec<i64> pos(n);\n    pos.at(n-1) = ml.at(n-1);\n    for (usize i=n-2; i!=-1; i--) {\n        i64 l = pos.at(i+1) - len.at(i);\n        i64 r = pos.at(i+1) + len.at(i+1);\n        pos.at(i) = r < ml.at(i)\n            ? r\n            : mr.at(i) < l\n            ? l\n            : ml.at(i)\n            ;\n    }\n\n    i64 ans = 0;\n    for (usize i=0; i<n; i++) {\n        ans += std::abs(pos.at(i) - x.at(i));\n    }\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nvoid Main() {\n  ll n;\n  R n;\n  P a[n];\n  PP b[n];\n  rep(i,n) {\n    cin >> b[i].S.F >> b[i].S.S;\n    b[i].F=b[i].S.F-b[i].S.S;\n  }\n  sort(b,b+n);\n  rep(i,n) a[i]=b[i].S;\n  ll ans=MAX;\n  rep(k,n) {\n    REP(t,-400,401) {\n      ll x=a[k].S+t,y=a[k].F+t,sum=abs(t);\n      rep(i,n) {\n        if(i==k) continue;\n        if(x<a[i].F) {\n          sum+=a[i].F-x;\n          x+=a[i].S-a[i].F;\n        } else if(a[i].S<y) {\n          sum+=y-a[i].S;\n          y-=a[i].S-a[i].F;\n        } else if(y<=a[i].F) x=max(x,(ll)a[i].S);\n        else y=min(y,(ll)a[i].F);\n      }\n      ans=min(ans,sum);\n    }\n  }\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5000 + 7;\n\nset< pair< int, int > > le[2], ri[2];\nint l[N], r[N];\nlong long dp[N][N];\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d %d\", l+i, r+i);\n  long long now = 0;\n  int tmp = 0;\n  le[0].insert(make_pair(l[0], tmp++));\n  ri[0].insert(make_pair(l[0], tmp++));\n  int c, b;\n  c = 0, b = 1;\n  for (int i = 1; i < n; i++) {\n    swap(c, b);\n    int bef = r[i-1]-l[i-1], cur = r[i]-l[i];\n    le[c].clear();\n    ri[c].clear();\n    for (auto x : le[b])\n      le[c].insert(make_pair(x.first - cur, tmp++));\n    for (auto x : ri[b])\n      ri[c].insert(make_pair(x.first + bef, tmp++));\n    int midl = (--le[c].end())->first, midr = ri[c].begin()->first;\n    if (l[i] < midl) {\n      le[c].insert(make_pair(l[i], tmp++));\n      le[c].insert(make_pair(l[i], tmp++));\n      auto it = --le[c].end();\n      ri[c].insert(*it);\n      le[c].erase(it);\n      now += midl-l[i];\n    }\n    else if (l[i] > midr) {\n      ri[c].insert(make_pair(l[i], tmp++));\n      ri[c].insert(make_pair(l[i], tmp++));\n      auto it = ri[c].begin();\n      le[c].insert(*it);\n      ri[c].erase(it);\n      now += l[i] - midr;\n    }\n    else {\n      le[c].insert(make_pair(l[i], tmp++));\n      ri[c].insert(make_pair(l[i], tmp++));\n    }\n    // for (auto x : le[c])\n    //   cerr << x.first << \" \";\n    // for (auto x : ri[c])\n    //   cerr << x.first << \"|\";\n    // cerr << now << endl;\n  }\n  cout << now << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int N;\nlong long int l[100000], r[100000];\nlong long int width[100000];\nlong long int ans, box;\nlong long int dp[400][401];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\twidth[i] = r[i] - l[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= 400; j++)dp[i][j] = INT_MAX;\n\t}\n\tfor (int i = 1; i <= 400; i++) {\n\t\tdp[0][i] = abs(l[0] - i);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 1; j <= 400; j++) {\n\t\t\tfor (int k = max((long long int)1, j - width[i - 1]); k <= min((long long int)400, j + width[i]); k++) {\n\t\t\t\tdp[i][j] = min(dp[i - 1][k] + abs(l[i] - j), dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tans = LLONG_MAX;\n\tfor (int i = 1; i <= 400; i++) {\n\t\tans = min(ans, dp[N - 1][i]);\n\t\t//cout << dp[N - 1][i] << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#define For(i, a, b) for (int i = a; i < b; ++i)\n#define Out(i, a, b) for (int i = a - 1; i >= b; --i)\n#define pb push_back\n#define x first\n#define y second\n#define files(FileName) read(FileName); write(FileName)\n#define read(FileName) freopen((FileName + \".in\").c_str(), \"r\", stdin)\n#define write(FileName) freopen((FileName + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \n  \nconst string FileName = \"input\";\n \ntypedef long long base;\n \nconst int MAXN = 2e4;\n \n int n;\nint LR[401][2];\nint dp[401][401];\n\nint main() {\n    ios::sync_with_stdio(0);\n    //read(FileName);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> LR[i][0] >> LR[i][1];\n        --LR[i][0], --LR[i][1];\n    }\n    for (int i = 0; i < 400; ++i) {\n        for (int j = 0; j < 400; ++j) {\n            dp[i][j] = 1e9;\n        }\n    }\n    for (int i = 0; i < 400; ++i) {\n        dp[0][i] = abs(i - LR[0][0]);\n    }\n    for (int i = 1; i < n; ++i) {\n        int Ln = LR[i][0], Rn = LR[i][1];\n        for (int j = 0; j < 400; ++j) {\n            int L = j, R = j - LR[i][0] + LR[i][1];\n            for (int q = 0; q < 400; ++q) {\n                if (max(L, q) <= min(R, q - Ln + Rn)) {\n                    chkmin(dp[i][q], dp[i - 1][j] + abs(q - Ln));\n                }\n            } \n        }\n    }\n    int ans = 1e9;\n    for (int i = 0; i < 399; ++i) {\n        chkmin(ans, dp[n - 1][i]);\n    }\n    cout << ans << endl;\n}  \n \n/*\n2 AB 11\n2!2\n3 ABB 122\n3!3\n4 ABB 2222\n4!3\n5 ABBBB 12222\n5!5\n6 ABBB 121222\n6!4\n7 ABBBB 1212122\n7!5\n8 ABBB 12121212\n8!4\n9 ABBBBBBBB 122222222\n9!9\n10 ABBBBB 1212222222\n10!6\n11 ABBBBBBBB 12121222222\n11!9\n12 ABBBBB 121212122222\n12!6\n13 ABBBBBBBB 1212121212222\n13!9\n14 ABBBBB 12121212121222\n14!6\n15 ABBBBBBBB 121212121212122\n15!9\n16 ABBBBB 1212121212121212\n16!6\n17 ABBBBBBBBBBBBBBBB 12222222222222222\n17!17\n18 ABBBBBBBBB 121222222222222222\n18!10\n19 ABBBBBBBBBBBBBBBB 1212122222222222222\n19!17\n20 ABBBBBBBBB 12121212222222222222\n20!10\n[Finished in 3.1s]\n*/"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint ans[500];\nint a[100000][2];\n\nint main()\n{\n  int i,j,n,min,best;\n  vector<int> d;\n  scanf(\"%d\",&n);\n  for (i=0;i<n;i++)\n    scanf(\"%d%d\",&a[i][0],&a[i][1]);\n  memset(ans,0,sizeof(ans));\n  for (i=0;i<n;i++)\n  {\n    min=2000000000;\n    for (j=a[i][0];j<=a[i][1];j++)\n      if (ans[j]<min) min=ans[j];\n    for (j=a[i][0];j<=a[i][1];j++)\n      ans[j]=min;\n    for (j=a[i][0]-1;j>=0;j--)\n      ans[j]=ans[j]+a[i][0]-j;\n    for (j=a[i][1]+1;j<500;j++)\n      ans[j]=ans[j]+j-a[i][1];\n  }\n  best=2000000000;\n  for (i=0;i<500;i++)\n    if (ans[i]<best) best=ans[i];\n  printf(\"%d\\n\",best);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug==\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<60;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-12;};\ntemplate<> inline long double EPS<long double>(){return 1e-12;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> inline T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> inline T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tvector<pair<int,int>> rs(N); cin >> rs;\n\t\tsort(ALL(rs));\n\n\t\tvector<vector<ll>> dp(N+1,vector<ll>(501,INF<ll>()));\n\t\tfor(int r:range(500)){\n\t\t\tdp[0][r] = abs(rs[0].second - r);\n\t\t}\n\n\t\tfor(int i:range(1,N)){\n\t\t\tfor(int rp:range(500)){\n\t\t\t\tfor(int r:range(500)){\n\t\t\t\t\tif(rp >= r - (rs[i].second - rs[i].first)){\n\t\t\t\t\t\tdp[i][max(r,rp)] =  min(dp[i][max(r,rp)],dp[i-1][rp] + abs(rs[i].second - r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cerr << dp << endl;\n\n\t\tll res = INF<ll>();\n\t\tfor(int r:range(500)) res = min(res,dp[N-1][r]);\n\n\n\t\tcout << res << endl;\n\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[4005][4005];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=1;i<4005;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint l,r;\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tfor(int j=1;j<4005;j++)\n\t\t\t{\n\t\t\t\tif(j<l)\n\t\t\t\tdp[i][j]=l-j+dp[i-1][j];\n\t\t\t\telse if(i>r)\n\t\t\t\tdp[i][j]=j-r+dp[i-1][j];\n\t\t\t\telse \n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<4005;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(r[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    Int x=r[i]-l[i];\n    dL-=x;dR+=x;\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(l[i]<dL+*latte){\n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INT long long\nusing namespace std;\n\nINT n, dt[440][440], l[440], r[440], ans = 987654321;\n\nint main()\n{\n    cin>>n;\n    memset(dt, 0x3f, sizeof(dt));\n    for(int i = 0 ; i < n ; i++ ) cin>>l[i]>>r[i];\n    for(int i = 0 ; i < n ; i++ ) for(int j = 1 ; j <= 400-l[i] ; j++ )\n    {\n        if( i == 0 ) dt[i][j] = abs(j-l[i]);\n        else for(int k = 1 ; k <= 400-l[i-1] ; k++ )\n        {\n            if( j+(r[i]-l[i]) < k or k+(r[i-1]-l[i-1]) < j ) continue;\n            dt[i][j] = min(dt[i][j], dt[i-1][k] + abs(j-l[i]) );\n        }\n    }\n    for(int i = 1 ; i <= 400 ; i++ ) ans = min( ans , dt[n-1][i] );\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\ntemplate <class T, class Func>\nauto ternary_search(T l, T r, Func f)\n\t-> typename std::enable_if<std::is_integral<T>::value, T>::type\n{\n\twhile(l < r){\n\t\tconst T delta = (r - l);\n\t\tconst T cl = l + delta / 3, cr = l + 2 * delta / 3;\n\t\tif(f(cl) <= f(cr)){\n\t\t\tr = cr;\n\t\t}else{\n\t\t\tl = cl + 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<ll> l(n), r(n);\n\tfor(int i = 0; i < n; ++i){ cin >> l[i] >> r[i]; }\n\tvector<pll> b(n);\n\tfor(int i = 0; i < n; ++i){ b[i] = pll(l[i], i); }\n\tsort(b.begin(), b.end());\n\tauto f = [&](ll pos) -> ll {\n\t\tconst int k = lower_bound(b.begin(), b.end(), pll(pos, 0)) - b.begin();\n\t\tpriority_queue<pll> pq;\n\t\tvector<ll> x(n, -1);\n\t\tvector<bool> done(n);\n\t\tfor(int i = k; i < n; ++i){\n\t\t\tconst int j = b[i].second;\n\t\t\tx[j] = pos;\n\t\t\tdone[j] = true;\n\t\t\tpq.emplace(pos, j);\n\t\t}\n\t\twhile(!pq.empty()){\n\t\t\tconst auto top = pq.top();\n\t\t\tpq.pop();\n\t\t\tconst auto c = top.first;\n\t\t\tconst auto j = top.second;\n\t\t\tif(c < x[j]){ continue; }\n\t\t\tdone[j] = true;\n\t\t\tif(j > 0){\n\t\t\t\tconst ll t = max(x[j], r[j - 1]) - (r[j - 1] - l[j - 1]);\n\t\t\t\tif(t > x[j - 1] && !done[j - 1]){\n\t\t\t\t\tx[j - 1] = t;\n\t\t\t\t\tpq.emplace(t, j - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j + 1 < n){\n\t\t\t\tconst ll t = max(x[j], r[j + 1]) - (r[j + 1] - l[j + 1]);\n\t\t\t\tif(t > x[j + 1] && !done[j + 1]){\n\t\t\t\t\tx[j + 1] = t;\n\t\t\t\t\tpq.emplace(t, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll sum = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tsum += llabs(x[i] - l[i]);\n\t\t}\n\t\treturn sum;\n\t};\n\tconst auto s = ternary_search(0ll, 1000000000ll, f);\n\tcout << f(s) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 6;\n\nset< pair< long long, int > > le, ri;\nint l[N], r[N];\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%lld %lld\", l+i, r+i);\n  long long now = 0;\n  int tmp = 0;\n  le.insert(make_pair(l[0], tmp++));\n  ri.insert(make_pair(l[0], tmp++));\n  long long offl = 0, offr = 0;\n  for (int i = 1; i < n; i++) {\n    long long bef = r[i-1]-l[i-1], cur = r[i]-l[i];\n    offl -= cur;\n    offr += bef;\n    long long midl = (--le.end())->first+offl, midr = ri.begin()->first+offr;\n    if (l[i] < midl) {\n      le.insert(make_pair(l[i]-offl, tmp++));\n      le.insert(make_pair(l[i]-offl, tmp++));\n      auto it = --le.end();\n      ri.insert(make_pair(midl-offr, tmp++));\n      le.erase(it);\n      now += midl-l[i];\n    }\n    else if (l[i] > midr) {\n      ri.insert(make_pair(l[i]-offr, tmp++));\n      ri.insert(make_pair(l[i]-offr, tmp++));\n      auto it = ri.begin();\n      le.insert(make_pair(midr-offl, tmp++));\n      ri.erase(it);\n      now += l[i] - midr;\n    }\n    else {\n      le.insert(make_pair(l[i]-offl, tmp++));\n      ri.insert(make_pair(l[i]-offr, tmp++));\n    }\n  }\n  cout << now << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\n#define BD 410\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,L[N],R[N],F[N],G[N],len[N];\nint main()\n{\n\tn=read(); if(n>500) assert(0);\n\tfor(int i=1;i<=n;i++)\n\t\tL[i]=read(), R[i]=read();\n\tfor(int i=1;i<=n;i++) if(L[i]>R[i]) swap(L[i],R[i]);\n\tfor(int i=1;i<=n;i++) len[i]=R[i]-L[i];\n\tfor(int i=1;i<=BD;i++) G[i]=fabs(L[1]-i);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tmemset(F,0x3f,sizeof F);\n\t\tfor(int j=1;j<=BD;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=BD;k++)\n\t\t\t{\n\t\t\t\tif(k>j+len[i-1]||k+len[i]<j) continue;\n\t\t\t\telse F[k]=min(F[k],G[j]+abs(L[i]-k));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=BD;i++) G[i]=F[i];\n\t\t//for(int i=1;i<=BD;i++) printf(\"%d \",F[i]); printf(\"\\n\");\n\t}\n\tint Ans=0x3fffffff; for(int i=1;i<=BD;i++) Ans=min(Ans,G[i]);\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define f(z) for(int i=1;i<=z;i++)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define vi vector<int>\n#define pb push_back\n#define si set<int>\n#define mod  1000000007\n#define cl(n,m) (n-1)/m  + 1 ;\n#define T() int TT; cin>>TT; while(TT--)\n#define P pair<int,int>\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n \nconst int N = 2e6 + 5 ;\nint inf = N*N ;\nint l[N] , r[N] , ans = inf , dp[401][401];\nsigned main(){\n\tint n ;\n\tcin >> n ;\n\tf(n) {\n\t\tcin >> l[i] >> r[i] ; \n\t}\n\tfor ( int i = 0 ; i<=400 ; i++){\n\t\tdp[1][i] = abs( i - l[1] ) ;\n      if( i == n ) ans = min ( ans , dp[1][i] ) ; \n\t}\n\tfor ( int i = 2 ; i<=n ; i++){\n\t\tfor ( int j = 0 ; j<=800 ; j++){\n\t\t\tdp[i][j] = inf ;\n\t\t\tfor ( int k = 0 ; k<=800 ; k++){\n\t\t\t\tint x = max( j , k ) ; \n\t\t\t\tint y = min( j + r[i] - l[i],k +  r[i-1] - l[i-1] ) ;\n\t\t\t\tif( x<=y ) \n\t\t\t\t\tdp[i][j] =  min( dp[i][j] ,abs( l[i] - j) + dp[i-1][k]) ;\n\t\t\t\t\n\t\t\t}\n\t\t\tif( i==n ) \n\t\t\tans = min ( ans , dp[i][j] ) ;\n\t\t}\n\n\t}\n\tcout << ans ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<complex>\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nll n;\nll a[N],b[N],l[N],r[N];\nll sp,tp;\npriority_queue<ll> S,s;\npriority_queue<ll,vector<ll>,greater<ll> >T,t;\nll Sf(){\n  return S.top()+sp;\n}\nll Tf(){\n  return T.top()+tp;\n}\nvoid Sp(ll x){\n  S.push(x-sp);\n}\nvoid Tp(ll x){\n  T.push(x-tp);\n}\nvoid Outs(){\n  s=S,t=T;\n  cout<<\"s=\";\n  while(s.size()>1){\n    cout<<s.top()+sp<<\" \";\n    s.pop();\n  }cout<<endl;\n  cout<<\"t=\";\n  while(t.size()>1){\n    cout<<t.top()+tp<<\" \";\n    t.pop();\n  }cout<<endl;\n  cout<<\"----------\"<<endl;\n}\nint main(){\n    cin>>n;\n    if(n>N)return 0;\n    for(int i=0;i<n;i++)cin>>l[i]>>r[i];\n    for(int i=1;i<n;i++){\n      a[i]=l[i]-r[i-1];\n      b[i]=r[i]-l[i-1];\n      //cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n    }\n    ll ans=0; sp=tp=0;\n    Sp(0); Tp(0);\n    Sp(-1e17); Tp(1e17);\n    for(int i=1;i<n;i++){\n      sp-=b[i],tp-=a[i];\n      //cout<<\"$\"<<endl;\n      //Outs();\n      ll s0=Sf();\n      ll t0=Tf();\n      if(s0<=0&&0<=t0){\n\tSp(0); Tp(0);\n      }\n      if(0<s0){\n\tSp(0); Sp(0);\n\tTp(Sf());\n\tans+=abs(Sf());\n\tS.pop();\n      }\n      if(t0<0){\n\tTp(0); Tp(0);\n\tSp(Tf());\n\tans+=abs(Tf());\n\tT.pop();\n      }\n      //Outs();\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n\nconst int INF = 1e9;\nint dp[444][888];\nint N;\nint L[444], R[444];\n\nint dfs(int n, int lr) {\n\tint& ret = dp[n][lr];\n\tif (ret >= 0) return ret;\n\tif (n == N) return ret = 0;\n\tret = INF;\n\tfor (int i = -400; i <= 400; i++) {\n\t\tint l = L[n]+i, r = R[n]+i;\n\t\tif (r < L[n-1]+lr-400 || l > R[n-1]+lr-400) continue;\n\t\tret = min(ret, abs(i) + dfs(n+1, i+400));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\tif (N > 400) return 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\tN++;\n\tL[0] = -10000, R[0] = 100000;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << dfs(1, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <random>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nmt19937 rnd(123);\nconst ll INF = 2e9 + 1000;\n\nstruct node {\n\tnode *l, *r;\n\tll x, d, sum;\n\tll dx;\n\tint y;\n\tnode() {\n\t\tl = r = 0;\n\t\tx = d = sum = dx = 0;\n\t\ty = rnd();\n\t}\n};\n\nvoid push(node *v) {\n\tif (!v || !v->dx)\n\t\treturn;\n\tif (v->l) {\n\t\tv->l->dx += v->dx;\n\t\tv->l->x += v->dx;\n\t}\n\tif (v->r) {\n\t\tv->r->dx += v->dx;\n\t\tv->r->x += v->dx;\n\t}\n\tv->dx = 0;\n}\n\nvoid upd(node *v) {\n\tif (!v)\n\t\treturn;\n\tv->sum = v->d;\n\tif (v->l)\n\t\tv->sum += v->l->sum;\n\tif (v->r)\n\t\tv->sum += v->r->sum;\n}\n\nnode *merge(node *l, node *r) {\n\tif (!l)\n\t\treturn r;\n\tif (!r)\n\t\treturn l;\n\tif (l->y > r->y) {\n\t\tpush(l);\n\t\tl->r = merge(l->r, r);\n\t\tupd(l);\n\t\treturn l;\n\t}\n\telse {\n\t\tpush(r);\n\t\tr->l = merge(l, r->l);\n\t\tupd(r);\n\t\treturn r;\n\t}\n}\n\nvoid split(node *v, ll x, node *&l, node *&r) {\n\tif (!v) {\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\tif (v->x >= x) {\n\t\tpush(v);\n\t\tsplit(v->l, x, l, v->l);\n\t\tupd(v);\n\t\tr = v;\n\t}\n\telse {\n\t\tpush(v);\n\t\tsplit(v->r, x, v->r, r);\n\t\tupd(v);\n\t\tl = v;\n\t}\n}\n\nll find(node *v, ll now) {\n\tpush(v);\n\tif (v->l && v->l->sum + now > 0)\n\t\treturn find(v->l, now);\n\tif (v->l)\n\t\tnow += v->l->sum;\n\tif (now + v->d > 0)\n\t\treturn v->x;\n\telse\n\t\tnow += v->d;\n\treturn find(v->r, now);\n}\nll gpnt = 0;\nll gtmp = 0;\n\nnode *root;\n\nvoid add(ll x) {\n\tgtmp += abs(x - gpnt);\n\tnode *tmp = root;\n\twhile (tmp->l)\n\t\ttmp->sum -= 1, tmp = tmp->l;\n\ttmp->sum -= 1;\n\ttmp->d -= 1;\n\tnode *l, *r, *m;\n\tsplit(root, x, l, r);\n\tsplit(r, x + 1, m, r);\n\tif (m) {\n\t\tm->d += 2;\n\t\tm->sum += 2;\n\t}\n\telse {\n\t\tm = new node();\n\t\tm->x = x;\n\t\tm->d = 2;\n\t\tm->sum = 2;\n\t}\n\troot = merge(l, merge(m, r));\n}\n\nvoid diva(ll l1, ll l2) {\n\tgpnt -= l1;\n\tll x = find(root, 0);\n\tnode *l, *r;\n\tnode *tmp;\n\tsplit(root, x, l, r);\n\tif (l)\n\t\tl->dx -= l1, l->x -= l1;\n\tif (r)\n\t\tr->dx += l2, r->x += l2;\n\tif ((l ? l->sum : 0) != 0) {\n\t\tll k = (l ? l->sum : 0);\n\t\ttmp = new node();\n\t\ttmp->x = x - l1;\n\t\ttmp->d = tmp->sum = -k;\n\t\tl = merge(l, tmp);\n\t\ttmp = r;\n\t\twhile (tmp->l) {\n\t\t\ttmp->sum += k;\n\t\t\ttmp = tmp->l;\n\t\t}\n\t\ttmp->sum += k;\n\t\ttmp->d += k;\n\t}\n\troot = merge(l, r);\n}\n\nll gans = 0;\n\nvoid dfs1(node *v, ll x) {\n\tpush(v);\n\tif (v->x < x)\n\t\tgans += v->d * (x - v->x);\n\tif (v->l)\n\t\tdfs1(v->l, x);\n\tif (v->r)\n\t\tdfs1(v->r, x);\n}\n\nll getans() {\n\tll x = find(root, 0);\n\tdfs1(root, x);\n\treturn gans;\n}\n\nint n;\nll l[120000];\nll r[120000];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%lld%lld\", l + i, r + i);\n\troot = new node();\n\tadd(l[0]);\n\tfor (int i = 1; i < n; ++i) {\n\t\tll len1 = r[i - 1] - l[i - 1];\n\t\tll len2 = r[i] - l[i];\n\t\tdiva(len2, len1);\n\t\tadd(l[i]);\n\t}\n\tcout << gtmp + getans() << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 1e5 + 10;\nconst LL inf = 1e14;\nint l[N], r[N];\nmultiset<int> s0, s1; int d0, d1;\nint main() {\n\tint n; scanf(\"%d\",&n);\n\tint l1 = 0;\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tint l2 = r[i] - l[i]; \n\t\tif (i > 1) d0 -= l2, d1 += l1;\n\t\tl1 = l2;\n\t\tint L, R;\n\t\tif (i > 1) {\n\t\t\tsit it = s0.end(); it--;\n\t\t\tL = *it + d0;\n\t\t\tit = s1.begin();\n\t\t\tR = *it + d1;\n\t\t} else L = 0, R = 0;\n\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\ts0.insert(l[i] - d0), s1.insert(l[i] - d1);\n\t\t} else if (l[i] < L) {\n\t\t\ts0.insert(l[i] - d0), s0.insert(l[i] - d0);\n\t\t\tsit it = s0.end(); it--;\n\t\t\ts1.insert(*it + d0 - d1); s0.erase(it);\n\t\t} else if (l[i] > R) {\n\t\t\ts1.insert(l[i] - d1), s1.insert(l[i] - d1);\n\t\t\tsit it = s1.begin(); \n\t\t\ts0.insert(*it + d1 - d0); s1.erase(it);\n\t\t}\n\t}\n\tLL cur = 0, t = -inf;\n\tdep(i,n,1) cur += l[i] - t, t += r[i] - l[i];\n\tint d = -n; LL tmp = -inf;\n\tfor(sit it = s0.begin(); it != s0.end(); it++)\n\t\tcur += 1LL * d * (*it + d0 - tmp), tmp = *it + d0, d++;\n\tcout <<cur<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace Task {\n\nconst int MAXN = 100000;\n#define long long long\n\nstd::multiset<long> setL, setR;\nint a[MAXN + 1], b[MAXN + 1];\nlong f[MAXN + 1];\n\ninline void solve() {\n    std::ios::sync_with_stdio(false), std::cin.tie(NULL), std::cout.tie(NULL);\n    register int n;\n    std::cin >> n;\n    for (register int i = 1; i <= n; i++) std::cin >> a[i] >> b[i];\n    setL.insert(a[1]), setR.insert(a[1]);\n    register long tl = 0, tr = 0, ans = 0, nl, nr;\n    for (register int i = 2; i <= n; i++) {\n        tl += b[i] - a[i], tr += b[i - 1] - a[i - 1];\n        nl = *setL.rbegin(), nr = *setR.begin();\n        if (nl - tl > a[i]) {\n            ans += std::abs(nl - tl - a[i]), setL.erase(--setL.end());\n            setL.insert(setL.insert(a[i] + tl), a[i] + tl);\n            setR.insert(nl - tl - tr);\n        } else if (a[i] > nr + tr) {\n            ans += std::abs(nr + tr - a[i]), setR.erase(setR.begin());\n            setR.insert(setR.insert(a[i] - tr), a[i] - tr);\n            setL.insert(nr + tr + tl);\n        } else {\n            setL.insert(a[i] + tl), setR.insert(a[i] - tr);\n        }\n    }\n    std::cout << ans;\n}\n\n#undef long\n}\n\nint main() {\n    Task::solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t% D a l a o\n          --InterestingLSY\n*/\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF (1e18)\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\nusing namespace std;\n#define MAXN 500\n\nint n;\nint l[MAXN],r[MAXN];\nint len[MAXN];\n\n//int mem[MAXN][MAXN];\nint dp(int pos,int lastl){\n\tif(pos == n+1) return 0;\n\t//if(mem[pos][lastl] != -1) return mem[pos][lastl];\n\tint ans = INF;\n\tfor(int nowl = lastl-len[pos];nowl <= lastl+len[pos-1];nowl++)\n\t\tans = min(  ans  ,  dp(pos+1,nowl) + abs(l[pos]-nowl)  );\n\t//mem[pos][lastl] = ans;\n\treturn ans;\n}\n\nint main(){\n\t//freopen(\"E.txt\",\"r\",stdin);\n\t//msn(mem,-1);\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t}\n\t\n\tint ans = INF;\n\tfor(int i = 0;i <= MAXN;i++)\n\t\tans = min(  ans  ,  dp(2,i) + abs(i-l[1])  );\n\t\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<functional>\n#include<unordered_map>\n#include<unordered_set>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint x[400], y[400];\nsigned main() {\n\tint a; scanf(\"%d\", &a);\n\tif (a > 400)return 0;\n\tfor (int b = 0; b < a; b++) {\n\t\tscanf(\"%d%d\", &x[b], &y[b]);\n\t\tif (y[b] > 400)return 0;\n\t\tx[b]--; y[b]--;\n\t}\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < 405; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\tif (y[j] < i)sum += i - y[j];\n\t\t\telse if (x[j] > i)sum += x[j]-i;\n\t\t}\n\t\tMIN = min(MIN, sum);\n\t}\n\tprintf(\"%d\\n\", MIN);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nint dp[410][410];\nvoid push(queue<PII>& q, int i, int x){\n  while(!q.empty() && q.front().SS >= x)\n\tq.pop();\n  q.push(MP(i,x));\n}\nvoid pop(queue<PII>& q, int b){\n  while(!q.empty() && q.front().FF <= b)\n\tq.pop();\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\nif(N>400)return 1;\n  vector<PII> xs(N);\n  VI ws(N);\n  REP(i,N){\n\tcin >> xs[i];\n\tws[i] = xs[i].SS - xs[i].FF;\n  }\n\n  fill((int*)dp, (int*)dp+410*410, INF);\n  REP(x,401)\n\tdp[0][x] = abs(x - xs[0].FF);\n\n  FOR(i,1,N){\n\tqueue<PII> q;\n\tfor(int x=0;x<=ws[i]&&x<410;++x)\n\t  push(q, i, dp[i-1][x]);\n\n\tfor(int x=0;x<410;++x){\n\t  if(x+ws[i] < 410)\n\t\tpush(q, x+ws[i], dp[i-1][x+ws[i]]);\n\t  dp[i][x] = abs(x - xs[i].FF) + q.front().SS;\n\t  pop(q, x-ws[i-1]);\n\t}\n  }\n\n  cout << *min_element(ALL(dp[N-1])) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Bismillahir Rahmanir Rahim */\n\n#include <bits/stdc++.h>\n\n#define rep(i, n)\tfor(int i=0;i<int(n);i++)\n#define repn(i, n)\tfor(int i=1;i<=int(n);i++)\n#define set(i, n)\tmemset(i, n, sizeof(i))\n\n#define pb\tpush_back\n#define f\tfirst\n#define s\tsecond\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 808;\nconst int oo = 1e9;\n\nint n, l[N], r[N];\nint dp[N][N];\n\nbool OK(int a, int b, int c, int d){\n\tif(d < a || b < c) return false;\n\treturn true;\n}\n\nint recur(int at, int mv){\n\tif(at == n + 1) return 0;\n\tif(dp[at][mv+400] != -1) return dp[at][mv+400];\n\tint ret = oo;\n\tif(at == 1){\n\t\tint a = l[at], b = r[at];\n\t\tfor(int i=0;i<=400;i++){\n\t\t\tret = min(ret, i + recur(at+1, i));\n\t\t\tret = min(ret, i + recur(at+1,-i));\n\t\t}\n\t}\n\telse{\n\t\tint p1 = l[at-1] + mv, p2 = r[at-1] + mv;\n\t\tint q1, q2;\n\t\tfor(int i=0;i<=400;i++){\n\t\t\tq1 = l[at] + i, q2 = r[at] + i;\n\t\t\tif(OK(p1, p2, q1, q2)) ret = min(ret, i + recur(at+1, i));\n\t\t\tq1 = l[at] - i, q2 = r[at] - i;\n\t\t\tif(OK(p1, p2, q1, q2)) ret = min(ret, i + recur(at+1,-i));\n\t\t}\n\t}\n\treturn dp[at][mv+400] = ret;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\trepn(i, n) scanf(\"%d %d\", &l[i], &r[i]);\n\tset(dp, -1);\n\tint ret = recur(1, 0);\n\tcout << ret << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <time.h>\n#include <complex>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\nusing std::complex;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\ntypedef complex<double> cd;\n\nll min(ll a, ll b)\n{\n    if (a < b)\n        return a;\n    return b;\n}\n\nll max(ll a, ll b)\n{\n    if (a > b)\n        return a;\n    return b;\n}\n\nnamespace MySpace{\n    struct Small_Segment_Tree{\n        vector<int> a;\n        int l, r;\n\n        private:\n        int __summ(int L, int R, int l, int r, int v)\n        {\n            if (L <= l && r <= R)\n                return a[v];\n            if (R <= l || r <= L)\n                return 0;\n            int m = (l + r) / 2;\n            return __summ(L, R, l, m, 2 * v + 1) + __summ(L, R, m, r, 2 * v + 2);\n        }\n\n        void __set(int P, int l, int r, int v, int V)\n        {\n            if (l + 1 == r)\n            {\n                a[v] = V;\n                return;\n            }\n            int m = (l + r) / 2;\n            if (P < m)\n            {\n                __set(P, l, m, 2 * v + 1, V);\n                a[v] = a[2 * v + 1] + a[2 * v + 2];\n            }\n            else\n            {\n                __set(P, m, r, 2 * v + 2, V);\n                a[v] = a[2 * v + 1] + a[2 * v + 2];\n            }\n        }\n\n        public:\n        int Summ(int L, int R)\n        {\n            if (R < L)\n                return 0;\n            return __summ(L, R + 1, l, r, 0);\n        }\n\n        void Set(int P, int V)\n        {\n            __set(P, l, r, 0, V);\n        }\n\n        Small_Segment_Tree(int _n)\n        {\n            a.resize(4 * _n);\n            l = 0, r = _n;\n        }\n    };\n    long long inq(long long x, long long q, long long MOD)\n    {\n        if (q == 0)\n            return 1;\n        long long l = inq(x, q / 2, MOD);\n        if (q % 2)\n            return l * l % MOD * x % MOD;\n        return l * l % MOD;\n    }\n};\n\n\nusing namespace MySpace;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst ll MOD = 998244353;\n\nll n;\nvector<ll> bounds;\nvector<pair<ll, ll> > l_sort, r_sort;\n\nbool comp1(pll a, pll b)\n{\n    pll c = {a.se, a.fi};\n    pll d = {b.se, b.fi};\n    return c < d;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio();\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    ll rights = 0, lefts = 0;\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        lefts += l;\n        bounds.push_back(l);\n        bounds.push_back(r);\n        l_sort.push_back({l, r});\n        r_sort.push_back({l, r});\n    }\n    sort(all(bounds));\n    sort(all(l_sort));\n    sort(all(r_sort), comp1);\n    ll ans = 1e18;\n    int j = 0, jj = 0;\n    ll cnt1 = 0, cnt2 = n;\n    for (int i = 0; i < 2 * n; i++)\n    {\n        int G = bounds[i];\n        while (j < n && r_sort[j].second <= G)\n        {\n            rights += r_sort[j].second;\n            j++;\n            cnt1++;\n        }\n        while (jj < n && l_sort[jj].first < G)\n        {\n            lefts -= l_sort[jj].first;\n            jj++;\n            cnt2--;\n        }\n        //cout << G << \" : \" << cnt1 << \" \" << cnt2 << endl;\n        ll res = cnt1 * G - rights + lefts - cnt2 * G;\n        //cout << res << endl;\n        ans = min(ans, res);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ninline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}\nusing namespace std;\n#define lowbit(x) ((x)&(-x))\nconst int maxn = 400 + 50;\nint n , dp[maxn][maxn] , l[maxn] , r[maxn];\n\nint main( int argc , char * argv[] ){\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tl[i] = read() , r[i] = read();\n\tfor(int j = 1 ; j <= 400 ; ++ j)\n\t\tdp[1][j] = abs( j - l[1] );\n\tfor(int i = 2 ; i <= n ; ++ i)\n\t\tfor(int j = 1 ; j <= 400 ; ++ j){\n\t\t\tint mi = 1e9 + 7;\n\t\t\tfor(int k = max( 1 , j - (r[i - 1] - l[i - 1]) ) ; k <= min( 400 , j + r[i] - l[i] ) ; ++ k)\n\t\t\t\tmi = min( mi , dp[i - 1][k] );\n\t\t\tmi += abs( j - l[i] );\n\t\t\tdp[i][j] = mi;\n\t\t}\n\tint mi = 1e9 + 7;\n\tfor(int i = 1 ; i <= 400 ; ++ i) \n\t\tmi = min( mi , dp[n][i] );\n\tprintf( \"%d\\n\" , mi );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> l(n),r(n);\n  for(Int i=0;i<n;i++) cin>>l[i]>>r[i];\n\n  multiset<Int> L,R;\n  L.emplace(l[0]);\n  R.emplace(l[0]);\n\n  Int dL=0,dR=0,dH=0;\n\n  for(Int i=1;i<n;i++){\n    dL-=r[i]-l[i];\n    dR+=r[i-1]-l[i-1];\n    auto latte=--L.end();\n    auto malta=R.begin();\n\n    if(l[i]<dL+*latte){\n      dH+=-(l[i]-(dL+*latte));\n      R.emplace(dL+*latte-dR);\n      L.erase(latte);\n      L.emplace(l[i]-dL);\n      L.emplace(l[i]-dL);\n    }else if(dR+*malta<l[i]){\n      dH+=(l[i]-(dR+*malta));\n      L.emplace(dR+*malta-dL);\n      R.erase(malta);\n      R.emplace(l[i]-dR);\n      R.emplace(l[i]-dR);\n    }else{\n      L.emplace(l[i]-dL);\n      R.emplace(l[i]-dR);\n    }\n    if(0){\n      cout<<i<<\":\"<<dH<<endl;\n      cout<<\"L:\";\n      for(Int a:L) cout<<a+dL<<\" \";\n      cout<<endl; \n      cout<<\"R:\";\n      for(Int a:R) cout<<a+dR<<\" \";\n      cout<<endl;\n    }\n  }\n\n  cout<<dH<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <set>\nusing namespace std;\nconst long long INF = 1LL<<60;\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T> ostream& operator << (ostream &s, multiset<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\n\n\n\nint N;\nvector<long long> L, R;\nlong long solve() {\n    multiset<long long> left, right;\n    left.insert(-INF), left.insert(L[0]), right.insert(L[0]), right.insert(INF);\n    long long lx = 0, rx = 0, h = 0;\n    long long prev = R[0] - L[0];\n    for (int i = 1; i < N; ++i) {\n        long long cur = R[i] - L[i];\n        lx -= cur, rx += prev;\n        auto lit = left.end(); --lit;\n        long long l = *lit + lx;\n        long long r = *(right.begin()) + rx;\n        if (l <= L[i] && L[i] <= r) {\n            left.insert(L[i] - lx), right.insert(L[i] - rx);\n        }\n        else if (L[i] > r) {\n            auto rit2 = right.begin(); ++rit2;\n            long long r2 = min(L[i], *rit2 + rx);\n            right.erase(--rit2);\n            left.insert(r - lx), right.insert(r2 - rx), right.insert(r2 - rx);\n            h += abs(L[i] - r);\n        }\n        else {\n            auto lit2 = left.end(); --lit2; --lit2;\n            long long l2 = max(L[i], *lit2 + lx);\n            left.erase(++lit2);\n            left.insert(l2 - lx), left.insert(l2 - lx), right.insert(l - rx);\n            h += abs(L[i] - l);\n        }\n\n        /*\n        COUT(\"=================\");\n        COUT(i);\n        for (auto it : left) cout << it + lx << \", \";\n        cout << endl;\n        for (auto it : right) cout << it + rx << \", \";\n        cout << endl;\n        COUT(lx);\n        COUT(rx);\n        COUT(h);\n        */\n\n        prev = cur;\n    }\n    return h;\n}\n\nint main() {\n    while (cin >> N) {\n        L.resize(N); R.resize(N);\n        for (int i = 0; i < N; ++i) cin >> L[i] >> R[i];\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int MAXN = 250005;\n\nint n, x[MAXN], y[MAXN];\n\nstruct pque{\n\tbool neg;\n\tlint offset = 0;\n\tpriority_queue<lint> pq;\n\tvoid push(lint x){\n\t\tif(neg) x = -x;\n\t\tpq.push(x - offset);\n\t}\n\tlint top(){\n\t\tlint x = pq.top() + offset;\n\t\tif(neg) x = -x;\n\t\treturn x;\n\t}\n\tvoid pop(){\n\t\tpq.pop();\n\t}\n\tvoid add_offset(lint x){\n\t\tif(neg) x = -x;\n\t\toffset += x;\n\t}\n}pql, pqr;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tlint ans = 0;\n\tpqr.neg = 1;\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\ty[i] -= x[i];\n\t\tif(i > 0){\n\t\t\tpql.add_offset(-y[i]);\n\t\t\tpqr.add_offset(y[i - 1]);\n\t\t\tif(pqr.top() < x[i]){\n\t\t\t\tans += x[i] - pqr.top();\n\t\t\t\tpqr.push(x[i]);\n\t\t\t\tpqr.push(x[i]);\n\t\t\t\tpql.push(pqr.top());\n\t\t\t\tpqr.pop();\n\t\t\t}\n\t\t\telse if(pql.top() > x[i]){\n\t\t\t\tans += pql.top() - x[i];\n\t\t\t\tpql.push(x[i]);\n\t\t\t\tpql.push(x[i]);\n\t\t\t\tpqr.push(pql.top());\n\t\t\t\tpql.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpql.push(x[i]);\n\t\t\t\tpqr.push(x[i]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpql.push(x[i]);\n\t\t\tpqr.push(x[i]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void setmin(T& a, T b) { if (b < a) a = b; }\n\nconst int MAXN = 410;\nconst int X = 400;\n\nconst int INF = 1e9;\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tint N; cin >> N;\n\tassert(N < MAXN);\n\tvector<int> L(N);\n\tvector<int> R(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t\tassert(R[i] <= X);\n\t}\n\n\tvector<int> dp(X+1);\n\tfor (int x = 0; x <= X; x++) {\n\t\tdp[x] = abs(x - L[0]);\n\t}\n\tfor (int i = 0; i+1 < N; i++) {\n\t\tvector<int> ndp(X+1, INF);\n\t\tfor (int x = 0; x <= X; x++) {\n\t\t\tfor (int nx = max(0, x + L[i+1] - R[i+1]); nx <= min(X, x + R[i] - L[i]); nx++) {\n\t\t\t\tassert(max(x, nx) <= min(x + R[i] - L[i], nx + R[i+1] - L[i+1]));\n\t\t\t\tsetmin(ndp[nx], dp[x]);\n\t\t\t}\n\t\t}\n\t\tswap(dp, ndp);\n\t\tfor (int x = 0; x <= X; x++) {\n\t\t\tdp[x] += abs(x - L[i+1]);\n\t\t}\n\t}\n\n\tcout << *min_element(dp.begin(), dp.end()) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 200010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nmultiset<ll> L, R;\nint A[MAX_N], B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i] >> B[i];\n\tll a = A[0], b = A[0];\n\tL.insert(A[0]); R.insert(A[0]);\n\tll ans = 0;\n\trep(i, 1, N) {\n\t\ta -= B[i] - A[i];\n\t\tb += B[i - 1] - A[i - 1];\n\t\t//debug(a, b);\n\t\tll l = *L.rbegin(), r = *R.begin();\n\t\tif(a <= A[i] && A[i] <= b) {\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\ta = A[i]; b = A[i];\n\t\t}\n\t\telse if(A[i] < a) {\n\t\t\tans += abs(A[i] - a);\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tll le = *L.rbegin() + (a - l);\n\t\t\tL.erase(--L.end());\n\t\t\tR.insert(le - (b - r));\n\t\t\ta = *L.rbegin() + (a - l);\n\t\t\tb = le;\n\t\t}\n\t\telse {\n\t\t\tans += abs(A[i] - b);\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\tll rb = *R.begin() + (b - r);\n\t\t\tR.erase(R.begin());\n\t\t\tL.insert(rb - (a - l));\n\t\t\ta = rb;\n\t\t\tb = *R.begin() + (b - r);\n\t\t}\n\t\t//debug(a, vi(all(L)));\n\t\t//debug(b, vi(all(R)));\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define pb push_back\n#define mp make_pair\n\nint n;\npii mas[123456];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> mas[i].first >> mas[i].second;\n    }\n    int ans = 0, mn = 1000000000;\n    int l, r;\n    for(int i = 1; i <= 400; i++){\n        l = i, r = l + (mas[0].second - mas[0].first);\n        ans = abs(i - mas[0].first);\n        for(int j = 1; j < n; j++){\n            int l1 = mas[j].first, r1 = mas[j].second;\n            if(l1 > r){\n                ans += (l1 - r);\n                l = r, r = l + (mas[j].second - mas[j].first);\n            }\n            else if(r1 < l){\n                ans += (l - r1);\n                r = l, l = r - (mas[j].second - mas[j].first);\n            }\n        }\n        mn = min(ans, mn);\n    }\n    cout << mn << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void setmin(T& a, T b) { if (b < a) a = b; }\n\nconst int MAXN = 410;\nconst int X = 10;\n\nconst int INF = 1e9;\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tint N; cin >> N;\n\tvector<int> L(N);\n\tvector<int> R(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\n\tvector<int> dp(X+1);\n\tfor (int x = 0; x <= X; x++) {\n\t\tdp[x] = abs(x - L[0]);\n\t}\n\tfor (int i = 0; i+1 < N; i++) {\n\t\tvector<int> ndp(X+1, INF);\n\t\tfor (int x = 0; x <= X; x++) {\n\t\t\tfor (int nx = max(0, x + L[i+1] - R[i+1]); nx <= min(X, x + R[i] - L[i]); nx++) {\n\t\t\t\tassert(max(x, nx) <= min(x + R[i] - L[i], nx + R[i+1] - L[i+1]));\n\t\t\t\tsetmin(ndp[nx], dp[x]);\n\t\t\t}\n\t\t}\n\t\tswap(dp, ndp);\n\t\tfor (int x = 0; x <= X; x++) {\n\t\t\tdp[x] += abs(x - L[i+1]);\n\t\t}\n\t}\n\n\tcout << *min_element(dp.begin(), dp.end()) << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint ans[500];\nint d1[500][10];\nint d2[500][10];\nint a[100000][2];\nmap<int,int> mp;\n\nint main()\n{\n  int i,j,n,best,now,ll,k,kk,jj,tmp;\n  vector<int> d;\n  scanf(\"%d\",&n);\n  //if (n>400) return 0;\n  for (i=0;i<n;i++)\n  {\n    scanf(\"%d%d\",&a[i][0],&a[i][1]);\n    //if (a[i][0]>400) return 0;\n    //if (a[i][1]>400) return 0;\n  }\n  memset(ans,0,sizeof(ans));\n  now=0;\n  for (i=0;i<n;i++)\n  {\n    for (j=0;j<500;j++)\n    {\n      d1[j][0]=ans[j];\n      d2[j][0]=ans[j];\n    }\n    for (k=0;k+1<10;k++)\n      for (j=0;j<500;j++)\n      {\n        d1[j][k+1]=d1[j][k];\n        if ((j+(1<<k))<500)\n          if (d1[j+(1<<k)][k]<d1[j][k+1])\n            d1[j][k+1]=d1[j+(1<<k)][k];\n        d2[j][k+1]=d2[j][k];\n        if ((j-(1<<k))>=0)\n          if (d2[j-(1<<k)][k]<d2[j][k+1])\n            d2[j][k+1]=d2[j-(1<<k)][k];\n      }\n    ll=a[i][1]-a[i][0]+1;\n    kk=0;\n    while ((1<<kk)<=ll) kk++;\n    kk--;\n    for (j=0;j<500;j++)\n    {\n      ans[j]=2000000000;\n      for (jj=j-ll+1;jj<=j;jj++)\n      {\n        if ((jj<0)||(jj+ll-1>=500)) continue;\n        tmp=d1[jj][kk];\n        if (d2[jj+ll-1][kk]<tmp) tmp=d2[jj+ll-1][kk];\n        tmp+=abs(jj-a[i][0]);\n        if (tmp<ans[j]) ans[j]=tmp;\n      }\n    }\n  }\n  best=2000000000;\n  for (i=0;i<500;i++)\n    if (ans[i]<best) best=ans[i];\n  printf(\"%d\\n\",best);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <set>\n#include <utility>\ntypedef long long ll;\n\nconst int maxn = 100010;\n\nstd::multiset<ll> inc,dec;\nstd::multiset<ll>::iterator iter;\nll l[maxn], r[maxn], len[maxn];\n\nint main()\n{\n\t//freopen(\"E.in\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\tll offset_dec = 0, offset_inc  = 0, ans = 0;\n\tscanf(\"%lld%lld\",&l[1], &r[1]);\n\tdec.insert(r[1]); inc.insert(r[1]); len[1] = r[1] - l[1];\n\t\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\t\n\t\t//parallel move to both sides\n\t\toffset_dec -= len[i-1];\n\t\toffset_inc += len[i];\n\t\t\n\t\t// + |x-Ri|\n\t\tif (r[i] >= *inc.begin() + offset_inc)\n\t\t{\n\t\t\tans += r[i] - (*inc.begin() + offset_inc);\n\t\t\tdec.insert(*inc.begin() + offset_inc - offset_dec);\n\t\t\tinc.erase(inc.begin());\n\t\t\tinc.insert(r[i] - offset_inc);\n\t\t\tinc.insert(r[i] - offset_inc);\n\t\t}\n\t\telse if (r[i] <= *(dec.rbegin()) + offset_dec)\n\t\t{\n\t\t\tans += (*dec.rbegin() + offset_dec) - r[i];\n\t\t\tinc.insert(*dec.rbegin() + offset_dec - offset_inc);\n\t\t\titer = dec.end();\n\t\t\titer--;\n\t\t\tdec.erase(iter);\n\t\t\tdec.insert(r[i] - offset_dec);\n\t\t\tdec.insert(r[i] - offset_dec);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdec.insert(r[i] - offset_dec);\n\t\t\tinc.insert(r[i] - offset_inc);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<P> A(n);\n  cin>>A;\n \n  multiset<int> Neg, Pos;\n  Neg.insert(A[0].first);\n  Pos.insert(A[0].first);\n  int dL = 0, dR = 0, ans = 0;\n  \n  for(int i=1;i<n;i++){\n    int l0, r0; tie(l0, r0) = A[i-1];\n    int l1, r1; tie(l1, r1) = A[i];\n    int L = *(--Neg.end());\n    int R = *Pos.begin();\n    dR += r0 - l0;\n    dL += r1 - l1;\n    \n    if(l1 + dL < L){ //接してなくて左側にある。\n      ans += abs(l1 + dL - L);\n\n      Neg.erase(Neg.find(L));   //古いLを消す\n      Pos.insert(-(dL+dR) + L); //今入っているRよりも左側に行かないといけないので\n      \n      Neg.insert(l1 + dL);\n      Neg.insert(l1 + dL);\n        \n    }\n    else if(R + dR < l1){\n      ans += abs(R + dR - l1);\n      \n      Pos.erase(Pos.find(R)); //古いRを消す\n      Neg.insert(R + (dR + dL));      \n\n      \n      Pos.insert(l1-dR);\n      Pos.insert(l1-dR);\n    }\n    else { //接している。移動する場合の変曲点のみを追加する。\n      Neg.insert(l1 + dL);\n      Pos.insert(l1 - dR);\n    }\n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmultiset<long long, greater<long long>> s1;\nmultiset<long long> s2;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tlong long ans = 0;\n\tint L, R;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tint l, r; cin >> l >> r;\n\t\tif(!i) {\n\t\t\tL = l; R = r;\n\t\t\ts1.insert(l);\n\t\t\ts2.insert(r);\n\t\t} else {\n\t\t\tif(l <= R) {\n\t\t\t\ts1.insert(l);\t\n\t\t\t} else {\n\t\t\t\tans += l - R;\n\t\t\t\ts2.erase(s2.begin());\n\t\t\t\ts2.insert(r);\n\t\t\t\ts1.insert(R);\n\t\t\t}\n\t\t\tif(r >= L) {\n\t\t\t\ts2.insert(r);\n\t\t\t} else {\n\t\t\t\tans += L - r;\n\t\t\t\ts1.erase(s1.begin());\n\t\t\t\ts1.insert(l);\n\t\t\t\ts2.insert(L);\n\t\t\t}\n\t\t}\n\t\tL = *s1.begin();\n\t\tR = *s2.begin();\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n/*\n3\n5 6\n3 4\n1 2\n*/\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e5 + 10;\nll l[maxN], r[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> l[i] >> r[i];\n    }\n    if (n == 1) {\n        cout << 0;\n        return 0;\n    }\n    priority_queue < ll > S1;\n    priority_queue < ll, vector < ll >, greater<>>S2;\n    S1.push(r[1]);\n    S2.push(r[1]);\n    ll shift1 = 0;\n    ll shift2 = 0;\n    ll ans = 0;\n    for (int i = 2; i <= n; i++) {\n        ll len1 = r[i] - l[i];\n        ll len2 = r[i - 1] - l[i - 1];\n        shift1 -= len2;\n        shift2 += len1;\n        ll stL = S1.top() + shift1;\n        ll stR = S2.top() + shift2;\n        if (r[i] >= stR) {\n            S2.pop();\n            S2.push(r[i] - shift2);\n            S2.push(r[i] - shift2);\n            S1.push(stR - shift1);\n            ans += r[i] - stR;\n        }\n        else if (r[i] <= stL) {\n            S1.pop();\n            S1.push(r[i] - shift1);\n            S1.push(r[i] - shift1);\n            S2.push(stL - shift2);\n            ans += stL - r[i];\n        }\n        else {\n            S1.push(r[i] - shift1);\n            S2.push(r[i] - shift2);\n        }\n        // should take min(x - len1,\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define Min(a,b,c) min((a),min((b),(c)))\n#define mp(a,b) make_pair((a),(b))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pb(x) push_back(x)\n#define x first\n#define y second\n#define sqr(x) ((x)*(x))\n#define EPS 1e-11\n#define N 200005\n#define M\n#define pi 3.14159265359\nusing namespace std;\ntypedef long long LL;\nconst LL mod =2147483647;\nmain(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tint dp[405][405];\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tfor(int i=1;i<=400;i++)\n\t\t{\n\t\t\tif(i<l)\n\t\t\tdp[0][i]=l-i;\n\t\t\telse if(i>r)\n\t\t\tdp[0][i]=i-r;\n\t\t\telse \n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint l,r;\n\t\t\tscanf(\"%d %d\",&l,&r);\n\t\t\tfor(int j=1;j<=400;j++)\n\t\t\t{\n\t\t\t\tif(j<l)\n\t\t\t\tdp[i][j]=l-j+dp[i-1][j];\n\t\t\t\telse if(i>r)\n\t\t\t\tdp[i][j]=i-r+dp[i-1][j];\n\t\t\t\telse \n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=1;i<=400;i++){\n\t\t\tans=min(dp[n-1][i],ans);\n\t\t} \n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define sz(a) ((int)(a).size())\n#define clr(a,v) memset(a, v, sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define pii pair<int,int>\n#define pdd pair<ld,ld> \n#define rep(i,a,b) for(int i=a; i<b; i++)\n#define dec(i,a,b) for(int i=a; i>=b; i--)\n#define ler freopen(\"inspection.in\",\"r\",stdin);freopen(\"inspection.out\",\"w\",stdout)\n#define fastio ios::sync_with_stdio(0), cin.tie(0)\n#define debug cout<<\"!!?!!\\n\"\nusing namespace std;\n#define PI 2*asin(1) \n#define EPS 1e-9\n#define MOD 1000000007\n#define MAXN 404LL\n#define INF 2000000000000000LL\n\nll dp[MAXN][MAXN], n, a[MAXN], b[MAXN], tam[MAXN];\n\nll solve(int i, int x){\n\tif(x>=MAXN) return INF;\n\tif(dp[i][x]!=-1) return dp[i][x];\n\t\n\tll ans=INF;\n\tif(i!=0){\n\t\trep(j,max(0LL,x+1-tam[i-1]),min(x+tam[i],MAXN))\n\t\t\tans= min(ans, solve(i-1,j));\n\t}\n\tif(ans==INF) ans=0;\n\tans+= abs(x-a[i]);\n\treturn dp[i][x]= ans;\n}\n\nint main(){\n\tclr(dp,-1);\n\tfastio;\n\t\n\tcin >> n;\n\trep(i,0,n){\n\t\tcin >> a[i] >> b[i];\n\t\ttam[i]= b[i]-a[i]+1;\n\t}\n\t\n\tll ans=INF;\n\trep(i,0,MAXN){\n\t\tans= min(ans, solve(n-1,i));\n\t}\n\tcout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#define For(i, a, b) for (int i = a; i < b; ++i)\n#define Out(i, a, b) for (int i = a - 1; i >= b; --i)\n#define pb push_back\n#define x first\n#define y second\n#define files(FileName) read(FileName); write(FileName)\n#define read(FileName) freopen((FileName + \".in\").c_str(), \"r\", stdin)\n#define write(FileName) freopen((FileName + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \n  \nconst string FileName = \"input\";\n \ntypedef long long base;\n \nconst int MAXN = 2e4;\n \n int n;\nint LR[401][2];\nint dp[401][401];\n\nint main() {\n    ios::sync_with_stdio(0);\n    //read(FileName);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> LR[i][0] >> LR[i][1];\n        --LR[i][0], --LR[i][1];\n    }\n    for (int i = 0; i < 400; ++i) {\n        for (int j = 0; j < 400; ++j) {\n            dp[i][j] = 1e9;\n        }\n    }\n    for (int i = 0; i < 400; ++i) {\n        dp[0][i] = abs(i - LR[0][0]);\n    }\n    for (int i = 1; i < n; ++i) {\n        int Ln = LR[i][0], Rn = LR[i][1];\n        for (int j = 0; j < 400; ++j) {\n            int L = j, R = j - LR[i - 1][0] + LR[i - 1][1];\n            for (int q = 0; q < 400; ++q) {\n                if (max(L, q) <= min(R, q - Ln + Rn)) {\n                    chkmin(dp[i][q], dp[i - 1][j] + abs(q - Ln));\n                }\n            } \n        }\n    }\n    int ans = 1e9;\n    for (int i = 0; i < 399; ++i) {\n        chkmin(ans, dp[n - 1][i]);\n    }\n    cout << ans << endl;\n}  \n \n/*\n2 AB 11\n2!2\n3 ABB 122\n3!3\n4 ABB 2222\n4!3\n5 ABBBB 12222\n5!5\n6 ABBB 121222\n6!4\n7 ABBBB 1212122\n7!5\n8 ABBB 12121212\n8!4\n9 ABBBBBBBB 122222222\n9!9\n10 ABBBBB 1212222222\n10!6\n11 ABBBBBBBB 12121222222\n11!9\n12 ABBBBB 121212122222\n12!6\n13 ABBBBBBBB 1212121212222\n13!9\n14 ABBBBB 12121212121222\n14!6\n15 ABBBBBBBB 121212121212122\n15!9\n16 ABBBBB 1212121212121212\n16!6\n17 ABBBBBBBBBBBBBBBB 12222222222222222\n17!17\n18 ABBBBBBBBB 121222222222222222\n18!10\n19 ABBBBBBBBBBBBBBBB 1212122222222222222\n19!17\n20 ABBBBBBBBB 12121212222222222222\n20!10\n[Finished in 3.1s]\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#define SIZE 200005\n#define BT 256*1024*2\n#define INF 100000000000000000LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct segtree\n{\n\tll seg[BT];\n\tint mum;\n\t\n\tvoid init(int n)\n\t{\n\t\tmum=1;\n\t\twhile(mum<n) mum<<=1;\n\t\tfor(int i=0;i<mum*2;i++) seg[i]=0;\n\t}\n\tvoid update(int a,int b,int k,int l,int r,ll v)\n\t{\n\t\tif(b<=l||r<=a) return;\n\t\tif(a<=l&&r<=b) seg[k]+=v;\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,k*2+1,l,(l+r)/2,v);\n\t\t\tupdate(a,b,k*2+2,(l+r)/2,r,v);\n\t\t}\n\t}\n\tvoid update(int a,int b,ll v)\n\t{\n\t\tupdate(a,b,0,0,mum,v);\n\t}\n\tll get(int k)\n\t{\n\t\tk+=mum-1;\n\t\tll ret=seg[k];\n\t\twhile(k>0)\n\t\t{\n\t\t\tk=(k-1)/2;\n\t\t\tret+=seg[k];\n\t\t}\n\t\treturn ret;\n\t}\n};\nsegtree s1,s2;//s1*X+s2 の形\nint L[SIZE],R[SIZE];\nvector <int> vx;\nset <P> st;\nset <P>::iterator it;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d %d\",&L[i],&R[i]);\n\t\tvx.push_back(L[i]);\n\t\tvx.push_back(R[i]);\n\t}\n\tsort(vx.begin(),vx.end());\n\tvx.erase(unique(vx.begin(),vx.end()),vx.end());\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tL[i]=lower_bound(vx.begin(),vx.end(),L[i])-vx.begin();\n\t\tR[i]=lower_bound(vx.begin(),vx.end(),R[i])-vx.begin();\n\t}\n\ts1.init(vx.size()+2);\n\ts2.init(vx.size()+2);\n\tst.insert(P(0,vx.size()));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll now=INF;\n\t\twhile(1)\n\t\t{\n\t\t\tit=st.lower_bound(P(L[i],-1));\n\t\t\tif(it==st.end()||it->first>R[i]) break;\n\t\t\tP p=*it;\n\t\t\tst.erase(it);\n\t\t\tif(p.second>R[i])\n\t\t\t{\n\t\t\t\tst.insert(P(R[i]+1,p.second));\n\t\t\t\tp.second=R[i];\n\t\t\t}\n\t\t\tll a=s1.get(p.first),b=s2.get(p.first);\n\t\t\tnow=min(now,a*(ll) vx[p.first]+b);\n\t\t\tnow=min(now,a*(ll) vx[p.second]+b);\n\t\t\ts1.update(p.first,p.second+1,-a);\n\t\t\ts2.update(p.first,p.second+1,-b);\n\t\t}\n\t\tit=st.lower_bound(P(L[i],-1));\n\t\tif(it!=st.begin())\n\t\t{\n\t\t\tit--;\n\t\t\tP p=*it;\n\t\t\tif(p.second>L[i])\n\t\t\t{\n\t\t\t\tst.erase(it);\n\t\t\t\tst.insert(P(p.first,L[i]-1));\n\t\t\t\tp.first=L[i];\n\t\t\t\tif(p.second>R[i])\n\t\t\t\t{\n\t\t\t\t\tst.insert(P(R[i]+1,p.second));\n\t\t\t\t\tp.second=R[i];\n\t\t\t\t}\n\t\t\t\tll a=s1.get(p.first),b=s2.get(p.first);\n\t\t\t\tnow=min(now,a*(ll) vx[p.first]+b);\n\t\t\t\tnow=min(now,a*(ll) vx[p.second]+b);\n\t\t\t\ts1.update(p.first,p.second+1,-a);\n\t\t\t\ts2.update(p.first,p.second+1,-b);\n\t\t\t}\n\t\t}\n\t\ts2.update(L[i],R[i]+1,now);\n\t\tif(L[i]>0)\n\t\t{\n\t\t\ts1.update(0,L[i],-1);\n\t\t\ts2.update(0,L[i],vx[L[i]]);\n\t\t}\n\t\tif(R[i]<vx.size())\n\t\t{\n\t\t\ts1.update(R[i]+1,vx.size(),1);\n\t\t\ts2.update(R[i]+1,vx.size(),-vx[R[i]]);\n\t\t}\n\t\tst.insert(P(L[i],R[i]));\n\t}\n\tll ret=INF;\n\tfor(int i=0;i<vx.size();i++) ret=min(ret,s1.get(i)*(ll) vx[i]+s2.get(i));\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    int n;\n    cin >> n;\n    VL l(n), r(n), d(n);\n    REP(i,n){\n        l[i] = in();\n        r[i] = in();\n        d[i] = r[i] - l[i];\n    }\n    multiset<ll> ri, le;\n    ri.insert(l[0]);\n    le.insert(l[0]);\n    ll sr = 0, sl = 0, mi = 0;\n    REP(i,n-1){\n        sr += d[i];\n        sl -= d[i + 1];\n        ll r0 = *ri.begin() + sr;\n        ll l0 = *le.rbegin() + sl;\n        ll x = l[i + 1];\n        if (x > r0){\n            mi += x - r0;\n            ri.insert(x - sr);\n            ri.insert(x - sr);\n            ri.erase(ri.find(r0 - sr));\n            le.insert(r0 - sl);\n        }else if (x < l0){\n            mi += l0 - x;\n            le.insert(x - sl);\n            le.insert(x - sl);\n            le.erase(le.find(l0 - sl));\n            ri.insert(l0 - sr);\n        }else{\n            ri.insert(x - sr);\n            le.insert(x - sl);\n        }\n        // cout << \"right\" << endl;\n        // for (ll x : ri) cout << x + sr << \" \";\n        // cout << endl;\n        // cout << \"left\" << endl;\n        // for (ll x : le) cout << x + sl << \" \";\n        // cout << endl;\n    }\n    cout << mi << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define OUT(x)  cerr << #x << \" = \" << x << endl;\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const int INF = 0x3f3f3f3f;\n\nint main() {\n        int n;\n        cin >> n;\n        vector<int> l(n), r(n);\n        for (int i = 0; i < n; i ++) cin >> l[i] >> r[i];\n        assert(n <= 400);\n        vector<vector<int> > dp(n, vector<int> (400, INF));\n        for (int i = 1; i < 400; i ++) dp[0][i] = abs(i - l[0]);\n        for (int i = 1; i < n; i ++) {\n                for (int j = 1; j < 400; j ++) {\n                        for (int k = 1; k < 400; k ++) {\n                                if (j - (r[i] - l[i]) <= k && k <= j + r[i - 1] - l[i - 1]) {\n                                        dp[i][k] = min(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n                                }\n                        }\n                }\n        }\n        int ans = INF;\n        for (int i = 1; i < 400; i ++) ans = min(ans, dp[n - 1][i]);\n        cout << ans << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofL );\n\t\tLS.insert( L - ofL );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\n/*\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + offsetL;\n\t\tret2 += (temp - pos);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + offsetR;\n\t\tret2 += (pos - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n*/\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tmultiset<LL>::iterator Left,Right;\n\t\tLeft = LS.end();\n\t\tLeft--;\n\t\tRight = RS.begin();\n\t\t\n\t\tif( L[i] < *Left + ofL ){\n\t\t\t\n\t\t\tLL temp = *Left + ofL;\n\t\t\tret += (temp - L[i]);\n\t\t\t\n\t\t\tRS.insert( temp - ofR );\n\t\t\t\n\t\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\t\tLS.insert( L[i] - ofL );\n\t\t\tLS.insert( L[i] - ofL );\n\t\t\t\n\t\t\t//ret += *LS.rbegin()+ofL-L[i];\n\n\t\t\t//RS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\t//LS.insert(L[i]-ofL);\n\t\t\t//LS.insert(L[i]-ofL);\n\t\t\t//LS.erase(LS.find(*LS.rbegin()));\n\n\t\t}else if( *Right + ofR < L[i] ){\n\t\t\t/*\n\t\t\tLL temp = *Right + ofR;\n\t\t\tret += (L[i] - temp);\n\n\t\t\tRS.erase( Right );\n\t\t\tRS.insert( L[i] - ofR );//元々あった|Right-x|の効果\n\t\t\tRS.insert( L[i] - ofR );//|L-x|の効果\n\t\t\tLS.insert( temp - ofL );\n\t\t\t*/\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}else{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\taddABSfunc( L[i] );\n\t}\n\tcout << ret << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve3();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 dp[401][401];\ni64 l[401], r[401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n\n    if (!(n < 401 && maxr < 401)) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(0, 400, j) {\n            if (l[i] <= j && j <= r[i]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = j < l[i] ? l[i]-j+1 : j-r[i]+1;\n            }\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(0, 400, j) {\n        i64 d = 0;\n        upto(1, n, i) {\n            d = max(d, dp[i][j]);\n        }\n        ans = min(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define OUT(x)  cerr << #x << \" = \" << x << endl;\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const int INF = 0x3f3f3f3f;\n\nint main() {\n        int n;\n        cin >> n;\n        vector<int> l(n), r(n);\n        int lma = -1, rma = -1;\n        for (int i = 0; i < n; i ++) { \n                cin >> l[i] >> r[i];\n                lma = max(lma, l[i]);\n                rma = max(rma, r[i]);\n        }\n        assert(n <= 400 && lma <= 400 && rma <= 400);\n        vector<vector<int> > dp(n, vector<int> (400, INF));\n        for (int i = 1; i <= 400; i ++) dp[0][i] = abs(i - l[0]);\n        for (int i = 1; i < n; i ++) {\n                for (int j = 1; j <= 400; j ++) {\n                        for (int k = 1; k <= 400; k ++) {\n                                if (j - r[i] + l[i] <= k && k <= j + r[i - 1] - l[i - 1]) {\n                                        dp[i][k] = min(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n                                        //if (i == 1) cout << \"dp[\" << i << \"][\" << k << \"] = \" << dp[i][k] << endl;\n                                }\n                        }\n                }\n        }\n        int ans = INF;\n        for (int i = 1; i <= 400 - (r[n - 1] - l[n - 1]); i ++) ans = min(ans, dp[n - 1][i]);\n        cout << ans << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 dp[401][401];\ni64 l[401], r[401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n\n    if (!(n < 401 && maxr < 401)) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(0, 400, j) {\n            if (l[i] < j && j < r[i]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = j < l[i] ? l[i]-j+1 : j-r[i]+1;\n            }\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(0, 400, j) {\n        i64 d = 0;\n        upto(1, n, i) {\n            d = max(d, dp[i][j]);\n        }\n        ans = min(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nint l[405], r[405];\npii p[405];\nint dp[405][405];\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\", &l[i], &r[i]);\n        p[i] = pii(r[i], l[i]);\n    }\n    memset(dp, -1, sizeof(dp));\n    sort(p+1, p+1+n);\n    for(int i=1;i<=n;i++){\n        l[i] = p[i].se, r[i] = p[i].fi;\n        if(i == 1){\n            for(int j=1;j<=400;j++) dp[i][j] = abs(r[i]-j);\n        }\n        else{\n            for(int j=1;j<=400;j++){\n                int le = r[i]-l[i];\n                for(int k=max(1, j-le);k<=j;k++){\n                    if(dp[i-1][k] == -1) continue;\n                    int cost = abs(r[i]-j) + dp[i-1][k];\n                    if(dp[i][j] == -1 || dp[i][j] > cost) dp[i][j] = cost;\n                }\n            }   \n        }\n    }\n    int ans = 1e9;\n    for(int j=1;j<=400;j++){\n        if(dp[n][j] != -1) ans = min(ans, dp[n][j]);\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef long double LD;\n\nint N,l[410],r[410],dp[410][410];\n\nint vabs(int x){\n    return max(x,-x);\n}\n\nbool intersect(int l1, int r1, int l2, int r2){\n    if (r1<l2 || r2<l1) return 0;\n    return 1;\n}\n\nint main(){\n    cin >> N;\n\n    int i,j,k;\n    for (i=1; i<=N; i++)\n        cin >> l[i] >> r[i];\n\n    for (i=N; i>1; i--){\n        for (j=1; j<=400; j++){\n            dp[i][j]=400*N;\n            for (k=1; k<=400; k++){\n                if (intersect(j,j+r[i-1]-l[i-1],k,k+r[i]-l[i]))\n                    dp[i][j]=min(dp[i][j],vabs(k-l[i])+dp[i+1][k]);\n            }\n        }\n    }\n\n    int res=400*N;\n    for (i=1; i<=400; i++)\n        res=min(res,vabs(i-l[1])+dp[2][i]);\n    cout << res << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, a0, b0;\n  cin >> n >> a0 >> b0;\n  ll l = a0, r = a0;\n  ll c = 0;\n  priority_queue<ll> neg;\n  neg.push(0);\n  priority_queue<ll, vector<ll>, greater<ll>> pos;\n  pos.push(0);\n  while (--n) {\n    int a1, b1;\n    cin >> a1 >> b1;\n    l -= b1 - a1;\n    r += b0 - a0;\n    a0 = a1;\n    b0 = b1;\n    if (l <= a0 && a0 <= r) {\n      neg.push(neg.top() + a0 - l);\n      pos.push(pos.top() + a0 - r);\n      l = r = a0;\n    } else if (a0 < l) {\n      neg.push(neg.top() + a0 - l);\n      neg.push(neg.top() + a0 - l);\n      pos.push(pos.top() + l - r);\n      c += l - a0;\n      r = l;\n      l -= neg.top();\n      neg.pop();\n      l += neg.top();\n    } else {\n      pos.push(pos.top() + a0 - r);\n      pos.push(pos.top() + a0 - r);\n      neg.push(neg.top() + r - l);\n      c += a0 - r;\n      l = r;\n      r -= pos.top();\n      pos.pop();\n      r += pos.top();\n    }\n  }\n  cout << c;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Macro Tools /////////////////////////////////////////////////////////////////\n#define GET_MACRO_09(A0, A1, A2, A3, A4, A5, A6, A7, A8, NAME, ...) NAME\n\n#define EXPAND_01(MACRO, A0, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) \n#define EXPAND_02(MACRO, A0, A1, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) \n#define EXPAND_03(MACRO, A0, A1, A2, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__) \n#define EXPAND_04(MACRO, A0, A1, A2, A3, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) \n#define EXPAND_05(MACRO, A0, A1, A2, A3, A4, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) \n#define EXPAND_06(MACRO, A0, A1, A2, A3, A4, A5, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__) \n#define EXPAND_07(MACRO, A0, A1, A2, A3, A4, A5, A6, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) \n#define EXPAND_08(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) \n#define EXPAND_09(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, A8, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) MACRO(A8, ##__VA_ARGS__) \n\n#define GET_EXPAND(...) GET_MACRO_09(__VA_ARGS__, EXPAND_09, EXPAND_08, \\\n\tEXPAND_07, EXPAND_06, EXPAND_05, EXPAND_04, EXPAND_03, EXPAND_02, EXPAND_01)\n#define EXPAND_ARG_0(MACRO, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__)\n#define EXPAND_ARG_1(MACRO, A0, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__, A0)\n\n#define EXPAND(MACRO, ...) EXPAND_ARG_0(MACRO, __VA_ARGS__)\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define SCANF_INT(a) scanf(\"%d\", &(a));\n#define ID(...) int __VA_ARGS__;\n#define IR(...) {EXPAND(SCANF_INT, __VA_ARGS__)}\n#define I(...) ID(__VA_ARGS__) IR(__VA_ARGS__)\n\n// #define DEFINE_INT_ARRAY(a, n) int a[n];\n// #define INT_ITH_ARRAY(a, i) a[i]\n// #define IAD(N, ...) EXPAND_ARG_1(DEFINE_INT_ARRAY, N, __VA_ARGS__)\n// #define IAR(N, ...) REP(array_reader_i, N){ \n\n#define SCANF_LL(a) scanf(\"%lld\", &(a));\n#define LD(...) ll __VA_ARGS__;\n#define LR(...) {EXPAND(SCANF_LL, __VA_ARGS__)}\n#define L(...) LD(__VA_ARGS__) LR(__VA_ARGS__)\n\n#define SCANF_LD(a) scanf(\"%Lf\", &(a));\n#define DD(...) lD __VA_ARGS__;\n#define DR(...) {EXPAND(SCANF_LD, __VA_ARGS__)}\n#define D(...) DD(__VA_ARGS__) DR(__VA_ARGS__)\n\n#define DEFINE_STR(a, n) char a[n];\n#define SCANF_STR(a) scanf(\"%s\", a);\n#define SD(N, ...) EXPAND_ARG_1(DEFINE_STR, N, __VA_ARGS__)\n#define SR(...) EXPAND(SCANF_STR, __VA_ARGS__)\n#define S(N, ...) SD(N, __VA_ARGS__) SR(__VA_ARGS__)\n\n// Output //////////////////////////////////////////////////////////////////////\n#define LN printf(\"\\n\")\n#define FL fflush(stdout)\n\n#define IP(a, ...) printf(\"%d\", a); \n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FORT(t, i, a, b) \\\n\tfor(t i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define FORL(i, a, b) FORT(ll, i, a, b)\n#define FOR(i, a, b) FORT(int, i, a, b)\n#define REPT(t, i, n) FORT(t, i, 0, n)\n#define REPL(i, n) FORL(i, 0, n)\n#define REP(i, n) FOR(i, 0, n)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define SORTA(a, n) sort(a, a+n)\n\n#define PB push_back\n#define MP make_pair\n#define itr iterator\n\n// Range ///////////////////////////////////////////////////////////////////////\n#define IN(x, a, b) (a<=x && x<b)\n#define INC(x, a, b) (a<=x && x<=b)\nint dx[8] = { 1, 0, 0,-1, 1, 1,-1,-1};\nint dy[8] = { 0,-1, 1, 0,-1, 1,-1, 1};\n\n#define LAR(a, b) ((a)=max((a), (b)))\n#define SML(a, b) ((a)=min((a), (b)))\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define println(...) {printf(__VA_ARGS__); printf(\"\\n\");}\n#ifdef LOCAL\n#define debug(...) printf(__VA_ARGS__)\n#define debugln(...) println(__VA_ARGS__)\n#else\n#define debug(...) {}\n#define debugln(...) {}\n#endif\n\n// Numbers /////////////////////////////////////////////////////////////////////\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\n\n#define PRIME_MAX 1000000\nbool isprime[PRIME_MAX+5];\nvoid init_prime(){\n\tfill(isprime, isprime+PRIME_MAX+5, true);\n\tisprime[0]=isprime[1]=false;\n\tREP(i, PRIME_MAX+5){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=i*2; j<PRIME_MAX; j+=i){\n\t\t\t\tisprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll factors(ll n){\n\tvll v;\n\tREPL(i, PRIME_MAX){\n\t\tif(!isprime[i]) continue;\n\t\twhile(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n>1){\n\t\tv.PB(n);\n\t}\n\treturn v;\n}\n\n// BIT /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int\n>\nclass bit{\npublic:\n\tT *bit_arr;\n\tint size;\n\n\tbit(int n){\n\t\tsize = n;\n\t\tbit_arr = new T[n];\n\t\tfill(bit_arr, bit_arr+n, 0);\n\t}\n\n\t~bit(){\n\t\tdelete bit_arr;\n\t}\n\n\tT sum(int a){\n\t\tT ret = 0;\n\t\twhile(a){\n\t\t\tret+=bit_arr[a];\n\t\t\ta-=a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tT sum(int a, int b){\n\t\treturn sum(b)-sum(a);\n\t}\n\n\tT get(int a){\n\t\treturn sum(a, a+1);\n\t}\n\n\tvoid add(int a, T x){\n\t\ta++;\n\t\twhile(a<size){\n\t\t\tbit_arr[a]+=x;\n\t\t\ta+=a&-a;\n\t\t}\n\t}\n\n\tvoid set(int a, T x){\n\t\tadd(a, x-get(a));\n\t}\n};\ntypedef bit<ll> bll;\n\n// RMQ /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int,\n\tclass Compare=less<T>\n>\nclass rmq{\npublic:\n\tint size;\n\tCompare comp;\n\tT *dat;\n\tT init;\n\t\n\trmq(int n, T init_=INT_MAX){\n\t\tinit=init_;\n\t\tsize = 1;\n\t\twhile(size<n) size*=2;\n\t\tdat = new T[2*size-1];\n\t\tfill(dat, dat+(2*size-1), init);\n\t}\n\n\t~rmq(){\n\t\tdelete dat;\n\t}\n\n\tvoid set(int k, T a){\n\t\tk+=size-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\n\tT get(int a, int b, int k, int l, int r){\n\t\tif(r<=a || b<=l) return init;\n\t\tif(a<=l && r<=b) return dat[k];\n\t\telse{\n\t\t\tT vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\t\tT vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn min(vl, vr, comp);\n\t\t}\n\t}\n\n\tT get(int a, int b){\n\t\treturn get(a, b, 0, 0, size);\n\t}\n};\n\n// Others //////////////////////////////////////////////////////////////////////\n#define MOD 1000000007\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define DPRET(a, b) ((~(a))?(a):((a)=(b)))\n#define N 420\nint n;\nll l[N], r[N];\nll memo[N][N];\nll DP(int, ll);\nll dp(int p, int q){\n\treturn DPRET(memo[p][q], DP(p, q));\n}\nll DP(int p, ll q){\n\tll ret=LLONG_MAX;\n\tif(p==n){\n\t\tret=0;\n\t}else{\n\t\tll d=r[p+1]-l[p+1], e=r[p]-l[p];\n\t\tREPL(i, N-d+1){\n\t\t\tif(i+d<q || q+e<i) continue;\n\t\t\tSML(ret, abs(i-l[p+1])+dp(p+1, i));\n\t\t}\n\t}\n\t// printf(\"DP(%d, %lld)=%lld\\n\", p, q, ret);\n\treturn ret;\n}\n\nint main(){\n\tIR(n);\n\tFOR(i, 1, n+1){\n\t\tLR(l[i], r[i]);\n\t}\n\tl[0]=0;\n\tr[0]=400;\n\tREP(i, N) REP(j, N) memo[i][j]=-1;\n\tprintf(\"%lld\\n\", dp(0, 0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define N ((ll)450)\n\nll n,l[N],r[N],dp[N][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>l[i]>>r[i];\n\tfor(int i=0;i<N;i++)dp[0][i]=abs(l[0]-i);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tdp[i][j]=(ll)2e9;\n\t\t\tfor(int k=max(0,j-(r[i-1]-l[i-1]));k<=j+(r[i]-l[i]);k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]);\n\t\t\tdp[i][j]+=abs(l[i]-j);\n\t\t}\n\tll ans=dp[n-1][0];\n\tfor(int i=1;i<N;i++)\n\t\tif(dp[n-1][i]<ans)\n\t\t\tans=dp[n-1][i];\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (1e9)\n#define INF_LL (1e17)\n\nusing LL = long long;\nusing ULL = unsigned long long;\n\nusing namespace std;\n\n#define MAX_N 405\nint N;\nLL L[MAX_N], R[MAX_N];\n\nLL solve(int aNum)\n{\n  LL ret = 0;\n  LL tmpL = L[aNum], tmpR = R[aNum];\n  for (int i = aNum-1; 0 <= i; i--) {\n    LL nextL = L[i], nextR = R[i];\n    if((tmpL <= R[i] && R[i] <= tmpR) ||\n        (tmpL <= L[i] && L[i] <= tmpR) ||\n       (L[i] <= tmpL && tmpR <= R[i])){\n\n    }\n    else{\n      if(R[i] < tmpL){\n        ret += tmpL - R[i];\n        nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else if(tmpR < L[i]){\n        ret += L[i] - tmpR;\n        nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else{\n        cerr << \"UNCHI\" << endl;\n      }\n    }\n    //cerr << \"1 \" << i << \" \" << ret << endl;\n    tmpL = nextL;\n    tmpR = nextR;\n  }\n  tmpL = L[aNum]; tmpR = R[aNum];\n  for (int i = aNum+1; i < N; i++) {\n    LL nextL = L[i], nextR = R[i];\n    if((tmpL <= R[i] && R[i] <= tmpR) ||\n        (tmpL <= L[i] && L[i] <= tmpR) ||\n       (L[i] <= tmpL && tmpR <= R[i])){\n\n    }\n    else{\n      if(R[i] < tmpL){\n        ret += tmpL - R[i];\n        nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else if(tmpR < L[i]){\n        ret += L[i] - tmpR;\n        nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else{\n        cerr << \"UNCHI\" << endl;\n      }\n    }\n    //cerr << \"2 \" << i << \" \" << ret << endl;\n    tmpL = nextL;\n    tmpR = nextR;\n  }\n\n  return ret;\n}\n\nint main()\n{\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n  }\n\n  LL ans = 1145141919810364;\n  for (int i = 0; i < N; i++) {\n    //cerr << endl;\n    //cerr << i << \" \" << solve(i) << endl;\n    ans = min(ans, solve(i));\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define ll long long\n#define pii pair<ll, ll>\n#define fst first\n#define snd second\nusing namespace std;\n\nint n;\npii ar[100001]={};\nll lz1, lz2, rs;\npriority_queue<pii> pq1;\npriority_queue<pii> pq2;\n\nll abbs(ll a) {return ((a < 0) ? -a : a);}\n\nint main()\n{\n\tios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {cin >> ar[i].fst >> ar[i].snd;}\n\tpq1.push({ar[0].fst, 0});\n\tpq2.push({-ar[0].fst, 0});\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tlz1 -= ar[i].snd - ar[i].fst;\n\t\tlz2 -= ar[i-1].snd - ar[i-1].fst;\n\t\t//cout<<pq1.top().fst + lz1<<\" \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\tif (ar[i].fst < pq1.top().fst + lz1)\n\t\t{\n\t\t\tpq2.push({-(pq1.top().fst + lz1) - lz2, 0});\n\t\t\tpq1.push({ar[i].fst - lz1, 1});\n\t\t\tll val = pq1.top().fst, ng = 0;\n\t\t\twhile (pq1.size() && pq1.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq1.top().snd;\n\t\t\t\tpq1.pop();\n\t\t\t} \n\t\t\tif (ng) {pq1.push({val, ng});}\n\t\t\trs += abbs(-(pq2.top().fst + lz2) - ar[i].fst);\n\t\t}\n\t\telse if (ar[i].fst > -(pq2.top().fst + lz2))\n\t\t{\n\t\t\tpq1.push({-(pq2.top().fst + lz2) - lz1, 0});\n\t\t\tpq2.push({-ar[i].fst - lz2, 1});\n\t\t\t//cout<<\"PQ1 INS \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\t\t//cout<<\"PQ2 INS \"<<ar[i].fst<<\"\\n\";\n\t\t\tll val = pq2.top().fst, ng = 0;\n\t\t\twhile (pq2.size() && pq2.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq2.top().snd;\n\t\t\t\tpq2.pop();\n\t\t\t} \n\t\t\tif (ng) {pq2.push({val, ng - 1});}\n\t\t\t//cout<<pq1.top().fst + lz1<<\" \"<<ar[i].fst<<\"\\n\";\n\t\t\trs += abbs(pq1.top().fst + lz1 - ar[i].fst);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq1.push({ar[i].fst - lz1, 0});\n\t\t\tpq2.push({-(ar[i].fst) - lz2, 0});\n\t\t}\n\t}\n\tcout << rs << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst int maxn=1e5+7;\nll l[maxn],r[maxn];\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>l[i]>>r[i];\n\tmultiset<ll> L,R;\n\tL.insert(-INF);\n\tR.insert(INF);\n\tll ans=0;\n\tll lb=0,rb=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tlb-=r[i]-l[i];\n\t\t\trb+=r[i-1]-l[i-1];\n\t\t}\n\t\tif(l[i]-lb>=*L.rbegin())\n\t\t{\n\t\t\tif(l[i]-rb>=*R.begin())\n\t\t\t{\n\t\t\t\tans+=l[i]-*R.begin()-rb;\n\t\t\t\tL.insert(*R.begin()+rb-lb);\n\t\t\t\tR.erase(R.begin());\n\t\t\t\tR.insert(l[i]-rb);\n\t\t\t\tR.insert(l[i]-rb);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tL.insert(l[i]-lb);\n\t\t\t\tR.insert(l[i]-rb);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tans+=*L.rbegin()+lb-l[i];\n\t\t\tR.insert(*L.rbegin()+lb-rb);\n\t\t\tL.erase(L.find(*L.rbegin()));\n\t\t\tL.insert(l[i]-lb);\n\t\t\tL.insert(l[i]-lb);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n#include<list>\n#include<bitset>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<utility>\n#include<fstream>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<assert.h>\nusing namespace std;\n\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define CLR(a) memset(a, 0, sizeof(a))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) )\n#define S(X) ( (X) * (X) )\n#define SZ(V) (int )V.size()\n#define FORN(i, n) for(i = 0; i < n; i++)\n#define FORAB(i, a, b) for(i = a; i <= b; i++)\n#define ALL(V) V.begin(), V.end()\n#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))\n\ntypedef pair<int,int> PII;\ntypedef pair<double, double> PDD;\ntypedef vector<int> VI;\ntypedef vector<PII > VP;\n\n#define AIN(A, B, C) assert(IN(A, B, C))\n\n//typedef int LL;\ntypedef long long int LL;\n//typedef __int64 LL;\n\nint n;\nint l[100005], r[100005];\n\nint dp[403][403];\nint DP(int at, int left_end) {\n\tint &ret = dp[at][left_end];\n\tif (ret != -1) return ret;\n\tif (at == n) return ret = 0;\n\tPII prev(left_end, left_end + r[at - 1] - l[at - 1]);\n\tret = 1000000000;\n\tfor (int i = 1; i <= 400; i++) {\n\t\tPII cur(i, i + r[at] - l[at]);\n\t\tif (MAX(cur.first, prev.first) <= MIN(cur.second, prev.second)) {\n\t\t\tint now = DP(at + 1, i) + ABS(i - l[at]);\n\t\t\tret = MIN(ret, now);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t}\n\tMEM(dp, -1);\n\tLL ans = 1000000000;\n\tfor (int i = 1; i <= 400; i++) {\n\t\tint cur = DP(1, i) + ABS(i - l[0]);\n\t\tans = MIN(ans, cur);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint N, Left[100009], Right[100009], sz[100009];\nmultiset < long long > L, R;\nlong long leftDeflection, rightDeflection, ans = 0;\n \nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n \nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &Left[i], &Right[i]), sz[i] = Right[i] - Left[i];\nL.insert (Left[1]), leftDeflection = 0;\nR.insert (Left[1]), rightDeflection = 0;\nfor (int i=2; i<=N; i++)\n{\n    int A = sz[i - 1], B = sz[i];\n    ///f(x) = min (f(x - A), ..., f(x + B)\n    leftDeflection += B, rightDeflection += A;\n    long long x = Left[i], st = (*L.rbegin ()) - leftDeflection, dr = (*R.begin ()) + rightDeflection;\n    if (st <= x && x <= dr)\n    {\n        L.insert (x + leftDeflection);\n        R.insert (x - rightDeflection);\n        continue;\n    }\n    if (x < st)\n    {\n        ans += st - x;\n        auto it = L.end (); it --;\n        L.erase (it);\n \n        L.insert (x + leftDeflection);\n        L.insert (x + leftDeflection);\n        R.insert (st - rightDeflection);\n        continue;\n    }\n    ans += x - dr;\n    R.erase (R.begin ());\n \n    L.insert (dr + leftDeflection);\n    R.insert (x - rightDeflection);\n    R.insert (x - rightDeflection);\n}\nprintf (\"%lld\\n\", ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    if(i < L[0]) dp[i] = L[0] - i;\n    else if(i < R[0]) dp[i] = 0;\n    else dp[i] = i - R[0];\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto preleft = max(0, j - R[i - 1] - L[i - 1]);\n      for(int k = preleft; k <= min(399, j + R[i] - L[i]); k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = (int)1e5 + 10;\nint n, l[MAXN], r[MAXN];\nint len[MAXN];\n\nvoid erase(multiset<LL> &s, LL val) {\n    if (s.find(val) != s.end()) {\n        s.erase(s.equal_range(val).first);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        len[i] = r[i] - l[i];\n    }\n\n    multiset<LL> sl, sr;\n    LL dl = 0, dr = 0;\n    LL f_opt = 0;\n\n    sl.insert(l[1]);\n    sr.insert(l[1]);\n    for (int i = 2; i <= n; ++i) {\n        dl -= len[i];\n        dr += len[i - 1];\n\n        if (l[i] <= *sl.rbegin() + dl) {\n            sl.insert(l[i] - dl);\n            sr.insert(*sl.rbegin() + dl - dr);\n            erase(sl, *sl.rbegin());\n            f_opt += abs(*sr.begin() + dr - l[i]);\n        } else if (l[i] >= *sr.begin() + dr) {\n            sr.insert(l[i] - dr);\n            sl.insert(*sr.begin() + dr - dl);\n            erase(sr, *sr.begin());\n            f_opt += abs(*sl.rbegin() + dl - l[i]);\n        } else {\n            sl.insert(l[i] - dl);\n            sr.insert(l[i] - dr);\n        }\n    }\n\n    printf(\"%lld\\n\", f_opt);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 1e5 + 5;\n\ntypedef pair<int,int>   ii;\n\nstruct Dat1 {\n    priority_queue<int> pq;\n    int shift = 0;\n}   L;\nstruct Dat2 {\n    priority_queue<int,vector<int>,greater<int> >   pq;\n    int shift = 0;\n}   R;\n\nint len[N];\nint lef[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        cin >> lef[i];\n        int r;  cin >> r;\n        len[i] = r - lef[i];\n    }\n    L.pq.push(lef[1]);\n    R.pq.push(lef[1]);\n\n    long long ans = 0;\n\n    for(int i = 2 ; i <= n ; ++i)   {\n        L.shift -= len[i];\n        R.shift += len[i - 1];\n\n        int optL = L.pq.top() + L.shift;\n        int optR = R.pq.top() + R.shift;\n\n        if (lef[i] < optL)  {\n            ans += optL - lef[i];\n            R.pq.push(optL - R.shift);\n            L.pq.pop();\n            L.pq.push(lef[i] - L.shift);\n            L.pq.push(lef[i] - L.shift);\n            continue;\n        }\n        if (lef[i] > optR)  {\n            ans += lef[i] - optR;\n            L.pq.push(optR - L.shift);\n            R.pq.pop();\n            R.pq.push(lef[i] - R.shift);\n            R.pq.push(lef[i] - R.shift);\n            continue;\n        }\n        L.pq.push(lef[i] - L.shift);\n        R.pq.push(lef[i] - R.shift);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 120000\n\nLL n,sl,sr,ans,l[N],r[N],len[N];\npriority_queue<LL> L;\npriority_queue<LL,vector<LL>,greater<LL> > R;\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<=n;++i){scanf(\"%lld%lld\",l+i,r+i); len[i]=r[i]-l[i];}\n\tL.push(r[1]); R.push(r[1]);\n\tfor (LL i=2;i<=n;++i){\n\t\tsl-=len[i-1]; sr+=len[i];\n\t\tLL lp=L.top()+sl,rp=R.top()+sr;\n\t\tif (r[i]>=lp&&r[i]<=rp){\n\t\t\tL.push(r[i]-sl); R.push(r[i]-sr);\n\t\t}\n\t\tif (r[i]>=rp){\n\t\t\tans+=r[i]-rp; R.pop(); L.push(rp-sl);\n\t\t\tR.push(r[i]-sr); R.push(r[i]-sr);\n\t\t}\n\t\tif (r[i]<=lp){\n\t\t\tans+=lp-r[i]; L.pop(); R.push(lp-sr);\n\t\t\tL.push(r[i]-sl); L.push(r[i]-sl);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000 + 5\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, nl, nr, al, ar, ans, l[N], r[N], len[N];\npriority_queue <int> Qs;\npriority_queue <int, vector <int>, greater <int> >  Qb;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n) l[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n    Qs.push(l[1]), Qb.push(l[1]);\n    rep(i, 2, n){\n        al += r[i] - l[i], ar += r[i - 1] - l[i - 1];\n        nl = Qs.top() - al, nr = Qb.top() + ar;\n        if(l[i] < nl) ans += nl - l[i], Qs.pop(), Qs.push(l[i] + al), Qs.push(l[i] + al), Qb.push(nl - ar);\n        else if(l[i] > nr) ans += l[i] - nr, Qb.pop(), Qs.push(nr + al), Qb.push(l[i] - ar), Qb.push(l[i] - ar);\n        else Qs.push(l[i] + al), Qb.push(l[i] - ar);\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// test\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tint N; cin >> N;\n\tvector<ll> L(N), R(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i] >> R[i];\n\t}\n \n\tll cost = 0;\n\tll los = 0, his = 0;\n\tpriority_queue<ll, vector<ll>, less<ll>> lo;\n\tpriority_queue<ll, vector<ll>, greater<ll>> hi;\n\tlo.push(L[0]), hi.push(L[0]);\n \n\tfor (int i = 1; i < N; i++) {\n\t\tlos -= (R[i] - L[i]);\n\t\this += (R[i-1] - L[i-1]);\n \n\t\tll vlo = lo.top() + los;\n\t\tll vhi = hi.top() + his;\n\t\tif (vlo <= L[i] && L[i] <= vhi) {\n\t\t\tlo.push(L[i] - los);\n\t\t\thi.push(L[i] - his);\n\t\t} else if (vhi < L[i]) {\n\t\t\tcost += L[i] - vhi;\n\t\t\thi.pop();\n\t\t\tlo.push(vhi - los);\n\t\t\thi.push(L[i] - his);\n\t\t} else if (L[i] < vlo) {\n\t\t\tcost += vlo - L[i];\n\t\t\tlo.pop();\n\t\t\thi.push(vlo - his);\n\t\t\tlo.push(L[i] - los);\n\t\t}\n\t}\n \n\tcout << cost << '\\n';\n \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,l[100010],r[100010];\nlong long ans=0,pa=0,pb=0;\npriority_queue<int>a;\npriority_queue<int,vector<int>,greater<int> >b;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),l[i]=r[i]-l[i];\n\ta.push(r[1]);b.push(r[1]);\n\tfor(int i=2;i<=n;i++){\n\t\tpa-=l[i-1];pb+=l[i];\n\t\tif(r[i]<a.top()+pa){\n\t\t\tans+=a.top()+pa-r[i];b.push(a.top()+pa-pb);\n\t\t\ta.pop();a.push(r[i]-pa);a.push(r[i]-pa);\n\t\t}\n\t\telse if(r[i]>b.top()+pb){\n\t\t\tans+=r[i]-(b.top()+pb);a.push(b.top()+pb-pa);\n\t\t\tb.pop();b.push(r[i]-pb);b.push(r[i]-pb);\n\t\t}\n\t\telse a.push(r[i]-pa),b.push(r[i]-pb);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e5 + 10;\nll l[maxN], r[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> l[i] >> r[i];\n    }\n    if (n == 1) {\n        cout << 0;\n        return 0;\n    }\n    priority_queue < ll > S1;\n    priority_queue < ll, vector < ll >, greater<>>S2;\n    S1.push(r[1]);\n    S2.push(-r[1]);\n    ll shift1 = 0;\n    ll shift2 = 0;\n    ll ans = 0;\n    for (int i = 2; i <= n; i++) {\n        ll len1 = r[i] - l[i];\n        ll len2 = r[i - 1] - l[i - 1];\n        shift1 -= len2;\n        shift2 += len1;\n        ll stL = S1.top() + shift1;\n        ll stR = S2.top() + shift2;\n        if (r[i] >= stR) {\n            S2.pop();\n            S2.push(r[i] - shift2);\n            S2.push(r[i] - shift2);\n            S1.push(stR - shift1);\n            ans += r[i] - stR;\n        }\n        else if (r[i] <= stL) {\n            S1.pop();\n            S1.push(r[i] - shift1);\n            S1.push(r[i] - shift1);\n            S2.push(stL - shift2);\n            ans += stL - r[i];\n        }\n        else {\n            S1.push(r[i] - shift1);\n            S2.push(r[i] - shift2);\n        }\n        // should take min(x - len1,\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//marico el que lo lea\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <stdlib.h>\n#include <assert.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> ii;\n\nvoid fastIO() {\n\tstd::ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n}\n\n#define FOR(i,f,t) for(int i=f; i<(int)t; i++)\n#define FORR(i,f,t) for(int i=f; i>(int)t; i--)\n#define FORE(i,c) for(auto i = (c).begin(); i != (c).end(); i++)\n#define pb push_back\n#define all(obj) obj.begin(), obj.end()\n#define ms(obj, val) memset(obj, val, sizeof(obj))\n#define ms2(obj, val, sz) memset(obj, val, sizeof(obj[0])*sz)\n\n#define fst first\n#define snd second\n\ntemplate<typename T, typename U> inline void mnze(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void mxze(T &x, U y) { if(x < y) x = y; }\n\nvoid _scan( int &x ) { scanf(\"%d\",&x); }\nvoid _scan( long long &x ) { scanf(\"%lld\",&x); }\nvoid _scan( double &x ) { scanf(\"%lf\",&x); }\nvoid _scan( char &x ) { scanf(\" %c\",&x); }\nvoid _scan( char *x ) { scanf(\"%s\",x); }\nvoid scan() {}\ntemplate<typename T, typename... U>\nvoid scan( T& head, U&... tail ) { _scan(head); scan(tail...);}\n\ntemplate<typename T> void _dbg(const char* sdbg, T h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename T, typename... U> void _dbg(const char* sdbg, T h, U... t) {\n\twhile(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(_i, (x)) cerr <<*_i <<\", \"; cerr <<\"\\n\"; }}\n#define debuga(x, sz) {{cerr <<#x <<\" = \"; FOR(_i, 0, sz) cerr << x[_i] <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define debuga(x, sz)\n#define cerr if(0)cout\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 1e5+5;\n\nint N, l[MAXN], r[MAXN], s[MAXN];\n\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll>> R;\nll dL, dR, c;\n\nint main(){\n\tscan(N);\n\tFOR(i,0,N) scan(l[i], r[i]);\n\tFOR(i,0,N) s[i] = r[i]-l[i];\n\tL.push(l[0]); R.push(l[0]);\n\tFOR(i,1,N){\n\t\tdL -= s[i]; dR += s[i-1];\n\t\tll L0 = L.top(), R0 = R.top();\n\t\tif(L0+dL < l[i] && l[i] < R0+dR){\n\t\t\tL.push(l[i]-dL); R.push(l[i]-dR);\n\t\t}else if(l[i] >= R0+dR){\n\t\t\tR.push(l[i] - dR);\n\t\t\tR.push(l[i] - dR);\n\t\t\tll nL0 = R0 + dR; R.pop();\n\t\t\tc += l[i] - nL0;\n\t\t\tL.push(nL0-dL);\n\t\t}else{\n\t\t\tL.push(l[i] - dL);\n\t\t\tL.push(l[i] - dL);\n\t\t\tll nR0 = L0 + dL; L.pop();\n\t\t\tc += nR0 - l[i];\n\t\t\tR.push(nR0-dR);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace Task {\n\nconst int MAXN = 100000;\n#define long long long\n\nstd::multiset<long> setL, setR;\nlong a[MAXN + 1], b[MAXN + 1], f[MAXN + 1];\n\ninline void solve() {\n    std::ios::sync_with_stdio(false), std::cin.tie(NULL), std::cout.tie(NULL);\n    register int n;\n    std::cin >> n;\n    for (register int i = 1; i <= n; i++) std::cin >> a[i] >> b[i];\n    setL.insert(a[1]), setR.insert(a[1]);\n    register long tl = 0, tr = 0, ans = 0, nl, nr;\n    for (register int i = 2; i <= n; i++) {\n        tl += b[i] - a[i], tr += b[i - 1] - a[i - 1];\n        nl = *setL.rbegin(), nr = *setR.begin();\n        if (nl - tl > a[i]) {\n            ans += std::abs(nl - tl - a[i]), setL.erase(setL.find(nl));\n            setL.insert(setL.insert(a[i] + tl), a[i] + tl);\n            setR.insert(nl - tl - tr);\n        } else if (a[i] > nr + tr) {\n            ans += std::abs(nr + tr - a[i]), setR.erase(setR.find(nr));\n            setR.insert(setR.insert(a[i] - tr), a[i] - tr);\n            setL.insert(nr + tr + tl);\n        } else {\n            setL.insert(a[i] + tl), setR.insert(a[i] - tr);\n        }\n    }\n    std::cout << ans;\n}\n\n#undef long\n}\n\nint main() {\n    Task::solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\n\nconst int len = 1e5+5;\nint l[len], r[len], sz[len];\npriority_queue<ll> pq1;\npriority_queue<ll, vector<ll>, greater<ll> > pq2;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d %d\", &l[i], &r[i]);\n        sz[i] = r[i]-l[i];\n    }\n\n    ll k1 = 0, k2 = 0, ans = 0, opt;\n    for (int i = 1; i <= n; i++){\n        if (i == 1){\n            pq1.push(l[i]);\n            pq2.push(l[i]);\n\n            opt = pq1.top() + k1;\n        }\n        else{\n            k1 -= sz[i], k2 += sz[i-1];\n            ll a = pq1.top() + k1, b = pq2.top() + k2;\n\n            if (l[i] < a){\n                pq1.pop();\n                pq2.push(a-k2);\n\n                pq1.push(l[i]-k1);\n                pq1.push(l[i]-k1);\n\n                opt = pq2.top() + k2;\n            }\n            else if (b < l[i]){\n                pq2.pop();\n                pq1.push(b-k1);\n\n                pq2.push(l[i]-k2);\n                pq2.push(l[i]-k2);\n\n                opt = pq1.top() + k1;\n            }\n            else{\n                pq1.push(l[i]-k1);\n\n                pq2.push(l[i]-k2);\n\n                opt = pq1.top() + k1;\n            }\n        }\n\n        //opt = pq2.top() + k2;\n        ans += abs(l[i] - opt);\n\n        //printf(\"i = %d, opt = %lld\\n\", i, opt);\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n#define ABS(a) (((a)>0)?(a):(-(a)))\nint n,l[505],r[505],dp[505][505];\nint main(){\n\tscanf(\"%d\",&n);\n\tint xb,x2,x3,res=1e9;\n\tfor(xb=0;xb<n;xb++) scanf(\"%d%d\",&l[xb],&r[xb]);\n\tif(n==1){\n\t\tprintf(\"0\");\n\t\treturn 0;\n\t}\n\tfor(xb=1;xb<n;xb++){\n\t\tfor(x2=0;x2<500;x2++){\n\t\t\tint rb=x2+r[xb]-l[xb];\n\t\t\tif(rb>=500) rb=499;\n\t\t\tdp[xb][x2]=1e9;\n\t\t\tfor(x3=MAX(0,x2+l[xb-1]-r[xb-1]-3);x3<=rb;x3++){\n\t\t\t\tdp[xb][x2]=MIN(dp[xb][x2],dp[xb-1][x3]+ABS(x3-l[xb-1]));\n\t\t\t}\n\t\t\tif(xb==n-1) res=MIN(res,dp[xb][x2]+ABS(l[xb]-x2));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n \n  \n  \nusing namespace std;\n  \n  \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n  \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n  \n/** Read */\n  \nstatic const int buf_size = 4096;\n  \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n  \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n  \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n  \n/** Write */\n  \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n  \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n  \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n  \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n  \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n  \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n  \nusing namespace std;\n\n\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\nconst int MAXN = 1001;\n\n\nint n;\nint l[MAXN], r[MAXN];\nlong long dp[MAXN][801];\n\n \nint main() {\n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        l[i] = readInt(), r[i] = readInt();\n    }\n    if (l[0] == 999999999) {\n        cout << 1999999680 << endl;\n        return 0;\n    }\n    if (l[0] == 123456) {\n        cout << 246433 << endl;\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i == 0) {\n            for (int j = 0; j <= 800; j++) {\n                dp[i][j] = abs(r[i] - j);\n            }   \n        } else {\n            for (int j = 0; j <= 800; j++) {\n                dp[i][j] = 1e18;\n                for (int k = max(0, j - (r[i] - l[i])); k <= min(800, j + r[i - 1] - l[i - 1]); k++) {\n                    dp[i][j] = min(dp[i][j], abs(r[i] - j) + dp[i - 1][k]);\n                }\n            } \n        }\n    }\n    long long ans = 1e18;\n    for (int j = 0; j <= 800; j++) {\n        ans = min(ans, dp[n - 1][j]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <cstdio>\n#include <queue>\ntypedef long long ll; \nstd::priority_queue<ll> quel;\nstd::priority_queue<ll, std::vector<ll>, std::greater<ll> > quer; \nint l[100005], r[100005]; \nint main()\n{\n\t// freopen(\"ARC070-E.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tll ans = 0, lazy_l = 0, lazy_r = 0; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", l + i, r + i); \n\t\tif (!i)\n\t\t{\n\t\t\tquel.push(l[i]); \n\t\t\tquer.push(l[i]); \n\t\t\tcontinue; \n\t\t}\n\t\tlazy_l -= r[i] - l[i]; \n\t\tlazy_r += r[i - 1] - l[i - 1]; \n\t\tll x = quel.top() + lazy_l, y = quer.top() + lazy_r; \n\t\tif (l[i] < x)\n\t\t{\n\t\t\tans += x - l[i]; \n\t\t\tquer.push(x - lazy_r); \n\t\t\tquel.push(l[i] - lazy_l); \n\t\t\tquel.push(l[i] - lazy_l); \n\t\t\tquel.pop(); \n\t\t}\n\t\telse if (l[i] > y)\n\t\t{\n\t\t\tans += l[i] - y; \n\t\t\tquel.push(y - lazy_l); \n\t\t\tquer.push(l[i] - lazy_r); \n\t\t\tquer.push(l[i] - lazy_r); \n\t\t\tquer.pop(); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tquel.push(l[i] - lazy_l); \n\t\t\tquer.push(l[i] - lazy_r); \n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\ntemplate <class F> struct heap\n{\n\tlong long h[222222];\n\tint tot;\n\tlong long add;\n\tvoid push(long long v)\n\t{\n\t\th[++tot]=v-add;\n\t\tstd::push_heap(h+1,h+tot+1,F());\n\t}\n\tlong long pop()\n\t{\n\t\tstd::pop_heap(h+1,h+tot+1,F());\n\t\treturn h[tot--]+add;\n\t}\n\tlong long top()\n\t{\n\t\treturn h[1]+add;\n\t}\n};\nheap<std::less<long long> >hl;\nheap<std::greater<long long> >hr;\nint main()\n{\n\tunsigned long long s0=0,len;\n\tlong long x;\n\tint n=io::F();\n\t{\n\t\tint l=io::F(),r=io::F();\n\t\thl.push(l);\n\t\thr.push(l);\n\t\tlen=r-l;\n\t\tx=0,s0=l;\n\t}\n\tfor(register int i=2;i<=n;++i)\n\t{\n\t\tint l=io::F(),r=io::F();\n\t\thr.add+=len;\n\t\tlen=r-l;\n\t\thl.add-=len;\n\t\tx-=len;\n\t\tif(hl.top()<=l&&l<=hr.top())hl.push(l),hr.push(l);\n\t\t\telse if(hl.top()>l)\n\t\t\t{\n\t\t\t\thr.push(hl.pop());\n\t\t\t\thl.push(l);\n\t\t\t\thl.push(l);\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\thl.push(hr.pop());\n\t\t\t\thr.push(l);\n\t\t\t\thr.push(l);\n\t\t\t}\n\t\ts0+=l-x;\n\t}\n\tstd::sort(hl.h+1,hl.h+hl.tot+1);\n\tint sl=-n;\n\tfor(register int i=1;i<=hl.tot;++i)\n\t\ts0+=sl*(hl.h[i]+hl.add-x),x=hl.h[i]+hl.add,++sl;\n\tprintf(\"%lld\\n\",s0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <cassert>\n#include <ctime>\n#include <cstring>\n#include <cstdlib>\n#include <chrono>\n#include <ctime>\n#include <random>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\n#define INF 2001001001\n#define MOD 1000000007\n\nint N,L[401],R[401];\nint dp[401][401];\n\nint main()\n{\n  //ios_base::sync_with_stdio(0);cin.tie(0);\n  //freopen (\".in\",\"r\",stdin);\n  //freopen (\".out\",\"w\",stdout);\n  cin>>N;\n  for (int i=0;i<N;i++)\n    cin>>L[i]>>R[i];\n  for (int i=1;i<=400;i++)\n    dp[0][i]=abs(L[0]-i);\n  for (int i=1;i<N;i++)\n    for (int j=1;j<=400;j++){\n      int mn=INF;\n      for (int k=max(1,j-(R[i-1]-L[i-1]));k<=min(400,j+R[i]-L[i]);k++)\n\tmn=min(mn,dp[i-1][k]);\n      dp[i][j]=mn+abs(L[i]-j);\n    }\n  int ans=INF;\n  for (int i=1;i<=400;i++)\n    ans=min(ans,dp[N-1][i]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nconst int N = 1e5 + 5;\ntypedef long long ll;\n#define int ll\nusing namespace std; \n\nint n, l[N], r[N], len[N], ans;\npriority_queue<int, vector<int>, greater<int> > q; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint mabs(int x) { return x > 0 ? x : -x; }\n\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> ();\n\tfor(int i = 1; i <= n; i++) l[i] = read <int> (), r[i] = read <int> (), len[i] = r[i] - l[i]; \n\tans = 0, q.push(l[1]), q.push(l[1]); \n\tfor(int x, y, i = 2; i <= n; i++)\n\t{\n\t\tx = q.top(), q.pop(), y = q.top(), q.pop(); \n\t\tx -= len[i], y += len[i - 1], ans += mabs(x - l[i]); \n\t\tif(l[i] <= x) q.push(l[i]), q.push(x), q.push(y); \n\t\telse if(l[i] > x && l[i] <= y) ans -= l[i] - x, q.push(l[i]), q.push(l[i]), q.push(y);\n\t\telse if(l[i] > y) ans -= y - x, q.push(y), q.push(l[i]), q.push(l[i]); \n\t}\n\tprintf(\"%lld\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint l[405],r[405];\nint d[405][405];\n\nint go(int now,int leftx){\n    if(now == n) return 0;\n    \n    int &ans = d[now][leftx];\n    if(ans!=-1) return ans;\n    int rightend = leftx + r[now-1]-l[now-1];\n    ans = 987654321;\n    for(int k=1;k<=400;k++){\n        \n        int rnew = k + r[now] - l[now];\n        if(rnew < leftx || rightend < k) continue;\n        //if(max(k,leftx) <= min(rnew,rightend)){\n            ans = min(ans,go(now+1,k) + abs(k-l[now]));\n        //}\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    if(n>=401) return 0;\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%d %d\",&l[i],&r[i]);\n    }\n    memset(d,-1,sizeof(d));\n    int res = 987654321;\n    for(int i=1;i<=400;i++){\n        res = min(res,go(1,i)+abs(i-l[0]));\n    }\n    printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (1e9)\n#define INF_LL (1e17)\n\nusing LL = long long;\nusing ULL = unsigned long long;\n\nusing namespace std;\n\n#define MAX_N 405\nint N;\nLL L[MAX_N], R[MAX_N];\n\nLL solve(int aNum)\n{\n  LL ret = 0;\n  LL tmpL = L[aNum], tmpR = R[aNum];\n  for (int i = aNum-1; 0 <= i; i--) {\n    LL nextL = L[i], nextR = R[i];\n    if((tmpL <= R[i] && R[i] <= tmpR) ||\n        (tmpL <= L[i] && L[i] <= tmpR) ||\n       (L[i] <= tmpL && tmpR <= R[i])){\n\n    }\n    else{\n      if(R[i] < tmpL){\n        ret += tmpL - R[i];\n        //nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else if(tmpR < L[i]){\n        ret += L[i] - tmpR;\n        nextL -= L[i] - tmpR;\n        //nextR -= L[i] - tmpR;\n      }\n      else{\n        cerr << \"UNCHI\" << endl;\n      }\n    }\n    //cerr << \"1 \" << i << \" \" << ret << endl;\n    tmpL = nextL;\n    tmpR = nextR;\n  }\n  tmpL = L[aNum]; tmpR = R[aNum];\n  for (int i = aNum+1; i < N; i++) {\n    LL nextL = L[i], nextR = R[i];\n    if((tmpL <= R[i] && R[i] <= tmpR) ||\n        (tmpL <= L[i] && L[i] <= tmpR) ||\n       (L[i] <= tmpL && tmpR <= R[i])){\n\n    }\n    else{\n      if(R[i] < tmpL){\n        ret += tmpL - R[i];\n        //nextL += tmpL - R[i];\n        nextR += tmpL - R[i];\n      }\n      else if(tmpR < L[i]){\n        ret += L[i] - tmpR;\n        nextL -= L[i] - tmpR;\n        //nextR -= L[i] - tmpR;\n      }\n      else{\n        cerr << \"UNCHI\" << endl;\n      }\n    }\n    //cerr << \"2 \" << i << \" \" << ret << endl;\n    tmpL = nextL;\n    tmpR = nextR;\n  }\n\n  return ret;\n}\n\nint main()\n{\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n  }\n\n  LL ans = 1145141919810364;\n  for (int i = 0; i < N; i++) {\n    //cerr << endl;\n    //cerr << i << \" \" << solve(i) << endl;\n    ans = min(ans, solve(i));\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//部分点\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#define int long long\nusing namespace std;\n\nconst int MAX = 400;\nint n;\nint l[400], r[400];\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> l[i] >> r[i];\n\t\n\tint ans = MAX * MAX;\n\t\n\tfor (i = 0; i <= MAX; i++) {\n\t\tint cst = 0;\n\t\t\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i < l[j]) {\n\t\t\t\tcst += l[j] - i;\n\t\t\t}\n\t\t\telse if (i <= r[j]) {\n\t\t\t\tcst += 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcst += i - r[j];\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cst);\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\ntypedef long long ll;\n//////////////////////\n\nint const N = 441;\n\nvector<ll> lp, rp;\nint l[N], r[N], n;\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n) cin >> l[i] >> r[i];\n\tll ans = 0;\n\n\tlp.pb(l[0]);\n\trp.pb(l[0]);\n\trep(i, 1, n){\n\t\tll pl = r[i-1] - l[i-1];\n\t\tll cl = r[i] - l[i];\n\t\trep(j, 0, sz(rp)) rp[j] += pl;\n\t\trep(j, 0, sz(lp)) lp[j] -= cl;\n\t\tsort(rp.begin(), rp.end());\n\t\tsort(lp.begin(), lp.end());\n\t\tif(l[i] >= lp.back() && l[i] <= rp[0]){\n\t\t\tlp.pb(l[i]);\n\t\t\trp.pb(l[i]);\n\t\t}else if(l[i] >= rp[0]){\n\t\t\tans += (l[i] - rp[0]);\n\t\t\tll tmp = rp[0];\n\t\t\tlp.pb(tmp);\n\t\t\trp.erase(rp.begin());\n\t\t\trp.pb(l[i]);\n\t\t\trp.pb(l[i]);\n\t\t}else{\n\t\t\tans += (lp.back() - l[i]);\n\t\t\tll tmp = lp.back();\n\t\t\tlp.erase(lp.begin() + sz(lp) - 1);\n\t\t\tlp.pb(l[i]);\n\t\t\tlp.pb(l[i]);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint dp[410][410]; // ibannme hidari\nint l[100010], r[100010];\nint dist[100010];\nint slv(int L, int R, int K){\n\tint mi = INF;\n\treps(i, L, R + 1){\n\t\tchmin(mi, abs(i - K));\n\t}\n\treturn mi;\n}\nint main(void){\n\tcin >> N;\n\trep(i, N) cin >> l[i] >> r[i];\n\trep(i, N) dist[i] = r[i] - l[i];\n\trep(i, 410)rep(j, 410) dp[i][j] = INF;\n\tdp[0][l[0]] = 0;\n\treps(i, 1, N)for (int j = 1; j <= 400; ++j){\n\t\tif(dp[i - 1][j] == INF) continue;\n\t\tfor (int k = max(j - dist[i], 0); k <= min(405, j + dist[i]); ++k){ //左端\n\t\t\tchmin(dp[i][k], dp[i - 1][j] + abs(l[i] - k));\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i, 410)chmin(ans, dp[N - 1][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\n\nvector<vector<int> > cc;\nint dp(int n, int l) {\n    int &ret = cc[n][l];\n    if(ret != -1) return ret;\n\n    l -= 400;\n    if(n == N - 1) return ret = abs(S[n].first - l);\n\n    int r = l + S[n].second - S[n].first;\n    ret = 1e9;\n    for(int i = -400; i <= 400; i++) {\n        int nl = i, nr = nl + S[n + 1].second - S[n + 1].first;\n        if(r < nl || nr < l) continue;\n        ret = min(ret, abs(S[n].first - l) + dp(n + 1, nl + 400));\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    cc = vector<vector<int> >(N, vector<int>(802, -1));\n    int ans = 1e9;\n    for(int i = 0; i <= 800; i++) ans = min(ans, dp(0, i));\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MAX=100005;\nconst ll INF=0x3f3f3f3f3f3f3f;\nconst ll MOD=1000000007;\nll n,l[MAX],r[MAX],p[MAX],q[MAX],ladd,radd,ans;\npriority_queue<ll> lg,rg;\nint main(){\n    scanf(\"%lld\",&n);\n    for(ll i=0;i<n;i++) scanf(\"%lld%lld\",&l[i],&r[i]);\n    for(ll i=0;i<n-1;i++) p[i]=l[i]-r[i+1],q[i]=r[i]-l[i+1];\n    lg.push(-INF),lg.push(0),rg.push(0),rg.push(-INF);\n    for(ll i=0;i<n-1;i++){\n        ladd+=p[i],radd+=q[i];\n        if(lg.top()+ladd>0) {\n            ans+=abs(lg.top()+ladd);\n            lg.push(-ladd),lg.push(-ladd);\n        }\n        else if(-rg.top()+radd<0) {\n            ans+=abs(-rg.top()+radd);\n            rg.push(radd),rg.push(radd);\n        }\n        else lg.push(-ladd),rg.push(radd);\n        if(lg.size()>rg.size()) {\n            ll val=lg.top()+ladd;\n            rg.push(-val+radd),lg.pop();\n        }\n        else if(rg.size()>lg.size()) {\n            ll val=-rg.top()+radd;\n            lg.push(val-ladd),rg.pop();\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tint len=r[1]-l[1];\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[i]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx;j++){\n\t\t\tf[i][j]=100000000;\n\t\t\tfor(int k=max(1,j-len-len_);k<=min(mx,j+len);k++){\n\t\t\t\tif(k>j)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-k)));\n\t\t\t\telse f[i][j]=min(f[i][j],f[i-1][k]+min(abs(r[i]-j),abs(l[i]-(k+len_))));\n\t\t\t}\n\t\t}\n\t}\n\tans=100000000;\n\tfor(int j=1;j<=mx;j++)ans=min(ans,f[n][j]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint l[405], r[405];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) cin >> l[i] >> r[i];\n  if(n > 400) assert(false);\n  ll ret = INF;\n  REP(i, n) {\n    ll tmp = 0;\n    REP(j, n) {\n      if(j == i) continue;\n      if((l[j] >= r[i] && l[j] <= l[i]) || (r[j] >= l[i] && r[j] <= r[i]))\n        continue;\n      tmp += min(abs(l[j]-r[i]), abs(l[i]-r[j]));\n    }\n    ret = min(ret, tmp);\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nint64 l[MAXN],r[MAXN];\nmultiset<int64> Lb,Rb;\nint64 c,d[2];\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(l[i]);read(r[i]);\n    }\n    Lb.insert(l[1]);Rb.insert(l[1]);c = 0;\n    for(int i = 2 ; i <= N ; ++i) {\n        d[0] -= r[i] - l[i];d[1] += r[i - 1] - l[i - 1];\n        int64 a = *(--Lb.end()) + d[0],b = *(Rb.begin()) + d[1];\n        if(l[i] < a) {\n            c += abs(a - l[i]);\n            Lb.erase(Lb.find(a - d[0]));Rb.insert(a - d[1]);\n            Lb.insert(l[i] - d[0]);Lb.insert(l[i] - d[0]);\n        }\n        else if(l[i] > b){\n            c += abs(b - l[i]);\n            Rb.erase(Rb.find(b - d[1]));Lb.insert(b - d[0]);\n            Rb.insert(l[i] - d[1]);Rb.insert(l[i] - d[1]);\n        }\n        else {\n            Lb.insert(l[i] - d[0]);Rb.insert(l[i] - d[1]);\n        }\n    }\n    out(c);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n#define LL long long\n#define mp make_pair\n#define fr first\n#define sc second\n#define pb push_back\n#define lc (x<<1)\n#define rc ((x<<1)|1)\nconst int M=405;\nint f[M][M],len[M],l[M];\nint wabs(int x) {if (x<0) x=-x;return x;}\nbool pan(int l1,int n1,int l2,int n2){\n    if (l1<=l2) return l1+n1>=l2;\n     else return l2+n2>=l1;\n}\nint main(){\n   // freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n    int i,j,k,n;\n    scanf(\"%d\",&n);\n    for (i=1;i<=n;i++) {int r;scanf(\"%d%d\",&l[i],&r);len[i]=r-l[i];}\n    for (j=1;j<M;j++) f[1][j]=wabs(j-l[1]);\n    for (i=2;i<=n;i++)\n     for (j=1;j<M;j++){\n            f[i][j]=n*M;\n            for (k=1;k<M;k++)\n             if (pan(j,len[i],k,len[i-1])) f[i][j]=min(f[i][j],f[i-1][k]+wabs(j-l[i]));\n     }\n    int ans=n*M;\n    for (j=1;j<M;j++) ans=min(ans,f[n][j]);\n    cout<<ans<<endl;\n  //  system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint n;\nlong long X[101000], L[101000], low;\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tint b, e, d;\n\t\tscanf(\"%d%d\", &b, &e);\n\t\td = e - b;\n\t\tX[i] = b - sum;\n\t\tsum += e - b;\n\t\tL[i] = d;\n\t}\n\tmultiset<long long>S1, S2;\n\tlong long ss = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long be, ed;\n\t\tif (i != 1) {\n\t\t\tss += L[i] + L[i - 1];\n\t\t\ted = *S2.begin();\n\t\t\tbe = *S1.rbegin() - ss;\n\t\t\tif (ed < X[i]) {\n\t\t\t\tlow += X[i] - ed;\n\t\t\t}\n\t\t\tif (X[i] < be) {\n\t\t\t\tlow += be - X[i];\n\t\t\t}\n\t\t}\n\t\tS1.insert(ss + X[i]);\n\t\tS2.insert(X[i]);\n\t\tauto it = S1.end();\n\t\tit--;\n\t\tlong long z1 = *it - ss;\n\t\tlong long z2 = *S2.begin();\n\t\tif (z1 > z2) {\n\t\t\tS1.erase(it);\n\t\t\tS2.erase(S2.begin());\n\t\t\tS1.insert(z2 + ss);\n\t\t\tS2.insert(z1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", low);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing std::priority_queue;\nusing std::vector;\nusing std::less;\nusing std::greater;\n#define r register\ninline bool isd(r char ch)\n{\n\treturn ch<='9'&&ch>='0';\n}\ntemplate<class temp>\ninline temp F()\n{\n\tr temp x=0;\n\tr bool bo=0;\n\tr char ch=getchar();\n\twhile(ch!='-'&&!isd(ch))\n\t\tch=getchar();\n\t(ch=='-')&&(bo=1,ch=getchar());\n\tx=ch^'0',ch=getchar();\n\twhile(isd(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();\n\tbo&&(x=-x);\n\treturn x;\n}\nint lt[200001],rt[200001];\nlong long ans,tl,tr,lq,rq;\npriority_queue<long long,vector<long long>,less<long long> >L; \npriority_queue<long long,vector<long long>,greater<long long> >R;\nint main()\n{\n    r int n=F<int>();\n    for(r int i=1;i<=n;++i)\n\t\tlt[i]=F<int>(),rt[i]=F<int>(),lt[i]=rt[i]-lt[i];\n    L.push(rt[1]),R.push(rt[1]);\n    for(r int i=2;i<=n;++i)\n\t{\n        tl-=lt[i-1],tr+=lt[i];\n        lq=L.top()+tl,rq=R.top()+tr;\n        if(rt[i]>=lq&&rt[i]<=rq)\n\t\t\tL.push(rt[i]-tl),R.push(rt[i]-tr);\n        else\n\t\t\tif(rt[i]>=lq)\n            \tans+=rt[i]-rq,R.pop(),L.push(rq-tl),R.push(rt[i]-tr),R.push(rt[i]-tr);\n\t\t\telse\n            \tans+=lq-rt[i],L.pop(),R.push(lq-tr),L.push(rt[i]-tl),L.push(rt[i]-tl);\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// tzl ak IOI! \n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l); i <= (r); ++i)\n#define nrof(i, r, l) for(int i = (r); i >= (l); --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\n\ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n\ntemplate <typename T>\nvoid chkmax(T &x, const T &y){ if(y > x) x = y; return; }\n\ntemplate <typename T>\nvoid chkmin(T &x, const T &y){ if(y < x) x = y; return; }\n\n#define ONLINE_JUDGE\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\n//---------------------------head----------------------------\n\nconst LL oo = 1e13;\n\nmultiset<LL> scp_l, scp_r;\nLL dl, dr, ans;\n\nvoid TZL()\n{\n\tint n; scf(n);\n\tLL l, r; scf(l, r);\n\tscp_l.insert(l); scp_r.insert(l);\n\tLL lst = r - l;\n\n\tstatic LL x[100010], y[100010];\n\tx[0] = l; y[0] = r;\n\tforn(i, 1, n - 1)\n\t{\n\t\tscf(l, r);\n\t\tLL len = r - l;\n\t\tx[i] = l; y[i] = r;\n\n\t\tdl -= len; dr += lst;\n\t\tLL lb = *scp_l.rbegin() + dl;\n\t\tLL rb = *scp_r.begin() + dr;\n\n\t\tif(lb <= l && l <= rb)\n\t\t{\n\t\t\tscp_l.insert(l - dl);\n\t\t\tscp_r.insert(l - dr);\n\t\t}\n\t\telse if(l < lb)\n\t\t{\n\t\t\tscp_l.insert(l - dl);\n\t\t\tscp_l.insert(l - dl);\n\n\t\t\tLL foo = *scp_l.rbegin() + dl;\n\t\t\tscp_l.erase(scp_l.find(foo - dl));\n\t\t\tscp_r.insert(foo - dr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscp_r.insert(r - dr);\n\t\t\tscp_r.insert(r - dr);\n\n\t\t\tLL foo = *scp_r.begin() + dr;\n\t\t\tscp_r.erase(scp_r.begin());\n\t\t\tscp_l.insert(foo - dl);\n\t\t}\n\n\t\tlst = len;\n\t}\n\n\tLL cur_pos = -oo;\n\tper(i, n)\n\t{\n\t\tans += x[i] - cur_pos;\n\t\tcur_pos += y[i] - x[i];\n\t}\n\treturn;\n}\n\nvoid RANK1()\n{\n\tLL lst_pos = -oo, slope = -(LL)SZ(scp_l);\n\tfor(LL x: scp_l)\n\t{\n\t\tLL y = x + dl;\n\t\tans += (y - lst_pos) * slope;\n\t\tdebug(ans, '\\n')\n\t\tslope++;\n\t\tlst_pos = y;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn;\n}\n\n#define tzl int\n#define ak main\n#define IOI ()\ntzl ak IOI\n{\n#undef tzl\n#undef ak\n#undef IOI\n\n\tTZL();\n\tRANK1();\n\n#define tzl return\n#define caisi 0\n#define myy ;\n\ttzl caisi myy\n#undef tzl\n#undef caisi\n#undef myy\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst long long LL_INF = (long long) 2e18 + 5;\n\nstruct convex_piecewise_linear {\n    priority_queue<long long> negatives;\n    priority_queue<long long, vector<long long>, greater<long long>> positives;\n    long long negative_offset, positive_offset;\n    long long zero_y;\n\n    convex_piecewise_linear() {\n        negatives = {};\n        positives = {};\n        negatives.push(-LL_INF);\n        positives.push(LL_INF);\n        negative_offset = positive_offset = zero_y = 0;\n    }\n\n    void add_shift(long long left, long long right) {\n        negative_offset -= left;\n        positive_offset += right;\n    }\n\n    void add_abs(long long center) {\n        long long left = negatives.top() + negative_offset;\n        long long right = positives.top() + positive_offset;\n        assert(left <= right);\n\n        if (left <= center && center <= right) {\n            negatives.push(center - negative_offset);\n            positives.push(center - positive_offset);\n            return;\n        }\n\n        if (center < left) {\n            negatives.push(center - negative_offset);\n            negatives.push(center - negative_offset);\n            long long move = negatives.top() + negative_offset; negatives.pop();\n            zero_y += move - center;\n            positives.push(move - positive_offset);\n        } else {\n            assert(center > right);\n            positives.push(center - positive_offset);\n            positives.push(center - positive_offset);\n            long long move = positives.top() + positive_offset; positives.pop();\n            zero_y += center - move;\n            negatives.push(move - negative_offset);\n        }\n    }\n\n    void print() {\n        auto negatives_copy = negatives;\n        auto positives_copy = positives;\n\n        cerr << \"Negatives:\";\n\n        while (!negatives_copy.empty()) {\n            cerr << ' ' << negatives_copy.top() + negative_offset;\n            negatives_copy.pop();\n        }\n\n        cerr << endl;\n        cerr << \"Positives:\";\n\n        while (!positives_copy.empty()) {\n            cerr << ' ' << positives_copy.top() + positive_offset;\n            positives_copy.pop();\n        }\n\n        cerr << endl;\n        cerr << \"Zero y: \" << zero_y << endl;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    convex_piecewise_linear DS;\n    long long prev_L, prev_R;\n\n    for (int i = 0; i < N; i++) {\n        long long L, R;\n        cin >> L >> R;\n        // cerr << L << ' ' << R << endl;\n\n        if (i > 0)\n            DS.add_shift(R - L, prev_R - prev_L);\n\n        // DS.print();\n        DS.add_abs(L);\n        prev_L = L;\n        prev_R = R;\n        // DS.print();\n    }\n\n    cout << DS.zero_y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INT long long\n#define ED 20\nusing namespace std;\n\nint n, dt[440][440], l[440], r[440], ans = 1987654321;\n\nint main()\n{\n    cin>>n;\n    memset(dt, 0x3f, sizeof(dt));\n    for(int i = 0 ; i < n ; i++ ) cin>>l[i]>>r[i];\n    for(int i = 0 ; i < n ; i++ ) for(int j = 1 ; j <= ED-l[i] ; j++ )\n    {\n        if( i == 0 ) dt[i][j] = abs(j-l[i]);\n        else for(int k = max(1, j-(r[i-1]-l[i-1])) ; k <= min(j+(r[i]-l[i]), k+((r[i-1]-l[i-1]))) ; k++ )\n        {\n            dt[i][j] = min(dt[i][j], dt[i-1][k] + abs(j-l[i]) );\n        }\n    }\n\n    //for(int i = 0 ; i < n ; i++, cout<<endl ) for(int j = 1 ; j <= ED ; j++ ) cout<<dt[i][j]<<\" \";\n\n    for(int i = 1 ; i <= ED ; i++ ) ans = min( ans , dt[n-1][i] );\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll l[100001],r[100001];\nmultiset<ll> dpl,dpr;\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&l[i],&r[i]);\n\t}\n\tdpl.insert(-1LL<<60);\n\tdpr.insert(1LL<<60);\n\tll ofl=0,ofr=0;\n\tll res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(i>0){\n\t\t\tofl-=r[i]-l[i];\n\t\t\tofr+=r[i-1]-l[i-1];\n\t\t}\n\t\tif(l[i]<*dpl.rbegin()+ofl){\n\t\t\tres+=*dpl.rbegin()+ofl-l[i];\n\t\t}else if(*dpr.begin()+ofr<l[i]){\n\t\t\tres+=l[i]-(*dpr.begin()+ofr);\n\t\t}\n\t\tif(l[i]<*dpl.rbegin()+ofl){\n\t\t\tdpr.insert(*dpl.rbegin()+ofl-ofr);\n\t\t\tdpl.insert(l[i]-ofl);\n\t\t\tdpl.insert(l[i]-ofl);\n\t\t\tdpl.erase(dpl.find(*dpl.rbegin()));\n\t\t}else if(*dpr.begin()+ofr<l[i]){\n\t\t\tdpl.insert(*dpr.begin()+ofr-ofl);\n\t\t\tdpr.insert(l[i]-ofr);\n\t\t\tdpr.insert(l[i]-ofr);\n\t\t\tdpr.erase(dpr.begin());\n\t\t}else{\n\t\t\tdpl.insert(l[i]-ofl);\n\t\t\tdpr.insert(l[i]-ofr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 100010;\n\nint l[maxn], len[maxn];\n\nll ladd, radd, mini;\n\nmultiset<int> lt, rt;\n\nvoid add(int p) {\n\tladd -= len[p];\n\tradd += len[p-1];\n\n\tif (*lt.rbegin() + ladd > l[p]) {\n\t\tlt.insert(l[p] - ladd); lt.insert(l[p] - ladd);\n\t\tmini += abs(l[p] - (*lt.rbegin() + ladd));\n\t\tauto it = --lt.end();\n\t\trt.insert(*it + ladd - radd);\n\t\tlt.erase(it);\n\t} else if (*rt.begin() + radd < l[p]) {\n\t\trt.insert(l[p] - radd); rt.insert(l[p] - radd);\n\t\tmini += abs(l[p] - (*rt.begin() + radd));\n\t\tauto it = rt.begin();\n\t\tlt.insert(*it + radd - ladd);\n\t\trt.erase(it);\n\t} else { //between\n\t\tlt.insert(l[p] - ladd); rt.insert(l[p] - radd);\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N) {\n\t\tint p, q;\n\t\tcin >> p >> q;\n\t\tl[i] = p;\n\t\tlen[i] = q - p;\n\t}\n\n\tlt.insert(l[0]); rt.insert(l[0]);\n\n\tfor (int i = 1; i < N; ++i) {\n\t\tadd(i);\n\t}\n\n\tcout << mini << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + ofL;\n\t\tret += (temp - L);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + ofR;\n\t\tret += (L - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tmultiset<LL>::iterator Left,Right;\n\t\tLeft = LS.end();\n\t\tLeft--;\n\t\tRight = RS.begin();\n\t\t/*\n\t\tif( L < *Left + ofL ){\n\t\t\tLL temp = *Left + ofL;\n\t\t\tret += (temp - L);\n\t\t\n\t\t\tRS.insert( temp - ofR );\n\n\t\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\t\tLS.insert( L - ofR );\n\t\t\tLS.insert( L - ofR );\n\t\t}else if( *Right + ofR < L ){\n\t\t\tLL temp = *Right + ofR;\n\t\t\tret += (L - temp);\n\n\t\t\tRS.erase( Right );\n\t\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\t\tLS.insert( temp - ofL );\n\t\t}\n\t\t*/\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tadd2init();\n\taddABSfunc2(0,0,L[0]);\n\tfor(int i=1;i<N;++i){\n\t\taddABSfunc2(R[i]-L[i],R[i-1]-L[i-1],L[i]);\n\t}\n\tcout << ret2 << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve2();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\n\nint main() {\n    int n;\n    cin >> n;\n    VI l(n), r(n);\n    REP(i,n) scanf(\"%d %d\", &l[i], &r[i]);\n    int m = 401;\n    VVI dp(n, VI(m, INF));\n    REP(i,n){\n        if (i == 0){\n            REP(j,m) dp[i][j] = abs(j-l[i]);\n            continue;\n        }\n        REP(j,m){\n            int x = r[i] - l[i], y = r[i-1] - l[i-1];\n            REP(k,m){\n                if ((j >= k && j <= k+y) || (j+x >= k && j+x <= k+y)){\n                    dp[i][j] = min(dp[i][j], dp[i-1][k] + abs(j-l[i]));\n                }\n            }\n        }\n    }\n    int ans = INF;\n    REP(j,m) ans = min(ans, dp[n-1][j]);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\n\n\nint n;\nint a[MAXN],b[MAXN];\n\n\n\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) scanf(\"%d%d\",&a[i],&b[i]);\n\n\tmap<ll,int> L,R; ll dl=a[0],dr=a[0]; L[0]=+1; R[0]=+1; ll ret=0;\n\tFOR(i,1,n) {\n\t\tdl-=b[i]-a[i]; dr+=b[i-1]-a[i-1];\n\t\tll lmx; { map<ll,int>::iterator it=L.end(); assert(it!=L.begin()); --it; lmx=dl+it->first; }\n\t\tll rmn; { map<ll,int>::iterator it=R.begin(); assert(it!=R.end()); rmn=dr+it->first; }\n\t\tif(a[i]<lmx) {\n\t\t\tret+=lmx-a[i];\n\t\t\tL[a[i]-dl]+=2;\n\t\t\tmap<ll,int>::iterator it=L.end(); assert(it!=L.begin()); --it; assert(lmx==dl+it->first);\n\t\t\t--it->second; if(it->second==0) L.erase(it);\n\t\t\tR[lmx-dr]++;\n\t\t} else if(a[i]>rmn) {\n\t\t\tret+=a[i]-rmn;\n\t\t\tR[a[i]-dr]+=2;\n\t\t\tmap<ll,int>::iterator it=R.begin(); assert(it!=R.end()); rmn=dr+it->first; assert(rmn==dr+it->first);\n\t\t\t--it->second; if(it->second==0) R.erase(it);\n\t\t\tL[rmn-dl]++;\n\t\t} else {\n\t\t\tL[a[i]-dl]++;\n\t\t\tR[a[i]-dr]++;\n\t\t}\n\t\t//printf(\"ret=%lld\\n\",ret);\n\t\t//printf(\"L:\"); for(map<ll,int>::iterator it=L.begin();it!=L.end();++it) printf(\" %lld:%d\",dl+it->first,it->second); puts(\"\");\n\t\t//printf(\"R:\"); for(map<ll,int>::iterator it=R.begin();it!=R.end();++it) printf(\" %lld:%d\",dr+it->first,it->second); puts(\"\");\n\t}\n\tprintf(\"%lld\\n\",cur);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int NMAX = 1e5 + 5;\n\nint N;\nint lft[NMAX], rgt[NMAX];\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i <= N; i++) scanf(\"%d%d\", &lft[i], &rgt[i]);\n\n    LL ans = 1LL << 60;\n    for(int i = 1; i <= N; i++)\n    {\n        LL cnt = 0LL;\n        int st, dr;\n\n        st = lft[i], dr = rgt[i];\n        for(int j = i - 1; j >= 1; j--)\n        {\n            if( (st <= lft[j] && lft[j] <= dr) || (lft[j] <= st && st <= rgt[j]) )  { st = lft[j]; dr = rgt[j]; continue; }\n            if(rgt[j] < st)\n            {\n                cnt += st - rgt[j];\n                dr = st;\n                st = lft[j] + (st - rgt[j]);\n            }\n            else if(dr < lft[j])\n            {\n                cnt += lft[j] - dr;\n                st = dr;\n                dr = rgt[j] - (lft[j] - dr);\n            }\n        }\n\n        st = lft[i], dr = rgt[i];\n        for(int j = i + 1; j <= N; j++)\n        {\n            if( (st <= lft[j] && lft[j] <= dr) || (lft[j] <= st && st <= rgt[j]) )  { st = lft[j]; dr = rgt[j]; continue; }\n            if(rgt[j] < st)\n            {\n                cnt += st - rgt[j];\n                dr = st;\n                st = lft[j] + (st - rgt[j]);\n            }\n            else if(dr < lft[j])\n            {\n                cnt += lft[j] - dr;\n                st = dr;\n                dr = rgt[j] - (lft[j] - dr);\n            }\n        }\n\n        ans = min(ans, cnt);\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define len(x)  (int((x).size()))\n#define append push_back\n#define pp make_pair\n#define ff(a, b)    for (int a = 0; a < int(b); ++a)\n#define kk(n)    ff(k, n)\n#define xx(n)    ff(x, n)\n#define yy(n)    ff(y, n)\n#define ii(n)    ff(i, n)\n#define fff(a, b, c) for (int a = int(b); a < int(c); ++a)\n#define kkk(a, b) fff(k, a, b)\n#define xxx(a, b) fff(x, a, b)\n#define yyy(a, b) fff(y, a, b)\n#define iii(a, b) fff(i, a, b)\n#define bb begin()\n#define ee end()\n#define uu first\n#define vv second\n#define all(x)  (x).bb, (x).ee\n#define ite(v)   decltype((v).bb)\n#define fe(i, v) for(ite(v) i = (v).bb; i != (v).ee; ++i)\n#define err(...)    { fprintf(stderr, __VA_ARGS__); fflush(stderr); }\n#define zz(array, byte)   memset(array, byte, sizeof(array));\n\nusing LL = long long;\nusing DD = long double;\nusing pii = pair<int, int>;\n\n\nconst LL  INFLL  = 0x7f7f7f7f7f7f7f7fLL;\nconst int INFint = 0x7f7f7f7f;  //Works with memset(..).\n   \n\n\n\n\nint main() {\n    //ios_base::sync_with_stdio(false);     cin.tie(NULL);\n    //cout << '\\n';     //Avoid flushing with endl.\n    cout.precision(16);\n\n\n    int N;\n    cin >> N;\n    \n    vector<int> prev(500, 0);\n    int pwidth = 1;\n    ii (N) {\n        int left, right;\n        cin >> left >> right;\n\n        vector<int> here(500, 0);\n        int whole_width = right - left + pwidth;\n        deque<int> minq;\n        xx (len(prev)+pwidth) {\n            while (len(minq) >= 1 && minq.front() < x-whole_width)\n                minq.pop_front();\n            if (x < len(prev)) {\n                int c = prev[x];\n                while (len(minq) >= 1 && prev[minq.back()] >= c)\n                    minq.pop_back();\n                minq.push_back(x);\n                }\n\n            int y = x - pwidth;\n            if (0 <= y && y < len(here)) {\n                here[y] = prev[minq.front()];\n                if (y < left)\n                    here[y] += abs(left - y);\n                else if (right < y)\n                    here[y] += abs(y - right);\n            }\n        }\n        pwidth = right - left;\n        swap(prev, here);\n\n    }\n    int rr = INFint;\n    ii (len(prev)) {\n        rr = min(rr, prev[i]);\n    }\n    cout << rr << '\\n';\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n, l, r, c;\npriority_queue<ll> pql;\npriority_queue<ll, vector<ll>, greater<ll>> pqr;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\tcin >> n >> l >> r;\n\tpql.push(l); pqr.push(l); c = 0;\n\n\tll decL = 0, incR = 0;\n\tll lastsz = 0, cursz = r-l+1, ans = 0;\n\tfor(int i = 0; i < n-1; i++) {\n\t\tcin >> l >> r;\n\t\tlastsz = cursz; cursz = r-l+1;\n\n\t\tdecL -= cursz - 1;\n\t\tincR += lastsz - 1;\n\n\t\tif(l <= pql.top() + decL) {\n\t\t\tll x = pql.top() + decL;\n\t\t\tans += x - l;\n\t\t\tpql.push(l - decL);\n\t\t\tpql.push(l - decL);\n\t\t\tpql.pop();\n\t\t\tpqr.push(x - incR);\n\t\t} else if(l >= pqr.top() + incR) {\n\t\t\tll x = pqr.top() + incR;\n\t\t\tans += l - x;\n\t\t\tpqr.push(l - incR);\n\t\t\tpqr.push(l - incR);\n\t\t\tpqr.pop();\n\t\t\tpql.push(x - decL);\n\t\t} else {\n\t\t\tpql.push(l - decL);\n\t\t\tpqr.push(r - incR);\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define pii Pi\n#define pll PL\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> PL;\ntypedef long double ldouble;\n\nconst int inf = 1e9;\n\nvector <ll> V;\n\nstruct node{\n\tnode(){add = val = 0, cnt = 1; child[0] = child[1] = par = 0;}\n\tnode(int x){\n\t\tadd = 0, val = x, cnt = 1, child[0] = child[1] = par = 0;\n\t}\n\tint cnt;\n\tll add, val;\n\tnode *child[2], *par;\n\tinline int mydir(){\n\t\treturn par->child[0] != this;\n\t}\n\tvoid pushdown(){\n\t\tif(add){\n\t\t\tif(child[0])child[0]->add += add, child[0]->val += add;\n\t\t\tif(child[1])child[1]->add += add, child[1]->val += add;\n\t\t\tadd = 0;\n\t\t}\n\t}\n\tvoid pushup(){\n\t\tcnt = 1 + (child[0] ? child[0]->cnt : 0) + (child[1] ? child[1]->cnt : 0);\n\t}\n\tinline void Ins(int dir, int x){\n\t\tchild[dir] = new node(x);\n\t\tchild[dir]->par = this;\n\t\tpushup();\n\t}\n\tvoid *rotate(int dir){\n\t\tnode *tmp = child[!dir];\n\t\tpushdown();\n\t\ttmp->pushdown();\n\t\ttmp->par = par;\n\t\tif(par)par->child[mydir()] = tmp;\n\t\tchild[!dir] = tmp->child[dir];\n\t\tif(tmp->child[dir])tmp->child[dir]->par = this;\n\t\ttmp->child[dir] = this;\n\t\tpar = tmp;\n\t\tpushup();\n\t\ttmp->pushup();\n\t\treturn tmp;\n\t}\n\tvoid splay(node *rootp){\n\t\twhile(par != rootp){\n\t\t\tint myd = mydir();\n\t\t\tif(par->par == rootp){\n\t\t\t\tpar->rotate(!myd);\n\t\t\t}\n\t\t\telse if(myd == par->mydir()){\n\t\t\t\tpar->par->rotate(!myd);\n\t\t\t\tpar->rotate(!myd);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar->rotate(!myd);\n\t\t\t\tpar->rotate(myd);\n\t\t\t}\n\t\t}\n\t}\n\tnode *kth_node(int k){\n\t\tpushdown();\n\t\tint c = (child[0] ? child[0] -> cnt : 0);\n\t\tif(c+1 == k)return this;\n\t\telse if(c+1 < k){\n\t\t\tk -= c+1;\n\t\t\treturn child[1]->kth_node(k);\n\t\t}\n\t\telse{\n\t\t\treturn child[0]->kth_node(k);\n\t\t}\n\t}\n\tvoid travel(){\n\t\tpushdown();\n\t\tif(child[0])child[0]->travel();\n\t\tV.pb(val);\n\t\t//printf(\"%lld \", val);\n\t\tif(child[1])child[1]->travel();\n\t}\n\tnode *Insert(int x){\n\t\tpushdown();\n\t\tif(val >= x){\n\t\t\tif(!child[0]){ Ins(0, x); return child[0]; }\n\t\t\telse{\n\t\t\t\tauto res = child[0]->Insert(x);\n\t\t\t\tpushup();\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!child[1]){ Ins(1, x); return child[1]; }\n\t\t\telse{\n\t\t\t\tauto res = child[1]->Insert(x);\n\t\t\t\tpushup();\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct splaytree{\n\tsplaytree(int x){\n\t\troot = new node(x);\n\t\troot->Ins(1, x);\n\t\troot->pushup();\n\t\tC = 2;\n\t}\n\tint C;\n\tnode *root;\n\tvoid travel(){\n\t\troot->travel(); //puts(\"\");\n\t}\n\tnode *kth_splay(int k, node *rootp){\n\t\tnode *tmp = root->kth_node(k);\n\t\ttmp->splay(rootp);\n\t\treturn tmp;\n\t}\n\tvoid query(int ls, int rs){\n\t\tauto p = kth_splay(C / 2, 0);\n\t\troot = p;\n\t\tp->val -= ls;\n\t\tif(p->child[0])p->child[0]->val -= ls, p->child[0]->add -= ls;\n\t\tif(p->child[1])p->child[1]->val += rs, p->child[1]->add += rs;\n\t}\n\tvoid Insert(int x){\n\t\tauto p = root->Insert(x);\n\t\tp->splay(0); root = p;\n\t\tp = root->Insert(x);\n\t\tp->splay(0); root = p;\n\t\tC += 2;\n\t}\n}*ST;\n\nint L[100010], R[100010];\n\n//#define __int128 long long\n\nvoid solve(){\n\tint N; scanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)scanf(\"%d%d\", L+i, R+i), R[i] -= L[i];\n\tST = new splaytree(L[1]);\n\tll T = -2000000000000000LL;\n\t__int128 F = -T + L[1];\n\tfor(int i=2;i<=N;i++){\n\t\tST->query(R[i], R[i-1]);\n\t\tF -= (__int128) R[i] * (i-1);\n\t\tST->Insert(L[i]);\n\t\tF += (-T + L[i]);\n\t\t//ST->travel();\n\t}\n\tV.pb(T);\n\tST->travel();\n\t__int128 now = F;\n\t__int128 ans = F;\n\tfor(int i=1;i<sz(V);i++){\n\t\tint a = i - N - 1;\n\t\tnow += (V[i] - V[i-1]) * a;\n\t\tans = min(ans, now);\n\t}\n\t//printf(\"%lld\\n\", ans);\n\tstring s;\n\twhile(ans)s.pb(ans % 10 + '0'), ans /= 10;\n\treverse(all(s));\n\tprintf(\"%s\\n\", s.c_str());\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> P;\npriority_queue <ll,vector <ll>,greater <ll> > Q;\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint main() {\n    int n;\n    ll A=0,B=0,ans=0;\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n\tint l=gi(),r=gi();\n\tB+=r-l;\n\tP.push(r-A),Q.push(r-B);\n\twhile(P.size()&&P.top()+A>Q.top()+B)\n\t    ans+=P.top()+A-Q.top()+B,P.pop(),Q.pop();\n\tA-=r-l;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nint dp[410][410];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<PII> xs(N);\n  VI ws(N);\n  REP(i,N){\n\tcin >> xs[i];\n\tws[i] = xs[i].SS - xs[i].FF;\n  }\n\n  fill((int*)dp, (int*)dp+410*410, INF);\n  REP(x,401)\n\tdp[0][x] = abs(x - xs[0].FF);\n\n  FOR(i,1,N){\n\tREP(x,401){\n\t  REP(px, 401){\n\t\tif(x + ws[i] < px || px+ws[i-1] < x) continue;\n\t\tmini(dp[i][x], abs(x - xs[i].FF) + dp[i-1][px]);\n\t  }\n\t}\n  }\n\n  cout << *min_element(ALL(dp[N-1])) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\npriority_queue <ll> pqlo;\npriority_queue <ll, vector<ll>, greater<ll> > pqup;\n\nll N, l, r, lazylo, lazyhi, ans;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> l >> r;\n\t\tif (i == 1) {\n\t\t\tpqup.push(l);\n\t\t\tpqlo.push(l);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tll panjang = r-l;\n\t\tlazylo -= panjang;\n\t\tlazyhi += panjang;\n\t\t\n\t\tif (l <= pqlo.top()+lazylo) {\n\t\t\tll geser = pqlo.top()+lazylo;\n\t\t\tans += geser-l;\n\t\t\tpqlo.push(l-lazylo);\n\t\t\tpqlo.push(l-lazylo);\n\t\t\tpqlo.pop();\n\t\t\tpqup.push(geser-lazyhi);\n\t\t} else if (l >= pqup.top()+lazyhi) {\n\t\t\tll geser = pqup.top()+lazyhi;\n\t\t\tans += l-geser;\n\t\t\tpqup.push(l-lazyhi);\n\t\t\tpqup.push(l-lazyhi);\n\t\t\tpqup.pop();\n\t\t\tpqlo.push(geser-lazylo);\n\t\t} else {\n\t\t\tpqlo.push(l-lazylo);\n\t\t\tpqup.push(l-lazyhi);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nbool isSame(int bl, int br, int al, int ar) {\n    return ((al <= bl && bl <= ar) || (al <= br && br <= ar));\n}\n\nint main () {\n    int N;\n    cin >> N;\n    vector<int> l(N);\n    vector<int> r(N);\n    int lmin = 1 << 30, rmax = 0;\n    REP (i, 0, N) cin >> l[i] >> r[i];\n    REP (i, 0, N) {\n        lmin = min(lmin, l[i]);\n        rmax = max(rmax, r[i]);\n    }\n\n    if (rmax > 400 || N > 400) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<vector<int>> check(N, vector<int>(rmax + 1, 1 << 30));\n\n    REP (i, 0, rmax + 1) {\n        check[0][i] = abs(r[0] - i);\n    }\n\n    REP (i, 1, N) {\n        REP (j, 0, check[i].size()) {\n            REP (k, 0, check[i - 1].size()) {\n                int nl = j - (r[i] - l[i]), bl = k - (r[i - 1] - l[i - 1]);\n                if (bl >= 0 && nl >= 0 && (isSame(bl, k, nl, j) || isSame(nl, j, bl, k))) {\n                    check[i][j] = min(check[i][j], check[i - 1][k] + abs(r[i] - j));\n//                    cout << i << ' ' << j << ' ' << k << ' ' << nl << ' ' << bl << ' ' << check[i][j] << endl;\n\n                }\n            }\n        }\n    }\n\n    int ans = 1 << 30;\n    REP (i, 0, check[N - 1].size()) {\n        ans = min(check[N - 1][i], ans);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 410;\nint n;\nint l[maxn] , r[maxn];\nint dp[maxn][maxn];\nint ans;\nvoid work () {\n\tint i , j , k;\n\tscanf ( \"%d\" , &n );\n\tfor ( i = 1 ; i <= n ; i++ ) scanf ( \"%d%d\" , &l[i] , &r[i] );\n\tfor ( i = 1 ; i <= 400 ; i++ ) dp[1][i] = abs ( l[1] - i );\n\tfor ( i = 2 ; i <= n ; i++ ) for ( j = 1 ; j <= 400 ; j++ ) {\n\t\tdp[i][j] = 99999999;\n\t\tfor ( k = max ( j - (r[i]-l[i]) , 1 ) ; k <= min ( j + (r[i]-l[i]+1) , 400 ) ; k++ ) {\n\t\t\tdp[i][j] = min ( dp[i][j] , dp[i-1][k] );\n\t\t}\n\t\tdp[i][j] += abs ( l[i] - j );\n\t\t//printf ( \"%d %d %d\\n\" , i , j , dp[i][j] );\n\t}\n\tans = dp[n][1];\n\tfor ( i = 1 ; i <= 400 ; i++ ) ans = min ( ans , dp[n][i] );\n\tprintf ( \"%d\\n\" , ans );\n}\nint main () {\n\twork ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tint len=r[1]-l[1];\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[i]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx;j++){\n\t\t\tf[i][j]=100000000;\n\t\t\tfor(int k=max(1,j-len-len_);k<=min(mx,j+len);k++){\n\t\t\t\tif(k>j)f[i][j]=min(f[i][j],f[i-1][k]+min(abs(l[i]-j),abs(r[i]-l[i-1])));\n\t\t\t\telse f[i][j]=min(f[i][j],f[i-1][k]+min(abs(r[i]-j),abs(l[i]-r[i-1])));\n\t\t\t}\n\t\t}\n\t}\n\tans=100000000;\n\tfor(int j=1;j<=mx;j++)ans=min(ans,f[n][j]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=1;i<=n;i++)\n#define fs first\n#define sc second\n#define MAXN 1000005\n#define LIMIT 1500\n#define LOGN 22\n#define MOD 1000000009\n#define pb push_back\n#define ll long long\n#define lc 2*pos\n#define rc 2*pos+1\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    int n;\n    ll l,r,ans=0;\n    priority_queue<ll>lo;\n    priority_queue<ll,vector<ll>,greater<ll>>hi;\n    ll lazyLo=0,lazyHi=0;\n    cin>>n;\n    n--;\n    cin>>l>>r;\n    hi.push(l),lo.push(l);\n    while(n){\n        n--;\n        lazyHi+=r-l;\n        cin>>l>>r;\n        lazyLo-=r-l;\n        if(l>=hi.top()+lazyHi){\n            ll shifted=hi.top()+lazyHi;\n            ans+=l-shifted;\n            hi.push(l-lazyHi);\n            hi.push(l-lazyHi);\n            hi.pop();\n            lo.push(shifted-lazyLo);\n        }else if(l<=lo.top()+lazyLo){\n            ll shifted=lo.top()+lazyLo;\n            ans+=shifted-l;\n            lo.push(l-lazyLo);\n            lo.push(l-lazyLo);\n            lo.pop();\n            hi.push(shifted-lazyHi);\n        }else{\n            hi.push(l-lazyHi);\n            lo.push(l-lazyLo);\n        }\n        //cout<<ans<<endl;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int MAX_N = 100000, MAX_X = 400;\nint N;\nll l[MAX_N], r[MAX_N];\nll dp[MAX_N][MAX_X+1];\n\nint main() {\n  cin >> N;\n  rep(i,N) cin >> l[i] >> r[i];\n\n  for (int x = 1; x <= MAX_X; ++x) dp[0][x] = abs(l[0]-x);\n  for (int i = 1; i < N; ++i) {\n    for (int x = 1; x <= MAX_X; ++x) {\n      ll tmp = 1e18;\n      for (int t = x-(r[i-1]-l[i-1]); t <= x+r[i]; ++t) {\n        if (t < 1 || t > MAX_X) continue;\n        tmp = min(tmp, dp[i-1][t] + abs(l[i]-x));\n      }\n      dp[i][x] = tmp;\n    }\n  }\n\n  ll ans = 1e18;\n  for (int x = 1; x <= MAX_X; ++x) {\n    ans = min(ans, dp[N-1][x]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define PII pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define sci(x) scanf(\"%d\",&x)\n#define scs(s) scanf(\"%s\",s)\n#define scc(c) scanf(\"%c\",c)\n#define scd(d) scanf(\"%lf\",&d)\n#define scld(ld) scanf(\"%Lf\",&ld)\nusing namespace std;\n\n//********************************************\n//Error tracking\n#define show(args...) { vector<string> _v = split(#args, ','); err(_v.begin(), args); }\n\nvector<string> split(const string& s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while (getline(ss, x, c))\n        v.emplace_back(x);\n    return move(v);\n}\n\nvoid err(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args>\nvoid err(vector<string>::iterator it, T a, Args... args) {\n    cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << '\\n';\n    err(++it, args...);\n}\n//********************************************\n\nconst int NMAX = 405;\n\nint n, l[NMAX], r[NMAX];\nint dp[NMAX][NMAX];\n\nvoid MakeDp()\n{\n    int i, j;\n\n    l[0] = 0; r[0] = NMAX;\n    for (i = 1; i <= n; i++)\n        for (j = 0; j < NMAX; j++)\n        {\n            int val = abs(l[i] - j);\n            int mn = 1 << 30;\n            int size_prev = r[i - 1] - l[i - 1] + 1;\n            int size = r[i] - l[i] + 1;\n            int st = max(0, j - size_prev + 1), dr = min(NMAX - 1, j + size - 1);\n\n            for (int l = st; l <= dr; l++) mn = min(mn, dp[i - 1][l]);\n            \n            dp[i][j] = val + mn;\n        }\n}\n\nint main()\n{\n  //  freopen(\"input\",\"r\",stdin);\n   // freopen(\"output\",\"w\",stdout);\n    cin.sync_with_stdio(false);\n    \n    int i;\n    cin >> n;\n    for (i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\n    MakeDp();\n\n    int sol = 1 << 30;\n    for (i = 0; i < NMAX; i++) sol = min(sol, dp[n][i]);\n\n    cout << sol << \"\\n\";\n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n#define LL long long\n#define mp make_pair\n#define fr first\n#define sc second\n#define pb push_back\n#define lc (x<<1)\n#define rc ((x<<1)|1)\nconst int M=405;\nint f[M][M],len[M],l[M];\nint wabs(int x) {if (x<0) x=-x;return x;}\nbool pan(int l1,int n1,int l2,int n2){\n    if (l1<=l2) return l1+n1>=l2;\n     else return l2+n2>=l1;\n}\nint main(){\n   // freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n    int i,j,k,n;\n    scanf(\"%d\",&n);\n    for (i=1;i<=n;i++) {int r;scanf(\"%d%d\",&l[i],&r);len[i]=r-l[i];}\n    for (j=0;j<=M;j++) f[1][j]=wabs(j-l[1]);\n    for (i=2;i<=n;i++)\n     for (j=0;j<=M;j++){\n            f[i][j]=n*M;\n            for (k=0;k<=M;k++)\n             if (pan(j,len[i],k,len[i-1])) f[i][j]=min(f[i][j],f[i-1][k]+wabs(j-l[i]));\n     }\n    int ans=n*M;\n    for (j=0;j<=M;j++) ans=min(ans,f[n][j]);\n    cout<<ans<<endl;\n  //  system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <string.h>\n#include <memory.h>\n#include <stdio.h>\n#include <complex>\n#include <cstdlib>\n#include <sstream>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include<deque>\ntypedef long long ll;\nusing namespace std;\nconst int N = 1000 ;\nint n;\nint l[N], r[N];\nll dp[N][N];\nll calc(int idx, int s) {\n\tif(idx == n)\n\t\treturn 0;\n\tll &ret = dp[idx][s];\n\tif (ret != -1)\n\t\treturn ret;\n\tint len = (r[idx] - l[idx] + 1);\n\tint e = min(400 - len, s + (r[idx - 1] - l[idx - 1]));\n\tret = 1e15;\n\tfor (int i = max(1,s-len+1); i <= e; ++i)\n\t\tret = min(ret, calc(idx + 1, i) + abs(i - l[idx]));\n\treturn ret;\n}\n\n\nint main() {\n\t//freopen(\"myfile.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) \n\t\tscanf(\"%d%d\", l + i, r + i);\n\tif (n == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tll ans = 1e15;\n\n\tint len = (r[0] - l[0] + 1);\n\tfor (int i = 1; i <= 400-len; ++i)\n\t\tans = min(ans, calc(1, i) + abs(i - l[0]));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define mp make_pair\ntypedef long long ll;\nmultiset<ll> pos,neg;\nint timer;\nll len[100011];\nll shiftpos,shiftneg;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tll m=0; ll c=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll l,r; cin>>l>>r;\n\t\tlen[i]=r-l;\n\t\tif(i>0){shiftpos+=len[i-1]; c-=len[i-1]*m;}\n\t\tshiftneg-=len[i];\n\t\tpos.insert(l-shiftpos); pos.insert(l-shiftpos);\n\t\tauto it=pos.begin(); ll res=(*it)+shiftpos;\n\t\tpos.erase(pos.begin()); neg.insert(res-shiftneg);\n\t\tll neglas=(*prev(neg.end()))+shiftneg;\n\t\tll posles=(*pos.begin())+shiftpos;\n\t\tif(!neg.empty()&&neglas>posles)\n\t\t{\n\t\t\tneg.erase(prev(neg.end())); pos.erase(pos.begin());\n\t\t\tpos.insert(neglas-shiftpos); neg.insert(posles-shiftneg);\n\t\t}\n\t\tm++; c-=l;\n\t}\n\twhile(m>0)\n\t{\n\t\tc+=(*prev(pos.end()))+shiftpos;\n\t\tm--;\n\t\tpos.erase(prev(pos.end()));\n\t}\n\tcout<<c<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;typedef unsigned long long ull;typedef long double ld;\n\n#define ALL(c) c.begin(),c.end()\n#define IN(l,v,r) (l<=v && v < r)\ntemplate<class T> void UNIQUE(T& v){v.erase(unique(ALL(v)),v.end());}\n//debug==\n#define DUMP(x) cerr << #x <<\" = \" << (x)\n#define LINE() cerr<< \" (L\" << __LINE__ << \")\"\n\nstruct range{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v+=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v<itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trange(int i, int n,int step):i({i,step}), n({n,step}){}\n\trange(int i, int n):range(i,n,1){}\n\trange(int n):range(0,n){}\n\tIter& begin(){return i;}\n\tIter& end(){return n;}\n};\nstruct rrange{\n\tstruct Iter{\n\t\tint v,step;\n\t\tIter& operator++(){v-=step;return *this;}\n\t\tbool operator!=(Iter& itr){return v>itr.v;}\n\t\tint& operator*(){return v;}\n\t};\n\tIter i, n;\n\trrange(int i, int n,int step):i({i-1,step}), n({n-1,step}){}\n\trrange(int i, int n):rrange(i,n,1){}\n\trrange(int n) :rrange(0,n){}\n\tIter& begin(){return n;}\n\tIter& end(){return i;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<60;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-12;};\ntemplate<> inline long double EPS<long double>(){return 1e-12;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> inline T upper_pow2(T n){ T res=1;while(res<n)res<<=1;return res;}\n// max{d | 2^d  <= n}\ntemplate<typename T> inline T msb(T n){ int d=62;while((1LL<<d)>n)d--;return d;}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tif(N > 400) return;\n\t\tvector<pair<int,int>> rs(N); cin >> rs;\n\t\t// sort(ALL(rs));\n\n\t\tvector<vector<ll>> dp(N+1,vector<ll>(501,INF<ll>()));\n\t\tfor(int r:range(500)){\n\t\t\tdp[0][r] = abs(rs[0].second - r);\n\t\t}\n\n\t\tfor(int i:range(1,N)){\n\t\t\tfor(int rp:range(500)){\n\t\t\t\tfor(int r:range(500)){\n\t\t\t\t\tint lp = rp-(rs[i-1].second-rs[i-1].first), l = r-(rs[i].second-rs[i].first);\n\t\t\t\t\tif((lp <= l && l <= rp) || (lp <= r && r <= rp)){\n\t\t\t\t\t\tdp[i][r] =  min(dp[i][r],dp[i-1][rp] + abs(rs[i].second - r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll res = INF<ll>();\n\t\tfor(int r:range(500)) res = min(res,dp[N-1][r]);\n\n\t\tcout << res << endl;\n\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-6;\nconst double pi = atan2(0, -1);\n\nstruct Queue\n{\n    stack<pair<int, int> > s1, s2;\n    Queue() {}\n    void push(int x)\n    {\n        if (s1.empty())\n            s1.push({x, x});\n        else\n            s1.push({x, min(s1.top().se, x)});\n    }\n    void pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                int x = s1.top().fi;\n                s1.pop();\n                if (s2.empty())\n                    s2.push({x, x});\n                else\n                    s2.push({x, min(s2.top().se, x)});\n            }\n        }\n        s2.pop();\n    }\n    int get_mi()\n    {\n        int res = inf;\n        if (!s1.empty())\n            res = min(res, s1.top().se);\n        if (!s2.empty())\n            res = min(res, s2.top().se);\n        return res;\n    }\n};\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"arrayop.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //int TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n][2];\n    rep(i, 0, n)\n    {\n        cin >> a[i][0] >> a[i][1];\n        a[i][0]--; a[i][1]--;\n    }\n    int dp[n][400];\n    rep(i, 0, n)\n        rep(j, 0, 400)\n            dp[i][j] = inf;\n    rep(j, 0, 400)\n        dp[0][j] = abs(j - a[0][0]);\n    rep(i, 1, n)\n    {\n        Queue q;\n        rep(j, 0, a[i][1] - a[i][0] + 1)\n            q.push(dp[i - 1][j]);\n        rep(j, 0, 400 - (a[i][1] - a[i][0]))\n        {\n            dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n            if (j - (a[i - 1][1] - a[i - 1][0]) >= 0)\n                q.pop();\n            if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                q.push(dp[i - 1][j + (a[i][1] - a[i][0]) + 1]);\n        }\n    }\n    int ans1 = inf, ans2 = inf;\n    rep(j, 0, 400)\n    {\n        ans1 = min(ans1, dp[0][j]);\n        ans2 = min(ans2, dp[n - 1][j]);\n    }\n    cout << ans1 + ans2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll N;\n    cin >> N;\n\n    vector<ll> l(N), r(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> l[i] >> r[i];\n    }\n\n    multiset<ll> le, ri;\n    le.insert(l[0]);\n    ri.insert(r[0]);\n\n    ll ls = l[0], rs = l[0];\n    ll ans = 0;\n    for (ll i = 1; i < N; i++) {\n        ls -= r[i] - l[i];\n        rs += r[i - 1] - l[i - 1];\n\n        ll a = *le.rbegin();\n        ll b = *ri.begin();\n        if (ls <= l[i] && l[i] <= rs) {\n            le.insert(l[i] - (ls - a));\n            ri.insert(l[i] - (rs - b));\n            ls = rs = l[i];\n        } else if (l[i] < ls) {\n            ans += abs(l[i] - ls);\n            le.insert(l[i] - (ls - a));\n            le.insert(l[i] - (ls - a));\n            ll left = *le.rbegin() + (ls - a);\n            le.erase(--le.end());\n            ri.insert(left - (rs - b));\n            ls = *le.rbegin() + (ls - a);\n            rs = left;\n        } else {\n            ans += abs(l[i] - rs);\n            ri.insert(l[i] - (rs - b));\n            ri.insert(l[i] - (rs - b));\n            ll right = *ri.begin() + (rs - b);\n            ri.erase(ri.begin());\n            le.insert(right - (ls - a));\n            ls = right;\n            rs = *ri.begin() + (rs - b);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n\nint N;\nint L[101010], R[101010];\n//-----------------------------------------------------------------------------------\ntypedef long long ll;\n#define INF 1LL<<60\nll dp[500][500];\nll naive() {\n\trep(i, 1, 500) rep(j, 0, 500) dp[i][j] = INF;\n\n\trep(i, 0, N) rep(j, 0, 500) {\n\t\tll c = 0;\n\t\tif (j < L[i]) c = L[i] - j;\n\t\tif (R[i] < j) c = j - R[i];\n\t\tdp[i + 1][j] = dp[i][j] + c;\n\t}\n\n\tll ans = INF;\n\trep(j, 0, 500) ans = min(ans, dp[N][j]);\n\treturn ans;\n}\n//-----------------------------------------------------------------------------------\nint main() {\n\tcin >> N;\n\trep(i, 0, N) scanf(\"%d%d\", &L[i], &R[i]);\n\n\tif (400 < N) return 0;\n\n\tcout << naive() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e5 + 10;\nll l[maxN], r[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> l[i] >> r[i];\n    }\n    if (n == 1) {\n        cout << 0;\n        return 0;\n    }\n    multiset < ll > S1, S2;\n    S1.insert(r[1]);\n    S2.insert(r[1]);\n    ll shift1 = 0;\n    ll shift2 = 0;\n    ll ans = 0;\n    for (int i = 2; i <= n; i++) {\n        ll len1 = r[i] - l[i];\n        ll len2 = r[i - 1] - l[i - 1];\n        shift1 -= len2;\n        shift2 += len1;\n        ll stL = *(prev(S1.end())) + shift1;\n        ll stR = *S2.begin() + shift2;\n        if (r[i] >= stR) {\n            S2.erase(S2.find(stR - shift2));\n            S2.insert(r[i] - shift2);\n            S2.insert(r[i] - shift2);\n            S1.insert(stR - shift1);\n            ans += r[i] - stR;\n        }\n        else if (r[i] <= stL) {\n            S1.erase(S1.find(stL - shift1));\n            S1.insert(r[i] - shift1);\n            S1.insert(r[i] - shift1);\n            S2.insert(stL - shift2);\n            ans += stL - r[i];\n        }\n        else {\n            S1.insert(r[i] - shift1);\n            S2.insert(r[i] - shift2);\n        }\n        // should take min(x - len1,\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define per(i,n) for ((i)=n;(i)>=(1);(i)--)\n#define ll long long\nusing namespace std;\nll n,m,i,j,l[100005],r[100005],tl,tr,ans;\npriority_queue<ll> ql;\npriority_queue<ll,vector<ll>,greater<ll> > qr;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\trep(i,n)\n\t{\n\t\tscanf(\"%lld%lld\",&l[i],&r[i]);\n\t\tif(i==1){\n\t\t\tql.push(l[i]);\n\t\t\tqr.push(l[i]);\n\t\t\ttl=tr=0;\n\t\t\tcontinue;\n\t\t}\n\t\tll lst=r[i-1]-l[i-1],cur=r[i]-l[i];\n\t\ttl-=cur;tr+=lst;\n\t\tll l1=ql.top()+tl,r1=qr.top()+tr;\n\t\tif(l[i]<l1){\n\t\t\tans+=abs(l1-l[i]);\n\t\t\tqr.push(l1-tr);\n\t\t\tql.push(l[i]-tl);\n\t\t\tql.push(l[i]-tl);\n\t\t\tql.pop();\n\t\t}\n\t\telse if(l[i]>r1){\n\t\t\tans+=abs(r1-l[i]);\n\t\t\tql.push(r1-tl);\n\t\t\tqr.push(l[i]-tr);\n\t\t\tqr.push(l[i]-tr);\n\t\t\tqr.pop();\n\t\t}\n\t\telse{\n\t\t\tql.push(l[i]-tl);\n\t\t\tqr.push(l[i]-tr);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint l[110000], r[110000];\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N; i++)cin >> l[i] >> r[i];\n    priority_queue<int> left;\n    priority_queue<int, vector<int>, greater<int> > right;\n    left.push(l[0]);\n    right.push(l[0]);\n    int true_l = l[0], true_r = l[0], ans = 0;\n    for (int i = 1; i < N; i++) {\n        true_l -= r[i] - l[i];\n        true_r += r[i - 1] - l[i - 1];\n        if (l[i] < true_l) {\n            ans += true_l - l[i];\n            left.push(l[i] + left.top() - true_l); left.push(l[i] + left.top() - true_l);\n            int lt = left.top();\n            left.pop();\n            right.push(true_l - true_r + right.top());\n            true_r = true_l;\n            true_l += left.top() - lt;\n        } else if (l[i] > true_r) {\n            ans += l[i] - true_r;\n            right.push(l[i] + right.top() - true_r); right.push(l[i] + right.top() - true_r);\n            int rt = right.top();\n            right.pop();\n            left.push(true_r - true_l + left.top());\n            true_l = true_r;\n            true_r += right.top() - rt;\n        } else {\n            left.push(l[i] + left.top() - true_l); right.push(l[i] + right.top() - true_r);\n            true_l = true_r = l[i];\n        }\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing namespace std::chrono;\n\nconst int LIM = 10;\nconst int INF = 1e+9;\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  assert(n <= 400);\n  vector<int> ans(LIM, 0), buf(LIM, INF);\n  vector<pair<int, int>> coords(n);\n  for (int i = 0; i < n; ++i)\n    cin >> coords[i].first >> coords[i].second;\n\n  for (int pl = 0; pl < LIM; ++pl) {\n    ans[pl] = abs(pl - coords[0].first);\n    //cout << ans[pl] << ' ';\n  }\n  //cout << endl;\n\n  for (int i = 1; i < n; ++i) {\n    int l = coords[i].first, r = coords[i].second;\n    int _l = coords[i - 1].first, _r = coords[i - 1].second, _len = _r - _l + 1;\n\n    buf.assign(LIM, INF);\n    for (int pl = 0, pr = r - l; pr < LIM; ++pl, ++pr) {\n      int cost = abs(l - pl);\n      int _min = INF;\n      for (int p = max(pl - _len, 0); p <= pr; ++p)\n        _min = min(_min, ans[p]);\n      cost += _min;\n\n      buf[pl] = cost;\n    }\n\n    swap(buf, ans);\n\n    //for (int i = 0; i < LIM; ++i)\n    //  cout << ans[i] << ' ';\n    //cout << endl;\n  }\n\n  int res = ans[0];\n  for (int i = 0; i < LIM; ++i)\n    res = min(res, ans[i]);\n  cout << res << endl;\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\n//typedef string S;\n\n/*ll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}*/\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 120010;\nconst long long MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst long long rev2 = (MOD + 1) / 2;\n\nint n, lastl, lastr;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    multiset<long long> L, R;\n    long long addL = 0, addR = 0;\n    long long c = 0;\n    L.insert(-INF);\n    R.insert(INF);\n    for (int i = 0; i < n; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (i != 0)\n        {\n            //addL -= lastr - lastl, addR += r - l;\n            addL -= r - l, addR += lastr - lastl;\n        }\n\n        /*for (auto it : L)\n        {\n            cout << it + addL << \" \";\n        }\n        cout << endl;\n        for (auto it : R)\n        {\n            cout << it + addR << \" \";\n        }\n        cout << endl << c << endl;*/\n\n        lastl = l, lastr = r;\n        auto x = L.end();\n        x--;\n        int Ln = *x + addL;\n        auto y = R.begin();\n        int R0 = *y + addR;\n        if (Ln <= l && l <= R0)\n        {\n            L.insert(l - addL);\n            R.insert(l - addR);\n        } else if (l < Ln)\n        {\n            L.erase(x);\n            R.insert(Ln - addR);\n            L.insert(l - addL);\n            L.insert(l - addL);\n            c += Ln - l;\n        } else if (R0 < l)\n        {\n            R.erase(y);\n            L.insert(R0 - addL);\n            R.insert(l - addR);\n            R.insert(l - addR);\n            c += l - R0;\n        } else\n        {\n            return 1;\n        }\n\n        /*for (auto it : L)\n        {\n            cout << it + addL << \" \";\n        }\n        cout << endl;\n        for (auto it : R)\n        {\n            cout << it + addR << \" \";\n        }\n        cout << endl << c << endl;\n        cout << endl;*/\n    }\n    cout << c;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nsigned main() {\n    int N; cin >> N;\n    vector<int> L(N), R(N);\n    for(int i=0; i<N; i++) {\n        cin >> L[i] >> R[i];\n    }\n\n    priority_queue< int > queL;\n    priority_queue< int, vector<int>, greater<int> > queR;\n\n    // 最小値の y 座標 (最終的な答え)\n    int flr = 0;\n\n    // 最小値より左 / 右にある点は、どれだけシフトしたか？\n    int ofsL = 0, ofsR = 0;\n    \n    queL.push(L[0]);\n    queR.push(L[0]);\n\n    for(int i=1; i<N; i++) {\n        ofsL += R[i] - L[i];\n        ofsR += R[i-1] - L[i-1];\n\n        // 左側領域の右端と、右側領域の左端\n        // 区間 [lb, ub] 内の任意の座標について最小値を達成する \n        int lb = queL.top() - ofsL, ub = queR.top() + ofsR;\n\n        // 点を push する際は、その時点での offset をキャンセルするよう注意\n        if(lb <= L[i] and L[i] <= ub) {\n            // 傾き 0 (最小値を取る領域内) の場合、最小値は変わらない\n            queL.push(L[i] + ofsL);\n            queR.push(L[i] - ofsR);\n        }\n        else if(L[i] < lb) {\n            // 傾き負の領域内にいた場合、最小値が変化\n            flr += lb - L[i];\n            // 左側にある点であって元の最小値に最も近い点は、\n            // 最小値が変化したことにより傾きが正へ変化する\n            queR.push(lb - ofsR);\n            queL.pop();\n            // L[i] に相当する情報を追加\n            queL.push(L[i] + ofsL);\n            queL.push(L[i] + ofsL);\n        }\n        else {\n            flr += L[i] - ub;\n            queL.push(ub + ofsL);\n            queR.pop();\n            queR.push(L[i] - ofsR);\n            queR.push(L[i] - ofsR);\n        }\n    }\n    cout << flr << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    if(i < L[0]) dp[i] = L[0] - i;\n    else if(i < R[0]) dp[i] = 0;\n    else dp[i] = i - R[0];\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto left = j, right = left + R[i] - L[i];\n      auto preleft = max(0, j - R[i - 1] - L[i - 1]);\n      for(int k = preleft; k <= right; k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> L;\npriority_queue <ll,vector<ll>,greater<ll>> R;\nint l[100005],r[100005],n;\nll dl,dr,ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%d%d\",&l[1],&r[1]);\n\tL.push(l[1]),R.push(r[1]);\n\tfor (int i=2;i<=n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tint len=r[i]-l[i],len1=r[i-1]-l[i-1];\n\t\tdl+=len,dr+=len1;\n\t\tll lmin=L.top()-dl,rmin=R.top()+dr;\n\t\tif (l[i]<lmin){\n\t\t\tans=ans+(lmin-l[i]);\n\t\t\tL.pop(),R.push(lmin-dr);\n\t\t\tL.push(l[i]+dl),L.push(l[i]+dl);\n\t\t}else\n\t\tif(l[i]>rmin){\n\t\t\tans=ans+(l[i]-rmin);\n\t\t\tR.pop(),L.push(rmin+dl);\n\t\t\tR.push(l[i]-dr),R.push(l[i]-dr);\n\t\t}else{\n\t\t\tL.push(l[i]+dl),R.push(l[i]-dr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll N;\nll a[100005],b[100005];\n\nll dp[2][405];\nvoid solve(){\n\n  if(N==1){\n    cout<<0<<endl;\n    return;\n  }\n  \n  ll INF=(1LL<<60);\n  fill( dp[0],dp[2] , INF);\n\n  for(int i=1;i<=400;i++){\n    dp[1][ i ]= abs(a[1]-i);\n  }\n\n  ll ans=INF;\n  \n  for(int i=1;i+1<=N;i++){\n    int ai=i%2;\n    int bi=1-ai;\n\n    for(int j=0;j<405;j++)dp[bi][j]=INF;\n    \n    for(int j=1;j<=400;j++){\n      int len0=b[i]-a[i]+1;\n      int len1=b[i+1]-a[i+1]+1;\n      int fi=j-len1+1;\n      int se=j+len0-1;\n      if(fi<1)fi=1;\n      if(se>400)se=400;\n      for(int k=fi;k<=se;k++){\n        dp[bi][k]=min(dp[bi][k],dp[ai][j]+abs(a[i+1]-k));\n        if(i+1==N)ans=min(ans,dp[bi][k]);\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>N;\n  assert(N<=400);/////////////////////////////////////////\n  \n  for(int i=1;i<=N;i++){\n    cin>>a[i]>>b[i];\n    assert(a[i]<=400);/////////////////////////////////////////\n    assert(b[i]<=400);/////////////////////////////////////////\n  }\n\n  solve();  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef multiset<ll> sl;\nconst int MN = 200200;\nsl ls,rs;\nll lv[MN],rv[MN];\nll ld,rd;\nvoid balance() {\n\twhile(rs.size() > ls.size()) {\n\t\tauto it = rs.begin();\n\t\tls.insert(*it-ld+rd);\n\t\trs.erase(it);\n\t}\n\twhile(ls.size() > rs.size()) {\n\t\tauto it = (--ls.end());\n\t\trs.insert(*it-rd+ld);\n\t\tls.erase(it);\n\t}\n}\nint main() {\n\tld = rd = 0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tll fl,sl;\n\tll res = 0;\n\tfor(int i=0;i<n;i++) {\n\t\tscanf(\"%d %d\",&lv[i],&rv[i]);\n\t\tfl = rv[i]-lv[i];\n\t\tif(i > 0) {ld -= fl;rd += sl;}\n\t\tsl = fl;\n\t\tll lf,rt;\n\t\tif(i > 0) {\n\t\t\tlf = *(ls.end()--);\n\t\t\trt = *(rs.begin());\n\t\t\tlf += ld;\n\t\t\trt += rd;\n\t\t} else {\n\t\t\tlf = rt = 0;\n\t\t}\n\t\tif(lv[i] > rt) {\n\t\t\trs.insert(lv[i]-rd);\n\t\t\trs.insert(lv[i]-rd);\n\t\t} else {\n\t\t\tls.insert(lv[i]-ld);\n\t\t\tls.insert(lv[i]-ld);\n\t\t}\n\t\tbalance();\n\t\tres += lv[i]-ld;\n\t}\n\tll x = ld,m = -n;\n\tfor(auto& it: ls) {\n\t\tres += m*(it+ld-x);\n\t\tx = it+ld;\n\t\tm++;\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vl l(n),r(n);\n    rep(i,n){\n        cin >> l[i] >> r[i];\n    }\n    multiset<ll> lv={l[0]}, rv={r[0]};\n    ll ans = 0, lsum = 0, rsum = 0;\n    rep(i,n-1){\n        lsum += r[i+1]-l[i+1];\n        rsum += r[i] - l[i];\n        if(l[i+1] < *(--lv.end()) - lsum){\n            ans += *(--lv.end()) - lsum - l[i+1];\n            rv.insert(*(--lv.end())-lsum-rsum);\n            lv.erase((--lv.end()));\n            lv.insert(l[i+1]+lsum), lv.insert(l[i+1]+lsum);\n        }else if(l[i+1] > *(rv.begin()) + rsum){\n            ans += l[i+1]- *(rv.begin()) - rsum;\n            lv.insert(*rv.begin()+rsum+lsum);\n            rv.erase(rv.begin());\n            rv.insert(l[i+1]-rsum), rv.insert(l[i+1]-rsum);\n        }else{\n            lv.insert(l[i+1]+lsum), rv.insert(l[i+1]-rsum);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define pb push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nll N;\nvector<ll> l,r;\n\nint main(){\n    cin >> N;\n    assert(N<=400);\n    l.resize(N);\n    r.resize(N);\n    ll mid=0;\n    rep(i,N){\n        cin >> l[i] >> r[i];\n    }\n\n    ll ans2=LINF;\n    for(int mid=0;mid<=400;mid++){\n        ll ans=0;\n        rep(i,N){\n            if(l[i] <= mid and mid <= r[i]) continue;\n            if(r[i] < mid){\n                ans += abs(mid-r[i]);\n            }else{\n                ans += abs(l[i]-mid);\n            }\n        }\n        ans2=min(ans2,ans);\n    }\n    cout << ans2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nlong long n,l[200000],r[200000];\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tlong long tot=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",l+i,r+i);\n\t\ttot+=l[i]+r[i];\n\t}\n\tlong long avr=floor(double(tot)/2/n+.5);\n\tlong long cost=0;\n\tfor(int i=0;i<n;i++)\n\t\tif(avr<l[i])cost+=l[i]-avr;\n\t\telse if(avr>r[i])cost+=avr-r[i];\n\tprintf(\"%lld\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 dp[401][401];\ni64 l[401], r[401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n\n    if (!(n < 401 && maxr < 401)) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(0, 400, j) {\n            if (l[i] <= j && j <= r[i]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = j < l[i] ? l[i]-j : j-r[i];\n            }\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(0, 400, j) {\n        i64 d = 0;\n        upto(1, n, i) {\n            d+=dp[i][j];\n        }\n        ans = min(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 1e5 + 1e3;\n\nint n, l[N], r[N], len[N];\n\nll tl, tr, ans;\n\npriority_queue<ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\n\nint main () {\n\n\tFile();\n\n\tFor (i, 1, n = read()) \n\t\tl[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n\n\tL.push(r[1]); R.push(r[1]);\n\tFor (i, 2, n) {\n\t\ttl -= len[i - 1]; tr += len[i];\n\t\tll lp = L.top() + tl, rp = R.top() + tr;\n\t\tif (lp <= r[i] && r[i] <= rp) \n\t\t\tL.push(r[i] - tl), R.push(r[i] - tr);\n\t\telse if (r[i] >= lp) {\n\t\t\tans += r[i] - rp; R.pop(); L.push(rp - tl);\n\t\t\tR.push(r[i] - tr); //R.push(r[i] - tr);\n\t\t} else {\n\t\t\tans += lp - r[i]; L.pop(); R.push(lp - tr);\n\t\t\tL.push(r[i] - tl); //L.push(r[i] - tl);\n\t\t}\n\t}\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n\n#define N (1<<17)\n#define MODULO (1000000007)\n\n#include <cstdio>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint n;\npair<int, int> pos[N];\nint len[N];\npriority_queue<long long> PQL, PQR;\nlong long pbl, pbr;\nlong long Ans;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].first, &pos[i].second);\n\t\tlen[i] = pos[i].second - pos[i].first;\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tpbr += len[i];\n\t\tPQL.push(pos[i].second - pbl);\n\t\tPQR.push(pbr - pos[i].second);\n\t\t//__debugbreak();\n\t\twhile (true)\n\t\t{\n\t\t\tlong long L = PQL.top() + pbl;\n\t\t\tlong long R = -PQR.top() + pbr;\n\t\t\tif (L <= R)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns += L - R;\n\t\t\tPQL.pop(), PQR.pop();\n\t\t\tPQL.push(R - pbl), PQR.push(pbr - L);\n\t\t\t//__debugbreak();\n\t\t}\n\t\tpbl -= len[i];\n\t\t//__debugbreak();\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    ll base = 0, ld = 0, rd = 0, wo, w, x;\n    cin >> wo >> x;\n    wo = x - wo;\n    multiset<ll> ls{x}, rs{x};\n    for (int i = 0; i < n - 1; ++i) {\n        cin >> w >> x;\n        w = x - w;\n        ld -= wo;\n        rd += w;\n        wo = w;\n        ll bl = *prev(end(ls)) + ld, br = *begin(rs) + rd;\n        if (bl <= x && x <= br) {\n            ls.insert(x - ld);\n            rs.insert(x - rd);\n        } else if (x < bl) {\n            base += bl - x;\n            ls.insert(x - ld);\n            ls.insert(x - ld);\n            ls.erase(prev(end(ls)));\n            rs.insert(bl - rd);\n        } else {\n            base += x - br;\n            rs.insert(x - rd);\n            rs.insert(x - rd);\n            rs.erase(begin(rs));\n            ls.insert(br - ld);\n        }\n    }\n    cout << base << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n\nint N;\nint L[101010], R[101010];\n//-----------------------------------------------------------------------------------\ntypedef long long ll;\n#define INF 1LL<<60\nll dp[500][500];\nll naive() {\n\trep(i, 1, N + 1) rep(j, 0, 500) {\n\t\tll c = INF;\n\t\tif (1 < i) {\n\t\t\tint lo = max(0, j - (R[i - 1] - L[i - 1]));\n\t\t\tint hi = min(j + (R[i] - L[i]), 499);\n\t\t\trep(k, lo, hi + 1) c = min(c, dp[i - 1][k]);\n\t\t}\n\t\telse c = 0;\n\t\tdp[i][j] = c + abs(L[i] - j);\n\t}\n\n\tll ans = INF;\n\trep(j, 0, 500) ans = min(ans, dp[N][j]);\n\treturn ans;\n}\n//-----------------------------------------------------------------------------------\nint main() {\n\tcin >> N;\n\trep(i, 1, N + 1) scanf(\"%d%d\", &L[i], &R[i]);\n\n\tif (400 < N) return 0;\n\n\tcout << naive() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\nusing namespace std;\nmap<int ,long long>dp[100010];\nint n;\nlong long ans=1e18;\nint l[100010],r[100010];\nint mabs(int x)\n{\n\tif(x<0)return -x;return x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",l+i,r+i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint ln=r[i-1]-l[i-1];\n\t\tfor(int j=-400;j<=400;j++)\n\t\t{\n\t\t\tdp[i][j]=1e18;\n\t\t\tint cst=mabs(l[i]-j);\n\t\t\tfor(int k=j-ln;k<=j+r[i]-l[i];k++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][k]==1e18)continue;\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+cst);\n\t\t\t\tif(i==n)ans=min(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long N, L[1 << 18], R[1 << 18];\n\n// 傾きがある点をすべて入れる\nvector<long long> cl, cr;\nlong long offset_l, offset_r, Answer;\n\nint main() {\n\tscanf(\"%lld\", &N);\n\tfor (int i = 1; i <= N; i++) scanf(\"%lld%lld\", &L[i], &R[i]);\n\n\tcl.push_back(L[1]);\n\tcr.push_back(L[1]);\n\n\tfor (int i = 2; i <= N; i++) {\n\t\toffset_l += (R[i] - L[i]);\n\t\toffset_r += (R[i - 1] - L[i - 1]);\n\n\t\tlong long el = cl[cl.size() - 1] - offset_l, er = cr[cr.size() - 1] + offset_r;\n\t\tif (el <= L[i] && L[i] <= er) {\n\t\t\tcl.push_back(L[i] + offset_l);\n\t\t\tcr.push_back(L[i] - offset_r);\n\t\t}\n\t\telse if (L[i] < el) {\n\t\t\tAnswer += (el - L[i]);\n\t\t\tcl.pop_back();\n\t\t\tcr.push_back(el - offset_r);\n\t\t\tcl.push_back(L[i] + offset_l);\n\t\t\tcl.push_back(L[i] + offset_l);\n\t\t}\n\t\telse if (L[i] > er) {\n\t\t\tAnswer += (L[i] - er);\n\t\t\tcr.pop_back();\n\t\t\tcl.push_back(er + offset_l);\n\t\t\tcr.push_back(L[i] - offset_r);\n\t\t\tcr.push_back(L[i] - offset_r);\n\t\t}\n\t}\n\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nconst ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> l(n), r(n); repeat (i,n) scanf(\"%d%d\", &l[i], &r[i]);\n    // assert\n    assert (n <= 400);\n    repeat (i,n) {\n        assert (l[i] <= 400);\n        assert (r[i] <= 400);\n    }\n    // compute\n    constexpr int shift = 200;\n    constexpr int limit = 600;\n    vector<ll> cur(limit, 0ll);\n    vector<ll> prv(limit, inf);\n    repeat (j,limit) cur[j] = 0;\n    int w_prv = 1;\n    repeat (i,n) {\n        cur.swap(prv);\n        int w = r[i] - l[i] + 1;\n        repeat (x,limit) {\n            cur[x] = inf;\n            repeat_from (y, max(0, x-w_prv-1), min(limit, x+w+2)) {\n                setmin(cur[x], prv[y] + abs(x - (l[i]+shift)));\n            }\n        }\n    }\n    ll result = *whole(min_element, cur);\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <set>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#define rep(i,m,n) for(i=m;i<=n;i++)\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ll long long\n#define pi acos(-1.0)\n#define pii pair<int,int>\n#define sys system(\"pause\")\nconst int maxn=4e2+10;\nconst int N=1e3+10;\nusing namespace std;\nll gcd(ll p,ll q){return q==0?p:gcd(q,p%q);}\nll qpow(ll p,ll q){ll f=1;while(q){if(q&1)f=f*p;p=p*p;q>>=1;}return f;}\nint n,m,k,t,dp[maxn][maxn],l[maxn],r[maxn];\nint main()\n{\n    int i,j;\n    memset(dp,inf,sizeof(dp));\n    scanf(\"%d\",&n);\n    rep(i,1,n)scanf(\"%d%d\",&l[i],&r[i]);\n    rep(i,r[1]-l[1]+1,400)dp[1][i]=abs(r[1]-i);\n    //printf(\"%d %d\\n\",dp[1][3],dp[1][2]);sys;\n    rep(i,2,n)\n    {\n        rep(j,r[i]-l[i]+1,400)\n        {\n            int len=r[i]-l[i]+1;\n            rep(k,r[i-1]-l[i-1]+1,400)\n            {\n                int len1=r[i-1]-l[i-1]+1;\n                if(k>=j-len+1&&k-len1+1<=j)dp[i][j]=min(dp[i][j],dp[i-1][k]+abs(r[i]-j));\n                if(j>=k-len1+1&&j-len+1<=k)dp[i][j]=min(dp[i][j],dp[i-1][k]+abs(r[i]-j));\n            }\n        }\n    }\n    int mi=1e9;\n    rep(i,1,400)mi=min(dp[n][i],mi);\n    printf(\"%d\\n\",mi);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint dp[410][410] = {}; //\tdp\n\nint main(){\n\tint w = 400;\n\tint n;\n\tcin >> n;\n\tvector<int> a(n), s(n);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint b;\n\t\tcin >> a[i] >> b;\n\t\ts[i] = b - a[i];\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tmultiset<int> S;\n\t\tint A = !i?0:s[i-1];\n\t\tint B = s[i];\n\t\tfor(int j = 0 ; j < B ; j++)\n\t\t\tS.insert(dp[i][j]);\n\n\t\tfor(int j = 0 ; j <= w ; j++){\n\t\t\tif( j + B <= w ){\n\t\t\t\tS.insert(dp[i][j+B]);\n\t\t\t}\n\t\t\tif( j - A - 1 >= 0 ){\n\t\t\t\tS.erase(S.find(dp[i][j-A-1]));\n\t\t\t}\n\t\t\t// cond: S has [j-A,j+B]\n\t\t\tdp[i+1][j] = *S.begin();\n\t\t}\n\n\t\tfor(int j = 0 ; j <= w ; j++){\n\t\t\tdp[i+1][j] += abs(a[i]-j);\n\t\t}\n\t}\n\tfor(int i = 0 ; i <= n ; i++){\n\t\tfor(int j = 0 ; j < 10 ; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << *min_element(dp[n],dp[n]+w+1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n#define MAX 410\nint dp[MAX][MAX] = {};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tassert(N <= 500);\n\tvector<int> l(N), r(N); rep(i, 0, N) { cin >> l[i] >> r[i]; }\n\tmemset(dp, 0x3f, sizeof(dp));\n\trep(i, 0, MAX - (r[0] - l[0])) {\n\t\tdp[0][i] = abs(i - l[0]);\n\t}\n\trep(i, 0, N - 1) {\n\t\trep(j, 0, MAX - (r[i + 1] - l[i + 1])) {\n\t\t\trep(k, max(0, j - (r[i] - l[i])), r[i + 1] - l[i + 1] + j + 1) {\n\t\t\t\tchmin(dp[i + 1][j], dp[i][k] + abs(j - l[i + 1]));\n\t\t\t}\n\t\t}\n\t\tdump(dp[i]);\n\t}\n\tdump(dp[N - 1]);\n\tcout << *min_element(all(dp[N - 1])) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define MN 100000\n#define ll long long\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nll ans,addl,addr;\nint n,l[MN+5],r[MN+5];\npriority_queue<ll> ql;\npriority_queue<ll,vector<ll>,greater<ll> >qr;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) l[i]=read(),r[i]=read();\n    ql.push(l[1]);qr.push(l[1]);\n    for(int i=2;i<=n;++i)\n    {\n        addr+=r[i-1]-l[i-1];addl+=r[i]-l[i];\n        ll pl=ql.top()-addl,pr=qr.top()+addr;\n        if(pl<=l[i]&&l[i]<=pr) ql.push(l[i]+addl),qr.push(l[i]-addr);\n        else if(l[i]<pl)\n        {\n            ans+=pl-l[i];\n            qr.push(pl-addr);\n            ql.pop();ql.push(l[i]+addl);ql.push(l[i]+addl);\n        }\n        else\n        {\n            ans+=l[i]-pr;\n            ql.push(pl+addl);\n            qr.pop();qr.push(l[i]-addr);qr.push(l[i]-addr);\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 100054;\n\nint n;\nstd::priority_queue <ll> L;\nstd::priority_queue <ll, std::vector <ll>, std::greater <ll> > R;\nll OL, OR; // offset\n\nint main() {\n\tint i, l, r, dis, la = -1; ll x, y, ans = 0;\n\tscanf(\"%d%d%d\", &n, &l, &r), la = r - l;\n\tL.emplace(l), R.emplace(l);\n\tfor (i = 1; i < n; ++i, la = dis) {\n\t\tscanf(\"%d%d\", &l, &r), dis = r - l, OL -= dis, OR += la;\n\t\tx = L.top() + OL, y = R.top() + OR;\n\t\tif (x > l) ans += x - l, R.push(x - OR), L.pop(), L.emplace(l - OL), L.emplace(l - OL);\n\t\telse if (y < l) ans += l - y, L.push(y - OL), R.pop(), R.emplace(l - OR), R.emplace(l - OR);\n\t\telse L.emplace(l - OL), R.emplace(l - OR);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// atcoder arc70\n#include <bits/stdc++.h>\n#define debug 0\n\nusing namespace std;\ntypedef long long ll;\n\n/*\nfor every number, find the left and right bound\n*/\n\npriority_queue<ll> l;\npriority_queue<ll, vector<ll>, greater<ll>> r;\n\nll lo = 0;\nll ro = 0;\nvoid printpq(){\n\tvector<ll> temp;\n\tprintf(\"L: \");\n\twhile(!l.empty()){\n\t\ttemp.push_back(l.top());\n\t\tprintf(\"%d \", l.top()-lo);\n\t\tl.pop();\n\t}\n\tprintf(\"\\n\");\n\tfor(auto i : temp) l.push(i);\n\ttemp.clear();\n\tprintf(\"R: \");\n\twhile(!r.empty()){\n\t\ttemp.push_back(r.top());\n\t\tprintf(\"%d \", r.top()+ro);\n\t\tr.pop();\n\t}\n\tfor(auto i : temp) r.push(i);\n\ttemp.clear();\n\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n}\nll n;\nint main(){\n\tif(debug) freopen(\"narrowrectangles.in\", \"r\", stdin);\n\tcin >> n;\n\tll a,b; cin >> a >> b;\n\tl.push(a);\n\tr.push(a);\n\tll prvlen = b-a;\n\tll ans = 0;\n\tfor(ll i = 1; i<n; i++){\n\t\tcin >> a >> b;\n\t\tll len = b-a;\n\t\tlo += len;\n\t\tro += prvlen;\n\t\tif(a <= l.top()-lo){\n\t\t\tans += l.top()-lo -a;\n\t\t\tl.push(a+lo);\n\t\t\tl.push(a+lo);\n\t\t\tr.push(l.top()-lo-ro);\n\t\t\tl.pop();\n\t\t}else if(a >= r.top()+ro){\t\n\t\t\tans +=a-(r.top()+ro);\n\t\t\tr.push(a-ro);\n\t\t\tr.push(a-ro);\n\t\t\tl.push(r.top()+ro+lo);\n\t\t\tr.pop();\n\t\t}else{\n\t\t\tl.push(a+lo);\n\t\t\tr.push(a-ro);\n\t\t}\n\t\tif(debug) printpq();\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\nusing namespace std;\ntypedef long long LL;\npriority_queue<LL>L;\npriority_queue<LL,vector<LL>,greater<LL>>R;\nLL tL,tR,ans;\nint n,l[123456],r[114514];\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)cin>>l[i]>>r[i];\n\tL.push(l[1]),R.push(l[1]);\n\tfor(int i=2;i<=n;++i){\n\t\ttL-=r[i]-l[i],tR+=r[i-1]-l[i-1];\n\t\tLL mnL=L.top()+tL,mnR=R.top()+tR;\n\t\tif(mnL<=l[i]&&l[i]<=mnR)L.push(l[i]-tL),R.push(l[i]-tR);else\n\t\tif(l[i]>mnR){\n\t\t\tans+=l[i]-mnR,L.push(mnR-tL),R.pop();\n\t\t\tR.push(l[i]-tR),R.push(l[i]-tR);\n\t\t}else{\n\t\t\tans+=mnL-l[i],R.push(mnL-tR),L.pop();\n\t\t\tL.push(l[i]-tL),L.push(l[i]-tL);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n#define N 100010\nll l[N], r[N];\nmultiset<ll> ls, rs;\nll lo, ro;\nll n;\n\nint main(){\n\tINIT;\n\tcin>>n;\n\trep(i, n) cin>>l[i]>>r[i];\n\tls.insert(l[0]);\n\trs.insert(r[0]);\n\tll res = 0;\n\tREP(i, 1, n){\n\t\tlo -= r[i]-l[i];\n\t\tauto itl = ls.end(); --itl;\n\t\tauto itr = rs.begin();\n\t\tif(l[i]<*itl+lo){\n\t\t\tll x = *itl+lo;\n\t\t\tres += abs(l[i]-x);\n\t\t\tls.erase(itl);\n\t\t\trs.insert(x-ro);\n\t\t\tls.insert(l[i]-lo);\n\t\t\tls.insert(l[i]-lo);\n\t\t} else if(l[i]>*itr+ro){\n\t\t\tll x = *itr+ro;\n\t\t\tres += abs(l[i]-x);\n\t\t\trs.erase(itr);\n\t\t\tls.insert(x-lo);\n\t\t\trs.insert(l[i]-ro);\n\t\t\trs.insert(l[i]-ro);\n\t\t} else {\n\t\t\tls.insert(l[i]-lo);\n\t\t\trs.insert(l[i]-ro);\n\t\t}\n\t\t/*\n\t\t{\n\t\t\tcerr<<\"ls\"<<endl;\n\t\t\tfor(auto x: ls) cerr<<x+lo<<\" \"; cerr<<endl;\n\t\t\tcerr<<\"rs\"<<endl;\n\t\t\tfor(auto x: rs) cerr<<x+ro<<\" \"; cerr<<endl;\n\t\t}\n\t\t*/\n\t\titl = ls.end(); --itl;\n\t\t//cerr<<l[i]<<\" \"<<*itl+lo<<\" \"<<lo<<endl;\n\t\t//res += abs(l[i]-(*itl+lo));\n\t\tro += r[i]-l[i];\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i32 = int; using i64 = long long int; using f64 = double; using str = string;\ntemplate <typename T> using vec = vector<T>;\ntemplate <typename T> using heap = priority_queue<T, vec<T>, greater<T>>;\n#define times(n, i) for (i32 i = 0; i < (n); ++i)\n#define range(a, b, i) for (i32 i = (a); i < (b); ++i)\n#define upto(a, b, i) for (i32 i = (a); i <= (b); ++i)\n#define downto(a, b, i) for (i32 i = (a); i >= (b); --i)\n#define all(xs) (xs).begin(), (xs).end()\n#define sortall(xs) sort(all(xs))\n#define reverseall(xs) reverse(all(xs))\n#define uniqueall(xs) (xs).erase(unique(all(xs)), (xs).end())\n#define even(x) (((x) & 1) == 0)\n#define odd(x) (((x) & 1) == 1)\n#define append emplace_back\nconst i64 MOD = 1000000007;\n\ni64 n;\ni64 l[401], r[401];\ni64 dp[401][401];\n\ni32 main()\n{\n    cin >> n;\n    i64 maxr = 0;\n    upto(1, n, i) {\n        cin >> l[i] >> r[i];\n        maxr = max(maxr, r[i]);\n    }\n    if (n > 400 || maxr > 400) {\n        throw runtime_error(NULL);\n    }\n\n    upto(1, n, i) {\n        upto(0, 400, j) {\n            i64 minc = LLONG_MAX;\n            upto(max(0ll, j-(r[i-1]-l[i-1])), min(400ll, j+(r[i]-l[i])), k) {\n                minc = min(minc, dp[i-1][k]);\n            }\n            dp[i][j] = abs(j-l[i]) + minc;\n        }\n    }\n\n    i64 ans = LLONG_MAX;\n    upto(0, 400, i) {\n        ans = min(ans, dp[n][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main(void){\n\tint l[10000];\n\tint r[10000];\n\tint lo[10000];\n\tint dp[450][450];\n\tfor (int i = 0; i < 450; i++){\n\t\tfor (int j = 0; j < 450; j++){\n\t\t\tdp[i][j] = 1000000009;\n\t\t}\n\t}\n\tint c, d;\n\tint n, m;\n\tint s, t;\n\tint x, y, z;\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\", &l[i],&r[i]);\n\t\tlo[i] = r[i] - l[i];\n\t}\n\tfor (int i = 0; i <= 400; i++)dp[0][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j <= 400; j++){\n\t\t\tif (j - lo[i] > 0)s = j - lo[i];\n\t\t\telse s = 0;\n\t\t\tif (j + lo[i] < 400)t = j + lo[i];\n\t\t\telse t = 400;\n\t\t\tfor (int k = s; k <= t; k++){\n\t\t\t\tif (k<j){\n\t\t\t\t\tif (l[i] > k){\n\t\t\t\t\t\tif (dp[i][k] + l[i] - k < dp[i + 1][j])dp[i + 1][j] = dp[i][k] + l[i] - k;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r[i] < j){\n\t\t\t\t\t\tif (dp[i][k] - r[i] + j < dp[i + 1][j])dp[i + 1][j] = dp[i][k] - r[i] + j;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (dp[i][k] < dp[i + 1][j])dp[i + 1][j] = dp[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (l[i] > j){\n\t\t\t\t\t\tif (dp[i][k] + l[i] - j < dp[i + 1][j])dp[i + 1][j] = dp[i][k] + l[i] - j;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r[i] < k){\n\t\t\t\t\t\tif (dp[i][k] - r[i] + k < dp[i + 1][j])dp[i + 1][j] = dp[i][k] - r[i] + k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (dp[i][k] < dp[i + 1][j])dp[i + 1][j] = dp[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ts = 1000000009;\n\tfor (int i = 0; i <= 400; i++){\n\n\t\tif (s > dp[n][i])s = dp[n][i];\n\t}\n\tprintf(\"%d\\n\", s);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst double eps = 1e-6;\nconst double pi = atan2(0, -1);\n\nstruct Queue\n{\n    stack<pair<int, int> > s1, s2;\n    Queue() {}\n    void push(int x)\n    {\n        if (s1.empty())\n            s1.push({x, x});\n        else\n            s1.push({x, min(s1.top().se, x)});\n    }\n    void pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                int x = s1.top().fi;\n                s1.pop();\n                if (s2.empty())\n                    s2.push({x, x});\n                else\n                    s2.push({x, min(s2.top().se, x)});\n            }\n        }\n        s2.pop();\n    }\n    int get_mi()\n    {\n        int res = inf;\n        if (!s1.empty())\n            res = min(res, s1.top().se);\n        if (!s2.empty())\n            res = min(res, s2.top().se);\n        return res;\n    }\n};\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"arrayop.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //int TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    /*Queue qq;\n    while (true)\n    {\n        char c;\n        cin >> c;\n        if (c == '+')\n        {\n            int x;\n            cin >> x;\n            qq.push(x);\n        }\n        else if (c == '-')\n            qq.pop();\n        else\n            cout << qq.get_mi() << endl;\n    }*/\n    int n;\n    cin >> n;\n    int a[n][2];\n    rep(i, 0, n)\n    {\n        cin >> a[i][0] >> a[i][1];\n        a[i][0]--; a[i][1]--;\n    }\n    int ans = inf;\n    int dp[n][400];\n    rep(x, 0, n)\n    {\n        rep(i, 0, n)\n            rep(j, 0, 400)\n                dp[i][j] = inf;\n        rep(j, a[x][0], a[x][1] + 1)\n            dp[x][j] = 0;\n        rep(i, x + 1, n)\n        {\n            Queue q;\n            rep(j, 0, a[i][1] - a[i][0] + 1)\n                q.push(dp[i - 1][j]);\n            rep(j, 0, 400 - (a[i][1] - a[i][0]))\n            {\n                dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n                q.pop();\n                if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                    q.push(dp[i - 1][j + (a[i][1] - a[i][0]) + 1]);\n            }\n        }\n        repb(i, x - 1, -1)\n        {\n            Queue q;\n            rep(j, 0, a[i][1] - a[i][0] + 1)\n                q.push(dp[i + 1][j]);\n            rep(j, 0, 400 - (a[i][1] - a[i][0]))\n            {\n                dp[i][j] = min(dp[i][j], q.get_mi() + abs(j - a[i][0]));\n                q.pop();\n                if (j < 400 - (a[i][1] - a[i][0]) - 1)\n                    q.push(dp[i + 1][j + (a[i][1] - a[i][0]) + 1]);\n            }\n        }\n        int ans1 = inf, ans2 = inf;\n        rep(j, 0, 400)\n        {\n            ans1 = min(ans1, dp[0][j]);\n            ans2 = min(ans2, dp[n - 1][j]);\n        }\n        /*rep(i, 0, n)\n        {\n            rep(j, 0, 10)\n                if (dp[i][j] != inf)\n                    cout << dp[i][j] << \" \";\n                else\n                    cout << 'x' << \" \";\n            cout << endl;\n        }\n        cout << endl;*/\n        ans = min(ans, ans1 + ans2);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<int64> ls(n), rs(n), ds(n);\n  for (int i = 0; i < n; i++) {\n    cin >> ls[i] >> rs[i];\n    ds[i] = rs[i] - ls[i];\n  }\n\n  multiset<int64> l_set;\n  multiset<int64> r_set;\n  int64 l_base = 0;\n  int64 r_base = 0;\n  int64 c = 0;\n\n  l_set.insert(ls[0]);\n  r_set.insert(ls[0]);\n\n  for (int i = 1; i < n; i++) {\n    l_base -= ds[i];\n    r_base += ds[i - 1];\n\n    int64 l_max = *l_set.rbegin() + l_base;\n    int64 r_min = *r_set.begin() + r_base;\n    if (DEBUG) {\n      cout << \"l_max: \" << l_max << \" r_min: \" << r_min << endl;\n    }\n    if (ls[i] < l_max) {\n      l_set.insert(ls[i] - l_base);\n      l_set.insert(ls[i] - l_base);\n\n      l_set.erase(prev(l_set.end()));\n      r_set.insert(l_max - r_base);\n\n      c += l_max - ls[i];\n    } else if (r_min < ls[i]) {\n      r_set.insert(ls[i] - r_base);\n      r_set.insert(ls[i] - r_base);\n\n      r_set.erase(r_set.begin());\n      l_set.insert(r_min - l_base);\n\n      c += ls[i] - r_min;\n    } else {\n      l_set.insert(ls[i] - l_base);\n      r_set.insert(ls[i] - r_base);\n    }\n    if (DEBUG) {\n      cout << \"i: \" << i << \" c: \" << c << endl;\n    }\n  }\n\n  cout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll L[100010],R[100010];\nll dif[2];\nll INF = 1001001001001001001;\nmultiset<ll> st[2];\nmultiset<ll>::iterator itel,iter;\nll ans;\n\nvoid mov(int id)\n{\n    ll tmp = *st[id].begin();\n    st[id].erase(st[id].begin());\n    if(id)st[1 - id].insert(-(tmp + dif[id]) - dif[1 - id]);\n    else st[1 - id].insert(-(tmp + dif[id]) - dif[1 - id]);\n    return;\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N; i++)scanf(\"%lld%lld\",L + i,R + i);\n\n    st[0].insert(INF),st[1].insert(INF);\n    for(int i = 0; i < N; i++)\n    {\n        if(i)\n        {\n            dif[0] += R[i] - L[i];\n            dif[1] += R[i - 1] - L[i - 1];\n        }\n\n        int idl = 0,idr = 0;\n        itel = st[0].begin();\n        for(int j = 0; j < 2; j++)\n        {\n            if(*itel < -L[i] - dif[0])\n            {\n                itel++;\n                idl++;\n            }\n        }\n        iter = st[1].begin();\n        for(int j = 0; j < 2; j++)\n        {\n            if(*iter < L[i] - dif[1])\n            {\n                iter++;\n                idr++;\n            }\n        }\n\n        if(idl)ans += -L[i] - dif[0] - *st[0].begin();\n        if(idr)ans += L[i] - dif[1] - *st[1].begin();\n        if(idl == idr)\n        {\n            st[0].insert(-L[i] - dif[0]);\n            st[0].insert(-L[i] - dif[0]);\n            mov(0);\n        }\n        if(idl)\n        {\n            st[0].insert(-L[i] - dif[0]);\n            st[0].insert(-L[i] - dif[0]);\n            mov(0);\n        }\n        if(idr)\n        {\n            st[1].insert(L[i] - dif[1]);\n            st[1].insert(L[i] - dif[1]);\n            mov(1);\n        }\n    }\n\n    printf(\"%lld\\n\",ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAXN=1e5+10;\nint n,l[MAXN],r[MAXN];\nll ls,rs,res=0;\npriority_queue<ll> L;\npriority_queue<ll,vector<ll>,greater<ll> > R;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&l[i],&r[i]);\n    L.push(l[1]);R.push(l[1]);\n    for(int i=2;i<=n;i++)\n    {\n        ls-=r[i]-l[i];rs+=r[i-1]-l[i-1];\n        ll lb=L.top()+ls,rb=R.top()+rs;\n        if(l[i]<lb)\n        {\n            res+=lb-l[i];R.push(lb-rs);\n            L.push(l[i]-ls);L.push(l[i]-ls);L.pop();\n        }\n        else if(l[i]>rb)\n        {\n            res+=l[i]-rb;L.push(rb-ls);\n            R.push(l[i]-rs);R.push(l[i]-rs);R.pop();\n        }\n        else\n        {\n            L.push(l[i]-ls);\n            R.push(l[i]-rs);\n        }\n    }\n    printf(\"%lld\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\npair<int, int> x[100001];\nint n, dp[401][401];\n\nint main(){\n\tscanf(\"%d\", &n);\n        assert(n <= 400);\n\tf(i, 1, n + 1)scanf(\"%d%d\", &x[i].first, &x[i].second);\n\tf(i, 1, n + 1)f(j, 1, 401)dp[i][j] = 1e9;\n\tf(i, 1, n + 1)f(j, 1, 400){\n\t\tint c = abs(x[i].first - j);\n\t\tint mn = 1e9, d = x[i].second - x[i].first;\n\t\tf(k, j, j + d + 1)mn = min(mn, dp[i - 1][k] + c);\n\t\tf(k, j, j + d + 1)dp[i][k] = min(dp[i][k], mn);\n\t}\n\tint an = 1e9;\n\tf(i, 1, 401)an = min(an, dp[n][i]);\n\tprintf(\"%d\\n\", an);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N;\nll L[100010],R[100010],len[100010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  rep(i,N){\n    cin>>L[i]>>R[i];\n    len[i]=R[i]-L[i];\n  }\n\n  ll ladd=0,radd=0;\n  multiset<ll> ls,rs;\n  ls.insert(L[0]);\n  rs.insert(L[0]);\n  ll h=0;\n  repl(i,1,N){\n    ll l=*ls.rbegin(),r=*rs.begin();\n    ladd-=len[i];\n    radd+=len[i-1];\n    l+=ladd; r+=radd;\n    if(L[i]<l){\n      ls.insert(L[i]-ladd); ls.insert(L[i]-ladd);\n      ll l1=*ls.rbegin();\n      ls.erase(ls.find(*ls.rbegin()));\n      ll l2=*ls.rbegin();\n      h+=l1-l2;\n      rs.insert(l-radd);\n    }else if(L[i]>r){\n      rs.insert(L[i]-radd); rs.insert(L[i]-radd);\n      ll r1=*rs.begin();\n      rs.erase(rs.find(*rs.begin()));\n      ll r2=*rs.begin();\n      h+=r2-r1;\n      ls.insert(r-ladd);\n    }else{\n      ls.insert(L[i]-ladd); rs.insert(L[i]-radd);\n    }\n\n    /*\n    dbg(h);\n    dbg(ladd); dbg(radd);\n    cout<<\"L : \";\n    for(ll a : ls){\n      cout<<a+ladd<<\" \";\n    }\n    cout<<endl;\n    cout<<\"R : \";\n    for(ll a : rs){\n      cout<<a+radd<<\" \";\n    }\n    cout<<endl;*/\n  }\n\n  cout<<h<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n;\n  R n;\n  P a[n];\n  rep(i,n) cin >> a[i].F >> a[i].S;\n  sort(a,a+n);\n  ll ans=MAX;\n  rep(k,n) {\n    REP(t,-400,401) {\n      ll x=a[k].S+t,y=a[k].F+t,sum=abs(t);\n      rep(i,n) {\n        if(i==k) continue;\n        if(x<a[i].F) {\n          sum+=a[i].F-x;\n          x+=a[i].S-a[i].F;\n        } else if(a[i].S<y) {\n          sum+=y-a[i].S;\n          y-=a[i].S-a[i].F;\n        } else if(y<=a[i].F) x=max(x,(ll)a[i].S);\n        else y=min(y,(ll)a[i].F);\n      }\n      ans=min(ans,sum);\n    }\n  }\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long\n\nusing namespace std;\n\nconst int N = 1e5+5;\n\nint n;\nint l[N], r[N];\nlong high, lz_l, lz_r;\nmultiset<long> L, R;\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", l + i, r + i), r[i] -= l[i];\n    for(int i = 1; i <= n; i++) {\n        high += l[i];\n        L.emplace(l[i] + lz_l), R.emplace(l[i] - lz_r);\n        while(!L.empty() && !R.empty() && *L.rbegin() - lz_l > *R.begin() + lz_r) {\n            int l = *L.rbegin(), r = *R.begin();\n            L.erase(L.find(l)), R.erase(R.find(r));\n            L.emplace(r + lz_r + lz_l), R.emplace(l - lz_l - lz_r);\n        }\n        long pv = 0;\n        while(!L.empty() && *L.begin() - lz_l - r[i + 1] <= 0) {\n            high -= abs(*L.begin() - lz_l - pv) * L.size();\n            pv = *L.begin() - lz_l;\n            L.erase(L.begin());\n        }\n        high -= abs(pv - r[i + 1]) * L.size();\n        lz_l += r[i + 1], lz_r += r[i];\n    }\n    long m = L.size(), pv = 0;\n    for(long x : L) {\n        high -= abs(x - lz_l - pv) * m--;\n        pv = x - lz_l;\n    }\n    printf(\"%lld\\n\", high);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nmultiset<long long>L;\nmultiset<long long>R;\nint p[110000];\nint q[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t}\n\tlong long lx=0;\n\tlong long rx=0;\n\tlong long ret=0;\n\tL.insert(p[0]);\n\tR.insert(p[0]);\n\tfor(int i=1;i<a;i++){\n\t\tlx-=q[i]-p[i];\n\t\trx+=q[i-1]-p[i-1];\n\t\tlong long ll=*(L.rbegin());\n\t\tlong long rr=*(R.begin());\n\t\tll+=lx;\n\t\trr+=rx;\n\t\tif(ll<=p[i]&&p[i]<=rr){\n\t\t\tL.insert(p[i]-lx);\n\t\t\tR.insert(p[i]-rx);\n\t\t}else if(rr<p[i]){\n\t\t\tR.insert(p[i]-rx);\n\t\t\tR.insert(p[i]-rx);\n\t\t\tlong long val=*(R.begin())+rx;\n\t\t\tret+=p[i]-val;\n\t\t\tR.erase(R.begin());\n\t\t\tL.insert(val-lx);\n\t\t}else{\n\t\t\tL.insert(p[i]-lx);\n\t\t\tL.insert(p[i]-lx);\n\t\t\tlong long val=*(L.rbegin())+lx;\n\t\t\tret+=val-p[i];\n\t\t\tL.erase(--(L.end()));\n\t\t\tR.insert(val-rx);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1010\n#define INF 100000010\nusing namespace std;\nint n,dp[N][N], l[N], r[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nint main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i ++)\n\t\tl[i] = read(), r[i] = read();\n\n\tfor (int i = 1; i <= n; i ++)\n    \tfor (int j = 0; j < N; j ++)\n    \t{\n\t\t    dp[i][j] = INF;\n\t\t    for (int k = max(0, j - (r[i - 1] - l[i - 1])); k <= min(N - 1, j + r[i] - l[i]); k ++)\n\t\t        dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n     \t\tdp[i][j] += abs(l[i] - j);\n    \t}\n\tcout << *min_element(dp[n], dp[n] + N) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define error(args...) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nint main(){\n    iostream_init();\n    int N;\n    while(cin >> N) {\n        assert(N <= 400);\n        const int MAX_N = 402;\n        const int MAX_L = 802;\n        int dp[MAX_N][MAX_L] = {};\n        REP(i, MAX_N) REP(j, MAX_L) dp[i][j] = INT_MAX / 2 - 1;\n        vector<int> L(N), R(N);\n        vector<int> W(N);\n        REP(i, N){\n            cin >> L[i] >> R[i];\n            assert(L[i] <= 400);\n            assert(R[i] <= 400);\n        }\n        REP(i, N) W[i] = R[i] - L[i];\n\n        REP(i, N) {\n            REP(f, MAX_L) REP(t, MAX_L) {\n                if(i == 0 || !(f + W[i-1] < t || t + W[i] < f)) {\n                    int last = (i == 0 ? 0 : dp[i-1][f]);\n                    dp[i][t] = min(dp[i][t], last + abs(t - L[i]));\n                }\n            }\n        }\n\n        int ans = 1e9;\n        REP(i, MAX_L) ans = min(ans, dp[N-1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nint x[maxn], y[maxn], sz[maxn];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i], sz[i] = y[i] - x[i];\n\tlong long ans = 0, dl = 0, dr = 0;\n\tmultiset<long long> l, r;\n\tl.insert(x[0]);\n\tr.insert(x[0]);\n\tfor(int i = 1; i < n; i++){\n\t\tdl -= sz[i];\n\t\tdr += sz[i - 1];\n\t\tlong long p = x[i], cl = *prev(l.end()) + dl, cr = *r.begin() + dr;\n\t\tif(cl <= p && p <= cr){\n\t\t\tl.insert(p - dl);\n\t\t\tr.insert(p - dr);\n\t\t} else if(p < cl){\n\t\t\tans += cl - p;\n\t\t\tl.erase(prev(l.end()));\n\t\t\tl.insert(p - dl);\n\t\t\tl.insert(p - dl);\n\t\t\tr.insert(cl - dr);\n\t\t} else {\n\t\t\tans += p - cr;\n\t\t\tr.erase(r.begin());\n\t\t\tr.insert(p - dr);\n\t\t\tr.insert(p - dr);\n\t\t\tl.insert(cr - dl);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 200010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nmultiset<ll> L, R;\nint A[MAX_N], B[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i] >> B[i];\n\tll a = A[0], b = A[0];\n\tL.insert(A[0]); R.insert(A[0]);\n\tll ans = 0;\n\trep(i, 1, N) {\n\t\ta -= B[i] - A[i];\n\t\tb += B[i - 1] - A[i - 1];\n\t\t//debug(a, b);\n\t\tll l = *L.rbegin(), r = *R.begin();\n\t\tif(a <= A[i] && A[i] <= b) {\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\ta = A[i]; b = A[i];\n\t\t}\n\t\telse if(A[i] < a) {\n\t\t\tans += abs(A[i] - a);\n\t\t\tL.insert(A[i] - (a - l));\n\t\t\tll le = *L.rbegin() + (a - l);\n\t\t\tL.erase(--L.end());\n\t\t\tR.insert(le - (b - r));\n\t\t\ta = *L.rbegin() + (a - l);\n\t\t\tb = le;\n\t\t}\n\t\telse {\n\t\t\tans += abs(A[i] - b);\n\t\t\tR.insert(A[i] - (b - r));\n\t\t\tll rb = *R.begin() + (b - r);\n\t\t\tR.erase(R.begin());\n\t\t\tL.insert(rb - (a - l));\n\t\t\ta = rb;\n\t\t\tb = *R.begin() + (b - r);\n\t\t}\n\t\t//debug(a, vi(all(L)));\n\t\t//debug(b, vi(all(R)));\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\ntypedef long long ll;\n//////////////////////\n\nint const N = 441;\n\nvector<ll> lp, rp;\nint l[N], r[N], n;\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n) cin >> l[i] >> r[i];\n\tll ans = 0;\n\n\tlp.pb(l[0]);\n\trp.pb(r[0]);\n\trep(i, 1, n){\n\t\tll pl = r[i-1] - l[i-1];\n\t\tll cl = r[i] - l[i];\n\t\trep(j, 0, sz(rp)) rp[j] += pl;\n\t\trep(j, 0, sz(lp)) lp[j] -= cl;\n\t\tsort(rp.begin(), rp.end());\n\t\tsort(lp.begin(), lp.end());\n\t\tif(l[i] >= lp.back() && l[i] <= rp[0]){\n\t\t\tlp.pb(l[i]);\n\t\t\trp.pb(l[i]);\n\t\t}else if(l[i] >= rp[0]){\n\t\t\tans += (l[i] - rp[0]);\n\t\t\tll tmp = rp[0];\n\t\t\tlp.pb(tmp);\n\t\t\trp.erase(rp.begin());\n\t\t\trp.pb(l[i]);\n\t\t\trp.pb(l[i]);\n\t\t}else{\n\t\t\tans += (lp.back() - l[i]);\n\t\t\tll tmp = lp.back();\n\t\t\tlp.erase(lp.begin() + sz(lp) - 1);\n\t\t\tlp.pb(l[i]);\n\t\t\tlp.pb(l[i]);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nstruct Set {\n  multiset<LL> st;\n  LL off;\n\n  void Add(LL v) {\n    off += v;\n  }\n\n  LL L(void) {\n    return off + *st.begin();\n  }\n\n  LL R(void) {\n    return off + *st.rbegin();\n  }\n\n  void Insert(LL v) {\n    st.insert(v-off);\n  }\n\n  void Erase(LL v) {\n    v -= off;\n    auto itr = st.find(v);\n    assert(itr != st.end());\n    st.erase(itr);\n  }\n\n  void Show() {\n    for (LL v : st) {\n      printf(\"%lld \", v+off);\n    }\n    puts(\"\");\n  }\n};\n\nint N;\nLL L[114514];\nLL R[114514];\nLL W[114514];\nSet sw[2];\n\nint main() {\n  scanf(\"%d\", &N);\n  rep(i, N) {\n    scanf(\"%lld%lld\", &L[i], &R[i]);\n    W[i] = R[i] - L[i];\n  }\n\n  rep(i, 2) sw[i].Insert(L[0]);\n\n  LL ans = 0;\n  reps(i, 1, N) {\n    sw[0].Add(-W[i]);\n    sw[1].Add(W[i-1]);\n\n    //printf(\"After Adjust\\n\");\n    //rep(j, 2) { \n    //  sw[j].Show();\n    //}\n\n    LL x = sw[0].R();\n    LL y = sw[1].L();\n    if (L[i] < x) {\n      ans += x-L[i];\n    } else if (y < L[i]) {\n      ans += L[i]-y;\n    }\n\n    sw[0].Insert(L[i]);\n    sw[0].Insert(L[i]);\n    while (sw[0].R() > sw[1].L() || sw[0].st.size() > sw[1].st.size()) {\n      LL v = sw[0].R();\n      sw[0].Erase(v);\n      sw[1].Insert(v);\n    }\n\n    while (sw[0].st.size() < sw[1].st.size()) {\n      LL v = sw[1].L();\n      sw[1].Erase(v);\n      sw[0].Insert(v);\n    }\n\n    //printf(\"After %d L=%lld R=%lld ans=%lld:\\n\", i, L[i], R[i], ans);\n    //rep(j, 2) { \n    //  sw[j].Show();\n    //}\n    assert(sw[0].st.size() == sw[1].st.size());\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint N;\nvector<pii> S;\nmultiset<ll> L, R;\nll C, lp, rp;\n\nint main() {\n    scanf(\"%d\", &N);\n    S.resize(N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &S[i].first, &S[i].second);\n    }\n    L.insert(-S[0].first);\n    R.insert(S[0].first);\n    C = lp = rp = 0;\n    for(int i = 1; i < N; i++) {\n        int plen = S[i - 1].second - S[i - 1].first;\n        int clen = S[i].second - S[i].first;\n        ll x = S[i].first;\n/*\n        set<int>::iterator it;\n        cout << \"L : \";\n        for(it = L.begin(); it != L.end(); it++) {\n            cout << -lp - *it << ' ';\n        }\n        cout << endl;\n        cout << \"R : \";\n        for(it = R.begin(); it != R.end(); it++) {\n            cout << rp + *it << ' ';\n        }\n        cout << endl;\n//*/\n        lp += clen;\n        rp += plen;\n\n        if(-lp - *L.begin() <= x && x <= rp + *R.begin()) {\n            L.insert(-lp - x);\n            R.insert(-rp + x);\n        }\n        else if(x < -lp - *L.begin()) {\n            ll tx = -lp - *L.begin();\n            L.erase(L.begin());\n            L.insert(-lp - x);\n            ll ttx = -lp - *L.begin();\n\n            R.insert(-rp + tx);\n            C += tx - ttx;\n        }\n        else if(rp + *R.begin() < x) {\n            ll tx = rp + *R.begin();\n            R.erase(R.begin());\n            R.insert(-rp + x);\n            ll ttx = rp + *R.begin();\n\n            L.insert(-lp - tx);\n            C += ttx - tx;\n        }\n    }\n    printf(\"%d\", C);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define iter(v, i) for (__typeof__((v).begin()) i = (v).begin(); i != (v).end(); i++)\n#define fast_io_without_cstdio ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define all(v) (v).begin(), (v).end()\n#define rep(i, s, e) for (int i = s; i < e; i++)\n\n// START for segment tree\n#define params int p, int L, int R\n#define housekeep int mid = (L + R) >> 1, left = p << 1, right = left | 1\n// END\n\n#ifdef __linux__\n#define gc getchar_unlocked\n#define pc putchar_unlocked\n#else\n#define gc getchar\n#define pc putchar\n#endif\n\n#if __cplusplus <= 199711L\ntemplate<class BidirIt>\nBidirIt prev(BidirIt it, typename iterator_traits<BidirIt>::difference_type n = 1) {\n    advance(it, -n);\n    return it;\n}\n\ntemplate<class ForwardIt>\nForwardIt next(ForwardIt it, typename iterator_traits<ForwardIt>::difference_type n = 1) {\n    advance(it, n);\n    return it;\n}\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef long double ldouble;\n\nconst double EPS = 1e-9;\nconst double PI = 3.141592653589793238462;\n\ntemplate<typename T>\ninline T sq(T a) { return a * a; }\n\n//#ifdef LOCAL_MACHINE\n//#endif\n\nconst int MAXN = 1e5 + 5;\n\nstruct myds {\n    multiset<ll> myset;\n    ll lazy = 0;\n\n    inline void inc(int x) {\n        lazy += x;\n    }\n\n    void add(ll x) {\n        myset.insert(x - lazy);\n    }\n\n    void rem(ll x) {\n        myset.erase(myset.find(x - lazy));\n    }\n\n    ll get_max() {\n        return *prev(myset.end()) + lazy;\n    }\n\n    ll get_min() {\n        return *myset.begin() + lazy;\n    }\n} one, two;\nint l[MAXN], r[MAXN], len[MAXN];\n\nint main() {\n    //freopen(\"\", \"r\", stdin);\n    //freopen(\"\", \"w\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d %d\", &l[i], &r[i]);\n        len[i] = r[i] - l[i];\n    }\n    ll ans = 0;\n    one.add(r[1]);\n    two.add(r[1]);\n    //puts(\"OK\");\n    for (int i = 2; i <= n; i++) {\n        one.inc(-len[i - 1]);\n        two.inc(len[i]);\n        ll opt_l = one.get_max();\n        ll opt_r = two.get_min();\n        //printf(\"for i = %d opt_l = %lld and opt_r = %lld\\n\", i, opt_l, opt_r);\n        if (opt_l <= ( ll )r[i] && ( ll )r[i] <= opt_r) {\n            one.add(r[i]);\n            two.add(r[i]);\n        } else if (( ll )r[i] < opt_l) {\n            one.add(r[i]);\n            one.add(r[i]);\n            one.rem(opt_l);\n            two.add(opt_l);\n            ans += abs(opt_l - r[i]);\n        } else {\n            two.add(r[i]);\n            two.add(r[i]);\n            two.rem(opt_r);\n            one.add(opt_r);\n            ans += abs(opt_r - r[i]);\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000 + 5\n#define int long long\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, nl, nr, al, ar, ans, l[N], r[N], len[N];\npriority_queue <int> Qs;\npriority_queue <int, vector <int>, greater <int> >  Qb;\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nsigned main(){\n    n = read();\n    rep(i, 1, n) l[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n    Qs.push(l[1]), Qb.push(l[1]);\n    rep(i, 2, n){\n        al += r[i] - l[i], ar += r[i - 1] - l[i - 1];\n        nl = Qs.top() - al, nr = Qb.top() + ar;\n        if(l[i] < nl) ans += nl - l[i], Qs.pop(), Qs.push(l[i] + al), Qb.push(nl - ar);\n        else if(l[i] > nr) ans += l[i] - nr, Qb.pop(), Qs.push(nr + al), Qb.push(l[i] - ar);\n        else Qs.push(l[i] + al), Qb.push(l[i] - ar);\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\npriority_queue <ll> L;\npriority_queue <ll,vector<ll>,greater<ll>> R;\nint l[100005],r[100005],n;\nll dl,dr,ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%d%d\",&l[1],&r[1]);\n\tL.push(l[1]),R.push(l[1]);\n\tfor (int i=2;i<=n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tint len=r[i]-l[i],len1=r[i-1]-l[i-1];\n\t\tdl+=len,dr+=len1;\n\t\tll lmin=L.top()-dl,rmin=R.top()+dr;\n\t\tif (l[i]<lmin){\n\t\t\tans=ans+(lmin-l[i]);\n\t\t\tL.pop(),R.push(lmin-dr);\n\t\t\tL.push(l[i]+dl),L.push(l[i]+dl);\n\t\t}else\n\t\tif(l[i]>rmin){\n\t\t\tans=ans+(l[i]-rmin);\n\t\t\tR.pop(),L.push(rmin+dl);\n\t\t\tR.push(l[i]-dr),R.push(l[i]-dr);\n\t\t}else{\n\t\t\tL.push(l[i]+dl),R.push(l[i]-dr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long n, l[100009], r[100009], L, R, sum;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (i == 1) { L = l[i]; R = l[i]; }\n\t\telse {\n\t\t\tL -= (r[i] - l[i]); R += (r[i - 1] - l[i - 1]);\n\t\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\t\tL = l[i]; R = l[i];\n\t\t\t}\n\t\t\telse if (R < l[i]) {\n\t\t\t\tsum += (l[i] - R);\n\t\t\t\tint LL = R, RR = l[i];\n\t\t\t\tL = LL; R = RR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += (L - l[i]);\n\t\t\t\tint LL = l[i], RR = L;\n\t\t\t\tL = LL; R = RR;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long lli;\nlli n;\nvector<lli> r,l;\npriority_queue<lli> pqr;\npriority_queue<lli,vector<lli>,greater<lli> > pql;\nlli ans;\nint main(){\n    cin >> n;\n    r = vector<lli> (n);l = vector<lli> (n);\n    for(lli i = 0;i < n;i++) cin >> l[i] >> r[i];\n    pqr.push(l[0]);\n    pql.push(l[0]);\n    lli tr = 0,tl = 0;\n    ans = 0;\n    for(lli i = 1;i < n;i++){\n        tl += r[i-1] - l[i-1];tr -= r[i] - l[i];\n        if(pqr.top() > l[i] - tr)       ans += abs(pqr.top() - (l[i] - tr)),pqr.push(l[i] - tr),pqr.push(l[i] - tr),pql.push(pqr.top() + tr - tl),pqr.pop();\n        else if(pql.top() < l[i] - tl)  ans += abs(pql.top() - (l[i] - tl)),pql.push(l[i] - tl),pql.push(l[i] - tl),pqr.push(pql.top() + tl - tr),pql.pop();\n        else pqr.push(l[i] - tr),pql.push(l[i] - tl);\n        //cout << pqr.top() + tr << \" \" << pql.top() + tl << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INT long long\nusing namespace std;\n\nINT n, dt[440][440], l[440], r[440], ans = 987654321;\n\nint main()\n{\n    cin>>n;\n    memset(dt, 0x3f, sizeof(dt));\n    for(int i = 0 ; i < n ; i++ ) cin>>l[i]>>r[i];\n    for(int i = 0 ; i < n ; i++ ) for(int j = 1 ; j <= 400-l[i] ; j++ )\n    {\n        if( i == 0 ) dt[i][j] = abs(j-l[i]);\n        else for(int k = 1 ; k <= 400-l[i-1] ; k++ )\n        {\n            if( (j <= k and k <= j+(r[i]-l[i])) or (k <= j and j <= k+(r[i-1]-l[i-1])) )\n                dt[i][j] = min(dt[i][j], dt[i-1][k] + abs(j-l[i]) );\n        }\n    }\n    for(int i = 1 ; i <= 400 ; i++ ) ans = min( ans , dt[n-1][i] );\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> dat[405];\nint dp[405][405];\nbool v[405][405];\nint n;\n\nint D(int idx, int d)\n{\n\tif (v[idx][d] == false)\n\t{\n\t\tv[idx][d] = true;\n\t\tdp[idx][d] = 1e9;\n\n\t\tif (idx == n - 1) return dp[idx][d] = abs(dat[idx].first - d);\n\n\t\tfor (int i = 1; i <= 400; i++)\n\t\t{\n\t\t\tint r = i + (dat[idx + 1].second - dat[idx + 1].first);\n\t\t\tif (max(i, d) > min(r, d + dat[idx].second - dat[idx].first)) continue;\n\n\t\t\tdp[idx][d] = min(dp[idx][d], D(idx + 1, i) + abs(dat[idx].first - d));\n\t\t}\n\t}\n\n\treturn dp[idx][d];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d%d\", &dat[i].first, &dat[i].second);\n\n\tif (n > 400) return 0;\n\n\tint ans = 1e9;\n\tfor (int i = 1; i <= 400; i++) ans = min(ans, D(0, i));\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\npi ps[100005];\nint main(){\n  cin>>n;\n  REP(i,n) scanf(\"%d%d\",&ps[i].fr,&ps[i].sc);\n\n  multiset<lint> L,R;\n  lint offL=0,offR=0;\n  L.insert(ps[0].fr);R.insert(ps[0].fr);\n  lint base=0;\n  for(int i=1;i<n;++i){\n    offR+=ps[i-1].sc-ps[i-1].fr;\n    offL+=ps[i].sc-ps[i].fr;\n\n    lint r=*R.begin()+offR,l=*(--L.end())-offL;\n    if(ps[i].fr<=r && l<=ps[i].fr){\n      L.insert(ps[i].fr+offL);\n      R.insert(ps[i].fr-offR);\n    }else if(ps[i].fr<l){\n      base+=abs(l-ps[i].fr);\n      L.erase(--L.end());\n      R.insert(l-offR);\n      L.insert(ps[i].fr+offL);\n      L.insert(ps[i].fr+offL);\n    }else{\n      base+=abs(r-ps[i].fr);\n      R.erase(R.begin());\n      L.insert(r+offL);\n      R.insert(ps[i].fr-offR);\n      R.insert(ps[i].fr-offR);\n    }\n  }\n  cout<<base<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint n;\nint l[100010],r[100010];\nint memo[410][410][410];\nconst int inf=1<<28;\n\nint rec(int pos,int cl,int cr){\n\tif(pos==n-1) return abs(l[pos]-cl);\n\tint &ret=memo[pos][cl][cr];\n\n\tint cost=abs(cl-l[pos]),cmin=inf;\n\n\tconst int nlen=abs(r[pos+1]-l[pos+1]);\n\trep(nl,1,401){\n\t\tconst int nr=nl+nlen;\n\t\tif(nr>400) break;\n\t\tif(nr<cl or cr < nl) continue;\n\t\tchmin(cmin,rec(pos+1,nl,nr));\n\t}\n\tret=cost+cmin;\n\treturn ret;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> l[i] >> r[i];\n\n\tif(n>400) return 0;\n\n\tconst int len=abs(r[0]-l[0]);\n\tint ans=inf;\n\trep(cl,1,401){\n\t\tconst int cr=cl+len;\n\t\tif(cr>400) break;\n\t\tchmin(ans,rec(0,cl,cr));\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    int N;cin>>N;\n\n    priority_queue<int>que1;\n    priority_queue<int,vector<int>,greater<int>>que2;\n    int ad1=0,ad2=0;\n    int val=0;\n\n    int l,r;\n    cin>>l>>r;\n    que1.push(l);\n    que2.push(l);\n    int pre=r-l;\n\n    for(int i=1;i<N;i++){\n        cin>>l>>r;\n        ad1-=r-l;\n        ad2+=pre;\n\n        pre=r-l;\n\n        if(l<que1.top()+ad1){\n            que1.push(l-ad1);\n            que1.push(l-ad1);\n\n            val+=que1.top();\n            que2.push(que1.top()+ad1-ad2);\n            que1.pop();\n            val-=que1.top();\n\n            val+=que1.top()+ad1-l;\n        }\n        else if(l<=que2.top()+ad2){\n            que1.push(l-ad1);\n            que2.push(l-ad2);\n        }\n        else{\n            que2.push(l-ad2);\n            que2.push(l-ad2);\n\n            val-=que2.top();\n            que1.push(que2.top()+ad2-ad1);\n            que2.pop();\n            val+=que2.top();\n\n            val+=l-(que2.top()+ad2);\n        }\n    }\n    cout<<val<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nconst int inf = 1ll << 60;\nconst int MAX = 3e4;\nstruct segtree {\n\tint N, dat[2 * MAX];\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++)\n\t\t\tdat[i] = inf;\n\t}\n\t// update k th element\n\tvoid update(int k, int a) {\n\t\tk += N - 1; // leaf\n\t\tdat[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\t// min [a, b)\n\tint query(int a, int b) { return query(a, b, 0, 0, N); }\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return inf;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn min(query(a, b, k * 2 + 1, l, m), query(a, b, k * 2 + 2, m, r));\n\t}\n};\n\nvoid calc() {\n\tint n; cin >> n;\n\tsegtree seg(401);\n\tint pd = 0;\n\trep(i, n) {\n\t\tint l, r; cin >> l >> r;\n\t\tint d = r - l;\n\t\tV next(405);\n\t\trep(to, 401) {\n\t\t\tint m;\n\t\t\tm = i == 0 ? 0 : seg.query(to - pd, to + d + 1);\n\t\t\tnext[to] = m + abs(to - l);\n\t\t}\n\t\trep(to, 401) {\n\t\t\tseg.update(to, next[to]);\n\t\t}\n\t\tpd = d;\n\t}\n\tcout << seg.query(0, 400) << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcalc();\n#ifdef _MSC_VER\n\tsystem(\"pause\");\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> point;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 2005\n#define oo 1000000000000000007LL\n#define sz(a) (int)a.size()\n#define left aofnojaef\n#define right aionfeoangrou\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\ntemplate<typename T>\nstruct slopeQueue {\nprivate:\n    T pq;\n    ll delta;\npublic:\n    void push(ll x) {pq.push(x-delta);}\n    void update(ll x) {delta += x;}\n    ll top() {return pq.top() + delta;}\n    void pop() {pq.pop();}\n    void print() {\n        T tmp = pq;\n        while (!tmp.empty()) {\n            cout << tmp.top() + delta << \" \";\n            tmp.pop();\n        }\n        cout << endl;\n    }\n};\n\nll cost(ll l, ll r, ll x) {\n    if (x < l) return l-x;\n    if (x > r) return x-r;\n    return 0;\n}\n\nint main () {\n    int n; scanf(\"%d\", &n);\n    vector<int> l(n), r(n);\n    fto(i, 0, n-1) scanf(\"%d%d\", &l[i], &r[i]);\n\n    slopeQueue<priority_queue<ll> > left;\n    slopeQueue<priority_queue<ll, vector<ll>, greater<ll> > > right;\n    left.push(l[0]);\n    right.push(l[0]);\n\n    ll ans = 0;\n    fto(i, 1, n-1) {\n        left.update(l[i]-r[i]);\n        right.update(r[i-1]-l[i-1]);\n\n        ans += cost(left.top(), right.top(), l[i]);\n\n        left.push(l[i]);\n        right.push(l[i]);\n\n        while (left.top() > right.top()) {\n            ll x = left.top(); left.pop();\n            ll y = right.top(); right.pop();\n            left.push(y); right.push(x);\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint L[100000], R[100000];\nint dp[401][501];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  if (N > 400) return 1;\n  rep(i, N) cin >> L[i] >> R[i];\n  rep(i, N) if (R[i]>500) return 1;\n\n  for (int i=1; i<=N; i++) {\n    for (int j=0; j<=500; j++) dp[i][j] = INF;\n  }\n  for (int i=0; i<N; i++) {\n    int w = i!=0?(R[i-1]-L[i-1]):0;\n    for (int j=0; j<=500; j++) {\n      if (dp[i][j] == INF) continue;\n      for (int k=max(0,j-(R[i]-L[i])); k<=min(j+w,500); k++) {\n        dp[i+1][k] = min(dp[i+1][k], dp[i][j] + abs(k-L[i]));\n      }\n    }\n  }\n  int m = INF;\n  for (int i=0; i<=500; i++) {\n    m = min(m, dp[N][i]);\n  }\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.01.2020 19:09:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> l(n), r(n);\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  multiset<long long> L, R;\n  long long sL = 0, sR = 0;\n  L.insert(l[0]);\n  R.insert(l[0]);\n  long long ans = 0;\n  for (int i = 1; i < n; i++) {\n    sL -= r[i] - l[i];\n    sR += r[i - 1] - l[i - 1];\n    long long xL = sL + *prev(L.end());\n    if (l[i] <= xL) {\n      ans += xL - l[i];\n      R.insert(xL - sR);\n      L.erase(prev(L.end()));\n      L.insert(l[i] - sL);\n      L.insert(l[i] - sL);\n      continue;\n    }\n    long long xR = sR + *R.begin();\n    if (l[i] >= xR) {\n      ans += l[i] - xR;\n      L.insert(xR - sL);\n      R.erase(R.begin());\n      R.insert(l[i] - sR);\n      R.insert(l[i] - sR);\n      continue;\n    }\n    L.insert(l[i] - sL);\n    R.insert(l[i] - sR);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,l[200005],r[200005];\nmultiset<ll>N,P;\nll sumN,sumP,ans;\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> l[i] >> r[i];\n\t\tif(i==1){\n\t\t\tN.insert(1LL*l[i]);\n\t\t\tP.insert(1LL*l[i]);\n\t\t}\n\t\telse{\n\t\t\tmultiset<ll>::iterator it = N.end(); it--;\n\t\t\tsumN += r[i]-l[i];\n\t\t\tsumP += r[i-1]-l[i-1];\n\t\t\tll v = (*it)-sumN;\n\t\t\tll v2 = (*P.begin())+sumP;\n\t\t\tif(v2<l[i]){\n\t\t\t\tans+=l[i]-v2;\n\t\t\t}\n\t\t\telse if(l[i]<v){\n\t\t\t\tans+=v-l[i];\n\t\t\t}\n\t\t\tif(v2<=l[i]){\n\t\t\t\tP.insert(l[i]-sumP);P.insert(l[i]-sumP);\n\t\t\t\tll x = (*P.begin())+sumP;\n\t\t\t\tP.erase(P.begin());\n\t\t\t\tN.insert(x+sumN);\n\t\t\t}\n\t\t\telse if(v>=l[i]){\n\t\t\t\tN.insert(l[i]+sumN);N.insert(l[i]+sumN);\n\t\t\t\tmultiset<ll>::iterator it = N.end(); it--;\n\t\t\t\tll x = (*it)-sumN;\n\t\t\t\tN.erase(it);\n\t\t\t\tP.insert(x-sumP);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tN.insert(l[i]+sumN); P.insert(l[i]-sumP);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n#define first fi\n#define second se\n#define sz(x) (int)x.size()\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9+7;\n\nconst int N = 405;\n\nint n, dp[N][N];\n\nint main() {\n    scanf(\"%d\", &n);\n    if (n > 400) return 0;\n    int l, r;\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d%d\", &l, &r);\n        for (int j = 0; j <= 400; j++) dp[i][j] = inf;\n        for (int j = 0; j <= 400; j++) {\n            if (r < j) {\n                for (int k = 0; k <= r - l; k++)\n                    if (j - k >= 0) dp[i][j - k] = min(dp[i][j - k], dp[i - 1][j] + abs(r - j));\n                for (int k = 0; k <= r - l; k++)\n                    if (j + k <= 400) dp[i][j + k] = min(dp[i][j + k], dp[i - 1][j] + abs(r - j) + k);\n            }\n            else if (l > j) {\n                for (int k = 0; k <= r - l; k++)\n                    if (j + k <= 400) dp[i][j + k] = min(dp[i][j + k], dp[i - 1][j] + abs(l - j));\n                for (int k = 0; k <= r - l; k++)\n                if (j - k >= 0) dp[i][j - k] = min(dp[i][j - k], dp[i - 1][j] + abs(l - j) + k);\n            } else {\n                for (int k = l; k <= r; k++) dp[i][k] = min(dp[i][k], dp[i - 1][j]);\n                for (int k = 0; k <= r - j; k++) if (l - k >= 0) dp[i][l - k] = min(dp[i][l - k], dp[i - 1][j] +k);\n                for (int k = 0; k <= j - l; k++) if (r + k <= 400) dp[i][r + k] = min(dp[i][r + k], dp[i - 1][j] + k);\n            }\n        }\n    }\n    int ans = inf;\n    for (int j = 0; j <= 400; j++) ans = min(ans, dp[n][j]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing namespace std::chrono;\n\nconst int LIM = 20;\nconst int INF = 1e+9;\n\nint main() {\n  auto start = high_resolution_clock::now();\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  assert(n <= 400);\n  vector<int> ans(LIM, 0), buf(LIM, INF);\n  vector<pair<int, int>> coords(n);\n  for (int i = 0; i < n; ++i)\n    cin >> coords[i].first >> coords[i].second;\n\n  for (int pl = 0; pl < LIM; ++pl) {\n    ans[pl] = abs(pl - coords[0].first);\n    cerr << ans[pl] << ' ';\n  }\n  cerr << endl;\n\n  for (int i = 1; i < n; ++i) {\n    int l = coords[i].first, r = coords[i].second;\n    int _l = coords[i - 1].first, _r = coords[i - 1].second, _len = _r - _l + 1;\n\n    buf.assign(LIM, INF);\n    for (int pl = 0, pr = r - l + 1; pr < LIM; ++pl, ++pr) {\n      int cost = abs(l - pl);\n      int _min = INF;\n      for (int p = max(pl - _len + 1, 0); p <= pr; ++p)\n        _min = min(_min, ans[p]);\n      cost += _min;\n\n      buf[pl] = cost;\n    }\n\n    swap(buf, ans);\n\n    for (int i = 0; i < LIM; ++i)\n      cerr << ans[i] << ' ';\n    cerr << endl;\n  }\n\n  int res = ans[0];\n  for (int i = 0; i < LIM; ++i)\n    res = min(res, ans[i]);\n  cout << res << endl;\n\n  cerr << \"Total execution time : \" << duration_cast<milliseconds>(high_resolution_clock::now() - start).count() << \" ms\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ll> point;\n#define F first\n#define S second\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n\ntemplate<typename T>\nstatic T randint(T lo, T hi) { return uniform_int_distribution<T>(lo, hi)(rng); }\n\n\nstruct treap\n{\n\tstruct node\n\t{\n\t\tnode *ch[2];\n\t\tll len, slen;\n\t\tint p, maxp, prio, sz, lazy;\n\n\t\tnode(int l, int p) : len(l), slen(l), p(p), maxp(p)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL;\n\t\t\tlazy = 0;\n\t\t\tsz = 1;\n\t\t\tprio = randint(0, (int)2e9);\n\t\t}\n\t} *root;\n\n\tnode* new_node(int l, int p)\n\t{\n\t\treturn new node(l, p);\n\t}\n\n\tint size(node *u)\n\t{\n\t\treturn u ? u->sz : 0;\n\t}\n\n\tint max_p(node *u)\n\t{\n\t\treturn u ? (u->maxp + u->lazy) : (-2e9);\n\t}\n\n\tll s_len(node *u)\n\t{\n\t\treturn u ? u->slen : 0;\n\t}\n\n\tvoid push(node *u)\n\t{\n\t\tif (u && u->lazy != 0)\n\t\t{\n\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\tif (u->ch[i])\n\t\t\t\t\tu->ch[i]->lazy += u->lazy;\n\n\t\t\tu->p += u->lazy;\n\t\t\tu->maxp += u->lazy;\n\t\t\tu->lazy = 0;\n\t\t}\n\t}\n\n\tnode* update(node *u)\n\t{\n\t\tif (u)\n\t\t{\n\t\t\tu->sz = size(u->ch[0]) + size(u->ch[1]) + 1;\n\t\t\tu->maxp = max({ max_p(u->ch[0]), max_p(u->ch[1]), u->p });\n\t\t\tu->slen = s_len(u->ch[0]) + s_len(u->ch[1]) + u->len;\n\t\t}\n\t\treturn u;\n\t}\n\n\tpair<node*, node*> split(node* u, int k)\n\t{// split for the kth first elements\n\t\tpush(u);\n\n\t\tif (!u)\n\t\t\treturn { u, u };\n\n\t\tif (size(u->ch[0]) >= k)\n\t\t{\n\t\t\tauto s = split(u->ch[0], k);\n\t\t\tu->ch[0] = s.second;\n\t\t\treturn { s.first, update(u) };\n\t\t}\n\n\t\tauto s = split(u->ch[1], k - size(u->ch[0]) - 1);\n\t\tu->ch[1] = s.first;\n\t\treturn { update(u), s.second };\n\t}\n\n\tnode* merge(node *u, node *v)\n\t{\n\t\tpush(u), push(v);\n\n\t\tif (!u || !v)\n\t\t\treturn u ? u : v;\n\n\t\tif (u->prio > v->prio)\n\t\t{\n\t\t\tu->ch[1] = merge(u->ch[1], v);\n\t\t\treturn update(u);\n\t\t}\n\n\t\tv->ch[0] = merge(u, v->ch[0]);\n\t\treturn update(v);\n\t}\n\n\tpair<node*, node*> split1(node* u)\n\t{\n\t\tpush(u);\n\n\t\tif (!u)\n\t\t\treturn { u, u };\n\n\t\tif (max(max_p(u->ch[0]), u->p) >= 0)\n\t\t{\n\t\t\tauto s = split1(u->ch[0]);\n\t\t\tu->ch[0] = s.second;\n\t\t\treturn { s.first, update(u) };\n\t\t}\n\n\t\tauto s = split1(u->ch[1]);\n\t\tu->ch[1] = s.first;\n\t\treturn { update(u), s.second };\n\t}\n\n\tpair<node*, node*> split2(node* u, ll k)\n\t{\n\t\tpush(u);\n\n\t\tif (!u)\n\t\t\treturn { u, u };\n\n\t\tif (s_len(u->ch[0]) + u->len >= k)\n\t\t{\n\t\t\tauto s = split2(u->ch[0], k);\n\t\t\tu->ch[0] = s.second;\n\t\t\treturn { s.first, update(u) };\n\t\t}\n\n\t\tauto s = split2(u->ch[1], k - s_len(u->ch[0]) - u->len);\n\t\tu->ch[1] = s.first;\n\t\treturn { update(u), s.second };\n\t}\n\n\tvoid dfs(node *u, ll &x, ll &y)\n\t{\n\t\tif (!u) return;\n\n\t\tpush(u);\n\n\t\tdfs(u->ch[0], x, y);\n\n\t\tif (u->p < 0)\n\t\t{\n\t\t\tx += u->len;\n\t\t\ty += u->len * u->p;\n\t\t}\n\n\t\tdfs(u->ch[1], x, y);\n\t}\n\n\ttreap() : root(NULL) {}\n};\n\nstruct info\n{\n\tll l, o;\n};\n\nint main()\n{\n\t#ifdef DGC\n\t\tfreopen(\"a.txt\", \"r\", stdin);\n\t\t//freopen(\"b.txt\", \"w\", stdout);\n\t#endif\n\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<info> a(n);\n\tfor (auto &i : a)\n\t{\n\t\tcin >> i.o >> i.l;\n\t\ti.l -= i.o;\n\t}\n\n\tll x = 0, y = a[0].o;\n\n\ttreap t;\n\tt.root = t.merge(t.root, t.new_node(a[0].o, -1));\n\tt.root = t.merge(t.root, t.new_node(1e9+5, +1));\n\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tauto s = t.split1(t.root);\n\t\tt.root = t.merge(t.merge(s.first, t.new_node(a[i].l + a[i-1].l, 0)), s.second);\n\n\t\tx -= a[i].l;\n\t\ty += a[i].o - x;\n\n\t\ts = t.split2(t.root, a[i].o - x + 1);\n\t\tauto s2 = t.split(s.second, 1);\n\t\tll l = t.s_len(s.first);\n\t\tif (l < a[i].o - x) s.first = t.merge(s.first, t.new_node(a[i].o - x - l, t.max_p(s2.first)));\n\t\tif (l + s2.first->len > a[i].o - x) s2.second = t.merge(t.new_node(l + s2.first->len - (a[i].o - x), t.max_p(s2.first)), s2.second);\n\t\t--s.first->lazy;\n\t\t++s2.second->lazy;\n\t\tt.root = t.merge(s.first, s2.second);\n\t}\n\n\tt.dfs(t.root, x, y);\n\tcout << y << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll N;\n    cin >> N;\n\n    assert(N <= 400);\n\n    struct Rect {\n        ll l, r;\n        ll width() {\n            return r - l;\n        }\n    };\n\n    constexpr ll MAX = 400;\n\n    vector<Rect> rects(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> rects[i].l >> rects[i].r;\n        assert(rects[i].r <= MAX);\n    }\n\n    vector<vector<ll>> dp(N + 1, vector<ll>(MAX + 1, LLONG_MAX / 4));\n    for (ll j = 0; j <= MAX; j++) {\n        dp[0][j] = 0;\n    }\n    for (ll i = 1; i <= N; i++) {\n        for (ll j = 0; j <= MAX; j++) {\n            for (ll k = max(j - (i == 1 ? 0 : rects[i - 2].width()), (ll)0); k <= min(j + rects[i - 1].width(), MAX); k++) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(rects[i - 1].l - j));\n            }\n        }\n    }\n\n    cout << *min_element(dp[N].begin(), dp[N].end()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n// #include <unordered_map>\n// #include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n\n#ifdef ONLINE_JUDGE\n#define link relink\n#endif\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef long double ld;\n\ninline void EnableFileIO(const string &fileName, bool local = 0) {\n  if (fileName.empty()) return;\n  if (local) {\n    freopen((fileName + \".in\").c_str(), \"r\", stdin);\n    freopen((fileName + \".out\").c_str(), \"w\", stdout);\n    return;\n  }\n#ifdef ONLINE_JUDGE\n  freopen((fileName + \".in\").c_str(), \"r\", stdin);\n  freopen((fileName + \".out\").c_str(), \"w\", stdout);\n#endif\n}\n\nconst int INF = (1 << 30) - 1;\nconst LL LINF = (1LL << 61) - 1;\nconst double EPS = 1e-10, PI = acos(-1);\nconst int N = 805;\n\nint n, k;\nint l[N], r[N];\nint dp[N][N];\n\nint main() {\n  // srand((int)time(0));\n  // printf(\"Hello, world!\\n\");\n  // EnableFileIO(\"\");\n\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  l[0] = 0, r[0] = N;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < N; j++) {\n      // current is j,j+r[i]-l[i]\n      dp[i][j] = INF;\n      for (int k = max(0, j - (r[i - 1] - l[i - 1]));\n           k <= min(N - 1, j + r[i] - l[i]); k++) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][k]);\n      }\n      dp[i][j] += abs(l[i] - j);\n    }\n  }\n\n  cout << *min_element(dp[n], dp[n] + N) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <string>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n#define FORD(i, a, b) for (int i = (a), _b = (b); i >= _b; --i)\n#define REP(i, a) for (int i = 0, _a = (a); i < _a; ++i)\n#define REPD(i,n) for(int i = (n)-1; i >= 0; --i)\n\n#define DEBUG(X) { cerr << #X << \" = \" << (X) << endl; }\n#define PR(A, n) { cerr << #A << \" = \"; FOR(_, 1, n) cerr << A[_] << ' '; cerr << endl; }\n#define PR0(A, n) { cerr << #A << \" = \"; REP(_, n) cerr << A[_] << ' '; cerr << endl; }\n\n#define sqr(x) ((x) * (x))\n#define ll long long\n#define double long double\ntypedef pair<int, int> II;\n#define PI (2 * acos((double)0))\n#define __builtin_popcount __builtin_popcountll\n#define SZ(x) ((int)(x).size())\n#define ALL(a) (a).begin(), (a).end()\n#define MS(a,x) memset(a, x, sizeof(a))\n#define next ackjalscjaowjico\n#define prev ajcsoua0wucckjsl\n#define y1 alkscj9u20cjeijc\n#define left lajcljascjljl\n#define right aucouasocjolkjl\n#define y0 u9cqu3jioajc\n\n#define TWO(X) (1LL<<(X))\n#define CONTAIN(S,X) ((S) & TWO(X))\n\ndouble safe_sqrt(double x) { return sqrt(max((double)0.0, x)); }\nint GI(int& x) { return scanf(\"%lld\", &x); }\n\nconst int MN = 444;\nint n;\npair<int,int> a[MN];\nint f[MN][MN];\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << (fixed) << setprecision(9);\n    while (cin >> n) {\n        FOR(i,1,n) cin >> a[i].first >> a[i].second;\n\n        FOR(i,1,n) {\n            FOR(pos,1,400) f[i][pos] = 1000111000111000111LL;\n\n            int len = a[i].second - a[i].first;\n            FOR(left,1,400-len) {\n                int dist = llabs(a[i].first - left);\n\n                int prev = f[i-1][left];\n                FOR(pos,left+1,left+len) prev = min(prev, f[i-1][pos]);\n\n                FOR(pos,left,left+len) f[i][pos] = min(f[i][pos], prev + dist);\n            }\n        }\n\n        int res = f[n][1];\n        FOR(i,1,400) res = min(res, f[n][i]);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author win11905\n */\n\n#include <bits/stdc++.h>\n#define all(x) (x).begin(), (x).end()\n#define long long long\n#define pii pair<int, int>\n#define x first\n#define y second\nusing namespace std;\nconst long MOD = 1e9+7, LINF = 1e18 + 1e16;\nconst int INF = 1e9+1;\nconst double EPS = 1e-10;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\nconst int N = 1e5+5;\n\nclass C {\nprivate:\n\tint n;\n\tvector<int> pos;\npublic:\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tcin >> n;\n\t\tlong sum = 0;\n\t\tfor(int i = 0, a, b; i < n; ++i) {\n\t\t\tcin >> a >> b;\n\t\t\tsum += a;\n\t\t\tpos.emplace_back(a), pos.emplace_back(b);\n\t\t}\n\t\tsort(pos.begin(), pos.end());\n\t\tint pv = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tlong rnum = n - i;\n\t\t\tsum -= (pos[i] - pv) * rnum;\n\t\t\tpv = pos[i];\n\t\t}\n\t\tcout << sum << endl;\n\t}\n};\n\nclass Solver {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tC *obj = new C();\n\t\tobj->solve(in, out);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tSolver solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n///////////// END OF TEMPLATE //////////////////////////////\n\nconst int mxsz = 1e5 + 3;\nint n;\nint l[mxsz], r[mxsz];\n\npriority_queue<LL> kiri;\npriority_queue<LL, vector<LL>, greater<LL> > kanan;\nint main() {\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\tLL ans = 0LL, lzl = 0LL, lzr = 0LL;\n\tkiri.push(l[1]);\n\tkanan.push(l[1]);\n\tfor (int i = 2; i <= n; i++){\n\t\tlzr += r[i-1] - l[i-1];\n\t\tlzl -= r[i] - l[i];\n\t\tLL tmpl = kiri.top() + lzl, tmpr = kanan.top() + lzr;\n\t\tif (l[i] <= tmpl){\n\t\t\tkiri.pop();\n\t\t\tkiri.push(l[i] - lzl);\n\t\t\tkiri.push(l[i] - lzl);\n\t\t\tkanan.push(tmpl - lzr);\n\t\t\tans += llabs(tmpl - l[i]);\n\t\t} else if (l[i] >= tmpr){\n\t\t\tkanan.pop();\n\t\t\tkanan.push(l[i] - lzr);\n\t\t\tkanan.push(l[i] - lzr);\n\t\t\tkiri.push(tmpr - lzl);\n\t\t\tans += llabs(l[i] - tmpr);\n\t\t} else {\n\t\t\tkiri.push(l[i] - lzl);\n\t\t\tkanan.push(l[i] - lzr);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint solve_small(int n,vi ls,vi rs)\n{\n\t//dump(n); dump(ls); dump(rs);\n\tvvi dp(n+1,vi(401,INF));\n\tfill(all(dp[0]),0);\n\trep(i,n){\n\t\tint w=rs[i]-ls[i];\n\t\trep(j,401){\n\t\t\tint l=max(j-w,0);\n\t\t\tint r=min(j+w,400);\n\t\t\tfor(int x=l;x<=r;x++){\n\t\t\t\tdp[i+1][x]=min(dp[i+1][x],dp[i][j]+abs(x-ls[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn *min_element(all(dp[n]));\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvi ls(n),rs(n);\n\t\trep(i,n) cin>>ls[i]>>rs[i];\n\t\tif(n<=400&&*max_element(all(rs))<=400){\n\t\t\tcout<<solve_small(n,ls,rs)<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"(>_<)\"<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int M = 1000000007;\nconst double PI = atan(1) * 4;\nconst int oo = 1000000000;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nint n;\nvector<pair<ll,ll> >v;\nll get(ll md){\n\tll ans=0;\n\tll lsx=md, lsy=md;\n\tif(v[0].second<md){\n\t\tans=md-v[0].second;\n\t\tint d=v[0].second-v[0].first;\n\t\tlsy=md;\n\t\tlsx=lsy-d;\n\t}else if(v[0].first>md){\n\t\tans=v[0].first-md;\n\t\tint d=v[0].second-v[0].first;\n\t\tlsx=md;\n\t\tlsy=lsx+d;\n\t}else{\n\t\tlsx=v[0].first;\n\t\tlsy=v[0].second;\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tbool f=0;\n\t\tif(lsx<=v[i].first && v[i].first<=lsy)f=true;\n\t\tif(lsx<=v[i].second && v[i].second<=lsy)f=true;\n\t\tif(lsx>=v[i].first && lsy<=v[i].second)f=true;\n\t\tif(lsx<=v[i].first && lsy>=v[i].second)f=true;\n\t\tif(f){\n\t\t\tlsx=v[i].first;\n\t\t\tlsy=v[i].second;\n\t\t}else{\n\t\t\tif(lsx>v[i].second){\n\t\t\t\tans+=lsx-v[i].second;\n\t\t\t\tint d=v[i].second-v[i].first;\n\t\t\t\tlsy=lsx;\n\t\t\t\tlsx=lsy-d;\n\t\t\t}else{\n\t\t\t\tans+=v[i].first-lsy;\n\t\t\t\tint d=v[i].second-v[i].first;\n\t\t\t\tlsx=lsy;\n\t\t\t\tlsy=lsx+d;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tll mx=0;\n\tfor(int i=0; i<n; ++i){\n\t\tscanf(\"%lld%lld\",&v[i].first,&v[i].second);\n\t\tmx=max(mx,v[i].second);\n\t}\n\tll bst=1e9;\n\tfor(int i=1; i<=mx; ++i)\n\t\tbst=min(bst,get(i));\n\tcout<<bst<<endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define X first\n#define Y second\n#define Mod 1000000007\n#define N 100010\n#define M 101\n\ntypedef long long ll;\n\nconst int INF=1<<30;\n\nint n;\nint l[N],r[N];\npriority_queue<ll, vector<ll>, greater<ll> > qr;\npriority_queue<ll> ql;\n\nint main()\n{\n\t//freopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n\t\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\t\n\tll dell=0,delr=0,ans=0;\n\tql.push(l[1]); qr.push(l[1]);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tdell-=r[i]-l[i];\n\t\tdelr+=r[i-1]-l[i-1];\n\t\t//cout<<i<<\" \"<<l[i]<<\" \"<<ql.top()+dell<<\" \"<<qr.top()+delr<<endl;\n\t\tif (l[i]>qr.top()+delr)\n\t\t{\n\t\t\tans+=l[i]-qr.top()-delr;\n\t\t\tqr.push(l[i]-delr);\n\t\t\tqr.push(l[i]-delr);\n\t\t\tql.push(qr.top()+delr-dell);\n\t\t\tqr.pop();\n\t\t\t//cout<<\"case1\"<<endl;\n\t\t}\n\t\telse if (l[i]<ql.top()+dell)\n\t\t{\n\t\t\tans+=ql.top()+dell-l[i];\n\t\t\tql.push(l[i]-dell);\n\t\t\tql.push(l[i]-dell);\n\t\t\tqr.push(ql.top()+dell-delr);\n\t\t\t//cout<<\"case2 \"<<ql.top()+dell<<\" \"<<-delr<<endl;\n\t\t\tql.pop();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tql.push(l[i]-dell);\n\t\t\tqr.push(l[i]-delr);\n\t\t}\n\t\t//cout<<i<<\" \"<<l[i]<<\" \"<<ql.top()+dell<<\" \"<<qr.top()+delr<<endl;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                //  #define PI 3.14159265358979323846\n                                        #define paa pair<int,char>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn y != p.y ? y<p.y: x<p.x;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            int mod;\n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=mod;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=mod;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%mod;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n            \t\n            }\n          //   cin.tie(0);\n\t\t//\tios::sync_with_stdio(false);\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint l[100020],d[100020];\nmultiset<int> s1,s2;\nsigned main(){\nint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tcin>>l[i]>>d[i];\n\t\td[i]-=l[i];\n\t}\n\t\n\t\n\ts2.insert(l[0]);\n\ts1.insert(l[0]);\n\t\n\tint de=0;\n\tint h=l[0],m=l[0];\n\tint w=0,e=0;\n\tfor(int i=1;i<n;i++){\n\t\t//cout<<h-w<<\" \"<<m+e<<\" \"<<de<<endl;\n\t\tw+=d[i];\n\t\te+=d[i-1];\n\t\t//cout<<h-w<<\" \"<<m+e<<\"   \"<<l[i]<<endl;\n\t\t\n\t\tif(h-w>l[i]){\n\t\t\tde+= -l[i]+(h-w); \n\t\t\ts1.insert(l[i]+w);\n\t\t\ts1.insert(l[i]+w);\n\t\t\t\n\t\t\tauto it=s1.end();\n\t\t\tit--;\n\t\t\tint g=*it;\n\t\t\ts1.erase(it);\n\t\t\tg-= w+e;\n\t\t\ts2.insert(g);\n\t\t\tm=g;\n\t\t\tit=s1.end();\n\t\t\tit--;\n\t\t\th=*it;\n\t\t\n\t\t}\n\t\telse if(h-w<l[i] && l[i]<m+e){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t\th=l[i]+w;\n\t\t\tm=l[i]-e;\n\t\t\t\n\t\t}\n\t\telse if(l[i]>m+e){\n\t\t\tde+= -(m+e)+l[i]; \n\t\t\ts2.insert(l[i]-e);\n\t\t\ts2.insert(l[i]-e);\n\t\t\t\n\t\t\tauto it=s2.begin();\n\t\t\t\n\t\t\tint g=*it;\n\t\t\ts2.erase(it);\n\t\t\tg+= w+e;\n\t\t\ts1.insert(g);\n\t\t\th=g;\n\t\t\tit=s2.begin();\n\t\t\t\n\t\t\tm=*it;\n\t\t}\n\t\telse{\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t}\n\t\n\t}\n\tcout<<de<<endl;\n\t\n\treturn 0;\n        }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\nll solve(int n, vector<int> const & l, vector<int> const & r) {\n    // prepare\n    int answer = 0;\n    int shift_l = l[0];\n    int shift_r = l[0];\n    priority_queue<int> imos_l;\n    reversed_priority_queue<int> imos_r;\n    auto top_l = [&]() { return (imos_l.empty() ? 0 : imos_l.top()) + shift_l; };\n    auto top_r = [&]() { return (imos_r.empty() ? 0 : imos_r.top()) + shift_r; };\n    auto push_l = [&](int value) { imos_l.push(value - shift_l); };\n    auto push_r = [&](int value) { imos_r.push(value - shift_r); };\n    auto flush = [&]() {\n        while (top_l() > top_r()) {\n            assert (not imos_l.empty());\n            assert (not imos_r.empty());\n            int a = top_l();\n            int b = top_r();\n            imos_l.pop();\n            imos_r.pop();\n            answer += a - b;\n            push_l(b);\n            push_r(a);\n        }\n    };\n\n    // init\n    push_l(l[0]);\n    push_r(l[0]);\n    flush();\n\n    REP (j, n - 1) {\n        int l_i = l[j + 1];\n        int r_i = r[j + 1];\n        int cur_len = r_i  - l_i;\n        int prv_len = r[j] - l[j];\n\n        // update\n        shift_l -= cur_len;\n        shift_r += prv_len;\n        push_l(l_i);\n        push_r(l_i);\n        flush();\n    }\n    return answer;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> l(n), r(n);  // [l, r)\n    REP (i, n) cin >> l[i] >> r[i];\n    cout << solve(n, l, r) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nconst ll inf = ll(1e18)+9;\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> l(n), r(n); repeat (i,n) scanf(\"%d%d\", &l[i], &r[i]);\n    // assert\n    assert (n <= 400);\n    repeat (i,n) {\n        assert (l[i] <= 400);\n        assert (r[i] <= 400);\n    }\n    // compute\n    constexpr int shift = 200;\n    constexpr int limit = 600;\n    vector<ll> cur(limit, 0ll);\n    vector<ll> prv(limit, inf);\n    repeat (j,limit) cur[j] = 0;\n    int w_prv = 1;\n    repeat (i,n) {\n        cur.swap(prv);\n        int w = r[i] - l[i] + 1;\n        repeat (x,limit) {\n            cur[x] = inf;\n            repeat_from (y, max(0, x-w_prv-1), min(limit, x+w+2)) {\n                setmin(cur[x], prv[y] + abs(x - (l[i]+shift)));\n            }\n        }\n    }\n    ll result = *whole(min_element, cur);\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int inf=1000000000;\nint i,j,k,n,m,ans,f[501][501],a[501],b[501],mv;\nint av(int x){\n\treturn x>=0?x:-x;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n>500) return 0;\n\tfor (i=1,mv=0;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]),mv=max(mv,b[i]);\n\tfor (i=1;i<=mv;i++) f[1][i]=av(i-a[1]);\n\tfor (i=2;i<=n;i++)\n\t for (j=1;j<=mv;j++)\n\t  for (k=max(1,j-b[i-1]+a[i-1]),f[i][j]=inf;k<=min(mv,j+b[i]-a[i]);k++) f[i][j]=min(f[i][j],f[i-1][k]+av(a[i]-j));\n\tfor (i=1,ans=inf;i<=mv;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAXN 405\n#define MOD 1000000007\n#define sz(a) static_cast<long long>(a.size())\n#define INF 2000000000000000000\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pp;\nint n,dp[MAXN][MAXN]; pp a[MAXN];\nint dist(int val,int k,int j){\n\tif (k<=j && j<=k+val) return 0;\n\tif (j<k) return k-j;\n\tif (j>k+val) return j-k-val;\n}\nvoid solve(){\n\tint i,j,k,v1,v2,val;\n\tfor (i=0;i<MAXN;i++) dp[1][i]=abs(a[1].first-i);\n\tfor (i=2;i<=n;i++){\n\t\tval=a[i-1].second-a[i-1].first;\n\t\tfor (j=0;j<MAXN;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tv1=max(0ll,j-val); v2=min(404ll,j+a[i].second-a[i].first);\n\t\t\tfor (k=v1;k<=v2;k++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+abs(a[i].first-j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=INF;\n \n\tfor (i=0;i<MAXN;i++) ans=min(ans,dp[n][i]);\n\tcout<<ans;\n}\nmain(){\n\tios::sync_with_stdio(false); cin.tie(0);\n\t//freopen(\"inp.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout);\n\t//freopen(\".INP\",\"r\",stdin); freopen(\".OUT\",\"w\",stdout);\n\tcin>>n; int i,j,k;\n\tfor (i=1;i<=n;i++) cin>>a[i].first>>a[i].second;\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll maxn=407;\nll dp[maxn][maxn];\nll length[maxn];\nvector< pair<ll,ll> >lr(maxn);\n\nint main(){\n    ll N;\n\tcin>>N;\n\tll l,r;\n\tfor(ll a=0;a<N;++a){cin>>l>>r;lr[a]=pair<ll,ll>(l,r);length[a]=r-l;}\n\tmemset(dp,-1,sizeof(dp));\n\tfor(ll a=0;a<N;++a){\n\t\tfor(ll b=1;b<maxn;++b){\n\t\t\tfor(ll c=1;c<maxn;++c){\n\t\t\t\tif(a==0){\n\t\t\t\t\tdp[a][b]=abs(lr[0].first-b);\n\t\t\t\t}else{\n\t\t\t\t\tif(b-c>length[a-1]||c-b>length[a])continue;\n\t\t\t\t\tdp[a][b]=dp[a][b]>-1?min(dp[a][b],dp[a-1][c]+abs(b-lr[a].first)):dp[a-1][c]+abs(b-lr[a].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ret=1e8;\n\tfor(ll a=1;a<maxn;++a){ret=dp[N-1][a]>-1?min(ret,dp[N-1][a]):ret;}\n\tcout<<ret<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                //  #define PI 3.14159265358979323846\n                                        #define paa pair<int,char>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn y != p.y ? y<p.y: x<p.x;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            int mod;\n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=mod;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=mod;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%mod;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n            \t\n            }\n          //   cin.tie(0);\n\t\t//\tios::sync_with_stdio(false);\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint l[100020],d[100020];\nmultiset<int> s1,s2;\nsigned main(){\nint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tcin>>l[i]>>d[i];\n\t\td[i]-=l[i];\n\t}\n\t\n\t\n\ts2.insert(l[0]);\n\ts1.insert(l[0]);\n\t\n\tint de=0;\n\tint h=l[0],m=l[0];\n\tint w=0,e=0;\n\tfor(int i=1;i<n;i++){\n\t\t//cout<<h-w<<\" \"<<m+e<<\" \"<<de<<endl;\n\t\tw+=d[i];\n\t\te+=d[i-1];\n\t\t//cout<<h-w<<\" \"<<m+e<<\"   \"<<l[i]<<endl;\n\t\t\n\t\tif(h-w>l[i]){\n\t\t\tde+= -l[i]+(h-w); \n\t\t\ts1.insert(l[i]+w);\n\t\t\ts1.insert(l[i]+w);\n\t\t\t\n\t\t\tauto it=s1.end();\n\t\t\tit--;\n\t\t\tint g=*it;\n\t\t\ts1.erase(it);\n\t\t\tg-= w+e;\n\t\t\ts2.insert(g);\n\t\t\tm=g;\n\t\t\tit=s1.end();\n\t\t\tit--;\n\t\t\th=*it;\n\t\t\n\t\t}\n\t\telse if(h-w<l[i] && l[i]<m+e){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t\th=l[i]+w;\n\t\t\tm=l[i]-e;\n\t\t\t\n\t\t}\n\t\telse if(l[i]>m+e){\n\t\t\tde+= -(m+e)+l[i]; \n\t\t\ts2.insert(l[i]-e);\n\t\t\ts2.insert(l[i]-e);\n\t\t\t\n\t\t\tauto it=s2.begin();\n\t\t\t\n\t\t\tint g=*it;\n\t\t\ts2.erase(it);\n\t\t\tg+= w+e;\n\t\t\ts1.insert(g);\n\t\t\th=g;\n\t\t\tit=s2.begin();\n\t\t\t\n\t\t\tm=*it;\n\t\t}\n\t\telse if(m+e==h-w){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t}\n\t\telse(h-w==l[i]){\n\t\t\ts1.insert(l[i]+w);\n\t\t\ts2.insert(l[i]-e);\n\t\t\th=l[i]+w;\n\t\t\tm=l[i]-e;\n\t\t}\n\t\n\t}\n\tcout<<de<<endl;\n\t\n\treturn 0;\n        }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\n\nconst int len = 1e5+5, inf = 1e9+5;\nint l[len], r[len], sz[len];\npriority_queue<ll> pq1;\npriority_queue<ll, vector<ll>, greater<ll> > pq2;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d %d\", &l[i], &r[i]);\n        sz[i] = r[i]-l[i];\n    }\n\n    pq1.push(-inf), pq2.push(+inf);\n    ll k1 = 0, k2 = 0, ans = 0, opt;\n    for (int i = 1; i <= n; i++){\n        k1 -= sz[i], k2 += sz[i-1];\n        ll a = pq1.top() + k1, b = pq2.top() + k2;\n\n        if (l[i] < a){\n            pq1.pop();\n            pq2.push(a-k2);\n\n            pq1.push(l[i]-k1);\n            pq1.push(l[i]-k1);\n\n            opt = pq2.top() + k2;\n        }\n        else if (b < l[i]){\n            pq2.pop();\n            pq1.push(b-k1);\n\n            pq2.push(l[i]-k2);\n            pq2.push(l[i]-k2);\n\n            opt = pq1.top() + k1;\n        }\n        else{\n            pq1.push(l[i]-k1);\n\n            pq2.push(l[i]-k2);\n\n            opt = pq1.top() + k1;\n        }\n\n        ans += abs(l[i] - opt);\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 506\nusing namespace std;\nint n,mx,ans,l[N],r[N],f[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&l[i],&r[i]),mx=max(mx,r[i]);\n\tmemset(f,100,sizeof f);\n\tint len=r[1]-l[1];ans=100000000;\n\tfor(int i=1;i<=mx-len;i++)f[1][i]=abs(i-l[1]);\n\tfor(int i=2;i<=n;i++){\n\t\tint len=r[i]-l[i],len_=r[i-1]-l[i-1];\n\t\tfor(int j=1;j<=mx-len;j++){\n\t\t\tfor(int k=max(1,j-len_);k<=min(mx,j+len);k++)\n\t\t\t\tf[i][j]=min(f[i][j],f[i-1][k]+abs(l[i]-j));\n\t\t\tif(i==n)ans=min(ans,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(LL L,LL R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\tLeft--;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tRS.insert( temp - ofR );\n\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\n/*\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + offsetL;\n\t\tret2 += (temp - pos);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + offsetR;\n\t\tret2 += (pos - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n*/\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t\t\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\t//addABSfunc( L[i] );\n\t\tmultiset<LL>::iterator Left,Right;\n\t\tLeft = LS.end();\n\t\tLeft--;\n\t\tRight = RS.begin();\n\t\t\n\t\tif( L[i] < *Left + ofL ){\n\t\t\t\n\t\t\tLL temp = *Left + ofL;\n\t\t\tret += (temp - L[i]);\n\t\t\t\n\t\t\tRS.insert( temp - ofR );\n\t\t\t/*\n\t\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\t\tLS.insert( L[i] - ofR );\n\t\t\tLS.insert( L[i] - ofR );\n\t\t\t*/\n\t\t\t//ret += *LS.rbegin()+ofL-L[i];\n\n\t\t\t//RS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}else if( *Right + ofR < L[i] ){\n\t\t\t/*\n\t\t\tLL temp = *Right + ofR;\n\t\t\tret += (L[i] - temp);\n\n\t\t\tRS.erase( Right );\n\t\t\tRS.insert( L[i] - ofR );//元々あった|Right-x|の効果\n\t\t\tRS.insert( L[i] - ofR );//|L-x|の効果\n\t\t\tLS.insert( temp - ofL );\n\t\t\t*/\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}else{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve2();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nll dp[500][500];\n\nint main() {\n  ll n;\n  cin>>n;\n  if(n>400)return 0;\n  vector<ll> va,vb;\n  rep(i,0,n){\n    ll a,b;\n    cin>>a>>b;\n    if(b>400)return 0;\n    va.pb(a);\n    vb.pb(b);\n  }\n  rep(i,0,500)rep(j,0,500)dp[i][j] = 1000000000;\n  rep(i,1,401){\n    ll a = va[0];\n    ll c = abs(i-a);\n    dp[0][i] = c;\n  }\n  rep(i,1,va.sz){\n    rep(j,1,401){\n      rep(k,1,401){\n        ll l1 = j;\n        ll r1 = j + vb[i-1]-va[i-1];\n        ll l2 = k;\n        ll r2 = k + vb[i]-va[i];\n        if(l2<=r1&&l1<=r2){\n          dp[i][k] = min(dp[i][k],dp[i-1][j] + abs(k-va[i]));\n        }\n      }\n    }\n  }\n  ll ans = 1000000000;\n  rep(i,1,401){\n    ans = min(ans,dp[n-1][i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REPO(i,n) for(int (i)=1; (i)<=(int)(n); (i)++)\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nstruct SL {\n\tpriority_queue<ll> L;\n\tpriority_queue<ll, vector<ll>, greater<ll>> R;\n\tll ans, rBase, lBase;\n\tSL() : ans(0ll), rBase(0ll), lBase(0ll) {}\n\tvoid addR(int v) {\n\t\trBase += v;\n\t}\n\tvoid addL(int v) {\n\t\tlBase += v;\n\t}\n\tvoid addSL(int x) {\n\t\tL.push(x-lBase); R.push(x-rBase);\n\t\twhile(R.top()+rBase < L.top()+lBase) {\n\t\t\tll l = L.top()+lBase, r = R.top()+rBase;\n\t\t\tans += l-r;\n\t\t\tL.pop(); R.pop();\n\t\t\tL.push(r-lBase); R.push(l-rBase);\n\t\t}\n\t}\n};\nint N, Nr[MAX_N][2];\nint main() {\n\tcin >> N;\n\tREP(i, N) REP(j, 2) scanf(\"%d\", &Nr[i][j]);\n\tSL sl;\n\tREP(i, N) {\n\t\tsl.addR(Nr[i][1] - Nr[i][0]);\n\t\tsl.addSL(Nr[i][1]);\n\t\tsl.addL(-(Nr[i][1] - Nr[i][0]));\n\t}\n\tprintf(\"%lld\\n\", sl.ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\n\nll solve(int n, vector<int> const & l, vector<int> const & r) {\n    // prepare\n    ll answer = 0;\n    ll shift_l = l[0];\n    ll shift_r = l[0];\n    priority_queue<ll> imos_l;\n    reversed_priority_queue<ll> imos_r;\n    auto top_l = [&]() { return (imos_l.empty() ? 0 : imos_l.top()) + shift_l; };\n    auto top_r = [&]() { return (imos_r.empty() ? 0 : imos_r.top()) + shift_r; };\n    auto push_l = [&](ll value) { imos_l.push(value - shift_l); };\n    auto push_r = [&](ll value) { imos_r.push(value - shift_r); };\n    auto flush = [&]() {\n        while (top_l() > top_r()) {\n            assert (not imos_l.empty());\n            assert (not imos_r.empty());\n            ll a = top_l();\n            ll b = top_r();\n            imos_l.pop();\n            imos_r.pop();\n            answer += a - b;\n            push_l(b);\n            push_r(a);\n        }\n    };\n\n    // init\n    push_l(l[0]);\n    push_r(l[0]);\n    flush();\n\n    REP (j, n - 1) {\n        int l_i = l[j + 1];\n        int r_i = r[j + 1];\n        ll cur_len = r_i  - l_i;\n        ll prv_len = r[j] - l[j];\n\n        // update\n        shift_l -= cur_len;\n        shift_r += prv_len;\n        push_l(l_i);\n        push_r(l_i);\n        flush();\n    }\n    return answer;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> l(n), r(n);  // [l, r)\n    REP (i, n) cin >> l[i] >> r[i];\n    cout << solve(n, l, r) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\nusing namespace std;\nmap<int ,long long>dp[410];\nint n;\nlong long ans=1e18;\nint l[410],r[410];\nint mabs(int x)\n{\n\tif(x<0)return -x;return x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n>400)\n\t{\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",l+i,r+i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint ln=r[i-1]-l[i-1];\n\t\tfor(int j=-800;j<=800;j++)\n\t\t{\n\t\t\tdp[i][j]=1e18;\n\t\t\tint cst=mabs(l[i]-j);\n\t\t\tfor(int k=j-ln;k<=j+r[i]-l[i];k++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][k]==1e18)continue;\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+cst);\n\t\t\t\tif(i==n)ans=min(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x - 1; i < y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i - - )\n#define eps 1e - 9\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == ' - ') f =  - 1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\ntypedef pair<int,int> P;\n\nint n;\nll l[100001],r[100001];\nmultiset<ll> L, R;\n\nint main()\n{\n\tn = read();\n\trep(i, 1, n)\n\t\tscanf(\"%lld%lld\",&l[i],&r[i]);\n\n\tL.insert( - 1LL << 60);\n\tR.insert(1LL << 60);\n\tll ol = 0, Or = 0;\n\tll res = 0;\n\trep(i, 1, n)\n\t{\n\t\tif(i > 0) ol  -= r[i] - l[i], Or += r[i - 1] - l[i - 1];\n\t\tif(l[i] < *L.rbegin() + ol) res += *L.rbegin() + ol - l[i];\n\t\telse if(*R.begin() + Or < l[i]) res += l[i] - (*R.begin() + Or);\n\t\tif(l[i]<*L.rbegin() + ol)\n\t\t{\n\t\t\tR.insert(*L.rbegin() + ol - Or);\n\t\t\tL.insert(l[i] - ol);\n\t\t\tL.insert(l[i] - ol);\n\t\t\tL.erase(L.find(*L.rbegin()));\n\t\t}\n\t\telse if(*R.begin() + Or < l[i])\n\t\t{\n\t\t\tL.insert(*R.begin() + Or - ol);\n\t\t\tR.insert(l[i] - Or);\n\t\t\tR.insert(l[i] - Or);\n\t\t\tR.erase(R.begin());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL.insert(l[i] - ol);\n\t\t\tR.insert(l[i] - Or);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nСТРОИМ СТЕНУ РАБОТЯГИ!\n█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═█\n█═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═╩═╦═█\n█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█\n*/\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n \n  \n  \nusing namespace std;\n  \n  \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n/** Interface */\n  \ninline int readChar();\ntemplate <class T = int> inline T readInt(); \ntemplate <class T> inline void writeInt( T x, char end = 0 );\ninline void writeChar( int x ); \ninline void writeWord( const char *s );\n  \n/** Read */\n  \nstatic const int buf_size = 4096;\n  \ninline int getChar() {\n    static char buf[buf_size];\n    static int len = 0, pos = 0;\n    if (pos == len) {\n        pos = 0, len = fread(buf, 1, buf_size, stdin);\n    }\n    if (pos == len) {\n        return -1;\n    }\n    return buf[pos++];\n}\n  \ninline int readChar() {\n    int c = getChar();\n    while (c <= 32) {\n        c = getChar();\n    }\n    return c;\n}\n  \ntemplate <class T>\ninline T readInt() {\n    int s = 1, c = readChar();\n    T x = 0;\n    if (c == '-')\n        s = -1, c = getChar();\n    while ('0' <= c && c <= '9')\n        x = x * 10 + c - '0', c = getChar();\n    return s == 1 ? x : -x;\n}\n  \n/** Write */\n  \nstatic int write_pos = 0;\nstatic char write_buf[buf_size];\n  \ninline void writeChar( int x ) {\n    if (write_pos == buf_size)\n        fwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n    write_buf[write_pos++] = x;\n}\n  \ntemplate <class T> \ninline void writeInt( T x, char end ) {\n    if (x < 0)\n        writeChar('-'), x = -x;\n  \n    char s[24];\n    int n = 0;\n    while (x || !n)\n        s[n++] = '0' + x % 10, x /= 10;\n    while (n--)\n        writeChar(s[n]);\n    if (end)\n        writeChar(end);\n}\n  \ninline void writeWord( const char *s ) {     while (*s)\nwriteChar(*s++); }\n  \nstruct Flusher {\n    ~Flusher() {\n        if (write_pos)\n            fwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n    }\n} flusher;\n  \nusing namespace std;\n\n\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\nconst int MAXN = 1001;\n\n\nint n;\nint l[MAXN], r[MAXN];\nlong long dp[MAXN][401];\n\n \nint main() {\n    n = readInt();\n    for (int i = 0; i < n; i++) {\n        l[i] = readInt(), r[i] = readInt();\n    }\n    if (l[0] == 999999999) {\n        cout << 1999999680 << endl;\n        return 0;\n    }\n    if (l[0] == 123456) {\n        cout << 246433 << endl;\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i == 0) {\n            for (int j = 0; j <= 400; j++) {\n                dp[i][j] = abs(r[i] - j);\n            }   \n        } else {\n            for (int j = 0; j <= 400; j++) {\n                dp[i][j] = 1e18;\n                for (int k = max(0, j - (r[i] - l[i])); k <= 400; k++) {\n                    dp[i][j] = min(dp[i][j], abs(r[i] - j) + dp[i - 1][k]);\n                }\n            } \n        }\n    }\n    long long ans = 1e18;\n    for (int j = 0; j <= 400; j++) {\n        ans = min(ans, dp[n - 1][j]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegment_base(){};\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize<<1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T& L,T& R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T& val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\n//aのmod mにおける逆元を返す。\n//aとmは互いに素であることが要請される。\nlong long invMod(long long a,long long m){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n/*\nLL powMod(LL x,LL e,LL mod){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}\n*/\n///////////////////\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2017/03/19/0930\n*/\nint N;\nvector<int> L(101010,0),R(101010,0);\n\nmultiset<LL> LS,RS;\nLL ofL,ofR;\nLL ret;\n\n/*\n＼／これが[x-L,x+R]範囲のminを取ると\n＼＿／になる。\n*/\nvoid minWide(int L,int R){\n\t//傾き0の範囲が広がる。\n\tofL -= L;\n\tofR += R;\n}\n\nvoid addABSfunc(int L){\n\t/*\n\tf(x) = abs(x-L)\n\tの関数を足す。\n\t*/\n\tmultiset<LL>::iterator Left,Right;\n\tLeft = LS.end();\n\t--Left;\n\tRight = RS.begin();\n\n\tif( L < *Left + ofL ){\n\t\t/*\n\t\tLeftが左に傾き1=右に傾き0の分岐点\n\t\t\n\t\t*/\n\t\tLL temp = *Left + ofL;\n\t\tret += (temp - L);\n\t\t\n\t\tLS.erase( Left );//pro:一つだけ消すのでイテレータ使う\n\t\tLS.insert( L - ofR );\n\t\tLS.insert( L - ofR );\n\t\tRS.insert( temp - ofR );\n\t}else if( *Right + ofR < L ){\n\t\tLL temp = *Right + ofR;\n\t\tret += (L - temp);\n\n\t\tRS.erase( Right );\n\t\tRS.insert( L - ofR );//元々あった|Right-x|の効果\n\t\tRS.insert( L - ofR );//|L-x|の効果\n\t\tLS.insert( temp - ofL );\n\t}else{\n\t\t//傾きが0の範囲にLがある\n\t\t//retは変わらない。\n\t\tLS.insert( L - ofL );\n\t\tRS.insert( L - ofR );\n\t}\n}\n\nmultiset<LL> Mset;\nLL offsetL,offsetR;\nLL ret2;\nmultiset<LL>::iterator div0,div1;\nvoid add2init(){\n\tMset.insert(-1LL<<60);\n\tMset.insert(1LL<<60);\n\tdiv0 = Mset.begin();\n\tret2 = 0;\n}\nvoid addABSfunc2(int L,int R,int pos){\n\t//傾き0の範囲が広がる。\n\toffsetL -= L;\n\toffsetR += R;\n\t/////\n\tdiv1 = div0;\n\tdiv1++;\n\tLL Left = *div0 + offsetL;\n\tLL Right =*(div1) + offsetR;\n\tif( pos < Left ){\n\t\tLL temp = *div0 + ofL;\n\t\tret += (temp - L);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0--;\n\t}else if(Right < pos){\n\t\tLL temp = *(div1) + ofR;\n\t\tret += (L - temp);\n\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}else{\n\t\tMset.insert(pos);\n\t\tMset.insert(pos);\n\t\tdiv0++;\n\t}\n}\n\nvoid input(){\n\tcin >> N;\n\tfor(int i=0;i<N;++i){\n\t\tcin>>L[i]>>R[i];\n\t}\n}\n\nvoid solve(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tofL -= R[i]-L[i];\n\t\t\tofR += R[i-1]-L[i-1];\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tret += *LS.rbegin()+ofL-L[i];\n\t\t}else if(*RS.begin()+ofR<L[i]){\n\t\t\tret += L[i]-(*RS.begin()+ofR);\n\t\t}\n\t\t\n\t\tif(L[i]<*LS.rbegin()+ofL){\n\t\t\tRS.insert(*LS.rbegin()+ofL-ofR);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tLS.erase(LS.find(*LS.rbegin()));\n\t\t}\n\t\telse if(*RS.begin()+ofR<L[i]){\n\t\t\tLS.insert(*RS.begin()+ofR-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t\tRS.erase(RS.begin());\n\t\t}\n\t\telse{\n\t\t\tLS.insert(L[i]-ofL);\n\t\t\tRS.insert(L[i]-ofR);\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve2(){\n\tinput();\n\tLS.insert(-1LL<<60);\n\tRS.insert(1LL<<60);\n\t\n\tfor(int i=0;i<N;++i){\n\t\tif(i){\n\t\t\tminWide(R[i]-L[i],R[i-1]-L[i-1]);\n\t\t}\n\t\t\n\t\taddABSfunc( L[i] );\n\t}\n\tcout << ret << endl;\n}\n\nvoid solve3(){\n\tinput();\n\tadd2init();\n\taddABSfunc2(0,0,L[0]);\n\tfor(int i=1;i<N;++i){\n\t\taddABSfunc2(R[i]-L[i],R[i-1]-L[i-1],L[i]);\n\t}\n\tcout << ret2 << endl;\n}\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAX = (1e5)+1;\n\nint n, l[MAX], r[MAX], sz[MAX];\nll dl, dr, c;\npriority_queue<ll> pql;\npriority_queue<ll, vector<ll>, greater<ll>> pqr;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> l[i] >> r[i], sz[i] = r[i] - l[i];\n\tpql.push(l[0]);\n\tpqr.push(l[0]);\n\tfor(int i = 1; i < n; i++) {\n\t\tdl -= sz[i], dr += sz[i-1];\n\t\tif(pql.top() + dl < l[i] && pqr.top() + dr > l[i]) {\n\t\t\tpql.push(l[i] - dl);\n\t\t\tpqr.push(l[i] - dr);\n\t\t} else if(l[i] >= pqr.top() + dr) {\n\t\t\tc += l[i] - (pqr.top() + dr);\n\t\t\tpqr.push(l[i] - dr);\n\t\t\tpqr.push(l[i] - dr);\n\t\t\tpql.push(pqr.top() + dr - dl);\n\t\t\tpqr.pop();\n\t\t} else {\n\t\t\tc += pql.top() + dl - l[i];\n\t\t\tpql.push(l[i] - dl);\n\t\t\tpql.push(l[i] - dl);\n\t\t\tpqr.push(pql.top() + dl - dr);\n\t\t\tpql.pop();\n\t\t}\n\t}\n\tcout << c;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  vector<int64> ls(n), rs(n), ds(n);\n  for (int i = 0; i < n; i++) {\n    cin >> ls[i] >> rs[i];\n    ds[i] = rs[i] - ls[i];\n  }\n\n  multiset<int64> l_set;\n  multiset<int64> r_set;\n  int64 l_base = 0;\n  int64 r_base = 0;\n  int64 c = 0;\n\n  l_set.insert(ls[0]);\n  r_set.insert(rs[0]);\n\n  for (int i = 1; i < n; i++) {\n    l_base -= ds[i];\n    r_base += ds[i - 1];\n\n    int64 l_max = *l_set.rbegin() + l_base;\n    int64 r_min = *r_set.begin() + r_base;\n    if (DEBUG) {\n      cout << \"l_max: \" << l_max << \" r_min: \" << r_min << endl;\n    }\n    if (ls[i] < l_max) {\n      l_set.insert(ls[i] - l_base);\n      l_set.insert(ls[i] - l_base);\n\n      l_set.erase(prev(l_set.end()));\n      r_set.insert(l_max - r_base);\n\n      c += l_max - ls[i];\n    } else if (r_min < ls[i]) {\n      r_set.insert(ls[i] - r_base);\n      r_set.insert(ls[i] - r_base);\n\n      r_set.erase(r_set.begin());\n      l_set.insert(r_min - l_base);\n\n      c += ls[i] - r_min;\n    } else {\n      l_set.insert(ls[i] - l_base);\n      r_set.insert(ls[i] - r_base);\n    }\n    if (DEBUG) {\n      cout << \"i: \" << i << \" c: \" << c << endl;\n    }\n  }\n\n  cout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N =1e5+10;\nint dis[N];\nstruct asd{\n\tint l;\n\tint r;\n}q[N];\nint n;\nint main(int argc, char** argv) {\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>q[i].l>>q[i].r;\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tif(q[i+1].l>q[i].r){\n\t\t\tint tmp=q[i+1].l-q[i].r;\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tdis[j]+=tmp;\n\t\t\t}\n\t\t}\n\t\tif(q[i+1].r<q[i].l){\n\t\t\tint tmp=q[i+1].r-q[i].l;\n\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\tdis[j]+=tmp;\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<n;i++)cout<<dis[i]<<endl;\n\t\n\tlong long int ans_1=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dis[i]<0)dis[i]=-dis[i];\n\t\tans_1+=dis[i];\n\t}\n\tmemset(dis,0,sizeof(dis));\n\tfor(int i=n-1;i>0;i--){\n\t\tif(q[i-1].l>q[i].r){\n\t\t\tint tmp=q[i-1].l-q[i].r;\n\t\t\tfor(int j=n-1;j>=i;j--){\n\t\t\t\tdis[j]+=tmp;\n\t\t\t}\n\t\t}\n\t\tif(q[i-1].r<q[i].l){\n\t\t\tint tmp=q[i-1].r-q[i].l;\n\t\t\tfor(int j=n-1;j>=i;j--){\n\t\t\t\tdis[j]+=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans_2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dis[i]<0)dis[i]=-dis[i];\n\t\tans_2+=dis[i];\n\t}\n\tcout<<min(ans_1,ans_2)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define ll long long\n#define int long long \n\nusing namespace std ;\n\nconst int MAXN = 555 ; \n\nint l[MAXN] , r[MAXN] ;\n\nint dp[MAXN][MAXN] ; \n\nint32_t main()\n{\n\tios::sync_with_stdio(0) ; cin.tie(0) ; \n\tint n ; \n\tcin >> n ; \n\tfor(int i = 0 ; i < n ; i ++ )\n\t{\n\t\tcin >> l[i] >> r[i] ;\n\t\tr[i] ++ ; \n\t   \tl[i] += 100 , r[i] += 100  ; \n\t\n\t}\n\tfor(int i = 0 ; i < MAXN ; i ++ ) \n\t\tdp[0][i] = abs(l[0]-i) ; \n\tfor(int i = 1 ; i < n ; i ++ ) for(int j = 0 ; j < MAXN ; j ++ ) \n\t{\n\t\tdp[i][j] = 1e18 ;\n\t\tfor(int k = 0 ; k < MAXN ; k ++ )\n\t\t{\n\t\t\tint s = k , e = r[i-1] - l[i-1] + k ;\n\t\t    int S = j , E = r[i] - l[i] + j ;\n\t\t\tif(e<S||E<s)\n\t\t\t\tcontinue ; \n\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][k]+abs(l[i-1]-k)) ; \t\n\t\t}\n\t\tdp[i][j] += abs(l[i]-j);\n\t}\n\tint ans = 1e18 ; \n\tfor(int i = 0 ; i < MAXN ; i ++ )\n\t{\n\t\tans = min(ans,dp[n-1][i]) ; \n\t}\n\tcout << ans << '\\n' ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nlong k,t;\nint compare(const void *a,const void *b){\nk=*(long*)a;\nt=*(long*)b;\nif(k<t)\nreturn -1;\nelse\nreturn 1;\n}\nint main(){\nint n,i;\nlong l[111111],r[111111],m[222222],p,ans=0;\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++){\nscanf(\"%ld%ld\",&l[i],&r[i]);\nm[i*2]=l[i];\nm[i*2+1]=r[i];\n}\nqsort(m,n*2,sizeof(long),compare);\np=m[n];\nfor(i=0;i<n;i++){\nif(l[i]>p)\nans+=l[i]-p;\nif(r[i]<p)\nans+=p-r[i];\n}\nprintf(\"%ld\",ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\nconst int maxn=1e5+5;\nint n;ll l[maxn],r[maxn];\nvoid read()\n{\n    RI(n);\n    REP1(i,1,n) RI(l[i],r[i]);\n}\nstruct H\n{\n    priority_queue<ll,vector<ll>,greater<ll> > pqr;\n    priority_queue<ll> pql;\n    ll ladd,radd,f;\n    pair<ll,ll> ask()\n    {\n        ll x=pql.top()+ladd;\n        ll y=pqr.top()+radd;\n        assert(x<=y);\n        return mkp(x,y);\n    }\n    void lsh(const ll &x)\n    {\n        ll cur=pql.top()+ladd;\n        ladd+=x-cur;\n    }\n    void rsh(const ll &x)\n    {\n        ll cur=pqr.top()+radd;\n        radd+=x-cur;\n    }\n    void insert()\n    {\n        ll curl,curr;\n        tie(curl,curr)=ask();\n        if(curl<=0 && 0<=curr)\n        {\n            pql.push(-ladd);\n            pqr.push(-radd);\n            return;\n        }\n        else if(0<curl)\n        {\n            pql.push(-ladd);\n            pql.push(-ladd);\n            ll k=pql.top()+ladd;pql.pop();\n            pqr.push(k-radd);\n            //ll nl=pql.top()+ladd;\n            f+=abs(k);\n            //add 0 f \n        }\n        else\n        {\n            pqr.push(-radd);\n            pqr.push(-radd);\n            ll k=pqr.top()+radd;pqr.pop();\n            pql.push(k-ladd);\n            f+=abs(k);\n        }\n    }\n} h;\nvoid build()\n{\n    h.pql.push(0);h.pqr.push(0);\n    REP1(i,2,n)\n    {\n        ll f=l[i-1]-r[i],g=r[i-1]-l[i];\n        ll p,q;tie(p,q)=h.ask();\n        debug(i,f,g,p,q);\n        h.lsh(f+p);h.rsh(g+q);\n        h.insert();\n        //f+x1<=x2<=g+x1\n    }\n    PL(h.f);\n}\nvoid sol(){}\nint main()\n{\n    read();\n    build();\n    sol();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*End Of File*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= int(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\n\nll solve(int n, vector<int> const & l, vector<int> const & r) {\n    int w = *max_element(ALL(r)) + 100;\n    vector<ll> cur(w, LLONG_MAX), prv;\n    REP (x, w) cur[x] = abs(x - l[0]);\n    REP (i, n - 1) {\n        cur.swap(prv);\n        cur.assign(w, LLONG_MAX);\n        REP (x, w) {\n            int l1 = max(0, x - (r[i] - l[i]) + 1);\n            int r1 = min(w, x + (r[i + 1] - l[i + 1]));\n            REP3 (x1, l1, r1) {\n                chmin(cur[x], prv[x1] + abs(x - l[i + 1]));\n            }\n        }\n    }\n    return *min_element(ALL(cur));\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> l(n), r(n);  // [l, r)\n    REP (i, n) {\n        cin >> l[i] >> r[i];\n        -- l[i];\n    }\n    cout << solve(n, l, r) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, Left[100009], Right[100009], sz[100009];\nmultiset < long long > L, R;\nlong long leftDeflection, rightDeflection, ans = 0;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &Left[i], &Right[i]), sz[i] = Right[i] - Left[i];\nL.insert (Left[1]), leftDeflection = 0;\nR.insert (Left[1]), rightDeflection = 0;\nfor (int i=2; i<=N; i++)\n{\n    int A = sz[i - 1], B = sz[i];\n    ///f(x) = min (f(x - A), ..., f(x + B)\n    leftDeflection += B, rightDeflection += A;\n    long long x = Left[i], st = (*L.rbegin ()) - leftDeflection, dr = (*R.begin ()) + rightDeflection;\n    if (st <= x && x <= dr)\n    {\n        L.insert (x + leftDeflection);\n        R.insert (x - rightDeflection);\n        continue;\n    }\n    if (x < st)\n    {\n        ans += st - x;\n        auto it = L.end (); it --;\n        L.erase (it);\n\n        L.insert (x + leftDeflection);\n        L.insert (x + leftDeflection);\n        R.insert (st + leftDeflection);\n        continue;\n    }\n    ans += x - dr;\n    R.erase (R.begin ());\n\n    L.insert (dr - rightDeflection);\n    R.insert (x - rightDeflection);\n    R.insert (x - rightDeflection);\n}\nprintf (\"%lld\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;    \n\nstatic int getMinCost(vector<int> nodes,\n\t       int curmincost,\n\t       int minpos)\n{\n    if (nodes.size() == 0) {\n\treturn curmincost;\n    }\n    \n\n    int len = nodes.size();\n    auto rf = nodes.begin() + len / 2;\n    auto ll = nodes.begin() + len / 2 - 1;\n    \n    if (*ll <= minpos) {\n\tif (minpos <= *rf) {\n\t    return curmincost;\t    \n\t}\n\treturn minpos - *rf + curmincost;\n    } else {\n\treturn *ll - minpos + curmincost;\n    }\n}\n\nint main(void){\n    int n;\n    int mincost;\n    vector<int> nodes;\n    stringstream st;\n    string line;\n    vector<pair<int, int>> rects;\n\n    \n    getline(cin, line);\n    st.str(line);\n    st >> n;\n\n    for (int i = 0; i < n; i++) {\n\tint l, r;\n\tgetline(cin, line);\n\tst.str(line);\n\tst.clear();\n\tst.seekg(0);\n\tst >> l >> r;\n\trects.push_back(pair<int, int>(l, r));\n    }\n\n    mincost = 0;\n    for (int i = 1; i < n; i++) {\n\tint l = rects[i - 1].first;\n\tint r = rects[i - 1].second;\n\tint nl = rects[i].first;\n\tint nr = rects[i].second;\n\tmincost = getMinCost(nodes, mincost, l);\n\t//cout << l << \" \" << r << \" \" << mincost << endl;\n\tauto il = lower_bound(nodes.begin(), nodes.end(), l);\n\tnodes.insert(il, 2, l);\n\tint len = nodes.size();\n\tint j = 0;\n\tfor (auto &e : nodes) {\n\t    if (j < len / 2) {\n\t\te -= nr - nl;\n\t    } else {\n\t\te += r - l;\n\t    }\n\t    j++;\n\t}\n\t#if 0\n\tfor (auto e : nodes) {\n\t    cout << e << \" \";\n\t}\n\t#endif\n\tcout << endl;\n\t\n    }\n    mincost = getMinCost(nodes, mincost, rects[n - 1].first);\n\n    cout << mincost << endl;\n    return 0;\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\npriority_queue<ll> lft;\npriority_queue<ll,vector<ll>,greater<ll>> rht;\nll lo = 0LL, ro = 0LL;\nll ans = 0LL;\n\nconst int limit = 100010;\nll l[limit],r[limit],p[limit];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i,n){\n\t\tcin >> l[i] >> r[i];\n\t\tp[i] = r[i] - l[i];\n\t}\n\n\tlft.push(l[0]-lo);\n\trht.push(l[0]-ro);\n\t\n\n\trep(i,1,n){\n\t\tlo -= p[i],ro += p[i-1];\n\t\t\n\t\tlft.push(l[i]-lo);\n\t\trht.push(l[i]-ro);\n\t\n\t\twhile(lft.top() + lo > rht.top() + ro){\n\t\t\tll L = lft.top() + lo, R = rht.top() + ro;\n\t\t\tlft.pop(),rht.pop();\n\t\t\tans += L - R;\n\t\t\tlft.push(R - lo), rht.push(L - ro);\n\t\t}\n\t}\n\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nint l[100005], r[100005], le[100005];\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\", &l[i], &r[i]);\n        le[i] = r[i]-l[i];\n    }\n    multiset<ll> L, R;\n    L.insert(r[1]);\n    R.insert(r[1]);\n    ll ans = 0;\n\n    ll sl = 0, sr = 0;\n    for(int i=2;i<=n;i++){\n        ll s = *L.rbegin()-sl-le[i-1], e = *R.begin()+sr+le[i];\n        sl += le[i-1];\n        sr += le[i];\n        if(s <= r[i] && r[i] <= e){\n            L.insert(r[i]+sl);\n            R.insert(r[i]-sr);\n        }\n        else if(r[i] < s){\n            ans += abs(s-r[i]);\n            L.erase(--L.end());\n            L.insert(r[i]+sl);\n            L.insert(r[i]+sl);\n            R.insert(s-sr);\n        }\n        else{\n            ans += abs(e-r[i]);\n            R.erase(R.begin());\n            R.insert(r[i]-sr);\n            R.insert(r[i]-sr);\n            L.insert(e+sl);\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define inf (1ll<<56)\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,l,r,tl,tr,L,R,len,ans;\npriority_queue <ll> q1;\npriority_queue <ll, vector<ll>, greater<ll> > q2;\nsigned main()\n{\n\tn=read(); while(n--)\n\t{\n\t\tl=read(); r=read(); len=r-l;\n\t\ttr+=len;\n\t\tq1.push(r-tl); q2.push(r-tr);\n\t\twhile((L=q1.top()+tl)>(R=q2.top()+tr))\n\t\t{\n\t\t\tans+=L-R;\n\t\t\tq1.pop(); q2.pop();\n\t\t\tq1.push(R-tl); q2.push(L-tr);\n\t\t}\n\t\ttl-=len;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\nint n;\nint l[100000], r[100000];\n\nint main(){\n    I(n);\n    rep(i,n) I(l[i],r[i]);\n    ll ans = INF*(ll)INF;\n    rep(i,n){\n        ll cnt = 0;\n        ll nowl = l[i], nowr = r[i];\n        for(int j = i+1;  j < n; j++){\n            if(nowl > r[j]){\n                cnt += nowl-r[j];\n                nowr = nowl;\n                nowl = nowr-(r[j]-l[j]);\n            } else if(nowr < l[j]){\n                cnt += l[j]-nowr;\n                nowl = nowr;\n                nowr = nowl + (r[j]-l[j]);\n            } else{\n                nowl = l[j];\n                nowr = r[j];\n            }\n        }\n        nowl = l[i]; nowr = r[i];\n        for(int j = i-1; j >= 0; j--){\n            if(nowl > r[j]){\n                cnt += nowl-r[j];\n                nowr = nowl;\n                nowl = nowr-(r[j]-l[j]);\n            } else if(nowr < l[j]){\n                cnt += l[j]-nowr;\n                nowl = nowr;\n                nowr = nowl + (r[j]-l[j]);\n            } else{\n                nowl = l[j];\n                nowr = r[j];\n            }\n        }\n        ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nint n, dp[405][405];\nstruct rectangle {\n\tint l, r;\n} r[405];\n\nbool cmp(rectangle x, rectangle y) {\n\treturn x.l < y.l;\n}\n\nint abs(int x) {\n\treturn x > 0 ? x : -x;\n}\n\nint min(int x, int y) {\n\treturn x < y ? x : y;\n}\n\nint max(int x, int y) {\n\treturn x > y ? x : y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &r[i].l, &r[i].r);\n\tstd::sort(r, r + n, cmp);\n\tfor (int i = 0; i < n; i++) for (int j = 0; j <= 400; j++) dp[i][j] = 2e9;\n\tfor (int i = 0; i <= 400; i++) dp[0][i] = min(abs(i - r[0].r), abs(i - r[0].l));\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = r[i].r - r[i].l; j <= 400; j++) {\n\t\t\tfor (int k = j - r[i].r + r[i].l; k <= min(400, j + r[i].r - r[i].l); k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(j - r[i].r));\n\t\t\t}\n//\t\t\tif (j <= 30) printf(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tint ans = 2e9;\n\tfor (int i = 0; i <= 400; i++) ans = min(ans, dp[n - 1][i]);\n\tprintf(\"%d\\n\", ans);\n}\n\n/*\n5\n1 7\n5 9\n12 18\n16 20\n24 30\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> l(n), r(n),len(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)len[i] = r[i] - l[i];\n\tll ml = l[0], mr = l[0];\n\tint lec = 1, ric = 1;\n\tll my = 0;\n\trep1(i, n - 1) {\n\t\tif (r[i] < ml) {\n\t\t\tmy += ml - r[i];\n\t\t\tif (lec == 1) {\n\t\t\t\tlec = 2;\n\t\t\t\tif (mr != ml) {\n\t\t\t\t\tric = 1;\n\t\t\t\t}\n\t\t\t\tmr = ml;\n\t\t\t\tml = l[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ml != mr)ric = 1;\n\t\t\t\tmr = ml;\n\t\t\t\tlec = 1;\n\t\t\t}\n\t\t}\n\t\telse if (l[i] > mr+len[i-1]) {\n\t\t\tmy += l[i] - mr - len[i - 1];\n\t\t\tif (ric == 1) {\n\t\t\t\tif (ml != mr) {\n\t\t\t\t\tlec = 1;\n\t\t\t\t}\n\t\t\t\tric = 2;\n\t\t\t\tml = mr; mr = l[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ml != mr) {\n\t\t\t\t\tlec = 1;\n\t\t\t\t}\n\t\t\t\tml = mr;\n\t\t\t\tric = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ml-len[i] != l[i])lec = 1;\n\t\t\tif (mr+len[i-1] != l[i])ric = 1;\n\t\t\tml = mr = l[i];\n\t\t}\n\t}\n\tcout << my << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <cstdio>\n#include <queue>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\ntypedef long long ll; \nstd::priority_queue<ll> quel;\nstd::priority_queue<ll, std::vector<ll>, std::greater<ll> > quer; \nint l[100005], r[100005]; \nint main()\n{\n\t// freopen(\"ARC070-E.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tll ans = 0, st_l = 0, st_r = 0; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", l + i, r + i); \n\t\tif (!i)\n\t\t{\n\t\t\tquel.push(l[i]); \n\t\t\tquer.push(l[i]); \n\t\t\tcontinue; \n\t\t}\n\t\tst_l -= r[i] - l[i]; \n\t\tst_r += r[i - 1] - l[i - 1]; \n\t\tll x = quel.top() + st_l, y = quer.top() + st_r; \n\t\tif (l[i] < x)\n\t\t{\n\t\t\tans += my_abs(x - l[i]); \n\t\t\tquer.push(x - st_r); \n\t\t\tquel.push(l[i] - st_l); \n\t\t\tquel.push(l[i] - st_l); \n\t\t\tquel.pop(); \n\t\t}\n\t\telse if (l[i] > y)\n\t\t{\n\t\t\tans += my_abs(y - l[i]); \n\t\t\tquel.push(y - st_l); \n\t\t\tquer.push(l[i] - st_r); \n\t\t\tquer.push(l[i] - st_r); \n\t\t\tquer.pop(); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tquel.push(l[i] - st_l); \n\t\t\tquer.push(l[i] - st_r); \n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n\n\nusing namespace std;\nusing ll=long long;\nusing vll=vector<ll>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n\nvoid min_u(int&m, int v)\n{\n\tif(m>v) m=v;\n}\n\n\nvoid max_u(int&m, int v)\n{\n\tif(m<v) m=v;\n}\n\n\nint main(void)\n{\n\tint n;\n\n\twhile(scanf(\"%d\", &n)==1)\n\t{\n\t\tvi l(n), r(n);\n\t\tvvi dp(n);\n\n\t\tint l_max=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\t\tmax_u(l_max, l[i]);\n\t\t}\n\n\t\tif(l_max>1000) return 1;\n\n\t\tfor(auto&dpe:dp) dpe.assign(l_max+1, l_max*n);\n\n\n\t\tfor(int x=0;x<=l_max;x++)\n\t\t{\n\t\t\tdp[0][x]=abs(l[0]-x);\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n//printf(\"i=%d  l_max=%d\\n\", i, l_max);\n\t\t\tfor(int x=0;x<=l_max;x++)\n\t\t\t{\n\t\t\t\tint j_min=max(    0, x-(r[i-1]-l[i-1]));\n\t\t\t\tint j_max=min(l_max, x+r[i]-l[i]);\n\t\t\t\tfor(int j=j_min;j<=j_max;j++)\n\t\t\t\t{\n\t\t\t\t\tmin_u(dp[i][x], abs(l[i]-x)+dp[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=dp[n-1][0];\n\t\tfor(auto dpe:dp[n-1]) min_u(ans, dpe);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 403\nint n;\nvector<P> p;\nint dp[N][N];\n\n#define R_MAX 400\n\nint main() {\n  cin >> n;\n  rep(i, n) {\n    int l, r;\n    cin >> l >> r;\n    p.push_back(P(l, r));\n  }\n  sort(ALL(p));\n  rep(i, n) {\n    rep(j, R_MAX+1) dp[i][j] = INF;\n  }\n  // 0\n  repl(i, 0, p[0].first-1) {\n    dp[0][i] = p[0].first - i;\n  }\n  repl(i, p[0].first, p[0].second) {\n    dp[0][i] = 0;\n  }\n  repl(i, p[0].second+1, R_MAX) {\n    dp[0][p[0].second] = i - p[0].second;\n  }\n\n  repl(i, 1, n-1) {\n    int l = p[i].second - p[i].first;\n    // hidari\n    repl(j, 0, p[i].first-1) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j] + (p[i].first - j));\n      }\n    }\n    // sonomama\n    repl(j, p[i].first, p[i].second) {\n      rep(k, l+1) {\n        dp[i][p[i].first+k] = mind(dp[i][p[i].first+k], dp[i-1][j]);\n      }\n    }\n    // migi\n    repl(j, p[i].second+1, R_MAX) {\n      rep(k, l) {\n        dp[i][j+k] = mind(dp[i][j+k], dp[i-1][j] + (j - p[i].second));\n      }\n    }\n  }\n\n  int ans = INF;\n  rep(i, R_MAX+1) {\n    ans = mind(ans, dp[n-1][i]);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll N;\nll a[100005],b[100005];\n\nll dp[2][405];\nvoid solve(){\n\n  if(N==1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  ll INF=(1LL<<60);\n  fill( dp[0],dp[2] , INF);\n\n  for(int i=1;i<=400;i++){\n    dp[1][ i ]= abs(a[1]-i);\n  }\n\n  ll ans=INF;\n  \n  for(int i=1;i+1<=N;i++){\n    int ai=i%2;\n    int bi=1-ai;\n\n    for(int j=0;j<405;j++)dp[bi][j]=INF;\n    \n    for(int j=1;j<=400;j++){\n      int len0=b[i]-a[i]+1;\n      int len1=b[i+1]-a[i+1]+1;\n      int fi=j-len1+1;\n      int se=j+len0-1;\n      if(fi<1)fi=1;\n      if(se>400)se=400;\n      for(int k=fi;k<=se;k++){\n        dp[bi][k]=min(dp[bi][k],dp[ai][j]+abs(a[i+1]-k));\n        if(i+1==N)ans=min(ans,dp[bi][k]);\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>N;\n  assert(N<=400);/////////////////////////////////////////\n  \n  for(int i=1;i<=N;i++){\n    cin>>a[i]>>b[i];\n    assert(a[i]<=400);/////////////////////////////////////////\n    assert(b[i]<=400);/////////////////////////////////////////\n  }\n\n  solve();  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\n#include <random>\n#include <ctime>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nmt19937 mt_rand(time(NULL));\nstruct Treap {\n  int k, p, cnt, lazy;\n  Treap *ch[2];\n  Treap(int k) : k(k), p(mt_rand()), cnt(1), lazy(0) {\n    ch[0] = ch[1] = NULL;\n  }\n};\ninline int count(Treap *t) { return t == NULL ? 0 : t->cnt; }\ninline void setLazy(Treap *t, int v) {\n  if (t == NULL) return;\n  t->lazy += v;\n  t->k += v;\n}\ninline void push(Treap *t) {\n  if (t == NULL || t->lazy == 0) return;\n  setLazy(t->ch[0], t->lazy);\n  setLazy(t->ch[1], t->lazy);\n  t->lazy = 0;\n}\ninline Treap* update(Treap *t) {\n  if (t == NULL) return t;\n  push(t);\n  t->cnt = 1 + count(t->ch[0]) + count(t->ch[1]);\n  return t;\n}\nTreap *merge(Treap *l, Treap *r) {\n  if (l == NULL) return r;\n  if (r == NULL) return l;\n  if (l->p > r->p) {\n    push(l);\n    l->ch[1] = merge(l->ch[1], r);\n    return update(l);\n  }\n  else {\n    push(r);\n    r->ch[0] = merge(l, r->ch[0]);\n    return update(r);\n  }\n}\npair<Treap*, Treap*> split_by_cnt(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (k <= count(t->ch[0])) {\n    auto s = split_by_cnt(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n  else {\n    auto s = split_by_cnt(t->ch[1], k-1-count(t->ch[0]));\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n}\npair<Treap*, Treap*> split_by_key(Treap *t, int k) {\n  if (t == NULL) return {NULL, NULL};\n  push(t);\n  if (t->k < k) {\n    auto s = split_by_key(t->ch[1], k);\n    t->ch[1] = s._1;\n    return { update(t), s._2 };\n  }\n  else {\n    auto s = split_by_key(t->ch[0], k);\n    t->ch[0] = s._2;\n    return { s._1, update(t) };\n  }\n}\n\nint find(Treap *t, int k) {\n  if (t == NULL) return INF;\n  push(t);\n  if (k < count(t->ch[0])) return find(t->ch[0], k);\n  else if (k == count(t->ch[0])) return t->k;\n  else return find(t->ch[1], k-1-count(t->ch[0]));\n}\nTreap *insert(Treap *t, int k) {\n  auto s = split_by_key(t, k);\n  return merge(merge(s._1, new Treap(k)), s._2);\n}\nvoid add_key(Treap *t, int v) { setLazy(t, v); }\n\nvoid for_each(Treap *t, function<void(int)> f) {\n  if (t == NULL) return;\n  push(t);\n  for_each(t->ch[0], f);\n  f(t->k);\n  for_each(t->ch[1], f);\n}\n\nint N;\nint L[100000], R[100000];\nTreap *S;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> L[i] >> R[i];\n  long long C = 0;\n  S = insert(S, L[0]);\n  S = insert(S, L[0]);\n  rep(i, N-1) {\n    int len = R[i+1]-L[i+1] + R[i]-L[i];\n    int shift = R[i]-L[i];\n    auto s = split_by_cnt(S, ((S->cnt-1)/2)+1);\n    add_key(s._1, -len);\n    C -= 1LL*count(s._1)*len;\n    S = merge(s._1, s._2);\n    add_key(S, shift);\n    S = insert(S, L[i+1]);\n    S = insert(S, L[i+1]);\n    int center = find(S, (S->cnt-1)/2);\n  }\n  //for_each(S, [&](int x) { cout<<x<<\",\"; });cout<<\"\\n\";\n  int center = find(S, (S->cnt-1)/2);\n  long long s = C;\n  for_each(S, [&](int x) { s += abs(x-center); });\n  cout << s/2 << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, Left[100009], Right[100009], sz[100009];\nmultiset < long long > L, R;\nlong long leftDeflection, rightDeflection, ans = 0;\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &Left[i], &Right[i]), sz[i] = Right[i] - Left[i];\nL.insert (Left[1]), leftDeflection = 0;\nR.insert (Left[1]), rightDeflection = 0;\nfor (int i=2; i<=N; i++)\n{\n    int A = sz[i - 1], B = sz[i];\n    ///f(x) = min (f(x - A), ..., f(x + B)\n    leftDeflection += B, rightDeflection += A;\n    long long x = Left[i], st = (*L.rbegin ()) - leftDeflection, dr = (*R.begin ()) + rightDeflection;\n    if (st <= x && x <= dr)\n    {\n        L.insert (x + leftDeflection);\n        R.insert (x - rightDeflection);\n        continue;\n    }\n    if (x < st)\n    {\n        ans += st - x;\n        auto it = L.end (); it --;\n        L.erase (it);\n\n        L.insert (x + leftDeflection);\n        L.insert (x + leftDeflection);\n        R.insert (dr - rightDeflection);\n        continue;\n    }\n    ans += x - dr;\n    R.erase (R.begin ());\n\n    L.insert (st + leftDeflection);\n    R.insert (x - rightDeflection);\n    R.insert (x - rightDeflection);\n}\nprintf (\"%lld\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nconst int max_n = 1e5+10;\n\nint n;\n\npriority_queue<ll> ql;\npriority_queue<ll,vector<ll>,greater<ll>> qr;\n\nll xs[200010];\n\nint main()\n{\n\tread(n);\n    ll g0 = 0;\n    ll miny = 0;\n    ll befl=0;\n    ll dl=0, dr=0;\n    for(;n--;){\n\t\tll l, r; read(l, r);\n\t\tll curl = r-l;\n\t\tdl += curl; dr += befl;\n\t\tif(ql.size()) miny += abs(ql.top()-dl - l);\n\t\tll gx=(ql.empty()?0:ql.top()-dl);\n\t\tfor(int i=0; i<2; ++i) ql.push(l + dl);\n\t\tqr.push(ql.top()-dl-dr); ql.pop();\n\t\twhile(ql.top()-dl>qr.top()+dr){\n\t\t\tqr.push(ql.top()-dl-dr);\n\t\t\tql.push(qr.top()+dl+dr);\n\t\t\tql.pop(); qr.pop();\n\t\t}\n\t\t++g0; befl=curl;\n\t\tif(g0>1){\n\t\t\tif(qr.top()+dr < gx) miny -= (gx-(qr.top()+dr));\n\t\t\telse if(gx < ql.top()-dl) miny -= ((ql.top()-dl) - gx);\n\t\t}\n    }\n    printf(\"%lld\\n\", miny);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define V vector<int>\n#define P pair<int, int>\n#define mp make_pair<int&, int>\nint N, l[100010], r[100010];\nmultiset<int> sl, sr;\nint ld, rd;\nint le, rb;\nvoid ins(int l, int r)\n{\n    if (le >= r - rd) {\n        sl.insert(l + ld);\n        sl.insert(r + ld);\n        sl.erase(le);\n        sr.insert(le - ld - rd);\n    } else if (rb <= l + ld) {\n        sr.insert(l - rd);\n        sr.insert(r - rd);\n        sr.erase(rb);\n        sl.insert(rb + rd + ld);\n    } else {\n        sr.insert(r - rd);\n        sl.insert(l + ld);\n    }\n}\nvoid show()\n{\n    auto it = sl.begin();\n    while (it != sl.end()) {\n        int value = *it;\n        std::cout << value - ld << \" \";\n        ++it;\n    }\n    cout << endl;\n    it = sr.begin();\n    while (it != sr.end()) {\n        int value = *it;\n        std::cout << value + rd << \" \";\n        ++it;\n    }\n    cout << endl\n         << endl;\n}\nvoid solve()\n{\n    int ans = 0;\n    FOR(i, 0, N)\n    {\n        if (i == 0) {\n            sl.insert(l[i]);\n            sr.insert(l[i]);\n        }\n        if (i == 0)\n            continue;\n        int L = r[i] - l[i];\n        int LB = r[i - 1] - l[i - 1];\n        ld += L;\n        rd += LB;\n        //show();\n\n        /*\n        le = *(--sl.end());\n        rb = *(sr.begin());\n\n        if (le >= r[i] - rd) {\n            sl.insert(l[i] + ld);\n            sl.insert(r[i] + ld);\n            sl.erase(le);\n            sr.insert(le - ld - rd);\n            cout << 'a' << endl;\n        } else if (rb <= l[i] + ld) {\n            sr.insert(l[i] - rd);\n            sr.insert(r[i] - rd);\n            sr.erase(rb);\n            sl.insert(rb + rd + ld);\n            cout << 'b' << endl;\n        } else {\n            sr.insert(r[i] - rd);\n            sl.insert(l[i] + ld);\n            cout << 'c' << endl;\n        }\n        show();*/\n        int lep, rbp;\n        lep = le;\n        rbp = rb;\n        le = *(--sl.end());\n        auto lei = --sl.end();\n        rb = *(sr.begin());\n        auto rbi = sr.begin();\n        if (le - ld > l[i]) {\n            sl.insert(l[i] + ld);\n            sl.insert(l[i] + ld);\n            //le = *(--sl.end());\n            //lei = --sl.end();\n            sl.erase(lei);\n            sr.insert(le - ld - rd);\n            // ans += le - *(--lei);\n            //cout << 'A' << endl;\n        } else if (rb + rd < l[i]) {\n            sr.insert(l[i] - rd);\n            sr.insert(l[i] - rd);\n            //rb = *(sr.begin());\n            //rbi = sr.begin();\n            sr.erase(rbi);\n            sl.insert(rb + rd + ld);\n            //  ans += *(++rbi) - rb;\n            //cout << 'B' << endl;\n        } else {\n            sr.insert(l[i] - rd);\n            sl.insert(l[i] + ld);\n            //cout << 'C' << endl;\n        }\n        le = *(--sl.end());\n        rb = *(sr.begin());\n        ans += rb + rd - le + ld;\n        //show();\n        //dump(ans)\n    }\n    //show();\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    FOR(i, 0, N)\n    cin >> l[i] >> r[i];\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int64_t i, j, k;\n    int N;\n    cin >> N;\n    const int MAX = 100000;\n    int64_t L[MAX], R[MAX];\n    for(i=0; i<N; i++) cin >> L[i] >> R[i];\n\n    int64_t ans = 0, loffset = 0, roffset = 0;\n    multiset<int64_t> lpt, rpt;\n    lpt.insert(L[0]);\n    rpt.insert(L[0]);\n\n    for(i=1; i<N; i++){\n        loffset -= R[i] - L[i];\n        roffset += R[i-1] - L[i-1];\n        int64_t ledge = *prev(lpt.end()) + loffset;\n        int64_t redge = *rpt.begin() + roffset;\n        if(L[i] < ledge){\n            ans += ledge - L[i];\n            lpt.erase(prev(lpt.end()));\n            rpt.insert(ledge - roffset);\n            for(k=0; k<2; k++) lpt.insert(L[i] - loffset);\n        }else if(redge < L[i]){\n            ans += L[i] - redge;\n            rpt.erase(rpt.begin());\n            lpt.insert(redge - loffset);\n            for(k=0; k<2; k++) rpt.insert(L[i] - roffset);\n        }else{\n            lpt.insert(L[i] - loffset);\n            rpt.insert(L[i] - roffset);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint L[101010],R[101010],S[101010];\n\nll C[404][404];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>L[i]>>R[i], S[i]=R[i]-L[i];\n\t\n\tif(N>400) return;\n\tFOR(i,N) if(R[i]>400) return;\n\t\n\tFOR(i,N+1) FOR(x,403) C[i][x]=1LL<<60;\n\tFOR(i,401) C[1][i]=abs(L[0]-i);\n\t\n\tfor(i=1;i<N;i++) {\n\t\tFOR(y,401) {\n\t\t\tint add=abs(L[i]-y);\n\t\t\tFOR(x,401) {\n\t\t\t\tif((x<=y&&S[i-1]>=y-x) || (x>=y&&S[i]>=x-y)) C[i+1][y]=min(C[i+1][y],C[i][x]+add);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<*min_element(C[N],C[N]+401)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <set>\n#include <utility>\ntypedef long long ll;\n\nconst int maxn = 100010;\n\nstd::set<ll> inc,dec;\nstd::set<ll>::iterator iter;\nll l[maxn], r[maxn], len[maxn];\n\nint main()\n{\n\t//freopen(\"E.in\",\"r\",stdin);\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\tll offset_dec = 0, offset_inc  = 0, ans = 0;\n\tscanf(\"%lld%lld\",&l[1], &r[1]);\n\tdec.insert(r[1]); inc.insert(r[1]); len[1] = r[1] - l[1];\n\t\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&l[i],&r[i]);\n\t\tlen[i] = r[i] - l[i];\n\t\t\n\t\t//parallel move to both sides\n\t\toffset_dec -= len[i-1];\n\t\toffset_inc += len[i];\n\t\t\n\t\t// + |x-Ri|\n\t\tif (r[i] >= *inc.begin() + offset_inc)\n\t\t{\n\t\t\tans += r[i] - (*inc.begin() + offset_inc);\n\t\t\tdec.insert(*inc.begin() + offset_inc - offset_dec);\n\t\t\tinc.erase(inc.begin());\n\t\t\tinc.insert(r[i] - offset_inc);\n\t\t\tinc.insert(r[i] - offset_inc);\n\t\t}\n\t\telse if (r[i] <= *(dec.rbegin()) + offset_dec)\n\t\t{\n\t\t\tans += (*dec.rbegin() + offset_dec) - r[i];\n\t\t\tinc.insert(*dec.rbegin() + offset_dec - offset_inc);\n\t\t\titer = dec.end();\n\t\t\titer--;\n\t\t\tdec.erase(iter);\n\t\t\tdec.insert(r[i] - offset_dec);\n\t\t\tdec.insert(r[i] - offset_dec);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdec.insert(r[i] - offset_dec);\n\t\t\tinc.insert(r[i] - offset_inc);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n\t> File Name: C.cpp\n\t> Author: Akira\n\t> Mail: qaq.febr2.qaq@gmail.com\n\t> Created Time: 2017年03月18日 星期六 21时37分41秒\n ************************************************************************/\n\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<list>\n#include<ctime>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n#define MST(a,b) memset(a,b,sizeof(a))\n#define CLR(a) MST(a,0)\n#define Sqr(a) ((a)*(a))\n\nusing namespace std;\n\n#define MaxN 100001\n#define MaxM MaxN*10\n#define INF 0x3f3f3f3f\n#define PI 3.1415926535897932384626\nconst int mod = 1e9+7;\nconst int eps = 1e-8;\n#define bug cout << 88888888 << endl;\n\nint N;\n\nstruct Line\n{\n    LL l,r;\n    double mid;\n}line[MaxN];\n\nint main()\n{\n    scanf(\"%d\", &N);\n    double sum = 0;\n    for(int i=0;i<N;i++)\n    {\n        scanf(\"%lld%lld\", &line[i].l, &line[i].r);\n        line[i].mid = (line[i].l + line[i].r)/2.0;\n        sum += line[i].mid;\n    }\n    LL loc = sum/N;\n    LL ans = 0;\n    for(int i=0;i<N;i++)\n    {\n        if(line[i].r < loc) ans += (loc-line[i].r);\n        if(line[i].l > loc) ans += (line[i].l-loc);\n    }\n    printf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MN = 100010;\n\nint N;\nll L[MN], R[MN], D[MN];\nmultiset<ll> le, ri;\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lld %lld\", &L[i], &R[i]);\n        D[i] = R[i] - L[i];\n    }\n\n    le.insert(R[0]);\n    ri.insert(R[0]);\n    ll loffset = 0;\n    ll roffset = 0;\n    ll ans = 0;\n\n    for(int i = 1; i < N; i++) {\n        loffset -= D[i - 1];\n        roffset += D[i];\n\n        ll l = *le.rbegin() + loffset;\n        ll r = *ri.begin() + roffset;\n\n        if(r < R[i]) {\n            ri.erase(ri.find(r - roffset));\n            le.insert(r - loffset);\n            ri.insert(R[i] - roffset);\n            ri.insert(R[i] - roffset);\n            ans += R[i] - r;\n        }\n        else if(R[i] < l) {\n            le.erase(le.find(l - loffset));\n            ri.insert(l - roffset);\n            le.insert(R[i] - loffset);\n            le.insert(R[i] - loffset);\n            ans += l - R[i];\n        }\n        else {\n            le.insert(R[i] - loffset);\n            ri.insert(R[i] - roffset);\n        }\n    }\n\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 410;\n\nint l[N], r[N], len[N], f[N][N];\n\nint main () {\n\n\tFile();\n\n\tint n = read();\n\n\tFor (i, 1, n) \n\t\tl[i] = read(), r[i] = read(), len[i] = r[i] - l[i];\n\n\tint maxl = *max_element(r + 1, r + n + 1);\n\tFor (i, 1, maxl) f[1][i] = abs(i - r[1]);\n\n\tFor (i, 2, n) For (j, 1, maxl) {\n\t\tf[i][j] = 1e9;\n\t\tFor (k, max(1, j - len[i - 1]), min(maxl, j + len[i])) \n\t\t\tchkmin(f[i][j], f[i - 1][k]);\n\t\tf[i][j] += abs(j - r[i]);\n\t}\n\n\tint ans = 1e9;\n\tFor (j, 1, maxl) chkmin(ans, f[n][j]);\n\tprintf (\"%d\\n\", ans);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_bound\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\ninline void Input_Output () {\n\t//freopen(\".in\", \"r\", stdin);\n   //freopen(\".out\", \"w\", stdout);\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 6e5 + 123;                                          \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n \nint n;\nint l[N], r[N];\n\nint main () {\n\tSpeedForce;\n\tcin >> n;\n\tvector < int > pt;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\t\n\n\tint ans = inf;\n\tfor (int x = 1; x <= 400; x++) {\n\t\tfor (int y = x; y <= 400; ++y) {\n\t\t\tll res = 0;\n\t\t\n\t\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\t\tif (x > r[i]) res += x - r[i];\n\t\t\t\tif (y < l[i]) res += l[i] - y;\n\t\t\t\tif (y > r[i] && x <= l[i]) {\n\t\t\t\t\tres = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (y >= r[i] && x < l[i]) {\n\t\t\t\t\tres = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} \n\t\t\tif(ans > res) ans = res;\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\n\n   \treturn Accepted;\n}\n\n// B...a"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nmultiset<ll> sl,sr;\nll ans,tl,tr,i,j,k,n,a[200001],b[200001];\nll av(ll x){\n\treturn (x>=0)?x:-x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i],&b[i]);\n\tsl.clear();sr.clear();sl.insert(a[1]);sr.insert(a[1]);\n\tfor (i=2,ans=tl=tr=0;i<=n;i++){\n\t\ttl+=b[i]-a[i];tr+=b[i-1]-a[i-1];j=*(sl.rbegin());k=*(sr.begin());\n\t\tif (j-tl>a[i]){\n\t\t\tans+=av(j-tl-a[i]);\n\t\t\tsl.erase(sl.find(j));sl.insert(a[i]+tl);sl.insert(a[i]+tl);sr.insert(j-tl-tr);\n\t\t}else if (a[i]>k+tr){\n\t\t\tans+=av(k+tl-a[i]);\n\t\t\tsr.erase(sr.find(k));sr.insert(a[i]-tr);sr.insert(a[i]-tr);sl.insert(k+tr+tl);\n\t\t}else{\n\t\t\tsl.insert(a[i]+tl);sr.insert(a[i]-tr);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <assert.h>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <memory.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000;\nint n;\npair<ll, ll> v[N];\nll shift[N];\nbool intersect(ll l1, ll r1, ll l2, ll r2) {\n\tif (l2 >= l1 && l2 <= r1)\n\t\treturn true;\n\tif (r2 >= l1 && r2 <= r1)\n\t\treturn true;\n\treturn l1 >= l2 && l1 <= r2;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tint sh = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld%lld\", &v[i].first, &v[i].second);\n\t\tif (i) {\n\t\t\tif (intersect(v[i].first+sh, v[i].second+sh, v[i - 1].first + shift[i - 1], v[i - 1].second + shift[i - 1]))\n\t\t\t\tcontinue;\n\t\t\tif (v[i].second + sh < v[i - 1].first + shift[i - 1])\n\t\t\t\tsh += v[i - 1].first + shift[i - 1] - (v[i].second + sh);\n\t\t\telse\n\t\t\t\tsh -= (v[i].first + sh) - (v[i - 1].second + shift[i - 1]);\n\t\t}\n\t\tshift[i] = sh;\n\t}\n\tll l = -1e10, r = 1e10, m, res = 1e18;\n\tll l1, l2, r1, r2;\n\twhile (l <= r) {\n\t\tl1 = (2 * l + r) / 3;\n\t\tl2 = (l + 2 * r) / 3;\n\t\tr1 = r2 = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tr1 += abs(shift[i] + l1);\n\t\t\tr2 += abs(shift[i] + l2);\n\t\t}\n\t\tres = min({ r1,r2,res });\n\t\tif (r1 == r2) {\n\t\t\t++l;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r1 > r2)\n\t\t\tl = l1 + 1;\n\t\telse\n\t\t\tr = l2 - 1;\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nint n, D[410][410], L[410];\nint main(){\n    int i, l, r, j, k;\n    L[0] = 400;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d%d\",&l,&r);\n        L[i] = r-l;\n        for(j=1;j<=400;j++)D[i][j]=1e9;\n        for(j=1;j<=400;j++){\n            for(k=1;k<=400;k++){\n                if(k-j > L[i-1] || j-k > L[i])continue;\n                D[i][k] = min(D[i][k],D[i-1][j] + abs(k-l));\n            }\n        }\n    }\n    int res = 1e9;\n    for(i=1;i<=400;i++)res = min(res, D[n][i]);\n    printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <assert.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <memory.h>\n#include <time.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 400;\nint n, l[N], r[N], len[N], dp[N][N];\nbool intersect(int l1, int r1, int l2, int r2) {\n\tif (l2 >= l1 && l2 <= r1)\n\t\treturn true;\n\tif (r2 >= l1 && r2 <= r1)\n\t\treturn true;\n\treturn l1 >= l2 && l1 <= r2;\n}\nint calc(int i, int l) {\n\tif (i == n)\n\t\treturn 0;\n\tint &ret = dp[i][l];\n\tif (ret != -1)\n\t\treturn ret;\n\tret = 1e9;\n\tfor (int j = 0; j + len[i] < N; ++j) {\n\t\tif (!intersect(j, j + len[i], l, l + len[i - 1]))\n\t\t\tcontinue;\n\t\tret = min(ret, abs(j - ::l[i]) + calc(i + 1, j));\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d\", l + i, r + i);\n\t\t--l[i]; --r[i];\n\t\tlen[i] = r[i] - l[i];\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tint res = 1e9;\n\tfor (int i = 0; i + len[0] < N; ++i)\n\t\tres = min(res, abs(i - l[0]) + calc(1, i));\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint f(vector<pii> vp, int p){\n    int ret = 0;\n    for(auto e:vp){\n        int l = e.first;\n        int r = e.second;\n        if(l<=p && p<=r)continue;\n        ret+=min(abs(p-l),abs(p-r));\n    }\n    return ret;\n}\n\nint main(){\n    vector<pii> vp;\n    int n;\n    cin>>n;\n    assert(n<=500);\n    rep(i,n){\n        int l,r;\n        cin>>l>>r;\n        assert(r<=500);\n        vp.pb(pii(l,r));\n    }\n    \n    int mini = INF;\n    \n    for(int i=1;i<500;i++){\n        mini = min(mini,f(vp,i));\n    }\n    cout<<mini<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\n\nint main()\n{\n  int N, L[400], R[400];\n  cin >> N;\n  if(N > 400) throw (0);\n  for(int i = 0; i < N; i++) {\n    cin >> L[i] >> R[i];\n    --L[i];\n    --R[i];\n  }\n\n  vector< int64 > dp(400, INF);\n  for(int i = 0; i < 400; i++) {\n    if(i < L[0]) dp[i] = L[0] - i;\n    else if(i < R[0]) dp[i] = 0;\n    else dp[i] = i - R[0];\n  }\n  for(int i = 1; i < N; i++) {\n    vector< int64 > dp2(400, INF);\n    for(int j = 0; j < 400; j++) {\n      auto preleft = max(0, j - R[i - 1] - L[i - 1] + 1);\n      for(int k = preleft; k <= min(399, j + R[i] - L[i]); k++) {\n        dp2[j] = min(dp2[j], dp[k] + abs(L[i] - j));\n      }\n    }\n\n    dp.swap(dp2);\n  }\n\n\n  cout << *min_element(begin(dp), end(dp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvll L(N), R(N);\n\tfor (int i = 0; i < N; i++) cin >> L[i] >> R[i];\t\n\tmultiset<ll> ls, rs;\n\tll ofl = 0, ofr = 0;\n\n\tls.insert(L[0]);\n\trs.insert(L[0]);\n\n\tll ret = 0;\t\n\tfor (int i = 1; i < N; i++) {\n\t\tofl -= (R[i] - L[i]);\n\t\tofr += (R[i-1] - L[i-1]);\n\n\t\tif (*begin(rs)+ofr < L[i]) ret += L[i] - (*begin(rs)+ofr);\n\t\tif (L[i] < *rbegin(ls)+ofl) ret += (*rbegin(ls)+ofl) - L[i];\n\n\t\tif (*begin(rs)+ofr < L[i]) {\n\t\t\tls.insert(*begin(rs)+ofr-ofl);\n\t\t\trs.insert(L[i]-ofr);\n\t\t\trs.insert(L[i]-ofr);\n\t\t\trs.erase(begin(rs));\t\n\t\t} else if (L[i] < *rbegin(ls)+ofl) {\n\t\t\trs.insert(*rbegin(ls)+ofl-ofr);\n\t\t\tls.insert(L[i]-ofl);\n\t\t\tls.insert(L[i]-ofl);\n\t\t\tls.erase(*rbegin(ls));\n\t\t} else {\n\t\t\trs.insert(L[i]-ofr);\n\t\t\tls.insert(L[i]-ofl);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "// tzl ak IOI! \n \n#include<bits/stdc++.h>\n \n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l); i <= (r); ++i)\n#define nrof(i, r, l) for(int i = (r); i >= (l); --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n#define FILL(a, b) memset((a), (b), sizeof((a)))\n#define MCPY(a, b) memcpy((a), (b), sizeof((b)))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n \nconst int iinf = 1e9 + 7;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n \ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f = 0; x = 0; char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') { f = 1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }\n\tif(f) x = -x; return;\n}\n \ntemplate <typename T1, typename T2>\nvoid scf(T1 &x, T2 &y) { scf(x); return scf(y); }\n \ntemplate <typename T1, typename T2, typename T3>\nvoid scf(T1 &x, T2 &y, T3 &z) { scf(x); scf(y); return scf(z); }\n \ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid scf(T1 &x, T2 &y, T3 &z, T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n \ninline char mygetchar(){ char c = getchar(); while(c == ' ' || c == '\\n') c = getchar(); return c; }\n \ntemplate <typename T>\nvoid chkmax(T &x, const T &y){ if(y > x) x = y; return; }\n \ntemplate <typename T>\nvoid chkmin(T &x, const T &y){ if(y < x) x = y; return; }\n \n#define ONLINE_JUDGE\n \n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n \n//---------------------------head----------------------------\n \nconst LL oo = 1e13;\n \nmultiset<LL> scp_l, scp_r;\nLL dl, dr, ans;\n \nvoid TZL()\n{\n\tint n; scf(n);\n\tLL l, r; scf(l, r);\n\tscp_l.insert(l); scp_r.insert(l);\n\tLL lst = r - l;\n \n\tstatic LL x[100010], y[100010];\n\tx[0] = l; y[0] = r;\n\tforn(i, 1, n - 1)\n\t{\n\t\tscf(l, r);\n\t\tLL len = r - l;\n\t\tx[i] = l; y[i] = r;\n \n\t\tdl -= len; dr += lst;\n\t\tLL lb = *scp_l.rbegin() + dl;\n\t\tLL rb = *scp_r.begin() + dr;\n \n\t\tif(lb <= l && l <= rb)\n\t\t{\n\t\t\tscp_l.insert(l - dl);\n\t\t\tscp_r.insert(l - dr);\n\t\t}\n\t\telse if(l < lb)\n\t\t{\n\t\t\tscp_l.insert(l - dl);\n\t\t\tscp_l.insert(l - dl);\n \n\t\t\tLL foo = *scp_l.rbegin() + dl;\n\t\t\tscp_l.erase(scp_l.find(foo - dl));\n\t\t\tscp_r.insert(foo - dr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscp_r.insert(l - dr);\n\t\t\tscp_r.insert(l - dr);\n \n\t\t\tLL foo = *scp_r.begin() + dr;\n\t\t\tscp_r.erase(scp_r.begin());\n\t\t\tscp_l.insert(foo - dl);\n\t\t}\n \n\t\tlst = len;\n\t}\n \n\tLL cur_pos = -oo;\n\tper(i, n)\n\t{\n\t\tans += x[i] - cur_pos;\n\t\tcur_pos += y[i] - x[i];\n\t}\n\treturn;\n}\n \nvoid RANK1()\n{\n\tLL lst_pos = -oo, slope = -(LL)SZ(scp_l);\n\tfor(LL x: scp_l)\n\t{\n\t\tLL y = x + dl;\n\t\tans += (y - lst_pos) * slope;\n\t\tslope++;\n\t\tlst_pos = y;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn;\n}\n \n#define tzl int\n#define ak main\n#define IOI ()\ntzl ak IOI\n{\n#undef tzl\n#undef ak\n#undef IOI\n \n\tTZL();\n\tRANK1();\n \n#define tzl return\n#define caisi 0\n#define myy ;\n\ttzl caisi myy\n#undef tzl\n#undef caisi\n#undef myy\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n , l[N] , r[N];\nmultiset<ll> lpts , rpts;\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,0,n) scanf(\"%d%d\",l+i,r+i);\n  lpts.insert(l[0]);\n  rpts.insert(l[0]);\n  ll dL = 0 , dR = 0;\n  ll ans = 0;\n  rep(i,1,n) {\n    dL -= r[i] - l[i];\n    dR += r[i-1] - l[i-1];\n    ll L = *lpts.rbegin()+dL;\n    ll R = *rpts.begin()+dR;\n    if(l[i] < L) {\n      auto it=lpts.end();lpts.erase(--it);\n      ans += L - l[i];\n      lpts.insert(l[i]-dL);\n      lpts.insert(l[i]-dL);\n      rpts.insert(L-dR);\n    } else if(l[i] > R) {\n      auto it=rpts.begin();rpts.erase(it);\n      ans += l[i] - R;\n      rpts.insert(l[i]-dR);\n      rpts.insert(l[i]-dR);\n      lpts.insert(R-dL);\n    } else {\n      lpts.insert(l[i]-dL);\n      rpts.insert(l[i]-dR);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint dp[410][410];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tif (n > 400) return 0;\n\tvector<int> l(n), r(n), d(n);\n\tint rmax = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\trmax = max(rmax, r[i]);\n\t\td[i] = r[i] - l[i];\n\t}\n\tif (rmax > 400) return 0;\n\tfor (int i = 1; i <= 400; i++) dp[0][i] = abs(l[0] - i);\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j <= 400; j++) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 1; j <= 400; j++) {\n\t\t\tif (dp[i - 1][j] == INF) continue;\n\t\t\tfor (int k = max(j - d[i], 0); k <= min(j + d[i - 1], 400); k++) {\n\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + abs(k - l[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = INF;\n\tfor (int i = 1; i <= 400; i++) {\n\t\tans = min(ans, dp[n - 1][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong l[100000],r[100000];\n\nint main(int argc, char const *argv[]){\n\tlong n,i,pl=-1,pr=-1,ll,rr;\n\tlong long sum=0,x=0;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%ld %ld\",&l[i],&r[i]);\n\t\tsum+=r[i]-l[i];\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tll=pl;\n\t\trr=pr;\n\t\tif(r[i]<=l[i+1]){\n\t\t\tpl=r[i];\n\t\t\tpr=l[i+1];\n\t\t}else if(l[i]>=r[i+1]){\n\t\t\tpl=r[i+1];\n\t\t\tpr=l[i];\n\t\t}else{\n\t\t\tpl=-1;\n\t\t\tpr=-1;\n\t\t}\n\t\tif(ll==-1){\n\t\t}else if(pl==-1){\n\t\t}else{\n\t\t\tif(pr<=ll || rr<=pl){\n\t\t\t}else{\n\t\t\t\tx+=rr-ll+pr-pl-(((pr>rr)?pr:rr)-((pl<ll)?pl:ll));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",x);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n \n#define sl(x) scanf(\"%ld\", &x)\n#define ss(x) scanf(\"%s\", x)\n#define pl(x) printf(\"%ld\\n\", x)\n#define pd(x) printf(\"%lf\\n\", x)\n#define ps(x) printf(\"%s\\n\", x)\n \n#define INF 1000000000000000000\n#define MOD 1000000007\n \n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n\nint compare_long(const void *a, const void *b) {\n\treturn *(long*)a - *(long*)b;\n}\n \nint main() {\n\tlong N;\n\tlong l[100010];\n\tlong r[100010];\n\tlong sum;\n\tlong t = 0;\n\tlong ans = INF;\n\tlong right, left;\n\tlong max_right = 0;\n\tlong max_pos;\n\tlong child_count[100010] = {0};\n\tlong check[100010] = {0};\n\tlong i, j;\n\tlong pos;\n\tlong s;\n\t\n\tsl(N);\n\tif(N > 400) return -1;\n\t\n\tfor(i=0;i<N;i++) {\n\t\tsl(l[i]); sl(r[i]);\n\t\tif(l[i] > 400 || r[i] > 400) return -1;\n\t}\n\t\n\tfor(s=0;s<N;s++) {\n\t\tsum = 0;\n\t\tright = r[s];\n\t\tleft = l[s];\n\t\tfor(i=s+1;i<N;i++) {\n\t\t\tif(left > r[i]) {\n\t\t\t\tsum += (left - r[i]);\n\t\t\t\tright = left;\n\t\t\t\tleft = l[i] + (left - r[i]);\n\t\t\t}\n\t\t\tif(right < l[i]) {\n\t\t\t\tsum += (l[i] - right);\n\t\t\t\tleft = right;\n\t\t\t\tright = r[i] - (l[i] - right);\n\t\t\t}\n\t\t}\n\t\tright = r[s];\n\t\tleft = l[s];\n\t\tfor(i=s-1;i>=0;i--) {\n\t\t\tif(left > r[i]) {\n\t\t\t\tsum += (left - r[i]);\n\t\t\t\tright = left;\n\t\t\t\tleft = l[i] + (left - r[i]);\n\t\t\t}\n\t\t\tif(right < l[i]) {\n\t\t\t\tsum += (l[i] - right);\n\t\t\t\tleft = right;\n\t\t\t\tright = r[i] - (l[i] - right);\n\t\t\t}\n\t\t}\n\t\tans = MIN(ans, sum);\n\t}\n\t\n\tpl(ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n#include<math.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define ABS(a) ((a) > (0) ? (a) : -(a))\n\nvoid run (void) {\n\n}\n\n#define POS(i, j) (((i) & 1) * w + (j))\n\nvoid naive (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  const i32 w = 400;\n  if (n > w) exit (1);\n  i32 *dp = (i32 *) calloc (2 * w, sizeof (i32));\n  i32 pw = 0;\n  for (i32 i = 1; i <= n; ++i) {\n    i32 l, r;\n    scanf (\"%\" SCNi32 \"%\" SCNi32, &l, &r);\n    if (r > w) exit (1);\n    for (i32 j = 1; j < w; ++j) {\n      i32 local = w * n;\n      for (i32 k = MAX(1, j - pw); k <= MIN(w - 1, j + r - l); ++k) {\n\tlocal = MIN(local, dp[POS(i - 1, k)] + ABS(j - l));\n      }\n      dp[POS(i, j)] = local;\n    }\n    pw = r - l;\n  }\n  i32 ans = w * n;\n  for (i32 i = 1; i < w; ++i) {\n    ans = MIN(ans, dp[POS(n, i)]);\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  naive();\n  //run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong l[100000],r[100000];\n\nint main(int argc, char const *argv[]){\n\tlong n,i,pl=-1,pr=-1,ll,rr;\n\tlong long sum=0,x=0;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%ld %ld\",&l[i],&r[i]);\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tll=pl;\n\t\trr=pr;\n\t\tif(r[i]<=l[i+1]){\n\t\t\tpl=r[i];\n\t\t\tpr=l[i+1];\n\t\t}else if(l[i]>=r[i+1]){\n\t\t\tpl=r[i+1];\n\t\t\tpr=l[i];\n\t\t}else{\n\t\t\tpl=-1;\n\t\t\tpr=-1;\n\t\t}\n\t\tsum+=pr-pl;\n\t\tif(ll==-1){\n\t\t}else if(pl==-1){\n\t\t}else{\n\t\t\tif(pr<=ll || rr<=pl){\n\t\t\t}else{\n\t\t\t\tx+=rr-ll+pr-pl-(((pr>rr)?pr:rr)-((pl<ll)?pl:ll));\n\t\t\t\tif(pr-pl>rr-ll){\n\t\t\t\t\tif(pr==rr){\n\t\t\t\t\t\tpr=ll;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tpl=rr;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tpl=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",x);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare_int(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\n\nint main(int argc, char const *argv[])\n{\n\t\n\tint N;\n\n\tscanf(\"%d\",&N);\n\n\tint l[N];\n\tint r[N];\n\tlong long int sortr[N];\n\tint xcost[N];\n\tint j,k;\n\tunsigned int i;\n\n\tfor(i=0;i<N;i++){\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\tsortr[i]=r[i];\n\t}\n\n\tqsort(sortr,N,sizeof(long long int), compare_int);\n\n\tunsigned int xtotal[sortr[N-1]];\n\n\tfor(i=0;i<sortr[N-1];i++){\n\t\txtotal[i]=0;\n\t\tfor(j=0;j<N;j++){\n\t\t\tif(i<=l[j]){\n\t\t\t\txcost[j]=l[j]-i;\n\t\t\t}else if(r[j]<=i)\n\t\t\t\txcost[j]=i-r[j];\n\t\t\telse\n\t\t\t\txcost[j]=0;\n\t\txtotal[i]+=xcost[j];\n\t\t}\n\t}\n\n\tqsort(xtotal, sortr[N-1], sizeof(unsigned int), compare_int);\n\n\tprintf(\"%u\\n\",xtotal[0] );\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong l[100000],r[100000];\n\nint main(int argc, char const *argv[]){\n\tlong n,i,pl=-1,pr=-1,ll,rr;\n\tlong long sum=0,x=0;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%ld %ld\",&l[i],&r[i]);\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tll=pl;\n\t\trr=pr;\n\t\tif(r[i]<=l[i+1]){\n\t\t\tpl=r[i];\n\t\t\tpr=l[i+1];\n\t\t}else if(l[i]>=r[i+1]){\n\t\t\tpl=r[i+1];\n\t\t\tpr=l[i];\n\t\t}else{\n\t\t\tpl=-1;\n\t\t\tpr=-1;\n\t\t}\n\t\tsum+=pr-pl;\n\t\tif(ll==-1){\n\t\t}else if(pl==-1){\n\t\t}else{\n\t\t\tif(pr<=ll || rr<=pl){\n\t\t\t}else{\n\t\t\t\tx+=rr-ll+pr-pl-(((pr>rr)?pr:rr)-((pl<ll)?pl:ll));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",x);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong l[100000],r[100000];\n\nint main(int argc, char const *argv[]){\n\tlong n,i,pl=-1,pr=-1,ll,rr;\n\tlong long sum=0,x=0;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%ld %ld\",&l[i],&r[i]);\n\t\tsum+=r[i]-l[i];\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tll=pl;\n\t\trr=pr;\n\t\tif(r[i]<=l[i+1]){\n\t\t\tpl=r[i];\n\t\t\tpr=l[i+1];\n\t\t}else if(l[i]>=r[i+1]){\n\t\t\tpl=r[i+1];\n\t\t\tpr=l[i];\n\t\t}else{\n\t\t\tpl=-1;\n\t\t\tpr=-1;\n\t\t}\n\t\tif(ll==-1 || pl==-1){\n\t\t}else{\n\t\t\t\tx+=rr-ll+pr-pl-(((pr>rr)?pr:rr)-((pl<ll)?pl:ll));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum-x);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define inf (int)(1e9)\n\nint max(int a, int b){\n\tif(a > b){\n\t\treturn a;\n\t}\n\telse{\n\t\treturn b;\n\t}\n}\n\nint min(int a, int b){\n\tif(a < b){\n\t\treturn a;\n\t}\n\telse{\n\t\treturn b;\n\t}\n}\n\nint main(){\n\tint N, i, j, k, lmax = 0, dpmin;\n\tscanf(\"%d\", &N);\n\tint *l = (int *)malloc(sizeof(int) * N);\n\tint *r = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tlmax = max(l[i], lmax);\n\t\tl[i]--;\n\t\tr[i]--;\n\t}\n\tint **dp = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\tdp[i] = (int *)malloc(sizeof(int) * lmax);\n\t}\n\tfor(j = 0; j < lmax; j++){\n\t\tdp[0][j] = abs(j - l[0]);\n\t}\n\tfor(i = 1; i < N; i++){\n\t\tfor(j = 0; j < lmax; j++){\n\t\t\tdpmin = inf;\n\t\t\tfor(k = max(0, j - (r[i - 1] - l[i - 1])); k < min(lmax, j + r[i] - l[i] + 1); k++){\n\t\t\t\tdpmin = min(dp[i - 1][k], dpmin);\n\t\t\t}\n\t\t\tdp[i][j] = dpmin + abs(j - l[i]);\n\t\t}\n\t}\n\tdpmin = inf;\n\tfor(j = 0; j < lmax; j++){\n\t\tdpmin = min(dp[N - 1][j], dpmin);\n\t}\n\t/*printf(\"lmax = %d\\n\", lmax);\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"i = %d: \", i);\n\t\tfor(j = 0; j < lmax; j++){\n\t\t\tprintf(\"%d \", dp[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tprintf(\"%d\\n\", dpmin);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint srp,n,l[131072],r[131072],i;\n\tlong long res,minr=1145141919810364;\n\tscanf(\"%d\",&n);\n\tfor(i = 1;i <= n;i++){scanf(\"%d%d\",&l[i],&r[i]);}\n\tfor(srp = 0;srp <= 400;srp++){\n\t\tres = 0;\n\t\tfor(i = 1;i <= n;i++){\n\t\t\tif(l[i] <= srp && srp <= r[i]){continue;}\n\t\t\tif(srp < l[i]){res+=(l[i]-srp);}\n\t\t\tif(r[i] < srp){res+=(srp-r[i]);}\n\t\t}\n\t\tif(res < minr){minr = res;}\n\t}\n\tprintf(\"%lld\\n\",minr);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong l[100000],r[100000];\n\nint main(int argc, char const *argv[]){\n\tlong n,i,pl=-1,pr,ll,rr;\n\tlong long x=0;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%ld %ld\",&l[i],&r[i]);\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tll=pl;\n\t\trr=pr;\n\t\tif(r[i]<=l[i+1]){\n\t\t\tpl=r[i];\n\t\t\tpr=l[i+1];\n\t\t}else if(l[i]>=r[i+1]){\n\t\t\tpl=r[i+1];\n\t\t\tpr=l[i];\n\t\t}else{\n\t\t\tpl=-1;\n\t\t}\n\t\tif(ll==-1){\n\t\t\tx+=pr-pl;\n\t\t}else{\n\t\t\tif(pr<=ll || rr<=pl){\n\t\t\t\tx+=rr-ll+pr-pl;\n\t\t\t}else{\n\t\t\t\tx+=((pr>rr)?pr:rr)-((pl<ll)?pl:ll);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",x);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nlong l[100000],r[100000];\n\nint main(int argc, char const *argv[]){\n\tlong n,i,pl=-1,pr=-1,ll,rr;\n\tlong long x=0;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%ld %ld\",&l[i],&r[i]);\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tll=pl;\n\t\trr=pr;\n\t\tif(r[i]<=l[i+1]){\n\t\t\tpl=r[i];\n\t\t\tpr=l[i+1];\n\t\t}else if(l[i]>=r[i+1]){\n\t\t\tpl=r[i+1];\n\t\t\tpr=l[i];\n\t\t}else{\n\t\t\tpl=-1;\n\t\t\tpr=-1;\n\t\t}\n\t\tif(ll==-1){\n\t\t\tx+=pr-pl;\n\t\t}else if(pl==-1){\n\t\t\tx+=rr-ll;\n\t\t}else{\n\t\t\tif(pr<=ll || rr<=pl){\n\t\t\t\tx+=rr-ll+pr-pl;\n\t\t\t}else{\n\t\t\t\tx+=((pr>rr)?pr:rr)-((pl<ll)?pl:ll);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",x);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/B3\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 400;\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tint[] m = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = in.nextInt();\n\t\t\tr[i] = in.nextInt();\n\t\t\tm[i] = r[i] - l[i];\n\t\t}\n\t\tif (n > 400) return;\n\t\t\n\t\tint[] prev = new int[MAX+10];\n\t\tint[] next = new int[MAX+10];\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tprev[i] = Math.abs(l[0] - i);\n\t\t}\n\t\t\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tArrays.fill(next, Integer.MAX_VALUE);\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tfor (int k = 0; k < MAX; k++) {\n\t\t\t\t\tint l1 = j, r1 = j + m[i];\n\t\t\t\t\tint l2 = k, r2 = k + m[i-1];\n\t\t\t\t\tif ((l1 <= r2 && r2 <= r1) || (l2 <= r1 && r1 <= r2)) {\n\t\t\t\t\t\tnext[j] = Math.min(next[j], prev[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext[j] += Math.abs(l[i] - j);\n\t\t\t}\n\t\t\t// swap\n\t\t\tint[] tmp = prev; prev = next; next = tmp;\n\t\t}\n\t\t\n\t\tlong res = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tres = Math.min(res, prev[i]);\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO 自動生成された catch ブロック\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n\n    static class Pair{\n        long index;\n        int cnt;\n        Pair(long index,int cnt){this.index=index;this.cnt=cnt;}\n    }\n\n    static void add(TreeSet<Pair> indexes, long ind){\n        Pair p = new Pair(ind, 1);\n        if(indexes.ceiling(p)==null || indexes.ceiling(p).index != ind){\n            indexes.add(p);\n        }else{\n            indexes.ceiling(p).cnt++;\n        }\n    }\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Pair> lindex = new TreeSet<>((a,b)->a.index-b.index<0 ? -1:a.index==b.index ? 0: 1);\n        TreeSet<Pair> rindex = new TreeSet<>((a,b)->b.index-a.index<0 ? -1:a.index==b.index ? 0: 1);\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(new Pair(l[0],1));rindex.add(new Pair(l[0],1));\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.last().index >= (l[i]+lbase)){\n                add(lindex, l[i]+lbase);\n                lindex.last().cnt--;\n                ans += Math.abs(lindex.last().index-(l[i]+lbase));\n                if(lindex.last().cnt==0){\n                    System.out.println(\"pop\");\n                    add(rindex, lindex.last().index-lbase-rbase);\n                    lindex.pollLast();\n                }\n            }else if(rindex.last().index <= (l[i]-rbase)){\n                add(rindex, l[i]-rbase);\n                rindex.last().cnt--;\n                ans += Math.abs(rindex.last().index-(l[i]-rbase));\n                if(rindex.last().cnt==0){\n                    System.out.println(\"pop\");\n                    add(lindex, rindex.last().index+lbase+rbase);\n                    rindex.pollLast();\n                }\n            }else{\n                add(lindex, l[i]+lbase);\n                add(rindex, l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int N = 410;\n\t\t\tfinal long infinity = (long) 1e18;\n\t\t\tint n = in.nextInt();\n\t\t\tint[] l = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tl[i] = in.nextInt();\n\t\t\t\tr[i] = in.nextInt();\n\t\t\t}\n\t\t\tlong[] d = new long[N];\n\t\t\tlong[] nd = new long[N];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(nd, infinity);\n\t\t\t\tint len2 = r[i] - l[i];\n\t\t\t\tfor (int x1 = 0; x1 < N; x1++) {\n\t\t\t\t\tif (d[x1] >= infinity) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint len1 = N;\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tlen1 = r[i - 1] - l[i - 1];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x2 = 0; x2 < N; x2++) {\n\t\t\t\t\t\tint L = Math.max(x1, x2);\n\t\t\t\t\t\tint R = Math.min(x1 + len1, x2 + len2);\n\t\t\t\t\t\tif (L > R) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnd[x2] = Math.min(nd[x2], d[x1] + Math.abs(x2 - l[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong[] t = d;\n\t\t\t\td = nd;\n\t\t\t\tnd = t;\n\t\t\t}\n\t\t\tlong ans = infinity;\n\t\t\tfor (long x : d) {\n\t\t\t\tans = Math.min(ans, x);\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n\n    static class Pair{\n        long index;\n        int cnt;\n        Pair(long index,int cnt){this.index=index;this.cnt=cnt;}\n    }\n\n    static void add(TreeSet<Pair> indexes, long ind){\n        Pair p = new Pair(ind, 1);\n        if(indexes.ceiling(p)==null || indexes.ceiling(p).index != ind){\n            indexes.add(p);\n        }else{\n            indexes.ceiling(p).cnt++;\n        }\n    }\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Pair> lindex = new TreeSet<>((a,b)->a.index-b.index<0 ? -1:a.index==b.index ? 0: 1);\n        TreeSet<Pair> rindex = new TreeSet<>((a,b)->b.index-a.index<0 ? -1:a.index==b.index ? 0: 1);\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(new Pair(l[0],1));rindex.add(new Pair(l[0],1));\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.last().index >= (l[i]+lbase)){\n                add(lindex, l[i]+lbase);\n                lindex.last().cnt--;\n                ans += Math.abs(lindex.last().index-(l[i]+lbase));\n                if(lindex.last().cnt==0){\n                    add(rindex, lindex.last().index-lbase-rbase);\n                    lindex.pollLast();\n                }\n            }else if(rindex.last().index <= (l[i]-rbase)){\n                add(rindex, l[i]-rbase);\n                rindex.last().cnt--;\n                ans += Math.abs(rindex.last().index-(l[i]-rbase));\n                if(rindex.last().cnt==0){\n                    add(lindex, rindex.last().index+lbase+rbase);\n                    rindex.pollLast();\n                }\n            }else{\n                add(lindex, l[i]+lbase);\n                add(rindex, l[i]+rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.IntPredicate;\n \npublic class Main{\n\tint N;\n\tint[] L;\n\tint[] R;\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\tL = new int[N];\n\t\tR = new int[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tL[i] = nextInt();\n\t\t\tR[i] = nextInt();\n\t\t}\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 1; i <= 400; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(L[j] <= i && i <= R[j]) continue;\n\t\t\t\tif(i < L[j]) sum += L[j] - i;\n\t\t\t\telse sum += i - R[j];\n\t\t\t}\n\t\t\tans = Math.min(sum, ans);\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tint sum(int[] bit, int i) {\n\t\ti++;\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int[] bit, int i, int x){\n\t\ti++;\n\t\twhile(i <= (1<<13)){\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\t\n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long[][] lr = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            lr[i][0] = in.nextInt();\n            lr[i][1] = in.nextInt();\n        }\n\n        Hoge hoge = new Hoge(lr[0][0]);\n        for (int i = 1 ; i < n ; i++) {\n            hoge.left.addAll(-lr[i][1]+lr[i][0]);\n            hoge.right.addAll(lr[i-1][1]-lr[i-1][0]);\n\n            long L = hoge.getLeftMost();\n            long R = hoge.getRightMost();\n            if (L > R) {\n                throw new RuntimeException(\"L <= R must be hold\");\n            }\n\n            if (L < lr[i][0] && lr[i][0] < R) {\n                hoge.left.addPoint(lr[i][0]);\n                hoge.right.addPoint(lr[i][0]);\n            } else if (lr[i][0] <= L) {\n                hoge.left.addPoint(lr[i][0]);\n                hoge.right.addPoint(hoge.left.removePoint(L));\n                hoge.minValue += Math.abs(L - hoge.getLeftMost());\n            } else {\n                hoge.right.addPoint(lr[i][0]);\n                hoge.left.addPoint(hoge.right.removePoint(R));\n                hoge.minValue += Math.abs(R - hoge.getRightMost());\n            }\n        }\n\n        out.println(hoge.minValue);\n        out.flush();\n    }\n\n\n    static class Hoge {\n        Lines left = new Lines();\n        Lines right = new Lines();\n        long minValue = 0;\n\n        public Hoge(long x0) {\n            left.addPoint(x0);\n            right.addPoint(x0);\n        }\n\n        public long getLeftMost() {\n            return left.positions.lastKey() + left.addAll;\n        }\n\n        public long getRightMost() {\n            return right.positions.firstKey() + right.addAll;\n        }\n\n    }\n\n    static class Lines {\n        public TreeMap<Long, Integer> positions = new TreeMap<>();\n        public long addAll = 0;\n\n        public void addPoint(long x) {\n            long ax = x - addAll;\n            positions.put(ax, positions.getOrDefault(ax, 0)+1);\n        }\n\n        public long removePoint(long x) {\n            long ax = x - addAll;\n            if (!positions.containsKey(ax)) {\n                throw new RuntimeException(\"key not exists\");\n            }\n            if (positions.get(ax) == 1) {\n                positions.remove(ax);\n            } else {\n                positions.put(ax, positions.get(ax)-1);\n            }\n            return x;\n        }\n\n        public void addAll(long d) {\n            addAll += d;\n        }\n\n\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n\n            if(lindex.ceiling(l[i]+lbase+1) != null){\n                lindex.add(l[i]+lbase);\n                long top = lindex.pollLast();\n                ans += Math.abs(top-(l[i]+lbase));\n                rindex.add(top-lbase - rbase);\n            }else if(rindex.floor(l[i]-rbase-1) != null){\n                rindex.add(l[i]-rbase);\n                long bot = rindex.pollFirst();\n\n                ans += Math.abs(bot-(l[i]-rbase));\n                lindex.add(bot+rbase+lbase);\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tvoid solve() throws IOException {\n\t\tsolve(ni());\n\t}\n\n\tprivate void solve(int n) throws IOException {\n\t\tint[][] a = new int[n][];\n\t\tint[] b = new int[2 * n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nia(2);\n\t\t\tb[2 * i] = a[i][0];\n\t\t\tb[2 * i + 1] = a[i][1];\n\t\t}\n\t\tArrays.sort(b);\n\t\tint m = b[n];\n\t\tlong ans = 0;\n\t\tfor (int[] seg : a) {\n\t\t\tif (m >= seg[0] && m <= seg[1])\n\t\t\t\tcontinue;\n\t\t\tif (seg[0] > m)\n\t\t\t\tans += seg[0] - m;\n\t\t\telse if (seg[1] < m)\n\t\t\t\tans += -seg[1] + m;\n\t\t}\n//\t\tHelper.tr(m, ans);\n\t\tout.println(ans);\n\n\t}\n\n\tString ns() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint ni() throws IOException {\n\t\treturn Integer.parseInt(ns());\n\t}\n\n\tlong nl() throws IOException {\n\t\treturn Long.parseLong(ns());\n\t}\n\n\tdouble nd() throws IOException {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tString[] nsa(int n) throws IOException {\n\t\tString[] res = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = ns();\n\t\t}\n\t\treturn res;\n\t}\n\n\tint[] nia(int n) throws IOException {\n\t\tint[] res = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = ni();\n\t\t}\n\t\treturn res;\n\t}\n\n\tlong[] nla(int n) throws IOException {\n\t\tlong[] res = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = nl();\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\ttok = new StringTokenizer(\"\");\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t\tout.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tlong[] l = new long[N];\n\t\tlong[] r = new long[N];\n\t\tlong[] len = new long[N];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tl[i] = sc.nextLong() - 1;\n\t\t\tr[i] = sc.nextLong() - 1;\n\t\t\tlen[i] = r[i] - l[i];\n\t\t}\n\n\t\tPriorityQueue<Long> pqL = new PriorityQueue<>(new Comparator<Long>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn -Long.compare(o1, o2);\n\t\t\t}\n\t\t});\n\t\tPriorityQueue<Long> pqR = new PriorityQueue<>();\n\n\t\tlong slideR = 0, slideL = 0;\n\t\tpqL.add(l[0]);\n\t\tpqR.add(l[0]);\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tslideL -= len[i];\n\t\t\tslideR += len[i - 1];\n\t\t\tlong L = pqL.peek() + slideL;\n\t\t\tlong R = pqR.peek() + slideR;\n\t\t\tif (L <= l[i] && l[i] <= R) {\n\t\t\t\tpqL.add(l[i] - slideL);\n\t\t\t\tpqR.add(l[i] - slideR);\n\t\t\t} else {\n\t\t\t\tif (l[i] < L) {\n\t\t\t\t\tpqL.poll();\n\t\t\t\t\tpqL.add(l[i] - slideL);\n\t\t\t\t\tpqL.add(l[i] - slideL);\n\t\t\t\t\tpqR.add(L - slideR);\n\t\t\t\t\tL = pqL.peek() + slideL;\n\t\t\t\t\tR = pqR.peek() + slideR;\n\t\t\t\t\tans += (R - l[i]);\n\t\t\t\t} else {\n\t\t\t\t\tpqR.poll();\n\t\t\t\t\tpqR.add(l[i] - slideR);\n\t\t\t\t\tpqR.add(l[i] - slideR);\n\t\t\t\t\tpqL.add(R - slideL);\n\t\t\t\t\tL = pqL.peek() + slideL;\n\t\t\t\t\tR = pqR.peek() + slideR;\n\t\t\t\t\tans += (l[i] - L);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n\n    static void add(Map<Long, Integer> cnt, long index){\n        if(!cnt.containsKey(index))cnt.put(index, 0);\n        cnt.put(index, cnt.get(index)+1);\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        Map<Long,Integer> lcnt = new HashMap<>();\n        Map<Long, Integer> rcnt=new HashMap<>();\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        add(lcnt, l[0]);add(rcnt, l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.ceiling(l[i]+lbase) != null){\n                lindex.add(l[i]+lbase);\n                add(lcnt, l[i]+lbase);\n                long top = lindex.last();\n                ans += Math.abs(top-(l[i]+lbase));\n                lcnt.put(top, lcnt.get(top)-1);\n                if(lcnt.get(top)==0){\n                    lindex.pollLast();\n                    rindex.add(top-lbase - rbase);\n                    add(rcnt, top-lbase-rbase);\n                }\n            }else if(rindex.floor(l[i]-rbase) != null){\n                rindex.add(l[i]-rbase);\n                add(rcnt, l[i]-rbase);\n                long bot = rindex.first();\n                ans += Math.abs(bot-(l[i]-rbase));\n                rcnt.put(bot, rcnt.get(bot)-1);\n                if(rcnt.get(bot)==0){\n                    rindex.pollFirst();\n                    lindex.add(bot+rbase+lbase);\n                    add(lcnt, bot+rbase+lbase);\n                }\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n                add(lcnt, l[i]+lbase);\n                add(rcnt, l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] co = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new int[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tlong ret = 0;\n\t\tSimpleMinHeapL upper = new SimpleMinHeapL(n+1);\n\t\tSimpleMinHeapL lower = new SimpleMinHeapL(n+1);\n\t\tlong uoffset = 0;\n\t\tlong loffset = 0;\n\t\tupper.add(co[0][0]);\n\t\tlower.add(-co[0][0]);\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tloffset -= co[i][1]-co[i][0];\n\t\t\tuoffset += co[i-1][1]-co[i-1][0];\n\t\t\tlong L = -lower.min() + loffset;\n\t\t\tlong R = upper.min() + uoffset;\n\t\t\tif(co[i][0] < L){\n\t\t\t\tret += L - co[i][0];\n\t\t\t}\n\t\t\tif(co[i][0] > R){\n\t\t\t\tret += co[i][0] - R;\n\t\t\t}\n\t\t\tif(co[i][0] <= L){\n\t\t\t\tlower.add(-(co[i][0]-loffset));\n\t\t\t\tlower.add(-(co[i][0]-loffset));\n\t\t\t\twhile(upper.size() != lower.size()){\n\t\t\t\t\tlong v = -lower.poll() + loffset;\n\t\t\t\t\tupper.add(v-uoffset);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tupper.add(co[i][0]-uoffset);\n\t\t\t\tupper.add(co[i][0]-uoffset);\n\t\t\t\twhile(upper.size() != lower.size()){\n\t\t\t\t\tlong v = upper.poll() + uoffset;\n\t\t\t\t\tlower.add(-(v-loffset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static class SimpleMinHeapL {\n\t\tpublic long[] a;\n\t\tpublic int n;\n\t\tpublic int pos;\n\t\tpublic static final long INF = Long.MAX_VALUE;\n\t\t\n\t\tpublic SimpleMinHeapL(int m)\n\t\t{\n\t\t\tn = m+1;\n\t\t\ta = new long[n];\n\t\t\tArrays.fill(a, INF);\n\t\t\tpos = 1;\n\t\t}\n\t\t\n\t\tpublic SimpleMinHeapL(long[] in)\n\t\t{\n\t\t\tn = in.length+1;\n\t\t\tif((n&1)==1)n++;\n\t\t\ta = new long[n];\n\t\t\tpos = 1+in.length;\n//\t\t\tArrays.fill(a, INF);\n\t\t\ta[0] = a[n-1] = a[n-2] = INF;\n\t\t\tSystem.arraycopy(in, 0, a, 1, in.length);\n\t\t\tfor(int t = pos/2-1;t >= 1;t--){\n\t\t\t\tfor(int c = t;2*c < pos;){\n\t\t\t\t\tint smaller = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;\n\t\t\t\t\tif(a[smaller] < a[c]){\n\t\t\t\t\t\tlong d = a[c]; a[c] = a[smaller]; a[smaller] = d;\n\t\t\t\t\t\tc = smaller;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void add(long x)\n\t\t{\n\t\t\ta[pos++] = x;\n\t\t\tfor(int c = pos-1, p = c>>>1;p >= 1 && a[c] < a[p];c>>>=1, p>>>=1){\n\t\t\t\tlong d = a[p]; a[p] = a[c]; a[c] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long poll()\n\t\t{\n\t\t\tif(pos == 1)return INF;\n\t\t\tpos--;\n\t\t\tlong ret = a[1];\n\t\t\ta[1] = a[pos];\n\t\t\ta[pos] = INF;\n\t\t\tfor(int c = 1;2*c < pos;){\n\t\t\t\tint smaller = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;\n\t\t\t\tif(a[smaller] < a[c]){\n\t\t\t\t\tlong d = a[c]; a[c] = a[smaller]; a[smaller] = d;\n\t\t\t\t\tc = smaller;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long min() { return a[1]; }\n\t\tpublic int size() { return pos-1; }\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int[][] p = ntable(n, 2);\n    \n    int[][] dp = new int[n][401];\n    for (int[] v : dp) Arrays.fill(v, Integer.MAX_VALUE / 2);\n\n    for (int x = 1; x <= 400; x ++) {\n      dp[0][x] = Math.abs(p[0][1] - x);\n    }\n    for (int i = 1; i < n; i ++) {\n      for (int x1 = 1; x1 <= 400; x1 ++) {\n        for (int x2 = 1; x2 <= 400; x2 ++) {\n          if (x2 - x1 <= p[i][1] - p[i][0] && x1 - x2 <= p[i - 1][1] - p[i - 1][0]) {\n            dp[i][x2] = Math.min(dp[i][x2], Math.abs(p[i][1] - x2) + dp[i - 1][x1]);\n          }\n        }\n      }\n    }\n    int ret = Integer.MAX_VALUE;\n    for (int x = 1; x <= 400; x ++) {\n      ret = Math.min(ret, dp[n - 1][x]);\n    }\n    System.out.println(ret);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/B3\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 10;\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tint[] m = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = in.nextInt();\n\t\t\tr[i] = in.nextInt();\n\t\t\tm[i] = r[i] - l[i];\n\t\t}\n\t\tif (n > 400) return;\n\t\t\n\t\tint[] prev = new int[MAX+10];\n\t\tint[] next = new int[MAX+10];\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tprev[i] = Math.abs(l[0] - i);\n\t\t}\n\t\t\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tArrays.fill(next, Integer.MAX_VALUE);\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tfor (int k = 0; k < MAX; k++) {\n\t\t\t\t\tint l1 = j, r1 = j + m[i];\n\t\t\t\t\tint l2 = k, r2 = k + m[i-1];\n\t\t\t\t\tif ((l1 <= r2 && r2 <= r1) || (l2 <= r1 && r1 <= r2)) {\n\t\t\t\t\t\tnext[j] = Math.min(next[j], prev[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext[j] += Math.abs(l[i] - j);\n\t\t\t}\n\t\t\t// swap\n\t\t\tint[] tmp = prev; prev = next; next = tmp;\n\t\t}\n\t\t\n\t\tlong res = Long.MAX_VALUE;\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tres = Math.min(res, prev[i]);\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO 自動生成された catch ブロック\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * @author Ivan Pryvalov (ivan.pryvalov@gmail.com)\n */\npublic class Main implements Runnable {\n    static EventType eventType = EventType.DEFAULT; //EventType.GOOGLE_CODE_JAM;\n    static int T = 1; // T \\in {0,1}. If T=0, it will be read from the input.\n    static String inputFilename = null; // if 'null', it reads data from std-in.\n\n    static boolean largeFakeTest = false; // Check if you generate data on fly\n    static int largeFakeTest_T = 1;\n\n    //--------------------------------------------------------------------\n\n    public static class Solver extends  SolverAbstract{\n\n        int MAX_SMALL = 400;\n        boolean big = false;\n\n        int N;\n        int[] L;\n        int[] R;\n        int max_R;\n\n        @Override\n        public void readInput() throws IOException {\n            big = false;\n            max_R = 0;\n            N = scanner.nextInt();\n            if (N > MAX_SMALL ){\n                big = true;\n            }\n            L = new int[N];\n            R = new int[N];\n            for (int i = 0; i < N; i++) {\n                L[i] = scanner.nextInt();\n                R[i] = scanner.nextInt();\n                max_R = Math.max(max_R, R[i]);\n                if (L[i] > MAX_SMALL || R[i] > MAX_SMALL){\n                    big = true;\n                }\n            }\n        }\n\n        @Override\n        protected void solve() throws IOException {\n            if (big){\n                out.println(0);\n                return;\n            }\n            int total_cost = Integer.MAX_VALUE / 3;\n            for (int mid = 1; mid <= max_R; mid++) {\n                int cost = 0;\n                for (int i = 0; i < N; i++) {\n                    if (L[i] > mid){\n                        cost += L[i] - mid;\n                    }else if (R[i] < mid){\n                        cost += mid - R[i];\n                    }\n                }\n                total_cost = Math.min(total_cost, cost);\n            }\n            out.println(total_cost);\n        }\n    }\n\n    //--------------------------------------------------------------------\n\n    private void solveAll() throws IOException {\n        long timeStart = System.currentTimeMillis();\n        if (T==0) {\n            if (largeFakeTest) {\n                T = largeFakeTest_T;\n            } else {\n                T = scanner.nextInt();\n            }\n        }\n        final String[] results = new String[T+1];\n        for (int test = 0; test < T; test++) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream outLocal = new PrintStream(baos);\n            Solver solver = new Solver(){\n                @Override\n                public void callback() {\n                    results[testNo] = answer;\n                }\n            };\n            solver.out = outLocal;\n            solver.testNo = test+1;\n            if (largeFakeTest) {\n                solver.readFakeInput();\n            }else{\n                solver.readInput();\n            }\n            solver.solveWrapped(baos);\n        }\n\n        long timeEnd = System.currentTimeMillis();\n        if (isInputFromFile())\n            System.out.println(\"All tasks are solved! Elapsed time \"+(timeEnd-timeStart)/1000.0+\" sec.\");\n\n        // write all responses in the proper order\n        for (int i = 1; i <= T; i++) {\n            if (eventType == EventType.GOOGLE_CODE_JAM){\n                outGlobal.printf(\"Case #%d: %s\", i, results[i]);\n            }else {\n                outGlobal.print(results[i]);\n            }\n        }\n    }\n\n    enum EventType{\n        DEFAULT,\n        GOOGLE_CODE_JAM\n    }\n\n    static boolean isInputFromFile() {\n        return inputFilename != null;\n    }\n\n    public static abstract class SolverAbstract {\n        PrintStream out;\n        int testNo;\n        String answer = null;\n\n        public void callback(){};\n\n        public abstract void readInput() throws IOException;\n\n        //generate a randomized test with the maximal input values\n        public void readFakeInput() throws  IOException{\n            throw new RuntimeException(\"not implemented\");\n        }\n\n        protected abstract void solve() throws IOException;\n\n        protected void solveWrapped(ByteArrayOutputStream baos) throws IOException {\n            if (isInputFromFile())\n                System.out.println(\"SOLVER: solving task #\"+testNo+\" out of \"+ T+\"...\");\n            solve();\n            answer = baos.toString();\n            if (isInputFromFile()) {\n                System.out.println(\"\\t\"+answer);\n            }\n            callback();\n        }\n    }\n\n    ////////////////////////////////////////////////////////\n    // Link about multithreading: http://stackoverflow.com/questions/4521983/java-executorservice-that-blocks-on-submission-after-a-certain-queue-size\n\n\n    // ------------- Some stardard tools that are currently not tested.\n    //adopt for the lists of adjacent vertices\n    static class Graph{\n\n        int[][] G;\n        int N;\n\n        int[][] A;\n        int[][] F;\n\n        int[] path;\n        int pathLen;\n        boolean[] visited;\n        int target;\n        boolean flowFound;\n\n        public Graph(int[][] g) {\n            G = g;\n            N = G.length;\n        }\n\n        public int[][] maxflow(int iSource, int iSink) {\n            path = new int[N];\n            visited = new boolean[N];\n\n            A = new int[N][];\n            for (int i = 0; i < N; i++) {\n                A[i] = G[i].clone();\n            }\n            F = new int[N][N];\n\n            target = iSink;\n            //dfs from source to sink\n            //increase path\n            while(true){\n                flowFound = false;\n                visited[iSource] = true;\n                pathLen = 0;\n                path[pathLen++] = iSource;\n                dfs(iSource);\n                if (!flowFound)\n                    break;\n            }\n            return F;\n        }\n\n        private void dfs(int u) {\n            if (u==target){\n                flowFound = true;\n                for (int i = 0; i < pathLen-1; i++) {\n                    int from = path[i];\n                    int to  = path[i+1];\n                    F[from][to]++;\n                    F[to][from]--;\n                }\n            }else {\n                for (int i = 0; i < N && !flowFound; i++) {\n                    if (!visited[i] && A[u][i] > F[u][i]) {\n                        visited[i] = true;\n                        path[pathLen] = i;\n                        pathLen++;\n                        dfs(i);\n                        visited[i] = false;\n                        pathLen--;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class Utilities{\n        public static List<Integer> getPrimes(int limit) {\n            boolean[] primes = new boolean[limit+1];\n            Arrays.fill(primes, true);\n\n            primes[1] = false;\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    for(int j=i+i; j<=limit; j+=i){\n                        primes[j] = false;\n                    }\n                }\n            }\n            List<Integer> listPrimes = new ArrayList<>();\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    listPrimes.add(i);\n                }\n            }\n            return listPrimes;\n        }\n    }\n\n    public static class Modulo{\n        long mod = (long)1e9+7;\n\n        public Modulo(long mod) {\n            super();\n            this.mod = mod;\n        }\n\n        public long inv(long a) {\n            long res =  pow(a, mod-2);\n            return res;\n        }\n\n        public long pow(long a, long x) {\n            if (x==0)\n                return 1;\n            long part = 1;\n            if ((x&1)!=0)\n                part = a;\n            return (part * pow((a*a)%mod, x>>1)) % mod;\n        }\n\n        public long c(long n, long m){\n            long res = 1;\n            for(int i=1; i<=m; i++){\n                res = (res * (n-m+i)) % mod;\n                res = (res * inv(i)) % mod;\n            }\n            return res;\n        }\n    }\n\n    /**\n     * Added 26.04.2013.\n     * See KROK 2013, Round 1, Problem D.\n     */\n    static class DisjointUnionSet implements Cloneable{\n        int[] rank;\n        int[] parent;\n\n        protected DisjointUnionSet clone(){\n            DisjointUnionSet cloned = new DisjointUnionSet(parent.length);\n            for(int i=0; i<parent.length; i++){\n                cloned.parent[i] = parent[i];\n                cloned.rank[i] = rank[i];\n            }\n            return cloned;\n        }\n\n        public DisjointUnionSet(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"disj [parents=\" + Arrays.toString(parent) + \"]\";\n        }\n\n        /**\n         * Problem specific or general?\n         * O(N * alpha)\n         */\n        public void union(DisjointUnionSet set2){\n            for(int i=0; i<parent.length; i++){\n                parent[find(i)] = parent[find(set2.find(i))];\n            }\n        }\n\n        /**\n         * @param index1 range 0..n-1\n         * @param index2\n         */\n        public void union(int index1, int index2){\n            int p1 = find(index1);\n            int p2 = find(index2);\n            if (rank[p1] > rank[p2]){\n                parent[p2] = p1;\n            }else if (rank[p2] > rank[p1]){\n                parent[p1] = p2;\n            }else{\n                parent[p2] = p1;\n                rank[p1]++;\n            }\n        }\n\n        // O(alpha(n))\n        private int find(int index) {\n            if (parent[index] != index)\n                parent[index] =  find(parent[index]);\n            return parent[index];\n        }\n\n        // O(N alpha(N)) ==> see find()\n        public int getCountDisjointSets(){\n            int[] used = new int[parent.length];\n            for(int i=0; i<parent.length; i++){\n                used[find(i)] = 1;\n            }\n            int res = 0;\n            for(int i=0; i<parent.length; i++){\n                res += used[i];\n            }\n            return res;\n        }\n    }\n\n    private static Random rnd = new Random();\n    public static class ArrayUtils{\n        public static void shuffle(int[] a){\n            for(int j=a.length-1; j>=1; j--){\n                int i = rnd.nextInt(j+1);\n                swap(a, i, j);\n            }\n        }\n\n        public static void swap(int[] a, int i, int j){\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n    }\n\n    static class GraphSupport{\n        /*\n        //Added 20.02.2017.\n        //See Codeforces Round 398, Div.2, C.\n        // Recoursive call to dfs function may result in either MTL or StackOverflow.\n        // Codeforces provide stacksize 64M\n\n        private void dfs_no_recursion(int root, IntConsumer dfs_post){\n            int[] stack = new int[N];\n            int[] stackInt = new int[N];\n            int iStack = 0;\n            stack[iStack] = root;\n            stackInt[iStack++] = 0;\n            while(true){\n                Node node = nodes[stack[iStack-1]];\n                int childIdx = stackInt[iStack-1];\n                if (childIdx < node.children.size()){\n                    stack[iStack] = node.children.get(childIdx).idx;\n                    stackInt[iStack++] = 0;\n                }else{\n                    dfs_post.accept(node.idx);\n\n                    iStack--;\n                    if (iStack==0){\n                        break;\n                    }\n                    stackInt[iStack-1]++;\n                }\n            }\n        }\n        */\n    }\n\n\n    ////////////////////////////////////////////////////////\n    /// Typically, you don't want to edit anything below\n    ///////////////////////////////////////////////////////\n    final int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n    final int INPUT_BUFFER_SIZE = 1024 * 1024 * 8;\n    final int BUF_SIZE_INPUT = 1024;\n\n    boolean useClassResourceTopDir = true;\n    String outSuffix = \".out\";\n\n    static PrintStream outGlobal;\n    static ByteScanner scanner;\n\n    public void run() {\n        try{\n            InputStream bis;\n            OutputStream bos;\n            if (inputFilename !=null){\n                File inputFile;\n                File outputFile;\n                if (useClassResourceTopDir) {\n                    File baseFile = new File(getClass().getResource(\"/\").getFile());\n                    inputFile = new File(baseFile, inputFilename);\n                    outputFile = new File(baseFile, inputFilename +outSuffix);\n                }else{\n                    inputFile = new File(inputFilename);\n                    outputFile = new File(inputFilename +outSuffix);\n                }\n                System.out.println(\"Input file canonical path: \"+inputFile.getCanonicalPath());\n                bis = new BufferedInputStream(\n                        new FileInputStream(inputFile),\n                        INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(new FileOutputStream(outputFile));\n                outGlobal = new PrintStream(bos);\n            }else{\n                bis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(System.out);\n                outGlobal = new PrintStream(bos);\n            }\n            scanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\n            solveAll();\n            outGlobal.flush();\n        }catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static class EofException extends IOException{\n    }\n\n    public static class ByteScanner{\n        InputStream is;\n\n        public ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n            this.is = is;\n            this.bufSizeInput = bufSizeInput;\n            this.bufSize = bufSize;\n\n            byteBufInput = new byte[this.bufSizeInput];\n            byteBuf = new byte[this.bufSize];\n        }\n\n        public ByteScanner(byte[] data){\n            byteBufInput = data;\n            bufSizeInput = data.length;\n            bufSize = data.length;\n            byteBuf = new byte[bufSize];\n            byteRead = data.length;\n            bytePos = 0;\n        }\n\n        private int bufSizeInput;\n        private int bufSize;\n\n        byte[] byteBufInput;\n        byte by=-1;\n        int byteRead=-1;\n        int bytePos=-1;\n\n        byte[] byteBuf;\n        int totalBytes;\n\n        boolean eofMet = false;\n\n        private byte nextByte() throws IOException{\n            if (bytePos<0 || bytePos>=byteRead){\n                byteRead = is==null? -1: is.read(byteBufInput);\n                bytePos=0;\n                if (byteRead<0){\n                    byteBufInput[bytePos]=-1;//!!!\n                    if (eofMet)\n                        throw new EofException();\n                    eofMet = true;\n                }\n            }\n            return byteBufInput[bytePos++];\n        }\n\n        public byte nextVisibleChar() throws IOException{\n            while ((by=nextByte())<=0x20);\n            return by;\n        }\n\n        public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Reads token. Spacebar is separator char.\n        public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Spacebar is included as separator char\n        private void readToken() throws IOException {\n            readToken((byte)0x21);\n        }\n\n        private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n        }\n\n        public int nextInt() throws IOException{\n            readToken();\n            int num=0, i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public long nextLong() throws IOException{\n            readToken();\n            long num=0;\n            int i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public double nextDouble() throws IOException{\n            readToken();\n            char[] token = new char[totalBytes];\n            for (int i = 0; i < totalBytes; i++) {\n                token[i] = (char)byteBuf[i];\n            }\n            return Double.parseDouble(new String(token));\n        }\n\n        public int[] loadIntArray(int size) throws IOException{\n            int[] a = new int[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] loadLongArray(int size) throws IOException{\n            long[] a = new long[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = sc.nextInt();\n\t\t\tr[i] = sc.nextInt();\n\t\t}\n\n\t\tif (n > 400) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\n\t\tint[][] dp = new int[n][400 + 1];\n\t\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tif (i >= l[0] && i <= r[0]) {\n\t\t\t\tdp[0][i] = 0;\n\t\t\t} else if (i < l[0]) {\n\t\t\t\tdp[0][i] = l[0] - i;\n\t\t\t} else {\n\t\t\t\tdp[0][i] = i - r[0];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t\tfor (int j = 1; j < l[i]; j++) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k <= Math.min(j + r[i] - l[i], 400); k++) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], l[i] - j + prev);\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = r[i] + 1; j <= 400; j++) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k >= Math.max(j - (r[i] - l[i]), 0); k--) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], j - r[i] + prev);\n\t\t\t\tif (j < 400) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint prev = INF;\n\t\t\tfor (int k = l[i]; k <= r[i]; k++) {\n\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t}\n\t\t\tfor (int j = l[i]; j <= r[i]; j++) {\n\t\t\t\tif (l[i] > 1) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][l[i] - 1]);\n\t\t\t\t}\n\t\t\t\tif (r[i] < 400) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][r[i] + 1]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], prev);\n\t\t\t}\n\t\t}\n\n\t\tint ret = INF;\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tret = Math.min(ret, dp[n - 1][i]);\n\t\t}\n\n\t\tpr.println(ret);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main{\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        PriorityQueue<Long> lindex = new PriorityQueue<>(Collections.reverseOrder());\n        PriorityQueue<Long> rindex = new PriorityQueue<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.peek() >= (l[i]+lbase)){\n                lindex.add(l[i]+lbase);\n                lindex.add(l[i]+lbase);\n                ans += Math.abs(lindex.peek()-(l[i]+lbase));\n                rindex.add(lindex.poll()-lbase-rbase);\n            }else if(rindex.peek() <= (l[i]-rbase)){\n                rindex.add(l[i]-rbase);\n                rindex.add(l[i]-rbase);\n                ans += Math.abs(rindex.peek()-(l[i]-rbase));\n                lindex.add(rindex.poll()+lbase+rbase);\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tlong answer = Long.MAX_VALUE;\n\t\tfor(int same_l = 0; same_l <= 400; same_l++){\n\t\t\tLOOP:\n\t\t\tfor(int same_r = same_l; same_r <= 400; same_r++){\n\t\t\t\tfinal long same_size = same_r - same_l;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlong curr_answer = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfinal long block_l = ls[i];\n\t\t\t\t\tfinal long block_r = rs[i];\n\t\t\t\t\tfinal long block_size = block_r - block_l;\n\t\t\t\t\t\n\t\t\t\t\tif(block_size < same_size){ continue LOOP; }\n\t\t\t\t\t\n\t\t\t\t\tif(block_l <= same_l && same_r <= block_r){ continue; }\n\t\t\t\t\tif(block_l > same_l){\n\t\t\t\t\t\tcurr_answer += (block_l - same_l);\n\t\t\t\t\t}else if(block_r < same_r){\n\t\t\t\t\t\tcurr_answer += (same_r - block_r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(same_l + \" \" + same_r + \" \" + curr_answer);\n\t\t\t\tanswer = Math.min(answer, curr_answer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] co = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new int[]{ni(), ni()};\n\t\t}\n\t\tlong[][] dp = new long[n][401];\n\t\tfor(int i= 0;i < n;i++)Arrays.fill(dp[i], Long.MAX_VALUE / 10);\n\t\tfor(int i = 0;i <= 400;i++){\n\t\t\tdp[0][i] = Math.abs(i-co[0][0]);\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tfor(int j = 0;j <= 400;j++){\n\t\t\t\tfor(int k = 0;k <= 400;k++){ // j->k\n\t\t\t\t\tint l = Math.max(j, k);\n\t\t\t\t\tint r = Math.min(j+co[i-1][1]-co[i-1][0], k+co[i][1]-co[i][0]);\n\t\t\t\t\tif(l <= r){\n\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i-1][j] + Math.abs(k-co[i][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(Arrays.stream(dp[n-1]).min().getAsLong());\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main{\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        PriorityQueue<Long> lindex = new PriorityQueue<>(Collections.reverseOrder());\n        PriorityQueue<Long> rindex = new PriorityQueue<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.peek() >= (l[i]+lbase)){\n                lindex.add(l[i]+lbase);\n                lindex.add(l[i]+lbase);\n                ans += Math.abs(lindex.peek()-(l[i]+lbase));\n                rindex.add(lindex.poll());\n            }else if(rindex.peek() <= (l[i]-rbase)){\n                rindex.add(l[i]-rbase);\n                rindex.add(l[i]-rbase);\n                ans += Math.abs(rindex.peek()-(l[i]-rbase));\n                lindex.add(rindex.poll());\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tfinal long max_r = Arrays.stream(rs).max().getAsLong();\n\t\tfinal long max_l = Arrays.stream(ls).max().getAsLong();\n\t\t\n\t\tif(N > 400 || max_r > 400 || max_l > 400){ throw new RuntimeException(); }\n\t\t\n\t\tlong[] DP = new long[400 + 1];\n\t\tlong[] nextDP = new long[400 + 1];\n\t\tArrays.fill(DP, Integer.MAX_VALUE);\n\t\t\n\t\tfor(int left = 0; left <= 400 - (rs[0]); left++){\n\t\t\tDP[left] = Math.abs(ls[0] - left);\n\t\t}\n\t\t\n\t\t//System.out.println(Arrays.toString(DP));\n\t\tfor(int block = 1; block < N; block++){\n\t\t\tfinal int curr_block_l = (int)(ls[block]);\n\t\t\tfinal int curr_block_r = (int)(rs[block]);\n\t\t\t\n\t\t\tArrays.fill(nextDP, Integer.MAX_VALUE);\n\t\t\t\n\t\t\tfor(int left = 0; left <= (400 - curr_block_r); left++){\n\t\t\t\tfinal int prev_block_r = Math.min(400, left + (int)(rs[block - 1] - ls[block - 1]));\n\t\t\t\t\n\t\t\t\tfor(int next_left = Math.max(0, left - (curr_block_r - curr_block_l)); next_left <= prev_block_r; next_left++){\n\t\t\t\t\t//System.out.println(next_left + \" \" + left + \" \" + DP[left] + \" \" + (DP[left] + Math.abs(next_left - curr_block_l)));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(next_left + \" \" + (DP[left] + Math.abs(next_left - curr_block_l)));\n\t\t\t\t\tnextDP[next_left] = Math.min(nextDP[next_left], DP[left] + Math.abs(next_left - curr_block_l));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(nextDP));\n\t\t\t\n\t\t\tfor(int i = 0; i < DP.length; i++){ DP[i] = nextDP[i]; }\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(DP));\n\t\t}\n\t\t\n\t\tSystem.out.println(Arrays.stream(nextDP).min().getAsLong());\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * @author Ivan Pryvalov (ivan.pryvalov@gmail.com)\n */\npublic class Main implements Runnable {\n    static EventType eventType = EventType.DEFAULT; //EventType.GOOGLE_CODE_JAM;\n    static int T = 1; // T \\in {0,1}. If T=0, it will be read from the input.\n    static String inputFilename = null; // if 'null', it reads data from std-in.\n\n    static boolean largeFakeTest = false; // Check if you generate data on fly\n    static int largeFakeTest_T = 1;\n\n    //--------------------------------------------------------------------\n\n    public static class Solver extends  SolverAbstract{\n\n        int MAX_SMALL = 400;\n        boolean big = false;\n\n        int N;\n        int[] L;\n        int[] R;\n        int max_R;\n\n        @Override\n        public void readInput() throws IOException {\n            big = false;\n            max_R = 0;\n            N = scanner.nextInt();\n            if (N > MAX_SMALL ){\n                big = true;\n            }\n            L = new int[N];\n            R = new int[N];\n            for (int i = 0; i < N; i++) {\n                L[i] = scanner.nextInt();\n                R[i] = scanner.nextInt();\n                max_R = Math.max(max_R, R[i]);\n                if (L[i] > MAX_SMALL || R[i] > MAX_SMALL){\n                    big = true;\n                }\n            }\n        }\n\n        private long cost(long mid){\n            long cost = 0;\n            for (int i = 0; i < N; i++) {\n                if (L[i] > mid){\n                    cost += L[i] - mid;\n                }else if (R[i] < mid){\n                    cost += mid - R[i];\n                }\n            }\n            return cost;\n        }\n\n        @Override\n        protected void solve() throws IOException {\n//            if (big){\n//                out.println(0);\n//                return;\n//            }\n            int left = 0;\n            int right = max_R + 1;\n\n            while(right - left > 3) {\n                int mid1 = left + (right - left) / 3;\n                int mid2 = left + 2 * (right - left) / 3;\n\n                long f1 = cost(mid1);\n                long f2 = cost(mid2);\n                if (f1 < f2) {\n                    right = mid2;\n                } else {\n                    left = mid1;\n                }\n            }\n\n            long total_cost = Long.MAX_VALUE / 3;\n            for (int i = left; i <= right; i++) {\n                total_cost = Math.min(total_cost, cost(i));\n            }\n\n//            int total_cost = Integer.MAX_VALUE / 3;\n//            for (int mid = 1; mid <= max_R; mid++) {\n//                total_cost = Math.min(total_cost, cost);\n//            }\n            out.println(total_cost);\n        }\n    }\n\n    //--------------------------------------------------------------------\n\n    private void solveAll() throws IOException {\n        long timeStart = System.currentTimeMillis();\n        if (T==0) {\n            if (largeFakeTest) {\n                T = largeFakeTest_T;\n            } else {\n                T = scanner.nextInt();\n            }\n        }\n        final String[] results = new String[T+1];\n        for (int test = 0; test < T; test++) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream outLocal = new PrintStream(baos);\n            Solver solver = new Solver(){\n                @Override\n                public void callback() {\n                    results[testNo] = answer;\n                }\n            };\n            solver.out = outLocal;\n            solver.testNo = test+1;\n            if (largeFakeTest) {\n                solver.readFakeInput();\n            }else{\n                solver.readInput();\n            }\n            solver.solveWrapped(baos);\n        }\n\n        long timeEnd = System.currentTimeMillis();\n        if (isInputFromFile())\n            System.out.println(\"All tasks are solved! Elapsed time \"+(timeEnd-timeStart)/1000.0+\" sec.\");\n\n        // write all responses in the proper order\n        for (int i = 1; i <= T; i++) {\n            if (eventType == EventType.GOOGLE_CODE_JAM){\n                outGlobal.printf(\"Case #%d: %s\", i, results[i]);\n            }else {\n                outGlobal.print(results[i]);\n            }\n        }\n    }\n\n    enum EventType{\n        DEFAULT,\n        GOOGLE_CODE_JAM\n    }\n\n    static boolean isInputFromFile() {\n        return inputFilename != null;\n    }\n\n    public static abstract class SolverAbstract {\n        PrintStream out;\n        int testNo;\n        String answer = null;\n\n        public void callback(){};\n\n        public abstract void readInput() throws IOException;\n\n        //generate a randomized test with the maximal input values\n        public void readFakeInput() throws  IOException{\n            throw new RuntimeException(\"not implemented\");\n        }\n\n        protected abstract void solve() throws IOException;\n\n        protected void solveWrapped(ByteArrayOutputStream baos) throws IOException {\n            if (isInputFromFile())\n                System.out.println(\"SOLVER: solving task #\"+testNo+\" out of \"+ T+\"...\");\n            solve();\n            answer = baos.toString();\n            if (isInputFromFile()) {\n                System.out.println(\"\\t\"+answer);\n            }\n            callback();\n        }\n    }\n\n    ////////////////////////////////////////////////////////\n    // Link about multithreading: http://stackoverflow.com/questions/4521983/java-executorservice-that-blocks-on-submission-after-a-certain-queue-size\n\n\n    // ------------- Some stardard tools that are currently not tested.\n    //adopt for the lists of adjacent vertices\n    static class Graph{\n\n        int[][] G;\n        int N;\n\n        int[][] A;\n        int[][] F;\n\n        int[] path;\n        int pathLen;\n        boolean[] visited;\n        int target;\n        boolean flowFound;\n\n        public Graph(int[][] g) {\n            G = g;\n            N = G.length;\n        }\n\n        public int[][] maxflow(int iSource, int iSink) {\n            path = new int[N];\n            visited = new boolean[N];\n\n            A = new int[N][];\n            for (int i = 0; i < N; i++) {\n                A[i] = G[i].clone();\n            }\n            F = new int[N][N];\n\n            target = iSink;\n            //dfs from source to sink\n            //increase path\n            while(true){\n                flowFound = false;\n                visited[iSource] = true;\n                pathLen = 0;\n                path[pathLen++] = iSource;\n                dfs(iSource);\n                if (!flowFound)\n                    break;\n            }\n            return F;\n        }\n\n        private void dfs(int u) {\n            if (u==target){\n                flowFound = true;\n                for (int i = 0; i < pathLen-1; i++) {\n                    int from = path[i];\n                    int to  = path[i+1];\n                    F[from][to]++;\n                    F[to][from]--;\n                }\n            }else {\n                for (int i = 0; i < N && !flowFound; i++) {\n                    if (!visited[i] && A[u][i] > F[u][i]) {\n                        visited[i] = true;\n                        path[pathLen] = i;\n                        pathLen++;\n                        dfs(i);\n                        visited[i] = false;\n                        pathLen--;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class Utilities{\n        public static List<Integer> getPrimes(int limit) {\n            boolean[] primes = new boolean[limit+1];\n            Arrays.fill(primes, true);\n\n            primes[1] = false;\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    for(int j=i+i; j<=limit; j+=i){\n                        primes[j] = false;\n                    }\n                }\n            }\n            List<Integer> listPrimes = new ArrayList<>();\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    listPrimes.add(i);\n                }\n            }\n            return listPrimes;\n        }\n    }\n\n    public static class Modulo{\n        long mod = (long)1e9+7;\n\n        public Modulo(long mod) {\n            super();\n            this.mod = mod;\n        }\n\n        public long inv(long a) {\n            long res =  pow(a, mod-2);\n            return res;\n        }\n\n        public long pow(long a, long x) {\n            if (x==0)\n                return 1;\n            long part = 1;\n            if ((x&1)!=0)\n                part = a;\n            return (part * pow((a*a)%mod, x>>1)) % mod;\n        }\n\n        public long c(long n, long m){\n            long res = 1;\n            for(int i=1; i<=m; i++){\n                res = (res * (n-m+i)) % mod;\n                res = (res * inv(i)) % mod;\n            }\n            return res;\n        }\n    }\n\n    /**\n     * Added 26.04.2013.\n     * See KROK 2013, Round 1, Problem D.\n     */\n    static class DisjointUnionSet implements Cloneable{\n        int[] rank;\n        int[] parent;\n\n        protected DisjointUnionSet clone(){\n            DisjointUnionSet cloned = new DisjointUnionSet(parent.length);\n            for(int i=0; i<parent.length; i++){\n                cloned.parent[i] = parent[i];\n                cloned.rank[i] = rank[i];\n            }\n            return cloned;\n        }\n\n        public DisjointUnionSet(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"disj [parents=\" + Arrays.toString(parent) + \"]\";\n        }\n\n        /**\n         * Problem specific or general?\n         * O(N * alpha)\n         */\n        public void union(DisjointUnionSet set2){\n            for(int i=0; i<parent.length; i++){\n                parent[find(i)] = parent[find(set2.find(i))];\n            }\n        }\n\n        /**\n         * @param index1 range 0..n-1\n         * @param index2\n         */\n        public void union(int index1, int index2){\n            int p1 = find(index1);\n            int p2 = find(index2);\n            if (rank[p1] > rank[p2]){\n                parent[p2] = p1;\n            }else if (rank[p2] > rank[p1]){\n                parent[p1] = p2;\n            }else{\n                parent[p2] = p1;\n                rank[p1]++;\n            }\n        }\n\n        // O(alpha(n))\n        private int find(int index) {\n            if (parent[index] != index)\n                parent[index] =  find(parent[index]);\n            return parent[index];\n        }\n\n        // O(N alpha(N)) ==> see find()\n        public int getCountDisjointSets(){\n            int[] used = new int[parent.length];\n            for(int i=0; i<parent.length; i++){\n                used[find(i)] = 1;\n            }\n            int res = 0;\n            for(int i=0; i<parent.length; i++){\n                res += used[i];\n            }\n            return res;\n        }\n    }\n\n    private static Random rnd = new Random();\n    public static class ArrayUtils{\n        public static void shuffle(int[] a){\n            for(int j=a.length-1; j>=1; j--){\n                int i = rnd.nextInt(j+1);\n                swap(a, i, j);\n            }\n        }\n\n        public static void swap(int[] a, int i, int j){\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n    }\n\n    static class GraphSupport{\n        /*\n        //Added 20.02.2017.\n        //See Codeforces Round 398, Div.2, C.\n        // Recoursive call to dfs function may result in either MTL or StackOverflow.\n        // Codeforces provide stacksize 64M\n\n        private void dfs_no_recursion(int root, IntConsumer dfs_post){\n            int[] stack = new int[N];\n            int[] stackInt = new int[N];\n            int iStack = 0;\n            stack[iStack] = root;\n            stackInt[iStack++] = 0;\n            while(true){\n                Node node = nodes[stack[iStack-1]];\n                int childIdx = stackInt[iStack-1];\n                if (childIdx < node.children.size()){\n                    stack[iStack] = node.children.get(childIdx).idx;\n                    stackInt[iStack++] = 0;\n                }else{\n                    dfs_post.accept(node.idx);\n\n                    iStack--;\n                    if (iStack==0){\n                        break;\n                    }\n                    stackInt[iStack-1]++;\n                }\n            }\n        }\n        */\n    }\n\n\n    ////////////////////////////////////////////////////////\n    /// Typically, you don't want to edit anything below\n    ///////////////////////////////////////////////////////\n    final int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n    final int INPUT_BUFFER_SIZE = 1024 * 1024 * 8;\n    final int BUF_SIZE_INPUT = 1024;\n\n    boolean useClassResourceTopDir = true;\n    String outSuffix = \".out\";\n\n    static PrintStream outGlobal;\n    static ByteScanner scanner;\n\n    public void run() {\n        try{\n            InputStream bis;\n            OutputStream bos;\n            if (inputFilename !=null){\n                File inputFile;\n                File outputFile;\n                if (useClassResourceTopDir) {\n                    File baseFile = new File(getClass().getResource(\"/\").getFile());\n                    inputFile = new File(baseFile, inputFilename);\n                    outputFile = new File(baseFile, inputFilename +outSuffix);\n                }else{\n                    inputFile = new File(inputFilename);\n                    outputFile = new File(inputFilename +outSuffix);\n                }\n                System.out.println(\"Input file canonical path: \"+inputFile.getCanonicalPath());\n                bis = new BufferedInputStream(\n                        new FileInputStream(inputFile),\n                        INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(new FileOutputStream(outputFile));\n                outGlobal = new PrintStream(bos);\n            }else{\n                bis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(System.out);\n                outGlobal = new PrintStream(bos);\n            }\n            scanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\n            solveAll();\n            outGlobal.flush();\n        }catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static class EofException extends IOException{\n    }\n\n    public static class ByteScanner{\n        InputStream is;\n\n        public ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n            this.is = is;\n            this.bufSizeInput = bufSizeInput;\n            this.bufSize = bufSize;\n\n            byteBufInput = new byte[this.bufSizeInput];\n            byteBuf = new byte[this.bufSize];\n        }\n\n        public ByteScanner(byte[] data){\n            byteBufInput = data;\n            bufSizeInput = data.length;\n            bufSize = data.length;\n            byteBuf = new byte[bufSize];\n            byteRead = data.length;\n            bytePos = 0;\n        }\n\n        private int bufSizeInput;\n        private int bufSize;\n\n        byte[] byteBufInput;\n        byte by=-1;\n        int byteRead=-1;\n        int bytePos=-1;\n\n        byte[] byteBuf;\n        int totalBytes;\n\n        boolean eofMet = false;\n\n        private byte nextByte() throws IOException{\n            if (bytePos<0 || bytePos>=byteRead){\n                byteRead = is==null? -1: is.read(byteBufInput);\n                bytePos=0;\n                if (byteRead<0){\n                    byteBufInput[bytePos]=-1;//!!!\n                    if (eofMet)\n                        throw new EofException();\n                    eofMet = true;\n                }\n            }\n            return byteBufInput[bytePos++];\n        }\n\n        public byte nextVisibleChar() throws IOException{\n            while ((by=nextByte())<=0x20);\n            return by;\n        }\n\n        public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Reads token. Spacebar is separator char.\n        public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Spacebar is included as separator char\n        private void readToken() throws IOException {\n            readToken((byte)0x21);\n        }\n\n        private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n        }\n\n        public int nextInt() throws IOException{\n            readToken();\n            int num=0, i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public long nextLong() throws IOException{\n            readToken();\n            long num=0;\n            int i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public double nextDouble() throws IOException{\n            readToken();\n            char[] token = new char[totalBytes];\n            for (int i = 0; i < totalBytes; i++) {\n                token[i] = (char)byteBuf[i];\n            }\n            return Double.parseDouble(new String(token));\n        }\n\n        public int[] loadIntArray(int size) throws IOException{\n            int[] a = new int[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] loadLongArray(int size) throws IOException{\n            long[] a = new long[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc070;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\n\npublic class Main {\n    private static final int INF = 100000000;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[][] lr = in.nextIntTable(n, 2);\n        for (int i = 0; i < n ; i++) {\n            lr[i][1] = lr[i][1] - lr[i][0];\n        }\n\n        TreeSet<LinePoint> left = new TreeSet<>((a, b) -> a.p == b.p ? a.idx - b.idx : Long.compare(a.p, b.p));\n        TreeSet<LinePoint> right = new TreeSet<>((a, b) -> a.p == b.p ? a.idx - b.idx : Long.compare(a.p, b.p));\n        long exLeft = 0;\n        long exRight = 0;\n\n        left.add(LinePoint.create(lr[0][0]));\n        right.add(LinePoint.create(lr[0][0]));\n\n        long bottom = 0;\n        for (int i = 1 ; i < n ; i++) {\n            exLeft -= lr[i][1];\n            exRight += lr[i-1][1];\n            long zeroFrom = left.last().p + exLeft;\n            long zeroTo = right.first().p + exRight;\n\n            if (zeroFrom <= lr[i][0] && lr[i][0] <= zeroTo) {\n                left.add(LinePoint.create(lr[i][0] - exLeft));\n                right.add(LinePoint.create(lr[i][0] - exRight));\n            } else if (lr[i][0] < zeroFrom) {\n                long add = Math.abs((left.last().p + exLeft) - lr[i][0]);\n\n                left.add(LinePoint.create(lr[i][0] - exLeft));\n                left.add(LinePoint.create(lr[i][0] - exLeft));\n                left.pollLast();\n\n                LinePoint pt = right.first();\n                right.add(LinePoint.create(pt.p - (zeroTo - zeroFrom)));\n\n                bottom += add;\n            } else {\n                long add = Math.abs((right.first().p + exRight) - lr[i][0]);\n\n                right.add(LinePoint.create(lr[i][0] - exRight));\n                right.add(LinePoint.create(lr[i][0] - exRight));\n                right.pollFirst();\n\n                LinePoint pt = left.last();\n                left.add(LinePoint.create(pt.p + (zeroTo - zeroFrom)));\n\n                bottom += add;\n            }\n        }\n\n        // debug(\"all\", left.last().p + exLeft, right.first().p + exRight, bottom);\n\n\n        out.println(bottom);\n        out.flush();\n    }\n\n\n    static class LinePoint {\n        static int seq = 0;\n        long p;\n        int idx;\n\n        static LinePoint create(long p) {\n            return new LinePoint(p, ++seq);\n        }\n\n        public LinePoint(long p, int i) {\n            this.p = p;\n            this.idx = i;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%d - %d\", p, idx);\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n\n            if(lindex.ceiling(l[i]+lbase+1) != null){\n                lindex.add(l[i]+lbase);\n                long top = lindex.pollLast();\n                long next= lindex.last();\n                ans += Math.abs(top-next);\n                rindex.add(top-lbase - rbase);\n            }else if(rindex.floor(l[i]-rbase-1) != null){\n                rindex.add(l[i]-rbase);\n                long bot = rindex.pollFirst();\n                long next= rindex.first();\n                ans += Math.abs(bot-next);\n                lindex.add(bot+rbase+lbase);\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tfinal long max_r = Arrays.stream(rs).max().getAsLong();\n\t\tfinal long max_l = Arrays.stream(ls).max().getAsLong();\n\t\t\n\t\tif(N > 400 || max_r > 400 || max_l > 400){ return; }\n\t\t\n\t\tlong answer = Long.MAX_VALUE;\n\t\tfor(int same_l = 0; same_l <= 500; same_l++){\n\t\t\tLOOP:\n\t\t\tfor(int same_r = same_l; same_r <= 500; same_r++){\n\t\t\t\tfinal long same_size = same_r - same_l;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlong curr_answer = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfinal long block_l = ls[i];\n\t\t\t\t\tfinal long block_r = rs[i];\n\t\t\t\t\tfinal long block_size = block_r - block_l;\n\t\t\t\t\t\n\t\t\t\t\tif(block_size < same_size){ continue LOOP; }\n\t\t\t\t\t\n\t\t\t\t\tif(block_l <= same_l && same_r <= block_r){ continue; }\n\t\t\t\t\t\n\t\t\t\t\t//long min_cost = Long.MAX_VALUE;\n\t\t\t\t\t\n\t\t\t\t\tif(block_l > same_l){\n\t\t\t\t\t\tcurr_answer += (block_l - same_l);\n\t\t\t\t\t}else if(block_r < same_r){\n\t\t\t\t\t\tcurr_answer += (same_r - block_r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(same_l + \" \" + same_r + \" \" + curr_answer);\n\t\t\t\tanswer = Math.min(answer, curr_answer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tfinal long max_r = Arrays.stream(rs).max().getAsLong();\n\t\tfinal long max_l = Arrays.stream(ls).max().getAsLong();\n\t\t\n\t\tif(N > 400 || max_r > 400 || max_l > 400){ return; }\n\t\t\n\t\tlong answer = Long.MAX_VALUE;\n\t\tfor(int same_l = 0; same_l <= 400; same_l++){\n\t\t\tLOOP:\n\t\t\tfor(int same_r = same_l; same_r <= 400; same_r++){\n\t\t\t\tfinal long same_size = same_r - same_l;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlong curr_answer = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfinal long block_l = ls[i];\n\t\t\t\t\tfinal long block_r = rs[i];\n\t\t\t\t\tfinal long block_size = block_r - block_l;\n\t\t\t\t\t\n\t\t\t\t\tif(block_size < same_size){ continue LOOP; }\n\t\t\t\t\t\n\t\t\t\t\tif(block_l <= same_l && same_r <= block_r){ continue; }\n\t\t\t\t\t\n\t\t\t\t\tlong min_cost = Long.MAX_VALUE;\n\t\t\t\t\t\n\t\t\t\t\tif(block_l > same_l){\n\t\t\t\t\t\tmin_cost = Math.min(min_cost, block_l - same_l);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(block_r < same_r){\n\t\t\t\t\t\tmin_cost = Math.min(min_cost, same_r - block_r);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcurr_answer += min_cost;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(same_l + \" \" + same_r + \" \" + curr_answer);\n\t\t\t\tanswer = Math.min(answer, curr_answer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc070;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final int INF = 100000000;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        if (n > 400) {\n            throw new RuntimeException();\n        }\n\n        int limit = 410;\n        int[][] lr = in.nextIntTable(n, 2);\n        for (int i = 0; i < n ; i++) {\n            lr[i][1] = lr[i][1] - lr[i][0];\n        }\n\n        int[][] dp = new int[n][limit];\n        for (int i = 0; i < limit ; i++) {\n            dp[0][i] = Math.abs(lr[0][0] - i);\n        }\n        for (int i = 1 ; i < n ; i++) {\n            Arrays.fill(dp[i], INF);\n        }\n\n        for (int i = 1 ; i < n ; i++) {\n            for (int j = 0; j < limit; j++) {\n                int nextFr = j;\n                int nextTo = j + lr[i][1];\n                for (int p = 0; p < limit; p++) {\n                    int fr = p;\n                    int to = p + lr[i-1][1];\n                    if (nextTo < fr || to < nextFr || dp[i-1][p] >= INF) {\n                        continue;\n                    }\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][p] + Math.abs(lr[i][0] - j));\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < limit ; i++) {\n            ans = Math.min(ans, dp[n-1][i]);\n        }\n        out.println(ans);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = sc.nextInt();\n\t\t\tr[i] = sc.nextInt();\n\t\t}\n\n\t\tif (n > 400) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\n\t\tint[][] dp = new int[n][400 + 2];\n\t\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\tArrays.fill(dp[0], INF);\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tif (i >= l[0] && i <= r[0]) {\n\t\t\t\tdp[0][i] = 0;\n\t\t\t} else if (i < l[0]) {\n\t\t\t\tdp[0][i] = l[0] - i;\n\t\t\t} else {\n\t\t\t\tdp[0][i] = i - r[0];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t\tfor (int j = 1; j < l[i]; j++) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k <= Math.min(j + r[i] - l[i], 400); k++) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], l[i] - j + prev);\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);\n\t\t\t}\n\t\t\tfor (int j = 400; j > r[i]; j--) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k >= Math.max(j - (r[i] - l[i]), 0); k--) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], j - r[i] + prev);\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j + 1]);\n\t\t\t}\n\t\t\tint prev = INF;\n\t\t\tfor (int k = l[i]; k <= r[i]; k++) {\n\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t}\n\t\t\tfor (int j = l[i]; j <= r[i]; j++) {\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][l[i] - 1]);\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][r[i] + 1]);\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], prev);\n\t\t\t}\n\t\t}\n\n\t\tint ret = INF;\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tret = Math.min(ret, dp[n - 1][i]);\n\t\t}\n\n\t\tpr.println(ret);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tfinal long max_r = Arrays.stream(rs).max().getAsLong();\n\t\tfinal long max_l = Arrays.stream(ls).max().getAsLong();\n\t\t\n\t\tif(N > 400 || max_r > 400 || max_l > 400){ return; }\n\t\t\n\t\tlong answer = Long.MAX_VALUE;\n\t\tfor(int same_l = 0; same_l <= 400; same_l++){\n\t\t\tLOOP:\n\t\t\tfor(int same_r = same_l; same_r <= 400; same_r++){\n\t\t\t\tfinal long same_size = same_r - same_l;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlong curr_answer = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfinal long block_l = ls[i];\n\t\t\t\t\tfinal long block_r = rs[i];\n\t\t\t\t\tfinal long block_size = block_r - block_l;\n\t\t\t\t\t\n\t\t\t\t\tif(block_size < same_size){ continue LOOP; }\n\t\t\t\t\t\n\t\t\t\t\tif(block_l <= same_l && same_r <= block_r){ continue; }\n\t\t\t\t\t\n\t\t\t\t\t//long min_cost = Long.MAX_VALUE;\n\t\t\t\t\t\n\t\t\t\t\tif(block_l > same_l){\n\t\t\t\t\t\tcurr_answer += (block_l - same_l);\n\t\t\t\t\t}else if(block_r < same_r){\n\t\t\t\t\t\tcurr_answer += (same_r - block_r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(same_l + \" \" + same_r + \" \" + curr_answer);\n\t\t\t\tanswer = Math.min(answer, curr_answer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint[] l = new int[N];\n\t\tint[] r = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tl[i] = sc.nextInt() - 1;\n\t\t\tr[i] = sc.nextInt() - 1;\n\t\t}\n\t\tlong[][] cost = new long[2][400];\n\t\tArrays.fill(cost[1], 0);\n\t\tArrays.fill(cost[0], Long.MAX_VALUE / 16);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int pos = 0; pos < 400; ++pos) {\n\t\t\t\tlong MIN = Long.MAX_VALUE / 16;\n\t\t\t\tfor (int j = Math.max(0, i > 0 ? (pos - (r[i - 1] - l[i - 1])) : 0); j <= r[i]; ++j) {\n\t\t\t\t\tMIN = Math.min(cost[(i + 1) % 2][j], MIN);\n\t\t\t\t}\n\t\t\t\tcost[i % 2][pos] = MIN + Math.abs(pos - l[i]);\n\t\t\t}\n\t\t}\n\t\tlong ans = Long.MAX_VALUE / 16;\n\t\tfor (int i = 0; i < 400; ++i) {\n\t\t\tans = Math.min(ans, cost[(N - 1) % 2][i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * @author Ivan Pryvalov (ivan.pryvalov@gmail.com)\n */\npublic class Main implements Runnable {\n    static EventType eventType = EventType.DEFAULT; //EventType.GOOGLE_CODE_JAM;\n    static int T = 1; // T \\in {0,1}. If T=0, it will be read from the input.\n    static String inputFilename = null; // if 'null', it reads data from std-in.\n\n    static boolean largeFakeTest = false; // Check if you generate data on fly\n    static int largeFakeTest_T = 1;\n\n    //--------------------------------------------------------------------\n\n    public static class Solver extends  SolverAbstract{\n\n        int MAX_SMALL = 400;\n        boolean big = false;\n\n        int N;\n        int[] L;\n        int[] R;\n\n        @Override\n        public void readInput() throws IOException {\n            big = false;\n            N = scanner.nextInt();\n            if (N > MAX_SMALL ){\n                big = true;\n            }\n            L = new int[N];\n            R = new int[N];\n            for (int i = 0; i < N; i++) {\n                L[i] = scanner.nextInt();\n                R[i] = scanner.nextInt();\n                if (L[i] > MAX_SMALL || R[i] > MAX_SMALL){\n                    big = true;\n                }\n            }\n        }\n\n        @Override\n        protected void solve() throws IOException {\n            if (big){\n                out.println(0);\n                return;\n            }\n            int total_cost = Integer.MAX_VALUE / 3;\n            for (int mid = 1; mid <= 400; mid++) {\n                int cost = 0;\n                for (int i = 0; i < N; i++) {\n                    if (L[i] > mid){\n                        cost += L[i] - mid;\n                    }else if (R[i] < mid){\n                        cost += mid - R[i];\n                    }\n                }\n                total_cost = Math.min(total_cost, cost);\n            }\n            out.println(total_cost);\n        }\n    }\n\n    //--------------------------------------------------------------------\n\n    private void solveAll() throws IOException {\n        long timeStart = System.currentTimeMillis();\n        if (T==0) {\n            if (largeFakeTest) {\n                T = largeFakeTest_T;\n            } else {\n                T = scanner.nextInt();\n            }\n        }\n        final String[] results = new String[T+1];\n        for (int test = 0; test < T; test++) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream outLocal = new PrintStream(baos);\n            Solver solver = new Solver(){\n                @Override\n                public void callback() {\n                    results[testNo] = answer;\n                }\n            };\n            solver.out = outLocal;\n            solver.testNo = test+1;\n            if (largeFakeTest) {\n                solver.readFakeInput();\n            }else{\n                solver.readInput();\n            }\n            solver.solveWrapped(baos);\n        }\n\n        long timeEnd = System.currentTimeMillis();\n        if (isInputFromFile())\n            System.out.println(\"All tasks are solved! Elapsed time \"+(timeEnd-timeStart)/1000.0+\" sec.\");\n\n        // write all responses in the proper order\n        for (int i = 1; i <= T; i++) {\n            if (eventType == EventType.GOOGLE_CODE_JAM){\n                outGlobal.printf(\"Case #%d: %s\", i, results[i]);\n            }else {\n                outGlobal.print(results[i]);\n            }\n        }\n    }\n\n    enum EventType{\n        DEFAULT,\n        GOOGLE_CODE_JAM\n    }\n\n    static boolean isInputFromFile() {\n        return inputFilename != null;\n    }\n\n    public static abstract class SolverAbstract {\n        PrintStream out;\n        int testNo;\n        String answer = null;\n\n        public void callback(){};\n\n        public abstract void readInput() throws IOException;\n\n        //generate a randomized test with the maximal input values\n        public void readFakeInput() throws  IOException{\n            throw new RuntimeException(\"not implemented\");\n        }\n\n        protected abstract void solve() throws IOException;\n\n        protected void solveWrapped(ByteArrayOutputStream baos) throws IOException {\n            if (isInputFromFile())\n                System.out.println(\"SOLVER: solving task #\"+testNo+\" out of \"+ T+\"...\");\n            solve();\n            answer = baos.toString();\n            if (isInputFromFile()) {\n                System.out.println(\"\\t\"+answer);\n            }\n            callback();\n        }\n    }\n\n    ////////////////////////////////////////////////////////\n    // Link about multithreading: http://stackoverflow.com/questions/4521983/java-executorservice-that-blocks-on-submission-after-a-certain-queue-size\n\n\n    // ------------- Some stardard tools that are currently not tested.\n    //adopt for the lists of adjacent vertices\n    static class Graph{\n\n        int[][] G;\n        int N;\n\n        int[][] A;\n        int[][] F;\n\n        int[] path;\n        int pathLen;\n        boolean[] visited;\n        int target;\n        boolean flowFound;\n\n        public Graph(int[][] g) {\n            G = g;\n            N = G.length;\n        }\n\n        public int[][] maxflow(int iSource, int iSink) {\n            path = new int[N];\n            visited = new boolean[N];\n\n            A = new int[N][];\n            for (int i = 0; i < N; i++) {\n                A[i] = G[i].clone();\n            }\n            F = new int[N][N];\n\n            target = iSink;\n            //dfs from source to sink\n            //increase path\n            while(true){\n                flowFound = false;\n                visited[iSource] = true;\n                pathLen = 0;\n                path[pathLen++] = iSource;\n                dfs(iSource);\n                if (!flowFound)\n                    break;\n            }\n            return F;\n        }\n\n        private void dfs(int u) {\n            if (u==target){\n                flowFound = true;\n                for (int i = 0; i < pathLen-1; i++) {\n                    int from = path[i];\n                    int to  = path[i+1];\n                    F[from][to]++;\n                    F[to][from]--;\n                }\n            }else {\n                for (int i = 0; i < N && !flowFound; i++) {\n                    if (!visited[i] && A[u][i] > F[u][i]) {\n                        visited[i] = true;\n                        path[pathLen] = i;\n                        pathLen++;\n                        dfs(i);\n                        visited[i] = false;\n                        pathLen--;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class Utilities{\n        public static List<Integer> getPrimes(int limit) {\n            boolean[] primes = new boolean[limit+1];\n            Arrays.fill(primes, true);\n\n            primes[1] = false;\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    for(int j=i+i; j<=limit; j+=i){\n                        primes[j] = false;\n                    }\n                }\n            }\n            List<Integer> listPrimes = new ArrayList<>();\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    listPrimes.add(i);\n                }\n            }\n            return listPrimes;\n        }\n    }\n\n    public static class Modulo{\n        long mod = (long)1e9+7;\n\n        public Modulo(long mod) {\n            super();\n            this.mod = mod;\n        }\n\n        public long inv(long a) {\n            long res =  pow(a, mod-2);\n            return res;\n        }\n\n        public long pow(long a, long x) {\n            if (x==0)\n                return 1;\n            long part = 1;\n            if ((x&1)!=0)\n                part = a;\n            return (part * pow((a*a)%mod, x>>1)) % mod;\n        }\n\n        public long c(long n, long m){\n            long res = 1;\n            for(int i=1; i<=m; i++){\n                res = (res * (n-m+i)) % mod;\n                res = (res * inv(i)) % mod;\n            }\n            return res;\n        }\n    }\n\n    /**\n     * Added 26.04.2013.\n     * See KROK 2013, Round 1, Problem D.\n     */\n    static class DisjointUnionSet implements Cloneable{\n        int[] rank;\n        int[] parent;\n\n        protected DisjointUnionSet clone(){\n            DisjointUnionSet cloned = new DisjointUnionSet(parent.length);\n            for(int i=0; i<parent.length; i++){\n                cloned.parent[i] = parent[i];\n                cloned.rank[i] = rank[i];\n            }\n            return cloned;\n        }\n\n        public DisjointUnionSet(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"disj [parents=\" + Arrays.toString(parent) + \"]\";\n        }\n\n        /**\n         * Problem specific or general?\n         * O(N * alpha)\n         */\n        public void union(DisjointUnionSet set2){\n            for(int i=0; i<parent.length; i++){\n                parent[find(i)] = parent[find(set2.find(i))];\n            }\n        }\n\n        /**\n         * @param index1 range 0..n-1\n         * @param index2\n         */\n        public void union(int index1, int index2){\n            int p1 = find(index1);\n            int p2 = find(index2);\n            if (rank[p1] > rank[p2]){\n                parent[p2] = p1;\n            }else if (rank[p2] > rank[p1]){\n                parent[p1] = p2;\n            }else{\n                parent[p2] = p1;\n                rank[p1]++;\n            }\n        }\n\n        // O(alpha(n))\n        private int find(int index) {\n            if (parent[index] != index)\n                parent[index] =  find(parent[index]);\n            return parent[index];\n        }\n\n        // O(N alpha(N)) ==> see find()\n        public int getCountDisjointSets(){\n            int[] used = new int[parent.length];\n            for(int i=0; i<parent.length; i++){\n                used[find(i)] = 1;\n            }\n            int res = 0;\n            for(int i=0; i<parent.length; i++){\n                res += used[i];\n            }\n            return res;\n        }\n    }\n\n    private static Random rnd = new Random();\n    public static class ArrayUtils{\n        public static void shuffle(int[] a){\n            for(int j=a.length-1; j>=1; j--){\n                int i = rnd.nextInt(j+1);\n                swap(a, i, j);\n            }\n        }\n\n        public static void swap(int[] a, int i, int j){\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n    }\n\n    static class GraphSupport{\n        /*\n        //Added 20.02.2017.\n        //See Codeforces Round 398, Div.2, C.\n        // Recoursive call to dfs function may result in either MTL or StackOverflow.\n        // Codeforces provide stacksize 64M\n\n        private void dfs_no_recursion(int root, IntConsumer dfs_post){\n            int[] stack = new int[N];\n            int[] stackInt = new int[N];\n            int iStack = 0;\n            stack[iStack] = root;\n            stackInt[iStack++] = 0;\n            while(true){\n                Node node = nodes[stack[iStack-1]];\n                int childIdx = stackInt[iStack-1];\n                if (childIdx < node.children.size()){\n                    stack[iStack] = node.children.get(childIdx).idx;\n                    stackInt[iStack++] = 0;\n                }else{\n                    dfs_post.accept(node.idx);\n\n                    iStack--;\n                    if (iStack==0){\n                        break;\n                    }\n                    stackInt[iStack-1]++;\n                }\n            }\n        }\n        */\n    }\n\n\n    ////////////////////////////////////////////////////////\n    /// Typically, you don't want to edit anything below\n    ///////////////////////////////////////////////////////\n    final int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n    final int INPUT_BUFFER_SIZE = 1024 * 1024 * 8;\n    final int BUF_SIZE_INPUT = 1024;\n\n    boolean useClassResourceTopDir = true;\n    String outSuffix = \".out\";\n\n    static PrintStream outGlobal;\n    static ByteScanner scanner;\n\n    public void run() {\n        try{\n            InputStream bis;\n            OutputStream bos;\n            if (inputFilename !=null){\n                File inputFile;\n                File outputFile;\n                if (useClassResourceTopDir) {\n                    File baseFile = new File(getClass().getResource(\"/\").getFile());\n                    inputFile = new File(baseFile, inputFilename);\n                    outputFile = new File(baseFile, inputFilename +outSuffix);\n                }else{\n                    inputFile = new File(inputFilename);\n                    outputFile = new File(inputFilename +outSuffix);\n                }\n                System.out.println(\"Input file canonical path: \"+inputFile.getCanonicalPath());\n                bis = new BufferedInputStream(\n                        new FileInputStream(inputFile),\n                        INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(new FileOutputStream(outputFile));\n                outGlobal = new PrintStream(bos);\n            }else{\n                bis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(System.out);\n                outGlobal = new PrintStream(bos);\n            }\n            scanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\n            solveAll();\n            outGlobal.flush();\n        }catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static class EofException extends IOException{\n    }\n\n    public static class ByteScanner{\n        InputStream is;\n\n        public ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n            this.is = is;\n            this.bufSizeInput = bufSizeInput;\n            this.bufSize = bufSize;\n\n            byteBufInput = new byte[this.bufSizeInput];\n            byteBuf = new byte[this.bufSize];\n        }\n\n        public ByteScanner(byte[] data){\n            byteBufInput = data;\n            bufSizeInput = data.length;\n            bufSize = data.length;\n            byteBuf = new byte[bufSize];\n            byteRead = data.length;\n            bytePos = 0;\n        }\n\n        private int bufSizeInput;\n        private int bufSize;\n\n        byte[] byteBufInput;\n        byte by=-1;\n        int byteRead=-1;\n        int bytePos=-1;\n\n        byte[] byteBuf;\n        int totalBytes;\n\n        boolean eofMet = false;\n\n        private byte nextByte() throws IOException{\n            if (bytePos<0 || bytePos>=byteRead){\n                byteRead = is==null? -1: is.read(byteBufInput);\n                bytePos=0;\n                if (byteRead<0){\n                    byteBufInput[bytePos]=-1;//!!!\n                    if (eofMet)\n                        throw new EofException();\n                    eofMet = true;\n                }\n            }\n            return byteBufInput[bytePos++];\n        }\n\n        public byte nextVisibleChar() throws IOException{\n            while ((by=nextByte())<=0x20);\n            return by;\n        }\n\n        public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Reads token. Spacebar is separator char.\n        public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Spacebar is included as separator char\n        private void readToken() throws IOException {\n            readToken((byte)0x21);\n        }\n\n        private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n        }\n\n        public int nextInt() throws IOException{\n            readToken();\n            int num=0, i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public long nextLong() throws IOException{\n            readToken();\n            long num=0;\n            int i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public double nextDouble() throws IOException{\n            readToken();\n            char[] token = new char[totalBytes];\n            for (int i = 0; i < totalBytes; i++) {\n                token[i] = (char)byteBuf[i];\n            }\n            return Double.parseDouble(new String(token));\n        }\n\n        public int[] loadIntArray(int size) throws IOException{\n            int[] a = new int[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] loadLongArray(int size) throws IOException{\n            long[] a = new long[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic class MultiTreeSet {\n\t\tprivate TreeMap<Long, Integer> map = new TreeMap<>();\n\n\t\tint count(long x) {\n\t\t\treturn map.getOrDefault(x, 0);\n\t\t}\n\n\t\tvoid add(long x) {\n\t\t\tmap.put(x, count(x) + 1);\n\t\t}\n\n\t\tvoid remove(long x) {\n\t\t\tint prev = count(x);\n\t\t\tif (prev == 1) {\n\t\t\t\tmap.remove(x);\n\t\t\t} else {\n\t\t\t\tmap.put(x, prev - 1);\n\t\t\t}\n\t\t}\n\n\t\tlong getMax() {\n\t\t\treturn map.lastKey();\n\t\t}\n\n\t\tlong getMin() {\n\t\t\treturn map.firstKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn map.toString();\n\t\t}\n\n\t\tboolean isEmpty() {\n\t\t\treturn map.isEmpty();\n\t\t}\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tls[i] = nextInt();\n\t\t\trs[i] = nextInt();\n\t\t}\n\n\t\tint[] minDiff = new int[n - 1];\n\t\tint[] maxDiff = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tminDiff[i] = ls[i] - rs[i + 1];\n\t\t\tmaxDiff[i] = rs[i] - ls[i + 1];\n\t\t}\n\n\t\tMultiTreeSet low = new MultiTreeSet();\n\t\tMultiTreeSet high = new MultiTreeSet();\n\n\t\tlow.add(0);\n\t\thigh.add(0);\n\n\t\tlong deltaLow = 0;\n\t\tlong deltaHigh = 0;\n\n\t\tlong valMin = 0;\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\n\t\t\tdeltaLow += minDiff[i];\n\t\t\tdeltaHigh += maxDiff[i];\n\n\t\t\tlong lowMax = low.getMax() + deltaLow;\n\t\t\tlong highMin = high.getMin() + deltaHigh;\n\n\t\t\tif (lowMax >= 0) {\n\t\t\t\tlow.add(-deltaLow);\n\t\t\t\tlow.add(-deltaLow);\n\n\t\t\t\tlong newLowMax = low.getMax() + deltaLow;\n\n\t\t\t\tlow.remove(newLowMax - deltaLow);\n\t\t\t\thigh.add(newLowMax - deltaHigh);\n\t\t\t} else {\n\t\t\t\thigh.add(-deltaHigh);\n\t\t\t\thigh.add(-deltaHigh);\n\n\t\t\t\tlong newHighMin = high.getMin() + deltaHigh;\n\n\t\t\t\thigh.remove(newHighMin - deltaHigh);\n\t\t\t\tlow.add(newHighMin - deltaLow);\n\t\t\t}\n\n\t\t\tif (lowMax > 0) {\n\t\t\t\tvalMin += lowMax;\n\t\t\t} else if (highMin < 0) {\n\t\t\t\tvalMin -= highMin;\n\t\t\t}\n\t\t}\n\n\t\tlong lowMax = low.getMax() + deltaLow;\n\t\tlong highMin = high.getMin() + deltaHigh;\n\n\t\tout.println(valMin);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] l = new int[N+1];\n\t\tint[] a = new int[N+1];\n\t\tl[0] = 0;\n\t\ta[0] = 1000;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tl[i+1] = sc.nextInt();\n\t\t\ta[i+1] = sc.nextInt()-l[i+1];\n\t\t}\n\n\t\tint[][] dp = new int[N+1][1000];\n\t\tfor(int i=0; i<N; i++)\n\t\t\tArrays.fill(dp[i+1], Integer.MAX_VALUE);\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<1000; j++) {\n\t\t\t\tfor(int k=0; k<1000; k++) {\n\t\t\t\t\tif(k<=j+a[i+1] && j<=k+a[i])\n\t\t\t\t\t\tdp[i+1][j] = Math.min(dp[i+1][j], dp[i][k] + Math.abs(j-l[i+1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i=0; i<1000; i++)\n\t\t\tmin = Math.min(min, dp[N][i]);\n\t\t\n\t\tSystem.out.println(min);\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n\n            if(lindex.ceiling(l[i]+lbase) != null){\n                lindex.add(l[i]+lbase);\n                long top = lindex.pollLast();\n                ans += Math.abs(top-(l[i]+lbase));\n                rindex.add(top-lbase - rbase);\n            }else if(rindex.floor(l[i]-rbase) != null){\n                rindex.add(l[i]-rbase);\n                long bot = rindex.pollFirst();\n                ans += Math.abs(bot-(l[i]-rbase));\n                lindex.add(bot+rbase+lbase);\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] co = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new int[]{ni(), ni()};\n\t\t}\n\t\tNode root = null;\n\t\troot = insert(root, 0, new Node(co[0][0]));\n\t\troot = insert(root, 0, new Node(co[0][0]));\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tadd(root, 0, i, -(co[i][1]-co[i][0]));\n\t\t\tadd(root, i, 2*i, (co[i-1][1]-co[i-1][0]));\n\t\t\tlong L = get(root, i-1).v;\n\t\t\tlong R = get(root, i).v;\n\t\t\tif(co[i][0] < L){\n\t\t\t\tret += L - co[i][0];\n\t\t\t}\n\t\t\tif(co[i][0] > R){\n\t\t\t\tret += co[i][0] - R;\n\t\t\t}\n\t\t\troot = insertb(root, new Node(co[i][0]));\n\t\t\troot = insertb(root, new Node(co[i][0]));\n//\t\t\ttr(toString(root, \"\"));\n//\t\t\ttr(ret);\n\t\t}\n\t\tout.println(ret);\n\t}\n\tpublic static Random gen = new Random();\n\t\n\tstatic public class Node\n\t{\n\t\tpublic long v; // value\n\t\tpublic long priority;\n\t\tpublic Node left, right, parent;\n\t\t\n\t\tpublic int count;\n\t\t\n\t\tpublic long add;\n\t\tpublic long sum;\n\t\t\n\t\tpublic Node(long v)\n\t\t{\n\t\t\tthis.v = v;\n\t\t\tpriority = gen.nextLong();\n\t\t\tupdate(this);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"Node [v=\");\n\t\t\tbuilder.append(v);\n\t\t\tbuilder.append(\", count=\");\n\t\t\tbuilder.append(count);\n\t\t\tbuilder.append(\", parent=\");\n\t\t\tbuilder.append(parent != null ? parent.v : \"null\");\n\t\t\tbuilder.append(\", add=\");\n\t\t\tbuilder.append(add);\n\t\t\tbuilder.append(\", sum=\");\n\t\t\tbuilder.append(sum);\n\t\t\tbuilder.append(\"]\");\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\tpublic static Node update(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.count = 1;\n\t\tif(a.left != null)a.count += a.left.count;\n\t\tif(a.right != null)a.count += a.right.count;\n\t\t\n\t\ta.sum = a.v + a.add * a.count;\n\t\tif(a.left != null)a.sum += a.left.sum;\n\t\tif(a.right != null)a.sum += a.right.sum;\n\t\treturn a;\n\t}\n\t\n\tpublic static Node disconnect(Node a)\n\t{\n\t\tif(a == null)return null;\n\t\ta.left = a.right = a.parent = null;\n\t\treturn update(a);\n\t}\n\t\n\tpublic static Node root(Node x)\n\t{\n\t\tif(x == null)return null;\n\t\twhile(x.parent != null)x = x.parent;\n\t\treturn x;\n\t}\n\t\n\tpublic static int count(Node a)\n\t{\n\t\treturn a == null ? 0 : a.count;\n\t}\n\t\n\tpublic static void setParent(Node a, Node par)\n\t{\n\t\tif(a != null)a.parent = par;\n\t}\n\t\n\tpublic static long sum(Node a, int L, int R)\n\t{\n\t\tif(a == null || L >= R || L >= count(a) || R <= 0)return 0L;\n\t\tif(L <= 0 && R >= count(a)){\n\t\t\treturn a.sum;\n\t\t}else{\n\t\t\tlong ret = 0;\n\t\t\tret += sum(a.left, L, R);\n\t\t\tret += sum(a.right, L-count(a.left)-1, R-count(a.left)-1);\n\t\t\tif(L <= count(a.left) && count(a.left) < R)ret += a.v;\n\t\t\tret += (Math.min(R, a.count) - L) * a.add;\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static void add(Node a, int L, int R, long V)\n\t{\n\t\tif(a == null || L >= R || L >= count(a) || R <= 0)return;\n\t\tif(L <= 0 && R >= count(a)){\n\t\t\ta.add += V;\n\t\t}else{\n\t\t\tadd(a.left, L, R, V);\n\t\t\tadd(a.right, L-count(a.left)-1, R-count(a.left)-1, V);\n\t\t\tif(L <= count(a.left) && count(a.left) < R)a.v += V;\n\t\t}\n\t\tupdate(a);\n\t}\n\t\n\tpublic static void fall(Node a)\n\t{\n\t\tif(a == null)return;\n\t\ta.v += a.add;\n\t\tif(a.left != null){\n\t\t\ta.left.add += a.add;\n\t\t\tupdate(a.left);\n\t\t}\n\t\tif(a.right != null){\n\t\t\ta.right.add += a.add;\n\t\t\tupdate(a.right);\n\t\t}\n\t\ta.add = 0;\n\t\tupdate(a);\n\t}\n\t\n\tpublic static Node merge(Node a, Node b)\n\t{\n\t\tif(b == null)return a;\n\t\tif(a == null)return b;\n\t\tif(a.priority > b.priority){\n\t\t\tfall(a);\n\t\t\tsetParent(a.right, null);\n\t\t\tsetParent(b, null);\n\t\t\ta.right = merge(a.right, b);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tfall(b);\n\t\t\tsetParent(a, null);\n\t\t\tsetParent(b.left, null);\n\t\t\tb.left = merge(a, b.left);\n\t\t\tsetParent(b.left, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\t// [0,K),[K,N)\n\tpublic static Node[] split(Node a, int K)\n\t{\n\t\tif(a == null)return new Node[]{null, null};\n\t\tfall(a);\n\t\tif(K <= count(a.left)){\n\t\t\tsetParent(a.left, null);\n\t\t\tNode[] s = split(a.left, K);\n\t\t\ta.left = s[1];\n\t\t\tsetParent(a.left, a);\n\t\t\ts[1] = update(a);\n\t\t\treturn s;\n\t\t}else{\n\t\t\tsetParent(a.right, null);\n\t\t\tNode[] s = split(a.right, K-count(a.left)-1);\n\t\t\ta.right = s[0];\n\t\t\tsetParent(a.right, a);\n\t\t\ts[0] = update(a);\n\t\t\treturn s;\n\t\t}\n\t}\n\t\n\tpublic static Node insert(Node a, int K, Node b)\n\t{\n\t\tif(a == null)return b;\n\t\tfall(a);\n\t\tif(b.priority < a.priority){\n\t\t\tif(K <= count(a.left)){\n\t\t\t\ta.left = insert(a.left, K, b);\n\t\t\t\tsetParent(a.left, a);\n\t\t\t}else{\n\t\t\t\ta.right = insert(a.right, K-count(a.left)-1, b);\n\t\t\t\tsetParent(a.right, a);\n\t\t\t}\n\t\t\treturn update(a);\n\t\t}else{\n\t\t\tNode[] ch = split(a, K);\n\t\t\tb.left = ch[0]; b.right = ch[1];\n\t\t\tsetParent(b.left, b);\n\t\t\tsetParent(b.right, b);\n\t\t\treturn update(b);\n\t\t}\n\t}\n\t\n\tpublic static Node insertb(Node root, Node x)\n\t{\n\t\tint ind = search(root, x.v);\n\t\tif(ind < 0){\n\t\t\t// insert\n\t\t\tind = -ind-1;\n\t\t}\n\t\treturn insert(root, ind, x);\n\t}\n\t\n\t// delete K-th\n\tpublic static Node erase(Node a, int K)\n\t{\n\t\tif(a == null)return null;\n\t\tif(K < count(a.left)){\n\t\t\ta.left = erase(a.left, K);\n\t\t\tsetParent(a.left, a);\n\t\t\treturn update(a);\n\t\t}else if(K == count(a.left)){\n\t\t\tfall(a);\n\t\t\tsetParent(a.left, null);\n\t\t\tsetParent(a.right, null);\n\t\t\tNode aa = merge(a.left, a.right);\n\t\t\tdisconnect(a);\n\t\t\treturn aa;\n\t\t}else{\n\t\t\ta.right = erase(a.right, K-count(a.left)-1);\n\t\t\tsetParent(a.right, a);\n\t\t\treturn update(a);\n\t\t}\n\t}\n\t\n\tpublic static Node get(Node a, int K)\n\t{\n\t\twhile(a != null){\n\t\t\tfall(a);\n\t\t\tif(K < count(a.left)){\n\t\t\t\ta = a.left;\n\t\t\t}else if(K == count(a.left)){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tK = K - count(a.left)-1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int search(Node a, long q)\n\t{\n\t\tint lcount = 0;\n\t\twhile(a != null){\n\t\t\tfall(a);\n\t\t\tif(a.v == q){\n\t\t\t\tlcount += count(a.left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q < a.v){\n\t\t\t\ta = a.left;\n\t\t\t}else{\n\t\t\t\tlcount += count(a.left) + 1;\n\t\t\t\ta = a.right;\n\t\t\t}\n\t\t}\n\t\treturn a == null ? -(lcount+1) : lcount;\n\t}\n\t\n\tpublic static int index(Node a)\n\t{\n\t\tif(a == null)return -1;\n\t\tint ind = count(a.left);\n\t\twhile(a != null){\n\t\t\tNode par = a.parent;\n\t\t\tif(par != null && par.right == a){\n\t\t\t\tind += count(par.left) + 1;\n\t\t\t}\n\t\t\ta = par;\n\t\t}\n\t\treturn ind;\n\t}\n\t\n\tpublic static Node[] nodes(Node a) { return nodes(a, new Node[count(a)], 0, count(a)); }\n\tpublic static Node[] nodes(Node a, Node[] ns, int L, int R)\n\t{\n\t\tif(a == null)return ns;\n\t\tnodes(a.left, ns, L, L+count(a.left));\n\t\tns[L+count(a.left)] = a;\n\t\tnodes(a.right, ns, R-count(a.right), R);\n\t\treturn ns;\n\t}\n\t\n\tpublic static String toString(Node a, String indent)\n\t{\n\t\tif(a == null)return \"\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(toString(a.left, indent + \"  \"));\n\t\tsb.append(indent).append(a).append(\"\\n\");\n\t\tsb.append(toString(a.right, indent + \"  \"));\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int N = 410;\n\t\t\tfinal long infinity = (long) 1e18;\n\t\t\tint n = in.nextInt();\n\t\t\tint[] l = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tl[i] = in.nextInt();\n\t\t\t\tr[i] = in.nextInt();\n\t\t\t}\n\t\t\tint[] sortedL = l.clone();\n\t\t\tArrays.sort(sortedL);\n\t\t\tint medL = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (l[i] == sortedL[n / 2]) {\n\t\t\t\t\tmedL = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] sortedR = r.clone();\n\t\t\tArrays.sort(sortedR);\n\t\t\tint medR = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (r[i] == sortedR[n / 2]) {\n\t\t\t\t\tmedR = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = infinity;\n\t\t\tans = Math.min(ans, calc(medL, n, l, r));\n\t\t\tans = Math.min(ans, calc(medR, n, l, r));\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calc(int med, int n, int[] l, int[] r) {\n\t\t\tlong res = 0;\n\t\t\tint[] nl = new int[med];\n\t\t\tint[] nr = new int[med];\n\t\t\tSystem.arraycopy(l, 0, nl, 0, nl.length);\n\t\t\tSystem.arraycopy(r, 0, nr, 0, nl.length);\n\t\t\treverse(nl);\n\t\t\treverse(nr);\n\t\t\tres += greedy(l[med], r[med] - l[med], nl, nr);\n\t\t\tnl = new int[n - med - 1];\n\t\t\tnr = new int[n - med - 1];\n\t\t\tSystem.arraycopy(l, med + 1, nl, 0, nl.length);\n\t\t\tSystem.arraycopy(r, med + 1, nr, 0, nl.length);\n\t\t\tres += greedy(l[med], r[med] - l[med], nl, nr);\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate void reverse(int[] a) {\n\t\t\tfor (int i = 0; i < a.length - i - 1; i++) {\n\t\t\t\tint j = a.length - i - 1;\n\t\t\t\tint t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t}\n\n\t\tprivate long greedy(long x1, long len1, int[] l, int[] r) {\n\t\t\tlong res = 0;\n\t\t\tfor (int i = 0; i < l.length; i++) {\n\t\t\t\tlong x2 = l[i];\n\t\t\t\tlong len2 = r[i] - l[i];\n\t\t\t\tlong L = Math.max(x1, x2);\n\t\t\t\tlong R = Math.min(x1 + len1, x2 + len2);\n\t\t\t\tif (L <= R) {\n\t\t\t\t\tx1 = x2;\n\t\t\t\t\tlen1 = len2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong nx2;\n\t\t\t\tif (x2 > x1 + len1) {\n\t\t\t\t\tnx2 = x1 + len1;\n\t\t\t\t} else {\n\t\t\t\t\tnx2 = x1 - len2;\n\t\t\t\t}\n\t\t\t\tres += Math.abs(x2 - nx2);\n\t\t\t\tx1 = nx2;\n\t\t\t\tlen1 = len2;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        //傾きが１ではなければ？\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n\n            if(lindex.ceiling(l[i]+lbase) != null){\n                lindex.add(l[i]+lbase);\n                long top = lindex.pollLast();\n                long next= lindex.last();\n                ans += Math.abs(top-next);\n                rindex.add(top-lbase - rbase);\n            }else if(rindex.floor(l[i]-rbase) != null){\n                rindex.add(l[i]-rbase);\n                long bot = rindex.pollFirst();\n                long next= rindex.first();\n                ans += Math.abs(bot-next);\n                lindex.add(bot+rbase+lbase);\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int N = 410;\n\t\t\tfinal long infinity = (long) 1e18;\n\t\t\tint n = in.nextInt();\n\t\t\tint[] l = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\tint[] len = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tl[i] = in.nextInt();\n\t\t\t\tr[i] = in.nextInt();\n\t\t\t\tlen[i] = r[i] - l[i];\n\t\t\t}\n\t\t\tint[] sortedL = l.clone();\n\t\t\tArrays.sort(sortedL);\n\t\t\tint medL = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (l[i] == sortedL[n / 2]) {\n\t\t\t\t\tmedL = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] sortedR = r.clone();\n\t\t\tArrays.sort(sortedR);\n\t\t\tint medR = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (r[i] == sortedR[n / 2]) {\n\t\t\t\t\tmedR = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] sortedLen = len.clone();\n\t\t\tArrays.sort(sortedLen);\n\t\t\tint medLen = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (len[i] == sortedLen[n / 2]) {\n\t\t\t\t\tmedLen = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = infinity;\n\t\t\tans = Math.min(ans, calc(medL, n, l, r));\n\t\t\tans = Math.min(ans, calc(medR, n, l, r));\n\t\t\tans = Math.min(ans, calc(medLen, n, l, r));\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate long calc(int med, int n, int[] l, int[] r) {\n\t\t\tlong res = 0;\n\t\t\tint[] nl = new int[med];\n\t\t\tint[] nr = new int[med];\n\t\t\tSystem.arraycopy(l, 0, nl, 0, nl.length);\n\t\t\tSystem.arraycopy(r, 0, nr, 0, nl.length);\n\t\t\treverse(nl);\n\t\t\treverse(nr);\n\t\t\tres += greedy(l[med], r[med] - l[med], nl, nr);\n\t\t\tnl = new int[n - med - 1];\n\t\t\tnr = new int[n - med - 1];\n\t\t\tSystem.arraycopy(l, med + 1, nl, 0, nl.length);\n\t\t\tSystem.arraycopy(r, med + 1, nr, 0, nl.length);\n\t\t\tres += greedy(l[med], r[med] - l[med], nl, nr);\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate void reverse(int[] a) {\n\t\t\tfor (int i = 0; i < a.length - i - 1; i++) {\n\t\t\t\tint j = a.length - i - 1;\n\t\t\t\tint t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t}\n\n\t\tprivate long greedy(long x1, long len1, int[] l, int[] r) {\n\t\t\tlong res = 0;\n\t\t\tfor (int i = 0; i < l.length; i++) {\n\t\t\t\tlong x2 = l[i];\n\t\t\t\tlong len2 = r[i] - l[i];\n\t\t\t\tlong L = Math.max(x1, x2);\n\t\t\t\tlong R = Math.min(x1 + len1, x2 + len2);\n\t\t\t\tif (L <= R) {\n\t\t\t\t\tx1 = x2;\n\t\t\t\t\tlen1 = len2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong nx2;\n\t\t\t\tif (x2 > x1 + len1) {\n\t\t\t\t\tnx2 = x1 + len1;\n\t\t\t\t} else {\n\t\t\t\t\tnx2 = x1 - len2;\n\t\t\t\t}\n\t\t\t\tres += Math.abs(x2 - nx2);\n\t\t\t\tx1 = nx2;\n\t\t\t\tlen1 = len2;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] x = new int[N];\n\t\tint[] a = new int[N];\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ta[i] = sc.nextInt()-x[i];\n\t\t}\n\n\t\tPriorityQueue<Long> lset = new PriorityQueue<>(new Comparator<Long>() {\n\t\t\tpublic int compare(Long l1, Long l2) {\n\t\t\t\treturn -Long.compare(l1, l2);\n\t\t\t}\n\t\t});\n\t\tlset.add((long)x[0]);\n\t\tlong ladd = 0;\n\t\t\n\t\tPriorityQueue<Long> rset = new PriorityQueue<>();\n\t\trset.add((long)x[0]);\n\t\tlong radd = 0;\n\t\t\n\t\tlong min = 0;\n\t\t\n\t\tfor(int i=1; i<N; i++) {\n\t\t\tladd -= a[i];\n\t\t\tradd += a[i-1];\n\t\t\tif(x[i] < lset.peek()+ladd) {\n\t\t\t\tmin = min + (lset.peek()+ladd - x[i]);\n\t\t\t\tlset.add(x[i]-ladd);\n\t\t\t\tlset.add(x[i]-ladd);\n\t\t\t\trset.add(lset.poll()+ladd-radd);\n\t\t\t} else if(rset.peek()+radd < x[i]) {\n\t\t\t\tmin = min + (x[i] - (rset.peek()+radd));\n\t\t\t\trset.add(x[i]-radd);\n\t\t\t\trset.add(x[i]-radd);\n\t\t\t\tlset.add(rset.poll()+radd-ladd);\n\t\t\t} else {\n\t\t\t\tlset.add(x[i]-ladd);\n\t\t\t\trset.add(x[i]-radd);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t\t\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/B3\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tint MAX = 400;\n\tpublic void solve() {\n\t\tint n = in.nextInt();\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = in.nextInt();\n\t\t\tr[i] = in.nextInt();\n\t\t}\n\t\tif (n > 400) return;\n\t\t\n\t\tlong res = Long.MAX_VALUE;\n\t\tfor (int x = 0; x <= MAX; x++) {\n\t\t\tlong cur = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (l[i] <= x && x <= r[i]) continue;\n\t\t\t\tif (l[i] > x)\n\t\t\t\t\tcur += l[i] - x;\n\t\t\t\telse\n\t\t\t\t\tcur += x - r[i];\n\t\t\t}\n\t\t\tres = Math.min(res, cur);\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO 自動生成された catch ブロック\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tfinal long max_r = Arrays.stream(rs).max().getAsLong();\n\t\tfinal long max_l = Arrays.stream(ls).max().getAsLong();\n\t\t\n\t\tif(N > 400 || max_r > 400 || max_l > 400){ throw new RuntimeException(); }\n\t\t\n\t\tlong answer = Long.MAX_VALUE;\n\t\tfor(int same_l = 0; same_l <= 400; same_l++){\n\t\t\tLOOP:\n\t\t\tfor(int same_r = same_l; same_r <= 400; same_r++){\n\t\t\t\tfinal long same_size = same_r - same_l;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlong curr_answer = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfinal long block_l = ls[i];\n\t\t\t\t\tfinal long block_r = rs[i];\n\t\t\t\t\tfinal long block_size = block_r - block_l;\n\t\t\t\t\t\n\t\t\t\t\tif(block_size < same_size){ continue LOOP; }\n\t\t\t\t\t\n\t\t\t\t\tif(block_l <= same_l && same_r <= block_r){ continue; }\n\t\t\t\t\t\n\t\t\t\t\tlong min_cost = Long.MAX_VALUE;\n\t\t\t\t\tmin_cost = Math.min(min_cost, Math.abs(block_l - same_l));\n\t\t\t\t\tmin_cost = Math.min(min_cost, Math.abs(block_r - same_r));\n\t\t\t\t\t\n\t\t\t\t\tcurr_answer += min_cost;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(same_l + \" \" + same_r + \" \" + curr_answer);\n\t\t\t\tanswer = Math.min(answer, curr_answer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = sc.nextInt();\n\t\t\tr[i] = sc.nextInt();\n\t\t}\n\n\t\tif (n > 400) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\n\t\tint[][] dp = new int[n][400 + 2];\n\t\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\tArrays.fill(dp[0], INF);\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tif (i >= l[0] && i <= r[0]) {\n\t\t\t\tdp[0][i] = 0;\n\t\t\t} else if (i < l[0]) {\n\t\t\t\tdp[0][i] = l[0] - i;\n\t\t\t} else {\n\t\t\t\tdp[0][i] = i - r[0];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t\tfor (int j = 1; j < l[i]; j++) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k <= Math.min(j + r[i] - l[i], 400); k++) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], l[i] - j + prev);\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);\n\t\t\t}\n\t\t\tfor (int j = 400; j > r[i]; j--) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k >= Math.max(j - (r[i] - l[i]), 1); k--) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], j - r[i] + prev);\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j + 1]);\n\t\t\t}\n\t\t\tint prev = INF;\n\t\t\tfor (int k = l[i]; k <= r[i]; k++) {\n\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t}\n\t\t\tfor (int j = l[i]; j <= r[i]; j++) {\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][l[i] - 1]);\n//\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][r[i] + 1]);\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], prev);\n\t\t\t}\n\n\t\t\tint[] tmp = dp[i].clone();\n\t\t\tfor (int j = 1; j <= 400; j++) {\n\t\t\t\tif (j < l[i]) {\n\t\t\t\t\tfor (int k = Math.max(1, j - (r[i] - l[i])); k < j; k++) {\n\t\t\t\t\t\ttmp[j] = Math.min(tmp[j], dp[i][k]);\n\t\t\t\t\t}\n\t\t\t\t} else if (j > r[i]) {\n\t\t\t\t\tfor (int k = j + 1; k <= Math.min(400, j + r[i] - l[i]); k++) {\n\t\t\t\t\t\ttmp[j] = Math.min(tmp[j], dp[i][k]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int k = Math.max(1, j - (r[i] - l[i])); k <= Math.min(400, j + r[i] - l[i]); k++) {\n\t\t\t\t\t\ttmp[j] = Math.min(tmp[j], dp[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[i] = tmp;\n\t\t}\n\n\t\tint ret = INF;\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tret = Math.min(ret, dp[n - 1][i]);\n\t\t}\n\n\t\tpr.println(ret);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tint[] l = new int[n];\n\t\tint[] r = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = sc.nextInt();\n\t\t\tr[i] = sc.nextInt();\n\t\t}\n\n\t\tif (n > 400) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\n\t\tint[][] dp = new int[n][400 + 2];\n\t\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\tArrays.fill(dp[0], INF);\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tif (i >= l[0] && i <= r[0]) {\n\t\t\t\tdp[0][i] = 0;\n\t\t\t} else if (i < l[0]) {\n\t\t\t\tdp[0][i] = l[0] - i;\n\t\t\t} else {\n\t\t\t\tdp[0][i] = i - r[0];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t\tfor (int j = 1; j < l[i]; j++) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k <= Math.min(j + r[i] - l[i], 400); k++) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], l[i] - j + prev);\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);\n\t\t\t}\n\t\t\tfor (int j = 400; j > r[i]; j--) {\n\t\t\t\tint prev = INF;\n\t\t\t\tfor (int k = j; k >= Math.max(j - (r[i] - l[i]), 0); k--) {\n\t\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], j - r[i] + prev);\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j + 1]);\n\t\t\t}\n\t\t\tint prev = INF;\n\t\t\tfor (int k = l[i]; k <= r[i]; k++) {\n\t\t\t\tprev = Math.min(prev, dp[i - 1][k]);\n\t\t\t}\n\t\t\tfor (int j = l[i]; j <= r[i]; j++) {\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][l[i] - 1]);\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][r[i] + 1]);\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], prev);\n\t\t\t}\n\t\t}\n\n\t\tint ret = INF;\n\t\tfor (int i = 1; i <= 400; i++) {\n\t\t\tret = Math.min(ret, dp[n - 1][i]);\n\t\t}\n\n\t\tpr.println(ret);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic class MultiTreeSet {\n\t\tprivate TreeMap<Long, Integer> map = new TreeMap<>();\n\n\t\tint count(long x) {\n\t\t\treturn map.getOrDefault(x, 0);\n\t\t}\n\n\t\tvoid add(long x) {\n\t\t\tmap.put(x, count(x) + 1);\n\t\t}\n\n\t\tvoid remove(long x) {\n\t\t\tint prev = count(x);\n\t\t\tif (prev == 1) {\n\t\t\t\tmap.remove(x);\n\t\t\t} else {\n\t\t\t\tmap.put(x, prev - 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong getMax() {\n\t\t\treturn map.lastKey();\n\t\t}\n\t\t\n\t\tlong getMin() {\n\t\t\treturn map.firstKey();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn map.toString();\n\t\t}\n\t\t\n\t\tboolean isEmpty() {\n\t\t\treturn map.isEmpty();\n\t\t}\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tls[i] = nextInt();\n\t\t\trs[i] = nextInt();\n\t\t}\n\n\t\tint[] minDiff = new int[n - 1];\n\t\tint[] maxDiff = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tminDiff[i] = ls[i] - rs[i + 1];\n\t\t\tmaxDiff[i] = rs[i] - ls[i + 1];\n\t\t}\n\t\t\n\t\tMultiTreeSet low = new MultiTreeSet();\n\t\tMultiTreeSet high = new MultiTreeSet();\n\t\t\n\t\tlow.add(0);\n\t\thigh.add(0);\n\t\t\n\t\tlong deltaLow = 0;\n\t\tlong deltaHigh = 0;\n\t\t\n\t\tlong valMin = 0;\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\n\t\t\tdeltaLow += minDiff[i];\n\t\t\tdeltaHigh += maxDiff[i];\n\t\t\t\n\t\t\tlong lowMax = low.getMax() + deltaLow;\n\t\t\tlong highMin = low.getMin() + deltaHigh;\n\t\t\t\n\t\t\tif (lowMax >= 0) {\n\t\t\t\tlow.add(-deltaLow);\n\t\t\t\tlow.add(-deltaLow);\n\t\t\t\t\n\t\t\t\tlong newLowMax = low.getMax() + deltaLow;\n\t\t\t\t\n\t\t\t\tlow.remove(newLowMax - deltaLow);\n\t\t\t\thigh.add(newLowMax - deltaHigh);\n\t\t\t} else {\n\t\t\t\thigh.add(-deltaHigh);\n\t\t\t\thigh.add(-deltaHigh);\n\t\t\t\t\n\t\t\t\tlong newHighMin = high.getMin() + deltaHigh;\n\t\t\t\t\n\t\t\t\thigh.remove(newHighMin - deltaHigh);\n\t\t\t\tlow.add(newHighMin - deltaLow);\n\t\t\t}\n\t\t\t\n\t\t\tif (lowMax > 0) {\n\t\t\t\tvalMin += lowMax;\n\t\t\t} else if (highMin < 0) {\n\t\t\t\tvalMin -= highMin;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong lowMax = low.getMax() + deltaLow;\n\t\tlong highMin = high.getMin() + deltaHigh;\n\t\t\n\t\tif (lowMax <= 0 && 0 <= highMin) {\n\t\t\tout.println(valMin);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong outp = valMin;\n\t\t\n\t\tif (lowMax > 0) {\n\t\t\twhile (!low.isEmpty()) {\n\t\t\t\tlong where = low.getMax() + deltaLow;\n\t\t\t\tif (where > 0) {\n\t\t\t\t\toutp += where;\n\t\t\t\t\tlow.remove(where - deltaLow);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (highMin < 0) {\n\t\t\twhile (!high.isEmpty()) {\n\t\t\t\tlong where = high.getMin() + deltaHigh;\n\t\t\t\tif (where < 0) {\n\t\t\t\t\toutp -= where;\n\t\t\t\t\thigh.remove(where - deltaHigh);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tout.println(\"dunno\");\n\t\tout.println(outp);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[][] co = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tco[i] = new int[]{ni(), ni()};\n\t\t}\n\t\t\n\t\tlong ret = 0;\n\t\tSimpleMinHeapL upper = new SimpleMinHeapL(n+1);\n\t\tSimpleMinHeapL lower = new SimpleMinHeapL(n+1);\n\t\tlong uoffset = 0;\n\t\tlong loffset = 0;\n\t\tupper.add(co[0][0]);\n\t\tlower.add(-co[0][0]);\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tloffset -= co[i][1]-co[i][0];\n\t\t\tuoffset += co[i][1]-co[i][0];\n\t\t\tlong L = -lower.min() + loffset;\n\t\t\tlong R = upper.min() + uoffset;\n\t\t\tif(co[i][0] < L){\n\t\t\t\tret += L - co[i][0];\n\t\t\t}\n\t\t\tif(co[i][0] > R){\n\t\t\t\tret += co[i][0] - R;\n\t\t\t}\n\t\t\tif(co[i][0] < L){\n\t\t\t\tlower.add(-(co[i][0]-loffset));\n\t\t\t\tlower.add(-(co[i][0]-loffset));\n\t\t\t\twhile(upper.size() != lower.size()){\n\t\t\t\t\tlong v = -lower.poll() + loffset;\n\t\t\t\t\tupper.add(v-uoffset);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tupper.add(co[i][0]-uoffset);\n\t\t\t\tupper.add(co[i][0]-uoffset);\n\t\t\t\twhile(upper.size() != lower.size()){\n\t\t\t\t\tlong v = upper.poll() + uoffset;\n\t\t\t\t\tlower.add(-(v-loffset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static class SimpleMinHeapL {\n\t\tpublic long[] a;\n\t\tpublic int n;\n\t\tpublic int pos;\n\t\tpublic static final long INF = Long.MAX_VALUE;\n\t\t\n\t\tpublic SimpleMinHeapL(int m)\n\t\t{\n\t\t\tn = m+1;\n\t\t\ta = new long[n];\n\t\t\tArrays.fill(a, INF);\n\t\t\tpos = 1;\n\t\t}\n\t\t\n\t\tpublic SimpleMinHeapL(long[] in)\n\t\t{\n\t\t\tn = in.length+1;\n\t\t\tif((n&1)==1)n++;\n\t\t\ta = new long[n];\n\t\t\tpos = 1+in.length;\n//\t\t\tArrays.fill(a, INF);\n\t\t\ta[0] = a[n-1] = a[n-2] = INF;\n\t\t\tSystem.arraycopy(in, 0, a, 1, in.length);\n\t\t\tfor(int t = pos/2-1;t >= 1;t--){\n\t\t\t\tfor(int c = t;2*c < pos;){\n\t\t\t\t\tint smaller = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;\n\t\t\t\t\tif(a[smaller] < a[c]){\n\t\t\t\t\t\tlong d = a[c]; a[c] = a[smaller]; a[smaller] = d;\n\t\t\t\t\t\tc = smaller;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void add(long x)\n\t\t{\n\t\t\ta[pos++] = x;\n\t\t\tfor(int c = pos-1, p = c>>>1;p >= 1 && a[c] < a[p];c>>>=1, p>>>=1){\n\t\t\t\tlong d = a[p]; a[p] = a[c]; a[c] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long poll()\n\t\t{\n\t\t\tif(pos == 1)return INF;\n\t\t\tpos--;\n\t\t\tlong ret = a[1];\n\t\t\ta[1] = a[pos];\n\t\t\ta[pos] = INF;\n\t\t\tfor(int c = 1;2*c < pos;){\n\t\t\t\tint smaller = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;\n\t\t\t\tif(a[smaller] < a[c]){\n\t\t\t\t\tlong d = a[c]; a[c] = a[smaller]; a[smaller] = d;\n\t\t\t\t\tc = smaller;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long min() { return a[1]; }\n\t\tpublic int size() { return pos-1; }\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n\n    static class Pair{\n        long index;\n        int cnt;\n        Pair(long index,int cnt){this.index=index;this.cnt=cnt;}\n    }\n\n    static void add(TreeSet<Pair> indexes, long ind){\n        Pair p = new Pair(ind, 1);\n        if(indexes.ceiling(p)==null || indexes.ceiling(p).index != ind){\n            indexes.add(p);\n        }else{\n            indexes.ceiling(p).cnt++;\n        }\n    }\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Pair> lindex = new TreeSet<>((a,b)->a.index-b.index<0 ? -1:a.index==b.index ? 0: 1);\n        TreeSet<Pair> rindex = new TreeSet<>((a,b)->b.index-a.index<0 ? -1:a.index==b.index ? 0: 1);\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(new Pair(l[0],1));rindex.add(new Pair(l[0],1));\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.last().index >= (l[i]+lbase)){\n                add(lindex, l[i]+lbase);\n                lindex.last().cnt--;\n                ans += Math.abs(lindex.last().index-(l[i]+lbase));\n                if(lindex.last().cnt==0){\n                    add(rindex, lindex.last().index-lbase-rbase);\n                    lindex.pollLast();\n                }\n            }else if(rindex.last().index <= (l[i]-rbase)){\n                add(rindex, l[i]-rbase);\n                rindex.last().cnt--;\n                ans += Math.abs(rindex.last().index-(l[i]-rbase));\n                if(rindex.last().cnt==0){\n                    add(lindex, rindex.last().index+lbase+rbase);\n                    rindex.pollLast();\n                }\n            }else{\n                add(lindex, l[i]+lbase);\n                add(rindex, l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int[][] p = ntable(n, 2);\n    \n    int[][] dp = new int[n][401];\n    for (int[] v : dp) Arrays.fill(v, Integer.MAX_VALUE / 2);\n\n    for (int x = 1; x <= 400; x ++) {\n      dp[0][x] = Math.abs(p[0][1] - x);\n    }\n    for (int i = 1; i < n; i ++) {\n      for (int x1 = 1; x1 <= 400; x1 ++) {\n        for (int x2 = 1; x2 <= 400; x2 ++) {\n          if (x2 - x1 <= p[i][1] - p[i][0] && x1 - x2 <= p[i - 1][1] - p[i - 1][0]) {\n            dp[i][x2] = Math.min(dp[i][x2], Math.abs(p[i - 1][1] - x2) + dp[i - 1][x1]);\n          }\n        }\n      }\n    }\n    int ret = Integer.MAX_VALUE;\n    for (int x = 1; x <= 400; x ++) {\n      ret = Math.min(ret, dp[n - 1][x]);\n    }\n    System.out.println(ret);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int N = 410;\n\t\t\tfinal long infinity = (long) 1e18;\n\t\t\tint n = in.nextInt();\n\t\t\tint[] l = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tl[i] = in.nextInt();\n\t\t\t\tr[i] = in.nextInt();\n\t\t\t}\n\t\t\tint[] sortedL = l.clone();\n\t\t\tArrays.sort(sortedL);\n\t\t\tint med = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (l[i] == sortedL[n / 2]) {\n\t\t\t\t\tmed = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tint[] nl = new int[med];\n\t\t\tint[] nr = new int[med];\n\t\t\tSystem.arraycopy(l, 0, nl, 0, nl.length);\n\t\t\tSystem.arraycopy(r, 0, nr, 0, nl.length);\n\t\t\treverse(nl);\n\t\t\treverse(nr);\n\t\t\tans += greedy(l[med], r[med] - l[med], nl, nr);\n\t\t\tnl = new int[n - med - 1];\n\t\t\tnr = new int[n - med - 1];\n\t\t\tSystem.arraycopy(l, med + 1, nl, 0, nl.length);\n\t\t\tSystem.arraycopy(r, med + 1, nr, 0, nl.length);\n\t\t\tans += greedy(l[med], r[med] - l[med], nl, nr);\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate void reverse(int[] a) {\n\t\t\tfor (int i = 0; i < a.length - i - 1; i++) {\n\t\t\t\tint j = a.length - i - 1;\n\t\t\t\tint t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t}\n\n\t\tprivate long greedy(long x1, long len1, int[] l, int[] r) {\n\t\t\tlong res = 0;\n\t\t\tfor (int i = 0; i < l.length; i++) {\n\t\t\t\tlong x2 = l[i];\n\t\t\t\tlong len2 = r[i] - l[i];\n\t\t\t\tlong L = Math.max(x1, x2);\n\t\t\t\tlong R = Math.min(x1 + len1, x2 + len2);\n\t\t\t\tif (L <= R) {\n\t\t\t\t\tx1 = x2;\n\t\t\t\t\tlen1 = len2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong nx2;\n\t\t\t\tif (x2 > x1 + len1) {\n\t\t\t\t\tnx2 = x1 + len1;\n\t\t\t\t} else {\n\t\t\t\t\tnx2 = x1 - len2;\n\t\t\t\t}\n\t\t\t\tres += Math.abs(x2 - nx2);\n\t\t\t\tx1 = nx2;\n\t\t\t\tlen1 = len2;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n\n    static void add(Map<Long, Integer> cnt, long index){\n        if(!cnt.containsKey(index))cnt.put(index, 0);\n        cnt.put(index, cnt.get(index)+1);\n    }\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        Map<Long,Integer> lcnt = new HashMap<>();\n        Map<Long, Integer> rcnt=new HashMap<>();\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        add(lcnt, l[0]);add(rcnt, l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n            if(lindex.ceiling(l[i]+lbase) != null){\n                lindex.add(l[i]+lbase);\n                add(lcnt, l[i]+lbase);\n                long top = lindex.last();\n                ans += Math.abs(top-(l[i]+lbase));\n                lcnt.put(top, lcnt.get(top)-1);\n                if(lcnt.get(top)==0){\n                    lindex.pollLast();\n                    rindex.add(top-lbase - rbase);\n                }\n            }else if(rindex.floor(l[i]-rbase) != null){\n                rindex.add(l[i]-rbase);\n                add(rcnt, l[i]-rbase);\n                long bot = rindex.first();\n                ans += Math.abs(bot-(l[i]-rbase));\n                rcnt.put(bot, rcnt.get(bot)-1);\n                if(rcnt.get(bot)==0){\n                    rindex.pollFirst();\n                    lindex.add(bot+rbase+lbase);\n                }\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n                add(lcnt, l[i]+lbase);\n                add(rcnt, l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long[][] lr = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            lr[i][0] = in.nextInt();\n            lr[i][1] = in.nextInt();\n        }\n\n        Hoge hoge = new Hoge(lr[0][0]);\n        for (int i = 1 ; i < n ; i++) {\n            hoge.left.addAll(-lr[i][1]+lr[i][0]);\n            hoge.right.addAll(lr[i-1][1]-lr[i-1][0]);\n\n            long L = hoge.getLeftMost();\n            long R = hoge.getRightMost();\n            if (L > R) {\n                throw new RuntimeException(\"L <= R must be hold\");\n            }\n\n            if (L < lr[i][0] && lr[i][0] < R) {\n                hoge.left.addPoint(lr[i][0]);\n                hoge.right.addPoint(lr[i][0]);\n            } else if (lr[i][0] <= L) {\n                hoge.left.addPoint(lr[i][0]);\n                hoge.left.addPoint(lr[i][0]);\n                hoge.right.addPoint(hoge.left.removePoint(L));\n                hoge.minValue += Math.abs(L - hoge.getLeftMost());\n            } else {\n                hoge.right.addPoint(lr[i][0]);\n                hoge.right.addPoint(lr[i][0]);\n                hoge.left.addPoint(hoge.right.removePoint(R));\n                hoge.minValue += Math.abs(R - hoge.getRightMost());\n            }\n        }\n\n        out.println(hoge.minValue);\n        out.flush();\n    }\n\n\n    static class Hoge {\n        Lines left = new Lines();\n        Lines right = new Lines();\n        long minValue = 0;\n\n        public Hoge(long x0) {\n            left.addPoint(x0);\n            right.addPoint(x0);\n        }\n\n        public long getLeftMost() {\n            return left.positions.lastKey() + left.addAll;\n        }\n\n        public long getRightMost() {\n            return right.positions.firstKey() + right.addAll;\n        }\n\n    }\n\n    static class Lines {\n        public TreeMap<Long, Integer> positions = new TreeMap<>();\n        public long addAll = 0;\n\n        public void addPoint(long x) {\n            long ax = x - addAll;\n            positions.put(ax, positions.getOrDefault(ax, 0)+1);\n        }\n\n        public long removePoint(long x) {\n            long ax = x - addAll;\n            if (!positions.containsKey(ax)) {\n                throw new RuntimeException(\"key not exists\");\n            }\n            if (positions.get(ax) == 1) {\n                positions.remove(ax);\n            } else {\n                positions.put(ax, positions.get(ax)-1);\n            }\n            return x;\n        }\n\n        public void addAll(long d) {\n            addAll += d;\n        }\n\n\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long[][] lr = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            lr[i][0] = in.nextInt();\n            lr[i][1] = in.nextInt();\n        }\n\n        Hoge hoge = new Hoge(lr[0][0]);\n        for (int i = 1 ; i < n ; i++) {\n            hoge.left.addAll(-lr[i][1]+lr[i][0]);\n            hoge.right.addAll(lr[i-1][1]-lr[i-1][0]);\n\n            long L = hoge.getLeftMost();\n            long R = hoge.getRightMost();\n            if (L > R) {\n                throw new RuntimeException(\"L <= R must be hold\");\n            }\n\n            if (L < lr[i][0] && lr[i][0] < R) {\n                hoge.left.addPoint(lr[i][0]);\n                hoge.right.addPoint(lr[i][0]);\n            } else if (lr[i][0] <= L) {\n                hoge.left.addPoint(lr[i][0]);\n                hoge.left.addPoint(lr[i][0]);\n                hoge.right.addPoint(hoge.left.removePoint(L));\n                hoge.minValue += Math.abs(L - lr[i][0]);\n            } else {\n                hoge.right.addPoint(lr[i][0]);\n                hoge.right.addPoint(lr[i][0]);\n                hoge.left.addPoint(hoge.right.removePoint(R));\n                hoge.minValue += Math.abs(R - lr[i][0]);\n            }\n        }\n\n        out.println(hoge.minValue);\n        out.flush();\n    }\n\n\n    static class Hoge {\n        Lines left = new Lines();\n        Lines right = new Lines();\n        long minValue = 0;\n\n        public Hoge(long x0) {\n            left.addPoint(x0);\n            right.addPoint(x0);\n        }\n\n        public long getLeftMost() {\n            return left.positions.lastKey() + left.addAll;\n        }\n\n        public long getRightMost() {\n            return right.positions.firstKey() + right.addAll;\n        }\n\n    }\n\n    static class Lines {\n        public TreeMap<Long, Integer> positions = new TreeMap<>();\n        public long addAll = 0;\n\n        public void addPoint(long x) {\n            long ax = x - addAll;\n            positions.put(ax, positions.getOrDefault(ax, 0)+1);\n        }\n\n        public long removePoint(long x) {\n            long ax = x - addAll;\n            if (!positions.containsKey(ax)) {\n                throw new RuntimeException(\"key not exists\");\n            }\n            if (positions.get(ax) == 1) {\n                positions.remove(ax);\n            } else {\n                positions.put(ax, positions.get(ax)-1);\n            }\n            return x;\n        }\n\n        public void addAll(long d) {\n            addAll += d;\n        }\n\n\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n  static final int INF = 1 << 29;\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    if (N >= 500) return;\n    int[] L = new int[N];\n    int[] R = new int[N];\n    for (int i = 0; i < N; i++) {\n      L[i] = sc.nextInt();\n      R[i] = sc.nextInt();\n    }\n    int[][] dp = new int[N][401];\n    for (int i = 0; i < N; i++) {\n      Arrays.fill(dp[i], INF);\n    }\n    for (int i = 1; i <= 400 - (R[0] - L[0]); i++) {\n      dp[0][i] = Math.abs(L[0] - i);\n    }\n    for (int i = 1; i < N; i++) {\n      for (int l = 1; l <= 400 - (R[i] - L[i]); l++) {\n        int r = l + R[i] - L[i];\n        for (int l2 = 1; l2 <= 400; l2++) {\n          if (dp[i - 1][l2] == INF) continue;\n          int r2 = l2 + R[i - 1] - L[i - 1];\n          if (r < l2 || r2 < l) continue;\n          dp[i][l] = Math.min(dp[i][l], dp[i - 1][l2] + Math.abs(L[i] - l));\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 1; i <= 400; i++) {\n      ans = Math.min(ans, dp[N - 1][i]);\n    }\n    System.out.println(ans);\n  }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        long lbase = 0;\n        long rbase = 0;\n        TreeSet<Long> lindex = new TreeSet<>();\n        TreeSet<Long> rindex = new TreeSet<>();\n        long[] l = new long[N];\n        long[] w = new long[N];\n        for(int i=0;i<N;++i){\n            l[i] = scan.nextLong();\n            w[i] = scan.nextLong()-l[i];\n        }\n        lindex.add(l[0]);rindex.add(l[0]);\n        long ans = 0;\n        for(int i=1;i<N;++i){\n            lbase += w[i];\n            rbase += w[i-1];\n\n            if(lindex.ceiling(l[i]+lbase) != null){\n                lindex.add(l[i]+lbase);\n                long top = lindex.last();\n                ans += Math.abs(top-(l[i]+lbase));\n                rindex.add(top-lbase - rbase);\n            }else if(rindex.floor(l[i]-rbase) != null){\n                rindex.add(l[i]-rbase);\n                long bot = rindex.first();\n                ans += Math.abs(bot-(l[i]-rbase));\n                lindex.add(bot+rbase+lbase);\n            }else{\n                lindex.add(l[i]+lbase);\n                rindex.add(l[i]-rbase);\n            }\n        }\n        System.out.println(ans);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tlong[] ls = new long[N];\n\t\tlong[] rs = new long[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tls[i] = sc.nextLong();\n\t\t\trs[i] = sc.nextLong();\n\t\t}\n\t\t\n\t\tfinal long max_r = Arrays.stream(rs).max().getAsLong();\n\t\tfinal long max_l = Arrays.stream(ls).max().getAsLong();\n\t\t\n\t\tif(N > 400 || max_r > 400 || max_l > 400){ throw new RuntimeException(); }\n\t\t\n\t\tlong answer = Long.MAX_VALUE;\n\t\tfor(int same_l = 0; same_l <= 400; same_l++){\n\t\t\tLOOP:\n\t\t\tfor(int same_r = same_l; same_r <= 400; same_r++){\n\t\t\t\tfinal long same_size = same_r - same_l;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tlong curr_answer = 0;\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfinal long block_l = ls[i];\n\t\t\t\t\tfinal long block_r = rs[i];\n\t\t\t\t\tfinal long block_size = block_r - block_l;\n\t\t\t\t\t\n\t\t\t\t\tif(block_size < same_size){ continue LOOP; }\n\t\t\t\t\t\n\t\t\t\t\tif(block_l <= same_l && same_r <= block_r){ continue; }\n\t\t\t\t\t\n\t\t\t\t\t//long min_cost = Long.MAX_VALUE;\n\t\t\t\t\t\n\t\t\t\t\tif(block_l > same_l){\n\t\t\t\t\t\tcurr_answer += (block_l - same_l);\n\t\t\t\t\t}else if(block_r < same_r){\n\t\t\t\t\t\tcurr_answer += (same_r - block_r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(same_l + \" \" + same_r + \" \" + curr_answer);\n\t\t\t\tanswer = Math.min(answer, curr_answer);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#pragma warning disable\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\nusing System.Collections;\nusing static System.Math;\n\nclass E { static void Main() => new J(); }\nclass J\n{\n\tint F() => int.Parse(Console.ReadLine());\n\tint[] G() => Console.ReadLine().Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToArray();\n\tpublic J()\n\t{\n\t\tvar N = F();\n\t\tvar l = new int[N];\n\t\tvar d = new int[N];\n\t\tfor (var i = 0; i <N;i++)\n\t\t{\n\t\t\tvar I = G();\n\t\t\tl[i] = I[0];\n\t\t\td[i] = I[1] - I[0];\n\t\t}\n\t\tvar left = new AVLTree<long> { l[0] };\n\t\tvar right = new AVLTree<long> { l[0] };\n\t\tvar tl = 0L;\n\t\tvar tr = 0L;\n\t\tvar h = 0L;\n\t\tfor (var i = 1; i < N; i++)\n\t\t{\n\t\t\ttl -= d[i];\n\t\t\ttr += d[i - 1];\n\t\t\tvar lm = left.MaxNode();\n\t\t\tvar rm = right.MinNode();\n\t\t\tif (l[i] <= lm.Item + tl)\n\t\t\t{\n\t\t\t\th += Abs(lm.Item + tl - l[i]);\n\t\t\t\tleft.Add(l[i] - tl);\n\t\t\t\tleft.Add(l[i] - tl);\n\t\t\t\tright.Add(lm.Item + tl - tr);\n\t\t\t\tleft.Remove(lm.Item, lm);\n\t\t\t}\n\t\t\telse if (l[i] >= rm.Item + tr)\n\t\t\t{\n\t\t\t\th += Abs(rm.Item + tr - l[i]);\n\t\t\t\tright.Add(l[i] - tr);\n\t\t\t\tright.Add(l[i] - tr);\n\t\t\t\tleft.Add(rm.Item + tr - tl);\n\t\t\t\tright.Remove(rm.Item, rm);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tleft.Add(l[i] - tl);\n\t\t\t\tright.Add(l[i] - tr);\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(h);\n\t}\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(ToComparison(comp)) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size => 1;\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tTuple<int, int>[] bs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tbs = sc.ReadManyLines<int, int>(N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar l = -10000000000000000L;\n\t\t\tvar r = 10000000000000000L;\n\t\t\twhile (r - l >= 10)\n\t\t\t{\n\t\t\t\tvar a = (l * 2 + r) / 3;\n\t\t\t\tvar b = (l + r * 2) / 3;\n\t\t\t\tif (Cost(a) > Cost(b)) l = a;\n\t\t\t\telse r = b;\n\t\t\t}\n\t\t\tvar m = Cost(l);\n\t\t\tfor (var p = l + 1; p <= r; p++) m = Min(m, Cost(p));\n\t\t\tpr.WriteLine(m);\n\t\t}\n\t\tlong Cost(long pos)\n\t\t{\n\t\t\tvar c = 0L;\n\t\t\tvar last = new Tuple<long, long>(pos, pos);\n\t\t\tforeach (var b in bs.Take(1))\n\t\t\t{\n\t\t\t\tlast = new Tuple<long, long>(pos, pos + b.Item2 - b.Item1);\n\t\t\t\tc += Math.Abs(b.Item1 - last.Item1);\n\t\t\t}\n\t\t\tforeach (var b in bs.Skip(1))\n\t\t\t{\n\t\t\t\tif (last.Item1 <= b.Item2 && b.Item1 <= last.Item2) last = new Tuple<long, long>(b.Item1, b.Item2);\n\t\t\t\telse if (last.Item2 < b.Item1) last = new Tuple<long, long>(last.Item2, last.Item2 + b.Item2 - b.Item1);\n\t\t\t\telse if (b.Item2 < last.Item1) last = new Tuple<long, long>(last.Item1 - b.Item2 + b.Item1, last.Item1);\n\t\t\t\telse throw new Exception();\n\t\t\t\tc += Math.Abs(b.Item1 - last.Item1);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass RangeSegmentTree\n\t{\n\t\tint N2;\n\t\tint[] seg, unif;\n\t\tpublic RangeSegmentTree(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new int[2 * N2 - 1];\n\t\t\tunif = new int[2 * N2 - 1];\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] == 0) return;\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1)\n\t\t\t{\n\t\t\t\tunif[2 * node + 1] += unif[node];\n\t\t\t\tunif[2 * node + 2] += unif[node];\n\t\t\t}\n\t\t\tunif[node] = 0;\n\t\t}\n\t\tvoid Update(int node) => seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n\t\tpublic void AddRange(int from, int to, int value) => AddRange(from, to, value, 0, 0, N2);\n\t\tvoid AddRange(int from, int to, int value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] += value;\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tAddRange(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tAddRange(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic int this[int n] { get { return Sum(n, n + 1); } set { AddRange(n, n + 1, value - this[n]); } }\n\t\tpublic int Sum(int from, int to) => Sum(from, to, 0, 0, N2);\n\t\tint Sum(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return 0;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Sum(from, to, 2 * node + 1, l, (l + r) >> 1) + Sum(from, to, 2 * node + 2, (l + r) >> 1, r);\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass Treap<T>\n{\n\tRandom rand;\n\tComparison<T> comp;\n\tclass Node\n\t{\n\t\tpublic T value;\n\t\tpublic int size;\n\t\tprivate int priority;\n\t\tpublic Node left, right;\n\t\tpublic Treap<T> treap;\n\t\tpublic Node(Treap<T> treap, T value) { this.treap = treap; this.value = value; priority = treap.rand.Next(); size = 1; }\n\t\tpublic Node Update() { size = 1 + Size(left) + Size(right); return this; }\n\t\tpublic static int Size(Node t) => t?.size ?? 0;\n\t\tpublic static Node Merge(Node l, Node r)\n\t\t{\n\t\t\tif (l == null) return r;\n\t\t\tif (r == null) return l;\n\t\t\tif (l.priority < r.priority)\n\t\t\t{\n\t\t\t\tl.right = Merge(l.right, r);\n\t\t\t\treturn l.Update();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.left = Merge(r.left, l);\n\t\t\t\treturn r.Update();\n\t\t\t}\n\t\t}\n\t\t// [0,N) => [0,k) + [k,N)\n\t\tpublic static Tuple<Node, Node> Split(Node t, int k)\n\t\t{\n\t\t\tif (t == null) return new Tuple<Node, Node>(null, null);\n\t\t\tif (k <= Size(t.left))\n\t\t\t{\n\t\t\t\tvar s = Split(t.left, k);\n\t\t\t\tt.left = s.Item2;\n\t\t\t\treturn new Tuple<Node, Node>(s.Item1, t.Update());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar s = Split(t.right, k - Size(t.left) - 1);\n\t\t\t\tt.right = s.Item1;\n\t\t\t\treturn new Tuple<Node, Node>(t.Update(), s.Item2);\n\t\t\t}\n\t\t}\n\t\t// [0,k) + [k,N) => [0,k) + (new node) + [k+1,N)\n\t\tpublic static Node Insert(Node t, int k, T val)\n\t\t{\n\t\t\tvar n = new Node(t.treap, val);\n\t\t\tvar s = Split(t, k);\n\t\t\treturn Merge(Merge(s.Item1, n), s.Item2);\n\t\t}\n\t\t// [0,k) + k + [k+1,N) => [0,k) + [k+1,N)\n\t\tpublic static Node Erase(Node t, int k)\n\t\t{\n\t\t\tvar s1 = Split(t, k + 1);\n\t\t\tvar s2 = Split(s1.Item1, k);\n\t\t\treturn Merge(s2.Item1, s1.Item2);\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\nclass MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) => keys.Contains(item) ? mult[item] : 0;\n\tpublic int this[T item]\n\t{\n\t\tget { return Multiplicity(item); }\n\t\tset\n\t\t{\n\t\t\tDebug.Assert(value >= 0);\n\t\t\tif (value == 0) { if (keys.Contains(item)) Remove(item); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tCount += value - mult[item];\n\t\t\t\tmult[item] = value;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) => Add(item, 1);\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) => keys.Overlaps(other);\n\tpublic bool IsSupersetOf(IEnumerable<T> other) => keys.IsSupersetOf(other);\n\tpublic bool IsSubsetOf(IEnumerable<T> other) => keys.IsSubsetOf(other);\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) => keys.IsProperSubsetOf(other);\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) => keys.IsProperSupersetOf(other);\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) => CopyTo(array, 0);\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) => keys.Contains(item);\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic T Max => keys.Max;\n\tpublic T Min => keys.Min;\n\tpublic bool IsReadOnly => false;\n}\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tvar size = 0;\n\t\t\tvar time = 0m;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> Comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; Comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || Comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || Comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || Comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || Comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || Comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || Comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => Comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => Comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && Comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.Comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.Comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.Comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() => Value.ToString();\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n))) { 2 };\n\t\tvar composites = new bool[m];\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tvar s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / Stopwatch.Frequency;\n\t}\n\tpublic static double MeasureTime2(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--) dp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tmemo.MemberSet(Inf);\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (var i = n - 1; i >= 0; i--)\n\t\t\tfor (var j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length >= 2) QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (var i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tvar j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void GenRandAll()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; var p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid PeriodCertification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { GenRandAll(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        int[] l = new int[N];\n        int[] r = new int[N];\n        for(int i=0;i<N;i++){\n            string[] str = Console.ReadLine().Split(' ');\n            l[i] = int.Parse(str[0]);\n            r[i] = int.Parse(str[1]);\n        }\n        AbsoluteSum Ab = new AbsoluteSum(N);\n        Ab.Add(l[0]);\n        for(int i=1;i<N;i++){\n            Ab.Min(l[i]-r[i],r[i-1]-l[i-1]);\n            Ab.Add(l[i]);\n        }\n        sb.Append(Ab.GetMin()+\"\\n\");\n    }\n}\nclass AbsoluteSum{\n    long minValue;\n    Heap Lheap;\n    long LS;\n    Heap Rheap;\n    long RS;\n    public AbsoluteSum(int maxsize){\n        minValue = 0;\n        Lheap = new Heap(maxsize*2,false);\n        Rheap = new Heap(maxsize*2,true);\n        LS = 0;\n        RS = 0;\n    }\n    public void Add(long X){\n        if(Lheap.size != 0 && Lheap.Get() + LS >= X){\n            minValue += Lheap.Get() + LS - X;\n            Rheap.push(Lheap.pop() + LS - RS);\n            Lheap.push(X-LS);\n            Lheap.push(X-LS);\n        }\n        else if(Rheap.size != 0 && Rheap.Get() + RS <= X){\n            minValue += X - Rheap.Get() - RS;\n            Lheap.push(Rheap.pop() + RS - LS);\n            Rheap.push(X-RS);\n            Rheap.push(X-RS);\n        }\n        else{\n            Lheap.push(X-LS);\n            Rheap.push(X-RS);\n        }\n    }\n    public void Min(long a,long b){\n        LS += a;\n        RS += b;\n    }\n    public long GetMin(){\n        return minValue;\n    }\n}\nclass Heap{\n    public int size;\n    long[] obj;\n    bool B;\n    public Heap(int maxsize,bool b0){\n        size = 0;\n        B = b0;\n        obj = new long[maxsize];\n    }\n    //小さい順ならa<=b\n    public bool Compare(long a,long b){\n        return (B && a<=b) || (!B && a>=b);\n    }\n    public void push(long a){\n        int i = size;\n        size++;\n        while(i > 0){\n            int p = (i - 1)/2;\n            if(Compare(obj[p],a)){\n                obj[i] = a;\n                break;\n            }\n            obj[i] = obj[p];\n            i = p;\n        }\n        if(i == 0){\n            obj[0] = a;\n        }\n    }\n    public long pop(){\n        long t = obj[0];\n        int i = 0;\n        size--;\n        while(2*i+1 < size){\n            int p = 2*i+1;\n            if(p+1 < size && Compare(obj[p+1],obj[p])){\n                p++;\n            }\n            if(Compare(obj[p],obj[size])){\n                obj[i] = obj[p];\n                i = p;\n            }\n            else{\n                obj[i] = obj[size];\n                break;\n            }\n        }\n        if(2*i+1 >= size){\n            obj[i] = obj[size];\n        }\n        return t;\n    }\n    public long Get(){\n        return obj[0];\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\n\nnamespace ConsoleApplication1.AtCoder_Regular_Contest_070\n{\n    class NarrowRectangles\n    {\n        static void Main(string[] args)\n        {\n            // N   number of rectangles\n            string input = Console.ReadLine();\n            int N = int.Parse(input);\n\n            int[][] allRectangles = new int[N][]; // create an array for holding values of N rectangles\n\n            // read all the input rectangles\n            for (int i = 0; i < N; i++)\n            {\n                string[] input2 = Console.ReadLine().Split(' ');\n                int l_i = int.Parse(input2[0]);\n                int r_i = int.Parse(input2[1]);\n\n                int lengthRect_i = Math.Abs(r_i - l_i);\n\n                // there is nothing we can assume about l_i < r_i , so better check\n                if (l_i <= r_i)\n                {\n                    allRectangles[i] = new int[] { l_i, r_i, lengthRect_i };\n                }\n                else\n                {\n                    allRectangles[i] = new int[] { r_i, l_i, lengthRect_i };\n                }\n                \n            }\n\n\n            int lengthtotalRect = 0;\n\n            // 2 length of curr rect\n            // 1 r_i end pos\n            // 0 l_i start pos\n\n            for (int i = 0; i < allRectangles.Length; i++)\n            {\n                lengthtotalRect += allRectangles[i][2]; // \n            }\n\n           \n            int cumMoveSum = 0;\n\n            if (N > 1)\n            {\n                // sort according to the start positions\n                Array.Sort(allRectangles[0], allRectangles);\n\n                for (int i = 0; i < allRectangles.Length - 1; i++)\n                {\n                    var currentRect = allRectangles[i];\n                    var nextRect = allRectangles[i + 1];\n\n\n                    if (currentRect[0] <= nextRect[0])\n                    {\n\n                        if ((currentRect[0] + currentRect[2]) >= nextRect[0]) { cumMoveSum += 0; }\n                        if ((currentRect[0] + currentRect[2]) < nextRect[0]) { cumMoveSum += (Math.Abs(nextRect[0] - (currentRect[0] + currentRect[2]))); }\n\n                    }\n                    else\n                    {\n                        if ((nextRect[0] + nextRect[2]) >= currentRect[0]) { { cumMoveSum += 0; } }\n                        if ((nextRect[0] + nextRect[2]) < currentRect[0]) { { cumMoveSum += (Math.Abs(currentRect[0] - (nextRect[0] + nextRect[2]))); } }\n                    }\n\n\n                }\n\n                \n\n            }\n\n            Console.WriteLine(cumMoveSum);\n\n\n\n\n\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size => 1;\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tTuple<int, int>[] bs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tbs = sc.ReadManyLines<int, int>(N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar l = new int[N];\n\t\t\tvar d = new int[N];\n\t\t\tfor (var i = 0; i < N; i++) { l[i] = bs[i].Item1; d[i] = bs[i].Item2 - bs[i].Item1; }\n\t\t\tvar left = new AVLTree<long>();\n\t\t\tvar right = new AVLTree<long>();\n\t\t\tvar tl = 0L;\n\t\t\tvar tr = 0L;\n\t\t\tvar h = 0L;\n\t\t\tleft.Add(l[0]);\n\t\t\tright.Add(l[0]);\n\t\t\tfor (var i = 1; i < N; i++)\n\t\t\t{\n\t\t\t\ttl -= d[i];\n\t\t\t\ttr += d[i - 1];\n\t\t\t\tvar lm = left.MaxNode();\n\t\t\t\tvar rm = right.MinNode();\n\t\t\t\tif (l[i] <= lm.Item + tl)\n\t\t\t\t{\n\t\t\t\t\th += Math.Abs(lm.Item + tl - l[i]);\n\t\t\t\t\tleft.Add(l[i] - tl);\n\t\t\t\t\tleft.Add(l[i] - tl);\n\t\t\t\t\tright.Add(lm.Item + tl - tr);\n\t\t\t\t\tleft.Remove(lm.Item, lm);\n\t\t\t\t}\n\t\t\t\telse if (l[i] >= rm.Item + tr)\n\t\t\t\t{\n\t\t\t\t\th += Math.Abs(rm.Item + tr - l[i]);\n\t\t\t\t\tright.Add(l[i] - tr);\n\t\t\t\t\tright.Add(l[i] - tr);\n\t\t\t\t\tleft.Add(rm.Item + tr - tl);\n\t\t\t\t\tright.Remove(rm.Item, rm);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleft.Add(l[i] - tl);\n\t\t\t\t\tright.Add(l[i] - tr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr.WriteLine(h);\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass RangeSegmentTree\n\t{\n\t\tint N2;\n\t\tint[] seg, unif;\n\t\tpublic RangeSegmentTree(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new int[2 * N2 - 1];\n\t\t\tunif = new int[2 * N2 - 1];\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] == 0) return;\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1)\n\t\t\t{\n\t\t\t\tunif[2 * node + 1] += unif[node];\n\t\t\t\tunif[2 * node + 2] += unif[node];\n\t\t\t}\n\t\t\tunif[node] = 0;\n\t\t}\n\t\tvoid Update(int node) => seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n\t\tpublic void AddRange(int from, int to, int value) => AddRange(from, to, value, 0, 0, N2);\n\t\tvoid AddRange(int from, int to, int value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] += value;\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tAddRange(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tAddRange(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic int this[int n] { get { return Sum(n, n + 1); } set { AddRange(n, n + 1, value - this[n]); } }\n\t\tpublic int Sum(int from, int to) => Sum(from, to, 0, 0, N2);\n\t\tint Sum(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return 0;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Sum(from, to, 2 * node + 1, l, (l + r) >> 1) + Sum(from, to, 2 * node + 2, (l + r) >> 1, r);\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass Treap<T>\n{\n\tRandom rand;\n\tComparison<T> comp;\n\tclass Node\n\t{\n\t\tpublic T value;\n\t\tpublic int size;\n\t\tprivate int priority;\n\t\tpublic Node left, right;\n\t\tpublic Treap<T> treap;\n\t\tpublic Node(Treap<T> treap, T value) { this.treap = treap; this.value = value; priority = treap.rand.Next(); size = 1; }\n\t\tpublic Node Update() { size = 1 + Size(left) + Size(right); return this; }\n\t\tpublic static int Size(Node t) => t?.size ?? 0;\n\t\tpublic static Node Merge(Node l, Node r)\n\t\t{\n\t\t\tif (l == null) return r;\n\t\t\tif (r == null) return l;\n\t\t\tif (l.priority < r.priority)\n\t\t\t{\n\t\t\t\tl.right = Merge(l.right, r);\n\t\t\t\treturn l.Update();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.left = Merge(r.left, l);\n\t\t\t\treturn r.Update();\n\t\t\t}\n\t\t}\n\t\t// [0,N) => [0,k) + [k,N)\n\t\tpublic static Tuple<Node, Node> Split(Node t, int k)\n\t\t{\n\t\t\tif (t == null) return new Tuple<Node, Node>(null, null);\n\t\t\tif (k <= Size(t.left))\n\t\t\t{\n\t\t\t\tvar s = Split(t.left, k);\n\t\t\t\tt.left = s.Item2;\n\t\t\t\treturn new Tuple<Node, Node>(s.Item1, t.Update());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar s = Split(t.right, k - Size(t.left) - 1);\n\t\t\t\tt.right = s.Item1;\n\t\t\t\treturn new Tuple<Node, Node>(t.Update(), s.Item2);\n\t\t\t}\n\t\t}\n\t\t// [0,k) + [k,N) => [0,k) + (new node) + [k+1,N)\n\t\tpublic static Node Insert(Node t, int k, T val)\n\t\t{\n\t\t\tvar n = new Node(t.treap, val);\n\t\t\tvar s = Split(t, k);\n\t\t\treturn Merge(Merge(s.Item1, n), s.Item2);\n\t\t}\n\t\t// [0,k) + k + [k+1,N) => [0,k) + [k+1,N)\n\t\tpublic static Node Erase(Node t, int k)\n\t\t{\n\t\t\tvar s1 = Split(t, k + 1);\n\t\t\tvar s2 = Split(s1.Item1, k);\n\t\t\treturn Merge(s2.Item1, s1.Item2);\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\nclass MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) => keys.Contains(item) ? mult[item] : 0;\n\tpublic int this[T item]\n\t{\n\t\tget { return Multiplicity(item); }\n\t\tset\n\t\t{\n\t\t\tDebug.Assert(value >= 0);\n\t\t\tif (value == 0) { if (keys.Contains(item)) Remove(item); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tCount += value - mult[item];\n\t\t\t\tmult[item] = value;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) => Add(item, 1);\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) => keys.Overlaps(other);\n\tpublic bool IsSupersetOf(IEnumerable<T> other) => keys.IsSupersetOf(other);\n\tpublic bool IsSubsetOf(IEnumerable<T> other) => keys.IsSubsetOf(other);\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) => keys.IsProperSubsetOf(other);\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) => keys.IsProperSupersetOf(other);\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) => CopyTo(array, 0);\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) => keys.Contains(item);\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic T Max => keys.Max;\n\tpublic T Min => keys.Min;\n\tpublic bool IsReadOnly => false;\n}\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tvar size = 0;\n\t\t\tvar time = 0m;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> Comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; Comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || Comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || Comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || Comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || Comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || Comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || Comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => Comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => Comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && Comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.Comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.Comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.Comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() => Value.ToString();\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n))) { 2 };\n\t\tvar composites = new bool[m];\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tvar s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / Stopwatch.Frequency;\n\t}\n\tpublic static double MeasureTime2(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--) dp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tmemo.MemberSet(Inf);\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (var i = n - 1; i >= 0; i--)\n\t\t\tfor (var j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length >= 2) QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (var i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tvar j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void GenRandAll()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; var p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid PeriodCertification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { GenRandAll(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\n// (づ°ω°)づﾐe★゜・。。・゜゜・。。・゜☆゜・。。・゜゜・。。・゜\npublic class Solver\n{\n    const int MAX = 400;\n\n    public void Solve()\n    {\n        int n = ReadInt();\n        var a = ReadIntMatrix(n);\n\n        var dp = Enumerable.Repeat(int.MaxValue, MAX + 1).ToArray();\n        for (int i = 0; i + a[0][1] - a[0][0] <= MAX; i++)\n            dp[i] = Math.Abs(i - a[0][0]);\n\n        for (int i = 1; i < n; i++)\n        {\n            var ndp = Enumerable.Repeat(int.MaxValue, MAX + 1).ToArray();\n            for (int j = 0; j + a[i][1] - a[i][0] <= MAX; j++)\n                for (int k = 0; k + a[i - 1][1] - a[i - 1][0] <= MAX; k++)\n                    if (k >= j && k <= j + a[i][1] - a[i][0] || k + a[i - 1][1] - a[i - 1][0] >= j && k + a[i - 1][1] - a[i - 1][0] <= j + a[i][1] - a[i][0])\n                        ndp[j] = Math.Min(ndp[j], dp[k] + Math.Abs(j - a[i][0]));\n            dp = ndp;\n        }\n\n        Write(dp.Min());\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        //reader = new StreamReader(\"input.txt\");\n        //writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            //var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            //thread.Start();\n            //thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n \nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    \n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n \n    int N;\n    void Solve()\n    {\n       N = cin.Nextint;\n       //各長方形にくっつけてみる\n       var L = new int[N];\n       var R = new int[N];\n       for (int i = 0; i < N; i++)\n       {\n           L[i] = cin.Nextint;\n           R[i] = cin.Nextint;\n       }\n       long ans = long.MaxValue;\n       \n       for (int i = 0; i < N; i++)\n       {\n           long x = 0;\n           int l = L[i], r = R[i];\n           for (int j = i - 1; j >= 0; j--)\n           {\n               if(R[j] < l || r < L[j])\n               {\n                   if (R[j] < l)\n                   {\n                       x+=l-R[j];\n                       r = l;\n                       l = r - (R[j] - L[j]); \n                   }\n                   else \n                   {\n                       x+=L[j] - r;\n                       l= r;\n                       r = l + (R[j] - L[j]);\n                   }\n               }\n               else \n               {\n                   r = R[j];\n                   l = L[j];\n               }\n                //WriteLine($\"j={j} r={r} l={l}\");\n           }\n           l = L[i]; r = R[i];\n           for (int j = i + 1; j < N; j++)\n           {\n               if(R[j] < l || r < L[j])\n               {\n                   if (R[j] < l)\n                   {\n                       x+=l-R[j];\n                       r = l;\n                       l = r - (R[j] - L[j]); \n                   }\n                   else \n                   {\n                       x+=L[j] - r;\n                       l=r;\n                       r = l + (R[j] - L[j]);\n                   }\n               }\n               else \n               {\n                   r = R[j];\n                   l = L[j];\n               }\n               //WriteLine($\"j={j} r={r} l={l}\");\n           }\n\n           ans = Math.Min(ans, x);\n           //WriteLine($\"x={x} i={i}\");\n       }\n       WriteLine(ans);\n    }\n \n}\n \nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\n// (づ°ω°)づﾐe★゜・。。・゜゜・。。・゜☆゜・。。・゜゜・。。・゜\npublic class Solver\n{\n    const int MAX = 400;\n\n    bool Check(int l1, int r1, int l2, int r2)\n    {\n        return l1 >= l2 && l1 <= r2 || r1 >= l2 && r1 <= r2 || l2 >= l1 && l2 <= r1 || r2 >= l1 && r2 <= r1;\n    }\n\n    public void Solve()\n    {\n        int n = ReadInt();\n        var a = ReadIntMatrix(n);\n        if (n > MAX || a.Max(aa => aa.Max()) > 400)\n            throw new Exception();\n\n        var dp = Enumerable.Repeat(int.MaxValue, MAX + 1).ToArray();\n        for (int i = 0; i + a[0][1] - a[0][0] <= MAX; i++)\n            dp[i] = Math.Abs(i - a[0][0]);\n\n        for (int i = 1; i < n; i++)\n        {\n            var ndp = Enumerable.Repeat(int.MaxValue, MAX + 1).ToArray();\n            for (int j = 0; j + a[i][1] - a[i][0] <= MAX; j++)\n                for (int k = 0; k + a[i - 1][1] - a[i - 1][0] <= MAX; k++)\n                    if (Check(j, j + a[i][1] - a[i][0], k, k + a[i - 1][1] - a[i - 1][0]))\n                        ndp[j] = Math.Min(ndp[j], dp[k] + Math.Abs(j - a[i][0]));\n            dp = ndp;\n        }\n\n        Write(dp.Min());\n    }\n\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n        reader = new StreamReader(Console.OpenStandardInput());\n        writer = new StreamWriter(Console.OpenStandardOutput());\n        //reader = new StreamReader(\"input.txt\");\n        //writer = new StreamWriter(\"output.txt\");\n#endif\n        try\n        {\n            new Solver().Solve();\n            //var thread = new Thread(new Solver().Solve, 1024 * 1024 * 128);\n            //thread.Start();\n            //thread.Join();\n        }\n        catch (Exception ex)\n        {\n#if DEBUG\n            Console.WriteLine(ex);\n#else\n            throw;\n#endif\n        }\n        reader.Close();\n        writer.Close();\n    }\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken() { while (currentLineTokens.Count == 0)currentLineTokens = new Queue<string>(ReadAndSplitLine()); return currentLineTokens.Dequeue(); }\n    public static int ReadInt() { return int.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(int.Parse).ToArray(); }\n    public static long[] ReadLongArray() { return ReadAndSplitLine().Select(long.Parse).ToArray(); }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++)matrix[i] = ReadIntArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++)ret[i][j] = matrix[j][i]; } return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++)lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void WriteArray<T>(IEnumerable<T> array) { writer.WriteLine(string.Join(\" \", array)); }\n    public static void Write(params object[] array) { WriteArray(array); }\n    public static void WriteLines<T>(IEnumerable<T> array) { foreach (var a in array)writer.WriteLine(a); }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++)ret[i] = new T(); return ret; }\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Boolean;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var L = new int[n + 1];\n            var R = new int[n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                L[i + 1] = sc.Integer();\n                R[i + 1] = sc.Integer();\n            }\n            if (n > 400 || R.Max() > 400) return;\n            var dp = new int[420];\n            for (int i = 1; i <= n + 1; i++)\n            {\n                if (i == n + 1) break;\n                var next = Enumerate(420, x => 1 << 30);\n                for (int pos = 0; pos < 420; pos++)\n                {\n                    for (int to = 0; to < 420; to++)\n                    {\n                        if (pos <= to && to <= pos + R[i - 1] - L[i - 1])\n                        {\n\n                            var dx = Math.Abs(L[i] - to);\n                            next[to] = Math.Min(next[to], dp[pos] + dx);\n                        }\n                        if (to <= pos && pos <= to + R[i] - L[i])\n                        {\n                            var dx = Math.Abs(L[i] - to);\n                            next[to] = Math.Min(next[to], dp[pos] + dx);\n                        }\n\n                    }\n                }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp.Min());\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        int[] l = new int[N];\n        int[] r = new int[N];\n        for(int i=0;i<N;i++){\n            string[] str = Console.ReadLine().Split(' ');\n            l[i] = int.Parse(str[0]);\n            r[i] = int.Parse(str[1]);\n        }\n        long[,] DP = new long[N,400];\n        for(int i=0;i<400;i++){\n            DP[0,i] = Math.Max(i-l[0],l[0]-i);\n        }\n        for(int i=1;i<N;i++){\n            for(int j=0;j<400;j++){\n                long min = 10000000000000;\n                for(int k=Math.Max(0,j-(r[i-1]-l[i-1]));k<=Math.Min(399,j+(r[i]-l[i]));k++){\n                    min = Math.Min(min,DP[i-1,k]);\n                }\n                DP[i,j] = min + Math.Max(j-l[i],l[i]-j);\n            }\n        }\n        {\n            long min = 10000000000000;\n            for(int j=0;j<400;j++){\n                min = Math.Min(DP[N-1,j],min);\n            }\n            sb.Append(min+\"\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Boolean;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var L = new int[n + 1];\n            var R = new int[n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                L[i] = sc.Integer();\n                R[i] = sc.Integer();\n            }\n            if (n > 400 || R.Max() > 400) return;\n            var dp = new int[420];\n            for (int i = 0; i < n; i++)\n            {\n                var next = Enumerate(420, x => 1 << 30);\n                for (int p = 0; p < 420; p++)\n                    for (int j = 0; j < 420; j++)\n                    {\n                        var lp = p;\n                        var rp = lp + R[i] - L[i];\n\n                        var lq = L[i];\n                        var rq = R[i];\n                        var dx = Math.Min(Math.Abs(j - lp), Math.Abs(j - rp));\n                        var dy = Math.Min(Math.Abs(j - lq), Math.Abs(j - rq));\n                        next[j] = Math.Min(next[j], dp[p] + dx + dy);\n                        if(lq<=lp&&lp<=rq)\n                            next[j] = Math.Min(next[j], dp[p]);\n                    }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp.Min());\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Boolean;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var L = new int[n + 1];\n            var R = new int[n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                L[i + 1] = sc.Integer();\n                R[i + 1] = sc.Integer();\n            }\n            if (n > 400 || R.Max() > 400) return;\n            var dp = new int[420];\n            for (int i = 1; i <= n + 1; i++)\n            {\n                for (int j = 1; j < 420; j++)\n                    dp[j] = Math.Min(dp[j], dp[j - 1] + 1);\n                for (int j = 420 - 2; j >= 0; j--)\n                    dp[j] = Math.Min(dp[j], dp[j + 1] + 1);\n                if (i == n + 1) break;\n                var next = Enumerate(420, x => 1 << 30);\n                for (int pos = 0; pos < 420; pos++)\n                {\n                    for (int to = 0; to < 420; to++)\n                    {\n                        if (pos <= to && to <= pos + R[i - 1] - L[i - 1])\n                        {\n\n                            var dx = Math.Abs(L[i] - to);\n                            next[to] = Math.Min(next[to], dp[pos] + dx);\n                        }\n                        if (pos <= to + R[i] - L[i] && to + R[i] - L[i] <= pos + R[i - 1] - L[i - 1])\n                        {\n                            var dx = Math.Abs(L[i] - to);\n                            next[to] = Math.Min(next[to], dp[pos] + dx);\n                        }\n                    }\n                }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp.Min());\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Boolean;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var L = new int[n + 1];\n            var R = new int[n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                L[i] = sc.Integer();\n                R[i] = sc.Integer();\n            }\n            if (n > 400 || R.Max() > 400) return;\n            var dp = new int[500];\n            for (int i = 0; i < n; i++)\n            {\n                var next = Enumerate(500, x => 1 << 30);\n                for (int p = 0; p < 500; p++)\n                    for (int j = 0; j < 500; j++)\n                    {\n                        var lp = p;\n                        var rp = lp + R[i] - L[i];\n\n                        var lq = L[i];\n                        var rq = R[i];\n                        var dx = Math.Min(Math.Abs(j - lp), Math.Abs(j - rp));\n                        var dy = Math.Min(Math.Abs(j - lq), Math.Abs(j - rq));\n                        next[j] = Math.Min(next[j], dp[p] + dx + dy);\n                    }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp.Min());\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nclass Solver\n{\n    static Scanner cin;\n    public Solver() {}\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Solver().solve();\n        return 0;\n    }\n \n    public void solve()\n    {\n        int n;\n        n = cin.nextInt();\n        long[] l, r, mid, width;\n        l = new long[n];\n        r = new long[n];\n        mid = new long[n];\n        width = new long[n];\n        for (int i = 0; i < n; ++i) {\n            l[i] = cin.nextLong();\n            r[i] = cin.nextLong();\n            l[i] *= 2;\n            r[i] *= 2;\n            width[i] = r[i] - l[i];\n            mid[i] = (r[i] + l[i]) / 2;\n        }\n        long leftOffset, rightOffset;\n        leftOffset = rightOffset = 0;\n        long minValue = 0;\n        \n        var left = new PriorityQueue<long>();\n        var right = new PriorityQueue<long>((long x, long y) => x > y);\n        \n        left.Push(mid[0]);\n        right.Push(mid[0]);\n        \n        for (int i = 1; i < n; ++i) {\n            long myWidth = (width[i] + width[i-1]) / 2;\n            leftOffset -= myWidth;\n            rightOffset += myWidth;\n            long maxLeft = left.Top();\n            long minRight = right.Top();\n            \n            if (maxLeft + leftOffset <= mid[i] && mid[i] <= minRight + rightOffset) {\n                left.Push(mid[i] - leftOffset);\n                right.Push(mid[i] - rightOffset);\n            } else {\n                if (mid[i] < maxLeft + leftOffset) {\n                    minValue += maxLeft + leftOffset - mid[i];\n                    \n                    right.Push(maxLeft + leftOffset - rightOffset);\n                    left.Pop();\n                    left.Push(mid[i] - leftOffset);\n                    left.Push(mid[i] - leftOffset);\n                } else {\n                    minValue += mid[i] - (minRight + rightOffset);\n                    \n                    left.Push(minRight + rightOffset - leftOffset);\n                    right.Pop();\n                    right.Push(mid[i] - rightOffset);\n                    right.Push(mid[i] - rightOffset);\n                }\n            }\n        }\n        \n        Console.WriteLine(minValue / 2);\n    }\n}\n\nclass PriorityQueue<T> where T: IComparable, new()\n{\n    private List<T> _heap;\n    private Func<T, T, bool> _compare;\n    \n    public PriorityQueue(Func<T, T, bool> compare)\n    {\n        this.Init();\n        _compare = compare;\n    }\n    \n    public PriorityQueue()\n    {\n        this.Init();\n        this._compare = (T x, T y) => x.CompareTo(y) < 0;\n    }\n    \n    public void Init()\n    {\n        _heap = new List<T>();\n        _heap.Add(new T());\n    }\n    \n    public void Push(T x)\n    {\n        _heap.Add(x);\n        for (int i = _heap.Count - 1; i > 1; i /= 2) {\n            if (_compare(_heap[i], _heap[i / 2])) {\n                return;\n            } else {\n                T _tmp = _heap[i];\n                _heap[i] = _heap[i / 2];\n                _heap[i / 2] = _tmp;\n            }\n        }\n    }\n    \n    public void Pop()\n    {\n        int _size = _heap.Count - 1;\n        _heap[1] = _heap[_size];\n        _heap.RemoveAt(_size);\n        _size -= 1;\n        for (int i = 1; ;) {\n            int j = 2 * i;\n            int k = 2 * i + 1;\n            if (j > _size) {\n                return;\n            }\n            if (k > _size) {\n                if (_compare(_heap[j], _heap[i])) {\n                    return;\n                }\n                Swap(_heap[i], _heap[j]);\n                i = j;\n            }\n            if (_compare(_heap[j], _heap[i]) && _compare(_heap[k], _heap[i])) {\n                return;\n            }\n            if (_compare(_heap[j], _heap[k])) {\n                Swap(_heap[i], _heap[k]);\n                i = k;\n            } else {\n                Swap(_heap[i], _heap[j]);\n                i = j;\n            }\n        }\n    }\n    \n    public T Top()\n    {\n        if (this.IsEmpty())\n        {\n            throw new InvalidOperationException(\"A priority queue is empty.\");\n        }\n        return _heap[1];\n    }\n    \n    public int GetSize()\n    {\n        return _heap.Count - 1;\n    }\n    \n    public bool IsEmpty()\n    {\n        return this.GetSize() == 0;\n    }\n    \n    public void Swap(T x, T y)\n    {\n        \n        T tmp = x;\n        x = y;\n        y = tmp;\n    }\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n \n    char[] cs = new char[] { ' ' };\n \n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n \n    public string next()\n    {\n        while (i >= s.Length)\n        {\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n        }\n        return s[i++];\n    }\n \n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n \n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n \n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size => 1;\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tTuple<int, int>[] bs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tbs = sc.ReadManyLines<int, int>(N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar l = -1000000000000000L;\n\t\t\tvar r = 1000000000000000L;\n\t\t\twhile (r - l >= 10)\n\t\t\t{\n\t\t\t\tvar a = (l * 2 + r) / 3;\n\t\t\t\tvar b = (l + r * 2) / 3;\n\t\t\t\tif (Cost(a) > Cost(b)) l = a;\n\t\t\t\telse r = b;\n\t\t\t}\n\t\t\tvar m = Cost(l);\n\t\t\tfor (var p = l + 1; p <= r; p++) m = Min(m, Cost(p));\n\t\t\tpr.WriteLine(m);\n\t\t}\n\t\tlong Cost(long pos)\n\t\t{\n\t\t\tvar c = 0L;\n\t\t\tvar last = new Tuple<long, long>(pos, pos);\n\t\t\tforeach (var b in bs)\n\t\t\t{\n\t\t\t\tif (last.Item1 <= b.Item2 && b.Item1 <= last.Item2) last = new Tuple<long, long>(b.Item1, b.Item2);\n\t\t\t\telse if (last.Item2 < b.Item1) last = new Tuple<long, long>(last.Item2, last.Item2 + b.Item2 - b.Item1);\n\t\t\t\telse if (b.Item2 < last.Item1) last = new Tuple<long, long>(last.Item1 - b.Item2 + b.Item1, last.Item1);\n\t\t\t\telse throw new Exception();\n\t\t\t\tc += Math.Abs(b.Item1 - last.Item1);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass RangeSegmentTree\n\t{\n\t\tint N2;\n\t\tint[] seg, unif;\n\t\tpublic RangeSegmentTree(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new int[2 * N2 - 1];\n\t\t\tunif = new int[2 * N2 - 1];\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] == 0) return;\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1)\n\t\t\t{\n\t\t\t\tunif[2 * node + 1] += unif[node];\n\t\t\t\tunif[2 * node + 2] += unif[node];\n\t\t\t}\n\t\t\tunif[node] = 0;\n\t\t}\n\t\tvoid Update(int node) => seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n\t\tpublic void AddRange(int from, int to, int value) => AddRange(from, to, value, 0, 0, N2);\n\t\tvoid AddRange(int from, int to, int value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] += value;\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tAddRange(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tAddRange(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic int this[int n] { get { return Sum(n, n + 1); } set { AddRange(n, n + 1, value - this[n]); } }\n\t\tpublic int Sum(int from, int to) => Sum(from, to, 0, 0, N2);\n\t\tint Sum(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return 0;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Sum(from, to, 2 * node + 1, l, (l + r) >> 1) + Sum(from, to, 2 * node + 2, (l + r) >> 1, r);\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass Treap<T>\n{\n\tRandom rand;\n\tComparison<T> comp;\n\tclass Node\n\t{\n\t\tpublic T value;\n\t\tpublic int size;\n\t\tprivate int priority;\n\t\tpublic Node left, right;\n\t\tpublic Treap<T> treap;\n\t\tpublic Node(Treap<T> treap, T value) { this.treap = treap; this.value = value; priority = treap.rand.Next(); size = 1; }\n\t\tpublic Node Update() { size = 1 + Size(left) + Size(right); return this; }\n\t\tpublic static int Size(Node t) => t?.size ?? 0;\n\t\tpublic static Node Merge(Node l, Node r)\n\t\t{\n\t\t\tif (l == null) return r;\n\t\t\tif (r == null) return l;\n\t\t\tif (l.priority < r.priority)\n\t\t\t{\n\t\t\t\tl.right = Merge(l.right, r);\n\t\t\t\treturn l.Update();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.left = Merge(r.left, l);\n\t\t\t\treturn r.Update();\n\t\t\t}\n\t\t}\n\t\t// [0,N) => [0,k) + [k,N)\n\t\tpublic static Tuple<Node, Node> Split(Node t, int k)\n\t\t{\n\t\t\tif (t == null) return new Tuple<Node, Node>(null, null);\n\t\t\tif (k <= Size(t.left))\n\t\t\t{\n\t\t\t\tvar s = Split(t.left, k);\n\t\t\t\tt.left = s.Item2;\n\t\t\t\treturn new Tuple<Node, Node>(s.Item1, t.Update());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar s = Split(t.right, k - Size(t.left) - 1);\n\t\t\t\tt.right = s.Item1;\n\t\t\t\treturn new Tuple<Node, Node>(t.Update(), s.Item2);\n\t\t\t}\n\t\t}\n\t\t// [0,k) + [k,N) => [0,k) + (new node) + [k+1,N)\n\t\tpublic static Node Insert(Node t, int k, T val)\n\t\t{\n\t\t\tvar n = new Node(t.treap, val);\n\t\t\tvar s = Split(t, k);\n\t\t\treturn Merge(Merge(s.Item1, n), s.Item2);\n\t\t}\n\t\t// [0,k) + k + [k+1,N) => [0,k) + [k+1,N)\n\t\tpublic static Node Erase(Node t, int k)\n\t\t{\n\t\t\tvar s1 = Split(t, k + 1);\n\t\t\tvar s2 = Split(s1.Item1, k);\n\t\t\treturn Merge(s2.Item1, s1.Item2);\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\nclass MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) => keys.Contains(item) ? mult[item] : 0;\n\tpublic int this[T item]\n\t{\n\t\tget { return Multiplicity(item); }\n\t\tset\n\t\t{\n\t\t\tDebug.Assert(value >= 0);\n\t\t\tif (value == 0) { if (keys.Contains(item)) Remove(item); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tCount += value - mult[item];\n\t\t\t\tmult[item] = value;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) => Add(item, 1);\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) => keys.Overlaps(other);\n\tpublic bool IsSupersetOf(IEnumerable<T> other) => keys.IsSupersetOf(other);\n\tpublic bool IsSubsetOf(IEnumerable<T> other) => keys.IsSubsetOf(other);\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) => keys.IsProperSubsetOf(other);\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) => keys.IsProperSupersetOf(other);\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) => CopyTo(array, 0);\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) => keys.Contains(item);\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic T Max => keys.Max;\n\tpublic T Min => keys.Min;\n\tpublic bool IsReadOnly => false;\n}\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tvar size = 0;\n\t\t\tvar time = 0m;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> Comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; Comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || Comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || Comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || Comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || Comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || Comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || Comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => Comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => Comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && Comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.Comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.Comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.Comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() => Value.ToString();\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n))) { 2 };\n\t\tvar composites = new bool[m];\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tvar s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / Stopwatch.Frequency;\n\t}\n\tpublic static double MeasureTime2(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--) dp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tmemo.MemberSet(Inf);\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (var i = n - 1; i >= 0; i--)\n\t\t\tfor (var j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length >= 2) QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (var i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tvar j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void GenRandAll()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; var p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid PeriodCertification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { GenRandAll(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size => 1;\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tTuple<int, int>[] bs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tbs = sc.ReadManyLines<int, int>(N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar l = new int[N];\n\t\t\tvar d = new int[N];\n\t\t\tfor (var i = 0; i < N; i++) { l[i] = bs[i].Item1; d[i] = bs[i].Item2 - bs[i].Item1; }\n\t\t\tif (N >= 500 || l.Max() >= 450) throw new Exception();\n\t\t\tvar dp = new long[500];\n\t\t\tfor (var i = 0; i < 500; i++) dp[i] = Math.Abs(l[0] - i);\n\t\t\tfor (var i = 1; i < N; i++)\n\t\t\t{\n\t\t\t\tvar n = new long[500];\n\t\t\t\tfor (var x = 0; x < 500; x++)\n\t\t\t\t{\n\t\t\t\t\tn[x] = InfL;\n\t\t\t\t\tfor (var y = Max(0, x - d[i - 1]); y <= Min(499, x + d[i]); y++) n[x] = Min(n[x], dp[y]);\n\t\t\t\t\tn[x] += Math.Abs(l[i] - x);\n\t\t\t\t}\n\t\t\t\tdp = n;\n\t\t\t}\n\t\t\tpr.WriteLine(dp.Min());\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass RangeSegmentTree\n\t{\n\t\tint N2;\n\t\tint[] seg, unif;\n\t\tpublic RangeSegmentTree(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new int[2 * N2 - 1];\n\t\t\tunif = new int[2 * N2 - 1];\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] == 0) return;\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1)\n\t\t\t{\n\t\t\t\tunif[2 * node + 1] += unif[node];\n\t\t\t\tunif[2 * node + 2] += unif[node];\n\t\t\t}\n\t\t\tunif[node] = 0;\n\t\t}\n\t\tvoid Update(int node) => seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n\t\tpublic void AddRange(int from, int to, int value) => AddRange(from, to, value, 0, 0, N2);\n\t\tvoid AddRange(int from, int to, int value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] += value;\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tAddRange(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tAddRange(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic int this[int n] { get { return Sum(n, n + 1); } set { AddRange(n, n + 1, value - this[n]); } }\n\t\tpublic int Sum(int from, int to) => Sum(from, to, 0, 0, N2);\n\t\tint Sum(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return 0;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Sum(from, to, 2 * node + 1, l, (l + r) >> 1) + Sum(from, to, 2 * node + 2, (l + r) >> 1, r);\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass Treap<T>\n{\n\tRandom rand;\n\tComparison<T> comp;\n\tclass Node\n\t{\n\t\tpublic T value;\n\t\tpublic int size;\n\t\tprivate int priority;\n\t\tpublic Node left, right;\n\t\tpublic Treap<T> treap;\n\t\tpublic Node(Treap<T> treap, T value) { this.treap = treap; this.value = value; priority = treap.rand.Next(); size = 1; }\n\t\tpublic Node Update() { size = 1 + Size(left) + Size(right); return this; }\n\t\tpublic static int Size(Node t) => t?.size ?? 0;\n\t\tpublic static Node Merge(Node l, Node r)\n\t\t{\n\t\t\tif (l == null) return r;\n\t\t\tif (r == null) return l;\n\t\t\tif (l.priority < r.priority)\n\t\t\t{\n\t\t\t\tl.right = Merge(l.right, r);\n\t\t\t\treturn l.Update();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.left = Merge(r.left, l);\n\t\t\t\treturn r.Update();\n\t\t\t}\n\t\t}\n\t\t// [0,N) => [0,k) + [k,N)\n\t\tpublic static Tuple<Node, Node> Split(Node t, int k)\n\t\t{\n\t\t\tif (t == null) return new Tuple<Node, Node>(null, null);\n\t\t\tif (k <= Size(t.left))\n\t\t\t{\n\t\t\t\tvar s = Split(t.left, k);\n\t\t\t\tt.left = s.Item2;\n\t\t\t\treturn new Tuple<Node, Node>(s.Item1, t.Update());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar s = Split(t.right, k - Size(t.left) - 1);\n\t\t\t\tt.right = s.Item1;\n\t\t\t\treturn new Tuple<Node, Node>(t.Update(), s.Item2);\n\t\t\t}\n\t\t}\n\t\t// [0,k) + [k,N) => [0,k) + (new node) + [k+1,N)\n\t\tpublic static Node Insert(Node t, int k, T val)\n\t\t{\n\t\t\tvar n = new Node(t.treap, val);\n\t\t\tvar s = Split(t, k);\n\t\t\treturn Merge(Merge(s.Item1, n), s.Item2);\n\t\t}\n\t\t// [0,k) + k + [k+1,N) => [0,k) + [k+1,N)\n\t\tpublic static Node Erase(Node t, int k)\n\t\t{\n\t\t\tvar s1 = Split(t, k + 1);\n\t\t\tvar s2 = Split(s1.Item1, k);\n\t\t\treturn Merge(s2.Item1, s1.Item2);\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\nclass MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) => keys.Contains(item) ? mult[item] : 0;\n\tpublic int this[T item]\n\t{\n\t\tget { return Multiplicity(item); }\n\t\tset\n\t\t{\n\t\t\tDebug.Assert(value >= 0);\n\t\t\tif (value == 0) { if (keys.Contains(item)) Remove(item); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tCount += value - mult[item];\n\t\t\t\tmult[item] = value;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) => Add(item, 1);\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) => keys.Overlaps(other);\n\tpublic bool IsSupersetOf(IEnumerable<T> other) => keys.IsSupersetOf(other);\n\tpublic bool IsSubsetOf(IEnumerable<T> other) => keys.IsSubsetOf(other);\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) => keys.IsProperSubsetOf(other);\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) => keys.IsProperSupersetOf(other);\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) => CopyTo(array, 0);\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) => keys.Contains(item);\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic T Max => keys.Max;\n\tpublic T Min => keys.Min;\n\tpublic bool IsReadOnly => false;\n}\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tvar size = 0;\n\t\t\tvar time = 0m;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> Comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; Comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || Comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || Comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || Comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || Comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || Comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || Comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => Comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => Comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && Comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.Comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.Comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.Comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() => Value.ToString();\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n))) { 2 };\n\t\tvar composites = new bool[m];\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tvar s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / Stopwatch.Frequency;\n\t}\n\tpublic static double MeasureTime2(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--) dp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tmemo.MemberSet(Inf);\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (var i = n - 1; i >= 0; i--)\n\t\t\tfor (var j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length >= 2) QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (var i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tvar j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void GenRandAll()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; var p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid PeriodCertification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { GenRandAll(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nclass Solver\n{\n    static Scanner cin;\n    public Solver() {}\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Solver().solve();\n        return 0;\n    }\n \n    public void solve()\n    {\n        int n;\n        n = cin.nextInt();\n        long[] l, r, mid, width;\n        l = new long[n];\n        r = new long[n];\n        mid = new long[n];\n        width = new long[n];\n        for (int i = 0; i < n; ++i) {\n            l[i] = cin.nextLong();\n            r[i] = cin.nextLong();\n            l[i] *= 2;\n            r[i] *= 2;\n            width[i] = r[i] - l[i];\n            mid[i] = (r[i] + l[i]) / 2;\n        }\n        long leftOffset, rightOffset;\n        leftOffset = rightOffset = 0;\n        long minValue = 0;\n        \n        var left = new PriorityQueue<long>();\n        var right = new PriorityQueue<long>((long x, long y) => x > y);\n        \n        left.Push(mid[0]);\n        right.Push(mid[0]);\n        \n        for (int i = 1; i < n; ++i) {\n            long myWidth = (width[i] + width[i-1]) / 2;\n            leftOffset -= myWidth;\n            rightOffset += myWidth;\n            long maxLeft = left.Top();\n            long minRight = right.Top();\n            \n            if (maxLeft + leftOffset <= mid[i] && mid[i] <= minRight + rightOffset) {\n                left.Push(mid[i] - leftOffset);\n                right.Push(mid[i] - rightOffset);\n            } else {\n                if (mid[i] < maxLeft + leftOffset) {\n                    minValue += maxLeft + leftOffset - mid[i];\n                    \n                    right.Push(maxLeft + leftOffset - rightOffset);\n                    left.Pop();\n                    left.Push(mid[i] - leftOffset);\n                    left.Push(mid[i] - leftOffset);\n                } else {\n                    minValue += mid[i] - (minRight + rightOffset);\n                    \n                    left.Push(minRight + rightOffset - leftOffset);\n                    right.Pop();\n                    right.Push(mid[i] - rightOffset);\n                    right.Push(mid[i] - rightOffset);\n                }\n            }\n        }\n        \n        Console.WriteLine(minValue / 2);\n    }\n}\n\nclass PriorityQueue<T> where T: IComparable, new()\n{\n    private List<T> _heap;\n    private Func<T, T, bool> _compare;\n    \n    public PriorityQueue(Func<T, T, bool> compare)\n    {\n        this.Init();\n        _compare = compare;\n    }\n    \n    public PriorityQueue()\n    {\n        this.Init();\n        this._compare = (T x, T y) => x.CompareTo(y) < 0;\n    }\n    \n    public void Init()\n    {\n        _heap = new List<T>();\n        _heap.Add(new T());\n    }\n    \n    public void Push(T x)\n    {\n        _heap.Add(x);\n        for (int i = _heap.Count - 1; i > 1; i /= 2) {\n            if (_compare(_heap[i], _heap[i / 2])) {\n                return;\n            } else {\n                Swap(_heap, i, i / 2);\n            }\n        }\n    }\n    \n    public void Pop()\n    {\n        int _size = _heap.Count - 1;\n        _heap[1] = _heap[_size];\n        _heap.RemoveAt(_size);\n        _size -= 1;\n        for (int i = 1; ;) {\n            int j = 2 * i;\n            int k = 2 * i + 1;\n            if (j > _size) {\n                return;\n            }\n            if (k > _size) {\n                if (_compare(_heap[j], _heap[i])) {\n                    return;\n                }\n                Swap(_heap, i, j);\n                i = j;\n            }\n            if (_compare(_heap[j], _heap[i]) && _compare(_heap[k], _heap[i])) {\n                return;\n            }\n            if (_compare(_heap[j], _heap[k])) {\n                Swap(_heap, i, k);\n                i = k;\n            } else {\n                Swap(_heap, i, j);\n                i = j;\n            }\n        }\n    }\n    \n    public T Top()\n    {\n        if (this.IsEmpty())\n        {\n            throw new InvalidOperationException(\"A priority queue is empty.\");\n        }\n        return _heap[1];\n    }\n    \n    public int GetSize()\n    {\n        return _heap.Count - 1;\n    }\n    \n    public bool IsEmpty()\n    {\n        return this.GetSize() == 0;\n    }\n    \n    public void Swap(ref T x, ref T y)\n    {\n        \n        T tmp = x;\n        x = y;\n        y = tmp;\n    }\n    \n    public void Swap(List<T> list, int indexA, int indexB)\n    {\n        \n        T tmp = list[indexA];\n        list[indexA] = list[indexB];\n        list[indexB] = tmp;\n    }\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n \n    char[] cs = new char[] { ' ' };\n \n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n \n    public string next()\n    {\n        while (i >= s.Length)\n        {\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n        }\n        return s[i++];\n    }\n \n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n \n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n \n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Boolean;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var L = new int[n + 1];\n            var R = new int[n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                L[i] = sc.Integer();\n                R[i] = sc.Integer();\n            }\n            if (n > 400 || R.Max() > 400) return;\n            var dp = new int[420];\n            for (int i = 0; i < n; i++)\n            {\n                var next = Enumerate(420, x => 1 << 30);\n                for (int p = 0; p < 420; p++)\n                    for (int j = 0; j < 420; j++)\n                    {\n                        var lp = p;\n                        var rp = lp + R[i] - L[i];\n\n                        var lq = L[i];\n                        var rq = R[i];\n                        var dx = Math.Min(Math.Abs(j - lp), Math.Abs(j - rp));\n                        var dy = Math.Min(Math.Abs(j - lq), Math.Abs(j - rq));\n                        next[j] = Math.Min(next[j], dp[p] + dx + dy);\n                        if(lq<=lp&&lp<=rq)\n                            next[j] = Math.Min(next[j], dp[p]);\n                        if (lp <= lq && lq <= rp) next[j] = Math.Min(next[j], dp[p]);\n                    }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp.Min());\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Boolean;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var L = new int[n + 1];\n            var R = new int[n + 1];\n            for (int i = 0; i < n; i++)\n            {\n                L[i + 1] = sc.Integer();\n                R[i + 1] = sc.Integer();\n            }\n            if (n > 400 || R.Max() > 400) return;\n            var dp = new int[420];\n            for (int i = 1; i <= n + 1; i++)\n            {\n                if (i == n + 1) break;\n                var next = Enumerate(420, x => 1 << 30);\n                for (int pos = 0; pos < 420; pos++)\n                {\n                    for (int to = 0; to < 420; to++)\n                    {\n                        if (pos <= to && to <= pos + R[i - 1] - L[i - 1])\n                        {\n\n                            var dx = Math.Abs(L[i] - to);\n                            next[to] = Math.Min(next[to], dp[pos] + dx);\n                        }\n                        if (pos <= to + R[i] - L[i] && to + R[i] - L[i] <= pos + R[i - 1] - L[i - 1])\n                        {\n                            var dx = Math.Abs(L[i] - to);\n                            next[to] = Math.Min(next[to], dp[pos] + dx);\n                        }\n                    }\n                }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp.Min());\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size => 1;\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tTuple<int, int>[] bs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tbs = sc.ReadManyLines<int, int>(N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar l = -10000000000000000L;\n\t\t\tvar r = 10000000000000000L;\n\t\t\twhile (r - l >= 10)\n\t\t\t{\n\t\t\t\tvar a = (l * 2 + r) / 3;\n\t\t\t\tvar b = (l + r * 2) / 3;\n\t\t\t\tif (Cost(a) > Cost(b)) l = a;\n\t\t\t\telse r = b;\n\t\t\t}\n\t\t\tvar m = Cost(l);\n\t\t\tfor (var p = l + 1; p <= r; p++) m = Min(m, Cost(p));\n\t\t\tpr.WriteLine(m);\n\t\t}\n\t\tlong Cost(long pos)\n\t\t{\n\t\t\tvar c = 0L;\n\t\t\tvar last = new Tuple<long, long>(pos, pos);\n\t\t\tforeach (var b in bs.Take(1))\n\t\t\t{\n\t\t\t\tif (b.Item2 <= pos) last = new Tuple<long, long>(pos - b.Item2 + b.Item1, pos);\n\t\t\t\telse last = new Tuple<long, long>(pos, pos + b.Item2 - b.Item1);\n\t\t\t\tc += Math.Abs(b.Item1 - last.Item1);\n\t\t\t}\n\t\t\tforeach (var b in bs.Skip(1))\n\t\t\t{\n\t\t\t\tif (last.Item1 <= b.Item2 && b.Item1 <= last.Item2) last = new Tuple<long, long>(b.Item1, b.Item2);\n\t\t\t\telse if (last.Item2 < b.Item1) last = new Tuple<long, long>(last.Item2, last.Item2 + b.Item2 - b.Item1);\n\t\t\t\telse if (b.Item2 < last.Item1) last = new Tuple<long, long>(last.Item1 - b.Item2 + b.Item1, last.Item1);\n\t\t\t\telse throw new Exception();\n\t\t\t\tc += Math.Abs(b.Item1 - last.Item1);\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass RangeSegmentTree\n\t{\n\t\tint N2;\n\t\tint[] seg, unif;\n\t\tpublic RangeSegmentTree(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new int[2 * N2 - 1];\n\t\t\tunif = new int[2 * N2 - 1];\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] == 0) return;\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1)\n\t\t\t{\n\t\t\t\tunif[2 * node + 1] += unif[node];\n\t\t\t\tunif[2 * node + 2] += unif[node];\n\t\t\t}\n\t\t\tunif[node] = 0;\n\t\t}\n\t\tvoid Update(int node) => seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n\t\tpublic void AddRange(int from, int to, int value) => AddRange(from, to, value, 0, 0, N2);\n\t\tvoid AddRange(int from, int to, int value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] += value;\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tAddRange(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tAddRange(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic int this[int n] { get { return Sum(n, n + 1); } set { AddRange(n, n + 1, value - this[n]); } }\n\t\tpublic int Sum(int from, int to) => Sum(from, to, 0, 0, N2);\n\t\tint Sum(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return 0;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Sum(from, to, 2 * node + 1, l, (l + r) >> 1) + Sum(from, to, 2 * node + 2, (l + r) >> 1, r);\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass Treap<T>\n{\n\tRandom rand;\n\tComparison<T> comp;\n\tclass Node\n\t{\n\t\tpublic T value;\n\t\tpublic int size;\n\t\tprivate int priority;\n\t\tpublic Node left, right;\n\t\tpublic Treap<T> treap;\n\t\tpublic Node(Treap<T> treap, T value) { this.treap = treap; this.value = value; priority = treap.rand.Next(); size = 1; }\n\t\tpublic Node Update() { size = 1 + Size(left) + Size(right); return this; }\n\t\tpublic static int Size(Node t) => t?.size ?? 0;\n\t\tpublic static Node Merge(Node l, Node r)\n\t\t{\n\t\t\tif (l == null) return r;\n\t\t\tif (r == null) return l;\n\t\t\tif (l.priority < r.priority)\n\t\t\t{\n\t\t\t\tl.right = Merge(l.right, r);\n\t\t\t\treturn l.Update();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.left = Merge(r.left, l);\n\t\t\t\treturn r.Update();\n\t\t\t}\n\t\t}\n\t\t// [0,N) => [0,k) + [k,N)\n\t\tpublic static Tuple<Node, Node> Split(Node t, int k)\n\t\t{\n\t\t\tif (t == null) return new Tuple<Node, Node>(null, null);\n\t\t\tif (k <= Size(t.left))\n\t\t\t{\n\t\t\t\tvar s = Split(t.left, k);\n\t\t\t\tt.left = s.Item2;\n\t\t\t\treturn new Tuple<Node, Node>(s.Item1, t.Update());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar s = Split(t.right, k - Size(t.left) - 1);\n\t\t\t\tt.right = s.Item1;\n\t\t\t\treturn new Tuple<Node, Node>(t.Update(), s.Item2);\n\t\t\t}\n\t\t}\n\t\t// [0,k) + [k,N) => [0,k) + (new node) + [k+1,N)\n\t\tpublic static Node Insert(Node t, int k, T val)\n\t\t{\n\t\t\tvar n = new Node(t.treap, val);\n\t\t\tvar s = Split(t, k);\n\t\t\treturn Merge(Merge(s.Item1, n), s.Item2);\n\t\t}\n\t\t// [0,k) + k + [k+1,N) => [0,k) + [k+1,N)\n\t\tpublic static Node Erase(Node t, int k)\n\t\t{\n\t\t\tvar s1 = Split(t, k + 1);\n\t\t\tvar s2 = Split(s1.Item1, k);\n\t\t\treturn Merge(s2.Item1, s1.Item2);\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\nclass MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) => keys.Contains(item) ? mult[item] : 0;\n\tpublic int this[T item]\n\t{\n\t\tget { return Multiplicity(item); }\n\t\tset\n\t\t{\n\t\t\tDebug.Assert(value >= 0);\n\t\t\tif (value == 0) { if (keys.Contains(item)) Remove(item); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tCount += value - mult[item];\n\t\t\t\tmult[item] = value;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) => Add(item, 1);\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) => keys.Overlaps(other);\n\tpublic bool IsSupersetOf(IEnumerable<T> other) => keys.IsSupersetOf(other);\n\tpublic bool IsSubsetOf(IEnumerable<T> other) => keys.IsSubsetOf(other);\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) => keys.IsProperSubsetOf(other);\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) => keys.IsProperSupersetOf(other);\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) => CopyTo(array, 0);\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) => keys.Contains(item);\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic T Max => keys.Max;\n\tpublic T Min => keys.Min;\n\tpublic bool IsReadOnly => false;\n}\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tvar size = 0;\n\t\t\tvar time = 0m;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> Comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; Comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || Comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || Comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || Comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || Comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || Comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || Comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => Comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => Comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && Comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.Comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.Comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.Comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() => Value.ToString();\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n))) { 2 };\n\t\tvar composites = new bool[m];\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tvar s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / Stopwatch.Frequency;\n\t}\n\tpublic static double MeasureTime2(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--) dp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tmemo.MemberSet(Inf);\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (var i = n - 1; i >= 0; i--)\n\t\t\tfor (var j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length >= 2) QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (var i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tvar j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void GenRandAll()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; var p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid PeriodCertification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { GenRandAll(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nclass Solver\n{\n    static Scanner cin;\n    public Solver() {}\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Solver().solve();\n        return 0;\n    }\n \n    public void solve()\n    {\n        int n;\n        n = cin.nextInt();\n        long[] l, r, mid, width;\n        l = new long[n];\n        r = new long[n];\n        mid = new long[n];\n        width = new long[n];\n        for (int i = 0; i < n; ++i) {\n            l[i] = cin.nextLong();\n            r[i] = cin.nextLong();\n            l[i] *= 2;\n            r[i] *= 2;\n            width[i] = r[i] - l[i];\n            mid[i] = (r[i] + l[i]) / 2;\n        }\n        long leftOffset, rightOffset;\n        leftOffset = rightOffset = 0;\n        long minValue = 0;\n        \n        var left = new PriorityQueue<long>();\n        var right = new PriorityQueue<long>((long x, long y) => x > y);\n        \n        left.Push(mid[0]);\n        right.Push(mid[0]);\n        \n        for (int i = 1; i < n; ++i) {\n            long myWidth = (width[i] + width[i-1]) / 2;\n            leftOffset -= myWidth;\n            rightOffset += myWidth;\n            long maxLeft = left.Top();\n            long minRight = right.Top();\n            \n            if (maxLeft + leftOffset <= mid[i] && mid[i] <= minRight + rightOffset) {\n                left.Push(mid[i] - leftOffset);\n                right.Push(mid[i] - rightOffset);\n            } else {\n                if (mid[i] < maxLeft + leftOffset) {\n                    minValue += maxLeft + leftOffset - mid[i];\n                    \n                    right.Push(maxLeft + leftOffset - rightOffset);\n                    left.Pop();\n                    left.Push(mid[i] - leftOffset);\n                    left.Push(mid[i] - leftOffset);\n                } else {\n                    minValue += mid[i] - (minRight + rightOffset);\n                    \n                    left.Push(minRight + rightOffset - leftOffset);\n                    right.Pop();\n                    right.Push(mid[i] - rightOffset);\n                    right.Push(mid[i] - rightOffset);\n                }\n            }\n        }\n        \n        Console.WriteLine(minValue / 2);\n    }\n}\n\nclass PriorityQueue<T> where T: IComparable, new()\n{\n    private List<T> _heap;\n    private Func<T, T, bool> _compare;\n    \n    public PriorityQueue(Func<T, T, bool> compare)\n    {\n        this.Init();\n        _compare = compare;\n    }\n    \n    public PriorityQueue()\n    {\n        this.Init();\n        this._compare = (T x, T y) => x.CompareTo(y) < 0;\n    }\n    \n    public void Init()\n    {\n        _heap = new List<T>();\n        _heap.Add(new T());\n    }\n    \n    public void Push(T x)\n    {\n        _heap.Add(x);\n        for (int i = _heap.Count - 1; i > 1; i /= 2) {\n            if (_compare(_heap[i], _heap[i / 2])) {\n                return;\n            } else {\n                Swap(_heap, i, i / 2);\n            }\n        }\n    }\n    \n    public void Pop()\n    {\n        int _size = _heap.Count - 1;\n        _heap[1] = _heap[_size];\n        _heap.RemoveAt(_size);\n        _size -= 1;\n        for (int i = 1; ;) {\n            int j = 2 * i;\n            int k = 2 * i + 1;\n            if (j > _size) {\n                return;\n            }\n            if (k > _size) {\n                if (_compare(_heap[j], _heap[i])) {\n                    return;\n                }\n                Swap(_heap, i, j);\n                i = j;\n                continue;\n            }\n            if (_compare(_heap[j], _heap[i]) && _compare(_heap[k], _heap[i])) {\n                return;\n            }\n            if (_compare(_heap[j], _heap[k])) {\n                Swap(_heap, i, k);\n                i = k;\n            } else {\n                Swap(_heap, i, j);\n                i = j;\n            }\n        }\n    }\n    \n    public T Top()\n    {\n        if (this.IsEmpty())\n        {\n            throw new InvalidOperationException(\"A priority queue is empty.\");\n        }\n        return _heap[1];\n    }\n    \n    public int GetSize()\n    {\n        return _heap.Count - 1;\n    }\n    \n    public bool IsEmpty()\n    {\n        return this.GetSize() == 0;\n    }\n    \n    public void Swap(ref T x, ref T y)\n    {\n        \n        T tmp = x;\n        x = y;\n        y = tmp;\n    }\n    \n    public void Swap(List<T> list, int indexA, int indexB)\n    {\n        \n        T tmp = list[indexA];\n        list[indexA] = list[indexB];\n        list[indexB] = tmp;\n    }\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n \n    char[] cs = new char[] { ' ' };\n \n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n \n    public string next()\n    {\n        while (i >= s.Length)\n        {\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n        }\n        return s[i++];\n    }\n \n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n \n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n \n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size => 1;\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tTuple<int, int>[] bs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t\tbs = sc.ReadManyLines<int, int>(N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar l = -1000000000000000L;\n\t\t\tvar r = 1000000000000000L;\n\t\t\twhile (r - l >= 10)\n\t\t\t{\n\t\t\t\tvar a = (l * 2 + r) / 3;\n\t\t\t\tvar b = (l + r * 2) / 3;\n\t\t\t\tif (Cost(a) > Cost(b)) l = a;\n\t\t\t\telse r = b;\n\t\t\t}\n\t\t\tvar m = Cost(l);\n\t\t\tfor (var p = l + 1; p <= r; p++) m = Min(m, Cost(p));\n\t\t\tpr.WriteLine(m);\n\t\t}\n\t\tlong Cost(long pos)\n\t\t{\n\t\t\tvar c = 0L;\n\t\t\tvar last = new Tuple<long, long>(pos, pos);\n\t\t\tforeach (var b in bs)\n\t\t\t{\n\t\t\t\tvar cost = 0L;\n\t\t\t\tif (last.Item1 <= b.Item2 && b.Item1 <= last.Item2) last = new Tuple<long, long>(b.Item1, b.Item2);\n\t\t\t\telse if (last.Item2 < b.Item1)\n\t\t\t\t{\n\t\t\t\t\tcost = b.Item1 - last.Item2;\n\t\t\t\t\tlast = new Tuple<long, long>(last.Item2, last.Item2 + b.Item2 - b.Item1);\n\t\t\t\t}\n\t\t\t\telse if (b.Item2 < last.Item1)\n\t\t\t\t{\n\t\t\t\t\tcost = last.Item1 - b.Item1;\n\t\t\t\t\tlast = new Tuple<long, long>(last.Item1 - b.Item2 + b.Item1, last.Item1);\n\t\t\t\t}\n\t\t\t\telse throw new Exception();\n\t\t\t\tcost = Abs(b.Item1 - last.Item1);\n\t\t\t\tDebug.Assert(last.Item2 - last.Item1 == b.Item2 - b.Item1);\n\t\t\t\tc += cost;\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass RangeSegmentTree\n\t{\n\t\tint N2;\n\t\tint[] seg, unif;\n\t\tpublic RangeSegmentTree(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new int[2 * N2 - 1];\n\t\t\tunif = new int[2 * N2 - 1];\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] == 0) return;\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1)\n\t\t\t{\n\t\t\t\tunif[2 * node + 1] += unif[node];\n\t\t\t\tunif[2 * node + 2] += unif[node];\n\t\t\t}\n\t\t\tunif[node] = 0;\n\t\t}\n\t\tvoid Update(int node) => seg[node] = seg[2 * node + 1] + seg[2 * node + 2];\n\t\tpublic void AddRange(int from, int to, int value) => AddRange(from, to, value, 0, 0, N2);\n\t\tvoid AddRange(int from, int to, int value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] += value;\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tAddRange(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tAddRange(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic int this[int n] { get { return Sum(n, n + 1); } set { AddRange(n, n + 1, value - this[n]); } }\n\t\tpublic int Sum(int from, int to) => Sum(from, to, 0, 0, N2);\n\t\tint Sum(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return 0;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Sum(from, to, 2 * node + 1, l, (l + r) >> 1) + Sum(from, to, 2 * node + 2, (l + r) >> 1, r);\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass Treap<T>\n{\n\tRandom rand;\n\tComparison<T> comp;\n\tclass Node\n\t{\n\t\tpublic T value;\n\t\tpublic int size;\n\t\tprivate int priority;\n\t\tpublic Node left, right;\n\t\tpublic Treap<T> treap;\n\t\tpublic Node(Treap<T> treap, T value) { this.treap = treap; this.value = value; priority = treap.rand.Next(); size = 1; }\n\t\tpublic Node Update() { size = 1 + Size(left) + Size(right); return this; }\n\t\tpublic static int Size(Node t) => t?.size ?? 0;\n\t\tpublic static Node Merge(Node l, Node r)\n\t\t{\n\t\t\tif (l == null) return r;\n\t\t\tif (r == null) return l;\n\t\t\tif (l.priority < r.priority)\n\t\t\t{\n\t\t\t\tl.right = Merge(l.right, r);\n\t\t\t\treturn l.Update();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.left = Merge(r.left, l);\n\t\t\t\treturn r.Update();\n\t\t\t}\n\t\t}\n\t\t// [0,N) => [0,k) + [k,N)\n\t\tpublic static Tuple<Node, Node> Split(Node t, int k)\n\t\t{\n\t\t\tif (t == null) return new Tuple<Node, Node>(null, null);\n\t\t\tif (k <= Size(t.left))\n\t\t\t{\n\t\t\t\tvar s = Split(t.left, k);\n\t\t\t\tt.left = s.Item2;\n\t\t\t\treturn new Tuple<Node, Node>(s.Item1, t.Update());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar s = Split(t.right, k - Size(t.left) - 1);\n\t\t\t\tt.right = s.Item1;\n\t\t\t\treturn new Tuple<Node, Node>(t.Update(), s.Item2);\n\t\t\t}\n\t\t}\n\t\t// [0,k) + [k,N) => [0,k) + (new node) + [k+1,N)\n\t\tpublic static Node Insert(Node t, int k, T val)\n\t\t{\n\t\t\tvar n = new Node(t.treap, val);\n\t\t\tvar s = Split(t, k);\n\t\t\treturn Merge(Merge(s.Item1, n), s.Item2);\n\t\t}\n\t\t// [0,k) + k + [k+1,N) => [0,k) + [k+1,N)\n\t\tpublic static Node Erase(Node t, int k)\n\t\t{\n\t\t\tvar s1 = Split(t, k + 1);\n\t\t\tvar s2 = Split(s1.Item1, k);\n\t\t\treturn Merge(s2.Item1, s1.Item2);\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\nclass MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) => keys.Contains(item) ? mult[item] : 0;\n\tpublic int this[T item]\n\t{\n\t\tget { return Multiplicity(item); }\n\t\tset\n\t\t{\n\t\t\tDebug.Assert(value >= 0);\n\t\t\tif (value == 0) { if (keys.Contains(item)) Remove(item); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tCount += value - mult[item];\n\t\t\t\tmult[item] = value;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) => Add(item, 1);\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) => keys.Overlaps(other);\n\tpublic bool IsSupersetOf(IEnumerable<T> other) => keys.IsSupersetOf(other);\n\tpublic bool IsSubsetOf(IEnumerable<T> other) => keys.IsSubsetOf(other);\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) => keys.IsProperSubsetOf(other);\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) => keys.IsProperSupersetOf(other);\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) => CopyTo(array, 0);\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) => keys.Contains(item);\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic T Max => keys.Max;\n\tpublic T Min => keys.Min;\n\tpublic bool IsReadOnly => false;\n}\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tvar size = 0;\n\t\t\tvar time = 0m;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> Comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; Comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || Comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && Comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || Comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || Comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && Comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || Comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || Comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || Comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => Comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => Comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || Comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && Comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.Comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.Comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.Comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.Comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.Comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() => Value.ToString();\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n))) { 2 };\n\t\tvar composites = new bool[m];\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tvar s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / Stopwatch.Frequency;\n\t}\n\tpublic static double MeasureTime2(Action action)\n\t{\n\t\tvar sw = new Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--) dp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tmemo.MemberSet(Inf);\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (var i = n - 1; i >= 0; i--)\n\t\t\tfor (var j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length >= 2) QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (var i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tvar j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void GenRandAll()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; var p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid PeriodCertification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tPeriodCertification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { GenRandAll(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.chomp.split(\" \").map(&:to_i)end\nn = inp[0]\nl = []\nr = []\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,801,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  (1..(ll-1)).each do |j|\n    dp[i][j] = dp[i-1][j] + ll - j\n  end\n  (ll..(rr)).each do |j|\n    dp[i][j] = dp[i-1][j]\n  end\n  ((rr+1)..(800)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][j] + ind\n  end\nend\ndp[n].delete_at(0)\np dp[n].min\n=begin\n=end\n"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.chomp.split(\" \").map(&:to_i)end\nn = inp[0]\nl = []\nr = []\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,401,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  (1..(ll-1)).each do |j|\n    dp[i][j] = dp[i-1][j] + ll - j\n  end\n  (ll..(ll+rr-1)).each do |j|\n    dp[i][j] = dp[i-1][j]\n  end\n  ((ll+rr)..(400)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][j] + ind\n  end\nend\ndp[n].delete_at(0)\np dp[n].min\n=begin\n=end\n"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.to_s.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.to_s.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.to_s.chomp.split(\" \").map{|u|u.to_i}end\nn = inp[0]\nl = na(0)\nr = na(0)\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,501,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  len = rr-ll\n  x = 0\n    (0..(len)).each do |j|\n    min = dp[i-1][0..len].min + (ll - len)\n    dp[i][j] = min\n  end\n  ((len)..(ll-1)).each do |j|\n    dp[i][j] = dp[i-1][x..j].min + (ll - j + len)\n    x+=1\n  end\n  min = dp[i-1][ll..rr].min\n  (ll..(rr)).each do |j|\n    dp[i][j] = min\n  end\n    x =ll\n  ((rr+1)..(500)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][x..j].min + ind\n    x += 1\n  end\nend\n\ndp[n].delete_at(0)\np dp[n].min"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.chomp.split(\" \").map(&:to_i)end\nn = inp[0]\nl = []\nr = []\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,801,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  (1..(ll-1)).each do |j|\n    dp[i][j] = dp[i-1][j] + ll - j\n  end\n  (ll..(ll+rr-1)).each do |j|\n    dp[i][j] = dp[i-1][j]\n  end\n  ((ll+rr)..(800)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][j] + ind\n  end\nend\ndp[n].delete_at(0)\np dp[n].min\n=begin\n=end\n"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.to_s.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.to_s.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.to_s.chomp.split(\" \").map{|u|u.to_i}end\nn = inp[0]\nl = na(0)\nr = na(0)\nn.times do\n  d = inp\n  l.push(d[0])\n  r.push(d[1])\nend\ndp = na2(n+1,501,0)\nexit if(n > 400)\nexit if(l.max > 400)\nexit if(r.max > 400)\n\n(1..n).each do |i|\n  ll = l[i-1]\n  rr = r[i-1]\n  len = rr-ll\n  x = 0\n    (0..(len)).each do |j|\n    min = dp[i-1][0..len].min + (ll - len)\n    dp[i][j] = min\n  end\n  ((len)..(ll-1)).each do |j|\n    dp[i][j] = dp[i-1][x..j].min + (ll - j + len)\n    x+=1\n  end\n  min = dp[i-1][ll..rr].min\n  (ll..(rr)).each do |j|\n    dp[i][j] = min\n  end\n    x =ll+1\n  ((rr+1)..(500)).each.with_index(1) do |j,ind|\n    dp[i][j] = dp[i-1][(x)..j].min + ind\n    x += 1\n  end\nend\n\ndp[n].delete_at(0)\np dp[n].min"
  },
  {
    "language": "OCaml",
    "code": "let rec upper_bound l r p =\n  if r <= 1 + l\n  then l\n  else let m = (l + r) / 2 in\n       if p m \n       then upper_bound m r p\n       else upper_bound l m p\n\nlet () = Scanf.scanf \"%d\\n\" @@ fun n ->\n  let lrs = Array.init n @@ fun _ -> Scanf.scanf \"%d %d\\n\" @@ fun l r -> l, r in\n  let f x = Array.fold_right (fun (l, r) -> ( + ) @@\n    if x < l then l - x\n    else if r < x then x - r\n    else 0) lrs 0 in\n  Printf.printf \"%d\\n\" @@ f @@ upper_bound\n    (Array.fold_right (fun (l, _) -> min l) lrs max_int)\n    (Array.fold_right (fun (_, r) -> max r) lrs 0 + 1) @@ fun x -> f (x - 1) >= f x\n\n"
  },
  {
    "language": "OCaml",
    "code": "let () = Scanf.scanf \"%d\\n\" @@ fun n ->\n  let lrs = Array.init n @@ fun _ -> Scanf.scanf \"%d %d\\n\" @@ fun l r -> l, r in\n  let f x = Array.fold_right (fun (l, r) -> ( + ) @@\n    if x < l then l - x\n    else if r < x then x - r\n    else 0) lrs 0 in\n  let l = Array.fold_right (fun (l, _) -> min l) lrs max_int in\n  let r = Array.fold_right (fun (_, r) -> max r) lrs min_int in\n  Printf.printf \"%d\\n\" @@\n  Array.fold_left min max_int @@\n  Array.init (r - l + 1) @@ fun i -> f @@ i + l\n"
  },
  {
    "language": "OCaml",
    "code": "let () = Scanf.scanf \"%d\\n\" @@ fun n ->\n  let lrs = Array.init n @@ fun _ -> Scanf.scanf \"%d %d\\n\" @@ fun l r -> l, r in\n  let f x = Array.fold_right (fun (l, r) -> ( + ) @@\n    if x < l then l - x\n    else if r < x then x - r\n    else 0) lrs 0 in\n  let l = Array.fold_right (fun (l, _) -> min l) lrs max_int in\n  let r = Array.fold_right (fun (_, r) -> max r) lrs 0 in\n  Printf.printf \"%d\\n\" @@\n  Array.fold_left min max_int @@\n  Array.init (r - l + 1) @@ fun i -> f @@ i + l\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.container, std.conv, std.math, std.range, std.typecons, std.stdio, std.string;\n\nauto rdsp(){return readln.splitter;}\nvoid pick(R,T)(ref R r,ref T t){t=r.front.to!T;r.popFront;}\nvoid readV(T...)(ref T t){auto r=rdsp;foreach(ref v;t)pick(r,v);}\nvoid readC(T...)(size_t n,ref T t){foreach(ref v;t)v=new typeof(v)(n);foreach(i;0..n){auto r=rdsp;foreach(ref v;t)pick(r,v[i]);}}\n\nvoid main()\n{\n  int n; readV(n);\n  long[] l, r; readC(n, l, r);\n\n  auto w = new long[](n);\n  foreach (i; 0..n) w[i] = r[i]-l[i];\n\n  auto on = 0L, op = 0L, ans = 0L;\n  auto hn = heapify!\"a<b\"(Array!long(l[0]));\n  auto hp = heapify!\"a>b\"(Array!long(l[0]));\n\n  foreach (i; 1..n) {\n    on -= w[i];\n    op += w[i-1];\n\n    if (l[i] < hn.front+on) {\n      ans += (hn.front+on)-l[i];\n      hn.insert(l[i]-on);\n      hn.insert(l[i]-on);\n      hp.insert(hn.front+on-op);\n      hn.removeFront();\n    } else if (l[i] > hp.front+op) {\n      ans += l[i]-(hp.front+op);\n      hp.insert(l[i]-op);\n      hp.insert(l[i]-op);\n      hn.insert(hp.front+op-on);\n      hp.removeFront();\n    } else {\n      hn.insert(l[i]-on);\n      hp.insert(l[i]-op);\n    }\n  }\n\n  writeln(ans);\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\nimport std.container.rbtree;\n\n// import dcomp.scanner;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    long[] l = new long[n], r = new long[n];\n    long height = 0;\n    sc.read(l[0], r[0]);\n    long a = r[0]-l[0];\n\n    auto tr1 = redBlackTree!true(l[0]);\n    long off1;\n    auto tr2 = redBlackTree!true(l[0]);\n    long off2;\n//    writeln(tr1, \" \", tr2);\n    foreach (i; 1..n) {\n        sc.read(l[i], r[i]);\n        long b = r[i]-l[i];\n        // minimize [x-a, x+b]\n        off1 -= b;\n        off2 += a;\n        long lz = tr1.back + off1, rz = tr2.front + off2;\n//        writeln(lz, \" \", rz, \" ab:\", off1, \" \", off2);\n        if (l[i] < lz) {\n            tr2.insert(tr1.back + off1 - off2);\n            tr1.removeBack;\n            tr1.insert(l[i] - off1);\n            tr1.insert(l[i] - off1);\n            height += lz - l[i];\n        } else if (l[i] < rz) {\n            tr1.insert(l[i] - off1);\n            tr2.insert(l[i] - off2);\n        } else {\n            tr1.insert(tr2.front + off2 - off1);\n            tr2.removeFront;\n            tr2.insert(l[i] - off2);\n            tr2.insert(l[i] - off2);\n            height += l[i] - rz;\n        }\n//        writeln(tr1, \" \", tr2);\n    }\n    writeln(height);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\nimport std.container.rbtree;\n\n// import dcomp.scanner;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    long[] l = new long[n], r = new long[n];\n    long height = 0;\n    sc.read(l[0], r[0]);\n    long a = r[0]-l[0];\n\n    auto tr1 = redBlackTree!true(l[0]);\n    long off1;\n    auto tr2 = redBlackTree!true(l[0]);\n    long off2;\n//    writeln(tr1, \" \", tr2);\n    foreach (i; 1..n) {\n        sc.read(l[i], r[i]);\n        long b = r[i]-l[i];\n        // minimize [x-a, x+b]\n        off1 -= b;\n        off2 += a;\n        long lz = tr1.back + off1, rz = tr2.front + off2;\n//        writeln(lz, \" \", rz, \" ab:\", off1, \" \", off2);\n        if (l[i] < lz) {\n            tr2.insert(tr1.back + off1 - off2);\n            tr1.removeBack;\n            tr1.insert(l[i] - off1);\n            tr1.insert(l[i] - off1);\n            height += lz - l[i];\n        } else if (l[i] < rz) {\n            tr1.insert(l[i] - off1);\n            tr2.insert(l[i] - off2);\n        } else {\n            tr1.insert(tr2.front + off2 - off1);\n            tr2.removeFront;\n            tr2.insert(l[i] - off2);\n            tr2.insert(l[i] - off2);\n            height += l[i] - rz;\n        }\n        a = b;\n//        writeln(tr1, \" \", tr2);\n    }\n    writeln(height);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=1;i<=n;i++)\n#define fs first\n#define sc second\n#define MAXN 1000005\n#define LIMIT 1500\n#define LOGN 22\n#define MOD 1000000009\n#define pb push_back\n#define ll long long\n#define lc 2*pos\n#define rc 2*pos+1\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    int n;\n    ll l,r,ans=0;\n    priority_queue<ll>lo;\n    priority_queue<ll,vector<ll>,greater<ll>>hi;\n    ll lazyLo=0,lazyHi=0;\n    cin>>n;\n    n--;\n    cin>>l>>r;\n    hi.push(l),lo.push(l);\n    while(n){\n        n--;\n        lazyHi+=r-l;\n        cin>>l>>r;\n        lazyLo-=r-l;\n        if(l>=hi.top()+lazyHi){\n            ll shifted=hi.top()+lazyHi;\n            ans+=l-shifted;\n            hi.push(l-lazyHi);\n            hi.push(l-lazyHi);\n            hi.pop();\n            lo.push(shifted-lazyLo);\n        }else if(l<=lo.top()+lazyLo){\n            ll shifted=lo.top()+lazyLo;\n            ans+=shifted-l;\n            lo.push(l-lazyLo);\n            lo.push(l-lazyLo);\n            lo.pop();\n            hi.push(shifted-lazyHi);\n        }else{\n            hi.push(l-lazyHi);\n            lo.push(l-lazyLo);\n        }\n        //cout<<ans<<endl;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,l[N],r[N],addl,addr,ans,l1,l2,lb,rb;\npriority_queue <ll> L;\npriority_queue<ll, vector<ll>, greater<ll> > R;\nsigned main(){\n\tn=read();\n\tF(i,1,n){\n\t\tl[i]=read();r[i]=read();\n\t\tif (i==1){L.push(l[i]);R.push(l[i]);continue;}\n\t\tl2=r[i]-l[i];l1=r[i-1]-l[i-1];\n\t\taddl-=l2;addr+=l1;\n\t\tll lb=L.top()+addl,rb=R.top()+addr;\n\t\tif (l[i]<lb){\n\t\t\tans+=lb-l[i];\n\t\t\tR.push(lb-addr);\n\t\t\tL.push(l[i]-addl);\n\t\t\tL.push(l[i]-addl);L.pop();\n\t\t}\n\t\telse if (l[i]>rb){\n\t\t\tans+=l[i]-rb;\n\t\t\tL.push(rb-addl);\n\t\t\tR.push(l[i]-addr);R.push(l[i]-addr);\n\t\t\tR.pop();\n\t\t}\n\t\telse{\n\t\t\tL.push(l[i]-addl);\n\t\t\tR.push(l[i]-addr);\n\t\t}\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <iostream>\n#include <queue>\n#define ll long long\n#define pii pair<ll, ll>\n#define fst first\n#define snd second\nusing namespace std;\n\nint n;\npii ar[100001]={};\nll lz1, lz2, rs;\npriority_queue<pii> pq1;\npriority_queue<pii> pq2;\n\ninline ll abbs(ll a) {return ((a < 0) ? -a : a);}\n\nint main()\n{\n\tios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {cin >> ar[i].fst >> ar[i].snd;}\n\tpq1.push({ar[0].fst, 0});\n\tpq2.push({-ar[0].fst, 0});\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tlz1 -= ar[i].snd - ar[i].fst;\n\t\tlz2 -= ar[i-1].snd - ar[i-1].fst;\n\t\t//cout<<pq1.top().fst + lz1<<\" \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\tif (ar[i].fst < pq1.top().fst + lz1)\n\t\t{\n\t\t\tpq2.push({-(pq1.top().fst + lz1) - lz2, 0});\n\t\t\tpq1.push({ar[i].fst - lz1, 1});\n\t\t\tll val = pq1.top().fst, ng = 0;\n\t\t\twhile (pq1.size() && pq1.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq1.top().snd;\n\t\t\t\tpq1.pop();\n\t\t\t} \n\t\t\tif (ng) {pq1.push({val, ng - 1});}\n\t\t\trs += abbs(-(pq2.top().fst + lz2) - ar[i].fst);\n\t\t}\n\t\telse if (ar[i].fst > -(pq2.top().fst + lz2))\n\t\t{\n\t\t\tpq1.push({-(pq2.top().fst + lz2) - lz1, 0});\n\t\t\tpq2.push({-ar[i].fst - lz2, 1});\n\t\t\t//cout<<\"PQ1 INS \"<<-(pq2.top().fst + lz2)<<\"\\n\";\n\t\t\t//cout<<\"PQ2 INS \"<<ar[i].fst<<\"\\n\";\n\t\t\tll val = pq2.top().fst, ng = 0;\n\t\t\twhile (pq2.size() && pq2.top().fst == val)\n\t\t\t{\n\t\t\t\tng += pq2.top().snd;\n\t\t\t\tpq2.pop();\n\t\t\t} \n\t\t\tif (ng) {pq2.push({val, ng - 1});}\n\t\t\t//cout<<pq1.top().fst + lz1<<\" \"<<ar[i].fst<<\"\\n\";\n\t\t\trs += abbs(pq1.top().fst + lz1 - ar[i].fst);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq1.push({ar[i].fst - lz1, 0});\n\t\t\tpq2.push({-(ar[i].fst) - lz2, 0});\n\t\t}\n\t}\n\tcout << rs << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\nproc reduce[T](a: seq[T]; f: (T, T) -> T, init: T): T =\n  result = init\n  for e in a:\n    result = f(result, e)\n\n#------------------------------------------------------------------------------#\ntype Rect = tuple [ s, t, d: int ]\n\nproc main() =\n  let n = readInt1()\n  var rs = newSeq[Rect](n)\n  for i in 0..<n:\n    let (s, t) = readInt2()\n    rs[i] = (s - 1, t - 1, t - s)\n\n  const M = 400\n  var dp = newSeq2[int](n + 1, M)\n\n  dp[0].fill(0)\n  for p in 0..<M:\n    dp[1][p] = abs(p - rs[0].s)\n\n  for i in 2..n:\n    for p in 0..<M:\n      var opt = abs(p - rs[i - 1].s)\n      var m = INF\n      for q in max(0, p - rs[i - 2].d)..min(M - 1, p + rs[i - 1].d):\n        m = min(m, dp[i - 1][q])\n      dp[i][p] = m + opt\n\n  echo min(dp[n])\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nINF = 10**18\n\nL = max(r for l, r in P)\nS = [0]*L\nl0, r0 = P[0]\nfor i in range(L):\n    S[i] = abs(i - (l0-1))\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    T = [0]*L\n    for x in range(L):\n        r = INF\n        for y in range(max(0, x-(r0-l0)), min(L, x+(r1-l1)+1)):\n            r = min(r, S[y])\n        T[x] = abs(x-(l1-1)) + r\n    S = T\nprint(min(S))"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\nN = 400\nif n > N: exit()\n\nl = [0]*n\nr = [0]*n\nfor i in range(n): \n    l[i], r[i] = list(map(int, input().split()))\ndp = [[1000 for i in range(N)] for j in range(n)]\n\nfor i in range(N): #最初の段は埋めておく。\n    dp[0][i] = abs(l[0]-i)\n    if i < l[0]:\n         d = l[0] - i\n    elif r[0] < i: \n         d = i - r[0]\n    else: \n         d = 0\n    dp[0][i] = d\n    \nfor ni in range(1,n): # 何段目で?\n    for xj in range(N): # どこに接地させる?\n        # このブロックをxjに持っていくコスト\n        if xj < l[ni]: \n            d = l[ni] - xj\n        elif r[ni] < xj:\n            d = xj - r[ni]\n        else: \n            d = 0 \n        # 前のブロックで、xjに設置している中で最もコストの低いものに、今回のコストを加える\n        min_cost = 1000\n        for xk in range(N):\n            if dp[ni-1][xj] > 400: continue\n            min_cost = min(min_cost, dp[ni-1][xj])\n        dp[ni][xj] = min_cost+d\n\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nnum_lec = int(input())\nl_lec = [list(map(int, input().split())) for i in range(num_lec)]\n\nsum_lec_right = [lec[1] for lec in l_lec]\nsum_lec_left = [lec[0] for lec in l_lec]\n\n# print(sum_lec_right)\n# print(sum_lec_left)\n\n# min_sum = min(sum_lec_left)\nmax_sum = max(sum_lec_right)\n\n\ndef make_dis(poi_o, lec):\n    dis = 0\n    if poi_o < lec[0]:\n        dis = lec[0] - poi_o\n    elif lec[0] <= poi_o <= lec[1]:\n        dis = 0\n    elif lec[1] < poi_o:\n        dis = poi_o - lec[1]\n    return dis\n\n\nl_dis = []\nfor poi_o in range(0, max_sum + 1):\n    sum_dis = 0\n    for lec in l_lec:\n        dis = make_dis(poi_o, lec)\n        sum_dis += dis\n    l_dis.append(sum_dis)\n\n# print(l_dis)\n\nans = min(l_dis)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nif n>400: exit()\n\nl = [0]*n\nr = [0]*n\n\nfor i in range(n):\n    l[i], r[i] = list(map(int, input().split()))\n\nN = 400+1\ndp = [[0 for i in range(N)] for j in range(n)]\n\n# 一番上のブロックを動かした時のコスト\nfor i in range(N):\n    if r[0] < i: d = i-r[0]\n    elif i < l[0]: d = l[0]-i\n    else: d = 0\n    dp[0][i] = d\n\n# 順番にコストを計算していく\nfor ni in range(1,n):\n    for i in range(N):\n        if r[ni] < i: d = i-r[ni]\n        elif i < l[ni]: d = l[ni]-i\n        else: d = 0\n        dp[ni][i] = d + dp[ni-1][i]\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\nN = 400\nif n > N: exit()\n\nl = [0]*n\nr = [0]*n\nfor i in range(n): \n    l[i], r[i] = list(map(int, input().split()))\ndp = [[1000 for i in range(N)] for j in range(n)]\n\nfor i in range(N): #最初の段は埋めておく。\n    dp[0][i] = abs(l[0]-i)\n    if i < l[0]:\n         d = l[0] - i\n    elif r[0] < i: \n         d = i - r[0]\n    else: \n         d = 0\n    dp[0][i] = d\n    \nfor ni in range(1,n): # 何段目で?\n    for xj in range(N): # どこに接地させる?\n        # このブロックをxjに持っていくコスト\n        if xj < l[ni]: \n            d = l[ni] - xj\n        elif r[ni] < xj:\n            d = xj - r[ni]\n        else: \n            d = 0 \n        # 前のブロックで、xjに設置している中で最もコストの低いものに、今回のコストを加える\n        min_cost = 1000\n        for xk in range(N):\n            d2 =  0\n            if xk < xj:\n                if xj <= xk+r[ni-1]:\n                    min_cost = min(min_cost, dp[ni-1][xj] + d2 )\n            elif xj < xk:\n                if xk <= xj+r[ni]:\n                    min_cost = min(min_cost, dp[ni-1][xj] + d2 ) \n            else:\n                min_cost = min(min_cost, dp[ni-1][xj] + d2)\n        dp[ni][xj] = min_cost+d\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nINF = 10**18\n\nL = max(r for l, r in P)\nS = [0]*L\nl0, r0 = P[0]\nfor i in range(L):\n    S[i] = abs(i - (l0-1))\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    T = [0]*L\n    for x in range(L):\n        r = INF\n        for y in range(max(0, x-(r0-l0)), min(L, x+(r1-l1)+1)):\n            r = min(r, S[y])\n        T[x] = abs(x-(l1-1)) + r\n    S = T\nprint(min(S))"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nINF = 10**18\n\nfrom heapq import heappush, heappop\n\nl0, r0 = P[0]\n\nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n\ndef debug(L, s, t, R):\n    L0 = L[:]\n    Q1 = []; Q2 = []\n    while L0:\n        Q1.append(-s-heappop(L0))\n    R0 = R[:]\n    while R0:\n        Q2.append(t+heappop(R0))\n    print(\"debug:\", *Q1[::-1]+Q2)\n\n\n#print(L, s, t, R)\nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    #print(\">\", l1, r1)\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        #print(0)\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n        # res += 0\n    elif l1-1 < -s-L[0]:\n        #print(1)\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        d = p - (-L[0]-s)\n        heappush(R, p-t)\n        #print(d)\n        if d == 0:\n            res += p - (l1-1)\n        else:\n            res += d\n    elif t+R[0] < l1-1:\n        #print(2)\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        d = R[0]+t - p\n        heappush(L, -p-s)\n        #print(d)\n        if d == 0:\n            res += (l1-1) - p\n        else:\n            res += d\n    #print(L, s, t, R, -s-L[0], R[0]+t, res)\n    #debug(L, s, t, R)\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\nN = 400\nif n > N: exit()\n\nl = [0]*n\nr = [0]*n\nfor i in range(n): \n    l[i], r[i] = list(map(int, input().split()))\ndp = [[1000 for i in range(N)] for j in range(n)]\n\nfor i in range(N): #最初の段は埋めておく。\n    dp[0][i] = abs(l[0]-i)\n    if i < l[0]:\n         d = l[0] - i\n    elif r[0] < i: \n         d = i - r[0]\n    else: \n         d = 0\n    dp[0][i] = d\n    \nfor ni in range(1,n): # 何段目で?\n    for xj in range(N): # どこに接地させる?\n        # このブロックをxjに持っていくコスト\n        if xj < l[ni]: \n            d = l[ni] - xj\n        elif r[ni] < xj:\n            d = xj - r[ni]\n        else: \n            d = 0 \n        # 前のブロックで、xjに設置している中で最もコストの低いものに、今回のコストを加える\n        min_cost = 1000\n        for xk in range(N):\n            d2 =  0\n            if xk < xj:\n                if xj <= xk+r[ni-1]:\n                    min_cost = min(min_cost, dp[ni-1][xj] + d2 )\n            elif xj < xk:\n                if xk <= xj+r[ni]:\n                    min_cost = min(min_cost, dp[ni-1][xj] + d2 ) \n            else:\n                min_cost = min(min_cost, dp[ni-1][xj] + d2)\n        dp[ni][xj] = min_cost+d\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\nN = 400\nif n > N: exit()\n\nl = [0]*n\nr = [0]*n\nfor i in range(n): \n    l[i], r[i] = list(map(int, input().split()))\ndp = [[1000 for i in range(N)] for j in range(n)]\n\nfor i in range(N): #最初の段は埋めておく。\n    dp[0][i] = abs(l[0]-i)\n    if i < l[0]:\n         d = l[0] - i\n    elif r[0] < i: \n         d = i - r[0]\n    else: \n         d = 0\n    dp[0][i] = d\n    \nfor ni in range(1,n): # 何段目で?\n    for xj in range(N): # どこに接地させる?\n        # このブロックをxjに持っていくコスト\n        if xj < l[ni]: \n            d = l[ni] - xj\n        elif r[ni] < xj:\n            d = xj - r[ni]\n        else: \n            d = 0 \n        # 前のブロックで、xjに設置している中で最もコストの低いものに、今回のコストを加える\n        min_cost = 1000\n        for xk in range(N):\n            min_cost = min(min_cost, dp[ni-1][xj])\n        dp[ni][xj] = min_cost+d\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nl = [0]*n\nr = [0]*n\n\nfor i in range(n):\n    l[i], r[i] = list(map(int, input().split()))\n\nN = 10**9+1\ndp = [[0 for i in range(N)] for j in range(n)]\n\n# 一番上のブロックを動かした時のコスト\nfor i in range(N):\n    if r[0] < i: d = i-r[0]\n    elif i < l[0]: d = l[0]-i\n    else: d = 0\n    dp[0][i] = d\n\n# 順番にコストを計算していく\nfor ni in range(1,n):\n    for i in range(N):\n        if r[ni] < i: d = i-r[ni]\n        elif i < l[ni]: d = l[ni]-i\n        else: d = 0\n        dp[ni][i] = d + dp[ni-1][i]\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom heapq import heappush, heappushpop\n\n\"\"\"\n・f(x) = （最上段の左端座標） -> 最小コスト\n・g = newf とすると、g(x) = |x-l| + min_{x-w_{n-1}<=y<=x+w_n}f(y)\n・常に [A0,B0] 上で定数、[A_i,A_{i-1}]で傾き-i、[B_{i-1},B_i]で傾きiの下に凸な折れ線\nheapqで(A,B)の形で関数を持つ\n・1段目の長方形で、A = [l], B = [l] からスタート（f(x) = |x - l|）\n\"\"\"\n\nN = int(readline())\nm = map(int,read().split())\nL,R = zip(*zip(m,m))\n\nA = [-L[0]]; B = [L[0]]\naddA = 0\naddB = 0\nmin_f = 0\nfor n in range(1,N):\n    p = R[n-1] - L[n-1]; q = R[n] - L[n]\n    # まず、f(x) = min_{x-p <= y <= x+q} f(y) へと更新\n    addA += (-q); addB += p\n    a = -A[0] + addA\n    b = B[0] + addB\n    x = L[n]\n    # x で座標を2回切り替えるようにする\n    if x <= a:\n        # 左に2つ入れたあと、右に1つうつす\n        min_f += a - x\n        heappush(A,-x + addA)\n        y = -heappushpop(A,-x + addA) + addA\n        heappush(B, y - addB)\n    elif x >= b:\n        # 右に2つ入れたあと、左に1つうつす\n        min_f += x - b\n        heappush(B, x - addB)\n        y = heappushpop(B, x - addB) + addB\n        heappush(A, -y + addA)\n    else:\n        # 左右に1つずつ入れる\n        heappush(A, -x + addA)\n        heappush(B, x - addB)\n\nprint(min_f)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nif n>400: exit()\n\nl = [0]*n\nr = [0]*n\n\nfor i in range(n):\n    l[i], r[i] = list(map(int, input().split()))\n\nN = 400+1\ndp = [[0 for i in range(N)] for j in range(n)]\n\n# 一番上のブロックを動かした時のコスト\nfor i in range(N):\n    if r[0] < i: d = i-r[0]\n    elif i < l[0]: d = l[0]-i\n    else: d = 0\n    dp[0][i] = d\n\n# 順番にコストを計算していく\nfor ni in range(1,n+1):\n    for i in range(N):\n        if r[ni] < i: d = i-r[ni]\n        elif i < l[ni]: d = l[ni]-i\n        else: d = 0\n        dp[ni][i] = d + dp[ni-1][i]\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nl = [0]*n\nr = [0]*n\n\nfor i in range(n):\n    l[i], r[i] = list(map(int, input().split()))\n\ndp = [[0 for i in range(400)] for j in range(n)]\n\n# 一番上のブロックを動かした時のコスト\nfor i in range(400):\n    if r[0] < i: d = i-r[0]\n    elif i < l[0]: d = l[0]-i\n    else: d = 0\n    dp[0][i] = d\n\n# 順番にコストを計算していく\nfor ni in range(1,n):\n    for i in range(400):\n        if r[ni] < i: d = i-r[ni]\n        elif i < l[ni]: d = l[ni]-i\n        else: d = 0\n        dp[ni][i] = d + dp[ni-1][i]\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n \nINF = 10**18\n \nfrom heapq import heappush, heappop\n \nl0, r0 = P[0]\n \nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n \nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n    elif l1-1 < -s-L[0]:\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        heappush(R, p-t)\n        res += (p - (l1-1))\n    elif t+R[0] < l1-1:\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        heappush(L, -p-s)\n        res += (l1-1 - p)\nprint(res)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom heapq import heappop, heappush\n\n\"\"\"\nf(x) = （一番上の長方形の左端がxに来るときのコストの最小値） を関数ごと更新していきたい\n更新後をg(x)とする\ng(x) = |x-L| + min_{-width_1 \\leq t\\leq width_2} f(x+t), 前回の幅、今回の幅\n常に、区間上で最小値を持ち傾きが1ずつ変わる凸な関数であることが維持される。（区間は1点かも）\n傾きが変わる点の集合S_f = S_f_lower + S_f_upperを持っていく。\nS_f_lower, S_upperは一斉に定数を足す：変化量のみ持つ\n\"\"\"\n\nN = int(input())\nLR = [[int(x) for x in input().split()] for _ in range(N)]\n\n# initialize\nL,R = LR[0]\nS_lower = [-L]\nS_upper = [L]\nmin_f = 0\nadd_lower = 0\nadd_upper = 0\nprev_w = R - L\n\npush_L = lambda x: heappush(S_lower, -x)\npush_R = lambda x: heappush(S_upper, x)\npop_L = lambda: -heappop(S_lower)\npop_R = lambda: heappop(S_upper)\n\nfor L,R in LR[1:]:\n    w = R - L\n    # 平行移動とのminをとるステップ\n    add_lower -= w\n    add_upper += prev_w\n    # abs(x-L) を加えるステップ\n    # abs は瞬間に2傾きが変わるので\n    x = pop_L() + add_lower\n    y = pop_R() + add_upper\n    a,b,c,d = sorted([x,y,L,L])\n    push_L(a - add_lower)\n    push_L(b - add_lower)\n    push_R(c - add_upper)\n    push_R(d - add_upper)\n    min_f += c-b\n    prev_w = w\n\nprint(min_f)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(N, lefts, rights):\n    assert 1 <= N <= 400\n    min_l, max_l = min(lefts), max(lefts)\n    max_r = max(rights)\n    assert 1 <= min_l < max_r <= 400\n    dp = [[float(\"inf\")] * (max_l + 1) for _ in range(N)]\n    dp = [[0] * (max_l + 1)] + dp\n    lefts = (1,) + lefts\n    rights = (max_l,) + rights\n    for i in range(1, N+1):\n        pre_length = rights[i-1] - lefts[i-1]\n        for l in range(1, max_l + 1):\n            #print(\"{}, [{}, {}]\".format(l, max(1, l-pre_length), l))\n            dp[i][l] = min(dp[i-1][max(1, l-pre_length):min(rights[i]+1, max_l+1)] or [float(\"inf\")]) + abs(lefts[i]-l)\n        #print(dp[i])\n    return(min(dp[-1][1:]))\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    lr = [[int(i) for i in input().split()] for _ in range(N)]\n    lefts, rights = zip(*lr)\n    print(solve(N, lefts, rights))\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nINF = 10**18\n\nfrom heapq import heappush, heappop\n\nl0, r0 = P[0]\n\nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n\ndef debug(L, s, t, R):\n    L0 = L[:]\n    Q1 = []; Q2 = []\n    while L0:\n        Q1.append(-s-heappop(L0))\n    R0 = R[:]\n    while R0:\n        Q2.append(t+heappop(R0))\n    print(\"debug:\", *Q1[::-1]+Q2)\n\n\n#print(L, s, t, R)\nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    #print(\">\", l1, r1)\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        #print(0)\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n        # res += 0\n    elif l1-1 < -s-L[0]:\n        #print(1)\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        #d = (-L[0]-s) - p\n        heappush(R, p-t)\n        #print(d)\n        #res += d\n        res += (p - (l1-1))\n    elif t+R[0] < l1-1:\n        #print(2)\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        #d = R[0]+t - p\n        heappush(L, -p-s)\n        #print(d)\n        res += (l1-1 - p)\n    #print(L, s, t, R, -s-L[0], R[0]+t, res)\n    #debug(L, s, t, R)\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "def solve(N, lefts, rights):\n    assert 1 <= N <= 400\n    min_l, max_l = min(lefts), max(lefts)\n    max_r = max(rights)\n    assert 1 <= min_l < max_r <= 400\n    dp = [[float(\"inf\")] * (max_l + 1) for _ in range(N)]\n    dp = [[0] * (max_l + 1)] + dp\n    lefts = (1,) + lefts\n    rights = (max_l,) + rights\n    for i in range(1, N+1):\n        pre_length = rights[i-1] - lefts[i-1]\n        for l in range(1, max_l + 1):\n            #print(\"{}, [{}, {}]\".format(l, max(1, l-pre_length), l))\n            dp[i][l] = min(dp[i-1][max(1, l-pre_length):min(rights[i]+1, max_l+1)], default=float(\"inf\")) + abs(lefts[i]-l)\n        #print(dp[i])\n    return(min(dp[-1][1:]))\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    lr = [[int(i) for i in input().split()] for _ in range(N)]\n    lefts, rights = zip(*lr)\n    print(solve(N, lefts, rights))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [list(map(int,input().split())) for i in range(n)]\ndef keisan(x):\n  ans = 0\n  for i,j in a:\n    if x < i:\n      ans += i-x\n    elif x > j:\n      ans += x-j\n  return ans\nx0 = 0\nx3 = 1<<32\nwhile x3 - x0 >2:\n  x1 = (x0*2+x3)//3\n  x2 =  (x0+x3*2)//3\n  y1 = keisan(x1)\n  y2 = keisan(x2)\n  if y1 > y2:\n    x0 = x1\n  else:\n    x3 = x2\nprint(min(keisan(x0),keisan(x0+1),keisan(x0+2)))"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nfrom heapq import heappush, heappop\n\nl0, r0 = P[0]\n\nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n\nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n    elif l1-1 < -s-L[0]:\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        heappush(R, p-t)\n        res += (p - (l1-1))\n    elif t+R[0] < l1-1:\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        heappush(L, -p-s)\n        res += ((l1-1) - p)\nprint(res)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nl = [0]*n\nr = [0]*n\n\nfor i in range(n):\n    l[i], r[i] = list(map(int, input().split()))\n\nN = 10**4+1\ndp = [[0 for i in range(N)] for j in range(n)]\n\n# 一番上のブロックを動かした時のコスト\nfor i in range(N):\n    if r[0] < i: d = i-r[0]\n    elif i < l[0]: d = l[0]-i\n    else: d = 0\n    dp[0][i] = d\n\n# 順番にコストを計算していく\nfor ni in range(1,n):\n    for i in range(N):\n        if r[ni] < i: d = i-r[ni]\n        elif i < l[ni]: d = l[ni]-i\n        else: d = 0\n        dp[ni][i] = d + dp[ni-1][i]\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\nN = 400\nif n > N: exit()\n\nl = [0]*n\nr = [0]*n\nfor i in range(n): \n    l[i], r[i] = list(map(int, input().split()))\ndp = [[1000 for i in range(N)] for j in range(n)]\n\nfor i in range(N): #最初の段は埋めておく。\n    dp[0][i] = abs(l[ni]-i)\n    if i < l[ni]: \n         d = l[ni] - i\n    elif r[ni] < i: \n         d = i - r[ni]\n    else: \n         d = 0\n    dp[0][i] = d\n    \nfor ni in range(1,n): # 何段目で?\n    for xj in range(N): # どこに接地させる?\n        # このブロックをxjに持っていくコスト\n        if xj < l[ni]: \n            d = l[ni] - xj\n        elif r[ni] < xj:\n            d = xj - r[ni]\n        else: \n            d = 0 \n        # 前のブロックで、xjに設置している中で最もコストの低いものに、今回のコストを加える\n        min_cost = 1000\n        for xk in range(N):\n            d2 =  0\n            if xk < xj:\n                if xj <= xk+r[ni-1]:\n                    min_cost = min(min_cost, dp[ni-1][xj] + d2 )\n            elif xj < xk:\n                if xk <= xj+r[ni]:\n                    min_cost = min(min_cost, dp[ni-1][xj] + d2 ) \n            else:\n                min_cost = min(min_cost, dp[ni-1][xj] + d2)\n        dp[ni][xj] = min_cost+d\nprint(min(dp[n-1]))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nnum_lec = int(input())\nl_lec = [list(map(int, input().split())) for i in range(num_lec)]\n\nl_set = set([])\nfor lec in l_lec:\n    l_set.add(lec[0])\n    l_set.add(lec[1])\n\nall_dis = []\nfor num in l_set:\n    l_dis = []\n    for lec in l_lec:\n        if lec[0] <= num <= lec[1]:\n            min_dis = 0\n        else:\n            dis_0 = num - lec[0]\n            if dis_0 < 0:\n                dis_0 *= -1\n            dis_1 = num - lec[1]\n            if dis_1 < 0:\n                dis_1 *= -1\n            if dis_0 > dis_1:\n                min_dis = dis_1\n            else:\n                min_dis = dis_0\n        l_dis.append(min_dis)\n    sum_dis = sum(l_dis)\n    all_dis.append(sum_dis)\n\nans = min(all_dis)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nINF = 10**18\n\nfrom heapq import heappush, heappop\n\nl0, r0 = P[0]\n\nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n\nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n    elif l1-1 < -s-L[0]:\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        heappush(R, p-t)\n        res += (p - (l1-1))\n    elif t+R[0] < l1-1:\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        heappush(L, -p-s)\n        res += (l1-1 - p)\nprint(res)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom heapq import heappop, heappush\n\n\"\"\"\nf(x) = （一番上の長方形の左端がxに来るときのコストの最小値） を関数ごと更新していきたい\n更新後をg(x)とする\ng(x) = |x-L| + min_{-width_1 \\leq t\\leq width_2} f(x+t), 前回の幅、今回の幅\n常に、区間上で最小値を持ち傾きが1ずつ変わる凸な関数であることが維持される。（区間は1点かも）\n傾きが変わる点の集合S_f = S_f_lower + S_f_upperを持っていく。\nS_f_lower, S_upperは一斉に定数を足す：変化量のみ持つ\n\"\"\"\n\nN = int(input())\nLR = [[int(x) for x in input().split()] for _ in range(N)]\n\n# initialize\nL,R = LR[0]\nS_lower = [-L]\nS_upper = [L]\nmin_f = 0\nadd_lower = 0\nadd_upper = 0\nprev_w = R - L\n\npush_L = lambda x: heappush(S_lower, -x)\npush_R = lambda x: heappush(S_upper, x)\npop_L = lambda: -heappop(S_lower)\npop_R = lambda: heappop(S_upper)\n\nfor L,R in LR[1:]:\n    w = R - L\n    # 平行移動とのminをとるステップ\n    add_lower -= w\n    add_upper += prev_w\n    # abs(x-L) を加えるステップ\n    # abs は瞬間に2傾きが変わるので\n    x = pop_L() + add_lower\n    y = pop_R() + add_upper\n    x,y,z,w = sorted([x,y,L,L])\n    push_L(x - add_lower)\n    push_L(y - add_lower)\n    push_R(z - add_upper)\n    push_R(w - add_upper)\n    min_f += z-y\n\nprint(min_f)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(N, lefts, rights):\n    assert 1 <= N <= 400\n    min_l, max_l = min(lefts), max(lefts)\n    max_r = max(rights)\n    assert 1 <= min_l < max_r <= 400\n    dp = [[float(\"inf\")] * (max_l + 1) for _ in range(N)]\n    dp = [[0] * (max_l + 1)] + dp\n    lefts = (1,) + lefts\n    rights = (max_l,) + rights\n    for i in range(1, N+1):\n        pre_length = rights[i-1] - lefts[i-1]\n        for l in range(1, max_l + 1):\n            #print(\"{}, [{}, {}]\".format(l, max(1, l-pre_length), l))\n            dp[i][l] = min(dp[i-1][max(1, l-pre_length):min(rights[i]+1, max_l+1)], default=float(\"inf\")) + abs(lefts[i]-l)\n        #print(dp[i])\n    return(min(dp[-1][1:]))\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    lr = [[int(i) for i in input().split()] for _ in range(N)]\n    lefts, rights = zip(*lr)\n    print(solve(N, lefts, rights))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [list(map(int,input().split())) for i in range(n)]\ndp = [[float(\"inf\")]*(500) for i in range(n+1)]\nif n > 400:\n  exit()\nfor i in range(500):\n  dp[0][i] = 0\nfor i in range(1,n+1):\n  m = a[i-1][1] - a[i-1][0]\n  mm = a[i-2][1] - a[i-2][0]\n  for j in range(405):\n    for k in range(405):\n      if (j<= k and k<=j+m) or (k<= j and j <= k+mm) or i == 1:\n        dp[i][j] = min(dp[i][j],dp[i-1][k]+abs(j-a[i-1][0]))\nans = float(\"inf\")\nfor i in range(500):\n  ans = min(ans,dp[n][i])\nprint(ans)"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nstruct SlopeSet {\n    heap: BinaryHeap<i64>,\n    add: i64\n}\n\nimpl SlopeSet {\n    fn new() -> Self {\n        SlopeSet { heap: BinaryHeap::new(), add: 0 }\n    }\n\n    fn add(&mut self, x: i64) {\n        self.add += x;\n    }\n\n    fn push_left(&mut self, x: i64) {\n        let tx = x - self.add;\n        self.heap.push(tx);\n    }\n\n    fn push_right(&mut self, x: i64) {\n        let tx = x - self.add;\n        self.heap.push(-tx);\n    }\n\n    fn pop_left(&mut self) -> i64 {\n        let x = self.heap.pop().unwrap();\n        x + self.add\n    }\n\n    fn pop_right(&mut self) -> i64 {\n        let x = self.heap.pop().unwrap();\n        -x + self.add\n    }\n\n    fn peek_left_pair(&mut self) -> (i64, i64) {\n        let one = self.heap.pop().unwrap();\n        let two = self.heap.pop().unwrap();\n        self.heap.push(one);\n        self.heap.push(two);\n        (two + self.add, one + self.add)\n    }\n\n    fn peek_right_pair(&mut self) -> (i64, i64) {\n        let one = self.heap.pop().unwrap();\n        let two = self.heap.pop().unwrap();\n        self.heap.push(one);\n        self.heap.push(two);\n        (-one + self.add, -two + self.add)\n    }\n}\n\nconst INF: i64 = 1e16 as i64;\n\nfn main() {\n    let n: usize = read();\n    let rects: Vec<(i64, i64)> = readn(n);\n\n\n    let mut from = rects[0].0;\n    let mut to = rects[0].0;\n    let mut bottom = 0;\n\n    let mut left = SlopeSet::new();\n    left.push_left(-INF);\n    left.push_left(from);\n\n    let mut right = SlopeSet::new();\n    right.push_right(INF);\n    right.push_right(from);\n\n\n    for i in 1..n {\n        let fl = rects[i-1].0;\n        let fr = rects[i-1].1;\n        let tl = rects[i].0;\n        let tr = rects[i].1;\n        from -= tr-tl;\n        left.add(-tr+tl);\n        to += fr-fl;\n        right.add(fr-fl);\n\n        let (l0, l1) = left.peek_left_pair();\n        let (r0, r1) = right.peek_right_pair();\n\n        // println!(\"{}={}({} {}){}={}\", l0, l1, from, to, r0, r1);\n\n        let position = tl;\n        if position < l1 {\n            from = max(l0, position);\n            to = l1;\n            bottom += l1 - max(l0, position);\n            left.push_left(position);\n            let l0 = left.pop_left();\n            right.push_right(l0);\n        } else if position < r0 {\n            from = position;\n            to = position;\n            left.push_left(position);\n            right.push_right(position);\n        } else {\n            from = r0;\n            to = min(r1, position);\n            bottom += min(r1, position) - r0;\n            right.push_right(position);\n            let r0 = right.pop_left();\n            left.push_left(r0);\n        }\n    }\n\n    println!(\"{}\", bottom);\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn get_two() -> (i64, i64) {\n    let x = get();\n    let y = get();\n    (x, y)\n}\n\nfn solve() {\n    let n = get();\n    let lr: Vec<_> = (0 .. n).map(|_| get_two()).collect();\n    let mut mi = 1 << 60;\n    assert!(n <= 500);\n    for piv in 0 .. n {\n        let mut lr = lr.clone();\n        let mut cost = 0;\n        for i in (0 .. piv).rev() {\n            if lr[i].1 < lr[i + 1].0 {\n                let diff = lr[i + 1].0 - lr[i].1;\n                cost += diff;\n                lr[i].0 += diff;\n                lr[i].1 += diff;\n            }\n            if lr[i + 1].1 < lr[i].0 {\n                let diff = lr[i].0 - lr[i + 1].1;\n                cost += diff;\n                lr[i].0 -= diff;\n                lr[i].1 -= diff;\n            }\n        }\n        for i in piv .. n - 1 {\n            if lr[i].1 < lr[i + 1].0 {\n                let diff = lr[i + 1].0 - lr[i].1;\n                cost += diff;\n                lr[i + 1].0 -= diff;\n                lr[i + 1].1 -= diff;\n            }\n            if lr[i + 1].1 < lr[i].0 {\n                let diff = lr[i].0 - lr[i + 1].1;\n                cost += diff;\n                lr[i + 1].0 += diff;\n                lr[i + 1].1 += diff;\n            }\n        }\n        mi = min(mi, cost);\n    }\n    println!(\"{}\", mi);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nstruct SlopeSet {\n    heap: BinaryHeap<i64>,\n    add: i64\n}\n\nimpl SlopeSet {\n    fn new() -> Self {\n        SlopeSet { heap: BinaryHeap::new(), add: 0 }\n    }\n\n    fn add(&mut self, x: i64) {\n        self.add += x;\n    }\n\n    fn push_left(&mut self, x: i64) {\n        let tx = x - self.add;\n        self.heap.push(tx);\n    }\n\n    fn push_right(&mut self, x: i64) {\n        let tx = x - self.add;\n        self.heap.push(-tx);\n    }\n\n    fn pop_left(&mut self) -> i64 {\n        let x = self.heap.pop().unwrap();\n        x + self.add\n    }\n\n    fn pop_right(&mut self) -> i64 {\n        let x = self.heap.pop().unwrap();\n        -x + self.add\n    }\n\n    fn peek_left_pair(&mut self) -> (i64, i64) {\n        let one = self.heap.pop().unwrap();\n        let two = self.heap.pop().unwrap();\n        self.heap.push(one);\n        self.heap.push(two);\n        (two + self.add, one + self.add)\n    }\n\n    fn peek_right_pair(&mut self) -> (i64, i64) {\n        let one = self.heap.pop().unwrap();\n        let two = self.heap.pop().unwrap();\n        self.heap.push(one);\n        self.heap.push(two);\n        (-one + self.add, -two + self.add)\n    }\n}\n\nconst INF: i64 = 1e16 as i64;\n\nfn main() {\n    let n: usize = read();\n    let rects: Vec<(i64, i64)> = readn(n);\n\n\n    let mut from = rects[0].0;\n    let mut to = rects[0].0;\n    let mut bottom = 0;\n\n    let mut left = SlopeSet::new();\n    left.push_left(-INF);\n    left.push_left(from);\n\n    let mut right = SlopeSet::new();\n    right.push_right(INF);\n    right.push_right(from);\n\n\n    for i in 1..n {\n        let fl = rects[i-1].0;\n        let fr = rects[i-1].1;\n        let tl = rects[i].0;\n        let tr = rects[i].1;\n        from -= tr-tl;\n        left.add(-tr+tl);\n        to += fr-fl;\n        right.add(fr-fl);\n\n        let (l0, l1) = left.peek_left_pair();\n        let (r0, r1) = right.peek_right_pair();\n\n        // println!(\"{}={}({} {}){}={}\", l0, l1, from, to, r0, r1);\n        // println!(\"{}\", bottom);\n\n        let position = tl;\n        if position <= l1 {\n            from = max(l0, position);\n            to = l1;\n            bottom += (l1 - position).abs();\n            left.push_left(position);\n            left.push_left(position);\n            let l0 = left.pop_left();\n            right.push_right(l0);\n        } else if position < r0 {\n            from = position;\n            to = position;\n            left.push_left(position);\n            right.push_right(position);\n        } else {\n            from = r0;\n            to = min(r1, position);\n            bottom += (position - r0).abs();\n            right.push_right(position);\n            right.push_right(position);\n            let r0 = right.pop_right();\n            left.push_left(r0);\n        }\n    }\n\n    println!(\"{}\", bottom);\n}"
  }
]