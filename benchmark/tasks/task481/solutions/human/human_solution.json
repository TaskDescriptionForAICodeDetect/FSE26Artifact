[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nint N,K;\nint memo[1 << 17];\nint memo2[1 << 17];\nint getans(bitset<17>&bs, const vector<vector<int>>&love) {\n\tif (memo[bs.to_ulong()] != -1)return memo[bs.to_ulong()];\n\tif (bs.count() == 0) {\n\t\treturn memo[bs.to_ulong()] =0;\n\t}\n\telse {\n\t\tvector<int>unused;\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tif (bs[i])unused.push_back(i);\n\t\t}\n\t\tvector<int>team;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < (1 << unused.size()); ++i) {\n\t\t\tbitset<17>team;\n\t\t\tint num(i);\n\t\t\tfor (int j = 0; j < unused.size(); ++j) {\n\t\t\t\tteam[j] = num % 2;\n\t\t\t\tnum /= 2;\n\t\t\t}\n\t\t\tif (team[0] == 0)continue;\n\t\t\tint teamlove = 0;\n\t\t\t{\n\t\t\t\tbitset<17>lovebs;\n\t\t\t\tvector<int>as;\n\t\t\t\tfor (int j = 0; j < unused.size(); ++j) {\n\t\t\t\t\tif (team[j]){\n\t\t\t\t\t\tlovebs[unused[j]] = true;\n\t\t\t\t\t\tas.push_back(unused[j]);\n\t\t\t\t}\n\t\t\t\tif (memo2[lovebs.to_ulong()] == -1) {\n\t\t\t\t\tfor (int j = 0; j < as.size(); ++j) {\n\t\t\t\t\t\tfor (int k = 0; k <as.size(); ++k) {\n\t\t\t\t\t\t\tteamlove += love[as[j]][as[k]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemo2[lovebs.to_ulong()] = teamlove;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tteamlove = memo2[lovebs.to_ulong()];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < unused.size(); ++j) {\n\t\t\t\tif (team[j])bs[unused[j]] = false;\n\t\t\t}\n\t\t\tans = max(ans, teamlove+getans(bs, love) + K);\n\t\t\tfor (int j = 0; j < unused.size(); ++j) {\n\t\t\t\tif (team[j])bs[unused[j]] =true;\n\t\t\t}\n\t\t}\n\t\treturn memo[bs.to_ulong()] = ans;\n\t}\n}\nint main() { \n\tcin >> N >> K; K *= 2;\n\tfor (int i = 0; i < (1 << 17); ++i) {\n\t\tmemo[i] = -1;\n\t\tmemo2[i] = -1;\n\t}\n\t//fill(memo, memo + sizeof(memo), -1);\n\tint sum = 0;\n\tvector<vector<int>>love(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> love[i][j];\n\t\t\tsum += love[i][j];\n\t\t}\n\t}\n\t\n\tbitset<17>bs;\n\tfor (int i = 0; i < N; ++i)bs[i] = true;\n\tint ans = getans(bs, love);\n\tcout << (ans - sum )/2<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<map<Int, Int> > > dp(n+2,vector<map<Int, Int> >(n+2));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(~dp[k][d][l]) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m+1);\n  for(auto &v:a) cin>>v;\n  vector<int> b(m);\n  for(auto &v:b) cin>>v;\n  int res=0;\n  vector<pair<pair<int,int>,int>> state;\n  for(int i=0;i<m;i++){\n    state.push_back({{a[i],a[i+1]},(1<<b[i])});\n  }\n  for(int rank=n;rank>=0;rank--){\n    if(rank==0){\n      if(!(state[0].second& 1)){\n\tres++;\n      }\n      break;\n    }\n    vector<pair<pair<int,int>,int>> nex;\n    for(int i=0;i<state.size();i++){\n      int lef=state[i].first.first+state[i].first.first%2;\n      int rig=state[i].first.second-state[i].first.second%2;\n      if(lef<rig){\n\tif(!(state[i].second&(1<<rank))){\n\t  res+=(rig-lef)/2;\n\t}\n\tnex.push_back({{lef/2,rig/2},state[i].second});\n      }\n      \n      if(rig!=state[i].first.second){\n\tint val=state[i+1].second;\n\tif(state[i].second&(1<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},val});\n\t}\n\telse if(val & (1<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second});\n\t}\n\telse{\n\n\t  res++;\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second|val});\n\t}\n      }\n    }\n\n    state=nex;\n  }\n  cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<math.h>\n#include<complex>\n#include<queue>\n\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; ++i)\nusing ll = long long;\nconst ll inf = 1ll<<32;\n\nint n,m;\nvector<ll> a,b;\n\nvector<ll> solve(int k, int l, int r){\n    int nxt = *upper_bound(a.begin(),a.end(),l);\n    vector<ll> ret(n+1,inf);\n    if(nxt<r){\n        auto vl = solve(k+1,l,(l+r)/2);\n        auto vr = solve(k+1,(l+r)/2,r);\n        rep(i,n+1){\n            ret[i]=min(ret[i],vl[i]+vr[k]);\n            ret[i]=min(ret[i],vl[k]+vr[i]);\n        }\n    }\n    else {\n        int idx = upper_bound(a.begin(),a.end(),l) - a.begin();\n        --idx;\n        int cur = b[idx];\n        ll res = 0;\n        int sz = 0;\n        while((1ll<<sz)<r-l){\n            if(k+sz!=cur)res += 1ll<<sz;\n            ++sz;\n        }\n        rep(i,n+1){\n            ret[i]=res;\n            if(cur!=i)++ret[i];\n        }\n    }\n    return ret;\n}\n \nint main(){\n    cin>>n>>m;\n    a.resize(m+1);\n    b.resize(m);\n    rep(i,m+1){\n        cin>>a[i];\n    }\n    rep(i,m)cin>>b[i];\n    auto ans = solve(1,0,1<<n);\n    cout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<long long int> a(m+1);\n  for(auto &v:a) cin>>v;\n  vector<int> b(m);\n  for(auto &v:b) cin>>v;\n  long long int res=0;\n  vector<pair<pair<int,int>,long long int>> state;\n  for(int i=0;i<m;i++){\n    state.push_back({{a[i],a[i+1]},(1LL<<b[i])});\n  }\n  for(long long int rank=n;rank>=0;rank--){\n    if(rank==0){\n      if(!(state[0].second& 1LL)){\n\tres++;\n      }\n      break;\n    }\n    vector<pair<pair<int,int>,long long int>> nex;\n    for(int i=0;i<state.size();i++){\n      long long int lef=state[i].first.first+state[i].first.first%2;\n      long long int rig=state[i].first.second-state[i].first.second%2;\n      if(lef<rig){\n\tif(!(state[i].second&(1LL<<rank))){\n\t  res+=(rig-lef)/2;\n\t}\n\tnex.push_back({{lef/2,rig/2},state[i].second});\n      }\n      \n      if(rig!=state[i].first.second){\n\tlong long int val=state[i+1].second;\n\tif(state[i].second&(1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},val});\n\t}\n\telse if(val & (1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second});\n\t}\n\telse{\n\t  res++;\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second|val});\n\t}\n      }\n    }\n    state=nex;\n  }\n  cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  for(Int i=0;i<=n;i++) dp[i].reserve(1<<16);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  for(Int i=0;i<=n;i++) dp[i].reserve(1<<17);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<map<Int, Int> > > dp(n+2,vector<map<Int, Int> >(n+2));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k][d].count(l)) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long;\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m+1);\n  for(auto &v:a) cin>>v;\n  vector<int> b(m);\n  for(auto &v:b) cin>>v;\n  int res=0;\n  vector<pair<pair<int,int>,int>> state;\n  for(int i=0;i<m;i++){\n    state.push_back({{a[i],a[i+1]},(1<<b[i])});\n  }\n  for(int rank=n;rank>=0;rank--){\n    if(rank==0){\n      if(!(state[0].second& 1)){\n\tres++;\n      }\n      break;\n    }\n    vector<pair<pair<int,int>,int>> nex;\n    for(int i=0;i<state.size();i++){\n      int lef=state[i].first.first+state[i].first.first%2;\n      int rig=state[i].first.second-state[i].first.second%2;\n      if(lef<rig){\n\tif(!(state[i].second&(1<<rank))){\n\t  res+=(rig-lef)/2;\n\t}\n\tnex.push_back({{lef/2,rig/2},state[i].second});\n      }\n      \n      if(rig!=state[i].first.second){\n\tint val=state[i+1].second;\n\tif(state[i].second&(1<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},val});\n\t}\n\telse if(val & (1<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second});\n\t}\n\telse{\n\t  res++;\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second|val});\n\t}\n      }\n    }\n\n    state=nex;\n  }\n  cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n  \n  Int ans=0;\n  function<void(Int,int,Int,int)> dfs=[&](Int l,Int r,Int d,Int k){\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<\":\"<<v<<endl;\n      if(k==v) ans+=(k==v);\n      else ans+=(r-l)>>(n-v+1);\n      return;\n    }\n    Int m=(l+r)>>1;\n    //cout<<check(l,m,k)<<\":\"<<check(l,m,d)<<endl;\n    //cout<<check(m,r,k)<<\":\"<<check(m,r,d)<<endl;\n    if(check(l,m,k)&&check(m,r,d)){\n      dfs(l,m,d+1,k);\n      dfs(m,r,d+1,d);\n      return;\n    }\n    if(check(l,m,d)&&check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }    \n    if(check(l,m,d)||check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }\n    dfs(l,m,d+1,k);\n    dfs(m,r,d+1,d);\n    return;\n  };\n  \n  dfs(0,1<<n,1,0);\n  cout<<(1<<n)-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\ntypedef pair<int,int> P;\n\nint N,M;\nint POW[31];\nint table[NUM],input_rank[NUM];\nmap<P,int> dp[31];\n\nint recursive(int left,int right,int range_winner_final_input_rank,int size){\n\n\tif(range_winner_final_input_rank == size && dp[size].find(P(left,right)) != dp[size].end()){\n\t\treturn dp[size][P(left,right)];\n\t}\n\n\tint L = 0,R = M,mid = (L+R)/2;\n\tint index = 0;\n\n\twhile(L <= R){\n\n\t\tif(table[mid] <= left){\n\n\t\t\tindex = mid;\n\t\t\tL = mid+1;\n\n\t\t}else{\n\t\t\tR = mid-1;\n\t\t}\n\t\tmid = (L+R)/2;\n\t}\n\n\tint ret = BIG_NUM;\n\n\tif(index+1 <= M && table[index] <= left && table[index+1] >= right){\n\n\t\tif(input_rank[index] >= size+1){\n\n\t\t\tret = POW[N-size]-POW[N-size]/POW[N-input_rank[index]+1];\n\n\t\t}else{\n\n\t\t\tret = POW[N-size];\n\n\t\t\tif(input_rank[index] == range_winner_final_input_rank){\n\t\t\t\tret--;\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tmid = (left+right)/2;\n\t\tret = min(recursive(left,mid,range_winner_final_input_rank,size+1)+recursive(mid,right,size+1,size+1),\n \t\t\t\trecursive(left,mid,size+1,size+1)+recursive(mid,right,range_winner_final_input_rank,size+1));\n\t}\n\n\tif(range_winner_final_input_rank == size){\n\n\t\treturn dp[size][P(left,right)] = ret;\n\n\t}else{\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\n\tfor(int i = 0; i < 31; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i <= M; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d\",&input_rank[i]);\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,POW[N],0,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n  \n  Int ans=0;\n  function<void(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k){\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      ans+=(k==v);\n      ans+=(r-l)>>(n-v+1);\n      assert(!(k==v)||!(((r-l)>>(n-v+1))>0));\n      return;\n    }\n    Int m=(l+r)>>1;\n    if(check(l,m,k)&&check(m,r,d)){\n      dfs(l,m,d+1,k);\n      dfs(m,r,d+1,d);\n      return;\n    }\n    if(check(l,m,d)||check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }\n    dfs(l,m,d+1,k);\n    dfs(m,r,d+1,d);\n    return;\n  };\n  \n  dfs(0,1<<n,1,0);\n  cout<<(1<<n)-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  for(Int i=0;i<=n;i++) dp[i].reserve(1<<20);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<map<Int, Int> > > dp(n+2,vector<map<Int, Int> >(n+2));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k][d].count(l)) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nint a[10010],b[10010];\n\nmap<P,int> dp[31];\n\nint dfs(int l,int r,int t,int rank){\n  if(rank==t&&dp[t].find(P(l,r))!=dp[t].end())return dp[t][P(l,r)];\n  int idx=lower_bound(a,a+m+1,r)-a;\n  int res=-1;\n  if(idx>0&&a[idx-1]<=l&&r<=a[idx]){\n    if(b[idx-1]>=rank+1){\n      res=r-l-(1<<(b[idx-1]-rank-1));\n    }else{\n      if(b[idx-1]==t)res=r-l-1;\n      else res=r-l;\n    }\n  }else{\n    int mid=(l+r)/2;\n    res=min(dfs(l,mid,t,rank+1)+dfs(mid,r,rank+1,rank+1),dfs(l,mid,rank+1,rank+1)+dfs(mid,r,t,rank+1));\n  }\n  if(rank==t)return dp[t][P(l,r)]=res;\n  else return res;\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  rep(i,m+1)scanf(\"%d\",a+i);\n  rep(i,m)scanf(\"%d\",b+i);\n  printf(\"%d\\n\", dfs(0,1<<n,0,0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<unordered_map<Int, Int> > > dp(n+2,vector<unordered_map<Int, Int> >(n+2));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k][d].count(l)) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<long long int> a(m+1);\n  for(auto &v:a) cin>>v;\n  vector<int> b(m);\n  for(auto &v:b) cin>>v;\n  long long int res=0;\n  vector<pair<pair<int,int>,long long int>> state;\n  for(int i=0;i<m;i++){\n    state.push_back({{a[i],a[i+1]},(1LL<<b[i])});\n  }\n  for(long long int rank=n;rank>=0;rank--){\n    if(rank==0){\n      if(!(state[0].second& 1LL)){\n\tres++;\n      }\n      break;\n    }\n    vector<pair<pair<int,int>,long long int>> nex;\n    for(int i=0;i<state.size();i++){\n      long long int lef=state[i].first.first+state[i].first.first%2;\n      long long int rig=state[i].first.second-state[i].first.second%2;\n      if(lef<rig){\n\tif(!(state[i].second&(1LL<<rank))){\n\t  res+=(rig-lef)/2;\n\t}\n\tnex.push_back({{lef/2,rig/2},state[i].second});\n      }\n      \n      if(rig!=state[i].first.second){\n\tlong long int val=state[i+1].second;\n\tif(state[i].second&(1LL<<rank)){\n\t  if(val & (1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},val|state[i].second});\t    \n\t  }\n\t  else nex.push_back({{rig/2,rig/2+1},val});\n\t}\n\telse if(val & (1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second});\n\t}\n\telse{\n\t  res++;\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second|val});\n\t}\n      }\n    }\n    state=nex;\n  }\n  cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<map<Int, Int> > > dp(n+1,vector<map<Int, Int> >(n+1));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(~dp[k][d][l]) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nmap<int,int> mp;\nint N,M,a[10001],b[10000];\nint seginc(int l,int r){\n\tint x=upper_bound(a,a+M+1,l)-a-1;\n\tif(r<=a[x+1]) return x;\n\treturn -1;\n}\nint query(int l,int r,int k,int L,int j){\n\tif(j-L==N+2 && mp.count(k)) return mp[k];\n\tint in=seginc(l,r);\n\tint ret=0;\n\tif(in>=0){\n//\t\tshow(in);\n\t\tif(j==b[in]) ret=(r-l)-1;\n\t\telse if(b[in]>N-L) ret=(r-l)-( 1<<(b[in]-(N-L)-1) );\n\t\telse ret=r-l;\n\t}else{\n\t\tint x=query(l,(l+r)/2,k*2,L-1,j)+query((l+r)/2,r,k*2+1,L-1,N-L+1);\n\t\tint y=query(l,(l+r)/2,k*2,L-1,N-L+1)+query((l+r)/2,r,k*2+1,L-1,j);\n\t\tret=min(x,y);\n\t}\n\tif(j-L==N+2) mp[k]=ret;\n//\tprintf(\"k=%d,  j=%d,   ret=%d\\n\",k,j,ret);\n\treturn ret;\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M+1) cin>>a[i];\n\trep(i,M) cin>>b[i];\n\tcout<<query(0,1<<N,1,N,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m+1);\n  for(auto &v:a) cin>>v;\n  vector<int> b(m);\n  for(auto &v:b) cin>>v;\n  int res=0;\n  vector<pair<pair<int,int>,long long int>> state;\n  for(int i=0;i<m;i++){\n    state.push_back({{a[i],a[i+1]},(1LL<<b[i])});\n  }\n  for(int rank=n;rank>=0;rank--){\n    if(rank==0){\n      if(!(state[0].second& 1)){\n\tres++;\n      }\n      break;\n    }\n    vector<pair<pair<int,int>,long long int>> nex;\n    for(int i=0;i<state.size();i++){\n      int lef=state[i].first.first+state[i].first.first%2;\n      int rig=state[i].first.second-state[i].first.second%2;\n      if(lef<rig){\n\tif(!(state[i].second&(1LL<<rank))){\n\t  res+=(rig-lef)/2;\n\t}\n\tnex.push_back({{lef/2,rig/2},state[i].second});\n      }\n      \n      if(rig!=state[i].first.second){\n\tint val=state[i+1].second;\n\tif(state[i].second&(1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},val});\n\t}\n\telse if(val & (1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second});\n\t}\n\telse{\n\t  res++;\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second|val});\n\t}\n      }\n    }\n\n    state=nex;\n  }\n  cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2646\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#endif\n//BEGIN CUT HERE\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> st(h);\n  for(int i=0;i<h;i++) cin>>st[i];\n\n  vector<vector<int> > used(h,vector<int>(w,0));\n\n  auto dfs=\n    MFP([&](auto dfs,int y,int x)->void{\n          used[y][x]=1;\n          if(y  >0&&st[y-1][x]!='#'&&!used[y-1][x]) dfs(y-1,x);\n          if(y+1<h&&st[y+1][x]!='#'&&!used[y+1][x]) dfs(y+1,x);\n          if(x  >0&&st[y][x-1]!='#'&&!used[y][x-1]) dfs(y,x-1);\n          if(x+1<w&&st[y][x+1]!='#'&&!used[y][x+1]) dfs(y,x+1);\n        });\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(st[i][j]=='s') dfs(i,j);\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(st[i][j]=='g')\n        cout<<(used[i][j]?\"Yes\":\"No\")<<endl;\n  return 0;\n}\n/*\n  https://atcoder.jp/contests/atc001/tasks/dfs_a\n*/\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T,typename U, typename H=hash<T> >\nusing gmap = cc_hash_table<T, U, H>;\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned AGC023_A(){\n  using ll = long long;\n  int n;\n  scanf(\"%d\",&n);\n  vector<ll> as(n);\n  for(int i=0;i<n;i++) scanf(\"%lld\",&as[i]);\n\n  gmap<ll, ll> mp;\n  ll ans=0,sum=0;\n  mp[sum]++;\n  for(int i=0;i<n;i++){\n    sum+=as[i];\n    ans+=mp[sum];\n    mp[sum]++;\n  }\n\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n/*\n  verified on 2019/12/09\n  https://atcoder.jp/contests/agc023/tasks/agc023_a\n*/\n\nsigned main(){\n  AGC023_A();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\ntemplate<typename T>\nstruct chash{\n  uint64_t operator()(T x) const{\n    uint64_t y(x);\n    y += 0x9e3779b97f4a7c15;\n    y = (y ^ (y >> 30)) * 0xbf58476d1ce4e5b9;\n    y = (y ^ (y >> 27)) * 0x94d049bb133111eb;\n    return y ^ (y >> 31);\n  }\n};\n\nsigned main(){\n  using ll = long long;\n\n  int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<int> as(m),bs(m);\n  for(int i=0;i<m;i++) cin>>as[i];\n  for(int i=1;i<m;i++) cin>>bs[i];\n\n  vector<ll> hs;\n  MFP([&](auto dfs,int l,int r)->void{\n        int x=lower_bound(as.begin(),as.end(),r)-as.begin();\n        if(as[x-1]<=l&&r<=as[x]) return;\n        hs.emplace_back(((ll)l<<31)|r);\n        int m=(l+r)>>1;\n        dfs(l,m);\n        dfs(m,r);\n      })(0,(1<<n));\n\n  sort(hs.begin(),hs.end());\n  hs.erase(unique(hs.begin(),hs.end()),hs.end());\n\n  gmap<ll, int, chash<ll> > idx;\n  for(int i=0;i<(int)hs.size();i++) idx[hs[i]]=i;\n\n  vector< vector<int> > dp(n+1,vector<int>(hs.size(),-1));\n\n  int ans=(1<<n)-\n    MFP([&](auto dfs,int l,int r,int d,int k)->int{\n          int x=lower_bound(as.begin(),as.end(),r)-as.begin();\n          if(as[x-1]<=l&&r<=as[x]){\n            int v=bs[x],tmp=0;\n            tmp+=(k==v);\n            tmp+=(r-l)>>(n-v+1);\n            return tmp;\n          }\n\n          if(~dp[k][idx[((ll)l<<31)|r]]) return dp[k][idx[((ll)l<<31)|r]];\n          int &res=(dp[k][idx[((ll)l<<31)|r]]=0);\n\n          int m=(l+r)>>1;\n          res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n          res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n          return res;\n        })(0,1<<n,1,0);\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<unordered_map<Int, Int> > > dp(n+2,vector<unordered_map<Int, Int> >(n+2));\n  for(Int i=0;i<n+2;i++)\n    for(Int j=0;j<n+2;j++)\n      dp[i][j].reserve(1<<13);\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k][d].count(l)) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\nvector<long long int>memo(18);\nlong long int getans(const long long int num) {\n\tconst int keta = to_string(num).size();\n\tif (keta >= 2) {\n\t\treturn (num - powint(10, keta - 1) + 1)*keta + memo[keta - 1];\n\t}\n\telse {\n\t\treturn num + 1;\n\t}\n}\nlong long int getnum(const pair<long long int, int>&p) {\n\tif (p.first == 0)return p.second;\n\treturn getans(p.first - 1) - p.second;\n}\nbool check(const int f,const long long int num, const string st) {\n\tstring pre = st.substr(0, f);\n\tconst string  prenumst = to_string(num - 1);\n\tif (prenumst.substr(prenumst.size() - pre.size(), pre.size()) != pre)return false;\n\telse {\n\t\t int nf = f;\n\t\t long long int nnum = num;\n\t\twhile (nf<st.size()) {\n\t\t\tstring nnumst = to_string(nnum);\n\t\t\tstring next = st.substr(nf, nnumst.size());\n\t\t\t bool same = (next == nnumst.substr(0, next.size()));\n\t\t\t if (!same) {\n\t\t\t\t return false;\n\t\t\t }\n\t\t\tnf += nnumst.size();\n\t\t\tnnum++;\n\t\t}\n\t\treturn true;\n\t}\n}\nlong long int check2(const string from, const string to, const int keta) {\n\t\n\tint f_size = from.size();\n\tint t_size = to.size();\n\tint kaburi = f_size + t_size - keta;\n\tif (all_of(from.begin() + kaburi, from.end(), [](const char&c) {return c == '9'; })) {\n\t\tbool ok = true;\n\t\tstring kaburif = from.substr(0, kaburi);\n\t\tkaburif = kaburif.empty()?\"1\":to_string(stol(kaburif) + 1);\n\t\tif (kaburif.size() != kaburi) {\n\t\t\tstring kaburit = to.substr(t_size - kaburi, kaburi);\n\t\t\tif (kaburif.substr(1) != kaburit)ok = false;\n\t\t\tif (ok) {\n\t\t\t\tstring ans;\n\t\t\t\tans += to_string(stol(to.substr(0,t_size-kaburi))-1);\n\t\t\t\tans += from;\n\t\t\t\treturn getnum(make_pair(stoll(ans), from.size() - keta));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 3e18;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstring kaburit = to.substr(t_size - kaburi, kaburi);\n\t\t\tif (kaburif != kaburit)ok = false;\n\t\t\tif (ok) {\n\t\t\t\tstring ans;\n\t\t\t\tans += to.substr(0, t_size - kaburi);\n\t\t\t\tans += from;\n\t\t\t\treturn getnum(make_pair(stoll(ans), from.size() - keta));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 3e18;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse {\n\t\tbool ok = true;\n\t\tstring kaburif = from.substr(0, kaburi);\n\t\tstring kaburit = to.substr(t_size - kaburi, kaburi);\n\t\tif (kaburif != kaburit)ok = false;\n\t\tif (ok) {\n\t\t\tstring ans;\n\t\t\tans += to.substr(0, t_size - kaburi);\n\t\t\tans += from;\n\t\t\treturn getnum(make_pair(stoll(ans), from.size() - keta));\n\t\t}\n\t\telse {\n\t\t\treturn 3e18;\n\t\t}\n\t}\n}\n\nlong long int  solve(string st) {\n\tif (st == \"0\")return 11;\n\tif (all_of(st.begin(), st.end(), [](const char&ch) {\n\t\treturn ch == '0';\n\t})) {\n\t\treturn getnum(make_pair(stoll('1' + st), -1));\n\t}\n\tlong long int ans (1e18);\n\tfor (int keta = 1; keta <= min(17,int(st.size())); ++keta) {\n\t\tfor (int f = 0; f < min(keta,int(st.size())); ++f) {\n\t\t\tstring ast = st.substr(f, keta);\n\t\t\tif (ast.size() < keta) {\n\t\t\t\tstring from = st.substr(0, f);\n\t\t\t\tstring to = st.substr(f,st.size()-f);\n\t\t\t\tif (to[0] != '0') {\n\t\t\t\t\tans = min(ans, check2(from, to, keta));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ast[0] != '0') {\n\t\t\t\t\tlong long int num = stoll(ast);\n\t\t\t\t\tif (check(f, num, st)) {\n\t\t\t\t\t\tans = min(ans, getnum(make_pair(num, f)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tmemo[1] = 10;\n\tfor (int i = 2; i <18; ++i) {\n\t\tmemo[i] = powint(10,i-1) * (i) * 9 + memo[i - 1];\n\t}\n\twhile (1) {\n\n\t\tstring st; cin >> st;\n\t\tif (st != \"#\") {\n\n\t\t\tlong long int ans = solve(st);\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n\n  using T = tuple<Int, Int, Int>;\n  map<T, Int> dp;\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    if(dp.count(T(l,r,k))) return dp[T(l,r,k)];\n    Int &res=dp[T(l,r,k)];\n    res=0;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]);\n    assert(a[x-1]<r);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      res+=(k==v);\n      res+=(r-l)>>(n-v+1);\n      return res;\n    }\n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> a(m+1);\n  for(auto &v:a) cin>>v;\n  vector<int> b(m);\n  for(auto &v:b) cin>>v;\n  int res=0;\n  vector<pair<pair<int,int>,long long int>> state;\n  for(int i=0;i<m;i++){\n    state.push_back({{a[i],a[i+1]},(1LL<<b[i])});\n  }\n  for(int rank=n;rank>=0;rank--){\n    if(rank==0){\n      if(!(state[0].second& 1)){\n\tres++;\n      }\n      break;\n    }\n    vector<pair<pair<int,int>,long long int>> nex;\n    for(int i=0;i<state.size();i++){\n      int lef=state[i].first.first+state[i].first.first%2;\n      int rig=state[i].first.second-state[i].first.second%2;\n      if(lef<rig){\n\tif(!(state[i].second&(1LL<<rank))){\n\t  res+=(rig-lef)/2;\n\t}\n\tnex.push_back({{lef/2,rig/2},state[i].second});\n      }\n      \n      if(rig!=state[i].first.second){\n\tlong long int val=state[i+1].second;\n\tif(state[i].second&(1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},val});\n\t}\n\telse if(val & (1LL<<rank)){\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second});\n\t}\n\telse{\n\t  res++;\n\t  nex.push_back({{rig/2,rig/2+1},state[i].second|val});\n\t}\n      }\n    }\n\n    state=nex;\n  }\n  cout<<res<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  for(Int i=0;i<=n;i++) dp[i].reserve(1<<15);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef pair<int,int> P;\nmap<int,int> mp;\nint N,M,a[10001],b[10000];\nint seginc(int l,int r){\n\tint x=upper_bound(a,a+M+1,l)-a-1;\n\tif(r<=a[x+1]) return x;\n\treturn -1;\n}\nint query(int l,int r,int k,int L,int j){\n\tif(j+L==N && mp.count(k)) return mp[k];\n\tint in=seginc(l,r);\n\tint ret=0;\n\tif(in>=0){\n\t\tif(j==b[in]) ret=(r-l)-1;\n\t\telse if(b[in]>N-L) ret=(r-l)-( 1<<(b[in]-(N-L)-1) );\n\t\telse ret=r-l;\n\t}else{\n\t\tint x=query(l,(l+r)/2,k*2,L-1,j)+query((l+r)/2,r,k*2+1,L-1,N-L+1);\n\t\tint y=query(l,(l+r)/2,k*2,L-1,N-L+1)+query((l+r)/2,r,k*2+1,L-1,j);\n\t\tret=min(x,y);\n\t}\n\tif(j+L==N) mp[k]=ret;\n\treturn ret;\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M+1) cin>>a[i];\n\trep(i,M) cin>>b[i];\n\tcout<<query(0,1<<N,1,N,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  \n  vector<vector<unordered_map<Int, Int> > > dp(n+2,vector<unordered_map<Int, Int> >(n+2));\n  for(Int i=0;i<n+2;i++)\n    for(Int j=0;j<n+2;j++)\n      dp[i][j].reserve(1<<15);\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k][d].count(l)) return dp[k][d][l];\n    Int &res=(dp[k][d][l]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  for(Int i=0;i<=n;i++) dp[i].reserve(1<<18);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint N, M;\nvector<int>as;\nvector<int>bs;\nvector<int> getans(const int l, const int r,const int depth) {\n\tauto lit = upper_bound(as.begin(), as.end(),l);\n\tauto rit = lower_bound(as.begin(), as.end(), r);\n\tif (lit == rit) {\n\t\tint rank = bs[prev(lit) - as.begin()];\n\t\tvector<int>nums(N+1);\n\t\tint rest = (r - l) / 2;\n\t\tint ok = 0;\n\t\tfor (int i = N; i >=0; --i) {\n\t\t\tnums[i] = rest;\n\t\t\tif (i == rank)ok = rest;\n\t\t\trest /= 2;\n\t\t}\n\t\tvector<int>anss(N + 1);\n\t\tfor (int i = 0; i <= depth; ++i) {\n\t\t\tanss[i] = ok+((i==rank)?1:0);\n\t\t}\n\t\treturn anss;\n\t}\n\telse {\n\t\tauto lans(getans(l, (l + r) / 2, depth + 1));\n\t\tauto rans(getans((l + r) / 2, r, depth + 1));\n\t\tvector<int>anss(N + 1);\n\t\tfor (int i = 0; i <=depth; ++i) {\n\t\t\tanss[i] = max(anss[i], lans[i] + rans[depth+1]);\n\t\t}\n\t\tfor (int i = 0; i <=depth; ++i) {\n\t\t\tanss[i] = max(anss[i], rans[i] + lans[depth+1]);\n\t\t}\n\t\treturn anss;\n\t}\n}\nint main() {cin >> N >> M;\n\tas.resize(M + 1);\n\tbs.resize(M);\n\tfor (int i = 0; i <= M; ++i) {\n\t\tcin >> as[i];\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> bs[i];\n\t}\n\tauto v= getans(0, (1 << N),0);\n\tcout << (1<<N)-v[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconstexpr int MAX = 10000;\nint a[MAX + 1], b[MAX];\nusing P = std::pair<int, int>;\nstd::map<P, int> memo[31];\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    int N, M;\n    std::cin >> N >> M;\n    for (int i = 0; i <= M; i++) { std::cin >> a[i]; }\n    for (int i = 0; i < M; i++) { std::cin >> b[i]; }\n    auto dp = [&](auto&& self, const int l, const int r, const int maxord, const int height) -> int {\n        const int w = r - l;\n        if (maxord == height and memo[maxord].find({l, r}) != memo[maxord].end()) { return memo[maxord][{l, r}]; }\n        int ans = 0;\n        const int ind = std::lower_bound(a, a + M + 1, r) - a;\n        if (a[ind - 1] <= l) {\n            const int ord = b[ind - 1];\n            if (ord - height >= 1) {\n                ans = w - (1 << (ord - height - 1));\n            } else {\n                if (ord == maxord) {\n                    ans = w - 1;\n                } else {\n                    ans = w;\n                }\n            }\n        } else {\n            const int mid = (l + r) / 2;\n            ans = std::min(self(self, l, mid, maxord, height + 1) + self(self, mid, r, height + 1, height + 1), self(self, l, mid, height + 1, height + 1) + self(self, mid, r, maxord, height + 1));\n        }\n        if (height == maxord) {\n            return memo[maxord][{l, r}] = ans;\n        } else {\n            return ans;\n        }\n    };\n    std::cout << dp(dp, 0, 1 << N, 0, 0) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  vector<ll> hs;\n  function<void(Int, Int)> predfs=[&](Int l,Int r){\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]) return;\n    \n    hs.emplace_back(((ll)l<<31)|r);\n    Int m=(l+r)>>1;\n    predfs(l,m);\n    predfs(m,r);\n  };\n\n  predfs(0,(1<<n));\n  sort(hs.begin(),hs.end());\n  hs.erase(unique(hs.begin(),hs.end()),hs.end());\n  map<ll, Int> idx;\n  for(Int i=0;i<(Int)hs.size();i++) idx[hs[i]]=i;\n  //cout<<hs.size()<<endl;\n  \n  vector<vector<Int> > dp(n+1,vector<Int>(hs.size(),-1));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(~dp[k][idx[((ll)l<<31)|r]]) return dp[k][idx[((ll)l<<31)|r]];\n    Int &res=(dp[k][idx[((ll)l<<31)|r]]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n  \n  Int ans=0;\n  function<void(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k){\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]);\n    assert(a[x-1]<r);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      ans+=(k==v);\n      ans+=(r-l)>>(n-v+1);\n      assert(!(k==v)||!(((r-l)>>(n-v+1))>0));\n      return;\n    }\n    Int m=(l+r)>>1;\n    if(check(l,m,k)&&check(m,r,d)){\n      dfs(l,m,d+1,k);\n      dfs(m,r,d+1,d);\n      return;\n    }\n    if(check(l,m,d)||check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }\n    dfs(l,m,d+1,k);\n    dfs(m,r,d+1,d);\n    return;\n  };\n  \n  dfs(0,1<<n,1,0);\n  cout<<(1<<n)-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nint a[10010],b[10010];\n\nmap<P,int> dp[31];\n\nint dfs(int l,int r,int t,int rank){\n  if(dp[t].find(P(l,r))!=dp[t].end())return dp[t][P(l,r)];\n  int idx=lower_bound(a,a+m+1,r)-a;\n  int res=-1;\n  if(idx>0&&a[idx-1]<=l&&r<=a[idx]){\n    if(b[idx-1]>=rank+1){\n      res=r-l-(1<<(b[idx-1]-rank-1));\n    }else{\n      if(b[idx-1]==t)res=r-l-1;\n      else res=r-l;\n    }\n  }else{\n    int mid=(l+r)/2;\n    res=min(dfs(l,mid,t,rank+1)+dfs(mid,r,rank+1,rank+1),dfs(l,mid,rank+1,rank+1)+dfs(mid,r,t,rank+1));\n  }\n  if(r-l<=(1<<18))return dp[t][P(l,r)]=res;\n  else return res;\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  rep(i,m+1)scanf(\"%d\",a+i);\n  rep(i,m)scanf(\"%d\",b+i);\n  printf(\"%d\\n\", dfs(0,1<<n,0,0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<Int , Int> > dp(n+1);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    if(dp[k].count((l<<31)|r)) return dp[k][(l<<31)|r];\n    Int &res=dp[k][(l<<31)|r];\n    res=0;\n\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]&&a[x-1]<r);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      res+=(k==v);\n      res+=(r-l)>>(n-v+1);\n      return res;\n    }\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint z[20000];\nint num[20000];\nint a,b;\npair<int,int> dfs(int d,int l,int r){\n\tint L=upper_bound(z,z+b+1,l)-z-1;\n\tint R=upper_bound(z,z+b+1,r)-z-1;\n\t//printf(\"%d %d %d: %d %d\\n\",d,l,r,L,R);\n\tif(l==r){\n\t\treturn make_pair(0,1<<num[L]);\n\t}\n\tif(L==R){\n\t\tif(num[L]<=d){\n\t\t\treturn make_pair(r-l,1<<num[L]);\n\t\t}\n\t\tint ad=0;\n\t\tfor(int i=0;i<=d;i++)ad+=(1<<i);\n\t//\tprintf(\"%d %d %d: %d %d %d\\n\",d,l,r,num[L],(r-l+1)-(r-l+1)/(1<<(1+a-num[L])),ad);\n\t\treturn make_pair((r-l+1)-(r-l+1)/(1<<(1+a-num[L])),ad);\n\t}\n\tpair<int,int>lv=dfs(d+1,l,(l+r)/2);\n\tpair<int,int>rv=dfs(d+1,(l+r)/2+1,r);\n\tint can=0;\n\tif(lv.second&(1<<(d+1))){\n\t\tcan|=rv.second;\n\t}\n\tif(rv.second&(1<<(d+1))){\n\t\tcan|=lv.second;\n\t}\n\tif(can&(1<<(d+1)))can-=(1<<(d+1));\n\tif(can){\n\t//\tprintf(\"%d %d %d: %d %d\\n\",d,l,r,lv.first+rv.first,can);\n\t\treturn make_pair(lv.first+rv.first,can);\n\t}\n\tint ad=lv.second|rv.second;\n\tfor(int i=d+1;i<=a;i++)if(ad&(1<<i))ad-=(1<<i);\n\tif(ad){\n\t\t//printf(\"%d %d %d: %d %d\\n\",d,l,r,lv.first+rv.first+1,ad);\n\t\treturn make_pair(lv.first+rv.first+1,ad);\n\t}\n\tad=0;\n\tfor(int i=0;i<=d;i++)ad+=(1<<i);\n//\tprintf(\"%d %d %d: %d %d\\n\",d,l,r,lv.first+rv.first+2,ad);\n\treturn make_pair(lv.first+rv.first+1,ad);\n}\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b+1;i++){\n\t\tscanf(\"%d\",z+i);\n\t}\n\tfor(int i=0;i<b;i++)scanf(\"%d\",num+i);\n\t/*for(int i=0;i<=a;i++){\n\t\tint len=1<<(a-i);\n\t\tfor(int j=0;j<=a;j++){\n\t\t\t\n\t\t}\n\t}*/\n\tprintf(\"%d\\n\",dfs(0,0,(1<<a)-1).first);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n  \n  Int ans=0;\n  function<void(Int,int,Int,int)> dfs=[&](Int l,Int r,Int d,Int k){\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<\":\"<<v<<endl;\n      ans+=(k==v);\n      ans+=(r-l)>>(n-v+1);\n      return;\n    }\n    Int m=(l+r)>>1;\n    //cout<<check(l,m,k)<<\":\"<<check(l,m,d)<<endl;\n    //cout<<check(m,r,k)<<\":\"<<check(m,r,d)<<endl;\n    if(check(l,m,k)&&check(m,r,d)){\n      dfs(l,m,d+1,k);\n      dfs(m,r,d+1,d);\n      return;\n    }\n    if(check(l,m,d)&&check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }    \n    if(check(l,m,d)||check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }\n    dfs(l,m,d+1,k);\n    dfs(m,r,d+1,d);\n    return;\n  };\n  \n  dfs(0,1<<n,1,0);\n  cout<<(1<<n)-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nint a[10010],b[10010];\n\nmap<P,int> dp[31];\n\nint dfs(int l,int r,int t,int rank){\n  if(dp[t].find(P(l,r))!=dp[t].end())return dp[t][P(l,r)];\n  int idx=lower_bound(a,a+m+1,r)-a;\n  int res=-1;\n  if(idx>0&&a[idx-1]<=l&&r<=a[idx]){\n    if(b[idx-1]>=rank+1){\n      res=r-l-(1<<(b[idx-1]-rank-1));\n    }else{\n      if(b[idx-1]==t)res=r-l-1;\n      else res=r-l;\n    }\n  }else{\n    int mid=(l+r)/2;\n    res=min(dfs(l,mid,t,rank+1)+dfs(mid,r,rank+1,rank+1),dfs(l,mid,rank+1,rank+1)+dfs(mid,r,t,rank+1));\n  }\n  if(r-l<=(1<<20))return dp[t][P(l,r)]=res;\n  else return res;\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  rep(i,m+1)scanf(\"%d\",a+i);\n  rep(i,m)scanf(\"%d\",b+i);\n  printf(\"%d\\n\", dfs(0,1<<n,0,0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,int> mp;\nint N,M,a[10001],b[10000];\nint seginc(int l,int r){\n\tint x=upper_bound(a,a+M+1,l)-a-1;\n\tif(r<=a[x+1]) return x;\n\treturn -1;\n}\nint query(int l,int r,int k,int L,int j){\n\tif(mp.count(P(k,j))) return mp[P(k,j)];\n\tint in=seginc(l,r);\n\tint ret=0;\n\tif(in>=0){\n//\t\tshow(in);\n\t\tif(j==b[in]) ret=(r-l)-1;\n\t\telse if(b[in]>N-L) ret=(r-l)-( 1<<(b[in]-(N-L)-1) );\n\t\telse ret=r-l;\n\t}else{\n\t\tint x=query(l,(l+r)/2,k*2,L-1,j)+query((l+r)/2,r,k*2+1,L-1,N-L+1);\n\t\tint y=query(l,(l+r)/2,k*2,L-1,N-L+1)+query((l+r)/2,r,k*2+1,L-1,j);\n\t\tret=min(x,y);\n\t}\n\tmp[P(k,j)]=ret;\n//\tprintf(\"k=%d,  j=%d,   ret=%d\\n\",k,j,ret);\n\treturn ret;\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M+1) cin>>a[i];\n\trep(i,M) cin>>b[i];\n\tcout<<query(0,1<<N,1,N,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <tuple>\n\nusing e_type = uintmax_t;\nusing r_type = size_t;\nusing p_type = std::pair<e_type, r_type>;\n\nstd::vector<p_type> encode(std::vector<p_type> const& orig) {\n  r_type cur = 0;\n  std::vector<p_type> res;\n  for (auto const& p: orig) {\n    e_type e;\n    r_type r;\n    std::tie(e, r) = p;\n    if (r == 0) continue;\n    if (cur & 1) {\n      ++cur;\n      res.emplace_back(e, 1);\n      --r;\n    }\n    if (r == 0) continue;\n    r_type b = (r & 1);\n    r ^= b;\n    if (r) {\n      cur += r;\n      res.emplace_back(e, r);\n    }\n    if (b) {\n      cur += b;\n      res.emplace_back(e, b);\n    }\n  }\n  // fprintf(stderr, \"cur: %zu\\n\", cur);\n  return res;\n}\n\nr_type nya(std::vector<p_type>& enc, e_type tg) {\n  r_type res = 0;\n  std::vector<p_type> next;\n  while (!enc.empty()) {\n    p_type s = enc.back();\n    enc.pop_back();\n    e_type es;\n    r_type rs;\n    std::tie(es, rs) = s;\n    if (rs > 1) {\n      if (!(tg & es)) {\n        res += rs / 2;\n      }\n      next.emplace_back(es & (tg-1), rs/2);\n      continue;\n    }\n    assert(!enc.empty());\n    p_type t = enc.back();\n    enc.pop_back();\n    e_type et;\n    r_type rt;\n    std::tie(et, rt) = t;\n    assert(rs == 1 && rt == 1);\n    if ((tg & es) && (tg & et)) {\n      next.emplace_back((es | et) & (tg-1), 1);\n    } else if (tg & es) {\n      next.emplace_back(et & (tg-1), 1);\n    } else if (tg & et) {\n      next.emplace_back(es & (tg-1), 1);\n    } else {\n      next.emplace_back((es | et) & (tg-1), 1);\n      ++res;\n    }\n  }\n  enc = encode(next);\n  return res;\n}\n\nint main() {\n  size_t n, m;\n  scanf(\"%zu %zu\", &n, &m);\n\n  std::vector<r_type> a(m+1);\n  for (auto& ai: a) scanf(\"%zu\", &ai);\n  std::vector<e_type> b(m);\n  for (auto& bi: b) {\n    scanf(\"%ju\", &bi);\n    bi = 1 << bi;\n  }\n\n  std::vector<p_type> input;\n  for (size_t i = 0; i < m; ++i) {\n    // fprintf(stderr, \"b[%zu], a[%zu:%zu]\\n\", i, i+1, i);\n    // fprintf(stderr, \"emplace_back(%jd, %zu)\\n\", b[i], a[i+1]-a[i]);\n    input.emplace_back(b[i], a[i+1]-a[i]);\n  }\n  std::vector<p_type> enc = encode(input);\n  r_type res = 0;\n  for (size_t i = 0; i < n; ++i) {\n    res += nya(enc, 1 << (n-i));\n  }\n\n  assert(enc.size() == 1);\n  {\n    e_type e;\n    r_type r;\n    std::tie(e, r) = enc[0];\n    if (!(e & 1)) ++res;\n  }\n\n  printf(\"%zu\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<int> a(m + 1), b(m);\n    for(auto& x : a) cin >> x;\n    for(auto& x : b) cin >> x;\n\n    vector<map<pii, int>> dp(n + 1);\n    // consider ['l', 'r'), 'd' is depth, 'final_rank' represents this block winner's rank (2^r)\n    function<int(int, int, int, int)> solve = [&] (int l, int r, int d, int final_rank) {\n        if(final_rank == d && dp[final_rank].count({l, r})) return dp[final_rank][{l, r}];\n        const int i = lower_bound(begin(a), end(a), r) - begin(a) - 1;\n        int res = 0;\n        if(0 <= i && a[i] <= l && r <= a[i + 1]) { // contain completely\n            if(b[i] >= d + 1) {\n                res = r - l - (r - l) / (1 << (n - b[i] + 1));\n            } else {\n                res = r - l - (b[i] == final_rank);\n            }\n        } else { // choose which block win\n            const int mid = (l + r) / 2;\n            res = min(solve(l, mid, d + 1, final_rank) + solve(mid, r, d + 1, d + 1),\n                      solve(l, mid, d + 1, d + 1) + solve(mid, r, d + 1, final_rank));\n        }\n        if(final_rank == d) return dp[final_rank][{l, r}] = res;\n        else return res;\n    };\n\n    cout << solve(0, 1 << n, 0, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  vector<Int> hs;\n  function<void(Int, Int)> predfs=[&](Int l,Int r){\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]) return;\n     \n    hs.emplace_back(l);\n    Int m=(l+r)>>1;\n    predfs(l,m);\n    predfs(m,r);\n  };\n \n  predfs(0,(1<<n));\n  sort(hs.begin(),hs.end());\n  hs.erase(unique(hs.begin(),hs.end()),hs.end());\n  map<Int, Int> idx;\n  for(Int i=0;i<(Int)hs.size();i++) idx[hs[i]]=i;\n  auto dp=make_v<Int>(n+2,n+2,hs.size());\n  fill_v(dp,-1);\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(~dp[k][d][idx[l]]) return dp[k][d][idx[l]];\n    Int &res=(dp[k][d][idx[l]]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<map<ll , Int> > dp(n+1);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=(dp[k][((ll)l<<31)|r]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n\n  using T = tuple<Int, Int, Int>;\n  map<T, Int> dp;\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    if(dp.count(T(l,r,k))) return dp[T(l,r,k)];\n    Int &res=dp[T(l,r,k)];\n    res=0;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]);\n    assert(a[x-1]<r);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      res+=(k==v);\n      res+=(r-l)>>(n-v+1);\n      return res;\n    }\n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  vector<Int> hs;\n  function<void(Int, Int)> predfs=[&](Int l,Int r){\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]) return;\n     \n    hs.emplace_back(l);\n    Int m=(l+r)>>1;\n    predfs(l,m);\n    predfs(m,r);\n  };\n \n  predfs(0,(1<<n));\n  sort(hs.begin(),hs.end());\n  hs.erase(unique(hs.begin(),hs.end()),hs.end());\n  map<Int, Int> idx;\n  for(Int i=0;i<(Int)hs.size();i++) idx[hs[i]]=i;\n  auto dp=make_v<Int>(n+2,n+2,hs.size());\n  fill_v(dp,-1);\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(~dp[k][d][idx[l]]) return dp[k][d][idx[l]];\n    Int &res=(dp[k][d][idx[l]]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long ;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<map<P , Int> > dp(n+1);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    if(dp[k].count(P(l,r))) return dp[k][P(l,r)];\n    Int &res=dp[k][P(l,r)];\n    res=0;\n\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]&&a[x-1]<r);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      res+=(k==v);\n      res+=(r-l)>>(n-v+1);\n      return res;\n    }\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  //using P = pair<Int, Int>;\n  vector<unordered_map<ll , Int> > dp(n+1);\n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    if(dp[k].count(((ll)l<<31)|r)) return dp[k][((ll)l<<31)|r];\n    Int &res=dp[k][((ll)l<<31)|r];\n    res=0;\n\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    assert(r<=a[x]&&a[x-1]<r);\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      res+=(k==v);\n      res+=(r-l)>>(n-v+1);\n      return res;\n    }\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\nusing ll = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  vector<ll> hs;\n  function<void(Int, Int)> predfs=[&](Int l,Int r){\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]) return;\n    \n    hs.emplace_back(((ll)l<<31)|r);\n    Int m=(l+r)>>1;\n    predfs(l,m);\n    predfs(m,r);\n  };\n\n  predfs(0,(1<<n));\n  sort(hs.begin(),hs.end());\n  hs.erase(unique(hs.begin(),hs.end()),hs.end());\n  map<ll, Int> idx;\n  for(Int i=0;i<(Int)hs.size();i++) idx[hs[i]]=i;\n  //cout<<hs.size()<<endl;\n  \n  vector<vector<Int> > dp(n+1,vector<Int>(hs.size(),-1));\n  \n  function<Int(Int, Int, Int, Int)> dfs=[&](Int l,Int r,Int d,Int k)->Int{\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x],tmp=0;\n      tmp+=(k==v);\n      tmp+=(r-l)>>(n-v+1);\n      return tmp;\n    }\n\n    if(~dp[k][idx[((ll)l<<31)|r]]) return dp[k][idx[((ll)l<<31)|r]];\n    Int &res=(dp[k][idx[((ll)l<<31)|r]]=0);\n    \n    Int m=(l+r)>>1;\n    res=max(res,dfs(l,m,d+1,d)+dfs(m,r,d+1,k));\n    res=max(res,dfs(l,m,d+1,k)+dfs(m,r,d+1,d));\n    return res;\n  };\n  \n  cout<<(1<<n)-dfs(0,1<<n,1,0)<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  Int n,m;\n  cin>>n>>m;\n\n  m++;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n  for(Int i=1;i<m;i++) cin>>b[i];\n\n  using P = pair<Int, Int>;\n  vector<set<P> > ss(n+1);\n  for(Int i=0;i<=n;i++){\n    ss[i].emplace(-1,-1);\n    ss[i].emplace((1<<n)+1,(1<<n)+1);\n  }\n  for(Int i=1;i<m;i++)\n    ss[b[i]].emplace(a[i-1],a[i]);\n\n  auto intersect=[&](Int a,Int b,Int c,Int d){\n    if(a>c) swap(a,c),swap(b,d);\n    //cout<<a<<\" \"<<b<<\":::\"<<c<<\" \"<<d<<endl;\n    return c<b;\n  };\n  \n  auto check=[&](Int l,Int r,Int k)->Int{\n    auto latte=ss[k].lower_bound(P(l,-1));\n    if(intersect(l,r,latte->first,latte->second)) return 1;\n    --latte;\n    return (intersect(l,r,latte->first,latte->second));    \n  };\n  \n  Int ans=0;\n  function<void(Int,int,Int,int)> dfs=[&](Int l,Int r,Int d,Int k){\n    //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<endl;\n    Int x=lower_bound(a.begin(),a.end(),r)-a.begin();\n    if(a[x-1]<=l&&r<=a[x]){\n      Int v=b[x];\n      //cout<<l<<\" \"<<r<<\" \"<<d<<\" \"<<k<<\":\"<<v<<endl;\n      ans+=(k==v);\n      ans+=(r-l)>>(n-v+1);\n      //cout<<k<<\" \"<<v<<\" \"<<((r-l)>>(n-v+1))<<endl;\n      assert(!(k==v)||!(((r-l)>>(n-v+1))>0));\n      return;\n    }\n    Int m=(l+r)>>1;\n    //cout<<check(l,m,k)<<\":\"<<check(l,m,d)<<endl;\n    //cout<<check(m,r,k)<<\":\"<<check(m,r,d)<<endl;\n    if(check(l,m,k)&&check(m,r,d)){\n      dfs(l,m,d+1,k);\n      dfs(m,r,d+1,d);\n      return;\n    }\n    if(check(l,m,d)&&check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }    \n    if(check(l,m,d)||check(m,r,k)){\n      dfs(l,m,d+1,d);\n      dfs(m,r,d+1,k);\n      return;\n    }\n    dfs(l,m,d+1,k);\n    dfs(m,r,d+1,d);\n    return;\n  };\n  \n  dfs(0,1<<n,1,0);\n  cout<<(1<<n)-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nint a[10010],b[10010];\n\nmap<P,int> dp[31];\n\nint dfs(int l,int r,int t,int rank){\n  if(dp[t].find(P(l,r))!=dp[t].end())return dp[t][P(l,r)];\n  int idx=lower_bound(a,a+m+1,r)-a;\n  int res=-1;\n  if(idx>0&&a[idx-1]<=l&&r<=a[idx]){\n    if(b[idx-1]>=rank+1){\n      res=r-l-(1<<(b[idx-1]-rank-1));\n    }else{\n      if(b[idx-1]==t)res=r-l-1;\n      else res=r-l;\n    }\n  }else{\n    int mid=(l+r)/2;\n    res=min(dfs(l,mid,t,rank+1)+dfs(mid,r,rank+1,rank+1),dfs(l,mid,rank+1,rank+1)+dfs(mid,r,t,rank+1));\n  }\n  return dp[t][P(l,r)]=res;\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,m+1)cin>>a[i];\n  rep(i,m)cin>>b[i];\n  cout<<dfs(0,1<<n,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic int n, m;\n\tstatic long[] a;\n\tstatic int[] b;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\ta = new long[m + 1];\n\t\tb = new int[m];\n\t\tfor (int i = 0; i < m + 1; ++i) {\n\t\t\ta[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tlong[] ret = dfs(0, 1 << n, 0);\n\t\tSystem.out.println(ret[0]);\n\t}\n\n\tstatic long[] dfs(int l, int r, int depth) {\n\t\tint lIdx = binarySearch(a, l);\n\t\tint rIdx = lIdx + 1;\n\t\tif (a[lIdx] <= l && r <= a[rIdx]) {\n\t\t\tlong[] ret = new long[n + 1];\n\t\t\tif (b[lIdx] > depth) {\n\t\t\t\tArrays.fill(ret, (1L << (n - depth)) - (1L << (b[lIdx] - 1 - depth)));\n\t\t\t} else {\n\t\t\t\tArrays.fill(ret, 1L << (n - depth));\n\t\t\t\tret[b[lIdx]] -= 1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tlong[] lDp = dfs(l, (l + r) / 2, depth + 1);\n\t\t\tlong[] rDp = dfs((l + r) / 2, r, depth + 1);\n\t\t\tlong[] ret = new long[n + 1];\n\t\t\tArrays.fill(ret, Long.MAX_VALUE / 16);\n\t\t\tfor (int i = 0; i <= depth; ++i) {\n\t\t\t\tret[i] = Math.min(lDp[depth + 1] + rDp[i], lDp[i] + rDp[depth + 1]);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t// key??\\?????????????????????????????????\n\tstatic int binarySearch(long[] arr, long key) {\n\t\tint left = 0;\n\t\tint right = arr.length;\n\t\twhile (right - left > 1) {\n\t\t\tint middle = (left + right) / 2;\n\t\t\tif (arr[middle] <= key)\n\t\t\t\tleft = middle;\n\t\t\telse\n\t\t\t\tright = middle;\n\t\t}\n\t\treturn left;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M = map(int, readline().split())\n    *A, = map(int, readline().split())\n    *B, = map(int, readline().split())\n    C = []\n    prv = 0\n    for i in range(M):\n        C.append((A[i+1] - prv, 1 << B[i]))\n        prv = A[i+1]\n    ans = 0\n    for i in range(N-1, -1, -1):\n        v = 1 << (i+1)\n        C1 = []\n        r = 0; p = 0\n        for c, b in C:\n            if r:\n                if (b & v) == (p & v) > 0:\n                    b0 = b | p\n                elif b & v:\n                    b0 = p\n                elif p & v:\n                    b0 = b\n                else:\n                    b0 = b | p\n                    ans += 1\n                if C1 and C1[-1][1] == b0:\n                    c1, b1 = C1.pop()\n                    C1.append((1+c1, b0))\n                else:\n                    C1.append((1, b0))\n                c -= 1\n            if c > 1:\n                if b & v == 0:\n                    ans += c // 2\n                if C1 and C1[-1][1] == b:\n                    c1, b1 = C1.pop()\n                    C1.append((c//2+c1, b))\n                else:\n                    C1.append((c//2, b))\n            if c % 2:\n                r = 1; p = b\n            else:\n                r = 0\n        C = C1\n    c, p = C[0]\n    if p & 1 == 0:\n        ans += 1\n    write(\"%d\\n\" % ans)\nsolve()\n"
  }
]