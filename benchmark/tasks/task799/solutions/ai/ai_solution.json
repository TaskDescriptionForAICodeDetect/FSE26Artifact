[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int A[N], B[M];\n    for (int i = 0; i < N; i++)\n        scanf(\"%d\", &A[i]);\n    \n    for (int j = 0; j < M; j++)\n        scanf(\"%d\", &B[j]);\n    \n    int grid[N][M];\n    int used[N * M + 1];\n    memset(used, 0, sizeof(used));\n    \n    long long ways = 1;\n    \n    for (int i = 0; i < N; i++) {\n        int max_row = 0;\n        for (int j = 0; j < M; j++) {\n            int val = (i + 1) * (j + 1);\n            if (val > A[i]) break;\n            \n            if (used[val]) {\n                ways = 0;\n                break;\n            }\n            \n            grid[i][j] = val;\n            used[val] = 1;\n            max_row = val;\n        }\n        \n        if (max_row != A[i]) {\n            ways = 0;\n            break;\n        }\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    for (int j = 0; j < M; j++) {\n        int max_col = 0;\n        for (int i = 0; i < N; i++) {\n            int val = grid[i][j];\n            \n            if (val > B[j]) {\n                ways = 0;\n                break;\n            }\n            \n            if (used[val]) {\n                ways = 0;\n                break;\n            }\n            \n            used[val] = 1;\n            max_col = val;\n        }\n        \n        if (max_col != B[j]) {\n            ways = 0;\n            break;\n        }\n    }\n    \n    for (int i = 1; i <= N * M; i++) {\n        if (!used[i])\n            ways = (ways * i) % MOD;\n    }\n    \n    printf(\"%lld\\n\", ways);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\nll factorial(ll n) {\n    ll res = 1;\n    for (ll i = 2; i <= n; i++) {\n        res = (res * i) % MOD;\n    }\n    return res;\n}\n\nll power(ll a, ll b) {\n    ll res = 1;\n    a = a % MOD;\n    while (b > 0) {\n        if (b & 1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inv(ll x) {\n    return power(x, MOD - 2);\n}\n\nint main() {\n    ll N, M;\n    scanf(\"%lld %lld\", &N, &M);\n\n    ll *A = (ll *)malloc((N + 1) * sizeof(ll));\n    ll *B = (ll *)malloc((M + 1) * sizeof(ll));\n\n    for (ll i = 1; i <= N; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n    for (ll j = 1; j <= M; j++) {\n        scanf(\"%lld\", &B[j]);\n    }\n\n    ll *A_sorted = (ll *)malloc((N + 1) * sizeof(ll));\n    ll *B_sorted = (ll *)malloc((M + 1) * sizeof(ll));\n\n    memcpy(A_sorted, A, (N + 1) * sizeof(ll));\n    memcpy(B_sorted, B, (M + 1) * sizeof(ll));\n\n    for (ll i = 1; i <= N; i++) {\n        for (ll j = i + 1; j <= N; j++) {\n            if (A_sorted[i] > A_sorted[j]) {\n                ll temp = A_sorted[i];\n                A_sorted[i] = A_sorted[j];\n                A_sorted[j] = temp;\n            }\n        }\n    }\n\n    for (ll i = 1; i <= M; i++) {\n        for (ll j = i + 1; j <= M; j++) {\n            if (B_sorted[i] > B_sorted[j]) {\n                ll temp = B_sorted[i];\n                B_sorted[i] = B_sorted[j];\n                B_sorted[j] = temp;\n            }\n        }\n    }\n\n    ll *AB = (ll *)malloc((N + M + 1) * sizeof(ll));\n    ll a_ptr = 1, b_ptr = 1, ab_ptr = 1;\n    while (a_ptr <= N && b_ptr <= M) {\n        if (A_sorted[a_ptr] < B_sorted[b_ptr]) {\n            AB[ab_ptr++] = A_sorted[a_ptr++];\n        } else if (A_sorted[a_ptr] > B_sorted[b_ptr]) {\n            AB[ab_ptr++] = B_sorted[b_ptr++];\n        } else {\n            AB[ab_ptr++] = A_sorted[a_ptr++];\n            b_ptr++;\n        }\n    }\n    while (a_ptr <= N) AB[ab_ptr++] = A_sorted[a_ptr++];\n    while (b_ptr <= M) AB[ab_ptr++] = B_sorted[b_ptr++];\n    ll total = ab_ptr - 1;\n\n    if (total != N * M) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    ll *cnt_A = (ll *)calloc((N * M + 1), sizeof(ll));\n    ll *cnt_B = (ll *)calloc((N * M + 1), sizeof(ll));\n    ll *cnt = (ll *)calloc((N * M + 1), sizeof(ll));\n\n    for (ll i = 1; i <= N; i++) cnt_A[A[i]]++;\n    for (ll j = 1; j <= M; j++) cnt_B[B[j]]++;\n    for (ll i = 1; i <= N * M; i++) cnt[i] = cnt_A[i] + cnt_B[i];\n\n    ll res = 1;\n    ll a_prev = 0, b_prev = 0;\n    for (ll i = 1; i <= N * M; i++) {\n        if (cnt_A[i] && cnt_B[i]) {\n            res = res * factorial(cnt_A[i]) % MOD;\n            res = res * factorial(cnt_B[i]) % MOD;\n        } else if (cnt_A[i]) {\n            res = res * factorial(cnt_A[i]) % MOD;\n            res = res * power(factorial(b_prev), cnt_A[i]) % MOD;\n            a_prev += cnt_A[i];\n        } else if (cnt_B[i]) {\n            res = res * factorial(cnt_B[i]) % MOD;\n            res = res * power(factorial(a_prev), cnt_B[i]) % MOD;\n            b_prev += cnt_B[i];\n        }\n    }\n\n    printf(\"%lld\\n\", res);\n\n    free(A);\n    free(B);\n    free(A_sorted);\n    free(B_sorted);\n    free(AB);\n    free(cnt_A);\n    free(cnt_B);\n    free(cnt);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N), B(M);\n    for (int i = 0; i < N; ++i) cin >> A[i];\n    for (int j = 0; j < M; ++j) cin >> B[j];\n\n    sort(A.begin(), A.end());\n    sort(B.begin(), B.end());\n\n    if (A.back() != B.back()) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    long long res = 1;\n    int i = N - 2, j = M - 2;\n    int cnt = 0;\n\n    while (i >= 0 || j >= 0) {\n        int current;\n        if (i >= 0 && j >= 0) {\n            current = max(A[i], B[j]);\n        } else if (i >= 0) {\n            current = A[i];\n        } else {\n            current = B[j];\n        }\n\n        int a_cnt = 0, b_cnt = 0;\n        while (i >= 0 && A[i] == current) {\n            a_cnt++;\n            i--;\n        }\n        while (j >= 0 && B[j] == current) {\n            b_cnt++;\n            j--;\n        }\n\n        if (current == A.back()) {\n            cnt += a_cnt + b_cnt;\n            continue;\n        }\n\n        if (a_cnt == 0 || b_cnt == 0) {\n            res = 0;\n            break;\n        }\n\n        long long ways = 1;\n        ways = (ways * a_cnt) % MOD;\n        ways = (ways * b_cnt) % MOD;\n\n        long long total = (a_cnt + b_cnt) * (a_cnt + b_cnt - 1LL) / 2 % MOD;\n        total = (total - (a_cnt * (a_cnt - 1LL) / 2 % MOD) - (b_cnt * (b_cnt - 1LL) / 2 % MOD)) % MOD;\n        total = (total + MOD) % MOD;\n\n        for (int k = 0; k < (a_cnt + b_cnt - 2); ++k) {\n            ways = (ways * (cnt + k + 1)) % MOD;\n        }\n\n        res = (res * ways) % MOD;\n        cnt += a_cnt + b_cnt;\n    }\n\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        int[] A = new int[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            A[i] = Integer.parseInt(st.nextToken());\n        }\n\n        int[] B = new int[M];\n        st = new StringTokenizer(br.readLine());\n        for (int j = 0; j < M; j++) {\n            B[j] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(A);\n        Arrays.sort(B);\n\n        if (A[N - 1] != B[M - 1]) {\n            System.out.println(0);\n            return;\n        }\n\n        long result = 1;\n        int i = N - 2;\n        int j = M - 2;\n\n        while (i >= 0 || j >= 0) {\n            int current;\n            if (i >= 0 && j >= 0) {\n                current = Math.max(A[i], B[j]);\n            } else if (i >= 0) {\n                current = A[i];\n            } else {\n                current = B[j];\n            }\n\n            int cntA = 0;\n            while (i >= 0 && A[i] == current) {\n                cntA++;\n                i--;\n            }\n\n            int cntB = 0;\n            while (j >= 0 && B[j] == current) {\n                cntB++;\n                j--;\n            }\n\n            if (current == A[N - 1]) {\n                continue;\n            }\n\n            long ways = 1;\n            long total = cntA + cntB;\n            long positions = cntA * cntB;\n            long free = (total * (total - 1) / 2) - (cntA * (cntA - 1) / 2) - (cntB * (cntB - 1) / 2);\n\n            for (long k = 1; k <= free; k++) {\n                ways = ways * k % MOD;\n            }\n\n            for (long k = 1; k <= positions; k++) {\n                ways = ways * (free + k) % MOD;\n            }\n\n            result = result * ways % MOD;\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:59:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1000000007;\n\n    public static int countWays(int N, int M) {\n        long result = 1;\n        boolean[] used = new boolean[N * M + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                int value = i * j;\n                if (used[value]) {\n                    return 0;\n                }\n                used[value] = true;\n            }\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                int countValid = 0;\n                for (int k = 1; k <= N * M; k++) {\n                    if (!used[k] && k % i == 0 && k / i <= M) {\n                        countValid++;\n                    }\n                }\n                result = (result * countValid) % MOD;\n            }\n        }\n        \n        return (int)result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        System.out.println(countWays(N, M));\n    }\n}",
    "timestamp": "2025-08-05 22:59:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> A(N), B(M);\n    for (int& a : A) cin >> a;\n    for (int& b : B) cin >> b;\n    \n    vector<vector<bool>> used(N, vector<bool>(M));\n    vector<int> rowMax(N), colMax(M);\n    \n    function<bool(int, int)> backtrack = [&](int row, int col) {\n        if (row == N) {\n            for (int i = 0; i < N; i++) {\n                if (rowMax[i] != A[i]) return false;\n            }\n            for (int j = 0; j < M; j++) {\n                if (colMax[j] != B[j]) return false;\n            }\n            return true;\n        }\n        \n        if (col == M) {\n            return backtrack(row + 1, 0);\n        }\n        \n        int ways = 0;\n        for (int val = 1; val <= N * M; val++) {\n            if (used[row][col]) continue;\n            \n            int r = val % N == 0 ? N : val % N;\n            int c = (val - 1) / N + 1;\n            \n            if (r - 1 != row || c - 1 != col) continue;\n            \n            rowMax[row] = max(rowMax[row], val);\n            colMax[col] = max(colMax[col], val);\n            used[row][col] = true;\n            \n            ways = (ways + backtrack(row, col + 1)) % MOD;\n            \n            rowMax[row] = 0;\n            colMax[col] = 0;\n            used[row][col] = false;\n        }\n        \n        return ways;\n    };\n    \n    cout << backtrack(0, 0) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef calculate_ways(N, M, A, B):\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][0] = 1\n\n    for j in range(1, M + 1):\n        dp[0][j] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD\n\n    count_row = [0] * (max(A) + 1)\n    count_col = [0] * (max(B) + 1)\n\n    for x in A:\n        count_row[x] += 1\n    for x in B:\n        count_col[x] += 1\n\n    combinations = 1\n    used = [False] * (N * M + 1)\n\n    for value in range(N * M, 0, -1):\n        rows = count_row[value]\n        cols = count_col[value]\n\n        if rows > 0 and cols > 0:\n            if used[value]:\n                return 0\n\n            if rows + cols - 1 > N * M - 1:\n                return 0\n\n            combinations *= (dp[rows][cols] - dp[rows - 1][cols - 1]) % MOD\n            combinations %= MOD\n        \n        elif rows > 0 or cols > 0:\n            if used[value]:\n                return 0\n\n            combinations *= dp[rows][cols] % MOD\n            combinations %= MOD\n        \n        used[value] = True\n\n    return combinations\n\n# Example usage:\nN = 3\nM = 3\nA = [3, 6, 9]\nB = [3, 6, 9]\nprint(calculate_ways(N, M, A, B))",
    "timestamp": "2025-08-13 13:07:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GridNumbering {\n\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int[] A = new int[N];\n        int[] B = new int[M];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n        for (int j = 0; j < M; j++) {\n            B[j] = sc.nextInt();\n        }\n\n        long[][] dp = new long[N + 1][M + 1];\n        for (int i = 0; i <= N; i++) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j <= M; j++) {\n            dp[0][j] = 1;\n        }\n\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n                if (A[i - 1] == B[j - 1]) {\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - 1] + MOD) % MOD;\n                }\n            }\n        }\n\n        System.out.println(dp[N][M]);\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 13:07:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MOD 1000000007\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int* A = (int*)malloc(N * sizeof(int));\n    int* B = (int*)malloc(M * sizeof(int));\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int j = 0; j < M; j++) {\n        scanf(\"%d\", &B[j]);\n    }\n\n    int possibilities = 1;\n    \n    for(int i = 1; i <= N * M; i++) {\n        int rowChoice = 0, colChoice = 0;\n        \n        for(int j = 0; j < N; j++) {\n            if (A[j] == i) {\n                rowChoice++;\n            }\n        }\n        \n        for(int j = 0; j < M; j++) {\n            if (B[j] == i) {\n                colChoice++;\n            }\n        }\n        \n        possibilities = (possibilities * ((rowChoice > 0 && colChoice > 0) ? 1 : rowChoice + colChoice)) % MOD;\n    }\n\n    printf(\"%d\\n\", possibilities);\n\n    free(A);\n    free(B);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:07:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction calculateWays(N, M, maxRowVals, maxColVals) {\n    const dp = Array.from({ length: N + 1 }, () => Array(M + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let i = 1; i <= N; i++) {\n        for (let j = 1; j <= M; j++) {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % MOD;\n            dp[i][j] = (dp[i][j] + MOD) % MOD;\n            if (maxRowVals[i - 1] === maxColVals[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n        }\n    }\n\n    return dp[N][M];\n}\n\n// Example usage:\n// const N = 3, M = 3;\n// const maxRowVals = [3, 6, 9];\n// const maxColVals = [3, 6, 9];\n// console.log(calculateWays(N, M, maxRowVals, maxColVals)); // Output: number of ways modulo 10^9 + 7",
    "timestamp": "2025-08-13 13:07:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways(N, M):\n    MOD = 10**9 + 7\n    \n    # Check if grid is possible\n    if N * M > N * M:\n        return 0\n    \n    # Initialize DP table\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Used set to track used numbers\n    used = set()\n    \n    # DP to count ways\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            for num in range(1, N * M + 1):\n                # Check if number can be placed in grid\n                if num not in used and num <= i * j:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD\n                    used.add(num)\n    \n    return dp[N][M]",
    "timestamp": "2025-08-13 13:07:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, M) {\n    const MOD = 1e9 + 7;\n    const factorial = new Array(N * M + 1).fill(0n);\n    factorial[0] = 1n;\n    \n    for (let i = 1; i <= N * M; i++) {\n        factorial[i] = (factorial[i-1] * BigInt(i)) % BigInt(MOD);\n    }\n    \n    const rowMax = new Array(N).fill(0);\n    const colMax = new Array(M).fill(0);\n    \n    function generatePermutations(currentRow, currentCol, used) {\n        if (currentRow === N) {\n            for (let j = 0; j < M; j++) {\n                if (rowMax[j] > colMax[j]) return 0n;\n            }\n            return 1n;\n        }\n        \n        if (currentCol === M) {\n            return generatePermutations(currentRow + 1, 0, used);\n        }\n        \n        let ways = 0n;\n        for (let num = 1; num <= N * M; num++) {\n            if (used.has(num)) continue;\n            \n            let value = num * (currentRow * M + currentCol + 1);\n            \n            rowMax[currentRow] = Math.max(rowMax[currentRow], value);\n            colMax[currentCol] = Math.max(colMax[currentCol], value);\n            \n            used.add(num);\n            ways = (ways + generatePermutations(currentRow, currentCol + 1, used)) % BigInt(MOD);\n            \n            used.delete(num);\n            \n            rowMax[currentRow] = Math.max(0, rowMax[currentRow] - value);\n            colMax[currentCol] = Math.max(0, colMax[currentCol] - value);\n        }\n        \n        return ways;\n    }\n    \n    return generatePermutations(0, 0, new Set()).toString();\n}",
    "timestamp": "2025-08-13 13:07:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = list(map(int, sys.stdin.readline().split()))\n    \n    if sorted(A) != A or sorted(B) != B:\n        print(0)\n        return\n    \n    if A[-1] != B[0]:\n        print(0)\n        return\n    \n    max_val = N * M\n    pos_A = [0] * (max_val + 2)\n    pos_B = [0] * (max_val + 2)\n    \n    for a in A:\n        pos_A[a] = 1\n    for b in B:\n        pos_B[b] = 1\n    \n    res = 1\n    cnt_A = 0\n    cnt_B = 0\n    common = 0\n    \n    for x in range(max_val, 0, -1):\n        if pos_A[x] and pos_B[x]:\n            common += 1\n        elif pos_A[x]:\n            cnt_A += 1\n            res = res * cnt_B % MOD\n        elif pos_B[x]:\n            cnt_B += 1\n            res = res * cnt_A % MOD\n        else:\n            res = res * (cnt_A * cnt_B - (max_val - x - common)) % MOD\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 13:08:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const A = input[1].split(' ').map(Number);\n    const B = input[2].split(' ').map(Number);\n\n    const maxA = Math.max(...A);\n    const maxB = Math.max(...B);\n    if (maxA !== B[0] || maxB !== A[N - 1] || maxA !== maxB) {\n        console.log(0);\n        return;\n    }\n\n    A.sort((a, b) => a - b);\n    B.sort((a, b) => a - b);\n\n    for (let i = 0; i < N; i++) {\n        if (A[i] < (i + 1)) {\n            console.log(0);\n            return;\n        }\n    }\n    for (let j = 0; j < M; j++) {\n        if (B[j] < (j + 1)) {\n            console.log(0);\n            return;\n        }\n    }\n\n    let result = 1;\n    let posA = 0;\n    let posB = 0;\n    let current = 0;\n\n    for (let k = 1; k <= N * M; k++) {\n        let countA = 0;\n        while (posA < N && A[posA] <= k) {\n            posA++;\n            countA++;\n        }\n        let countB = 0;\n        while (posB < M && B[posB] <= k) {\n            posB++;\n            countB++;\n        }\n\n        if (countA > 0 && countB > 0) {\n            if (k === maxA) {\n                // Do nothing, already handled\n            } else {\n                const total = countA * countB - current;\n                if (total <= 0) {\n                    console.log(0);\n                    return;\n                }\n                result = (result * total) % MOD;\n            }\n        } else if (countA > 0) {\n            const total = countA * posB - current;\n            if (total <= 0) {\n                console.log(0);\n                return;\n            }\n            result = (result * total) % MOD;\n        } else if (countB > 0) {\n            const total = countB * posA - current;\n            if (total <= 0) {\n                console.log(0);\n                return;\n            }\n            result = (result * total) % MOD;\n        } else {\n            const total = posA * posB - current;\n            if (total <= 0) {\n                console.log(0);\n                return;\n            }\n            result = (result * total) % MOD;\n        }\n        current = posA * posB;\n    }\n\n    console.log(result);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:08:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint solve(int N, int M, vector<int>& A, vector<int>& B) {\n    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));\n    dp[0][0] = 1;\n    \n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (A[i - 1] == B[j - 1]) {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + MOD) % MOD;\n            } else {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n            }\n        }\n    }\n    return dp[N][M];\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N), B(M);\n    for (int i = 0; i < N; ++i) cin >> A[i];\n    for (int j = 0; j < M; ++j) cin >> B[j];\n    cout << solve(N, M, A, B) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:38:12"
  }
]