[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint count_points_inside_triangle(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int count = 0;\n    int min_x = x1, max_x = x1;\n    int min_y = y1, max_y = y1;\n    \n    min_x = (x2 < min_x) ? x2 : min_x;\n    min_x = (x3 < min_x) ? x3 : min_x;\n    max_x = (x2 > max_x) ? x2 : max_x;\n    max_x = (x3 > max_x) ? x3 : max_x;\n    \n    min_y = (y2 < min_y) ? y2 : min_y;\n    min_y = (y3 < min_y) ? y3 : min_y;\n    max_y = (y2 > max_y) ? y2 : max_y;\n    max_y = (y3 > max_y) ? y3 : max_y;\n    \n    for (int x = min_x + 1; x < max_x; x++) {\n        for (int y = min_y + 1; y < max_y; y++) {\n            int d1 = abs((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));\n            int d2 = abs((x3 - x2) * (y - y2) - (y3 - y2) * (x - x2));\n            int d3 = abs((x1 - x3) * (y - y3) - (y1 - y3) * (x - x3));\n            int total = abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1));\n            \n            if (d1 + d2 + d3 == total)\n                count++;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int W, H, K;\n    scanf(\"%d %d %d\", &W, &H, &K);\n    \n    int triangle_count = 0;\n    \n    for (int x1 = 0; x1 <= W; x1++) {\n        for (int x2 = 0; x2 <= W; x2++) {\n            for (int x3 = 0; x3 <= W; x3++) {\n                if (x1 == x2 || x1 == x3 || x2 == x3) continue;\n                \n                for (int y1 = 0; y1 <= H; y1++) {\n                    for (int y2 = 0; y2 <= H; y2++) {\n                        for (int y3 = 0; y3 <= H; y3++) {\n                            if (y1 == y2 || y1 == y3 || y2 == y3) continue;\n                            \n                            int side1 = (x1 == 0 || x1 == W) && (y1 == 0 || y1 == H);\n                            int side2 = (x2 == 0 || x2 == W) && (y2 == 0 || y2 == H);\n                            int side3 = (x3 == 0 || x3 == W) && (y3 == 0 || y3 == H);\n                            \n                            if (side1 || side2 || side3) continue;\n                            \n                            int side1_idx = (x1 == 0) ? 0 : (x1 == W) ? 1 : (y1 == 0) ? 2 : 3;\n                            int side2_idx = (x2 == 0) ? 0 : (x2 == W) ? 1 : (y2 == 0) ? 2 : 3;\n                            int side3_idx = (x3 == 0) ? 0 : (x3 == W) ? 1 : (y3 == 0) ? 2 : 3;\n                            \n                            if (side1_idx == side2_idx || side1_idx == side3_idx || side2_idx == side3_idx)\n                                continue;\n                            \n                            int points_inside = count_points_inside_triangle(x1, y1, x2, y2, x3, y3);\n                            \n                            if (points_inside <= K)\n                                triangle_count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", triangle_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long count_lattice_points(long long x1, long long y1, long long x2, long long y2) {\n    return gcd(abs(x1 - x2), abs(y1 - y2)) - 1;\n}\n\nlong long count_triangles(int W, int H, int K) {\n    long long total = 0;\n    // The four sides are:\n    // Side 1: (0,0) to (W,0) - bottom\n    // Side 2: (W,0) to (W,H) - right\n    // Side 3: (0,H) to (W,H) - top\n    // Side 4: (0,0) to (0,H) - left\n    // We need to pick one point from each of three different sides.\n\n    // Case 1: bottom, right, top\n    for (long long x1 = 1; x1 < W; ++x1) {\n        for (long long y2 = 1; y2 < H; ++y2) {\n            for (long long x3 = 1; x3 < W; ++x3) {\n                long long A = x1 * (y2 - H) + W * (H - 0) + x3 * (0 - y2);\n                A = llabs(A);\n                long long B = count_lattice_points(x1, 0, W, y2) + \n                              count_lattice_points(W, y2, x3, H) + \n                              count_lattice_points(x3, H, x1, 0);\n                long long I = (A - B) / 2 + 1;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    // Case 2: bottom, right, left\n    for (long long x1 = 1; x1 < W; ++x1) {\n        for (long long y2 = 1; y2 < H; ++y2) {\n            for (long long y3 = 1; y3 < H; ++y3) {\n                long long A = x1 * (y2 - y3) + W * (y3 - 0) + 0 * (0 - y2);\n                A = llabs(A);\n                long long B = count_lattice_points(x1, 0, W, y2) + \n                              count_lattice_points(W, y2, 0, y3) + \n                              count_lattice_points(0, y3, x1, 0);\n                long long I = (A - B) / 2 + 1;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    // Case 3: bottom, top, left\n    for (long long x1 = 1; x1 < W; ++x1) {\n        for (long long x2 = 1; x2 < W; ++x2) {\n            for (long long y3 = 1; y3 < H; ++y3) {\n                long long A = x1 * (H - y3) + x2 * (y3 - 0) + 0 * (0 - H);\n                A = llabs(A);\n                long long B = count_lattice_points(x1, 0, x2, H) + \n                              count_lattice_points(x2, H, 0, y3) + \n                              count_lattice_points(0, y3, x1, 0);\n                long long I = (A - B) / 2 + 1;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    // Case 4: right, top, left\n    for (long long y1 = 1; y1 < H; ++y1) {\n        for (long long x2 = 1; x2 < W; ++x2) {\n            for (long long y3 = 1; y3 < H; ++y3) {\n                long long A = W * (H - y3) + x2 * (y3 - y1) + 0 * (y1 - H);\n                A = llabs(A);\n                long long B = count_lattice_points(W, y1, x2, H) + \n                              count_lattice_points(x2, H, 0, y3) + \n                              count_lattice_points(0, y3, W, y1);\n                long long I = (A - B) / 2 + 1;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    int W, H, K;\n    scanf(\"%d %d %d\", &W, &H, &K);\n    printf(\"%lld\\n\", count_triangles(W, H, K));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:30:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long count_lattice_points(long long x1, long long y1, long long x2, long long y2) {\n    return gcd(abs(x1 - x2), abs(y1 - y2)) - 1;\n}\n\nlong long compute_triangles(int W, int H, int K) {\n    long long total = 0;\n    // Iterate over all possible pairs of points on different sides\n    // There are four combinations of sides: (bottom, left), (bottom, right), (top, left), (top, right)\n    // For each combination, iterate over all points and count valid triangles\n\n    // Points on bottom (y=0, x=1..W-1)\n    // Points on top (y=H, x=1..W-1)\n    // Points on left (x=0, y=1..H-1)\n    // Points on right (x=W, y=1..H-1)\n\n    // Combination 1: bottom, left, right\n    for (int x1 = 1; x1 < W; ++x1) {\n        for (int y2 = 1; y2 < H; ++y2) {\n            for (int y3 = 1; y3 < H; ++y3) {\n                long long A = (long long)x1 * (y2 - y3) + (long long)W * y3;\n                long long B = gcd(x1, y2) + gcd(W - x1, y3) + gcd(W, abs(y2 - y3));\n                long long I = (A - B + 2) / 2;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    // Combination 2: bottom, left, top\n    for (int x1 = 1; x1 < W; ++x1) {\n        for (int y2 = 1; y2 < H; ++y2) {\n            for (int x3 = 1; x3 < W; ++x3) {\n                long long A = (long long)x1 * (H - y2) + (long long)x3 * y2;\n                long long B = gcd(x1, H - y2) + gcd(x3, y2) + gcd(abs(x1 - x3), H);\n                long long I = (A - B + 2) / 2;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    // Combination 3: bottom, right, top\n    for (int x1 = 1; x1 < W; ++x1) {\n        for (int y3 = 1; y3 < H; ++y3) {\n            for (int x2 = 1; x2 < W; ++x2) {\n                long long A = (long long)(W - x1) * (H - y3) + (long long)(W - x2) * y3;\n                long long B = gcd(W - x1, H - y3) + gcd(W - x2, y3) + gcd(abs(x1 - x2), H);\n                long long I = (A - B + 2) / 2;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    // Combination 4: left, right, top\n    for (int y1 = 1; y1 < H; ++y1) {\n        for (int x2 = 1; x2 < W; ++x2) {\n            for (int y3 = 1; y3 < H; ++y3) {\n                long long A = (long long)y1 * (W - x2) + (long long)H * x2 - (long long)y3 * x2;\n                long long B = gcd(y1, W - x2) + gcd(H - y3, x2) + gcd(W, abs(y1 - y3));\n                long long I = (A - B + 2) / 2;\n                if (I <= K) total++;\n            }\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    int W, H, K;\n    cin >> W >> H >> K;\n    cout << compute_triangles(W, H, K) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class RectangleTriangles {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int W = scanner.nextInt();\n        int H = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        long count = 0;\n        \n        for (int x1 = 1; x1 < W; x1++) {\n            for (int x2 = 1; x2 < W; x2++) {\n                for (int y1 = 1; y1 < H; y1++) {\n                    for (int y2 = 1; y2 < H; y2++) {\n                        long area = Math.abs((x1 * (H - y2) + x2 * y1 + W * (y2 - y1)) - (y1 * (W - x2) + y2 * x1 + H * (x2 - x1)));\n                        long boundary = gcd(x1, y1) + gcd(W - x2, y2) + gcd(Math.abs(x2 - x1), Math.abs(y2 - y1));\n                        long interior = (area - boundary) / 2 + 1;\n                        \n                        if (interior <= K) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n    \n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-05 22:31:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int countTriangles(int W, int H, int K) {\n        List<Point> perimeterPoints = new ArrayList<>();\n        \n        // Collect points on perimeter\n        for (int x = 0; x <= W; x++) {\n            perimeterPoints.add(new Point(x, 0));\n            perimeterPoints.add(new Point(x, H));\n        }\n        for (int y = 1; y < H; y++) {\n            perimeterPoints.add(new Point(0, y));\n            perimeterPoints.add(new Point(W, y));\n        }\n        \n        int count = 0;\n        int n = perimeterPoints.size();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    Point p1 = perimeterPoints.get(i);\n                    Point p2 = perimeterPoints.get(j);\n                    Point p3 = perimeterPoints.get(k);\n                    \n                    // Check different sides\n                    if (getSide(p1, W, H) == getSide(p2, W, H) || \n                        getSide(p2, W, H) == getSide(p3, W, H) || \n                        getSide(p3, W, H) == getSide(p1, W, H)) {\n                        continue;\n                    }\n                    \n                    // Count grid points inside triangle\n                    if (countGridPointsInside(p1, p2, p3) <= K) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private static int getSide(Point p, int W, int H) {\n        if (p.x == 0) return 0;\n        if (p.x == W) return 1;\n        if (p.y == 0) return 2;\n        return 3;\n    }\n    \n    private static int countGridPointsInside(Point p1, Point p2, Point p3) {\n        int count = 0;\n        int minX = Math.min(Math.min(p1.x, p2.x), p3.x);\n        int maxX = Math.max(Math.max(p1.x, p2.x), p3.x);\n        int minY = Math.min(Math.min(p1.y, p2.y), p3.y);\n        int maxY = Math.max(Math.max(p1.y, p2.y), p3.y);\n        \n        for (int x = minX + 1; x < maxX; x++) {\n            for (int y = minY + 1; y < maxY; y++) {\n                if (isPointInside(p1, p2, p3, new Point(x, y))) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private static boolean isPointInside(Point p1, Point p2, Point p3, Point p) {\n        double totalArea = triangleArea(p1, p2, p3);\n        double area1 = triangleArea(p, p2, p3);\n        double area2 = triangleArea(p1, p, p3);\n        double area3 = triangleArea(p1, p2, p);\n        \n        return Math.abs(totalArea - (area1 + area2 + area3)) < 1e-10;\n    }\n    \n    private static double triangleArea(Point p1, Point p2, Point p3) {\n        return Math.abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    }\n    \n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Test cases can be added here\n    }\n}",
    "timestamp": "2025-08-05 22:31:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint countPointsInTriangle(vector<pair<int, int>>& triangle) {\n    int minX = min({triangle[0].first, triangle[1].first, triangle[2].first});\n    int maxX = max({triangle[0].first, triangle[1].first, triangle[2].first});\n    int minY = min({triangle[0].second, triangle[1].second, triangle[2].second});\n    int maxY = max({triangle[0].second, triangle[1].second, triangle[2].second});\n    \n    int count = 0;\n    for (int x = minX + 1; x < maxX; ++x) {\n        for (int y = minY + 1; y < maxY; ++y) {\n            if (isPointInTriangle(triangle, {x, y})) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nbool isPointInTriangle(vector<pair<int, int>>& triangle, pair<int, int> point) {\n    auto sign = [](pair<int, int> p1, pair<int, int> p2, pair<int, int> p3) {\n        return (p1.first - p3.first) * (p2.second - p3.second) - (p2.first - p3.first) * (p1.second - p3.second);\n    };\n    \n    int d1 = sign(point, triangle[0], triangle[1]);\n    int d2 = sign(point, triangle[1], triangle[2]);\n    int d3 = sign(point, triangle[2], triangle[0]);\n    \n    bool has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    bool has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    \n    return !(has_neg && has_pos);\n}\n\nint main() {\n    int W, H, K;\n    cin >> W >> H >> K;\n    \n    vector<pair<int, int>> perimeter;\n    for (int x = 0; x <= W; ++x) {\n        perimeter.push_back({x, 0});\n        perimeter.push_back({x, H});\n    }\n    for (int y = 1; y < H; ++y) {\n        perimeter.push_back({0, y});\n        perimeter.push_back({W, y});\n    }\n    \n    int count = 0;\n    int n = perimeter.size();\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (perimeter[i].first == perimeter[j].first && perimeter[i].first == perimeter[k].first) continue;\n                if (perimeter[i].second == perimeter[j].second && perimeter[i].second == perimeter[k].second) continue;\n                \n                vector<pair<int, int>> triangle = {perimeter[i], perimeter[j], perimeter[k]};\n                int points = countPointsInTriangle(triangle);\n                \n                if (points <= K) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    cout << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_triangles(W, H, K):\n    def count_points_on_side(w, h):\n        return w + h\n    \n    side_a_points = W\n    side_b_points = H\n    side_c_points = W\n    side_d_points = H\n\n    total_count = 0\n\n    for x1 in range(1, W):\n        for y1 in [0, H]:\n            for y2 in range(1, H):\n                for x2 in [0, W]:\n                    if x1 != x2 and y1 != y2:\n                        if x2 == W:\n                            area = abs(x1 * y2)\n                        else:\n                            area = abs((W - x1) * y2)\n                        \n                        point_inside = area - W - H + x1 + y2\n                        if point_inside <= K:\n                            total_count += 1\n\n    return total_count\n\nW = 10  # Example W\nH = 5   # Example H\nK = 20  # Example K\nprint(count_triangles(W, H, K))",
    "timestamp": "2025-08-13 11:04:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class TriangleCounter {\n    public static int countTriangles(int W, int H, int K) {\n        int count = 0;\n        \n        for (int x1 = 0; x1 <= W; x1++) {\n            for (int x2 = 0; x2 <= W; x2++) {\n                if (x1 == x2) continue;\n                \n                for (int y1 = 0; y1 <= H; y1++) {\n                    for (int y2 = 0; y2 <= H; y2++) {\n                        if (y1 == y2) continue;\n                        \n                        if (isPerimeterPoint(x1, 0, W, H) && isPerimeterPoint(x2, 0, W, H)\n                                && isPerimeterPoint(0, y1, W, H)\n                                && isPerimeterPoint(0, y2, W, H)\n                                && differentSides(x1, y1, x2, y2, W, H)) {\n                            \n                            int A = Math.abs(x1 * (y2 - H) + x2 * (H - y1) + W * (y1 - y2)); // Twice the area of Δ\n                            int gridPointsInside = Math.max(0, A / 2 - W - H + 1);\n                            \n                            if (gridPointsInside <= K) {\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private static boolean isPerimeterPoint(int x, int y, int W, int H) {\n        return (x == 0 || x == W || y == 0 || y == H);\n    }\n    \n    private static boolean differentSides(int x1, int y1, int x2, int y2, int W, int H) {\n        return (x1 == 0 && x2 == W) || (x1 == W && x2 == 0)\n            || (y1 == 0 && y2 == H) || (y1 == H && y2 == 0)\n            || (x1 == 0 && y1 == H) || (x1 == W && y1 == 0)\n            || (x2 == 0 && y2 == H) || (x2 == W && y2 == 0);\n    }\n    \n    public static void main(String[] args) {\n        int W = 5;  // Example values\n        int H = 3;  // Example values\n        int K = 2;  // Example values\n        int result = countTriangles(W, H, K);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 11:04:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint countTriangles(int W, int H, int K) {\n    int count = 0;\n    for (int x1 = 1; x1 < W; ++x1) {\n        for (int y2 = 1; y2 < H; ++y2) {\n            int a = x1;    // Distance from (0,0) to (x1,0)\n            int b = y2;    // Distance from (W,0) to (W,y2)\n            int c = W;     // Distance from (0,H) to (W,H)\n\n            int interiorPoints = a * b / 2;\n            if (interiorPoints <= K) count++;\n        }\n    }\n\n    for (int y1 = 1; y1 < H; ++y1) {\n        for (int x2 = 1; x2 < W; ++x2) {\n            int a = y1;    // Distance from (0,0) to (0,y1)\n            int b = x2;    // Distance from (0,H) to (x2,H)\n            int c = H;     // Distance from (W,0) to (W,H)\n\n            int interiorPoints = a * b / 2;\n            if (interiorPoints <= K) count++;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int W, H, K;\n    scanf(\"%d %d %d\", &W, &H, &K);\n    printf(\"%d\\n\", countTriangles(W, H, K));\n    return 0;\n}",
    "timestamp": "2025-08-13 11:04:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countTriangles(W, H, K) {\n    let totalTriangles = 0;\n\n    // Iterate over each possible vertex configuration\n    for (let x1 = 0; x1 <= W; x1++) {\n        for (let x2 = 0; x2 <= W; x2++) {\n            if (x1 === x2) continue;\n            for (let y1 = 0; y1 <= H; y1++) {\n                for (let y2 = 0; y2 <= H; y2++) {\n                    if (y1 === y2) continue;\n                    \n                    // Determine the sides for each point\n                    let side1 = x1 === 0 ? 0 : x1 === W ? 2 : y1 === 0 ? 1 : 3;\n                    let side2 = x2 === 0 ? 0 : x2 === W ? 2 : y2 === 0 ? 1 : 3;\n                    let side3 = 6 - (side1 + side2);\n                    \n                    if ((side1 ^ side2 ^ side3) !== 3) continue;\n\n                    // Points for the third point are along the third side\n                    let validTriangles = 0;\n                    switch(side3) {\n                        case 0: // (0, y)\n                            validTriangles = Math.min(y1, y2);\n                            break;\n                        case 1: // (x, 0)\n                            validTriangles = Math.min(x1, x2);\n                            break;\n                        case 2: // (W, y)\n                            validTriangles = Math.min(H - y1, H - y2);\n                            break;\n                        case 3: // (x, H)\n                            validTriangles = Math.min(W - x1, W - x2);\n                            break;\n                    }\n\n                    for (let i = 1; i <= validTriangles; i++) {\n                        let a, b, c = 0;\n                        switch(side3) {\n                            case 0: b = x1; a = x2; c = b + a; break;\n                            case 1: b = y1; a = y2; c = b + a; break;\n                            case 2: b = H - y1; a = H - y2; c = b + a; break;\n                            case 3: b = W - x1; a = W - x2; c = b + a; break;\n                        }\n                        \n                        let pointsInside = Math.floor(0.5 * Math.abs(b * a + a * i - b * i));\n                        \n                        if (pointsInside <= K) {\n                            totalTriangles++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return totalTriangles / 2;  // To account for symmetry\n}",
    "timestamp": "2025-08-13 11:05:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_triangles(W, H, K):\n    total_triangles = 0\n    \n    # Check all possible combinations of vertices on different sides\n    sides = [(0, 0, W, 0), (0, 0, 0, H), (W, 0, W, H), (0, H, W, H)]\n    \n    for i in range(4):\n        for j in range(i+1, 4):\n            for k in range(j+1, 4):\n                # Vertices from sides i, j, k\n                side_a, side_b, side_c = sides[i], sides[j], sides[k]\n                \n                # Get vertices on each side\n                vertices_a = get_vertices_on_side(side_a, W, H)\n                vertices_b = get_vertices_on_side(side_b, W, H)\n                vertices_c = get_vertices_on_side(side_c, W, H)\n                \n                # Check all combinations of vertices on these sides\n                for x1 in vertices_a:\n                    for x2 in vertices_b:\n                        for x3 in vertices_c:\n                            # Ensure no rectangle vertex is used\n                            if (x1 in [(0,0), (W,0), (0,H), (W,H)] or \n                                x2 in [(0,0), (W,0), (0,H), (W,H)] or \n                                x3 in [(0,0), (W,0), (0,H), (W,H)]):\n                                continue\n                            \n                            # Check grid points inside triangle\n                            grid_points = count_grid_points(x1, x2, x3)\n                            \n                            if grid_points <= K:\n                                total_triangles += 1\n    \n    return total_triangles\n\ndef get_vertices_on_side(side, W, H):\n    x1, y1, x2, y2 = side\n    vertices = []\n    \n    if x1 == x2:  # vertical side\n        for y in range(min(y1, y2)+1, max(y1, y2)):\n            vertices.append((x1, y))\n    else:  # horizontal side\n        for x in range(min(x1, x2)+1, max(x1, x2)):\n            vertices.append((x, y1))\n    \n    return vertices\n\ndef count_grid_points(p1, p2, p3):\n    def area(a, b, c):\n        return abs(a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1])) / 2\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    def boundary_points(a, b):\n        return gcd(abs(b[0]-a[0]), abs(b[1]-a[1])) + 1\n    \n    total_points = 1 + boundary_points(p1, p2) + boundary_points(p2, p3) + boundary_points(p3, p1)\n    triangle_area = area(p1, p2, p3)\n    \n    # Pick's theorem\n    interior_points = int(triangle_area + 1 - (total_points / 2))\n    \n    return interior_points",
    "timestamp": "2025-08-13 11:05:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countTriangles(W, H, K) {\n    let count = 0;\n    const sides = [\n        {start: [0, 0], end: [W, 0], isHorizontal: true},\n        {start: [W, 0], end: [W, H], isHorizontal: false},\n        {start: [W, H], end: [0, H], isHorizontal: true},\n        {start: [0, H], end: [0, 0], isHorizontal: false}\n    ];\n\n    function crossProduct(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n    }\n\n    function countGridPointsInside(a, b, c) {\n        let count = 0;\n        const minX = Math.min(a[0], b[0], c[0]);\n        const maxX = Math.max(a[0], b[0], c[0]);\n        const minY = Math.min(a[1], b[1], c[1]);\n        const maxY = Math.max(a[1], b[1], c[1]);\n\n        for (let x = minX + 1; x < maxX; x++) {\n            for (let y = minY + 1; y < maxY; y++) {\n                if (isPointInTriangle([x, y], a, b, c)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    function isPointInTriangle(p, a, b, c) {\n        const areaSign = Math.sign(crossProduct(a, b, c));\n        const sign1 = Math.sign(crossProduct(a, b, p)) * areaSign;\n        const sign2 = Math.sign(crossProduct(b, c, p)) * areaSign;\n        const sign3 = Math.sign(crossProduct(c, a, p)) * areaSign;\n        return sign1 >= 0 && sign2 >= 0 && sign3 >= 0;\n    }\n\n    for (let i = 0; i < sides.length; i++) {\n        for (let j = i + 1; j < sides.length; j++) {\n            for (let k = j + 1; k < sides.length; k++) {\n                const p1 = sides[i].start;\n                const p2 = sides[j].start;\n                const p3 = sides[k].start;\n\n                if (sides[i].isHorizontal === sides[j].isHorizontal || \n                    sides[j].isHorizontal === sides[k].isHorizontal || \n                    sides[k].isHorizontal === sides[i].isHorizontal) continue;\n\n                const gridPointsInside = countGridPointsInside(p1, p2, p3);\n                if (gridPointsInside <= K) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}",
    "timestamp": "2025-08-13 11:05:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef count_triangles(W, H, K):\n    total = 0\n    \n    # Function to compute the number of interior points in a triangle using Pick's theorem\n    def interior_points(a, b, c):\n        # Calculate the area using the shoelace formula\n        area = abs((a[0]*(b[1] - c[1]) + b[0]*(c[1] - a[1]) + c[0]*(a[1] - b[1])) / 2)\n        # Calculate boundary points using gcd\n        def boundary_points(p1, p2):\n            return math.gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + 1\n        B = boundary_points(a, b) + boundary_points(b, c) + boundary_points(c, a) - 3\n        I = area - B // 2 + 1\n        return I\n    \n    # Generate all possible points on the four sides\n    bottom = [(x, 0) for x in range(1, W)]\n    top = [(x, H) for x in range(1, W)]\n    left = [(0, y) for y in range(1, H)]\n    right = [(W, y) for y in range(1, H)]\n    \n    # All combinations of three points from different sides\n    from itertools import product\n    \n    # Bottom, Left, Top\n    for b in bottom:\n        for l in left:\n            for t in top:\n                I = interior_points(b, l, t)\n                if I <= K:\n                    total += 1\n    # Bottom, Left, Right\n    for b in bottom:\n        for l in left:\n            for r in right:\n                I = interior_points(b, l, r)\n                if I <= K:\n                    total += 1\n    # Bottom, Top, Right\n    for b in bottom:\n        for t in top:\n            for r in right:\n                I = interior_points(b, t, r)\n                if I <= K:\n                    total += 1\n    # Left, Top, Right\n    for l in left:\n        for t in top:\n            for r in right:\n                I = interior_points(l, t, r)\n                if I <= K:\n                    total += 1\n    \n    return total",
    "timestamp": "2025-08-13 11:05:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countTriangles(W, H, K) {\n    let count = 0;\n\n    function gcd(a, b) {\n        while (b) {\n            let temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    function boundaryPoints(x1, y1, x2, y2) {\n        return gcd(Math.abs(x2 - x1), Math.abs(y2 - y1)) - 1;\n    }\n\n    function pickThreeSides() {\n        const sides = [\n            { start: [0, 0], end: [W, 0], type: 'bottom' },\n            { start: [W, 0], end: [W, H], type: 'right' },\n            { start: [W, H], end: [0, H], type: 'top' },\n            { start: [0, H], end: [0, 0], type: 'left' }\n        ];\n        const combinations = [\n            [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]\n        ];\n        return combinations;\n    }\n\n    const sideCombinations = pickThreeSides();\n\n    for (const sides of sideCombinations) {\n        const [a, b, c] = sides;\n        const sideA = [\n            { start: [0, 0], end: [W, 0] },\n            { start: [W, 0], end: [W, H] },\n            { start: [W, H], end: [0, H] },\n            { start: [0, H], end: [0, 0] }\n        ][a];\n        const sideB = [\n            { start: [0, 0], end: [W, 0] },\n            { start: [W, 0], end: [W, H] },\n            { start: [W, H], end: [0, H] },\n            { start: [0, H], end: [0, 0] }\n        ][b];\n        const sideC = [\n            { start: [0, 0], end: [W, 0] },\n            { start: [W, 0], end: [W, H] },\n            { start: [W, H], end: [0, H] },\n            { start: [0, H], end: [0, 0] }\n        ][c];\n\n        for (let x1 = sideA.start[0]; x1 <= sideA.end[0]; x1++) {\n            for (let y1 = sideA.start[1]; y1 <= sideA.end[1]; y1++) {\n                if ((x1 === 0 || x1 === W) && (y1 === 0 || y1 === H)) continue;\n                if (!(x1 === sideA.start[0] || x1 === sideA.end[0] || y1 === sideA.start[1] || y1 === sideA.end[1])) continue;\n\n                for (let x2 = sideB.start[0]; x2 <= sideB.end[0]; x2++) {\n                    for (let y2 = sideB.start[1]; y2 <= sideB.end[1]; y2++) {\n                        if ((x2 === 0 || x2 === W) && (y2 === 0 || y2 === H)) continue;\n                        if (!(x2 === sideB.start[0] || x2 === sideB.end[0] || y2 === sideB.start[1] || y2 === sideB.end[1])) continue;\n\n                        for (let x3 = sideC.start[0]; x3 <= sideC.end[0]; x3++) {\n                            for (let y3 = sideC.start[1]; y3 <= sideC.end[1]; y3++) {\n                                if ((x3 === 0 || x3 === W) && (y3 === 0 || y3 === H)) continue;\n                                if (!(x3 === sideC.start[0] || x3 === sideC.end[0] || y3 === sideC.start[1] || y3 === sideC.end[1])) continue;\n\n                                if (x1 === x2 && y1 === y2) continue;\n                                if (x1 === x3 && y1 === y3) continue;\n                                if (x2 === x3 && y2 === y3) continue;\n\n                                const area = Math.abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2);\n                                if (area === 0) continue;\n\n                                const b1 = boundaryPoints(x1, y1, x2, y2);\n                                const b2 = boundaryPoints(x2, y2, x3, y3);\n                                const b3 = boundaryPoints(x3, y3, x1, y1);\n                                const B = b1 + b2 + b3 + 3;\n\n                                const I = area + 1 - B / 2;\n                                if (I <= K) {\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}",
    "timestamp": "2025-08-13 11:06:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n\nint calculateGridPointsOnEdge(int a) {\n    return a + 1; // For an edge of length a, there are a+1 points\n}\n\nint main() {\n    int W, H, K;\n    std::cin >> W >> H >> K;\n\n    // Grid points on perimeter of rectangle R\n    int top = calculateGridPointsOnEdge(W);\n    int right = calculateGridPointsOnEdge(H);\n    int bottom = calculateGridPointsOnEdge(W);\n    int left = calculateGridPointsOnEdge(H);\n\n    // Total number of grid points, excluding vertices\n    int perimeter = 2 * (W + H);\n\n    int triangleCount = 0;\n\n    for (int topIndex = 1; topIndex < top - 1; ++topIndex) {\n        for (int rightIndex = 1; rightIndex < right - 1; ++rightIndex) {\n            for (int bottomIndex = 1; bottomIndex < bottom - 1; ++bottomIndex) {\n                // Convert index to coordinates\n                int x1 = topIndex, y1 = 0;\n                int x2 = W, y2 = rightIndex;\n                int x3 = bottomIndex, y3 = H;\n\n                // Area of triangle Δ using determinant method\n                int area2 = std::abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\n\n                // Number of grid points inside using Pick's Theorem: A = i + b/2 - 1\n                // We need i, the number of interior points.\n                int boundaryPoints = 3; // Each side contributes one point + the vertices of the triangle\n                int interiorPoints = (area2 - boundaryPoints) / 2 + 1;\n\n                if (interiorPoints <= K) {\n                    triangleCount++;\n                }\n            }\n        }\n    }\n\n    std::cout << triangleCount << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:23"
  }
]