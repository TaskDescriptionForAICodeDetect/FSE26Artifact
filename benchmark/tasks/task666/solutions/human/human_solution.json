[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint W,H,K,i,j,k,l;\ninline ll calc(int n,int m){\n\tstatic int v1[N],v2[N];ll ans=0;\n\tfor(i=1;i<m;++i){\n\t\tint lm1,lm2;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv1[j]=(m+1)*(j+1)-(i+1)*(j+1)+3;\n\t\t\tif(v1[j]>K*2+m*2)break;\n\t\t}\n\t\tlm1=j;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv2[j]=(m+1)*j-(m-i+1)*(j+1);\n\t\t\tif(v2[j]>K*2+m*2)break;\n\t\t}\n\t\tlm2=j;\n\t\tfor(j=1,k=lm2-1;j<lm1;++j){\n\t\t\tfor(;k>1 && v1[j]+v2[k]>K*2;--k);\n\t\t\tans+=k-1;\n\t\t\tint vv=v1[j]-__gcd(j,i);\n\t\t\tfor(l=0;vv+v2[k+l]-m-(m-i)<=K*2 && k+l<lm2;++l)ans+=vv+v2[k+l]-__gcd(k+l,m-i)-__gcd(abs(j-k-l),m)<=K*2;\n/*\n\t\t\tfor(l=0;k+l<lm2;++l){\n\t\t\t\tans+=vv+v2[k+l]-__gcd(k+l,m-i)-__gcd(abs(j-k-l),m)<=K*2;\n\t\t\t\tif(vv+v2[k+l]-__gcd(k+l,m-i)-__gcd(abs(j-k-l),m)<=K*2){\nif(vv+v2[k+l]-m-(m-i)<=K*2);\nelse ++i,--i;\n}\n\t\t\t}\n*/\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tprintf(\"%lld\\n\",calc(W,H)+calc(H,W)<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=500005,lim=100000;\nint p[N],flag[N],mu[N],A[N],B[N],nA,nB,W,H,K;\nll ans;\nvi d;\n\nvoid init(int n){\n\tint cnt=0;\n\tmu[1]=1;\n\trep(i,2,n){\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tflag[i*p[j]]=1;\n\t\t\tif(i%p[j]==0){\n\t\t\t\tmu[i*p[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i*p[j]]=-mu[i];\n\t\t}\n\t}\n}\n\nll calc(int W,int H,int K,int d){\n\tll ans=0;\n\trep(r,1,d){\n\t\trep(x,1,W-1){\n\t\t\tnA=nB=0;\n\t\t\tfor(int i=r;i<H&&(ll)i*(W-x)<=K+W;i+=d){\n\t\t\t\tA[++nA]=i*(W-x)-__gcd(i,x);\n\t\t\t}\n\t\t\tfor(int i=r;i<H&&(ll)i*x<=K+W;i+=d){\n\t\t\t\tB[++nB]=i*x-__gcd(i,W-x);\n\t\t\t}\n\t\t\tsort(A+1,A+nA+1);\n\t\t\tsort(B+1,B+nB+1);\n\t\t\trep(i,1,nB){\n\t\t\t\tans+=upper_bound(A+1,A+nA+1,K-B[i])-A-1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int W,int H){\n\td.clear();\n\tfor(int i=1;i*i<=W;i++){\n\t\tif(W%i==0){\n\t\t\td.pb(i);\n\t\t\tif(i*i!=W) d.pb(W/i);\n\t\t}\n\t}\n\tfor(auto x:d){\n\t\tfor(auto y:d){\n\t\t\tif(y%x==0&&mu[y/x]){\n\t\t\t\tans+=mu[y/x]*calc(W,H,K+x,y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tread(W),read(H),read(K);\n\tK=K*2-2;\n\tinit(lim);\n\tsolve(W,H);\n\tsolve(H,W);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint W, H, K;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint64_t solve() {\n    // A = I + B / 2 - 1, where I <= K\n    // A - B / 2 + 1 = I <= K\n    // 2 * A - B <= 2 * (K - 1)\n    //\n    // A = H * W - W * (H - (y1 + y2) / 2) - x * y1 / 2 - (W - x) * y2 / 2\n    //   = W * (y1 + y2) / 2 - x * y1 / 2 - (W - x) * y2 / 2\n    //   = [(W - x) * y1 + x * y2] / 2\n    // B = gcd(y1 - y2, W) + gcd(y1, x) + gcd(y2, W - x)\n    int64_t total = 0;\n    int lim = 2 * (K - 1) + 3 * W;\n    for (int x = 1; x < W; x++) {\n        for (int y2 = 1; y2 < H; y2++) {\n            if (x * y2 > lim)\n                break;\n            // (W - x) * y1 + x * y2 <= 2 * (K - 1) + 3 <= 2 * (K - 1) + B\n            int y1 = (2 * (K - 1) - x * y2 + 3) / (W - x);\n            if (y1 >= y2) {\n                total += 2 * y2 - 1;\n                continue;\n            }\n            if (y1 < 1)\n                y1 = 1;\n            total += 2 * (y1 - 1);\n            for (; y1 <= y2; y1++) {\n                int A2 = (W - x) * y1 + x * y2;\n                if (A2 > lim)\n                    break;\n                int B = gcd(y1, x) + gcd(y2, W - x) + gcd(abs(y1 - y2), W);\n                if (A2 - B <= 2 * (K - 1)) {\n                    total++;\n                    if (y1 != y2)\n                        total++;\n                }\n            }\n        }\n    }\n    return total;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> W >> H >> K;\n\n    int64_t total = solve();\n    swap(W, H);\n    total += solve();\n    total *= 2;\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn abs(b*(c-a)-m*(n-a))-(__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\t/*\n\tfor(int j=1;j<m;j++)\n\t{\n\t\tcerr<<\"SOLVE \"<<j<<'\\n';\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tassert(calc(n,m,i,j,i)<=calc(n,m,i-1,j,i-1));\n\t\t\t//cerr<<calc(n,m,i,j,i)<<'\\n';\n\t\t}\n\t}\n\t*/\n\t/*\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll a=1;a<n;a++)\n\t\t{\n\t\t\tfor(ll c=a+1;c<n;c++)\n\t\t\t{\n\t\t\t\tif(calc(n,m,a,b,c)<calc(n,m,a,b,c+1))\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"FAIL \"<<a<<' '<<b<<' '<<c<<' '<<calc(n,m,a,b,c)<<' '<<calc(n,m,a,b,c+1)<<'\\n';\n\t\t\t\t}\n\t\t\t\t//assert(calc(n,m,a,b,c)>=calc(n,m,a,b,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll z=1;z<=min(n-1,ll(210000)/m);z++)\n\t\t{\n\t\t\tll a=n-z;\n\t\t\tll as=a+1;\n\t\t\tll lo=1; ll hi=a;\n\t\t\twhile(lo<=hi)\n\t\t\t{\n\t\t\t\tll mid=(lo+hi)>>1;\n\t\t\t\tif(calc(n,m,a,b,mid)<=k)\n\t\t\t\t{\n\t\t\t\t\tas=mid;\n\t\t\t\t\thi=mid-1;\n\t\t\t\t}\n\t\t\t\telse lo=mid+1;\n\t\t\t}\n\t\t\tfor(ll y=0;y<=min(a-1,ll(410000)/m);y++)\n\t\t\t{\n\t\t\t\tll c=a-y;\n\t\t\t\tif(c<as-500) break;\n\t\t\t\tif(calc(n,m,a,b,c)<=k) \n\t\t\t\t{\n\t\t\t\t\tif(y>0) ans+=2;\n\t\t\t\t\telse ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\t\t\t\n\t\t\t//a is the maxi\n\t\t\t//c<=a\n\t\t\tll as=a+1;\n\t\t\tll lo=1; ll hi=a;\n\t\t\twhile(lo<=hi)\n\t\t\t{\n\t\t\t\tll mid=(lo+hi)>>1;\n\t\t\t\tif(calc(n,m,a,b,mid)<=k)\n\t\t\t\t{\n\t\t\t\t\tas=mid;\n\t\t\t\t\thi=mid-1;\n\t\t\t\t}\n\t\t\t\telse lo=mid+1;\n\t\t\t}\n\t\t\tif(as==a+1) continue;\n\t\t\tans+=2*(a+1-as)-1;\n\t\t\t*/\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\n \nconst ll INF = 2e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//↓,→,↑,←\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n    #undef endl\n#endif\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\n// const ll mod = 998244353ll;\nconst ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll mod){ll x=1;while(b){while(!(b&1)){(a*=a)%=mod;b>>=1;}(x*=a)%=mod;b--;}return x;}\nvoid YES(bool cond){ if(cond){ p(\"YES\");}else{ p(\"NO\");} return;}\nvoid Yes(bool cond){ if(cond){ p(\"Yes\");}else{ p(\"No\");} return;}\n\n/*\nll fact[fact_table + 5],rfact[fact_table + 5]; \n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table],mod - 2, mod);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n\nvoid init(){\n    struct timeval _time;\n    gettimeofday(&_time, NULL);\n    ll usec = _time.tv_usec * 1000000;\n    srand(usec);\n    return;\n}\n\nll range(ll a,ll b){\n    // generate random number [a, b]\n    // if b >= 10^8, this might not be precise\n    ll num = rand() % (1 + b - a) + a;\n    return num;\n}\n\nbool multicase = false;\nll mygcd(ll a, ll b){\n    if(b > a)swap(a, b);\n    if(b == 0 || a == b)return a;\n    return mygcd(b, a % b);\n}\n\nll calc(ll w, ll h, ll k){\n    ll ans = 0;\n    for(ll i1=1;i1<h;i1++){\n        for(ll i2=1;i2<h;i2++){\n            if (min(i1, i2) * w + 2 * h + w > 2 * k) break;\n            if (max(i1, i2) * w + 2 <= 2 * k) {\n                ans += w - 1;\n                continue;\n            }\n            for(ll j=1;j<w;j++){\n                ll b = mygcd(i1, j) + mygcd(w - j, i2) + mygcd(w, abs(i1 - i2));\n                ll s = max(i1, i2) * w * 2;\n                s -= (i1 * j) + (w - j) * (i2) + (abs(i1 - i2) * w);\n                if(s - b + 2 <= 2 * k)ans ++;\n            }\n        }\n    }\n    return ans;\n}\nll n,m,num,a,b,c,d,e,h,q;\nvoid solve(){\n    ll w, k;\n    cin >> w >> h >> k;\n    ll ans = 0;\n    ans += calc(w, h, k) * 2;\n    ans += calc(h, w, k) * 2;\n    p(ans);\n    return;\n}\n\nint main(){\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll q, testcase = 1;\n    if(multicase){\n        cin >> q;\n    }else{\n        q = 1; \n    }\n    while(q--){\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n    // solve();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd_(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tif (w < h) {\n\t\tll inf = -2 * h - w;\n\t\tll res1 = 0; ll res2 = 0;\n\t\tfor (ll x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)continue;\n\t\t\tfor (ll x2 = x1; x2 < w; x2++) {\n\t\t\t\tif (2 * k - 2 - x1 * h - (x2 - x1) < inf)continue;\n\t\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\t\tll s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd_(x1, y) + gcd_(h - y, x2) + gcd_(x2 - x1, h);\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n\telse {\n\t\tll inf = -2 * h - w;\n\t\tll res1 = 0; ll res2 = 0;\n\t\tfor (ll x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)continue;\n\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\tfor (ll x2 = x1; x2 < w; x2++) {\n\t\t\t\t\tll s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd_(x1, y) + gcd_(h - y, x2) + gcd_(x2 - x1, h);\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Let's join Kaede Takagaki Fan Club !!\n//明日は高垣楓さんの誕生日！おめでとうございます！！！\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target (\"avx\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define all(x) x.begin(),x.end()\ntemplate<class T>\nvoid dmp(T a){\n\trep(i,a.size()) cout << a[i] << \" \";\n\tcout << endl;\n}\ntemplate<class T>\nbool chmax(T&a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nbool chmin(T&a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nvoid g(T &a){\n\tcin >> a;\n}\ntemplate<class T>\nvoid o(const T &a,bool space=false){\n\tcout << a << (space?' ':'\\n');\n}\n//ios::sync_with_stdio(false);\nconst ll mod = 1000000007;//998244353\ntemplate<class T>\nvoid add(T&a,T b){\n\ta+=b;\n\tif(a >= mod) a-=mod;\n}\nll gcd(ll a, ll b){\n\tif(a < b) swap(a, b);\n\tif(b == 0) return a;\n\telse return gcd(b, a%b);\n}\nll specific(ll h, ll w, ll dif, ll k){\n\tll ans = 0;\n\tll DH = gcd(h, dif);\n\tfor(ll i=1;i<h;i++){\n\t\tif(dif * i > 450000LL) break;\n\t\tll lb = 0, ub = w-dif;\n\t\tchmin(ub, (450000LL-dif*i) / h + 1LL);\n\t\tchmax(ub, 1LL);\n\t\twhile(ub-lb > 1){\n\t\t\tll mid = (lb+ub)/2;\n\t\t\tll S = 1LL * h * (mid+dif) - 1LL * (h-i) * (dif);\n\t\t\tS += 2;\n\t\t\tS -= gcd(i, mid) + gcd(h-i, mid+dif) + DH;\n\t\t\tif(S <= 2*k) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tans += ub-1;\n\t}\n\treturn ans;\n}\nll calc(ll w, ll h, ll k){\n\tll ret = 0;\n\tfor(int i=0;i<=w-2;i++){\n\t\tret += specific(h, w, i, k) * (i==0?1LL:2LL);\n\t}\n\treturn ret;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tint w, h, k;\n\tcin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tans <<= 1;\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W,K;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>K;\n\tll ret=0;\n\tFOR(i,2) {\n\t\tfor(int s=0;s<=H-2;s++) {\n\t\t\tint R=2*K+__gcd(s,W)-2;\n\t\t\tll pat=0;\n\t\t\tfor(x=1;x<W;x++) {\n\t\t\t\tint R2=R-s*x;\n\t\t\t\tif(R2<0) break;\n\t\t\t\t\n\t\t\t\tint Ymi=min(H-s-2,R2/W-1);\n\t\t\t\tif(Ymi>0) pat+=Ymi;\n\t\t\t\tfor(y=max(1,Ymi+1);y<=Ymi+2 && y+s<H;y++) {\n\t\t\t\t\tll v=1LL*W*y-__gcd(x,y)-__gcd(W-x,y+s);\n\t\t\t\t\tif(v<=R2) pat++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tret+=((s==0)?1:2)*pat;\n\t\t}\n\t\tswap(H,W);\n\t}\n\tcout<<2*ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nint solve(int W, int H, int K) {\n\tK = 2 * K - 2;\n\tint ans = 0;\n\tfor (int x = 1; x < W; ++x) {\n\t\tint lim = min(H - 1, (K + 2 * W) / (W - x));\n\t\tfor (int y1 = 1; y1 <= lim; ++y1) {\n\t\t\tint rhs = K - (W - x) * y1 + __gcd(x, y1);\n\t\t\t// x * y2 <= rhs + (W, |y1-y2|) + (W-x, y2)\n\t\t\tint lim2 = min(H - 1, (rhs + 2 * W - x) / x);\n\t\t\tfor (int y2 = 1; y2 <= lim2; ++y2) {\n\t\t\t\tif (x * y2 <= rhs + __gcd(W, abs(y1 - y2)) + __gcd(W - x, y2))\n\t\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tint ans = 2 * (solve(w, h, k) + solve(h, w, k));\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n\n\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    vector<int> preg(W);\n    for (int i = 0; i < W; i++) preg[i] = __gcd(i, H);\n    \n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K - (H-y)*x1;\n            if (((LL)y)*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n            }\n            int g = __gcd(x1, y);\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (y*x2 > 2*K+x1-x2+g+H-y) break;\n                LL c = (H-y)*x1 + y*x2 - (g + __gcd(x2, H-y) + preg[x1-x2]) + 2;\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nint gcd(int a,int b){\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tint s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\treturn a<<s;\n\t\n}\n\npi sub(pi a,pi b){\n\treturn pi(a.a-b.a,a.b-b.b);\n}\n\nint crs(pi a,pi b){\n\treturn a.a*b.b-a.b*b.a;\n}\n\nint tri2(pi a,pi b,pi c){\n\treturn abs(crs(sub(c,a),sub(b,a)));\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint h,w,k;cin>>h>>w>>k;\n\tint ans=0;\n\trep(_,2){\n\t\trng(left,1,h){\n\t\t\trep(dif,w-1){\n\t\t\t\tif(tri2(pi(0,left),pi(1+dif,0),pi(1,h))>(k+h)*2)break;\n\t\t\t\tint lw=0,up=w-dif;\n\t\t\t\tint base=gcd(h,dif);\n\t\t\t\twhile(up-lw>1){\n\t\t\t\t\tconst int mid=(lw+up)/2;\n\t\t\t\t\tint t=tri2(pi(0,left),pi(mid+dif,0),pi(mid,h));\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(t<=(k+h)*2){\n\t\t\t\t\t\tt-=base;\n\t\t\t\t\t\tt-=gcd(left,mid+dif);\n\t\t\t\t\t\tt-=gcd(h-left,mid);\n\t\t\t\t\t\tt+=2;\n\t\t\t\t\t\tif(t/2<=k)ok=true;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tlw=mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tup=mid;\n\t\t\t\t}\n\t\t\t\tans+=lw;\n\t\t\t\tif(dif>0)ans+=lw;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(h,w);\n\t}\n\tprint(ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint pregcd[333][100010];\nint mgcd(int a,int b)\n{\n\tif(a<b)\n\t{\n\t\tif(a<333)return pregcd[a][b];\n\t\telse return gcd(a,b);\n\t}\n\telse\n\t{\n\t\tif(b<333)return pregcd[b][a];\n\t\telse return gcd(a,b);\n\t}\n}\nint K;\nlong f(int W,int H)\n{\n\tlong ans=0;\n\tconst int LIM=2*K+2*W;\n\tfor(int x=1;x<W;x++)\n\t{\n\t\tfor(int y1=1;y1<H&&(W-x)*y1<=LIM;y1++)\n\t\t{\n\t\t\tconst int LIM2=LIM-(W-x)*y1;\n\t\t\tint preb=mgcd(x,y1);\n\t\t\tfor(int y2=1;y2<=y1&&x*y2<=LIM2;y2++)\n\t\t\t{\n\t\t\t\tint b=preb+mgcd(W-x,y2)+mgcd(W,y1-y2);\n\t\t\t\tint S=x*y2+(W-x)*y1;\n\t\t\t\tif(S-b+2<=2*K)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tans+=y2<y1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\nmain()\n{\n\tfor(int i=0;i<333;i++)for(int j=0;j<=100000;j++)pregcd[i][j]=gcd(i,j);\n\tint W,H;\n\tcin>>W>>H>>K;\n\tcout<<f(W,H)+f(H,W)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int W, H, K;\n    scanf(\"%d %d %d\", &W, &H, &K);\n    auto solve = [&](int W, int H) {\n        long long ans = 0;\n        for (int d = 0; d <= H - 2; d++) {\n            for (int j = 1; j < W && d * j <= 2 * K; j++) {\n                int t = 2 * K - 2 - d * j + __gcd(W, d);\n                if (t < 0) continue;\n                int i = min(H - d - 1, t / W + 1);\n                if (i * W - __gcd(i, j) - __gcd(W - j, i + d) > t) i--;\n                ans += i * (!d ? 1 : 2);\n            }\n        }\n        return ans;\n    };\n    printf(\"%lld\\n\", (solve(W, H) + solve(H, W)) * 2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nconst int limit = 20;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nll get(int x, int y) {\n\tif (x < y) swap(x, y);\n\tif (y == 0) return x + 1;\n\tint q = x / y, r = x % y;\n\treturn 1ll * q * (y + 1) * y / 2 + get(y, r);\n}\nll get(int x, int y, bool type) {\n\tll ans = get(x, y);\n\tif (!type) ans -= 1 + __gcd(x, y);\n\treturn ans;\n}\nint n, m, k;\nbool check(int i, int j, int l) {\n\tif (i == j) return i * (m + 1ll) - get(i, l, true) - get(i, m - l, true) + 3 <= k;\n\telse return get(j - i, m, false) + i * (m + 1ll) - get(i, l, true) - get(j, m - l, true) + 3 <= k;\n}\nll work(int n, int m) {\n\tll ans = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tbool goon = false;\n\t\tfor (int j = 1; j <= m - 1; j++)\n\t\t\tif (check(i, i, j)) {\n\t\t\t\tgoon = true;\n\t\t\t\tans += 1;\n\t\t\t}\n\t\tif (!goon) break;\n\t}\n\tfor (int i = 1; i <= n - 2; i++) {\n\t\tbool goon = false;\n\t\tfor (int j = 1; j <= limit && j <= m - 1; j++)\n\t\t\tif (check(i, i + 1, j)) goon = true;\n\t\tif (!goon) break;\n\t\tint now = m - 1;\n\t\tfor (int j = i + 1; j <= n - 1; j++) {\n\t\t\tnow = min(m - 1, now + limit);\n\t\t\twhile (now >= 1 && !check(i, j, now)) now--;\n\t\t\tans += 2 * now;\n\t\t\tfor (int l = now; l >= 1 && now - l <= limit; l--)\n\t\t\t\tans -= 2 * !check(i, j, l);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(m), read(k);\n\tcout << work(n, m) * 2 + work(m, n) * 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nint n, m, k;\nlong long ans = 0ll;\n\nint gcd(int x, int y) {\n\tif (x < 0) x = -x;\n\tif (y < 0) y = -y;\n\tif (x < y) swap(x, y);\n\twhile (y) {\n\t\tint r = x % y;\n\t\tx = y, y = r;\n\t}\n\treturn x;\n}\nlong long solve(int w, int h, int s) {\n\tlong long res = 0ll;\n\tfor (int i = 1; i < h; i++) {\n\t\tint i_ = max(i, h - i);\n\t\t// We can replace i with i_.\n\t\tfor (int j = 1; j <= h && j <= (2 * s + 3 * h) / i_; j++) {\n\t\t\tint k_min = (s * 2 - i_ * j) / (h - i_);\n\t\t\tk_min = min(k_min, w - 1);\n\t\t\tk_min = max(k_min, 0);\n\t\t\tres += k_min;\n\t\t\tfor (int k = k_min + 1; k < w; k++) {\n\t\t\t\tif (i_ * j + (h - i_) * k - 3 * h + 2 > (s << 1)) break;\n\t\t\t\tint twice_n = i_ * j + (h - i_) * k - gcd(i_, k) - gcd(h - i_, j) - gcd(h, j - k) + 2;\n\t\t\t\tif (twice_n <= (s << 1)) res++; \n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = (solve(n, m, k) + solve(m, n, k)) << 1;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll w, h, k;\n\tcin >> w >> h >> k;\n\tk = 2 * k - 2;\n\tll ans = 0;\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tfor (ll b = 1; b < h; b++) {\n\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\tswap(w, h);\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) { \n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tfor (ll b = 1; b < h; b++) {\n\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\tFOR(y,1,w){\n\t\t++ans;\n\t\tFor(z,2,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),L=0,lim=2*k-2;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-2-tmp<=lim) L=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tint ret=2*L,R=L;\n\t\t\tFor(x,L+1,z-1){\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*x-y-min(z-x,w)-tmp>lim){R=x-1;break;}\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\t\tret+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=ret;\n\t\t\tif (R==0) break;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tif (w==1||h==1) return puts(\"0\"),0;\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}"
  },
  {
    "language": "C++",
    "code": "."
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int magic = 5000;\n    vector<vi> g(magic, vi(magic));\n    FOR(i, 0, magic) g[0][i] = g[i][0] = i;\n    FOR(i, 1, magic) FOR(j, 1, magic) {\n        if (i <= j) g[i][j] = g[i][j - i];\n        else g[i][j] = g[i - j][j];\n    }\n\n    auto calc = [&] (int x, int y) {\n        x = abs(x), y = abs(y);\n        if (x < magic && y < magic) return g[x][y] - 1;\n        return __gcd(x, y) - 1;\n    };\n\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 3e5; j++) {\n                int tmp = calc(j, w - i);\n                int s;\n                for (int k = 1; k < h && (s = abs(j * i + (w - i) * k) - tmp) <= 2 * d + 2e5; k++) {\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                    else {\n                        s -= f[abs(j - k)];\n                        s -= calc(k, i);\n                        s -= 1;\n                        if (s <= d + d) {\n                            res += 2;\n                            if (i + i == w) {\n                                res--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nlong long ans = 0ll;\n\nint gcd(int x, int y) {\n\tif (x < 0) x = -x;\n\tif (y < 0) y = -y;\n\tif (x < y) swap(x, y);\n\twhile (y) {\n\t\tint r = x % y;\n\t\tx = y, y = r;\n\t}\n\treturn x;\n}\nlong long solve(int w, int h, int s) {\n\tlong long res = 0ll;\n\tfor (int i = 1; i < h; i++) {\n\t\tint i_ = max(i, h - i);\n\t\t// We can replace i with i_.\n\t\tfor (int j = 1; j < h && j <= (2 * s + 3 * h) / i_; j++) {\n\t\t\tint k_min = (s * 2 - i_ * j) / (h - i_);\n\t\t\tk_min = min(k_min, w - 1);\n\t\t\tk_min = max(k_min, 0);\n\t\t\tres += k_min;\n\t\t\tint g = gcd(h - i_, j);\n\t\t\tfor (int k = k_min + 1; k < w; k++) {\n\t\t\t\tif (i_ * j + (h - i_) * k - 3 * h + 2 > (s << 1)) break;\n\t\t\t\tint twice_n = i_ * j + (h - i_) * k - gcd(i_, k) - g - gcd(h, j - k) + 2;\n\t\t\t\tif (twice_n <= (s << 1)) res++; \n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = (solve(n, m, k) + solve(m, n, k)) << 1;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=500005,lim=100000;\nint p[N],flag[N],mu[N],A[N],B[N],nA,nB,W,H,K;\nll ans;\nvi d;\n\nvoid init(int n){\n\tint cnt=0;\n\tmu[1]=1;\n\trep(i,2,n){\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tflag[i*p[j]]=1;\n\t\t\tif(i%p[j]==0){\n\t\t\t\tmu[i*p[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i*p[j]]=-mu[i];\n\t\t}\n\t}\n}\n\nll calc(int W,int H,int K,int d){\n\tll ans=0;\n\tint tot=0;\n\trep(r,1,min(d,min(H,K+W))){\n\t\trep(x,1,W-1){\n\t\t\tnA=nB=0;\n\t\t\tfor(int i=r;i<H&&(ll)i*(W-x)<=K+W;i+=d){\n\t\t\t\tA[++nA]=i*(W-x)-__gcd(i,x);\n\t\t\t\t/*\n\t\t\t\tint p=nA;\n\t\t\t\twhile(p>=2&&A[p]<A[p-1]){\n\t\t\t\t\tswap(A[p],A[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tfor(int i=r;i<H&&(ll)i*x<=K+W;i+=d){\n\t\t\t\tB[++nB]=i*x-__gcd(i,W-x);\n\t\t\t\t/*\n\t\t\t\tint p=nB;\n\t\t\t\twhile(p>=2&&B[p]<B[p-1]){\n\t\t\t\t\tswap(B[p],B[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tsort(A+1,A+nA+1);\n\t\t\tsort(B+1,B+nB+1);\n\t\t\tint p=nA;\n\t\t\trep(i,1,nB){\n\t\t\t\twhile(p&&A[p]+B[i]>K) p--;\n\t\t\t\tans+=p;\n\t\t\t}\n\t\t\ttot+=nA+nB;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int W,int H){\n\td.clear();\n\tfor(int i=1;i*i<=W;i++){\n\t\tif(W%i==0){\n\t\t\td.pb(i);\n\t\t\tif(i*i!=W) d.pb(W/i);\n\t\t}\n\t}\n\tfor(auto x:d){\n\t\tfor(auto y:d){\n\t\t\tif(y%x==0&&mu[y/x]){\n\t\t\t\tans+=mu[y/x]*calc(W,H,K+x,y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tread(W),read(H),read(K);\n\tK=K*2-2;\n\tinit(lim);\n\tsolve(W,H);\n\tsolve(H,W);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define R register\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tstatic int c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\nint ans;\ninline void sol(int w,int h,int k){\n\t//bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tint a,b,c,A,C,B=k+h-2,D;\n\trep(b,1,h>>1){\n\t\tA=min(B/(h-b)+2,w);\n\t\tD=B;\n\t\tREP(a,1,A){\n\t\t\tC=min(D/b+2,w);\n\t\t\tREP(c,1,C)if(a*(h-b)+b*c+2<=k+gcd(a,b)+gcd(c,h-b)+gcd((a>c)?(a-c):(c-a),h)){\n\t\t\t\tif((b<<1)==h)++ans;\n\t\t\t\telse ans+=2;\n\t\t\t}\n\t\t\tcmax(D-=h-b,0);\n\t\t}\n\t}\n}\ninline void ac(){\n}\nint main(){\n\tint w,h,k,n,i;\n\tscanf(\"%d%d%d\",&w,&h,&k);k<<=1;\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%d\",ans<<1);\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n  if(a==0 || b==0) return(a+b);\n  else if(a%b == 0) return(b);\n  else return(gcd(b, a%b));\n}\n\nint main(){\n  int W,H,K;\n  cin>>W>>H>>K;\n  long long cnt1=0;\n  long long cnt2=0;\n  \n\tfor(int i=1;i<=H-1;i++){ //横の長さがW\n      for(int j=1;j<=H-1;j++){\n        for(int k=1;k<=W-1;k++){\n          long long X=gcd(W,abs(i-j))+gcd(i,k)+gcd(j,W-k)-(2*W*max(i,j)-(W*abs(i-j)+i*k+j*(W-k)));\n            if(X<=2*K+2){\n              cnt1++;\n            }\n          for(int k=1;k<=W-1;k++){\n            long long X=gcd(W,abs(i-j))+gcd(H-i,k)+gcd(H-j,W-k)-(2*W*max(H-i,H-j)-(W*abs(i-j)+(H-i)*k+(H-j)*(W-k)));\n            if(X<=2*K+2){\n              cnt1++;\n            }\n          }\n        }\n      }\n    }\n\tfor(int i=1;i<=W-1;i++){ //縦の長さがH  \n      for(int j=1;j<=W-1;j++){\n        for(int k=1;k<=H-1;k++){\n          long long X=gcd(abs(i-j),H)+gcd(i,k)+gcd(j,H-k)-(2*H*max(i,j)-(H*abs(i-j)+i*k+j*(H-k)));\n            if(X<=2*K+2){\n              cnt2++;\n            }\n        }\n        for(int k=1;k<=H-1;k++){\n          long long X=gcd(abs(i-j),H)+gcd(W-i,k)+gcd(W-j,H-k)-(2*H*max(W-i,W-j)-(H*abs(i-j)+(W-i)*k+(W-j)*(H-k)));\n            if(X<=2*K+2){\n              cnt2++;\n            }\n        }\n      }\n    }\n//    long long X=gcd(a,b)+gcd(c,d)+gcd(e,f)-(2*max({a,c,e})*H-(a*b+c*d+e*f));\n//  if(X<=2*K+2) count++;\n  \n  cout<<2*(cnt1+cnt2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn abs(b*(c-a)-m*(n-a))-(__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll d=0;d<=min(n-1,ll(410000)/b);d++)\n\t\t{\n\t\t\tll R = k-b*d+__gcd(b,m);\n\t\t\tif(R<0) continue;\n\t\t\tll mina=R/m;\n\t\t\tll coeff=2;\n\t\t\tif(d==0) coeff=1;\n\t\t\t//cerr<<b<<' '<<d<<' '<<mina<<'\\n';\n\t\t\t\n\t\t\tif(mina+3<=n-1-d)\n\t\t\t{\n\t\t\t\tassert(calc(n,m,n-(mina+3),b,n-(mina+3)-d)>k);\n\t\t\t}\n\t\t\t\n\t\t\tfor(ll z=mina+1;z<=mina+2;z++)\n\t\t\t{\n\t\t\t\tif(z<=n-1-d&&calc(n,m,n-z,b,n-z-d)<=k) ans+=coeff;\n\t\t\t}\n\t\t\tans+=coeff*min(mina,n-1-d);\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n \nvoid chemthan() {\n    const int magic = 5000;\n    vector<vi> dvs(magic);\n    FOR(i, 1, sz(dvs)) {\n        for (int j = i; j < sz(dvs); j += i) {\n            dvs[j].pb(i);\n        }\n    }\n    int w, h, d; cin >> w >> h >> d;\n    vector<vi> g(magic, vi(magic));\n    FOR(i, 0, magic) g[0][i] = g[i][0] = i;\n    FOR(i, 1, magic) FOR(j, 1, magic) {\n        if (i <= j) g[i][j] = g[i][j - i];\n        else g[i][j] = g[i - j][j];\n    }\n \n    auto calc = [&] (int x, int y) {\n        if (!x || !y) return x + y - 1;\n        x = abs(x), y = abs(y);\n        if (y < x) swap(x, y);\n        y %= x;\n        if (x < magic && y < magic) return g[x][y] - 1;\n        return __gcd(x, y) - 1;\n    };\n \n    long long res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= d + d + w + h + h; j++) {\n                int t = d + d + calc(j, w - i) + 1 - i * j;\n                //(w - i) * k - gcd(w, |j - k|) - gcd(i, k) <= t\n                int c = 1 + (i + i < w);\n                int s = min(h - 1, t < 0 ? 0 : t / (w - i));\n                res += c * s;\n                for (int k = s + 1; k < h; k++) {\n                    if ((w - i) * k < t + w + i) {\n                        if ((w - i) * k - f[abs(j - k)] - calc(i, k) <= t) {\n                            res += c;\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n//(W - a) * b + c * a - gcd(a, b) - gcd(W - a, c) - gcd(W, b - c) + 2 <= 2 * K\nLL f(LL W, LL H, LL K){\n    LL ans = 0;\n    for(LL a = 1; a < W; a += 1)\n        for(LL b = 1; b < H; b += 1)\n            for(int c = 1; c < H; c += 1){\n                ans += (W - a) * b + c * a - gcd(a, b) - gcd(W - a, c) - gcd(W, b - c) + 2 <= 2 * K;\n            }\n    return ans;\n}\nint main(){\n    LL W, H, K;\n    cin >> W >> H >> K;\n    cout << f(W, H, K) * 2 + f(H, W, K) * 2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n\n\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    vector<int> preg(W);\n    for (int i = 0; i < W; i++) preg[i] = __gcd(i, H);\n    \n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K - (H-y)*x1;\n            if (((LL)y)*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n            }\n            int g = __gcd(x1, y);\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (x1 != x2 and y*x2 > 2*K+g + H-y + x1-x2) x2 = x1;\n                if ((LL)y*x2 > 1e6) break;\n                LL c = (H-y)*x1 + y*x2 - (g + __gcd(x2, H-y) + preg[x1-x2]) + 2;\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt gcd(Int x, Int y)\n{\n    if (x == 0)\n        return y;\n    return gcd(y % x, x);\n}\n\nInt inside(Int x1, Int y1, Int x2, Int y2)\n{\n    Int s = abs(x1 * y2 - x2 * y1);\n    s += 2;\n    s -= gcd(abs(x1), abs(y1));\n    s -= gcd(abs(x2), abs(y2));\n    s -= gcd(abs(x2 - x1), abs(y2 - y1));\n    return s / 2;\n}\n\nInt cnt(Int w, Int h, Int k)\n{\n    Int ans = 0;\n    for (Int x = 1; x < w; x++) {\n        for (Int s = 0; s < h - 1; s++) {\n            if (inside(1, x, -s, w) > 2 * k)\n                break;\n            if (inside(1, x, -s, w) > k)\n                continue;\n            Int bottom = 1, top = h - s;\n            while (top - bottom > 1) {\n                Int mid = (top + bottom) / 2;\n                if (inside(mid, x, -s, w) <= k)\n                    bottom = mid;\n                else\n                    top = mid;\n            }\n            cout << x << \" \" << s << \" \" << bottom << endl;\n            if (s == 0)\n                ans += bottom;\n            else\n                ans += bottom * 2;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    Int w, h, k;\n    cin >> w >> h >> k;\n    cout << 2 * cnt(w, h, k) + 2 * cnt(h, w, k) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <chrono>\n#include <random>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <iomanip>\n#define dibs reserve\n#define OVER9000 1234567890\n#define tisic 47\n#define soclose 1e-8\n#define patkan 9\n#define ff first\n#define ss second\nusing uint = unsigned int;\nusing cat = long long;\nusing dbl = long double;\nconstexpr dbl pi = 3.14159265358979323846;\nusing namespace std;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ntemplate <typename T>\nT abs(T x) { return (x < 0) ? (-x) : x; }\n\nint gcd(int x, int y) {\n\tif(x > y) swap(x, y);\n\twhile(x) {\n\t\ty %= x;\n\t\tswap(x, y);\n\t}\n\treturn y;\n}\n\ncat solve(int W, int H, int K) {\n\t// vector< vector<int> > divs(H+1);\n\t// for(int i = 1; i <= H; i++)\n\t// \tfor(int j = i; j <= H; j += i)\n\t// \t\tdivs[j].push_back(i);\n\tcat ret = 0;\n\tfor(int r = 1; r <= (H-1)/2; r++) {\n\t\tfor(int c2 = 1; c2 < W && c2*(H-r) <= 2*(K-1+H); c2++) {\n\t\t\tint c1 = 1, c1b = min(W-1, (2*(K-1)-c2*(H-r))/r);\n\t\t\tif(c1 <= c1b) {\n\t\t\t\tret += c1b-c1+1;\n\t\t\t\tc1 = c1b+1;\n\t\t\t}\n\t\t\twhile(c1 < W && c1*r+c2*(H-r) <= 2*(K-1)+min(c2,r)+2*H-r) {\n\t\t\t\tret += (c1*r+c2*(H-r) <= 2*(K-1)+gcd(c1,H-r)+gcd(c2,r)+gcd(abs(c1-c2),H));\n\t\t\t\tc1++;\n\t\t\t}\n\t\t}\n\t}\n\tret *= 2;\n\tif(H%2 == 0) {\n\t\tint r = H/2;\n\t\tfor(int c2 = 1; c2 < W && c2*(H-r) <= 2*(K-1+H); c2++) {\n\t\t\tint c1 = 1, c1b = min(W-1, (2*(K-1)-c2*(H-r))/r);\n\t\t\tif(c1 <= c1b) {\n\t\t\t\tret += c1b-c1+1;\n\t\t\t\tc1 = c1b+1;\n\t\t\t}\n\t\t\twhile(c1 < W && c1*r+c2*(H-r) <= 2*(K-1)+min(c2,r)+2*H-r) {\n\t\t\t\tret += (c1*r+c2*(H-r) <= 2*(K-1)+gcd(c1,H-r)+gcd(c2,r)+gcd(abs(c1-c2),H));\n\t\t\t\tc1++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcout << fixed << setprecision(10);\n\tint W, H, K;\n\tcin >> W >> H >> K;\n\tcout << 2 * (solve(W, H, K) + solve(H, W, K)) << \"\\n\";\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\n\nll S(int x0, int y0, int x1, int y1, int x2, int y2) {\n    x1 -= x0;\n    y1 -= y0;\n    x2 -= x0;\n    y2 -= y0;\n    return abs((ll)x1 * y2 - (ll)x2 * y1);\n}\n\nint W, H;\nll a[100010], b[100010];\n\nll hen(int x0, int y0, int x1, int y1) {\n    if (abs(x1 - x0) == W) return a[abs(y1 - y0)];\n    if (abs(y1 - y0) == H) return b[abs(x1 - x0)];\n    return __gcd(abs(x1 - x0), abs(y1 - y0)) - 1;\n}\n\nll unko;\n\nll f(int x0, int y0, int x1, int y1, int x2, int y2) {\n    return (S(x0, y0, x1, y1, x2, y2) - (unko + hen(x1, y1, x2, y2) + hen(x2, y2, x0, y0) + 3)) / 2 + 1;\n}\n\nint main() {\n    int K;\n    cin >> W >> H >> K;\n    rep(z, 100001) a[z] = __gcd(W, z) - 1;\n    rep(z, 100001) b[z] = __gcd(H, z) - 1;\n    ll ans = 0;\n    for (int y = 1; y <= H - 1; y++) {\n        int l, r;\n        for (l = 1; l <= W - 1; l++)\n            if (min(S(0, y, l, 0, 0, H), S(0, y, l, 0, W, 0)) > (K + 150000) * 2)\n                break;\n        for (r = W - 1; r >= 0; r--)\n            if (min(S(0, y, r, 0, 0, H), S(0, y, r, 0, W, 0)) > (K + 150000) * 2)\n                break;\n        for (int x = 1; x < l; x++) {\n            unko = hen(x, 0, 0, y);\n            for (int X = 1; X <= W - 1 && S(0, y, x, 0, X, H) <= (K + 150000) * 2; X++)\n                if (f(0, y, x, 0, X, H) <= K)\n                    ans++;\n            for (int Y = 1; Y <= H - 1 && S(0, y, x, 0, W, Y) <= (K + 150000) * 2; Y++)\n                if (f(0, y, x, 0, W, Y) <= K)\n                    ans++;\n        }\n        if (l == W) continue;\n        for (int x = W - 1; x > r; x--) {\n            unko = hen(x, 0, 0, y);\n            for (int X = 1; X <= W - 1 && S(0, y, x, 0, X, H) <= (K + 150000) * 2; X++)\n                if (f(0, y, x, 0, X, H) <= K)\n                    ans++;\n            for (int Y = 1; Y <= H - 1 && S(0, y, x, 0, W, Y) <= (K + 150000) * 2; Y++)\n                if (f(0, y, x, 0, W, Y) <= K)\n                    ans++;\n        }\n    }\n    cout << ans * 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint W,H,k;\ninline int _gcd(int a,int b){\n\tif(b==0)return a;\n\treturn _gcd(b,a%b);\n}\nll Solve(int n,int m){\n\tint lim=3*m+2*k;\n\tll ans=0;\n\tfor(int y=1;y<m;++y){\n\t\tfor(int d=0;d<n-1&&d*y<=lim;++d){\n\t\t\tint t=_gcd(m,d)+2*k-d*y-2;\n\t\t\tif(t<0)continue;\n\t\t\tint x=t/m+1;\n\t\t\tans+=(min(t/m,n-d-1)+(x+d<n&&x*m-_gcd(x,y)-_gcd(m-y,x+d)<=t))*(1+(d>0));\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tW=read(),H=read(),k=read();\n\tprintf(\"%lld\\n\",(Solve(W,H)+Solve(H,W))<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint W, H, K;\nint gcdtbl[201][100100];\n\nint gcd(int a, int b, bool f = false)\n{\n\ta = max(a, -a);\n\tb = max(b, -b);\n\tif (!f && a <= 200) {\n\t\treturn gcdtbl[a][b];\n\t}\n\twhile (b) {\n\t\tint tmp = a % b;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nbool test(int y, int dx, int x)\n{\n\ti64 S2 = (x + dx) * (i64)H - (i64)(H - y) * dx;\n\tint b = gcd(dx, H) + gcd(x + dx, H - y) + gcd(x, y);\n\ti64 tmp = (S2 + 2 - b);\n\tif (tmp % 2 == 1) abort();\n\treturn tmp / 2 <= K;\n}\n\nint solve(int dx, int y)\n{\n\tint xlo = 0, xhi = min(W - 1 - dx, 500500 / H);\n\twhile (xlo < xhi) {\n\t\tint mid = (xlo + xhi + 1) / 2;\n\t\tif (test(y, dx, mid)) {\n\t\t\txlo = mid;\n\t\t} else {\n\t\t\txhi = mid - 1;\n\t\t}\n\t}\n\t// printf(\"%d %d %d %d: %d\\n\", dx, y, W, H, xlo);\n\treturn xlo;\n}\n\nint main()\n{\n\tfor (int i = 0; i <= 200; ++i) {\n\t\tfor (int j = 0; j <= 100000; ++j) gcdtbl[i][j] = gcd(i, j, true);\n\t}\n\tscanf(\"%d%d%d\", &W, &H, &K);\n\ti64 ret = 0;\n\tfor (int t = 0; t < 2; ++t) {\n\t\tfor (int dx = 0; dx <= W - 2; ++dx) {\n\t\t\tint ymax;\n\t\t\tif (dx == 0) ymax = H - 1;\n\t\t\telse ymax = min(500500 / dx, H - 1);\n\t\t\tfor (int y = 1; y <= ymax; ++y) {\n\t\t\t\tret += solve(dx, y) * (dx == 0 ? 2 : 4);\n\t\t\t}\n\t\t}\n\t\tswap(H, W);\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint K;\nint pregcd[1<<17];\nlong f(int W,int H)\n{\n\tlong ans=0;\n\tconst int LIM=2*K+2*W;\n\tfor(int i=0;i<H;i++)pregcd[i]=gcd(W,i);\n\tfor(int x=1;x<W;x++)\n\t{\n\t\tfor(int y1=1;y1<H&&(W-x)*y1<=LIM;y1++)\n\t\t{\n\t\t\tconst int LIM2=LIM-(W-x)*y1;\n\t\t\tint preb=gcd(x,y1);\n\t\t\tfor(int y2=1;y2<=y1&&x*y2<=LIM2;y2++)\n\t\t\t{\n\t\t\t\tint b=preb+gcd(W-x,y2)+pregcd[y1-y2];\n\t\t\t\tint S=x*y2+(W-x)*y1;\n\t\t\t\tif(S-b+2<=2*K)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tans+=y2<y1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\nmain()\n{\n\tint W,H;\n\tcin>>W>>H>>K;\n\tcout<<f(W,H)+f(H,W)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 11100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint gcd(int a,int b){\n\twhile(b){\n\t\ta%=b;swap(a,b);\n\t}\n\treturn a;\n}\nint lg[110000];\nint rg[110000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tlong long ret=0;\n\tfor(int z=0;z<2;z++){\n\t\t\n\t\tfor(int j=1;j<b;j++){\n\t\t\tint h=min(a-2,(2*c+2*(a+b))/j+2);\n\t\t\tfor(int i=0;i<h+3;i++){\n\t\t\t\tlg[i]=gcd(i,j);\n\t\t\t\trg[i]=gcd(i,b-j);\n\t\t\t}\n\t\t\tfor(int i=0;i<=h;i++){\n\t\t\t\tint tmp=gcd(i,b);\n\t\t\t\tint left=0;\n\t\t\t\tint right=h-i+3;\n\t\t\t\twhile(left+1<right){\n\t\t\t\t\tint M=(left+right)/2;\n\t\t\t\t\tint V=lg[M]+rg[M+i];\n\t\t\t\t\tif(M+i<a&&(long long)(M+i)*b*2-(long long)j*M-(long long)(b-j)*(M+i)-\n\t\t\t\t\t\t(long long)b*i<=c*2+tmp+V-2){\n\t\t\t\t\t\tleft=M;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright=M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// printf(\"%d %d: %d\\n\",j,i,left);\n\t\t\t\tret+=left;\n\t\t\t\tif(i){\n\t\t\t\t\tret+=left;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(a,b);\n\t}\n\tret*=2;\n\tprintf(\"%lld\\n\",ret);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint dfrac(int x, int y) {\n  if (x < 0)return (x - y + 1) / y;\n  return x / y;\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n\n  function<ll(int, int, int)> solve = [&](int n, int m, int k) {\n\n    vector<int> div(n + 1);\n    for (int i = 1; i <= n; ++i)\n      for (int j = i; j <= n; j += i)\n        ++div[j];\n\n    ll ret = 0;\n    for (int i = 1; i < n; ++i) {\n      for (int d = 0; d < m - 1; ++d) {\n        int d1 = gcd(d, n);\n        int S2 = i * d;\n        // G = S - (d1 + d2 + d3)/2\n        int est = d1 + div[i] + div[n - i];\n        if (S2 - n * 2 + 1 > k * 2) break;\n        if (S2 - est + 1 > k * 2) continue;\n        int least = min(dfrac(k * 2 - S2 + est - 1, n) - 1, m - 1 - d);\n        least = max(least, 0);\n        //int least = 0;\n        ll con = 0;\n        con += least;\n        for (int j = least + 1; j * n + S2 - n * 2 + 1 <= k * 2 && j + d < m; ++j) {\n          int act = S2 + j * n - d1 - gcd(i, j) - gcd(n - i, j + d) + 1;\n          if (act <= k * 2)\n            ++con;\n        }\n        if (d == 0) ret += con;\n        else\n          ret += con * 2;\n      }\n    }\n    return ret;\n  };\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  cout << (solve(n, m, k) + solve(m, n, k)) * 2;\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n//binary gcd\nll gcd(ll _a, ll _b) {\n    ull a = abs(_a), b = abs(_b);\n    if (a == 0) return b;\n    if (b == 0) return a;\n    int shift = bsf(a|b);\n    a >>= bsf(a);\n    do {\n        b >>= bsf(b);\n        if (a > b) swap(a, b);\n        b -= a;\n    } while (b);\n    return (a << shift);\n}\n\n/// g:gcd(a, b), ax+by=g\nstruct EG { ll g, x, y; };\nEG ext_gcd(ll a, ll b) {\n    if (b == 0) {\n        if (a >= 0) return EG{a, 1, 0};\n        else return EG{-a, -1, 0};\n    } else {\n        auto e = ext_gcd(b, a % b);\n        return EG{e.g, e.y, e.x - a / b * e.y};\n    }\n}\n\n\nll inv_mod(ll x, ll md) {\n    auto z = ext_gcd(x, md).x;\n    return (z % md + md) % md;\n}\n\ntemplate<class T, class U>\nT pow_mod(T x, U n, T md) {\n    T r = 1 % md;\n    x %= md;\n    while (n) {\n        if (n & 1) r = (r * x) % md;\n        x = (x * x) % md;\n        n >>= 1;\n    }\n    return r;\n}\n\n// (rem, mod)\npair<ll, ll> crt(const V<ll>& b, const V<ll>& c) {\n    int n = int(b.size());\n    ll r = 0, m = 1;\n    for (int i = 0; i < n; i++) {\n        auto eg = ext_gcd(m, c[i]);\n        ll g = eg.g, im = eg.x;\n        if ((b[i] - r) % g) return {0, -1};\n        ll tmp = (b[i] - r) / g * im % (c[i] / g);\n        r += m * tmp;\n        m *= c[i] / g;\n    }\n    return {(r % m + m) % m, m};\n}\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nll S2(ll a, ll b, ll c, ll d) {\n    return a * d - b * c;\n}\nll check(ll s2, ll a, ll b, ll c, ll d, ll g_cd) {\n    ll i2 = s2 - (gcd(a, b) + g_cd + gcd(a - c, b - d)) + 2;\n    return i2 / 2;\n}\n\nll solve(ll w, ll h, ll n) {\n    ll s_pred = 2 * n + 3 * min(w, h);\n    ll ans = 0;\n    for (ll i = 1; i < w; i++) {\n        for (ll j = 1; j < h; j++) {\n            if (S2(w - i, 1, -i, j) > s_pred) break;\n            ll g_cd = gcd(-i, j);\n            ll lw_k = 0, up_k = h;\n            while (up_k - lw_k > 1) {\n                ll mid_k = (lw_k + up_k) / 2;\n                ll s2 = S2(w - i, mid_k, -i, j);\n                if (s2 - g_cd + 2 <= 2 * n) {\n                    lw_k = mid_k;\n                } else {\n                    up_k = mid_k;\n                }\n            }\n            ans += (up_k - 1);\n            for (ll k = up_k; k < h; k++) {\n                // (i, 0), (w, k), (0, j)\n                ll s2 = S2(w - i, k, -i, j);\n                if (s2 - g_cd - 2 * min(w, h) + 2 > 2 * n) break;\n                if (check(s2, w - i, k, -i, j, g_cd) <= n) ans++;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll w, h, k;\n    sc.read(w, h, k);\n\n    ll ans = 2 * solve(w, h, k) + 2 * solve(h, w, k);\n\n    pr.writeln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, k;\nll work(int n, int m) {\n\tll ans = 0;\n\tfor (int i = 0; i <= n - 2; i++)\n\tfor (int j = 1; j <= m - 1 && i * j <= 2 * k + m; j++) {\n\t\tint tmp = 2 * k + __gcd(i, m) - i * j - 2;\n\t\tif (tmp >= 0) {\n\t\t\tint limit = min(n - 1 - i, tmp / m + 1);\n\t\t\tans += (limit - (m * limit - __gcd(limit, j) - __gcd(limit + i, m - j) > tmp)) * (1 + (i != 0));\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(m), read(k);\n\tcout << work(n, m) * 2 + work(m, n) * 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint n,m,k;\nlong long gcd(int x,int y)\n{\n\tif (y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid swap(int &x,int &y)\n{\n\tint t=x;x=y;y=t;\n}\nlong long calculate(int r,int c)\n{\n\tlong long total=0;\n\tfor (int x1=1;x1<r;x1++)\n\t\tfor (int y=1;y<c;y++)\n\t\t\tfor (int z1=1;z1<r;z1++)\n\t\t\t{\n\t\t\t\tint x=x1,z=z1;\n\t\t\t\tif (x>z) swap(x,z);\n\t\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\t\tif (p<=2*k-1) total++;\n\t\t\t}\n\treturn total*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t//n++;m++;\n\tlong long ans=0;\n\tans=calculate(n,m);\n\tans=ans+calculate(m,n);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\t/*FOR(y,1,w)\n\t\tFOR(z,1,h)\n\t\t\tFor(x,1,z) if (1ll*y*z+1ll*x*(w-y)-__gcd(x,y)-__gcd(w-y,z)-__gcd(w,z-x)<=2*k-2){\n\t\t\t\tans++;\n\t\t\t\tprintf(\"%d %d %d %d\\n\",w,y,z,x);\n\t\t\t\tif (z!=x) ans++;\n\t\t\t}\n\treturn ans;*/\n\tll sum=0;\n\tFOR(y,1,w){\n\t\t++ans;\n\t\tFor(z,2,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),L=0,R=0,lim=2*k-2;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-2-tmp<=lim) L=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tl=1,r=z-1;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-y-min(z-mid,w)-tmp<=lim) R=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tif (R==0) break;\n\t\t\tsum+=R-L;\n\t\t\tint ret=2*L;\n\t\t\tFor(x,L+1,R) if (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\tret+=2;\n\t\t\t}\n\t\t\tans+=ret;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tif (w==1||h==1) return puts(\"0\"),0;\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}\n/*\n100000 100000 100000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define i128 __int128\n#define mp make_pair\n#define ld long double\ntypedef pair<int, int> pii;\ntypedef priority_queue<int, vector<int>, greater<int> > small_heap;\ntypedef priority_queue<int> big_heap;\nconst int N = 1e6 + 100;\nint T;\nint h, w, k;\n\nll solve(int w, int h) {\n    ll ans = 0;\n    for (int a = 1; a < w; a++) {\n        for (int cha = 0; cha < h; cha++) {\n            int R = 2 * k - a * cha + __gcd(cha, w) - 2;\n            if (R < 0)break;\n            int low = min(h - cha - 1, R / w);\n            ans += cha == 0 ? low : low * 2;\n            low++;\n            if (low + cha < h && w * low - __gcd(w - a, low + cha) - __gcd(a, low) <= R)\n                ans += cha == 0 ? 1 : 2;\n        }\n    }\n    return ans * 2;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &w, &h, &k);\n    printf(\"%lld\\n\", solve(w, h) + solve(h, w));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>     \n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nint H,W,K;\nll Ans=0;\n\nint gcd(int a,int b){\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\n\ninline void solve(){\n\tfor(int s=0;s<=min(H-2,2*K+W-2);++s)\n\t    for(int x=1;x<W&&x*s<=2*K+W-2;++x){\n\t    \tint R=2*K+gcd(s,W)-s*x-2;\n\t    \tint tmp=min(R/W,H-s-1);\n\t    \tif(tmp>0){\n\t    \t\tif(s==0)Ans+=2ll*tmp;\n\t    \t\telse Ans+=4ll*tmp;\n\t\t\t}\n\t    \tint yy=(R/W)+1;\n\t    \tif(yy>=H-s)continue;\n\t    \tif(1ll*W*yy-gcd(x,yy)-gcd(W-x,yy+s)<=R){\n\t    \t\tif(s==0)Ans+=2;\n\t    \t\telse Ans+=4;\n\t\t\t}\n\t\t}\n}\n\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n}\n\nint main(){\n\trd(W);rd(H);rd(K);\n\tsolve();\n\tswap(W,H);\n\tsolve();\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint K;\nlong f(int W,int H)\n{\n\tlong ans=0;\n\tconst int LIM=2*K+2.1e5;\n\tfor(int x=1;x<W;x++)\n\t{\n\t\tfor(int y2=1;y2<H&&x*y2<=LIM;y2++)\n\t\t{\n\t\t\tconst int LIM2=LIM-x*y2;\n\t\t\tint preb=gcd(W-x,y2);\n\t\t\tfor(int y1=1;y1<H&&(W-x)*y1<=LIM2;y1++)\n\t\t\t{\n\t\t\t\tint b=gcd(x,y1)+preb+gcd(W,abs(y1-y2));\n\t\t\t\tint S=x*y2+(W-x)*y1;\n\t\t\t\tif(S-b+2<=2*K)ans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\nmain()\n{\n\tint W,H;\n\tcin>>W>>H>>K;\n\tcout<<f(W,H)+f(H,W)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn m*min(a,c)+abs(c-a)*b-(__gcd(m,abs(c-a))+__gcd(b,min(a,c))+__gcd(m-b,max(a,c)));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll d=0;d<=min(n-1,ll(410000)/b);d++)\n\t\t{\n\t\t\tll R = k-b*d+__gcd(b,m);\n\t\t\tif(R<0) continue;\n\t\t\tll mina=R/m;\n\t\t\tll coeff=2;\n\t\t\tif(d==0) coeff=1;\n\t\t\t//cerr<<b<<' '<<d<<' '<<mina<<'\\n';\n\t\t\t\n\t\t\tif(mina+3<=n-1-d)\n\t\t\t{\n\t\t\t\tassert(calc(n,m,mina+3,b,mina+3+d)>k);\n\t\t\t}\n\t\t\t\n\t\t\tfor(ll z=mina+1;z<=mina+2;z++)\n\t\t\t{\n\t\t\t\tif(z<=n-1-d&&calc(n,m,z,b,z+d)<=k) ans+=coeff;\n\t\t\t}\n\t\t\tans+=coeff*min(mina,n-1-d);\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nll get(int H, int W, int K){\n\tint R = 2 * K - 2;\n\tll ret = 0;\n\tfor(int x = 1; x < H; x++){\n\t\tfor(int p = 1; p * x - 3 * min(H, W) <= R && p < W; p++){\n\t\t\tint b = __gcd(H - x, p);\n\t\t\tint r = R - p * x + b;\n\n\t\t\tint mx = max(0, r) / (H-x);\n\n\t\t\tret += min(mx, W - 1);\n\t\t\t\n\t\t\tfor(int q = mx + 1; q < W; q++){\n\t\t\t\tif(q * (H - x) > r + x + H) break;\n\t\t\t\tret += (q * (H - x) - __gcd(q, x) - __gcd(abs(p - q), H)) <= r;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint W, H, K; cin >> W >> H >> K;\n\tcout <<  2 * (get(H, W, K) + get(W, H, K)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef complex<double> cd;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\n#define bugf(...) fprintf(stderr,__VA_ARGS__);\n#define bugs(x) cerr<<\"    \"<<(x);\n#define bugx(x) cerr<<\"    \"<<(#x)<<\" = \"<<(x);\n#define bugl cerr<<\"\\n\";\n#define bugL cerr<<\"\\n================================================\\n\";\n#define bugt bugx(clock());bugl;\n#define R register\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tint c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\ninline int abs(int a){return (a<0)?(-a):a;}\nint ans;\ninline void sol(int w,int h,int k){\n\t//bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tint a,b,c,A,C,B=k+h-2,D;\n\trep(b,1,h>>1){\n\t\tA=min(B/(h-b)+2,w);\n\t\tD=B;\n\t\tREP(a,1,A){\n\t\t\tC=min(D/b+2,w);\n\t\t\tREP(c,1,C)if(a*(h-b)+b*c+2<=k+gcd(a,b)+gcd(c,h-b)+gcd(abs(a-c),h)){\n\t\t\t\tif((b<<1)==h)++ans;\n\t\t\t\telse ans+=2;\n\t\t\t}\n\t\t\tcmax(D-=h-b,0);\n\t\t}\n\t}\n}\ninline void ac(){\n\tint w,h,k,n,i;\n\tscanf(\"%d%d%d\",&w,&h,&k);k<<=1;\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%d\",ans<<1);\n}\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t\n\tac();\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n,m,k;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline int gcd(int x,int y) { return (!y)?x:gcd(y,x%y); }\n\ninline ll calc(int c,int d,int lim)\n{\n\tif (lim<0) return 0;\n\tll res=0;\n\tint hh=lim/m,mx=n-d-1;\n\tres+=max(0,min(mx,hh-1));\n\tif (hh>0&&hh<=mx&&(ll)hh*m-gcd(m-c,hh+d)-gcd(hh,c)<=lim) res++;\n\thh++;\n\tif (hh>0&&hh<=mx&&(ll)hh*m-gcd(m-c,hh+d)-gcd(hh,c)<=lim) res++;\n\thh++;\n\tif (hh>0&&hh<=mx&&(ll)hh*m-gcd(m-c,hh+d)-gcd(hh,c)<=lim) res++;\n\treturn res;\n}\n\ninline ll work()\n{\n\tll res=0;\n\tint mx=k*2-2+m;\n\tfor (int i=1;i<=min(m-1,mx);i++) for (int j=0;j*i<=mx&&j<=n-2;j++)\n\t{\n\t\tif (j==0) res+=calc(i,j,k*2-2-i*j+gcd(j,m));\n\t\telse res+=calc(i,j,k*2-2-i*j+gcd(j,m))*2;\n\t}\n\treturn res*2;\n}\n\nint main()\n{\n\tn=rd();m=rd();k=rd();\n\tll ans=work();\n\tswap(n,m);\n\tprintf(\"%lld\\n\",ans+work());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint h,w,k;\nll solve(int w,int h)\n{\n    ll ans=0;\n    for(int a=1;a<w;a++)\n        for(int b=1;b<h;b++)\n    {\n        int R=2*k-b*(w-a)+__gcd(a,b)-2;\n        if(R<-h) break;\n        int low=min(R/a,h-1);\n        low=max(low,b-1);\n        //cout<<a<<' '<<b<<' '<<low<<endl<<endl;\n        if(low>b) ans+=(low-b)*2;\n        for(int c=low+1;c<=low+200&&c<h;c++)\n            if(c>=b)\n            {\n                int k=a*c-__gcd(w-a,c)-__gcd(c-b,w);\n                if(k<=R) ans+=c==b?1:2;\n            }\n        if(low>=b)\n        {\n            int c=b;\n            int k=a*c-__gcd(w-a,c)-__gcd(c-b,w);\n            if(k<=R) ans+=c==b?1:2;\n        }\n    }\n    return ans*2;\n}\nll ssolve(int w,int h)\n{\n    ll ans=0;\n    for(int a=1;a<w;a++)\n        for(int b=1;b<h;b++)\n    {\n        //cout<<a<<' '<<b<<endl;\n        for(int c=b;c<h;c++)\n        {\n            int R=2*k-b*(w-a)+__gcd(a,b)-2;\n            //assert(R>=-h-h);\n            int L=a*c-__gcd(w-a,c)-__gcd(c-b,w);\n            if(c!=b) assert(L<=a*c&&L>=(a-2)*c);\n            if(L<=R)\n                ans+=c==b?1:2;//,cout<<c<<' ';\n        }\n        //cout<<endl<<endl;\n    }\n    return ans*2;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&w,&h,&k);\n    printf(\"%lld\\n\",solve(w,h)+solve(h,w));\n}\n/*\n5 4 5\n1 1\n1 2 3\n\n1 2\n2 3\n\n1 3\n3\n\n2 1\n1 2 3\n\n2 2\n2 3\n\n2 3\n3\n\n3 1\n1 2 3\n\n3 2\n2\n\n3 3\n3\n\n4 1\n1 2\n\n4 2\n2\n\n4 3\n3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint w, h, k;\n\nllint gcd(llint a, llint b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nllint calc(llint w, llint h)\n{\n\tllint ret = 0;\n\tfor(llint x = 1; x < w; x++){\n\t\tfor(llint y = 1; y < h; y++){\n\t\t\tif((w-x)*y > k + 3*max(w, h)) break;\n\t\t\tllint K = k + gcd(x, y) - (w-x)*y;\n\t\t\tif(K > 0) ret += min(h-1, K / x);\n\t\t\tfor(llint z = max(1LL, K/x+1); z < h; z++){\n\t\t\t\tif(x*z > K + (w-x) + w) break;\n\t\t\t\tif(x*z - gcd(w-x, z) - gcd(w, abs(y-z)) <= K) ret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> w >> h >> k;\n\tk = 2*k - 2;\n\t\n\tllint ans = 2 * calc(w, h) + 2 * calc(h, w);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nlong long ans = 0ll;\n\nint gcd(int x, int y) {\n\tif (x < 0) x = -x;\n\tif (y < 0) y = -y;\n\tif (x < y) swap(x, y);\n\twhile (y) {\n\t\tint r = x % y;\n\t\tx = y, y = r;\n\t}\n\treturn x;\n}\nlong long solve(int w, int h, int s) {\n\tlong long res = 0ll;\n\tfor (int i = 1; i < h; i++) {\n\t\tint i_ = max(i, h - i);\n\t\t// We can replace i with i_.\n\t\tfor (int j = 1; j < w && j <= (2 * s + 3 * h) / i_; j++) {\n\t\t\tint k_min = (s * 2 - i_ * j) / (h - i_);\n\t\t\tk_min = min(k_min, w - 1);\n\t\t\tk_min = max(k_min, 0);\n\t\t\tres += k_min;\n\t\t\tint g = gcd(h - i_, j);\n\t\t\tfor (int k = k_min + 1; k < w; k++) {\n\t\t\t\tif (i_ * j + (h - i_) * k - 3 * h + 2 > (s << 1)) break;\n\t\t\t\tint twice_n = i_ * j + (h - i_) * k - gcd(i_, k) - g - gcd(h, j - k) + 2;\n\t\t\t\tif (twice_n <= (s << 1)) res++; \n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tans = (solve(n, m, k) + solve(m, n, k)) << 1;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005;\nint f[N],g[N];\nll solve(int w,int h,int k){\n\tll ans=0;\n\tFor(h2,1,h-1){\n\t\tint h1=h-h2,L=0,R=0,mx=0;\n\t\tint l=1,r=w-1;\n\t\twhile(l<r){\n\t\t\tll b=((l+r)>>1)+1,a=b;\n\t\t\tif((a+b)*h-a*h1-b*h2-h+2<=2*k)l=b; else r=b-1;\n\t\t}\n\t\tL=l;\n\t\tl=0,r=w-1;\n\t\twhile(l<r){\n\t\t\tll b=((l+r)>>1)+1,a=b;\n\t\t\tif((a+b)*h-a*h1-b*h2-(h+h)+2<=2*k)l=b; else r=b-1;\n\t\t}\n\t\tR=l;\n\t\tFor(de,0,w-2){\n\t\t\tint gg=__gcd(h,de),sum=0;\n\t\t\twhile(L>1){\n\t\t\t\tint b=L,a=L+de;\n\t\t\t\tif(L>w-1-de||(a+b)*h-a*h1-b*h2-gg+2>2*k)L--; else break;\n\t\t\t}\n\t\t\twhile(R){\n\t\t\t\tint b=R,a=R+de;\n\t\t\t\tif(R>w-1-de||(a+b)*h-a*h1-b*h2-(h+gg)+2>2*k)R--; else break;\n\t\t\t}\n\t\t\t//R=min(R+1,w-1-de);\n\t\t\t//L=1; R=w-1-de;'\n\t\t\tif(L>R)break;\n\t\t\tFor(o,mx+1,R+de)f[o]=__gcd(o,h1);\n\t\t\tmx=max(mx,R+de);\n\t\t\tif(!de)For(o,1,R)g[o]=__gcd(o,h2);\n\t\t\tsum+=L-1;\n\t\t\tFor(b,L,R){\n\t\t\t\tint a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(f[a]+g[b]+gg)+2<=2*k){\n\t\t\t\t\t//assert(((a+b)*h-a*h1-b*h2-2*(h+gg)+2<=k));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(de)ans+=sum*2; else ans+=sum;\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint w=read(),h=read(),k=read();\n\tcout<<solve(w,h,k)+solve(h,w,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define R register\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tR int c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\nint ans;\ninline void sol(int w,int h,int k){\n\t//bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tint a,b,c,A,C,B=k+h-2,D;\n\trep(b,1,h>>1){\n\t\tA=min(B/(h-b)+2,w);\n\t\tD=B;\n\t\tREP(a,1,A){\n\t\t\tC=min(D/b+2,w);\n\t\t\tREP(c,1,C)if(a*(h-b)+b*c+2<=k+gcd(a,b)+gcd(c,h-b)+gcd((a>c)?(a-c):(c-a),h)){\n\t\t\t\tif((b<<1)==h)++ans;\n\t\t\t\telse ans+=2;\n\t\t\t}\n\t\t\tcmax(D-=h-b,0);\n\t\t}\n\t}\n}\ninline void ac(){\n}\nint main(){\n\tint w,h,k,n,i;\n\tscanf(\"%d%d%d\",&w,&h,&k);k<<=1;\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%d\",ans<<1);\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint K;\nint solve(int W,int H){\n\tint ans=0;\n\tfor(int S=0;S<H-1;++S)\n\t\tfor(int X=1;X<W && 2*K+W-S*X>=0;++X){\n\t\t\tint R=2*K+__gcd(S,W)-S*X-2;\n\t\t\tif(R>=0){\n\t\t\t\tint p=min(H-1-S,R/W+1);\n\t\t\t\tif(W*p-__gcd(X,p)-__gcd(W-X,p+S)>R) --p;\n\t\t\t\tans+=p;if(S!=0) ans+=p;\n\t\t\t} \n\t\t} \n\treturn ans;\n}\nsigned main(){\n\tint W,H;\n\tcin>>W>>H>>K;\n\tcout<<solve(W,H)*2+solve(H,W)*2;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2; if (i * 2 == W) base = 1;\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + W + 2) break;\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nint spe[100005];\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+2000,top=0;\n\tFor(k,1,H-1) if (gcd(k,W)>=1000) spe[++top]=k;\n\tFor(k,W-W/2,W-1){\n\t\t//if (k%100==0) cerr<<k<<endl;\n\t\tint B=min(500000/(W-k),H-1),rp=(k*2==W?1:2);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k)-gcd(k,i),key2=k;\n\t\t\tll b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tif (b1>=i) ans-=rp;\n\t\t\tb1=min(b1,1ll*(H-1)); ans+=b1*rp; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tll cv=key1-gcd(W,abs(i-b1))-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2&&b1!=i) ans+=rp;\n\t\t\t}\n\t\t\tll arr=1ll*W*i;\n\t\t\tll cv=arr-W-gcd(k,i)-gcd(W-k,i);\n\t\t\tif (cv<=2*K-2) ans+=rp;\n\t\t\tif (1ll*(W-k)*1000<=2*K+W+2000){\n\t\t\t\t//if (i==1) cerr<<k<<endl;\n\t\t\t\tFor(sgn,-1,1) if (sgn) For(p,1,top){\n\t\t\t\t\tint b=i+sgn*spe[p];\n\t\t\t\t\tif (b<b1||b>=H) continue;\n\t\t\t\t\tll arr=1ll*(W-k)*i-gcd(k,i)+1ll*k*b;\n\t\t\t\t\tif (arr>2*K+W+1200) break;\n\t\t\t\t\tll cv=arr-gcd(W,abs(i-b))-gcd(W-k,b);\n\t\t\t\t\t//if (i==2501&&spe[p]==2500) cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t\tif (cv<=2*K-2&&arr>LIM) ans+=rp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n5000 5000 100000\n197045732\n100000 100000 100000\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nint spe[100005];\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+2000,top=0;\n\tFor(k,1,H-1) if (gcd(k,W)>=1000) spe[++top]=k;\n\tFor(k,W-W/2,W-1){\n\t\tint B=min(500000/(W-k),H-1),rp=(k*2==W?1:2);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k)-gcd(k,i),key2=k;\n\t\t\tll b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tif (b1>=i) ans-=rp;\n\t\t\tb1=min(b1,1ll*(H-1)); ans+=b1*rp; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tll cv=key1-gcd(W,abs(i-b1))-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2&&b1!=i) ans+=rp;\n\t\t\t}\n\t\t\tll arr=1ll*W*i;\n\t\t\tll cv=arr-W-gcd(k,i)-gcd(W-k,i);\n\t\t\tif (cv<=2*K-2) ans+=rp;\n\t\t\tif (1ll*(W-k)*1000<=2*K+W+2000){\n\t\t\t\t//if (i==1) cerr<<k<<endl;\n\t\t\t\tFor(p,1,top) For(sgn,-1,1) if (sgn){\n\t\t\t\t\tint b=i+sgn*spe[p];\n\t\t\t\t\tif (b<b1||b>=H) continue;\n\t\t\t\t\tll arr=1ll*(W-k)*i-gcd(k,i)+1ll*k*b;\n\t\t\t\t\tll cv=arr-gcd(W,abs(i-b))-gcd(W-k,b);\n\t\t\t\t\t//if (i==2501&&spe[p]==2500) cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t\tif (cv<=2*K-2&&arr>LIM) ans+=rp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n5000 5000 100000\n197045732\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\nint s[209][100009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\tif (a <= 100000 && b <= 200) return s[b][a];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = i; j <= 200; j += i) {\n\t\t\tfor (int k = i; k <= 100000; k += i) s[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * (W - i) / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - k); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 300) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint area = a * k + b * j;\n\t\t\t\tint z1 = gcd(a, j);\n\t\t\t\tint z2 = gcd(b, k);\n\t\t\t\tint z3 = gcd(W, abs(j - k));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\nint s[209][100009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\tif (a <= 100000 && b <= 200) return s[b][a];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = i; j <= 200; j += i) {\n\t\t\tfor (int k = i; k <= 100000; k += i) s[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * (W - i) / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - k); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 300) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<iostream>\nusing namespace std;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint K;\nint pregcd[1<<17];\nlong f(int W,int H)\n{\n\tlong ans=0;\n\tconst int LIM=2*K+2*W;\n\tfor(int i=0;i<H;i++)pregcd[i]=gcd(W,i);\n\tfor(int x=1;x<W;x++)\n\t{\n\t\tfor(int y1=1;y1<H&&(W-x)*y1<=LIM;y1++)\n\t\t{\n\t\t\tconst int LIM2=LIM-(W-x)*y1;\n\t\t\tint preb=gcd(x,y1);\n\t\t\tfor(int y2=1;y2<=y1&&x*y2<=LIM2;y2++)\n\t\t\t{\n\t\t\t\tint b=preb+gcd(W-x,y2)+pregcd[y1-y2];\n\t\t\t\tint S=x*y2+(W-x)*y1;\n\t\t\t\tif(S-b+2<=2*K)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tans+=y2<y1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\nmain()\n{\n\tint W,H;\n\tcin>>W>>H>>K;\n\tcout<<f(W,H)+f(H,W)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nint gcd(int a,int b){\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tint s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\treturn a<<s;\n\t\n}\n\npi sub(pi a,pi b){\n\treturn pi(a.a-b.a,a.b-b.b);\n}\n\nint crs(pi a,pi b){\n\treturn a.a*b.b-a.b*b.a;\n}\n\nint tri2(pi a,pi b,pi c){\n\treturn abs(crs(sub(c,a),sub(b,a)));\n}\n\nint interior(pi a,pi b,pi c,int base){\n\tint ans=tri2(a,b,c);\n\tans-=gcd(a.a-b.a,a.b-b.b);\n\t//ans-=gcd(b.a-c.a,b.b-c.b);\n\tans-=gcd(c.a-a.a,c.b-a.b);\n\tans-=base;\n\tans+=2;\n\treturn ans/2;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint h,w,k;cin>>h>>w>>k;\n\tint ans=0;\n\trep(_,2){\n\t\trng(left,1,h){\n\t\t\trep(dif,w-1){\n\t\t\t\tif(tri2(pi(0,left),pi(1+dif,0),pi(1,h))>(k+min(h,w))*2)break;\n\t\t\t\tint lw=0,up=w-dif;\n\t\t\t\tint base=gcd(h,dif);\n\t\t\t\twhile(up-lw>1){\n\t\t\t\t\tconst int mid=(lw+up)/2;\n\t\t\t\t\tint t=tri2(pi(0,left),pi(mid+dif,0),pi(mid,h));\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(t<=(k+min(h,w))*2){\n\t\t\t\t\t\tt-=base;\n\t\t\t\t\t\tt-=gcd(left,mid+dif);\n\t\t\t\t\t\tt-=gcd(h-left,mid);\n\t\t\t\t\t\tt+=2;\n\t\t\t\t\t\tif(t/2<=k)ok=true;\n\t\t\t\t\t}\n\t\t\t\t\tif(ok)\n\t\t\t\t\t\tlw=mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tup=mid;\n\t\t\t\t}\n\t\t\t\tans+=lw;\n\t\t\t\tif(dif>0)ans+=lw;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(h,w);\n\t}\n\tprint(ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vi2 = vector<vector<int>>;\n#define MP(a,b) make_pair((a),(b))\n#define MT(...) make_tuple(__VA_ARGS__)\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl;\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl;\n#define gcda(x,y) gcd(abs(x),abs(y))\n\n#define DCOUT(x,n) cout << fixed << setprecision(n) << (x) << endl;\n\n#define sz(x) (int)(x).size()\n#define HOGE cout << \"hoge\" << endl;\nusing P = pair<ll,ll>;\n\ntemplate<typename T>inline istream& operator>>(istream&i,vector<T>&v)\n{REP(j,sz(v))i>>v[j];return i;}\n\nconst int INF = 1e9;\n\nint main(){\n    //s = i + p/2 - 1\n    //i = s - p/2 + 1\n    int w, h;\n    cin >> w >> h;\n  \tint k;\n  \tcin >> k;\n    ll ans1 = 0;\n    ll ans2 = 0;\n    \n    //パターン1 (0,0) と (a,b) と (c,h)\n    for(int c = -w+2; c <= w-2; c++){\n        for(int a = max(c+1,1); a <= min(w+c-1,w-1); a++){\n            for(int b = 1; b <= h-1; b++){\n                double s = abs(a*h-b*c)/2;\n                double p = gcda(a,b)+gcda(c,h)+gcda(a-c,b-h);\n                double i = s - p/2 +1;\n                if(i<=k) ans1 ++;\n            }\n        }\n    }\n    ans1 *= 2;\n\n    //パターン2 (0,0) と (a,b) と (c,w)\n    for(int c = -h+2; c <= h-2; c++){\n        for(int a = max(c+1,1); a <= min(h+c-1,h-1); a++){\n            for(int b = 1; b <= w-1; b++){\n                double s = abs(a*h-b*c)/2;\n                double p = gcda(a,b)+gcda(c,h)+gcda(a-c,b-h);\n                double i = s - p/2 +1;\n                if(i<=k) ans2 ++;\n            }\n        }\n    }\n    ans2 *= 2;\n\n    ll ans = ans1 + ans2;\n    cout << ans  << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005;\nint f[N],g[N];\nll solve(int w,int h,int k){\n\tll ans=0;\n\tFor(h2,1,h-1){\n\t\tint h1=h-h2,L=w-1,R=w-1;\n\t\tFor(de,0,w-2){\n\t\t\tint gg=__gcd(h,de),sum=0;\n\t\t\twhile(L>1){\n\t\t\t\tint b=L,a=L+de;\n\t\t\t\tif(L>w-1-de||(a+b)*h-a*h1-b*h2-gg+2>2*k)L--; else break;\n\t\t\t}\n\t\t\twhile(R){\n\t\t\t\tint b=R,a=R+de;\n\t\t\t\tif(R>w-1-de||(a+b)*h-a*h1-b*h2-(h+gg)+2>2*k)R--; else break;\n\t\t\t}\n\t\t\t//R=min(R+1,w-1-de);\n\t\t\t//L=1; R=w-1-de;'\n\t\t\tif(L>R)break;\n\t\t\tif(!de){\n\t\t\t\tFor(o,1,R+de)f[o]=__gcd(o,h1);\n\t\t\t\tFor(o,1,R)g[o]=__gcd(o,h2);\n\t\t\t}\n\t\t\tsum+=L-1;\n\t\t\tFor(b,L,R){\n\t\t\t\tint a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(f[a]+g[b]+gg)+2<=2*k){\n\t\t\t\t\t//assert(((a+b)*h-a*h1-b*h2-2*(h+gg)+2<=k));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(de)ans+=sum*2; else ans+=sum;\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint w=read(),h=read(),k=read();\n\tcout<<solve(w,h,k)+solve(h,w,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n//            c * w + (a - c) * b <= 2k;\n            long mina = max((2 * k - c * w) / b + c, c);\n            mina = min(mina, h);\n            if (mina > c) {\n                res += (mina - c) * 2 - 1;\n            }\n            for (long a = mina; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                if (s / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                long g = mm;\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a, w - b);\n                }\n                g += mem2[a];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nll area(int x1, int y1, int x2, int y2, int x3, int y3) {\n  int a = x2 - x1, b = y2 - y1;\n  int c = x3 - x1, d = y3 - y1;\n  return abs(a * (ll) d - b * (ll) c);\n}\n\nll f(int a, int b) {\n  a = abs(a), b = abs(b);\n  while (b) {\n    int ret = a % b;\n    a = b;\n    b = ret;\n  }\n  return a;\n}\n\nll cost(int x1, int y1, int x2, int y2, int x3, int y3) {\n  ll a = area(x1, y1, x2, y2, x3, y3);\n  ll g = f(x2 - x1, y2 - y1) + f(x3 - x1, y3 - y1) + f(x3 - x2, y3 - y2);\n  return a - g + 2;\n}\n\nll solve(int w, int h, int k) {\n  ll sum = 0;\n  for (int x1 = 1; x1 < w; x1++) {\n    for (int y = h - 1; y >= 1; y--) {\n      if (x1 * (ll) (h - y) > k + 3 * h) {\n        break;\n      }\n      ll val = x1 * (ll) (h - y) - f(y, x1);\n      ll mx = max(0ll, (k - val) / y);\n      sum += 2 * mx;\n      for (int x2 = mx + 1; x2 < w; x2++) {\n        if (val + x2 * (ll) y - h - w > k) {\n          break;\n        }\n        if (val + x2 * (ll) y - f(h - y, x2) - f(x2 - x1, h) <= k) {\n          sum += 2;\n        }\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  k = 2 * (k - 1);\n  cout << solve(w, h, k) + solve(h, w, k) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\nint s[209][100009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 100000 && b <= 200) return s[b][a];\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = i; j <= 200; j += i) {\n\t\t\tfor (int k = i; k <= 100000; k += i) s[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * (W - i) / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\t\t\t\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(x, a);\n\t\t\t\tint z2 = gcd(y, b);\n\t\t\t\tint z3 = gcd(abs(x - y), W);\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - k); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 300) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+2*W;\n\tint LIM2=2*K+W+1200;\n\tFor(k,1,W-1){\n\t\tFor(d,0,H-2){\n\t\t\tint p1=1,p2=p1+d;\n\t\t\tif (p2<1) p1+=1-p2,p2=1;\n\t\t\tll key=1ll*p1*(W-k)+1ll*p2*k;\n\t\t\tif (key>=2*K+3*W) break;\n\t\t\tkey-=gcd(abs(d),W);\n\t\t\tll b=(key>2*K?-1:max(0ll,(2*K-key)/W));\n\t\t\tans+=min(H-1ll-max(p1,p2),b)+1; key+=(++b)*W;\n\t\t\tfor (;key<=LIM&&b+p1<H&&b+p2<H;key+=W,++b){\n\t\t\t\tll cv=key-gcd(k,b+p1)-gcd(W-k,b+p2);\n\t\t\t\tif (cv<=2*K-2) ++ans;\n\t\t\t}\n\t\t}\n\t\tRep(d,-1,-H+2){\n\t\t\tint p1=1,p2=p1+d;\n\t\t\tif (p2<1) p1+=1-p2,p2=1;\n\t\t\tll key=1ll*p1*(W-k)+1ll*p2*k;\n\t\t\tif (key>=2*K+3*W) break;\n\t\t\tkey-=gcd(abs(d),W);\n\t\t\tll b=(key>2*K?-1:max(0ll,(2*K-key)/W));\n\t\t\tans+=min(H-1ll-max(p1,p2),b)+1; key+=(++b)*W;\n\t\t\tfor (;key<=LIM&&b+p1<H&&b+p2<H;key+=W,++b){\n\t\t\t\tll cv=key-gcd(k,b+p1)-gcd(W-k,b+p2);\n\t\t\t\tif (cv<=2*K-2) ++ans;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n\treturn 0;\n}\n/*\n5000 5000 100000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nconst int limit = 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nll get(int x, int y) {\n\tif (x < y) swap(x, y);\n\tif (y == 0) return x + 1;\n\tint q = x / y, r = x % y;\n\treturn 1ll * q * (y + 1) * y / 2 + get(y, r);\n}\nll get(int x, int y, bool type) {\n\tll ans = get(x, y);\n\tif (!type) ans -= 1 + __gcd(x, y);\n\treturn ans;\n}\nint n, m, k;\nbool check(int i, int j, int l) {\n\tif (i == j) return i * (m + 1ll) - get(i, l, true) - get(i, m - l, true) + 3 <= k;\n\telse return get(j - i, m, false) + i * (m + 1ll) - get(i, l, true) - get(j, m - l, true) + 3 <= k;\n}\nll work() {\n\tll ans = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tbool goon = false;\n\t\tfor (int j = 1; j <= m - 1; j++)\n\t\t\tif (check(i, i, j)) {\n\t\t\t\tgoon = true;\n\t\t\t\tans += 1;\n\t\t\t}\n\t\tif (!goon) break;\n\t}\n\tfor (int i = 1; i <= n - 2; i++) {\n\t\tbool goon = false;\n\t\tfor (int j = 1; j <= m - 1; j++)\n\t\t\tif (check(i, i + 1, j)) goon = true;\n\t\tif (!goon) break;\n\t\tfor (int j = i + 1; j <= i + limit && j <= n - 1; j++)\n\t\tfor (int k = 1; k <= m - 1; k++)\n\t\t\tans += check(i, j, k) * 2;\n\t\tint now = m - 1;\n\t\tfor (int j = i + limit + 1; j <= n - 1; j++) {\n\t\t\tnow = min(m - 1, now + limit);\n\t\t\twhile (now >= 1 && !check(i, j, now)) now--;\n\t\t\tans += 2 * now;\n\t\t\tfor (int l = now; l >= 1 && now - l <= limit; l--)\n\t\t\t\tans -= 2 * !check(i, j, l);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(m), read(k);\n\tll ans = work() * 2; swap(n, m);\n\tans += work() * 2;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+1200;\n\tFor(k,1,W-1){\n\t\tint B=min(500000/k,H-1);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k),key2=k;\n\t\t\tint b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tb1=min(b1,H-1); ans+=b1; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tint cv=key1-gcd(W,abs(i-b1))-gcd(k,i)-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2) ans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n100000 100000 100000\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tif (H>W) swap(H,W);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\tassert(c<=n);\n\treturn m*min(a,c)+abs(c-a)*b-(__gcd(m,abs(c-a))+__gcd(b,min(a,c))+__gcd(m-b,max(a,c)));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll d=0;d<=min(n-1,ll(410000)/b);d++)\n\t\t{\n\t\t\tll R = k-b*d+__gcd(b,m);\n\t\t\tif(R<0) continue;\n\t\t\tll mina=R/m;\n\t\t\tll coeff=2;\n\t\t\tif(d==0) coeff=1;\n\t\t\t//cerr<<b<<' '<<d<<' '<<mina<<'\\n';\n\t\t\t\n\t\t\tif(mina+3<=n-1-d)\n\t\t\t{\n\t\t\t\tassert(calc(n,m,mina+3,b,mina+3+d)>k);\n\t\t\t}\n\t\t\t\n\t\t\tfor(ll z=mina+1;z<=mina+2;z++)\n\t\t\t{\n\t\t\t\tif(z<=n-1-d&&calc(n,m,z,b,z+d)<=k) ans+=coeff;\n\t\t\t}\n\t\t\tans+=coeff*min(mina,n-1-d);\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n\n\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    vector<int> preg(W);\n    for (int i = 0; i < W; i++) preg[i] = __gcd(i, H);\n    \n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K - (H-y)*x1;\n            if (((LL)y)*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n                // low++;\n            }\n            int g = __gcd(x1, y);\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (y*x2 > 2*K+2*H) break;\n                LL c = (H-y)*x1 + y*x2 - (g + __gcd(x2, H-y) + preg[x1-x2]) + 2;\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    int W, H, K;\n    scanf(\"%d %d %d\", &W, &H, &K);\n    auto solve = [&](int W, int H) {\n        ll ans = 0;\n        for (int d = 0; d <= H - 2; d++) {\n            for (int j = 1; j < W && d * j <= 2 * K; j++) {\n                int t = 2 * K - 2 - d * j + __gcd(W, d);\n                if (t < 0) continue;\n                int i = min(H - d - 1, t / W + 1);\n                if (1LL * i * W - __gcd(i, j) - __gcd(W - j, i + d) > t) i--;\n                ans += i * (!d ? 1 : 2);\n            }\n        }\n        return ans;\n    };\n    printf(\"%lld\\n\", (solve(W, H) + solve(H, W)) * 2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n,m,k;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline int gcd(int x,int y) { return (!y)?x:gcd(y,x%y); }\n\ninline ll calc(int c,int d,int lim)\n{\n\tif (lim<0) return 0;\n\tint hh=lim/m,mx=n-d-1;\n\tll res=max(0,min(mx,hh));\n\thh++;\n\tif (hh>0&&hh<=mx&&hh*m-gcd(m-c,hh+d)-gcd(hh,c)<=lim) res++;\n\thh++;\n\tif (hh>0&&hh<=mx&&hh*m-gcd(m-c,hh+d)-gcd(hh,c)<=lim) res++;\n\treturn res;\n}\n\ninline ll work()\n{\n\tll res=0;\n\tint mx=k*2-2+m;\n\tfor (int i=1;i<=m-1;i++) for (int j=0;j*i<=mx&&j<=n-2;j++)\n\t{\n\t\tif (j==0) res+=calc(i,j,k*2-2-i*j+gcd(j,m));\n\t\telse res+=calc(i,j,k*2-2-i*j+gcd(j,m))*2;\n\t}\n\treturn res*2;\n}\n\nint main()\n{\n\tn=rd();m=rd();k=rd();\n\tll ans=work();\n\tswap(n,m);\n\tprintf(\"%lld\\n\",ans+work());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\nint w, h, k;\nll calc(int w, int h, int o){\n\tll ans=0;\n\tfor(int x=1; x<w; ++x) for(int z=o; x*z<=k*2-2+w && z<=h-2; ++z){\n\t\tint R=k*2-2+__gcd(w, z)-x*z;\n\t\tif(R<0) continue;\n\t\tans+=min(R/w, h-z-1);\n\t\tint y=R/w+1;\n\t\tif(y+z<h) ans+=(w*y-__gcd(x, y)-__gcd(w-x, y+z)<=R);\n\t}\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tprintf(\"%lld\\n\", (calc(w, h, 0)+calc(w, h, 1)+calc(h, w, 0)+calc(h, w, 1))*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n\n\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    vector<int> preg(W);\n    for (int i = 0; i < W; i++) preg[i] = __gcd(i, H);\n    \n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K - (H-y)*x1;\n            if (((LL)y)*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n            }\n            int g = __gcd(x1, y);\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (x1 != x2 and y*x2 > 2*K+g + H-y + x1-x2) x2 = x1;\n                LL c = (H-y)*x1 + y*x2 - (g + __gcd(x2, H-y) + preg[x1-x2]) + 2;\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint W, H, K;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint solve() {\n    // A = I + B / 2 - 1, where I <= K\n    // A - B / 2 + 1 = I <= K\n    // 2 * A - B <= 2 * (K - 1)\n    //\n    // A = H * W - W * (H - (y1 + y2) / 2) - x * y1 / 2 - (W - x) * y2 / 2\n    //   = W * (y1 + y2) / 2 - x * y1 / 2 - (W - x) * y2 / 2\n    //   = [(W - x) * y1 + x * y2] / 2\n    // B = gcd(y1 - y2, W) + gcd(y1, x) + gcd(y2, W - x)\n    int total = 0;\n    int lim = 2 * (K - 1) + 3 * W;\n    for (int x = 1; x < W; x++) {\n        for (int y2 = 1; y2 < H; y2++) {\n            if (x * y2 > lim)\n                break;\n            for (int y1 = 1; y1 <= y2; y1++) {\n                int A2 = (W - x) * y1 + x * y2;\n                if (A2 > lim)\n                    break;\n                int B = gcd(y1, x) + gcd(y2, W - x) + gcd(abs(y1 - y2), W);\n                if (A2 - B <= 2 * (K - 1)) {\n                    total++;\n                    if (y1 != y2)\n                        total++;\n                }\n            }\n        }\n    }\n    return total;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> W >> H >> K;\n\n    int total = solve();\n    swap(W, H);\n    total += solve();\n    total *= 2;\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 6/14/2020, 3:53:32 AM\n * Powered by Visual Studio Code\n */\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing namespace std;\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nusing max_heap = priority_queue<T>;\ntemplate <typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1'000'000'007LL};\n// constexpr ll MOD{998'244'353LL}; // be careful\nconstexpr ll MAX_SIZE{3'000'010LL};\n// constexpr ll MAX_SIZE{30'000'010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(Mint const &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(Mint const &a) { return *this += -a; }\n  Mint &operator++() { return *this += 1; }\n  Mint operator++(int)\n  {\n    Mint tmp{*this};\n    ++*this;\n    return tmp;\n  }\n  Mint &operator--() { return *this -= 1; }\n  Mint operator--(int)\n  {\n    Mint tmp{*this};\n    --*this;\n    return tmp;\n  }\n  Mint &operator*=(Mint const &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(Mint const &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(Mint const &a) const { return Mint(*this) += a; }\n  Mint operator-(Mint const &a) const { return Mint(*this) -= a; }\n  Mint operator*(Mint const &a) const { return Mint(*this) *= a; }\n  Mint operator/(Mint const &a) const { return Mint(*this) /= a; }\n  bool operator<(Mint const &a) const { return x < a.x; }\n  bool operator<=(Mint const &a) const { return x <= a.x; }\n  bool operator>(Mint const &a) const { return x > a.x; }\n  bool operator>=(Mint const &a) const { return x >= a.x; }\n  bool operator==(Mint const &a) const { return x == a.x; }\n  bool operator!=(Mint const &a) const { return !(*this == a); }\n  Mint power(ll N) const\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, Mint<MOD> const &rhs) { return rhs + lhs; }\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, Mint<MOD> const &rhs) { return -rhs + lhs; }\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, Mint<MOD> const &rhs) { return rhs * lhs; }\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, Mint<MOD> const &rhs) { return Mint<MOD>{lhs} / rhs; }\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a) { return stream >> a.x; }\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, Mint<MOD> const &a) { return stream << a.x; }\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i{2LL}; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i{1LL}; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\ntemplate <typename T>\nT gcd(T x, T y) { return y ? gcd(y, x % y) : x; }\ntemplate <typename T>\nT lcm(T x, T y) { return x / gcd(x, y) * y; }\n// ----- for C++17 -----\ntemplate <typename T>\nint popcount(T x) // C++20\n{\n  int ans{0};\n  while (x != 0)\n  {\n    ans += x & 1;\n    x >>= 1;\n  }\n  return ans;\n}\n// ----- Infty -----\ntemplate <typename T>\nconstexpr T Infty() { return numeric_limits<T>::max(); }\ntemplate <typename T>\nconstexpr T mInfty() { return numeric_limits<T>::min(); }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1'000'000'000'000'010LL}; // or\n// constexpr int infty{1'000'000'010};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\n// ----- Solve -----\n\nclass Solve\n{\n  ll W, H, K;\n\npublic:\n  Solve(ll W, ll H, ll K) : W{W}, H{H}, K{K} {}\n\n  ll answer()\n  {\n    ll ans{0};\n    for (auto s{0LL}; s < W - 1; ++s)\n    {\n      for (auto y{H - 1}; rhs_bound(s, y) >= 0 && y > 0; --y)\n      {\n        ll tmp{calc(s, y)};\n        if (s == 0)\n        {\n          ans += tmp;\n        }\n        else\n        {\n          ans += 2 * tmp;\n        }\n      }\n    }\n    return ans;\n  }\n\nprivate:\n  ll rhs(ll s, ll y)\n  {\n    return 2 * K - s * (H - y) + gcd(s, H) - 2;\n  }\n\n  ll rhs_bound(ll s, ll y)\n  {\n    return 2 * K - s * (H - y) + H - 2;\n  }\n\n  ll lhs(ll x, ll s, ll y)\n  {\n    return H * x - gcd(H - y, x) - gcd(y, x + s);\n  }\n\n  ll calc(ll s, ll y)\n  {\n    ll R{rhs(s, y)};\n    if (R < 0)\n    {\n      return 0;\n    }\n    ll ans{min(W - s - 1, R / H)};\n    ll x{R / H + 1};\n    if (x + s < W && lhs(x, s, y) <= R)\n    {\n      ++ans;\n    }\n    return ans;\n  }\n};\n\n// ----- main() -----\n\nint main()\n{\n  ll W, H, K;\n  cin >> W >> H >> K;\n  Solve solve(W, H, K), solve2(H, W, K);\n  ll ans{2 * solve.answer() + 2 * solve2.answer()};\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 13.06.2020 15:12:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long Solve(int w, int h, int k) {\n  k = 2 * k - 2;\n  long long ans = 0;\n  for (int x = 1; x < w; x++) {\n    for (int y0 = 1; y0 < h; y0++) {\n      int a = (w - x) * y0 - __gcd(x, y0);\n      if (a > k + 2 * w) {\n        break;\n      }\n      // a + x * y1 <= k?\n      // y1 <= (k - a) / x\n      int bound = min(h - 1, max(0, (k - a) / x));\n      ans += bound;\n      for (int y1 = bound + 1; y1 < h; y1++) {\n        int b = a + x * y1;\n        if (b > k + 2 * w) {\n          break;\n        }\n        int c = b - __gcd(w - x, y1) - __gcd(w, abs(y0 - y1));\n        if (c <= k) {\n          ans += 1;\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  cout << 2 * (Solve(w, h, k) + Solve(h, w, k)) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                long g = mm;\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a, w - b);\n                }\n                g += mem2[a];\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nint maxs=4e5+5;\nint sum=0;\nint a,b,k;\nvoid check(pair <int,int> a,pair <int,int> b,pair <int,int> c)\n{\n    int s=abs(a.first*b.second+b.first*c.second+c.first*a.second-a.second*b.first-b.second*c.first-c.second*a.first);\n    int g=abs(__gcd(a.first-b.first,a.second-b.second))+abs(__gcd(c.first-b.first,c.second-b.second))+abs(__gcd(a.first-c.first,a.second-c.second));\n    int ans=(s-g+2)/2;\n    if(ans<=k)\n    {\n        ++sum;\n    }\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    cin>>a>>b>>k;\n    for(int i=1;i<a;++i)\n    {\n        for(int j=1;j<min(maxs/i,b);++j)\n        {\n            for(int k=1;k<min(maxs/(a-i),b);++k)\n            {\n                check({i,0},{0,j},{a,k});\n            }\n        }\n    }\n    swap(a,b);\n    for(int i=1;i<a;++i)\n    {\n        for(int j=1;j<min(maxs/i,b);++j)\n        {\n            for(int k=1;k<min(maxs/(a-i),b);++k)\n            {\n                check({i,0},{0,j},{a,k});\n            }\n        }\n    }\n    sum*=2;\n    cout<<sum;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nint W, H, K;\n\ninline LL solve(int W, int H)\n{\n\tLL ans = 0;\n\tfor(int c = 1; c < W; c++)\n\t\tfor(int d = 0; d < H && c * d <= 2 * K + W - 2; d++)\n\t\t{\n\t\t\tint R = 2 * K - 2 + __gcd(W, d) - c * d;\n\t\t\tif(R >= 0)\n\t\t\t{\n\t\t\t\tint a = R / W + 1, t = min(H - 1 - d, R / W);\n\t\t\t\tif(a + d < H && a * W - __gcd(a, c) - __gcd(W - c, a + d) <= R) t ++;\n\t\t\t\tans += t * (1 + (d > 0));\n\t\t\t}\n\t\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &K);\n\tprintf(\"%lld\\n\", 2ll * (solve(W, H) + solve(H, W)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll w, h, k;\n\tcin >> w >> h >> k;\n\tk = 2 * k - 2;\n\tll ans = 0;\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tll x = (k - i * a) / w - i;\n\t\t\tchmin(x, h - 1);\n\t\t\tif (x < a) {\n\t\t\t\tfor (ll b = a; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += (x - a) * 2 + 1;\n\t\t\t\tfor (ll b = x + 1; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswap(w, h);\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tll x = (k - i * a) / w - i;\n\t\t\tchmin(x, h - 1);\n\t\t\tif (x < a) {\n\t\t\t\tfor (ll b = a; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += (x - a) * 2 + 1;\n\t\t\t\tfor (ll b = x + 1; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\ninline int calc(int x, int y) {\n    return __gcd(abs(x), abs(y)) - 1;\n};\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 3e5; j++) {\n                int tmp = calc(j, w - i);\n                int s;\n                for (int k = 1; k < h && (s = abs(j * i + (w - i) * k) - tmp) <= 2 * d + 2e5; k++) {\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                    else {\n                        s -= f[abs(j - k)];\n                        s -= calc(k, i);\n                        s -= 1;\n                        if (s <= d + d) {\n                            res += 2;\n                            if (i + i == w) {\n                                res--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define R register\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tint c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\nint ans;\ninline void sol(int w,int h,int k){\n\t//bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tint a,b,c,A,C,B=k+h-2,D;\n\trep(b,1,h>>1){\n\t\tA=min(B/(h-b)+2,w);\n\t\tD=B;\n\t\tREP(a,1,A){\n\t\t\tC=min(D/b+2,w);\n\t\t\tREP(c,1,C)if(a*(h-b)+b*c+2<=k+gcd(a,b)+gcd(c,h-b)+gcd((a>c)?(a-c):(c-a),h)){\n\t\t\t\tif((b<<1)==h)++ans;\n\t\t\t\telse ans+=2;\n\t\t\t}\n\t\t\tcmax(D-=h-b,0);\n\t\t}\n\t}\n}\ninline void ac(){\n}\nint main(){\n\tint w,h,k,n,i;\n\tscanf(\"%d%d%d\",&w,&h,&k);k<<=1;\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%d\",ans<<1);\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\nint s[209][100009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\tif (a <= 100000 && b <= 200) return s[b][a];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = i; j <= 200; j += i) {\n\t\t\tfor (int k = i; k <= 100000; k += i) s[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * (W - i) / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\t\t\t\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - k); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 400) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nll area(int x1, int y1, int x2, int y2, int x3, int y3) {\n  int a = x2 - x1, b = y2 - y1;\n  int c = x3 - x1, d = y3 - y1;\n  return abs(a * (ll) d - b * (ll) c);\n}\n\nll f(int a, int b) {\n  a = abs(a), b = abs(b);\n  while (b) {\n    int ret = a % b;\n    a = b;\n    b = ret;\n  }\n  return a;\n}\n\nll cost(int x1, int y1, int x2, int y2, int x3, int y3) {\n  ll a = area(x1, y1, x2, y2, x3, y3);\n  ll g = f(x2 - x1, y2 - y1) + f(x3 - x1, y3 - y1) + f(x3 - x2, y3 - y2);\n  return a - g + 2;\n}\n\nll solve(int w, int h, int k) {\n  ll sum = 0;\n  for (int x1 = 1; x1 < w; x1++) {\n    for (int y = h - 1; y >= 1; y--) {\n      if (x1 * (ll) (h - y) > k + 3 * h) {\n        break;\n      }\n      ll val = x1 * (ll) (h - y) - f(y, x1);\n      for (int x2 = 1; x2 < w; x2++) {\n        if (val + x2 * (ll) y - h - w > k) {\n          break;\n        }\n        if (val + x2 * (ll) y <= k) {\n          sum += 2;\n          continue;\n        }\n        if (val + x2 * (ll) y - f(h - y, x2) - f(x2 - x1, h) <= k) {\n          sum += 2;\n        }\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  k = 2 * (k - 1);\n  cout << solve(w, h, k) + solve(h, w, k) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\t/*FOR(y,1,w)\n\t\tFOR(z,1,h)\n\t\t\tFor(x,1,z) if (1ll*y*z+1ll*x*(w-y)-__gcd(x,y)-__gcd(w-y,z)-__gcd(w,z-x)<=2*k-2){\n\t\t\t\tans++;\n\t\t\t\tprintf(\"%d %d %d %d\\n\",w,y,z,x);\n\t\t\t\tif (z!=x) ans++;\n\t\t\t}\n\treturn ans;*/\n\tFOR(y,1,w){\n\t\t++ans;\n\t\tFor(z,2,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),R=0,lim=2*k-2;\n\t\t\tl=1,r=z-1;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-y-min(z-mid,w)-tmp<=lim) R=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tif (R==0) break;\n\t\t\tint ret=0;\n\t\t\tFor(x,1,R) if (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\tret+=2;\n\t\t\t}\n\t\t\tans+=ret;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tif (w==1||h==1) return puts(\"0\"),0;\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\n#define vsv sim,class d,class e\n#define nop(o,c,r,l...)>auto operator o(const c&a,const r&b)->decltype(make_pair(l)){return{l};}\n#define pcg(o) vsv,class f nop(o, pair <c u d>, pair <e u f>, a.first o b.first, a.second o b.second)vsv,class=typename enable_if<!is_base_of<ios_base,c>::value>::type nop(o,c,pair<d u e>,a o b.first,a o b.second)vsv nop(o,pair<c u d>,e,a.first o b,a.second o b)\n#define clp(o) pcg(o)vsv>void operator o##=(pair<c,d>&a,const e&b){a.first o##=b;a.second o##=b;}vsv,class f>void operator o##=(pair<c,d>&a,const pair<e,f>&b){a.first o##=b.first;a.second o##=b.second;}\n#define syd(o) sim,class d>auto operator o(pair<c, d> e)->decltype(make_pair(o e.first,o e.second)){return{o e.first,o e.second};}\n#define u ,\nclp(+)clp(-)clp(*)clp(/)clp(%)clp(^)clp(|)clp(>>)clp(<<)clp(&)pcg(&&)pcg(||)syd(-)syd(+)syd(~)syd(!)\n#undef u\nint on(pii a, pii b) {\n\ta -= b;\n\tint g = gcd(FS(a));\n\treturn abs(g);\n}\nll pro(pii a, pii b) {\n\treturn a.first * 1ll * b.second - a.second * 1ll * b.first;\n}\nll area2(pii a, pii b, pii c) {\n\treturn abs(pro(a - b, b - c));\n}\nint ins(pii a, pii b, pii c) {\n\tll s2 = area2(a, b, c);\n\t// debug(imie(a), imie(b), imie(c));\n\tassert(s2);\n\tint bou = on(a, b) + on(b, c) + on(c, a);\n\tint out = s2 - bou + 2;\n\t// debug(imie(a), imie(b), imie(c), imie(bou), imie(s2), imie(out));\n\tassert(out % 2 == 0 && out >= 0);\n\treturn out / 2;\n}\nint solve_old(int w, int h, int K) {\n\tint ans = 0;\n\tint bou = 2 * (K + h + 1);\n\tfor (int i = 1; i < w; ++i) {\n\t\tfor (int j = i; j < w; ++j) {\n\t\t\tint coef = (i == j ? 1 : 2);\n\t\t\tpii a = {0, i}, b = {h, j};\n\t\t\tpii c0 = {1, 0};\n\t\t\tif (area2(a, b, c0) > bou) break;\n\t\t\tfor (int k = 1; k < h; ++k) {\n\t\t\t\tpii c = {k, 0};\n\t\t\t\tif (area2(a, b, c) > bou) break;\n\t\t\t\tif (ins(a, b, c) <= K) ans += coef;\n\t\t\t}\n\t\t}\n\t}\n\trans;\n}\nint solve_semi(int W, int H, int K) {\n\tint ans = 0;\n\tint bou1 = 2 * K, bou2 = 2 * (K + H + 1);\n\tfor (int a = 1; a < W; ++a) {\n\t\tfor (int b = 1; b < H; ++b) {\n\t\t\tpii A = {a, 0}, B = {0, b}, C0 = {a, H};\n\t\t\tif (area2(A, B, C0) > bou2) break;\n\t\t\tfor (int c = a; c < W; ++c) {\n\t\t\t\tint coef = (a == c ? 1 : 2);\n\t\t\t\tpii C = {c, H};\n\t\t\t\tif (area2(A, B, C) > bou2) break;\n\t\t\t\tbool is = ins(A, B, C) <= K;\t\n\t\t\t\tif (area2(A, B, C) <= bou1) assert(is);\n\t\t\t\tif (is) ans += coef;\n\t\t\t}\n\t\t}\n\t}\n\trans;\n}\nint solve(int W, int H, int K) {\n\tint ans = 0;\n\tint bou1 = 2 * K, bou2 = 2 * (K + H + 1);\n\tfor (int a = 1; a < W; ++a) {\n\t\tfor (int b = 1; b < H; ++b) {\n\t\t\tpii A = {a, 0}, B = {0, b}, C0 = {a, H};\n\t\t\tif (area2(A, B, C0) > bou2) break;\n\t\t\tll a0 = area2(A, B, C0), a1 = area2(A, B, {a + 1, H});\n\t\t\tll step = a1 - a0;\n\t\t\tint x = max(0ll, min((bou1 - a0) / step, (ll)W - a));\n\t\t\tans += 2 * x - (x > 0);\n\t\t\tfor (int c = a + x; c < W; ++c) {\n\t\t\t\tint coef = (a == c ? 1 : 2);\n\t\t\t\tpii C = {c, H};\n\t\t\t\tif (area2(A, B, C) > bou2) break;\n\t\t\t\tbool is = ins(A, B, C) <= K;\t\n\t\t\t\tif (area2(A, B, C) <= bou1) assert(is);\n\t\t\t\tif (is) ans += coef;\n\t\t\t}\n\t\t}\n\t}\n\trans;\n}\nint main() {\n\tint w, h, K;\n\tscanf(\"%d%d%d\", &w, &h, &K);\n\tif (w == 1 || h == 1) done(\"0\\n\");\n\tprintf(\"%d\\n\", 2 * (solve(w, h, K) + solve(h, w, K)));\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nLL solve(int w, int h, int k)\n{\n    LL ret = 0;\n    for (int a = 1; a <= w - 1 && a * h <= 2 * k + 2 * h - 2; a++)\n        rep1(x, h - 1)\n        {\n            int ub = 2 * k + __gcd(a, h - x) - 2 - a * x;\n            ret += min(ub / (h - x), w - 1) >= a ? (min(w - 1, ub / (h - x)) - a) * 2 + 1 : 0;\n            for (int b = max(a, min(ub / (h - x), w - 1) + 1); b <= w - 1 && b * (h - x) <= ub + h + x; b++)\n                if (b * (h - x) - __gcd(h, b - a) - __gcd(b, x) <= ub)\n                    ret += b == a ? 1 : 2;\n        }\n    return ret;\n}\n\nint main()\n{\n    int w, h, k;\n    scanf(\"%d%d%d\", &w, &h, &k);\n    printf(\"%lld\\n\", 2 * solve(w, h, k) + 2 * solve(h, w, k));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nll get(int H, int W, int K){\n\tint R = 2 * K - 2;\n\tll ret = 0;\n\tfor(int x = 1; x < H; x++){\n\t\tfor(int p = 1; p * x - 3 * min(H, W) <= R && p < W; p++){\n\t\t\tint b = __gcd(H - x, p);\n\t\t\tint r = R - p * x + b;\n\t\t\t// q * x <= r ? \n\t\t\tint mx = max(0, r) / (H-x);\n\t\t\tret += min(mx, W - 1);\n\t\t\t\n\t\t\tfor(int q = mx + 1; q < W; q++){\n\t\t\t\tif(q * (H - x) > r + min(q, x) + H) break;\n\t\t\t\tret += (q * (H - x) - __gcd(q, x) - __gcd(abs(p - q), H)) <= r;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint W, H, K; cin >> W >> H >> K;\n\tcout <<  2 * (get(H, W, K) + get(W, H, K)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n// 10535724\nconst int B = 5;\n\nint gcd(int x, int y) {\n\tif (x < y) swap(x, y);\n\twhile(y > 0) {\n\t\tx %= y;\n\t\tswap(x, y);\n\t}\n\treturn x;\n}\nint inside(int y, int x1, int x2, int h) {\n\tint res = x1 * (h - y) + x2 * y + 2;\n\tres -= gcd(x2, h - y);\n\tres -= gcd(x1, y);\n\tres -= gcd(abs(x1 - x2), h);\n\tassert(res % 2 == 0);\n\treturn res / 2;\n}\nll solve(int y, int w, int h, int k) {\n\t//eprintf(\"solve %lld\\n\", y);\n\tll ans = 0;\n\tfor (int x = 1; x < w; x++) {\n\t\tif (x * y + h - y > 2 * k + 2 * h) break;\n\t\tint mx = (2 * k - x * y) / (h - y);\n\t\tmx = max(0, mx);\n\t\tmx = min(mx, w - 1);\n\t\tans += mx;\n\t\tfor (int t = mx + 1; t <= mx + B + 3 * (h < 10) + (h < 1000); t++) {\n\t\t\tif (t <= 0 || t >= w) continue;\n\t\t\tans += inside(y, t, x, h) <= k;\n\t\t}\n\t}\n\treturn ans;\n}\nll solve(int w, int h, int k) {\n\tll ans = 0;\n\tfor (ll y = 1; 2 * y <= h; y++) {\n\t\tll cur = solve(y, w, h, k);\n\t\tif (2 * y != h) cur *= 2;\n\t\tans += cur;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tll ans = solve(w, h, k) + solve(h, w, k);\n\tprintf(\"%lld\\n\", ans * 2);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nll area(int x1, int y1, int x2, int y2, int x3, int y3) {\n  int a = x2 - x1, b = y2 - y1;\n  int c = x3 - x1, d = y3 - y1;\n  return abs(a * (ll) d - b * (ll) c);\n}\n\nll f(int a, int b) {\n  a = abs(a), b = abs(b);\n  while (b) {\n    int ret = a % b;\n    a = b;\n    b = ret;\n  }\n  return a;\n}\n\nll cost(int x1, int y1, int x2, int y2, int x3, int y3) {\n  ll a = area(x1, y1, x2, y2, x3, y3);\n  ll g = f(x2 - x1, y2 - y1) + f(x3 - x1, y3 - y1) + f(x3 - x2, y3 - y2);\n  return a - g + 2;\n}\n\nll bad_consider = 0;\n\nll solve(int w, int h, int k) {\n  ll sum = 0;\n  int t = min(w, h);\n  for (int x1 = 1; x1 < w; x1++) {\n    for (int y = h - 1; y >= 1; y--) {\n      if (x1 * (ll) (h - y) > k + 3 * t) {\n        break;\n      }\n      ll val = x1 * (ll) (h - y) - f(y, x1);\n      ll mx = min((ll) w - 1, max(0ll, (k - val) / y));\n      sum += 2 * mx;\n      for (int x2 = mx + 1; x2 < w; x2++) {\n        if (val + x2 * (ll) y - 2 * t > k) {\n          break;\n        }\n        if (val + x2 * (ll) y - f(h - y, x2) - f(x2 - x1, h) <= k) {\n          sum += 2;\n        }\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  k = 2 * (k - 1);\n  cout << solve(w, h, k) + solve(h, w, k) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 3 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 3 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t\tif (area > 2 * K + W + 2) assert(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n//binary gcd\nll gcd(ll _a, ll _b) {\n    ull a = abs(_a), b = abs(_b);\n    if (a == 0) return b;\n    if (b == 0) return a;\n    int shift = bsf(a|b);\n    a >>= bsf(a);\n    do {\n        b >>= bsf(b);\n        if (a > b) swap(a, b);\n        b -= a;\n    } while (b);\n    return (a << shift);\n}\n\n/// g:gcd(a, b), ax+by=g\nstruct EG { ll g, x, y; };\nEG ext_gcd(ll a, ll b) {\n    if (b == 0) {\n        if (a >= 0) return EG{a, 1, 0};\n        else return EG{-a, -1, 0};\n    } else {\n        auto e = ext_gcd(b, a % b);\n        return EG{e.g, e.y, e.x - a / b * e.y};\n    }\n}\n\n\nll inv_mod(ll x, ll md) {\n    auto z = ext_gcd(x, md).x;\n    return (z % md + md) % md;\n}\n\ntemplate<class T, class U>\nT pow_mod(T x, U n, T md) {\n    T r = 1 % md;\n    x %= md;\n    while (n) {\n        if (n & 1) r = (r * x) % md;\n        x = (x * x) % md;\n        n >>= 1;\n    }\n    return r;\n}\n\n// (rem, mod)\npair<ll, ll> crt(const V<ll>& b, const V<ll>& c) {\n    int n = int(b.size());\n    ll r = 0, m = 1;\n    for (int i = 0; i < n; i++) {\n        auto eg = ext_gcd(m, c[i]);\n        ll g = eg.g, im = eg.x;\n        if ((b[i] - r) % g) return {0, -1};\n        ll tmp = (b[i] - r) / g * im % (c[i] / g);\n        r += m * tmp;\n        m *= c[i] / g;\n    }\n    return {(r % m + m) % m, m};\n}\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nll S2(ll a, ll b, ll c, ll d) {\n    return a * d - b * c;\n}\nll check(ll s2, ll a, ll b, ll c, ll d, ll g_cd) {\n    ll i2 = s2 - (gcd(a, b) + g_cd + gcd(a - c, b - d)) + 2;\n    return i2 / 2;\n}\n\nll solve(ll w, ll h, ll n) {\n    ll s_pred = 2 * n + 2 * min(w, h) + w;\n    ll ans = 0;\n    for (ll i = 1; i < w; i++) {\n        for (ll j = 1; j < h; j++) {\n            if (S2(w - i, 1, -i, j) > s_pred) break;\n            ll g_cd = gcd(-i, j);\n            ll lw_k = 0, up_k = h;\n            while (up_k - lw_k > 1) {\n                ll mid_k = (lw_k + up_k) / 2;\n                ll s2 = S2(w - i, mid_k, -i, j);\n                if (s2 - g_cd + 2 <= 2 * n) {\n                    lw_k = mid_k;\n                } else {\n                    up_k = mid_k;\n                }\n            }\n            ans += (up_k - 1);\n            for (ll k = up_k; k < h; k++) {\n                // (i, 0), (w, k), (0, j)\n                ll s2 = S2(w - i, k, -i, j);\n                if (s2 - g_cd - min(w, h) - w + 2 > 2 * n) break;\n                if (check(s2, w - i, k, -i, j, g_cd) <= n) ans++;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll w, h, k;\n    sc.read(w, h, k);\n\n    ll ans = 2 * solve(w, h, k) + 2 * solve(h, w, k);\n\n    pr.writeln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nint64_t count_bottom(int W, int H, int K) {\n    int64_t answer = 0;\n\n    for (int s = 0; s < H - 1; s++)\n        for (int x = 1; x < W && x * s <= 2 * K + W - 2; x++) {\n            int R = 2 * K - 2 - x * s + __gcd(W, s);\n\n            if (R >= 0) {\n                int y = min(R / W + 1, H - s - 1);\n                assert(0 < y && y + s < H);\n                int success = W * y - __gcd(x, y) - __gcd(W - x, y + s) <= R;\n                success += y - 1;\n                answer += (s == 0 ? 1 : 2) * success;\n            }\n        }\n\n    return answer;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    cout << 2 * count_bottom(W, H, K) + 2 * count_bottom(H, W, K) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 100005;\n\nint K;\n\nint solve(int W, int H) {\n\tint S = 3 * H + 2 * K;\n\tint ans[2] = {0, 0};\n\tfor (int x1 = 1; x1 < W && x1 * H <= S; ++x1) {\n\t\tfor (int y = 1; y < H; ++y) {\n\t\t\tfor (int dx = 0; dx * y <= S - x1 * H && x1 + dx < W; ++dx) {\n\t\t\t\tint x2 = x1 + dx;\n\t\t\t\tint t = x1 * H + dx * y;\n\t\t\t\tt -= std::__gcd(dx, H) + std::__gcd(x2, H - y) + std::__gcd(x1, y) - 2;\n\t\t\t\tif (t % 2 == 0 && t <= 2 * K) {\n\t\t\t\t\t++ans[dx == 0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2 * ans[0] + ans[1];\n}\n\nint main() {\n\tint W, H;\n\tread(W), read(H), read(K);\n\tprint(2 * (solve(W, H) + solve(H, W)));\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n//binary gcd\nll gcd(ll _a, ll _b) {\n    ull a = abs(_a), b = abs(_b);\n    if (a == 0) return b;\n    if (b == 0) return a;\n    int shift = bsf(a|b);\n    a >>= bsf(a);\n    do {\n        b >>= bsf(b);\n        if (a > b) swap(a, b);\n        b -= a;\n    } while (b);\n    return (a << shift);\n}\n\n/// g:gcd(a, b), ax+by=g\nstruct EG { ll g, x, y; };\nEG ext_gcd(ll a, ll b) {\n    if (b == 0) {\n        if (a >= 0) return EG{a, 1, 0};\n        else return EG{-a, -1, 0};\n    } else {\n        auto e = ext_gcd(b, a % b);\n        return EG{e.g, e.y, e.x - a / b * e.y};\n    }\n}\n\n\nll inv_mod(ll x, ll md) {\n    auto z = ext_gcd(x, md).x;\n    return (z % md + md) % md;\n}\n\ntemplate<class T, class U>\nT pow_mod(T x, U n, T md) {\n    T r = 1 % md;\n    x %= md;\n    while (n) {\n        if (n & 1) r = (r * x) % md;\n        x = (x * x) % md;\n        n >>= 1;\n    }\n    return r;\n}\n\n// (rem, mod)\npair<ll, ll> crt(const V<ll>& b, const V<ll>& c) {\n    int n = int(b.size());\n    ll r = 0, m = 1;\n    for (int i = 0; i < n; i++) {\n        auto eg = ext_gcd(m, c[i]);\n        ll g = eg.g, im = eg.x;\n        if ((b[i] - r) % g) return {0, -1};\n        ll tmp = (b[i] - r) / g * im % (c[i] / g);\n        r += m * tmp;\n        m *= c[i] / g;\n    }\n    return {(r % m + m) % m, m};\n}\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nll S2(ll a, ll b, ll c, ll d) {\n    return a * d - b * c;\n}\nll check(ll s2, ll a, ll b, ll c, ll d) {\n    ll i2 = s2 - (gcd(a, b) + gcd(c, d) + gcd(a - c, b - d)) + 2;\n    return i2 / 2;\n}\n\nll solve(ll w, ll h, ll n) {\n    ll s_pred = 2 * n + 3 * min(w, h) + 100;\n    ll ans = 0;\n    for (ll i = 1; i < w; i++) {\n        for (ll j = 1; j < h; j++) {\n            if (S2(w - i, 1, -i, j) > s_pred) break;\n            for (ll k = 1; k < h; k++) {\n                // (i, 0), (w, k), (0, j)\n                ll s2 = S2(w - i, k, -i, j);\n                if (s2 > s_pred) break;\n                if (check(s2, w - i, k, -i, j) <= n) ans++;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll w, h, k;\n    sc.read(w, h, k);\n\n    ll ans = 2 * solve(w, h, k) + 2 * solve(h, w, k);\n\n    pr.writeln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n  if(a==0 || b==0) return(a+b);\n  else if(a%b == 0) return(b);\n  else return(gcd(b, a%b));\n}\n\nint main(){\n  int W,H,K;\n  cin>>W>>H>>K;\n  long long cnt1=0;\n  long long cnt2=0;\n  \n\tfor(int i=1;i<=H-1;i++){ //横の長さがW\n      for(int j=1;j<=H-1;j++){\n        for(int k=1;k<=W-1;k++){\n          long long X=gcd(W,abs(i-j))+gcd(i,k)+gcd(j,W-k)-(2*W*max(i,j)-(W*abs(i-j)+i*k+j*(W-k)));\n            if(X<=2*K+2){\n              cnt1++;\n            }\n          for(int k=1;k<=W-1;k++){\n            long long X=gcd(W,abs(i-j))+gcd(H-i,k)+gcd(H-j,W-k)-(2*W*max(H-i,H-j)-(W*abs(i-j)+(H-i)*k+(H-j)*(W-k)));\n            if(X<=2*K+2){\n              cnt1++;\n            }\n          }\n        }\n      }\n    }\n\tfor(int i=1;i<=W-1;i++){ //縦の長さがH  \n      for(int j=1;j<=W-1;j++){\n        for(int k=1;k<=H-1;k++){\n          long long X=gcd(abs(i-j),H)+gcd(i,k)+gcd(j,H-k)-(2*H*max(i,j)-(H*abs(i-j)+i*k+j*(H-k)));\n            if(X<=2*K+2){\n              cnt2++;\n            }\n        }\n        for(int k=1;k<=H-1;k++){\n          long long X=gcd(abs(i-j),H)+gcd(W-i,k)+gcd(W-j,H-k)-(2*H*max(W-i,W-j)-(H*abs(i-j)+(W-i)*k+(W-j)*(H-k)));\n            if(X<=2*K+2){\n              cnt2++;\n            }\n        }\n      }\n    }\n//    long long X=gcd(a,b)+gcd(c,d)+gcd(e,f)-(2*max({a,c,e})*H-(a*b+c*d+e*f));\n//  if(X<=2*K+2) count++;\n  \n  cout<<cnt1+cnt2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nstruct point_t {\n    int x, y;\n    point_t() : x(0), y(0) {}\n    point_t(int x, int y) : x(x), y(y) {}\n    point_t(const point_t& rhs) : x(rhs.x), y(rhs.y) {}\n    int operator < (const point_t& rhs) const {return make_pair(y, x) < make_pair(rhs.y, rhs.x);}\n    int operator == (const point_t& rhs) const {return make_pair(y, x) == make_pair(rhs.y, rhs.x);}\n    point_t operator - (const point_t& rhs) const {return point_t(x - rhs.x, y - rhs.y);}\n};\nlong long cross(point_t a, point_t b) {\n    return (long long) a.x * b.y - (long long) a.y * b.x;\n}\nlong long area(point_t a, point_t b, point_t c) {\n    return abs(cross(a, b) + cross(b, c) + cross(c, a));\n}\n\ninline int calc(int x, int y) {\n    return __gcd(abs(x), abs(y)) - 1;\n};\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 5e5; j++) {\n                point_t a(0, i);\n                point_t b(j, w);\n                long long s;\n                for (int k = 1; k < h && (s = area(a, b, point_t(k, 0))) <= 2 * d + 5e5; k++) {\n                    s -= calc(j, w - i);\n                    //s -= calc(j - k, w);\n                    s -= f[abs(j - k)];\n                    s -= calc(k, i);\n                    s -= 3;\n                    s += 2;\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+W+1000;\n\tFor(k,1,W-1){\n\t\tint B=min(LIM/(W-k),H-1);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k),key2=k;\n\t\t\tll b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tb1=min(b1,1ll*(H-1)); ans+=b1; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tint cv=key1-gcd(W,abs(i-b1))-gcd(k,i)-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2) ans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n5000 5000 100000\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn abs(b*(c-a)-m*(n-a))-(__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll d=0;d<=min(n-1,ll(610000)/b);d++)\n\t\t{\n\t\t\tll R = k-b*d+__gcd(b,m);\n\t\t\tif(R<0) continue;\n\t\t\tll mina=R/m;\n\t\t\tll coeff=2;\n\t\t\tif(d==0) coeff=1;\n\t\t\t//cerr<<b<<' '<<d<<' '<<mina<<'\\n';\n\t\t\t/*\n\t\t\tif(mina+3<=n-1-d)\n\t\t\t{\n\t\t\t\tassert(calc(n,m,n-(mina+3),b,n-(mina+3)-d)>k);\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(ll z=mina+1;z<=mina+2;z++)\n\t\t\t{\n\t\t\t\tif(z<=n-1-d&&calc(n,m,n-z,b,n-z-d)<=k) ans+=coeff;\n\t\t\t}\n\t\t\tans+=coeff*min(mina,n-1-d);\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W,K;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>K;\n\tll ret=0;\n\tFOR(i,2) {\n\t\tfor(int s=0;s<=H-2;s++) {\n\t\t\tint R=2*K+__gcd(s,W)-2;\n\t\t\tll pat=0;\n\t\t\tfor(x=1;x<W;x++) {\n\t\t\t\tint R2=R-s*x;\n\t\t\t\tif(R2<0) break;\n\t\t\t\t\n\t\t\t\tint Ymi=R2/W;\n\t\t\t\t//if(Ymi) pat+=Ymi-1;\n\t\t\t\t//for(y=max(1,Ymi);y<=Ymi+2 && y+s<H;y++) {\n\t\t\t\tfor(y=1;y<=Ymi+2 && y+s<H;y++) {\n\t\t\t\t\tll v=1LL*W*y-__gcd(x,y)-__gcd(W-x,y+s);\n\t\t\t\t\tif(v<=R2) pat++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tret+=((s==0)?1:2)*pat;\n\t\t}\n\t\tswap(H,W);\n\t}\n\tcout<<2*ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n//binary gcd\nll gcd(ll _a, ll _b) {\n    ull a = abs(_a), b = abs(_b);\n    if (a == 0) return b;\n    if (b == 0) return a;\n    int shift = bsf(a|b);\n    a >>= bsf(a);\n    do {\n        b >>= bsf(b);\n        if (a > b) swap(a, b);\n        b -= a;\n    } while (b);\n    return (a << shift);\n}\n\n/// g:gcd(a, b), ax+by=g\nstruct EG { ll g, x, y; };\nEG ext_gcd(ll a, ll b) {\n    if (b == 0) {\n        if (a >= 0) return EG{a, 1, 0};\n        else return EG{-a, -1, 0};\n    } else {\n        auto e = ext_gcd(b, a % b);\n        return EG{e.g, e.y, e.x - a / b * e.y};\n    }\n}\n\n\nll inv_mod(ll x, ll md) {\n    auto z = ext_gcd(x, md).x;\n    return (z % md + md) % md;\n}\n\ntemplate<class T, class U>\nT pow_mod(T x, U n, T md) {\n    T r = 1 % md;\n    x %= md;\n    while (n) {\n        if (n & 1) r = (r * x) % md;\n        x = (x * x) % md;\n        n >>= 1;\n    }\n    return r;\n}\n\n// (rem, mod)\npair<ll, ll> crt(const V<ll>& b, const V<ll>& c) {\n    int n = int(b.size());\n    ll r = 0, m = 1;\n    for (int i = 0; i < n; i++) {\n        auto eg = ext_gcd(m, c[i]);\n        ll g = eg.g, im = eg.x;\n        if ((b[i] - r) % g) return {0, -1};\n        ll tmp = (b[i] - r) / g * im % (c[i] / g);\n        r += m * tmp;\n        m *= c[i] / g;\n    }\n    return {(r % m + m) % m, m};\n}\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nll S2(ll a, ll b, ll c, ll d) {\n    return a * d - b * c;\n}\nll check(ll s2, ll a, ll b, ll c, ll d, ll g_cd) {\n    ll i2 = s2 - (gcd(a, b) + g_cd + gcd(a - c, b - d)) + 2;\n    return i2 / 2;\n}\n\nll solve(ll w, ll h, ll n) {\n    ll s_pred = 2 * n + 2 * min(w, h) + w;\n    ll ans = 0;\n    for (ll i = 1; i < w; i++) {\n        for (ll j = 1; j < h; j++) {\n            if (S2(w - i, 1, -i, j) > s_pred) break;\n            ll g_cd = gcd(-i, j);\n            ll lw_k = 0, up_k = h;\n            while (up_k - lw_k > 1) {\n                ll mid_k = (lw_k + up_k) / 2;\n                ll s2 = S2(w - i, mid_k, -i, j);\n                if (s2 - g_cd + 2 <= 2 * n) {\n                    lw_k = mid_k;\n                } else {\n                    up_k = mid_k;\n                }\n            }\n            ans += (up_k - 1);\n            for (ll k = up_k; k < h; k++) {\n                // (i, 0), (w, k), (0, j)\n                ll s2 = S2(w - i, k, -i, j);\n                if (s2 - g_cd - 2 * min(w, h) + 2 > 2 * n) break;\n                if (check(s2, w - i, k, -i, j, g_cd) <= n) ans++;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll w, h, k;\n    sc.read(w, h, k);\n\n    ll ans = 2 * solve(w, h, k) + 2 * solve(h, w, k);\n\n    pr.writeln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005;\nint f[N],g[N];\nll solve(int w,int h,int k){\n\tll ans=0;\n\tFor(h2,1,h-1){\n\t\tint h1=h-h2,L=0,R=0,mx=0;\n\t\tint l=1,r=w-1;\n\t\twhile(l<r){\n\t\t\tll b=((l+r)>>1)+1,a=b;\n\t\t\tif((a+b)*h-a*h1-b*h2-h+2<=2*k)l=b; else r=b-1;\n\t\t}\n\t\tL=l;\n\t\tl=0,r=w-1;\n\t\twhile(l<r){\n\t\t\tll b=((l+r)>>1)+1,a=b;\n\t\t\tif((a+b)*h-a*h1-b*h2-(h+h)+2<=2*k)l=b; else r=b-1;\n\t\t}\n\t\tR=l;\n\t\tFor(de,0,w-2){\n\t\t\tint gg=__gcd(h,de),sum=0;\n\t\t\twhile(L>1){\n\t\t\t\tll b=L,a=L+de;\n\t\t\t\tif(L>w-1-de||(a+b)*h-a*h1-b*h2-gg+2>2*k)L--; else break;\n\t\t\t}\n\t\t\twhile(R){\n\t\t\t\tll b=R,a=R+de;\n\t\t\t\tif(R>w-1-de||(a+b)*h-a*h1-b*h2-(h+gg)+2>2*k)R--; else break;\n\t\t\t}\n\t\t\t//R=min(R+1,w-1-de);\n\t\t\t//L=1; R=w-1-de;'\n\t\t\tif(L>R)break;\n\t\t\tFor(o,mx+1,R+de)f[o]=__gcd(o,h1);\n\t\t\tmx=max(mx,R+de);\n\t\t\tif(!de)For(o,1,R)g[o]=__gcd(o,h2);\n\t\t\tsum+=L-1;\n\t\t\tFor(b,L,R){\n\t\t\t\tint a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(f[a]+g[b]+gg)+2<=2*k){\n\t\t\t\t\t//assert(((a+b)*h-a*h1-b*h2-2*(h+gg)+2<=k));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(de)ans+=sum*2; else ans+=sum;\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint w=read(),h=read(),k=read();\n\tcout<<solve(w,h,k)+solve(h,w,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=500005,lim=100000;\nint p[N],flag[N],mu[N],A[N],B[N],nA,nB,W,H,K;\nll ans;\nvi d;\n\nvoid init(int n){\n\tint cnt=0;\n\tmu[1]=1;\n\trep(i,2,n){\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tflag[i*p[j]]=1;\n\t\t\tif(i%p[j]==0){\n\t\t\t\tmu[i*p[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i*p[j]]=-mu[i];\n\t\t}\n\t}\n}\n\nll calc(int W,int H,int K,int d){\n\tll ans=0;\n\tint tot=0;\n\trep(x,1,W-1){\n\t\trep(r,1,min(d,min(H,K+W))){\n\t\t\tif((ll)r*(W-x)>K+W) break;\n\t\t\tif((ll)r*x>K+W) break;\n\t\t\tnA=nB=0;\n\t\t\tfor(int i=r;i<H&&(ll)i*(W-x)<=K+W;i+=d){\n\t\t\t\tA[++nA]=i*(W-x)-__gcd(i,x);\n\t\t\t\tint p=nA;\n\t\t\t\twhile(p>=2&&A[p]<A[p-1]){\n\t\t\t\t\tswap(A[p],A[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=r;i<H&&(ll)i*x<=K+W;i+=d){\n\t\t\t\tB[++nB]=i*x-__gcd(i,W-x);\n\t\t\t\tint p=nB;\n\t\t\t\twhile(p>=2&&B[p]<B[p-1]){\n\t\t\t\t\tswap(B[p],B[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p=nA;\n\t\t\trep(i,1,nB){\n\t\t\t\twhile(p&&A[p]+B[i]>K) p--;\n\t\t\t\tans+=p;\n\t\t\t}\n\t\t\ttot+=nA+nB;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int W,int H){\n\td.clear();\n\tfor(int i=1;i*i<=W;i++){\n\t\tif(W%i==0){\n\t\t\td.pb(i);\n\t\t\tif(i*i!=W) d.pb(W/i);\n\t\t}\n\t}\n\tfor(auto x:d){\n\t\tfor(auto y:d){\n\t\t\tif(y%x==0&&mu[y/x]){\n\t\t\t\tans+=mu[y/x]*calc(W,H,K+x,y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tread(W),read(H),read(K);\n\tK=K*2-2;\n\tinit(lim);\n\tsolve(W,H);\n\tsolve(H,W);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tll inf = -2 * h - w;\n\tll res1 = 0; ll res2 = 0;\n\tfor (ll x1 = 1; x1 < w; x1++) {\n\t\tif (2*k-2-x1*h < inf)continue;\n\t\tfor (ll x2 = x1; x2 < w; x2++) {\n\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\tll s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\tif (s < inf)break;\n\t\t\t\tif (s >= 0) {\n\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\telse res1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + gcd(x2 - x1, h);\n\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2 * (res1 + 2 * res2);\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nll solve(int W, int H, int K) {\n\tK = 2 * K - 2;\n\tll ans = 0;\n\tfor (int x = 1; x < W; ++x) {\n\t\tint lim = min(H - 1, (K + 2 * W) / (W - x));\n\t\tfor (int y1 = 1; y1 <= lim; ++y1) {\n\t\t\tint rhs = K - (W - x) * y1 + __gcd(x, y1);\n\t\t\t// x * y2 <= rhs + (W, |y1-y2|) + (W-x, y2)\n\t\t\tint bound = min(H - 1, max(0, rhs / x));\n\t\t\tans += bound;\n\t\t\tint lim2 = min(H - 1, (rhs + 2 * W - x) / x);\n\t\t\tfor (int y2 = bound + 1; y2 <= lim2; ++y2) {\n\t\t\t\tif (x * y2 <= rhs + __gcd(W, abs(y1 - y2)) + __gcd(W - x, y2))\n\t\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tll ans = 2 * (solve(w, h, k) + solve(h, w, k));\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                if (s / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                long g = mm;\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a, w - b);\n                }\n                g += mem2[a];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cout << 11123456789999 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) 0 //fprintf(stderr, args)\nint w, h, k;\nlong long ans;\nint gcd(int x, int y) {\n\treturn y?gcd(y, x%y):x;\n}\nvoid solve() {\n\tmeow(\"%d * %d\\n\", w, h);\n\tfor(int d=0; d<h; ++d) {\n\t\tint coef=2*(1+!!d), a, kk=k+gcd(d, w);\n\t\tfor(int c=1; c<w && c*d<=kk; ++c) {\n\t\t\tint a=(kk-c*d)/w;\n\t\t\ta=std::min(a, h-d-1);\n\t\t\tans+=coef*a;\n\t\t\tmeow(\"c=%d, d=%d: + %d*%d\\n\", c, d, a, coef);\n\t\t\t++a;\n\t\t\tif(a<h-d) {\n\t\t\t\tint b=a+d;\n\t\t\t\tmeow(\"check (%d, %d, %d): + %d*%d\\n\", a, b, c, a*w+c*d<=kk+gcd(a, c)+gcd(b, w-c), coef);\n\t\t\t\tif(a*w+c*d<=kk+gcd(a, c)+gcd(b, w-c)) ans+=coef;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tk=2*k-2;\n\tsolve();\n\tstd::swap(w, h);\n\tsolve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\n//int Pow(int x,int y){\n//\tint ans=1;\n//\tfor (;y;y>>=1,x=(LL)x*x%mod)\n//\t\tif (y&1)\n//\t\t\tans=(LL)ans*x%mod;\n//\treturn ans;\n//}\n//void Add(int &x,int y){\n//\tif ((x+=y)>=mod)\n//\t\tx-=mod;\n//}\n//void Del(int &x,int y){\n//\tif ((x-=y)<0)\n//\t\tx+=mod;\n//}\n//int Add(int x){\n//\treturn x>=mod?x-mod:x;\n//}\n//int Del(int x){\n//\treturn x<0?x+mod:x;\n//}\n//void ckmax(int &x,int y){\n//\tif (x<y)\n//\t\tx=y;\n//}\n//void ckmin(int &x,int y){\n//\tif (x>y)\n//\t\tx=y;\n//}\nconst int N=100005;\nint w,h,k;\nLL calc(LL w,LL h,LL k){\n\tk=k*2-2;\n\t//s*2-b<=k\n\tLL minwh=min(w,h);\n\tLL ans=0;\n\tFor(x,1,w-1)\n\t\tFor(y0,1,h-1){\n\t\t\tLL b=__gcd(x,y0);\n\t\t\tLL mins=(w-x)*y0;\n\t\t\tif (mins-minwh*3>k)\n\t\t\t\tbreak;\n\t\t\tif (mins-b-minwh*2>k)\n\t\t\t\tcontinue;\n\t\t\t//w * y0 + (y1 - y0) * (w - (w - x)) = w * y0 - y0 * x + y1 * x = mins + y1 * x\n\t\t\t//mins + y1 * x - b <= k\n\t\t\t//y1 <= (k + b - mins) / x\n\t\t\tLL miny1=min(h-1,max(0LL,(k+b-mins)/x));\n\t\t\tans+=miny1;\n\t\t\tFor(y1,miny1+1,h-1){\n\t\t\t\tLL s=mins+(LL)y1*x;\n\t\t\t\tif (s-b-minwh*2>k)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s-b-__gcd(w-x,(LL)y1)-__gcd(w,(LL)abs(y1-y0))<=k)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\nint main(){\n\tw=read(),h=read(),k=read();\n\tcout<<calc(w,h,k)*2+calc(h,w,k)*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nLL solve(int w, int h, int k)\n{\n\tLL ret = 0;\n\tfor(int a = 1; a <= w - 1 && a * h <= 2 * k + 2 * h - 2; a ++)\n\trep1(x, h - 1) {\n\t\tint ub = 2 * k + __gcd(a, h - x) - 2 - a * x;\n\t\tret += min(ub / (h - x), w - 1) >= a ? (min(w - 1, ub / (h - x)) - a) * 2 + 1 : 0;\n\t\tfor(int b = max(a, min(ub / (h - x), w - 1) + 1); b <= w - 1 && b * (h - x) <= ub + h + x; b ++)\n\t\tif(b * (h - x) - __gcd(h, b - a) - __gcd(b, x) <= ub) ret += b == a ? 1 : 2;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tprintf(\"%lld\\n\", 2 * solve(w, h, k) + 2 * solve(h, w, k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint h,w,k;\nll solve(int w,int h)\n{\n    ll ans=0;\n    for(int a=1;a<w;a++)\n        for(int c_b=0;c_b<h;c_b++)\n    {\n        int R=2*k-a*c_b+__gcd(c_b,w)-2;\n        if(R<0) break;\n        int low=min(h-1-c_b,R/w);\n        ans+=c_b==0?low:low*2;\n        low++;\n        if(low+c_b<h&&w*low-__gcd(w-a,low+c_b)-__gcd(a,low)<=R)\n            ans+=c_b==0?1:2;\n    }\n    return ans*2;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&w,&h,&k);\n    printf(\"%lld\\n\",solve(w,h)+solve(h,w));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nstruct point_t {\n    int x, y;\n    point_t() : x(0), y(0) {}\n    point_t(int x, int y) : x(x), y(y) {}\n    point_t(const point_t& rhs) : x(rhs.x), y(rhs.y) {}\n    int operator < (const point_t& rhs) const {return make_pair(y, x) < make_pair(rhs.y, rhs.x);}\n    int operator == (const point_t& rhs) const {return make_pair(y, x) == make_pair(rhs.y, rhs.x);}\n    point_t operator - (const point_t& rhs) const {return point_t(x - rhs.x, y - rhs.y);}\n};\nint cross(point_t a, point_t b) {\n    return a.x * b.y - a.y * b.x;\n}\nint area(point_t a, point_t b, point_t c) {\n    return abs(cross(a, b) + cross(b, c) + cross(c, a));\n}\n\ninline int calc(int x, int y) {\n    return __gcd(abs(x), abs(y)) - 1;\n};\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 3e5; j++) {\n                point_t a(0, i);\n                point_t b(j, w);\n                int s;\n                for (int k = 1; k < h && (s = area(a, b, point_t(k, 0))) <= 2 * d + 3e5; k++) {\n                    s -= calc(j, w - i);\n                    s -= f[abs(j - k)];\n                    s -= calc(k, i);\n                    s -= 3;\n                    s += 2;\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nconst int limit = 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nll get(int x, int y) {\n\tif (x < y) swap(x, y);\n\tif (y == 0) return x + 1;\n\tint q = x / y, r = x % y;\n\treturn 1ll * q * (y + 1) * y / 2 + get(y, r);\n}\nll get(int x, int y, bool type) {\n\tll ans = get(x, y);\n\tif (!type) ans -= 1 + __gcd(x, y);\n\treturn ans;\n}\nint n, m, k;\nbool check(int i, int j, int l) {\n\tif (i == j) return i * (m + 1ll) - get(i, l, true) - get(i, m - l, true) + 3 <= k;\n\telse return get(j - i, m, false) + i * (m + 1ll) - get(i, l, true) - get(j, m - l, true) + 3 <= k;\n}\nll work(int n, int m) {\n\tll ans = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tbool goon = false;\n\t\tfor (int j = 1; j <= m - 1; j++)\n\t\t\tif (check(i, i, j)) {\n\t\t\t\tgoon = true;\n\t\t\t\tans += 1;\n\t\t\t}\n\t\tif (!goon) break;\n\t}\n\tfor (int i = 1; i <= n - 2; i++) {\n\t\tbool goon = false;\n\t\tfor (int j = 1; j <= m - 1; j++)\n\t\t\tif (check(i, i + 1, j)) goon = true;\n\t\tif (!goon) break;\n\t\tfor (int j = i + 1; j <= i + limit && j <= n - 1; j++)\n\t\tfor (int k = 1; k <= m - 1; k++)\n\t\t\tans += check(i, j, k) * 2;\n\t\tint now = m - 1;\n\t\tfor (int j = i + limit + 1; j <= n - 1; j++) {\n\t\t\tnow = min(m - 1, now + limit);\n\t\t\twhile (now >= 1 && !check(i, j, now)) now--;\n\t\t\tans += 2 * now;\n\t\t\tfor (int l = now; l >= 1 && now - l <= limit; l--)\n\t\t\t\tans -= 2 * !check(i, j, l);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(m), read(k);\n\tcout << work(n, m) * 2 + work(m, n) * 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\n \nconst ll INF = 2e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//↓,→,↑,←\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n    #undef endl\n#endif\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\n// const ll mod = 998244353ll;\nconst ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll mod){ll x=1;while(b){while(!(b&1)){(a*=a)%=mod;b>>=1;}(x*=a)%=mod;b--;}return x;}\nvoid YES(bool cond){ if(cond){ p(\"YES\");}else{ p(\"NO\");} return;}\nvoid Yes(bool cond){ if(cond){ p(\"Yes\");}else{ p(\"No\");} return;}\n\n/*\nll fact[fact_table + 5],rfact[fact_table + 5]; \n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table],mod - 2, mod);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n\nvoid init(){\n    struct timeval _time;\n    gettimeofday(&_time, NULL);\n    ll usec = _time.tv_usec * 1000000;\n    srand(usec);\n    return;\n}\n\nll range(ll a,ll b){\n    // generate random number [a, b]\n    // if b >= 10^8, this might not be precise\n    ll num = rand() % (1 + b - a) + a;\n    return num;\n}\n\nbool multicase = false;\nll mygcd(ll a, ll b){\n    if(b > a)swap(a, b);\n    if(b == 0 || a == b)return a;\n    return mygcd(b, a % b);\n}\n\nll calc(ll w, ll h, ll k){\n    ll ans = 0;\n    for(ll i1=1;i1<h;i1++){\n        ll hmin = (k - 1) / (i1 * w);\n        hmin = max(1ll, hmin - 2);\n        // hmax = min(h - 1, hmax + 1000000);\n        ans += (hmin - 1) * (w - 1);\n        for(ll i2=hmin;i2<h;i2++){\n            ll sc = max(i1, i2) * w * 2;\n            if (sc + 2 <= 2 * k) {\n                ans += w - 1;\n                continue;\n            }\n            for(ll j=1;j<w;j++){\n                ll b = mygcd(i1, j) + mygcd(w - j, i2) + mygcd(w, abs(i1 - i2));\n                ll s = max(i1, i2) * w * 2;\n                s -= (i1 * j) + (w - j) * (i2) + (abs(i1 - i2) * w);\n                if(s - b + 2 <= 2 * k)ans ++;\n            }\n        }\n    }\n    return ans;\n}\nll n,m,num,a,b,c,d,e,h,q;\nvoid solve(){\n    ll w, k;\n    cin >> w >> h >> k;\n    ll ans = 0;\n    ans += calc(w, h, k) * 2;\n    ans += calc(h, w, k) * 2;\n    p(ans);\n    return;\n}\n\nint main(){\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll q, testcase = 1;\n    if(multicase){\n        cin >> q;\n    }else{\n        q = 1; \n    }\n    while(q--){\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n    // solve();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 11100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint gcd(int a,int b){\n\twhile(b){\n\t\ta%=b;swap(a,b);\n\t}\n\treturn a;\n}\n\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tlong long ret=0;\n\tfor(int z=0;z<2;z++){\n\t\t\n\t\tfor(int j=1;j<b;j++){\n\t\t\tint h=min(a-2,(2*c+2*(a+b))/j+2);\n\t\t\tfor(int i=0;i<=h;i++){\n\t\t\t\tint tmp=gcd(i,b);\n\t\t\t\tint left=0;\n\t\t\t\tint right=a;\n\t\t\t\twhile(left+1<right){\n\t\t\t\t\tint M=(left+right)/2;\n\t\t\t\t\tint V=gcd(M,j)+gcd(M+i,b-j);\n\t\t\t\t\tif(M+i<a&&(long long)(M+i)*b*2-(long long)j*M-(long long)(b-j)*(M+i)-\n\t\t\t\t\t\t(long long)b*i<=c*2+tmp+V-2){\n\t\t\t\t\t\tleft=M;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright=M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// printf(\"%d %d: %d\\n\",j,i,left);\n\t\t\t\tret+=left;\n\t\t\t\tif(i){\n\t\t\t\t\tret+=left;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(a,b);\n\t}\n\tret*=2;\n\tprintf(\"%lld\\n\",ret);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nll go(int w, int h, int k){\n\tll an = 0;\n\tf(x, 1, w)f(y2, 0, min(h, (2 * k - 2 + w) / (w - x) + 1)){\n\t\tint y1 = min(h - 1ll, (2 * k + (ll)x * y2 + gcd(w, y2)) / w), t = 0;\n\t\tif (y1 >= y2){\n\t\t\tt += y1 - y2;\n\t\t\t++y1;\n\t\t\tif (y1 != h && (ll)w * y1 - gcd(x, y1) - gcd(w - x, y1 - y2) <= 2 * k + (ll)x * y2 - 2 + gcd(w, y2))++t;\n\t\t}\n\t\tan += t;\n\t\tif (y2)an += t;\n\t}\n\treturn an;\n}\n\nint main(){\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tprintf(\"%lld\\n\", go(w, h, k) + go(h, w, k) << 1);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint h, w, k;\nconst int BUBEN = 1e5 + 10;\nint f(int x, int y) {\n    return __gcd(x, y) + 1;\n}\nint solve(int h, int w, int k) {\n    int ans = 0;\n    k *= 2;\n    for (int a = 1; a < h; a++) {\n        for (int b = 1; b < w; b++) {\n            if ((h - a) * b > k + BUBEN) break;\n            for (int c = 1; c < w; c++) {\n                int area = c * a + (h - a) * b;\n                if (area > k + BUBEN) break;\n                area -= f(a, b);\n                area -= f(h - a, c);\n                if (b == c) {\n                    area -= (h + 1);\n                }\n                else {\n                    area -= f(abs(b - c), h);\n                }\n                area += 2;\n                area += 3;\n                if (area <= k) ans++;\n            }\n\n        }\n    }\n    return ans;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> h >> w >> k;\n    cout << 2 * solve(h, w, k) + 2 * solve(w, h, k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <chrono>\n#include <random>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <iomanip>\n#define dibs reserve\n#define OVER9000 1234567890\n#define tisic 47\n#define soclose 1e-8\n#define patkan 9\n#define ff first\n#define ss second\nusing uint = unsigned int;\nusing cat = long long;\nusing dbl = long double;\nconstexpr dbl pi = 3.14159265358979323846;\nusing namespace std;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ntemplate <typename T>\nT abs(T x) { return (x < 0) ? (-x) : x; }\n\nint gcd(int x, int y) {\n\tif(x > y) swap(x, y);\n\twhile(x) {\n\t\ty %= x;\n\t\tswap(x, y);\n\t}\n\treturn y;\n}\n\ncat solve_inner(int r, int c2, int W, int H, int K, auto & G) {\n\tint ret = 0;\n\tint C = 2*(K-1)+gcd(c2,r)-c2*(H-r);\n\tint c1 = 1, c1b = min(W-1, C/r);\n\tif(c1 <= c1b) {\n\t\tret += c1b-c1+1;\n\t\tc1 = c1b+1;\n\t}\n\twhile(c1 < c2 && c1*r <= C+min(c2,H-r)+c2) {\n\t\tret += (c1*r <= C+gcd(c1,H-r)+G[c2-c1]);\n\t\tc1++;\n\t}\n\tif(1LL*c2*r > C+2*H-r) return ret;\n\tif(c1 < c2) c1 = c2;\n\tif(c1 == c2) {\n\t\tret += (c1*r <= C+gcd(c1,H-r)+H);\n\t\tc1++;\n\t}\n\tif(r <= 2) {\n\t\twhile(c1 < W && c1*r <= C+2*H-r) {\n\t\t\tret += (c1*r <= C+gcd(c1,H-r)+G[c1-c2]);\n\t\t\tc1++;\n\t\t}\n\t}\n\telse {\n\t\twhile(c1 < W && c1*r <= C+2*H-r && c1*(r-2) <= C-c2) {\n\t\t\tret += (c1*r <= C+gcd(c1,H-r)+G[c1-c2]);\n\t\t\tc1++;\n\t\t}\n\t}\n\treturn ret;\n}\n\ncat solve(int W, int H, int K) {\n\tvector<int> G(W+1, 0);\n\tfor(int i = 0; i <= W; i++) G[i] = gcd(H, i);\n\tcat ret = 0;\n\tfor(int r = 1; r <= (H-1)/2; r++)\n\t\tfor(int c2 = 1; c2 < W && c2*(H-r) <= 2*(K-1+H); c2++)\n\t\t\tret += solve_inner(r, c2, W, H, K, G);\n\tret *= 2;\n\tif(H%2 == 0) {\n\t\tint r = H/2;\n\t\tfor(int c2 = 1; c2 < W && c2*(H-r) <= 2*(K-1+H); c2++)\n\t\t\tret += solve_inner(r, c2, W, H, K, G);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcout << fixed << setprecision(10);\n\tint W, H, K;\n\tcin >> W >> H >> K;\n\tcout << 2 * (solve(W, H, K) + solve(H, W, K)) << \"\\n\";\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 13.06.2020 15:12:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long Solve(int w, int h, int k) {\n  k = 2 * k - 2;\n  long long ans = 0;\n  for (int x = 1; x < w; x++) {\n    for (int y0 = 1; y0 < h; y0++) {\n      int a = (w - x) * y0 - __gcd(x, y0);\n      if (a > k + 2 * w) {\n        break;\n      }\n      // a + x * y1 <= k?\n      // y1 <= (k - a) / x\n      int bound = min(h - 1, max(0, (k - a) / x));\n      ans += bound;\n      for (int y1 = bound + 1; y1 < h; y1++) {\n        int b = a + x * y1;\n        if (b > k + 2 * w) {\n          break;\n        }\n        int c = b - __gcd(w - x, y1) - __gcd(w, abs(y0 - y1));\n        if (c <= k) {\n          ans += 1;\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  cout << 2 * (Solve(w, h, k) + Solve(h, w, k)) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath> \nusing namespace std;\nint gcd(int u,int V)\n{\n\tint t;\n\tt = u % V;\n\tif (t == 0)\n\treturn V;\n\telse return gcd(V,t);\n}\n\nint main(){\n\tint width,height,k;\n  \tcin>>width>>height>>k;\n  \t\n  \tint answer = 0;\n  \t\n  \tint gridAll = (width-1)*(height-1);\n  \t//cout<<gridAll<<endl;\n  \t//case 1\n  \tfor(int Ay=1;Ay<height;Ay++){\n      \tfor(int Bx=1;Bx<width;Bx++){\n          \tfor(int Cx=Bx+1;Cx<width;Cx++){\n              \t//cout <<\"a:\"<<Ay<<\"b:\"<<Bx<<\"c:\"<<Cx<<endl;\n              \tint gridOut = 0;\n              \t//AOB\n              \tint unit;\n              \tif(Bx<=(height-Ay)){ unit=gcd(Bx,(height-Ay)); }\n                else{ unit=gcd((height-Ay),Bx); }\n              \tgridOut += ( (height-Ay-1)*(Bx-1) )/2;\n              \tgridOut += unit-1;\n              \t//APC\n              \tif(Cx<=Ay){ unit=gcd(Cx,Ay); }\n              \telse{ unit=gcd(Ay,Cx);}\n              \tgridOut += ( (Ay-1)*(Cx-1) )/2;\n              \tgridOut += unit-1;\n              \t//BCQR\n              \tif(Cx-Bx<=height){unit=gcd(Cx-Bx,height);}\n              \telse{unit=gcd(height,Cx-Bx);}\n              \tgridOut += (width-Cx)*(height-1) + ( (Cx-Bx-1)*(height-1) )/2;\n              \tgridOut += unit-1;\n                \n              \t//cout<<gridOut<<endl;\n                if(gridAll-gridOut<=k){\n                  \t//cout<<\"ok\"<<endl;\n                  \tanswer +=4;\n                }\n            }\n        }\n      \tfor(int Bx=1;Bx<width;Bx++){\n              \t//cout <<\"a:\"<<Ay<<\"b:\"<<Bx<<endl;\n           \tint gridOut = 0;\n             //AOB\n           \tint unit;\n          \tif(Bx<=height-Ay){unit=gcd(Bx,(height-Ay));}\n          \telse{unit=gcd(height-Ay,Bx);}\n            gridOut += ( (height-Ay-1)*(Bx-1) )/2;\n            gridOut += unit-1;\n          \t//APC\n          \tif(Bx<=Ay){ unit=gcd(Bx,Ay); }\n          \telse{unit = gcd(Ay,Bx);}\n            gridOut += ( (Ay-1)*(Bx-1) )/2;\n          \tgridOut += unit-1;\n            //BCQR\n            gridOut += (width-Bx)*(height-1);\n                \n              \t//cout<<gridOut<<endl;\n            if(gridAll-gridOut<=k) answer+=2;\n        }\n    }\n  \t//cout<<\"case 2\"<<endl;\n  \tfor(int Ay=1;Ay<width;Ay++){\n      \tfor(int Bx=1;Bx<height;Bx++){\n          \tfor(int Cx=Bx+1;Cx<height;Cx++){\n              \t//cout <<\"a:\"<<Ay<<\"b:\"<<Bx<<\"c:\"<<Cx<<endl;\n              \tint gridOut = 0;\n              \t//AOB\n              \tint unit;\n                if(Bx<=width-Ay){unit=gcd(Bx,(width-Ay));}\n              \telse{unit=gcd(width-Ay,Bx);}\n              \tgridOut += ( (width-Ay-1)*(Bx-1) )/2;\n              \tgridOut += unit-1;\n              \t//APC\n              \tif(Cx<=Ay){unit=gcd(Cx,Ay);}\n              \telse{unit=gcd(Ay,Cx);}\n              \tgridOut += ( (Ay-1)*(Cx-1) )/2;\n              \tgridOut += unit-1;\n              \t//BCQR\n              \tif(Cx-Bx<=height){ unit=gcd(Cx-Bx,height);}\n              \telse{unit=gcd(height,Cx-Bx);}\n              \tgridOut += (height-Cx)*(width-1) + ( (Cx-Bx-1)*(width-1) )/2;\n              \tgridOut += unit-1;\n                \n              \t//cout<<gridOut<<endl;\n                if(gridAll-gridOut<=k) answer +=4;\n            }\n        }\n      \tfor(int Bx=1;Bx<height;Bx++){\n              \t//cout <<\"a:\"<<Ay<<\"b:\"<<Bx<<endl;\n           \tint gridOut = 0;\n             //AOB\n           \tint unit;\n          \tif(Bx<=width-Ay){ unit=gcd(Bx,(width-Ay));}\n          \telse{ unit=gcd(width-Ay,Bx);}\n            gridOut += ( (width-Ay-1)*(Bx-1) )/2;\n          \tgridOut += unit-1;\n            //APC\n            if(Bx<=Ay){ unit=gcd(Bx,Ay);}\n          \telse{unit=gcd(Ay,Bx);}\n            gridOut += ( (Ay-1)*(Bx-1) )/2;\n          \tgridOut += unit-1;\n            //BCQR\n            gridOut += (height-Bx)*(width-1);\n                \n          \t//cout<<gridOut<<endl;\n            if(gridAll-gridOut<=k) answer+=2;\n        }\n    }\n    cout<<answer<<endl;\n  \treturn 0;\n}\n                  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn abs(b*(c-a)-m*(n-a))-(__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\t/*\n\tfor(int j=1;j<m;j++)\n\t{\n\t\tcerr<<\"SOLVE \"<<j<<'\\n';\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tassert(calc(n,m,i,j,i)<=calc(n,m,i-1,j,i-1));\n\t\t\t//cerr<<calc(n,m,i,j,i)<<'\\n';\n\t\t}\n\t}\n\t*/\n\t/*\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll a=1;a<n;a++)\n\t\t{\n\t\t\tfor(ll c=a+1;c<n;c++)\n\t\t\t{\n\t\t\t\tif(calc(n,m,a,b,c)<calc(n,m,a,b,c+1))\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"FAIL \"<<a<<' '<<b<<' '<<c<<' '<<calc(n,m,a,b,c)<<' '<<calc(n,m,a,b,c+1)<<'\\n';\n\t\t\t\t}\n\t\t\t\t//assert(calc(n,m,a,b,c)>=calc(n,m,a,b,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll z=1;z<=min(n-1,ll(500000)/m);z++)\n\t\t{\n\t\t\tll a=n-z;\n\t\t\tfor(ll y=0;y<=min(a-1,ll(500000)/m);y++)\n\t\t\t{\n\t\t\t\tll c=a-y;\n\t\t\t\tif(calc(n,m,a,b,c)<=k) \n\t\t\t\t{\n\t\t\t\t\tif(y>0) ans+=2;\n\t\t\t\t\telse ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\t\t\t\n\t\t\t//a is the maxi\n\t\t\t//c<=a\n\t\t\tll as=a+1;\n\t\t\tll lo=1; ll hi=a;\n\t\t\twhile(lo<=hi)\n\t\t\t{\n\t\t\t\tll mid=(lo+hi)>>1;\n\t\t\t\tif(calc(n,m,a,b,mid)<=k)\n\t\t\t\t{\n\t\t\t\t\tas=mid;\n\t\t\t\t\thi=mid-1;\n\t\t\t\t}\n\t\t\t\telse lo=mid+1;\n\t\t\t}\n\t\t\tif(as==a+1) continue;\n\t\t\tans+=2*(a+1-as)-1;\n\t\t\t*/\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nint cnt(int H, int W, int x, int y, int a){\n    int S = y * W + a * x;\n    int b = gcd(x, y) + gcd(W - x, y + a) + gcd(W, a);\n    return (S + 2 - b) / 2;\n}\n\nsigned main(){\n\n    int W, H, K; cin >> W >> H >> K;\n    int ans = 0;\n    REP(_, 2){\n        FOR(a, 1, H - 1){\n            int M = min(W - 1, 2 * (K + W) / a);\n            FOR(x, 1, M + 1){\n                int ymin = min((2 * K - a * x) / W, H - 1 - a);\n                if(ymin >= 1) ans += ymin * 2;\n                REP(k, 2) if(ymin + 1 + k <= H - 1 - a && cnt(H, W, x, ymin + 1 + k, a) <= K) ans += 2;\n            }\n        }\n\n        FOR(x, 1, W){\n            int ymin = min(2 * K / W, H - 1);\n            if(ymin >= 1) ans += ymin;\n            REP(k, 2) if(ymin + 1 + k <= H - 1 && cnt(H, W, x, ymin + 1 + k, 0) <= K) ans += 1;\n        }\n\n        swap(W, H);\n    }\n    ans *= 2;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\n\nlint solve(int H, int W, int K)\n{\n    lint ret = 0;\n    REP(dh, H - 1)\n    {\n        FOR(w, 1, W)\n        {\n\n            lint R = 2 * K - 2 + __gcd(W, dh) - 1LL * w * dh;\n            if (R < 0) break;\n\n            lint lo = min<lint>(R / W, H - 1 - dh); // hs <= lo なら必ず成立\n            lint hi = min<lint>((R + W * 2) / W, H - dh); // hs >= hi なら必ず不成立\n\n            lint ret_tmp = lo;\n            FOR(hs, lo + 1, hi)\n            {\n                lint x = hs * W - __gcd(w, hs) - __gcd<int>(W - w, hs + dh);\n                if (x <= R) ret_tmp++;\n            }\n\n            if (1LL * H * W <= 10)\n            {\n                dbg((vector<lint>{H, W, dh, w, lo, hi, ret_tmp}));\n            }\n            ret += ret_tmp * (1 + (dh != 0));\n        }\n    }\n    return ret * 2;\n}\n\nint main()\n{\n    int W, H, K;\n    cin >> W >> H >> K;\n    lint ret = solve(W, H, K) + solve(H, W, K);\n    cout << ret << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nint w,h,k;\n\nint calc(int w,int h){\n\tint ans[2]={0,0};\n\tfor(int y=1;y<h;y++)\n\t\tfor(int d=0;d*y<=3*h+2*k&&d<w;d++){\n\t\t\tint r=__gcd(d,h)+2*k-2-d*y;\n\t\t\tint lim=min(max(r/h,0ll),w-d-1);\n\t\t\tans[d==0]+=lim;\n\t\t\tfor(int x1=lim+1;x1<=lim+2&&x1+d<w;x1++) if(x1*h-__gcd(x1+d,h-y)-__gcd(x1,y)<=r) ans[d==0]++;\n\t\t}\n\treturn 2*ans[0]+ans[1];\n}\n\nsigned main(){\n\tread(w,h,k);\n\twrite(calc(w,h)+calc(h,w)<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\nint s[509][100009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\tif (a <= 100000 && b <= 200) return s[b][a];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= 500; i++) {\n\t\tfor (int j = i; j <= 500; j += i) {\n\t\t\tfor (int k = i; k <= 100000; k += i) s[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * (W - i) / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint area = a * k + b * j;\n\t\t\t\tint z1 = s[a][j];\n\t\t\t\tint z2 = s[b][k];\n\t\t\t\tint z3 = s[W][abs(j - k)];\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - k); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 500) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nll count(int x, int y){\n\tif (x == 0 || y == 0) return (y - x + 1);\n\tll s2 = 1ll * x * y,\n\tb = x + y + __gcd(x, y),\n\ta2 = s2 - b + 2;\n\treturn a2 / 2 + b;\n}\nll ans, cnt;\nll solve(int W, int H, int L){\n\tint Lim = 2 * L + W + 1;\n\tll sum = 0;\n\tfor (int t = 1; t < H - 1; t++)\n\t\tfor (int x = 1; x <= W - 1; x++){\n\t\t\tif (t * x >= Lim) break;\n\t\t\tint r = 2 * L + __gcd(W, t) - 2 - x * t;\n\t\t\tif (r < 0) continue;\n\t\t\tint y = r / W; \n\t\t\ty = min(y, H - 1 - t);\n\t\t\tsum = sum + 4 * y;\n\t\t\twhile (W * y <= r + W && y + 1 + t < H){\n\t\t\t\ty++;\n\t\t\t\tif (W * y - __gcd(y, x) - __gcd(W - x, y + t) <= r) sum += 4;\n\t\t\t}\n\t\t}\n\t\n\tint t = 0;\n\tfor (int x = 1; x <= W - 1; x++){\n\t\t\tif (t * x >= Lim) break;\n\t\t\tint r = 2 * L + __gcd(W, t) - 2 - x * t;\n\t\t\tif (r < 0) continue;\n\t\t\tint y = r / W;\ty = min(y, H - 1 - t);\n\t\t\tsum = sum + 2 * y;\n\t\t\twhile (W * y <= r + W && y + 1 + t < H){\n\t\t\t\ty++;\n\t\t\t\tif (W * y - __gcd(y, x) - __gcd(W - x, y + t) <= r) sum += 2;\n\t\t\t}\n\t\t}\n\treturn sum;\n}\nint main(){\n\tint W, H, L;\n\tread(W); read(H); read(L);\n\tans = ans + solve(W, H, L);\n\tans = ans + solve(H, W, L);\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn m*min(a,c)+abs(c-a)*b-(__gcd(m,abs(c-a))+__gcd(b,min(a,c))+__gcd(m-b,max(a,c)));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll d=0;d<=min(n-1,ll(410000)/b);d++)\n\t\t{\n\t\t\tll R = k-b*d+__gcd(b,m);\n\t\t\tif(R<0) continue;\n\t\t\tll mina=R/m;\n\t\t\tll coeff=2;\n\t\t\tif(d==0) coeff=1;\n\t\t\t//cerr<<b<<' '<<d<<' '<<mina<<'\\n';\n\t\t\t\n\t\t\tif(mina+3<=n-1-d)\n\t\t\t{\n\t\t\t\tassert(calc(n,m,mina+3,b,mina+3+d)>k);\n\t\t\t}\n\t\t\t\n\t\t\tfor(ll z=mina+1;z<=mina+2;z++)\n\t\t\t{\n\t\t\t\tif(z<=n-1-d&&calc(n,m,z,b,z+d)<=k) ans+=coeff;\n\t\t\t}\n\t\t\tans+=coeff*min(mina,n-1-d);\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                if (s / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                long g = mm;\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                g += get(a, w - b);\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunknown-pragmas\"\n#pragma region template\n\n// #pragma GCC target(\"avx2\")\n// #pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n// #include <boost/range/irange.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// #include <boost/algorithm/string/classification.hpp> // is_any_of\n// #include <boost/algorithm/string/split.hpp>\n// #include <boost/algorithm/string/join.hpp>\n// #include <boost/algorithm/string/replace.hpp>\n// #include <boost/math/tools/minima.hpp>\n\n#define all(a) (a).begin(),(a).end()\n#define sz(a) (int)(a).size()\n#define last(a) (a).at((int)(a).size()-1)\n#define rep(i,n) for(int i=0,i##_len=(n);i<i##_len;i++)\n#define brep(i,a,b) for(int i=(a),i##_len=(b);i<=i##_len;i++)\n#define rrep(i,n) int i=(n);int now=-1;while(i--&&(now++||1))\n#define xrep(i,n) for(int i=1,i##_len=(n);i<=i##_len;i++)\n#define Yes(n) cout<<((n)?YES:NO)<<'\\n'\n#define co(n) cout<<(n)<<'\\n'\n#define fo(n) printf(\"%.15lf\\n\",(n))\n#define fout cout<<fixed<<setprecision(15)\n#define Sort(v) sort(all(v))\n#define rSort(v) sort(all(v),greater<typeof(v[0])>())\n#define Rev(v) reverse(all(v))\n#define Unique(v) (v).erase(unique(all(v)),(v).end())\n#define eb emplace_back\n#define fi first\n#define se second\n\n#ifdef ONLINE_JUDGE\n#define here()\n#define cprint(vec)\n#define comment(msg)\n#define observe(var)\n#define local(x)\n#define alter(x,y) y\n#else\n#define here() cerr<<__func__<<'/'<<__LINE__<<\": passed\\n\"\n#define cprint(vec) print_e(vec)\n#define comment(msg) cerr<<\"{ \"<<msg<< \" }\\n\"\n#define observe(var) cerr<<\"{ \"<<#var<<\" : \"<<var<<\" }\\n\"\n#define local(x) x\n#define alter(x,y) x\n#endif\n\nusing namespace std;\nusing ll    = long long;\nusing ld    = long double;\nusing ull   = unsigned long long;\nusing vbl   = vector<bool>;\nusing dqbl  = deque<bool>;\nusing vint  = vector<int>;\nusing vll   = vector<long long>;\nusing vdbl  = vector<double>;\nusing vstr  = vector<string>;\nusing vvbl  = vector<vector<bool>>;\nusing vdqbl = vector<deque<bool>>;\nusing vvint = vector<vector<int>>;\nusing vvll  = vector<vector<long long>>;\n\n// using boost::irange;\n// using boost::multiprecision::cpp_int;\n// using boost::algorithm::split;\n// using boost::algorithm::join;\n// using boost::math::tools::brent_find_minima;\n// using boost::algorithm::replace_all;\n\ntemplate<class S>\n  using uset = unordered_set<S>;\ntemplate<class S, class T>\n  using umap = unordered_map<S, T>;\n\nconstexpr int         INF   = 1e9;\nconstexpr long long   LINF  = 1e18;\nconstexpr double      EPS   = 1e-9;\nconstexpr long double LEPS  = 1e-18;\n\n// --- functions which take 1 argument --- //\ninline void ignore_ret(int x){x++;}\ntemplate<class T> inline int sgn(const T &x){return (x>0)-(x<0);}\ntemplate<class T> inline int digit(T x){int r=1;while((x/=10)>=1)r++;return r;}\ntemplate<class T> inline double deg_to_rad(const T &a){return a/180.0*M_PI;}\ntemplate<class T> inline double rad_to_deg(const T &a){return a/M_PI*180.0;}\ntemplate<class T> inline ll factorial(const T &n){if(n==0)return 1;ll r=1;brep(i,2,n)r*=i;return r;}\ntemplate<class T> inline map<T,T> factorize(T n){map<T,T>r;for(T i=2;i*i<=n;i++){while(n%i==0){r[i]++;n/=i;}}if(n!=1)r[n]=1;return r;}\ntemplate<class T> inline vector<T> divisor(const T &n){vector<T>r;for(T i=1;i*i<=n;i++){if(!(n%i)){r.eb(i);if(i*i!=n)r.eb(n/i);}}Sort(r);return r;}\n\n// --- functions which take 2 arguments --- //\ntemplate<class T> inline bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline T nPr(const T &n,const T &k){if(n<k||n<0||k<0)return 0;T r=1;brep(i,n-k+1,n)r*=i;return r;}\ntemplate<class T> inline T nCr(const T &n,const T &k){if(n<k||n<0||k<0)return 0;T r=1;k=min(k,n-k);brep(i,n-k+1,n)r*=i;return r/factorial(k);}\n\n// --- functions which take vector/deque as argument --- //\ntemplate<class T> inline void print(const vector<T> &v){cout<<\"[ \";for(auto& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class T> inline void print(const deque<T> &v){cout<<\"[ \";for(auto& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class T> inline void print(const vector<vector<T>> &v){for(auto& x:v)print<T>(x);}\ntemplate<class T> inline void print(const vector<deque<T>> &v){for(auto& x:v)print<T>(x);}\ntemplate<class T> inline void print_d(const vector<T> &v,string d){rep(i,sz(v)-1)cout<<v[i]<<d;cout<<last(v)<<'\\n';}\ntemplate<class T> inline void print_d(const vector<vector<T>> &v,string d){for(auto& x:v)print_d(x,d);}\ntemplate<class T> inline void print_e(const vector<T> &v){cerr<<\"[ \";for(auto& x:v)cerr<<x<<' ';cerr<<\"]\\n\";}\ntemplate<class T> inline void print_e(const vector<vector<T>> &v){for(auto& x:v)print_e<T>(x);}\ntemplate<class T> inline bool in(const T &k,const vector<T> &v){return find(all(v),k)!=v.end();}\n                  inline bool in(const int &k,const vector<ll> &v){return find(all(v),k)!=v.end();}\n                  inline bool in(const ll &k,const vector<int> &v){return find(all(v),k)!=v.end();}\n                  inline bool in(const char &k,const string& v){return find(all(v),k)!=v.end();}\n                  inline bool in(const char* &k,const vector<string>& v){return find(all(v),k)!=v.end();}\ntemplate<class T> inline T min(const vector<T> &v){return *min_element(all(v));}\ntemplate<class T> inline T max(const vector<T> &v){return *max_element(all(v));}\ntemplate<class T> inline T sum(const T &v){return reduce(all(v),(T)0);}\ntemplate<class T> inline T gcd(const vector<T> &v){T r=v[0];brep(i,1,sz(v)-1)r=gcd(r,v[i]);return r;}\ntemplate<class T> inline T lcm(const vector<T> &v){T r=v[0];brep(i,1,sz(v)-1)r=lcm(r,v[i]);return r;}\ntemplate<class T> inline double abs(const vector<T> &v){return sqrt(reduce(all(v),0.0,[](T s,T v){return s+=v*v;}));}\ntemplate<class T> inline T vector_add(const T &u,const T &v){T r(u.size());rep(i,u.size())r[i]=u[i]+v[i];return r;}\ntemplate<class T> inline T vector_subtract(const T &u,const T &v){T r(u.size());rep(i,u.size())r[i]=u[i]-v[i];return r;}\ntemplate<class T> inline T vector_multiply(const T &u,const T &v){T r(u.size());rep(i,u.size())r[i]=u[i]*v[i];return r;}\ntemplate<class S, class T> inline common_type<S,T> dot_product(const vector<S> &u,const vector<T> &v){T r=0;rep(i,u.size())r+=u[i]*v[i];return r;}\ntemplate<class S, class T> inline void sort_by_second(vector<pair<S,T>> &v){sort(all(v),[](auto &L,auto &R){return L.second<R.second;});}\n\n// --- functions which take set/map as argument --- //\ntemplate<class T> inline bool in(const T &k,const set<T> &v){return find(all(v),k)!=v.end();}\ntemplate<class T> inline bool in(const T &k,const unordered_set<T> &v){return find(all(v),k)!=v.end();}\ntemplate<class T> inline T min(const set<T> &v){return *min_element(all(v));}\ntemplate<class T> inline T min(const unordered_set<T> &v){return *min_element(all(v));}\ntemplate<class T> inline T max(const set<T> &v){return *max_element(all(v));}\ntemplate<class T> inline T max(const unordered_set<T> &v){return *max_element(all(v));}\ntemplate<class T> inline T gcd(const set<T> &v){T r=0;for(T x:v)r=(r==0)?x:gcd(r,x);return r;}\ntemplate<class T> inline T gcd(const unordered_set<T> &v){T r=0;for(T x:v)r=(r==0)?x:gcd(r,x);return r;}\ntemplate<class T> inline T lcm(const set<T> &v){T r=0;for(T x:v)r=(r==0)?x:lcm(r,x);return r;}\ntemplate<class T> inline T lcm(const unordered_set<T> &v){T r=0;for(T x:v)r=(r==0)?x:lcm(r,x);return r;}\ntemplate<class T>         inline void print(const set<T> &v){cout<<\"[ \";for(T& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class T>         inline void print(const unordered_set<T> &v){cout<<\"[ \";for(T& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class S, class T> inline void print(const map<S,T> &m){cout<<\"[ \";for(auto& x:m)cout<<\"{ \"<<x.fi<<\", \"<<x.se<<\" } \";cout<<\"]\\n\";}\ntemplate<class S, class T> inline void print(const unordered_map<S,T> &m){cout<<\"[ \";for(auto& x:m)cout<<\"{ \"<<x.fi<<\", \"<<x.se<<\" } \";cout<<\"]\\n\";}\n\n#pragma endregion template\n\nll solve(int W, int H, int K) {\n  ll to_return = 0;\n\n  for (int x = 1; x < W; x++) {\n    for (int s = 0; s < H-1; s++) {\n      ll R = 2*K + gcd(s, W) - s*x - 2;\n      if (R < 0) break;\n\n      ll cnt = max(0LL, min(R/W, (ll)H-s-1));\n      ll y_1 = cnt + 1;\n      if (0 < y_1 && y_1 < H - s && W*y_1 - gcd(x, y_1) - gcd(W-x, y_1+s) <= R) cnt++;\n      \n      if (s == 0) to_return += cnt;\n      else to_return += 2*cnt;\n    }\n  }\n\n  return to_return;\n}\n\nint main() {\n  int W, H, K;\n  scanf(\"%d%d%d\", &W, &H, &K);\n  printf(\"%lld\\n\", 2*solve(W, H, K) + 2*solve(H, W, K));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint W, H, K;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint solve() {\n    // A = I + B / 2 - 1, where I <= K\n    // A - B / 2 + 1 = I <= K\n    // 2 * A - B <= 2 * (K - 1)\n    //\n    // A = H * W - W * (H - (y1 + y2) / 2) - x * y1 / 2 - (W - x) * y2 / 2\n    //   = W * (y1 + y2) / 2 - x * y1 / 2 - (W - x) * y2 / 2\n    //   = [(W - x) * y1 + x * y2] / 2\n    // B = gcd(y1 - y2, W) + gcd(y1, x) + gcd(y2, W - x)\n    int total = 0;\n    int lim = 2 * (K - 1) + 3 * W;\n    for (int x = 1; x < W; x++) {\n        for (int y2 = 1; y2 < H; y2++) {\n            if (x * y2 > lim)\n                break;\n            // (W - x) * y1 + x * y2 <= 2 * (K - 1) + 3 <= 2 * (K - 1) + B\n            int y1 = (2 * (K - 1) - x * y2 + 3) / (W - x);\n            if (y1 >= y2) {\n                total += 2 * y2 - 1;\n                continue;\n            }\n            if (y1 < 1)\n                y1 = 1;\n            total += 2 * (y1 - 1);\n            for (; y1 <= y2; y1++) {\n                int A2 = (W - x) * y1 + x * y2;\n                if (A2 > lim)\n                    break;\n                int B = gcd(y1, x) + gcd(y2, W - x) + gcd(abs(y1 - y2), W);\n                if (A2 - B <= 2 * (K - 1)) {\n                    total++;\n                    if (y1 != y2)\n                        total++;\n                }\n            }\n        }\n    }\n    return total;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> W >> H >> K;\n\n    int total = solve();\n    swap(W, H);\n    total += solve();\n    total *= 2;\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint W,H,K,i,j,k,l;\ninline ll calc(int n,int m){\n\tstatic int v1[N],v2[N];ll ans=0;\n\tfor(i=1;i<m;++i){\n\t\tint lm1,lm2;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv1[j]=(m+1)*(j+1)-(i+1)*(j+1)+3;\n\t\t\tif(v1[j]+2*i-(m+1)>K*2+m*2)break;\n\t\t}\n\t\tlm1=j;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv2[j]=(m+1)*j-(m-i+1)*(j+1);\n\t\t\tif(v2[j]>K*2+m*2)break;\n\t\t}\n\t\tlm2=j;\n\t\tfor(j=1,k=lm2-1;j<lm1;++j){\n\t\t\tfor(;k>1 && v1[j]+v2[k]>K*2;--k);\n\t\t\tans+=k-1;\n\t\t\tint vv=v1[j]-__gcd(j,i);\n\t\t\tfor(l=0;vv+v2[k+l]-m-(m-i)<=K*2 && k+l<lm2;++l)ans+=vv+v2[k+l]-__gcd(k+l,m-i)-__gcd(abs(j-k-l),m)<=K*2;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tprintf(\"%lld\\n\",calc(W,H)+calc(H,W)<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nll area(int x1, int y1, int x2, int y2, int x3, int y3) {\n  int a = x2 - x1, b = y2 - y1;\n  int c = x3 - x1, d = y3 - y1;\n  return abs(a * (ll) d - b * (ll) c);\n}\n\nll f(int a, int b) {\n  a = abs(a), b = abs(b);\n  while (b) {\n    int ret = a % b;\n    a = b;\n    b = ret;\n  }\n  return a;\n}\n\nll cost(int x1, int y1, int x2, int y2, int x3, int y3) {\n  ll a = area(x1, y1, x2, y2, x3, y3);\n  ll g = f(x2 - x1, y2 - y1) + f(x3 - x1, y3 - y1) + f(x3 - x2, y3 - y2);\n  return a - g + 2;\n}\n\nll bad_consider = 0;\n\nll solve(int w, int h, int k) {\n  ll sum = 0;\n  int t = min(w, h);\n  for (int x1 = 1; x1 < w; x1++) {\n    for (int y = h - 1; y >= 1; y--) {\n      if (x1 * (ll) (h - y) > k + 3 * t) {\n        break;\n      }\n      ll val = x1 * (ll) (h - y) - f(y, x1);\n      ll mx = min((ll) w - 1, max(0ll, (k - val) / y));\n      sum += 2 * mx;\n      auto eval = [&] (int x2) {\n        if (val + x2 * (ll) y - f(h - y, x2) - f(x2 - x1, h) <= k) {\n          sum += 2;\n        }\n      };\n      if (x1 > mx) {\n        eval(x1);\n      }\n      for (int x2 = mx + 1; x2 < w; x2++) {\n        if (val + x2 * (ll) y - 2 * t > k) {\n          break;\n        }\n        if (x2 != x1)\n          eval(x2);\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  k = 2 * (k - 1);\n  cout << solve(w, h, k) + solve(h, w, k) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nlint solve(lint H, lint W, lint K)\n{\n    lint ret = 0;\n    FOR(h1, 1, H)\n    {\n        FOR(h2, 1, H)\n        {\n            lint hs, hl;\n            tie(hs, hl) = minmax(h1, h2);\n            lint lo = hs * (W - 1) + hl * 1 + 2;\n            if (lo > 2 * K + W * 2) break;\n\n            lint tmp = 2 - gcd<lint>(W, hl - hs);\n            FOR(w, 1, W)\n            {\n                lint curr = hl * w + hs * (W - w) + tmp - gcd(w, hs) - gcd(W - w, hl);\n                // if (curr > 2 * K) break;\n                if (curr <= 2 * K) ret++;\n            }\n        }\n    }\n    return ret * 2;\n}\n\nint main()\n{\n    int W, H, K;\n    cin >> W >> H >> K;\n    lint ret = solve(W, H, K) + solve(H, W, K);\n    cout << ret << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nint W,H,k,tmp,R;\nll ans,sum;\nint gcd(int x,int y) {\n\tif (!x||!y) return x+y;\n\treturn gcd(y,x%y);\n}\nint up(int x,int y) {\n\tif (x%y==0) return x/y;\n\treturn x/y+1;\n}\nint down(int x,int y) { return x/y; }\nvoid solve() {\n\ttmp=2*k-2+W;\n\tfor (int s=0;s<H&&s<=tmp;s++)\n\tfor (int x=1;x<W&&x*s<=tmp;x++) {\n\t\tR=2*k-2-s*x+gcd(W,s);\n\t\tif (R/W>=H-s-1) sum=H-s-1;\n\t\telse {\n\t\t\tsum=R/W;\n\t\t\tfor (int y=R/W+1;y<=(R+W)/W;y++) {\n\t\t\t\tif ((ll)W*y-gcd(x,y)-gcd(W-x,y+s)<=R) sum++;\n\t\t\t}\n\t\t}\n\t\tif (!s) ans+=sum;\n\t\telse ans+=sum*2;\n\t\t\n\t}\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(W); read(H); read(k);\n\tsolve();\n\tswap(W,H);\n\tsolve();\n\tprintf(\"%lld\\n\",ans*2);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,k;\nlong long ans;\n\nvoid solve(){\n\tfor (int b=0;b<m;++b){\n\t\tfor (int c=1;c<n;++c){\n\t\t\tint r=k*2-2+__gcd(n,b)-b*c;\n\t\t\tans+=max(0,min(m-1-b,r/n))*(1+(b>0));\n\t\t\tfor (int a=r/n+1;a<=r/n+2;++a){\n\t\t\t\tif (a>0&&a+b<m) ans+=(a*n-__gcd(a,c)-__gcd(n-c,a+b)<=r)*(1+(b>0));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tsolve();\n\tswap(n,m);\n\tsolve();\n\tprintf(\"%lld\\n\",ans*2);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint n,m,k;\nlong long gcd(int x,int y)\n{\n\tif (y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid swap(long long &x,long long &y)\n{\n\tlong long t=x;x=y;y=t;\n}\nlong long calculate(int r,int c)\n{\n\tlong long total=0;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>2*k-1+c*3) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t\tfor (long long z=x+1;z<r;z++)\n\t\t\t{\n\t\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\t\tif (x*c+z*y-x*y>2*k-1+c*3) break;\n\t\t\t\tif (p<=2*k-1) total++;\n\t\t\t}\n\t}\n\ttotal*=2;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>2*k-1+c*3) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t{\n\t\t\tlong long z=x;\n\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\tif (p<=2*k-1) total++;\n\t\t}\n\t}\n\treturn total*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t//n++;m++;\n\tlong long ans=0;\n\tans=calculate(n,m);\n\tans=ans+calculate(m,n);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint h, w, k;\nconst int BUBEN = 1e5 + 10;\nint f(int x, int y) {\n    return __gcd(x, y) + 1;\n}\nconst int maxN = 1e5 + 10;\nvector < int > f1[maxN], f2[maxN];\nint pp[maxN];\nll solve(int h, int w, int k) {\n    ll ans = 0;\n    k *= 2;\n    for (int i = 0; i < maxN; i++) {\n        pp[i] = __gcd(i, h);\n    }\n    for (int a = 1; a < h; a++) {\n        vector < int > d1;\n        vector < int > d2;\n        for (int b = 1; b < w; b++) {\n            if ((h - a) * b > k + BUBEN) break;\n            d1.emplace_back((h - a) * b - f(a, b));\n        }\n        int max_b = d1.size();\n        for (int c = 1; c < w; c++) {\n            if (c * a > k + BUBEN) break;\n            d2.emplace_back(c * a - f(h - a, c));\n        }\n        int max_c = d2.size();\n        int t = max(max_b, max_c);\n        for (int i = 0; i <= t; i++) {\n            f1[i % h].clear();\n            f2[i % h].clear();\n        }\n        for (int i = 1; i <= max_b; i++) {\n            f1[i % h].emplace_back(d1[i - 1]);\n        }\n        for (int i = 1; i <= max_c; i++) {\n            f2[i % h].emplace_back(d2[i - 1]);\n        }\n        for (int i = 0; i <= min(h - 1, max_b); i++) {\n            sort(f1[i].begin(), f1[i].end());\n            if (f1[i].empty()) continue;\n            for (int j = 0; j <= min(h - 1, max_c); j++) {\n                if (f2[j].empty()) continue;\n                if (i == 1) sort(f2[j].begin(), f2[j].end());\n                int d = pp[abs(i - j)];\n                int lim = k - 4 + d;\n                int ptr = f2[j].size() - 1;\n                for (int x = 0; x < f1[i].size(); x++) {\n                    while (ptr >= 0 && f1[i][x] + f2[j][ptr] > lim) ptr--;\n                    ans += (ptr + 1);\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> h >> w >> k;\n    cout << 2 * solve(h, w, k) + 2 * solve(w, h, k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint W, H, K;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint solve() {\n    // A = I + B / 2 - 1, where I <= K\n    // A - B / 2 + 1 = I <= K\n    // 2 * A - B <= 2 * (K - 1)\n    //\n    // A = H * W - W * (H - (y1 + y2) / 2) - x * y1 / 2 - (W - x) * y2 / 2\n    //   = W * (y1 + y2) / 2 - x * y1 / 2 - (W - x) * y2 / 2\n    //   = [(W - x) * y1 + x * y2] / 2\n    // B = gcd(y1 - y2, W) + gcd(y1, x) + gcd(y2, W - x)\n    int total = 0;\n    int lim = 2 * (K - 1) + 3 * W;\n    for (int x = 1; x < W; x++) {\n        for (int y2 = 1; y2 < H; y2++) {\n            if (x * y2 > lim)\n                break;\n            for (int y1 = 1; y1 < H; y1++) {\n                int A2 = (W - x) * y1 + x * y2;\n                if (A2 > lim)\n                    break;\n                int B = gcd(y1, x) + gcd(y2, W - x) + gcd(abs(y1 - y2), W);\n                if (A2 - B <= 2 * (K - 1))\n                    total++;\n            }\n        }\n    }\n    return total;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> W >> H >> K;\n\n    int total = solve();\n    swap(W, H);\n    total += solve();\n    total *= 2;\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            if (c * w > 2 * k + w + (w - b) + mm) continue;\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                if (s / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                long g = mm;\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a, w - b);\n                }\n                g += mem2[a];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nint spe[100005];\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+2000,top=0;\n\tFor(k,1,H-1) if (gcd(k,W)>=1000) spe[++top]=k;\n\tFor(k,W-W/2,W-1){\n\t\t//if (k%100==0) cerr<<k<<endl;\n\t\tint B=min(500000/(W-k),H-1),rp=(k*2==W?1:2);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k)-gcd(k,i),key2=k;\n\t\t\tll b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tif (b1>=i) ans-=rp;\n\t\t\tb1=min(b1,1ll*(H-1)); ans+=b1*rp; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tll cv=key1-gcd(W,abs(i-b1))-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2&&b1!=i) ans+=rp;\n\t\t\t}\n\t\t\tll arr=1ll*W*i;\n\t\t\tll cv=arr-W-gcd(k,i)-gcd(W-k,i);\n\t\t\tif (cv<=2*K-2) ans+=rp;\n\t\t\tif (1ll*(W-k)*1000<=2*K+W+2000){\n\t\t\t\t//if (i==1) cerr<<k<<endl;\n\t\t\t\tRep(p,top,1){\n\t\t\t\t\tint b=i-spe[p];\n\t\t\t\t\tif (b<b1||b>=H) continue;\n\t\t\t\t\tll arr=1ll*(W-k)*i-gcd(k,i)+1ll*k*b;\n\t\t\t\t\tif (arr>2*K+W+2000) break;\n\t\t\t\t\tll cv=arr-gcd(W,abs(i-b))-gcd(W-k,b);\n\t\t\t\t\t//if (i==2501&&spe[p]==2500) cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t\tif (cv<=2*K-2&&arr>LIM) ans+=rp;//cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t}\n\t\t\t\tFor(p,1,top){\n\t\t\t\t\tint b=i+spe[p];\n\t\t\t\t\tif (b<b1||b>=H) continue;\n\t\t\t\t\tll arr=1ll*(W-k)*i-gcd(k,i)+1ll*k*b;\n\t\t\t\t\tif (arr>2*K+W+2000) break;\n\t\t\t\t\tll cv=arr-gcd(W,abs(i-b))-gcd(W-k,b);\n\t\t\t\t\t//if (i==2501&&spe[p]==2500) cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t\tif (cv<=2*K-2&&arr>LIM) ans+=rp;//cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n5000 5000 100000\n197045732\n100000 100000 100000\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n\tcerr<<clock()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int W, H, K;\n    scanf(\"%d %d %d\", &W, &H, &K);\n    auto solve = [&](int W, int H) {\n        long long ans = 0;\n        for (int d = 0; d <= H - 2; d++) {\n            for (int j = 1; j < W && d * j <= 2 * K + W; j++) {\n                int t = 2 * K - 2 - d * j + __gcd(W, d);\n                if (t < 0) continue;\n                int i = min(H - d - 1, t / W + 1);\n                if (i * W - __gcd(i, j) - __gcd(W - j, i + d) > t) i--;\n                ans += i * (!d ? 1 : 2);\n            }\n        }\n        return ans;\n    };\n    printf(\"%lld\\n\", (solve(W, H) + solve(H, W)) * 2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n\n\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    vector<int> preg(W);\n    for (int i = 0; i < W; i++) preg[i] = __gcd(i, H);\n    \n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K - (H-y)*x1;\n            if (((LL)y)*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n            }\n            int g = __gcd(x1, y);\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (x1 != x2 and y*x2 > 2*K+g + min(x2, H-y) + min(x1-x2, H)) x2 = x1;\n                if ((LL)y*x2 > 1e6) break;\n                LL c = (H-y)*x1 + y*x2 - (g + __gcd(x2, H-y) + preg[x1-x2]) + 2;\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n// 10535724\nconst int B = 5;\n\nint gcd(int x, int y) {\n\tif (x < y) swap(x, y);\n\twhile(y > 0) {\n\t\tx %= y;\n\t\tswap(x, y);\n\t}\n\treturn x;\n}\nint inside(int y, int x1, int x2, int h) {\n\tint res = x1 * (h - y) + x2 * y + 2;\n\tres -= gcd(x2, h - y);\n\tres -= gcd(x1, y);\n\tres -= gcd(abs(x1 - x2), h);\n\tassert(res % 2 == 0);\n\treturn res / 2;\n}\nll solve(int y, int w, int h, int k) {\n\t//eprintf(\"solve %lld\\n\", y);\n\tll ans = 0;\n\tfor (int x = 1; x < w; x++) {\n\t\tif (x * y + h - y > 2 * k + 2 * h) break;\n\t\tint mx = (2 * k - x * y) / (h - y);\n\t\tmx = max(0, mx);\n\t\tans += mx;\n\t\tfor (int t = mx + 1; t <= mx + B + 3 * (h < 10) + (h < 1000); t++) {\n\t\t\tif (t <= 0 || t >= w) continue;\n\t\t\tans += inside(y, t, x, h) <= k;\n\t\t}\n\t}\n\treturn ans;\n}\nll solve(int w, int h, int k) {\n\tll ans = 0;\n\tfor (ll y = 1; 2 * y <= h; y++) {\n\t\tll cur = solve(y, w, h, k);\n\t\tif (2 * y != h) cur *= 2;\n\t\tans += cur;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tll ans = solve(w, h, k) + solve(h, w, k);\n\tprintf(\"%lld\\n\", ans * 2);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint n,m,k;\nlong long gcd(int x,int y)\n{\n\tif (y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid swap(long long &x,long long &y)\n{\n\tlong long t=x;x=y;y=t;\n}\nlong long calculate(int r,int c)\n{\n\tlong long total=0;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>6*k) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t\tfor (long long z=x+1;z<r;z++)\n\t\t\t{\n\t\t\t//\tlong long x=x1,z=z1;\n\t\t\t//\tif (x>z) swap(x,z);\n\t\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\t\tif (x*c+z*y-x*y>6*k) break;\n\t\t\t\tif (p<=2*k-1) total++;\n\t\t\t}\n\t}\n\ttotal*=2;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>6*k) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t{\n\t\t\tlong long z=x;\n\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\tif (p<=2*k-1) total++;\n\t\t}\n\t}\n\treturn total*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t//n++;m++;\n\tlong long ans=0;\n\tans=calculate(n,m);\n\tans=ans+calculate(m,n);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nint w, h, lim;\n\n// 2*interior=2*area-boundary+2 <= 2*lim\n// 2*area=x*(y+dy)+(w-x)*y\n// boundary=gcd(x,y)+gcd(w,dy)+gcd(w-x,y+dy)\n// -> x*(y+dy)+(w-x)*y-gcd(x,y)-gcd(w,dy)-gcd(w-x,y+dy)+2 <= 2*lim\n// bruteforce dy and x -> y*w-(gcd(x,y)+gcd(w-x,y+dy)) <= 2*lim-x*dy+gcd(w,dy)-2 = RHS\n// since gcd part in [1..w] if y<=RHS/w always ok and if y>RHS/w+1 never ok -> only need to check y=floor(RHS/w)+1\n\nll calc(int w, int h) {\n\tll ret = 0;\n\tFORE(x, 1, w - 1) {\n\t\tREPE(dy, h - 2) {\n\t\t\tint mlt = dy == 0 ? 1 : 2;\n\t\t\tif (2 * lim - (ll)x*dy + w <= 0) break;\n\t\t\tll rhs = 2 * lim - (ll)x*dy + gcd(w, dy) - 2;\n\t\t\tll ysafe = rhs / w;\n\t\t\tll yvalid = min(ysafe, (ll)h - dy - 1);\n\t\t\tif (yvalid >= 1) ret += mlt*(yvalid - 1 + 1);\n\t\t\tll ycheck = ysafe + 1;\n\t\t\tif (ycheck >= 1 && ycheck + dy <= h - 1 && (ll)ycheck*w - (gcd(x, ycheck) + gcd(w - x, ycheck + dy)) <= rhs) ret += mlt;\n\t\t}\n\t}\n\t/*FORE(x, 1, w - 1) {\n\t\tFORE(y, 1, h - 1) {\n\t\t\tREPE(dy, h - y - 1) {\n\t\t\t\tint mlt = dy == 0 ? 1 : 2;\n\t\t\t\tif ((ll)x*(y + dy) + (ll)(w - x)*y - gcd(x, y) - gcd(w, dy) - gcd(w - x, y + dy) <= 2 * lim) {\n\t\t\t\t\tprintf(\"\\t(%d,%d,%d):%d\\n\", x, y, dy, mlt);\n\t\t\t\t\tret += mlt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t//printf(\"(%d,%d): %lld\\n\", w, h, ret);\n\treturn ret;\n}\n\nll solve() {\n\treturn 2 * calc(w, h) + 2 * calc(h, w);\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\", &w, &h, &lim);\n\tprintf(\"%lld\\n\", solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\n//int Pow(int x,int y){\n//\tint ans=1;\n//\tfor (;y;y>>=1,x=(LL)x*x%mod)\n//\t\tif (y&1)\n//\t\t\tans=(LL)ans*x%mod;\n//\treturn ans;\n//}\n//void Add(int &x,int y){\n//\tif ((x+=y)>=mod)\n//\t\tx-=mod;\n//}\n//void Del(int &x,int y){\n//\tif ((x-=y)<0)\n//\t\tx+=mod;\n//}\n//int Add(int x){\n//\treturn x>=mod?x-mod:x;\n//}\n//int Del(int x){\n//\treturn x<0?x+mod:x;\n//}\n//void ckmax(int &x,int y){\n//\tif (x<y)\n//\t\tx=y;\n//}\n//void ckmin(int &x,int y){\n//\tif (x>y)\n//\t\tx=y;\n//}\nconst int N=100005;\nint w,h,k;\nLL calc(LL w,LL h,LL k){\n\tk=k*2-2;\n\t//s*2-b<=k\n\tLL ans=0;\n\tFor(x,1,w-1)\n\t\tFor(y0,1,h-1){\n\t\t\tLL b=__gcd(x,y0);\n\t\t\tLL mins=(w-x)*y0;\n\t\t\tif (mins-w*3>k)\n\t\t\t\tbreak;\n\t\t\tif (mins-b-w*2>k)\n\t\t\t\tcontinue;\n\t\t\t//w * y0 + (y1 - y0) * (w - (w - x)) = w * y0 - y0 * x + y1 * x = mins + y1 * x\n\t\t\t//mins + y1 * x - b <= k Ê±±ØÈ»³É¹¦ \n\t\t\t//y1 <= (k + b - mins) / x\n\t\t\tLL miny1=min(h-1,max(0LL,(k+b-mins)/x));\n\t\t\tans+=miny1;\n\t\t\tFor(y1,miny1+1,h-1){\n\t\t\t\tLL s=mins+(LL)y1*x;\n\t\t\t\tif (s-b-w*2>k)\n\t\t\t\t\tbreak;\n\t\t\t\tif (s-b-__gcd(w-x,(LL)y1)-__gcd(w,(LL)abs(y1-y0))<=k)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\nint main(){\n\tw=read(),h=read(),k=read();\n\tcout<<calc(w,h,k)*2+calc(h,w,k)*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint W,H,K,i,j,k,l;\ninline ll calc(int n,int m){\n\tstatic int v1[N],v2[N];ll ans=0;\n\tfor(i=1;i<m;++i){\n\t\tint lm1,lm2;\n\t\tfor(j=1;j<=n;++j){\n\t\t\tv1[j]=(m+1)*(j+1)-(i+1)*(j+1)+4;\n\t\t\tif(v1[j]>K*2+500)break;\n\t\t}\n\t\tlm1=j;\n\t\tfor(j=1;j<=n;++j){\n\t\t\tv1[j]=(m+1)*j-(m-i+1)*(j+1);\n\t\t\tif(v1[j]>K*2+500)break;\n\t\t}\n\t\tlm2=j;\n\t\tfor(j=1;j<lm1;++j)v1[j]-=__gcd(j,i);\n\t\tfor(j=1;j<lm2;++j)v2[j]-=__gcd(j,m-i);\n\t\tfor(j=1,k=lm2-1;j<lm1;++j){\n\t\t\tfor(;k>1 && v1[j]+v2[k]>K*2+130;--k);\n\t\t\tans+=k-1;\n\t\t\tfor(l=0;l<130 && k+l<lm2;++l)ans+=v1[j]+v2[k]-__gcd(abs(j-k-l),m)<=K*2;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tprintf(\"%lld\\n\",calc(W,H)+calc(H,W)<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n\n\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    vector<int> preg(W);\n    for (int i = 0; i < W; i++) preg[i] = __gcd(i, H);\n    \n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K - (H-y)*x1;\n            if (((LL)y)*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n            }\n            int g = __gcd(x1, y);\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (x1 != x2 and (H-y)*x1 + y*x2 > 2*K+g + min(x2, H-y) + min(x1-x2, H)) x2 = x1;\n                if ((LL)y*x2 > 1e6) break;\n                LL c = (H-y)*x1 + y*x2 - (g + __gcd(x2, H-y) + preg[x1-x2]) + 2;\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int LIM=500005;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nll F(int H,int W,int K){\n\tll ans=0;\n\tFor(k,1,W-1){\n\t\tint B=min(LIM/W,H-1);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*k,key2=W-k;\n\t\t\tint b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tif (b1>=i) ans+=2*i-1;\n\t\t\telse{\n\t\t\t\tans+=2*b1; \n\t\t\t\tkey1+=(++b1)*key2;\n\t\t\t\tfor (;key1<=LIM&&b1<=i;key1+=key2,++b1){\n\t\t\t\t\tint cv=key1-gcd(W,i-b1)-gcd(W-k,i)-gcd(k,b1);\n\t\t\t\t\tif (cv<=2*K-2) ans+=(i==b1?1:2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tif (H>W) swap(H,W);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nlong gcd(long a, long b) {\n    while (b > 0) {\n        long c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nlong get(long x, long y) {\n    x = abs(x);\n    y = abs(y);\n    long d = gcd(x, y);\n    return d + 1;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                long g = get(c, b) + get(a, w - b) + get(a - c, w) - 3;\n                s = (s - g + 2) / 2;\n//                cout << w << \" \" << a << \" \" << b << \" \" << c << \" \" << s << \"\\n\";\n                if (s <= k) {\n                    res++;\n                    if (a != c) res++;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                long g = mm;\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a, w - b);\n                }\n                g += mem2[a];\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if (s - g + 2 <= k * 2) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt gcd(Int x, Int y)\n{\n    if (x == 0)\n        return y;\n    return gcd(y % x, x);\n}\n\nInt inside(Int x1, Int y1, Int x2, Int y2)\n{\n    Int s = abs(x1 * y2 - x2 * y1);\n    s += 2;\n    s -= gcd(abs(x1), abs(y1));\n    s -= gcd(abs(x2), abs(y2));\n    s -= gcd(abs(x2 - x1), abs(y2 - y1));\n    return s / 2;\n}\n\nInt cnt(Int w, Int h, Int k)\n{\n    Int ans = 0;\n    for (Int x = 1; x < w; x++) {\n        for (Int s = 0; s < h - 1; s++) {\n            if (inside(1, x, -s, w) > 2 * k)\n                break;\n            if (inside(1, x, -s, w) > k)\n                continue;\n            Int bottom = 1, top = h - s;\n            while (top - bottom > 1) {\n                Int mid = (top + bottom) / 2;\n                if (inside(mid, x, -s, w) <= k)\n                    bottom = mid;\n                else\n                    top = mid;\n            }\n            if (s == 0)\n                ans += bottom;\n            else\n                ans += bottom * 2;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    Int w, h, k;\n    cin >> w >> h >> k;\n    cout << 2 * cnt(w, h, k) + 2 * cnt(h, w, k) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\nint n,m,sk;\n\nvoid into(){\n  scanf(\"%d%d%d\",&n,&m,&sk);\n}\n\nLL ans;\n\nLL Get_ans(int n,int m,int sk){\n  LL res=0;\n  sk=sk-1<<1;\n  for (int i=1;i<n;++i)\n\tfor (int k=0;k<m&&i*k<=n*2+sk+2;++k){\n\t  int t=i*k-gcd(k,n),j=min((sk-t)/n+1,m-k);\n\t  res+=max(j-1,0)+(j&&j<m-k&&t+n*j<=sk+gcd(n-i,j+k)+gcd(i,j))<<(bool)k;\n\t}\n  return res;\n}\n\nvoid Get_ans(){\n  ans=Get_ans(n,m,sk)+Get_ans(m,n,sk)<<1;\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 100005;\n\nint K;\n\nlong long solve(int W, int H) {\n\tint S = 3 * H + 2 * K;\n\tlong long ans[2] = {0, 0};\n\tfor (int y = 1; y < H; ++y) {\n\t\tfor (int d = 0; d * y <= S && d < W; ++d) {\n\t\t\tint R = std::__gcd(d, H) + 2 * K - 2 - d * y;\n\t\t\tint lim = std::min(std::max(R / H, 0), W - d - 1);\n\t\t\tans[d == 0] += lim;\n\t\t\tfor (int x1 = lim + 1; x1 <= lim + 2 && x1 + d < W; ++x1) {\n\t\t\t\tif (x1 * H - std::__gcd(x1 + d, H - y) - std::__gcd(x1, y) <= R) {\n\t\t\t\t\t++ans[d == 0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2 * ans[0] + ans[1];\n}\n\nint main() {\n\tint W, H;\n\tread(W), read(H), read(K);\n\t// W = H = K = 100000;\n\tprint(2 * (solve(W, H) + solve(H, W)));\n\tdebug(\"%.3lf\\n\", 1.0 * clock() / CLOCKS_PER_SEC);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=100005;\nint w,h,k;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nlong long solve(int w,int h)\n{\n\tlong long res=0;\n\tfor(int d=0;d<h;d++)\n\t\tfor(int a=1;a<w;a++)\n\t\t{\n\t\t\tint R=2*k-a*d+gcd(d,w)-2;\n\t\t\tif(R<0) break;\n\t\t\tint b=min(h-1-d,R/w);\n\t\t\tint tmp=b;\n\t\t\tb++;\n\t\t\tif(b+d<h&&w*b-gcd(w-a,b+d)-gcd(a,b)<=R) tmp++;\n\t\t\tif(d==0) res+=tmp;\n\t\t\telse res+=tmp*2;\n\t\t}\n\treturn res*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&w,&h,&k);\n\tprintf(\"%lld\",solve(w,h)+solve(h,w));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\nint s[509][100009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\tif (a <= 100000 && b <= 200) return s[b][a];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n\tfor (int i = 0; i <= 100000; i++) s[0][i] = i;\n\tfor (int i = 0; i <= 500; i++) s[i][0] = i;\n\tfor (int i = 1; i <= 500; i++) {\n\t\tfor (int j = i; j <= 500; j += i) {\n\t\t\tfor (int k = i; k <= 100000; k += i) s[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * (W - i) / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = s[a][x];\n\t\t\t\tint z2 = s[b][y];\n\t\t\t\tint z3 = s[W][abs(x - y)];\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - k); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 500) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint area = a * k + b * j;\n\t\t\t\tint z1 = gcd(a, j);\n\t\t\t\tint z2 = gcd(b, k);\n\t\t\t\tint z3 = gcd(W, abs(j - k));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\n \nconst ll INF = 2e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//↓,→,↑,←\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n    #undef endl\n#endif\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\n// const ll mod = 998244353ll;\nconst ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll mod){ll x=1;while(b){while(!(b&1)){(a*=a)%=mod;b>>=1;}(x*=a)%=mod;b--;}return x;}\nvoid YES(bool cond){ if(cond){ p(\"YES\");}else{ p(\"NO\");} return;}\nvoid Yes(bool cond){ if(cond){ p(\"Yes\");}else{ p(\"No\");} return;}\n\n/*\nll fact[fact_table + 5],rfact[fact_table + 5]; \n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table],mod - 2, mod);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n\nvoid init(){\n    struct timeval _time;\n    gettimeofday(&_time, NULL);\n    ll usec = _time.tv_usec * 1000000;\n    srand(usec);\n    return;\n}\n\nll range(ll a,ll b){\n    // generate random number [a, b]\n    // if b >= 10^8, this might not be precise\n    ll num = rand() % (1 + b - a) + a;\n    return num;\n}\n\nbool multicase = false;\nll mygcd(ll a, ll b){\n    if(b > a)swap(a, b);\n    if(b == 0 || a == b)return a;\n    return mygcd(b, a % b);\n}\n\nll calc(ll w, ll h, ll k){\n    ll ans = 0;\n    for(ll i1=1;i1<h;i1++){\n        for(ll i2=1;i2<h;i2++){\n            if (min(i1, i2) * w - 2 * h - w > 2 * k) break;\n            if (max(i1, i2) * w * 2 + 2 <= 2 * k) {\n                ans += w - 1;\n                continue;\n            }\n            for(ll j=1;j<w;j++){\n                ll b = mygcd(i1, j) + mygcd(w - j, i2) + mygcd(w, abs(i1 - i2));\n                ll s = max(i1, i2) * w * 2;\n                s -= (i1 * j) + (w - j) * (i2) + (abs(i1 - i2) * w);\n                if(s - b + 2 <= 2 * k)ans ++;\n            }\n        }\n    }\n    return ans;\n}\nll n,m,num,a,b,c,d,e,h,q;\nvoid solve(){\n    ll w, k;\n    cin >> w >> h >> k;\n    ll ans = 0;\n    ans += calc(w, h, k) * 2;\n    ans += calc(h, w, k) * 2;\n    p(ans);\n    return;\n}\n\nint main(){\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll q, testcase = 1;\n    if(multicase){\n        cin >> q;\n    }else{\n        q = 1; \n    }\n    while(q--){\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n    // solve();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint W,H,K,i,j,k,l;\ninline ll calc(int n,int m){\n\tstatic int v1[N],v2[N];ll ans=0;\n\tfor(i=1;i<m;++i){\n\t\tint lm1,lm2;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv1[j]=(m+1)*(j+1)-(i+1)*(j+1)+3;\n\t\t\tif(v1[j]>K*2+500)break;\n\t\t}\n\t\tlm1=j;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv2[j]=(m+1)*j-(m-i+1)*(j+1);\n\t\t\tif(v2[j]>K*2+500)break;\n\t\t}\n\t\tlm2=j;\n\t\tfor(j=1,k=lm2-1;j<lm1;++j){\n\t\t\tfor(;k>1 && v1[j]+v2[k]>K*2;--k);\n\t\t\tans+=k-1;\n\t\t\tint vv=v1[j]-__gcd(j,i);\n\t\t\tfor(l=0;vv+v2[k+l]-m-(m-i)<=K*2 && k+l<lm2;++l)ans+=vv+v2[k+l]-__gcd(k+l,m-i)-__gcd(abs(j-k-l),m)<=K*2;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tprintf(\"%lld\\n\",calc(W,H)+calc(H,W)<<1);\n}"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\n#define vsv sim,class d,class e\n#define nop(o,c,r,l...)>auto operator o(const c&a,const r&b)->decltype(make_pair(l)){return{l};}\n#define pcg(o) vsv,class f nop(o, pair <c u d>, pair <e u f>, a.first o b.first, a.second o b.second)vsv,class=typename enable_if<!is_base_of<ios_base,c>::value>::type nop(o,c,pair<d u e>,a o b.first,a o b.second)vsv nop(o,pair<c u d>,e,a.first o b,a.second o b)\n#define clp(o) pcg(o)vsv>void operator o##=(pair<c,d>&a,const e&b){a.first o##=b;a.second o##=b;}vsv,class f>void operator o##=(pair<c,d>&a,const pair<e,f>&b){a.first o##=b.first;a.second o##=b.second;}\n#define syd(o) sim,class d>auto operator o(pair<c, d> e)->decltype(make_pair(o e.first,o e.second)){return{o e.first,o e.second};}\n#define u ,\nclp(+)clp(-)clp(*)clp(/)clp(%)clp(^)clp(|)clp(>>)clp(<<)clp(&)pcg(&&)pcg(||)syd(-)syd(+)syd(~)syd(!)\n#undef u\nint on(pii a, pii b) {\n\ta -= b;\n\tint g = gcd(FS(a));\n\treturn abs(g);\n}\nll pro(pii a, pii b) {\n\treturn a.first * 1ll * b.second - a.second * 1ll * b.first;\n}\nll area2(pii a, pii b, pii c) {\n\treturn abs(pro(a - b, b - c));\n}\nint ins(pii a, pii b, pii c) {\n\tll s2 = area2(a, b, c);\n\t// debug(imie(a), imie(b), imie(c));\n\tassert(s2);\n\tint bou = on(a, b) + on(b, c) + on(c, a);\n\tint out = s2 - bou + 2;\n\t// debug(imie(a), imie(b), imie(c), imie(bou), imie(s2), imie(out));\n\tassert(out % 2 == 0 && out >= 0);\n\treturn out / 2;\n}\nint solve_old(int w, int h, int K) {\n\tint ans = 0;\n\tint bou = 2 * (K + h + 1);\n\tfor (int i = 1; i < w; ++i) {\n\t\tfor (int j = i; j < w; ++j) {\n\t\t\tint coef = (i == j ? 1 : 2);\n\t\t\tpii a = {0, i}, b = {h, j};\n\t\t\tpii c0 = {1, 0};\n\t\t\tif (area2(a, b, c0) > bou) break;\n\t\t\tfor (int k = 1; k < h; ++k) {\n\t\t\t\tpii c = {k, 0};\n\t\t\t\tif (area2(a, b, c) > bou) break;\n\t\t\t\tif (ins(a, b, c) <= K) ans += coef;\n\t\t\t}\n\t\t}\n\t}\n\trans;\n}\nint solve_semi(int W, int H, int K) {\n\tint ans = 0;\n\tint bou1 = 2 * K, bou2 = 2 * (K + H + 1);\n\tfor (int a = 1; a < W; ++a) {\n\t\tfor (int b = 1; b < H; ++b) {\n\t\t\tpii A = {a, 0}, B = {0, b}, C0 = {a, H};\n\t\t\tif (area2(A, B, C0) > bou2) break;\n\t\t\tfor (int c = a; c < W; ++c) {\n\t\t\t\tint coef = (a == c ? 1 : 2);\n\t\t\t\tpii C = {c, H};\n\t\t\t\tif (area2(A, B, C) > bou2) break;\n\t\t\t\tbool is = ins(A, B, C) <= K;\t\n\t\t\t\tif (area2(A, B, C) <= bou1) assert(is);\n\t\t\t\tif (is) ans += coef;\n\t\t\t}\n\t\t}\n\t}\n\trans;\n}\nll solve(int W, int H, int K) {\n\tll ans = 0;\n\tint bou1 = 2 * K, bou2 = 2 * (K + H + 1);\n\tfor (int a = 1; a < W; ++a) {\n\t\tfor (int b = 1; b < H; ++b) {\n\t\t\tpii A = {a, 0}, B = {0, b}, C0 = {a, H};\n\t\t\tif (area2(A, B, C0) > bou2) break;\n\t\t\tll a0 = area2(A, B, C0), a1 = area2(A, B, {a + 1, H});\n\t\t\tll step = a1 - a0;\n\t\t\tint x = max(0ll, min((bou1 - a0) / step, (ll)W - a));\n\t\t\tans += 2 * x - (x > 0);\n\t\t\tfor (int c = a + x; c < W; ++c) {\n\t\t\t\tint coef = (a == c ? 1 : 2);\n\t\t\t\tpii C = {c, H};\n\t\t\t\tif (area2(A, B, C) > bou2) break;\n\t\t\t\tbool is = ins(A, B, C) <= K;\t\n\t\t\t\tif (area2(A, B, C) <= bou1) assert(is);\n\t\t\t\tif (is) ans += coef;\n\t\t\t}\n\t\t}\n\t}\n\trans;\n}\nint main() {\n\tint w, h, K;\n\tscanf(\"%d%d%d\", &w, &h, &K);\n\tif (w == 1 || h == 1) done(\"0\\n\");\n\tprintf(\"%lld\\n\", 2 * (solve(w, h, K) + solve(h, w, K)));\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nint W,H,K,i,j,k,l;\ninline ll calc(int n,int m){\n\tstatic int v1[N],v2[N];ll ans=0;\n\tfor(i=1;i<m;++i){\n\t\tint lm1,lm2;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv1[j]=(m+1)*(j+1)-(i+1)*(j+1)+3;\n\t\t\tif(v1[j]>K*2+500)break;\n\t\t}\n\t\tlm1=j;\n\t\tfor(j=1;j<n;++j){\n\t\t\tv2[j]=(m+1)*j-(m-i+1)*(j+1);\n\t\t\tif(v2[j]>K*2+500)break;\n\t\t}\n\t\tlm2=j;\n\t\tfor(j=1,k=lm2-1;j<lm1;++j){\n\t\t\tfor(;k>1 && v1[j]+v2[k]>K*2;--k);\n\t\t\tans+=k-1;\n\t\t\tfor(l=0;l<130 && k+l<lm2;++l)ans+=v1[j]+v2[k+l]-__gcd(j,i)-__gcd(k+l,m-i)-__gcd(abs(j-k-l),m)<=K*2;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tprintf(\"%lld\\n\",calc(W,H)+calc(H,W)<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint64_t count_bottom(int W, int H, int K) {\n    int64_t answer = 0;\n\n    for (int s = 0; s < H - 1; s++)\n        for (int x = 1; x < W && x * s <= 2 * K + W - 2; x++) {\n            int R = 2 * K - 2 - x * s + __gcd(W, s);\n\n            if (R >= 0) {\n                int y = min(R / W + 1, H - s - 1);\n                int success = W * y - __gcd(x, y) - __gcd(W - x, y + s) <= R;\n                success += y - 1;\n                answer += (s == 0 ? 1 : 2) * success;\n            }\n        }\n\n    return answer;\n}\n\nint main() {\n    int W, H, K;\n    cin >> W >> H >> K;\n    cout << 2 * count_bottom(W, H, K) + 2 * count_bottom(H, W, K) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\t/*FOR(y,1,w)\n\t\tFOR(z,1,h)\n\t\t\tFor(x,1,z) if (1ll*y*z+1ll*x*(w-y)-__gcd(x,y)-__gcd(w-y,z)-__gcd(w,z-x)<=2*k-2){\n\t\t\t\tans++;\n\t\t\t\tprintf(\"%d %d %d %d\\n\",w,y,z,x);\n\t\t\t\tif (z!=x) ans++;\n\t\t\t}\n\treturn ans;*/\n\t//ll sum=0;\n\tFOR(y,1,w){\n\t\t++ans;\n\t\tFor(z,2,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),L=0,R=0,lim=2*k-2;\n\t\t\tl=1,r=z-1;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-y-min(z-mid,w)-tmp<=lim) R=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tif (R==0) break;\n\t\t\t//sum+=R-L;\n\t\t\tint ret=0;\n\t\t\tFor(x,1,R) if (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\tret+=2;\n\t\t\t}\n\t\t\tans+=ret;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tif (w==1||h==1) return puts(\"0\"),0;\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\t/*FOR(y,1,w)\n\t\tFOR(z,1,h)\n\t\t\tFor(x,1,z) if (1ll*y*z+1ll*x*(w-y)-__gcd(x,y)-__gcd(w-y,z)-__gcd(w,z-x)<=2*k-2){\n\t\t\t\tans++;\n\t\t\t\tprintf(\"%d %d %d %d\\n\",w,y,z,x);\n\t\t\t\tif (z!=x) ans++;\n\t\t\t}\n\treturn ans;*/\n\t//ll sum=0;\n\tFOR(y,1,w){\n\t\t++ans;\n\t\tFor(z,2,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),L=0,R=0,lim=2*k-2;\n\t\t\tl=1,r=z-1;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-y-min(z-mid,w)-tmp<=lim) R=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tif (R==0) break;\n\t\t\t//sum+=R-L;\n\t\t\tint ret=0;\n\t\t\tFor(x,1,R) if (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\tret+=2;\n\t\t\t}\n\t\t\tans+=ret;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tif (w==1||h==1) return puts(\"0\"),0;\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                if (s / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                long g = mm;\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a - c, w);\n                }\n                g += mem2[a];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\nint n,m,k;\nlong long ans;\n\nvoid solve(){\n\tfor (int b=0;b<m;++b){\n\t\tfor (int c=1;c<n&&b*c<=k*2-2+n*3;++c){\n\t\t\tint r=k*2-2+__gcd(n,b)-b*c;\n\t\t\tans+=max(0,min(m-1-b,r/n))*(1+(b>0));\n\t\t\tfor (int a=r/n+1;a<=r/n+2;++a){\n\t\t\t\tif (a>0&&a+b<m) ans+=(a*n-__gcd(a,c)-__gcd(n-c,a+b)<=r)*(1+(b>0));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tsolve();\n\tswap(n,m);\n\tsolve();\n\tprintf(\"%lld\\n\",ans*2);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tif (w < h) {\n\t\tll inf = -2 * h - w;\n\t\tll res1 = 0; ll res2 = 0;\n\t\tfor (ll x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)continue;\n\t\t\tfor (ll x2 = x1; x2 < w; x2++) {\n\t\t\t\tif (2 * k - 2 - x1 * h - (x2 - x1) < inf)continue;\n\t\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\t\tll s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + gcd(x2 - x1, h);\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n\telse {\n\t\tll inf = -2 * h - w;\n\t\tll res1 = 0; ll res2 = 0;\n\t\tfor (ll x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)continue;\n\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\tfor (ll x2 = x1; x2 < w; x2++) {\n\t\t\t\t\tll s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + gcd(x2 - x1, h);\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll w, h, k;\n\tcin >> w >> h >> k;\n\tk = 2 * k - 2;\n\tll ans = 0;\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tll x = (k - i * a) / (w - i);\n\t\t\tchmin(x, h - 1);\n\t\t\tif (x < a) {\n\t\t\t\tfor (ll b = a; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += (x - a) * 2 + 1;\n\t\t\t\tfor (ll b = x + 1; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswap(w, h);\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tll x = (k - i * a) / (w - i);\n\t\t\tchmin(x, h - 1);\n\t\t\tif (x < a) {\n\t\t\t\tfor (ll b = a; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += (x - a) * 2 + 1;\n\t\t\t\tfor (ll b = x + 1; b < h; b++) {\n\t\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nll cal(int w,int h,int k) {\n\tll ret=0;\n\tfor(int d=0;d<h;d++)\n\t\tfor(int j=1;j<w&&1ll*d*j<=k+k+w-2;j++) {\n\t\t\tint val=k+k+__gcd(w,d)-2-d*j;\n\t\t\tif(val<0) continue;\n\t\t\tint lim=min(h-1-d,val/w),cnt=lim;\n\t\t\tif(lim+1<=h-1-d&&1ll*(lim+1)*w-__gcd(lim+1,j)-__gcd(w-j,lim+1+d)<=val) ++cnt;\n\t\t\tret+=cnt*(d==0?1:2);\n\t\t}\n\treturn ret;\n}\n\nint main() {\n\tint w,h,k;cin>>w>>h>>k;\n\tcout<<(cal(w,h,k)+cal(h,w,k))*2;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nll area(int x1, int y1, int x2, int y2, int x3, int y3) {\n  int a = x2 - x1, b = y2 - y1;\n  int c = x3 - x1, d = y3 - y1;\n  return abs(a * (ll) d - b * (ll) c);\n}\n\nll f(int a, int b) {\n  a = abs(a), b = abs(b);\n  while (b) {\n    int ret = a % b;\n    a = b;\n    b = ret;\n  }\n  return a;\n}\n\nll cost(int x1, int y1, int x2, int y2, int x3, int y3) {\n  ll a = area(x1, y1, x2, y2, x3, y3);\n  ll g = f(x2 - x1, y2 - y1) + f(x3 - x1, y3 - y1) + f(x3 - x2, y3 - y2);\n  return a - g + 2;\n}\n\nll bad_consider = 0;\n\nll solve(int w, int h, int k) {\n  ll sum = 0;\n  int t = min(w, h);\n  int z = max(w, h);\n  for (int x1 = 1; x1 < w; x1++) {\n    for (int y = h - 1; y >= 1; y--) {\n      if (x1 * (ll) (h - y) > k + 3 * z) {\n        break;\n      }\n      ll val = x1 * (ll) (h - y) - f(y, x1);\n      ll mx = min((ll) w - 1, max(0ll, (k - val) / y));\n      sum += 2 * mx;\n      auto eval = [&] (int x2) {\n        if (val + x2 * (ll) y - f(h - y, x2) - f(x2 - x1, h) <= k) {\n          sum += 2;\n        }\n      };\n      if (x1 > mx) {\n        eval(x1);\n      }\n      for (int x2 = mx + 1; x2 < w; x2++) {\n        if (val + x2 * (ll) y - 2 * t > k) {\n          break;\n        }\n        if (x2 != x1)\n          eval(x2);\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int w, h, k;\n  cin >> w >> h >> k;\n  k = 2 * (k - 1);\n  cout << solve(w, h, k) + solve(h, w, k) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=500005,lim=100000;\nint p[N],flag[N],mu[N],A[N],B[N],nA,nB,W,H,K;\nll ans;\nvi d;\n\nvoid init(int n){\n\tint cnt=0;\n\tmu[1]=1;\n\trep(i,2,n){\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tflag[i*p[j]]=1;\n\t\t\tif(i%p[j]==0){\n\t\t\t\tmu[i*p[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i*p[j]]=-mu[i];\n\t\t}\n\t}\n}\n\nll calc(int W,int H,int K,int d){\n\tll ans=0;\n\tint tot=0;\n\trep(r,1,min(d,min(H,K+W))){\n\t\trep(x,1,W-1){\n\t\t\tnA=nB=0;\n\t\t\tfor(int i=r;i<H&&(ll)i*(W-x)<=K+W;i+=d){\n\t\t\t\tA[++nA]=i*(W-x)-__gcd(i,x);\n\t\t\t\tint p=nA;\n\t\t\t\twhile(p>=2&&A[p]<A[p-1]){\n\t\t\t\t\tswap(A[p],A[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=r;i<H&&(ll)i*x<=K+W;i+=d){\n\t\t\t\tB[++nB]=i*x-__gcd(i,W-x);\n\t\t\t\tint p=nB;\n\t\t\t\twhile(p>=2&&B[p]<B[p-1]){\n\t\t\t\t\tswap(B[p],B[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p=nA;\n\t\t\trep(i,1,nB){\n\t\t\t\twhile(p&&A[p]+B[i]>K) p--;\n\t\t\t\tans+=p;\n\t\t\t}\n\t\t\ttot+=nA+nB;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int W,int H){\n\td.clear();\n\tfor(int i=1;i*i<=W;i++){\n\t\tif(W%i==0){\n\t\t\td.pb(i);\n\t\t\tif(i*i!=W) d.pb(W/i);\n\t\t}\n\t}\n\tfor(auto x:d){\n\t\tfor(auto y:d){\n\t\t\tif(y%x==0&&mu[y/x]){\n\t\t\t\tans+=mu[y/x]*calc(W,H,K+x,y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tread(W),read(H),read(K);\n\tK=K*2-2;\n\tinit(lim);\n\tsolve(W,H);\n\tsolve(H,W);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll ans,m,n,k;\nvoid get(){\n\tfor (ll x=1;x<n;x++){\n\t\tfor (ll y=0;y<m-1;y++){\n\t\t\tif (x*y>2*k+n-2) break;\n\t\t\tll b=2*k-2-x*y+__gcd(n,y),c=b/n;\n\t\t\tif (c+y<m-1){if (n*(c+1)<=b+__gcd(x,c+1)+__gcd(n-x,c+y+1))c++;}\n\t\t\telse c=m-1-y;\n\t\t\tif (y==0)ans+=c*2;else ans+=c*4;\n\t\t}\n\t}\n}\nint main(){\n\tcin>>n>>m>>k;\n\tget();swap(m,n);get();cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tif (w < h) {\n\t\tint inf = -2 * h - w;\n\t\tint res1 = 0; int res2 = 0;\n\t\tfor (int x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)break;\n\t\t\tfor (int x2 = x1; x2 < w; x2++) {\n\t\t\t\tif (2 * k - 2 - x1 * h - (x2 - x1) < inf)break;\n\t\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\t\tint s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + gcd(x2 - x1, h);\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n\telse {\n\t\tint inf = -2 * h - w;\n\t\tint res1 = 0; int res2 = 0;\n\t\tfor (int x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)break;\n\t\t\tfor (int y = 1; y < h; y++) {\n\t\t\t\tfor (int x2 = x1; x2 < w; x2++) {\n\t\t\t\t\tint s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + gcd(x2 - x1, h);\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n  if(a==0 || b==0) return(a+b);\n  else if(a%b == 0) return(b);\n  else return(gcd(b, a%b));\n}\n\nint main(){\n  int W,H,K;\n  cin>>W>>H>>K;\n  long long cnt1=0;\n  long long cnt2=0;\n  \n\tfor(int i=1;i<=H-1;i++){ //横の長さがW\n      for(int j=1;j<=H-1;j++){\n        for(int k=1;k<=W-1;k++){\n          long long X=gcd(W,abs(i-j))+gcd(i,k)+gcd(j,W-k)-(2*W*max(i,j)-(W*abs(i-j)+i*k+j*(W-k)));\n            if(X<=2*K+2){\n              cnt1++;\n            }\n        }\n      }\n    }\n\tfor(int i=1;i<=W-1;i++){ //縦の長さがH  \n      for(int j=1;j<=W-1;j++){\n        for(int k=1;k<=H-1;k++){\n          long long X=gcd(abs(i-j),H)+gcd(i,k)+gcd(j,H-k)-(2*H*max(i,j)-(H*abs(i-j)+i*k+j*(H-k)));\n            if(X<=2*K+2){\n              cnt2++;\n            }\n        }\n      }\n    }\n//    long long X=gcd(a,b)+gcd(c,d)+gcd(e,f)-(2*max({a,c,e})*H-(a*b+c*d+e*f));\n//  if(X<=2*K+2) count++;\n  \n  cout<<2*(cnt1+cnt2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=100005;\nint w,h,k;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nlong long solve(int w,int h)\n{\n\tlong long res=0;\n\tfor(int d=0;d<h;d++)\n\t\tfor(int a=1;a<w;a++)\n\t\t{\n\t\t\tint R=2*k-a*d+gcd(d,w)-2;\n\t\t\tif(R<0) break;\n\t\t\tint b=min(h-1-d,R/w);\n\t\t\tint tmp=b;\n\t\t\tb++;\n\t\t\tif(b+d<h&&1LL*w*b-gcd(w-a,b+d)-gcd(a,b)<=R) tmp++;\n\t\t\tif(d==0) res+=tmp;\n\t\t\telse res+=tmp*2;\n\t\t}\n\treturn res*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&w,&h,&k);\n\tprintf(\"%lld\",solve(w,h)+solve(h,w));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nint spe[100005];\nint gv[100005];\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+1500,top=0;\n\tFor(i,0,H-1) gv[i]=gcd(W,i);\n\tFor(k,1,H-1) if (gcd(k,W)>=1000) spe[++top]=k;\n\tFor(k,W-W/2,W-1){\n\t\t//if (k%100==0) cerr<<k<<endl;\n\t\tint B=min(300000/(W-k),H-1),rp=(k*2==W?1:2);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k)-gcd(k,i),key2=k;\n\t\t\tll b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tif (b1>=i) ans-=rp;\n\t\t\tb1=min(b1,1ll*(H-1)); ans+=b1*rp; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tll cv=key1-gv[abs(b1-i)]-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2&&b1!=i) ans+=rp;\n\t\t\t}\n\t\t\tll arr=1ll*W*i;\n\t\t\tll cv=arr-W-gcd(k,i)-gcd(W-k,i);\n\t\t\tif (cv<=2*K-2) ans+=rp;\n\t\t\tif (1ll*(W-k)*1000<=2*K+W+2000){\n\t\t\t\tRep(p,top,1){\n\t\t\t\t\tint b=i-spe[p];\n\t\t\t\t\tif (b<b1||b>=H) continue;\n\t\t\t\t\tll arr=1ll*(W-k)*i-gcd(k,i)+1ll*k*b;\n\t\t\t\t\tif (arr>2*K+W+1500) break;\n\t\t\t\t\tll cv=arr-gv[abs(i-b)]-gcd(W-k,b);\n\t\t\t\t\t//if (i==2501&&spe[p]==2500) cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t\tif (cv<=2*K-2&&arr>LIM) ans+=rp;//cerr<<cv<<' '<<arr<<endl;\n\t\t\t\t}\n\t\t\t\tFor(p,1,top){\n\t\t\t\t\tint b=i+spe[p];\n\t\t\t\t\tif (b<b1||b>=H) continue;\n\t\t\t\t\tll arr=1ll*(W-k)*i-gcd(k,i)+1ll*k*b;\n\t\t\t\t\tif (arr>2*K+W+1500) break;\n\t\t\t\t\tll cv=arr-gv[abs(i-b)]-gcd(W-k,b);\n\t\t\t\t\tif (cv<=2*K-2&&arr>LIM) ans+=rp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n5000 5000 100000\n197045732\n100000 100000 100000\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n\tcerr<<clock()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 100005;\n\nint K;\n\nint solve(int W, int H) {\n\tint S = 3 * H + 2 * K;\n\tint ans[2] = {0, 0};\n\tfor (int y = 1; y < H; ++y) {\n\t\tfor (int d = 0; d * y <= S && d < W; ++d) {\n\t\t\tint R = std::__gcd(d, H) + 2 * K - 2 - d * y;\n\t\t\tint lim = std::min(std::max(R / H, 0), W - d - 1);\n\t\t\tans[d == 0] += lim;\n\t\t\tfor (int x1 = lim + 1; x1 <= lim + 2 && x1 + d < W; ++x1) {\n\t\t\t\tif (x1 * H - std::__gcd(x1 + d, H - y) - std::__gcd(x1, y) <= R) {\n\t\t\t\t\t++ans[d == 0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2 * ans[0] + ans[1];\n}\n\nint main() {\n\tint W, H;\n\tread(W), read(H), read(K);\n\t// W = H = K = 100000;\n\tprint(2 * (solve(W, H) + solve(H, W)));\n\tdebug(\"%.3lf\\n\", 1.0 * clock() / CLOCKS_PER_SEC);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma region template\n#include <bits/stdc++.h>\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define sz(a) (int)(a).size()\n#define last(a) (a).at((int)(a).size()-1)\n#define rep(i,n) for(int i=0,i##_len=(n);i<i##_len;i++)\n#define brep(i,a,b) for(int i=(a),i##_len=(b);i<=i##_len;i++)\n#define rrep(i,n) int i=(n);int now=-1;while(i--&&(now++||1))\n#define xrep(i,n) for(int i=1,i##_len=(n);i<=i##_len;i++)\n#define Yes(n) cout<<((n)?YES:NO)<<'\\n'\n#define co(n) cout<<(n)<<'\\n'\n#define fo(n) printf(\"%.15lf\\n\",(n))\n#define fout cout<<fixed<<setprecision(15)\n#define Sort(v) sort(all(v))\n#define rSort(v) sort(all(v),greater<typeof(v[0])>())\n#define Rev(v) reverse(all(v))\n#define Unique(v) (v).erase(unique(all(v)),(v).end())\n#define eb emplace_back\n#define fi first\n#define se second\n\n#ifdef ONLINE_JUDGE\n#define here()\n#define cprint(vec)\n#define comment(msg)\n#define observe(var)\n#define local(x)\n#define alter(x,y) y\n#else\n#define here() cerr<<__func__<<'/'<<__LINE__<<\": passed\\n\"\n#define cprint(vec) print_e(vec)\n#define comment(msg) cerr<<\"{ \"<<msg<< \" }\\n\"\n#define observe(var) cerr<<\"{ \"<<#var<<\" : \"<<var<<\" }\\n\"\n#define local(x) x\n#define alter(x,y) x\n#endif\n\nusing namespace std;\nusing ll    = long long;\nusing ld    = long double;\nusing ull   = unsigned long long;\nusing vbl   = vector<bool>;\nusing dqbl  = deque<bool>;\nusing vint  = vector<int>;\nusing vll   = vector<long long>;\nusing vdbl  = vector<double>;\nusing vstr  = vector<string>;\nusing vvbl  = vector<vector<bool>>;\nusing vdqbl = vector<deque<bool>>;\nusing vvint = vector<vector<int>>;\nusing vvll  = vector<vector<long long>>;\n\nconstexpr int         INF   = 1e9;\nconstexpr long long   LINF  = 1e18;\nconstexpr double      EPS   = 1e-9;\nconstexpr long double LEPS  = 1e-18;\n\n// --- functions which take 1 argument --- //\ninline void ignore_ret(int x){x++;}\ntemplate<class T> inline int sgn(const T& x){return (x>0)-(x<0);}\ntemplate<class T> inline int digit(T x){int r=1;while((x/=10)>=1)r++;return r;}\ntemplate<class T> inline double deg_to_rad(const T& a){return a/180.0*M_PI;}\ntemplate<class T> inline double rad_to_deg(const T& a){return a/M_PI*180.0;}\ntemplate<class T> inline ll factorial(const T& n){if(n==0)return 1;ll r=1;brep(i,2,n)r*=i;return r;}\ntemplate<class T> inline map<T,T> factorize(T n){map<T,T>r;for(T i=2;i*i<=n;i++){while(n%i==0){r[i]++;n/=i;}}if(n!=1)r[n]=1;return r;}\ntemplate<class T> inline vector<T> divisor(const T& n){vector<T>r;for(T i=1;i*i<=n;i++){if(!(n%i)){r.eb(i);if(i*i!=n)r.eb(n/i);}}Sort(r);return r;}\n\n// --- functions which take 2 arguments --- //\ntemplate<class T> inline bool chmax(T& a,const T& b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,const T& b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline T nPr(const T& n,const T& k){if(n<k||n<0||k<0)return 0;T r=1;brep(i,n-k+1,n)r*=i;return r;}\ntemplate<class T> inline T nCr(const T& n,const T& k){if(n<k||n<0||k<0)return 0;T r=1;k=min(k,n-k);brep(i,n-k+1,n)r*=i;return r/factorial(k);}\n\n// --- functions which take vector(s) as argument(s) --- //\ntemplate<class T> inline void print(const vector<T>& v){cout<<\"[ \";for(auto& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class T> inline void print(const vector<vector<T>>& v){for(auto& x:v)print<T>(x);}\ntemplate<class T> inline void print_d(const vector<T>& v,string d){rep(i,sz(v)-1)cout<<v[i]<<d;cout<<last(v)<<'\\n';}\ntemplate<class T> inline void print_d(const vector<vector<T>>& v,string d){for(auto& x:v)print_d(x,d);}\ntemplate<class T> inline void print_e(const vector<T>& v){cerr<<\"[ \";for(auto& x:v)cerr<<x<<' ';cerr<<\"]\\n\";}\ntemplate<class T> inline void print_e(const vector<vector<T>>& v){for(auto& x:v)print_e<T>(x);}\ntemplate<class T> inline bool in(const T& k,const vector<T>& v){return find(all(v),k)!=v.end();}\n                  inline bool in(const int& k,const vector<ll>& v){return find(all(v),k)!=v.end();}\n                  inline bool in(const ll& k,const vector<int>& v){return find(all(v),k)!=v.end();}\n                  inline bool in(const char& k,const string& v){return find(all(v),k)!=v.end();}\n                  inline bool in(const char*& k,const vector<string>& v){return find(all(v),k)!=v.end();}\ntemplate<class T> inline T min(const vector<T>& v){return *min_element(all(v));}\ntemplate<class T> inline T max(const vector<T>& v){return *max_element(all(v));}\ntemplate<class T> inline T sum(const T& v){return reduce(all(v),(T)0);}\ntemplate<class T> inline T gcd(const vector<T>& v){T r=v[0];brep(i,1,sz(v)-1)r=gcd(r,v[i]);return r;}\ntemplate<class T> inline T lcm(const vector<T>& v){T r=v[0];brep(i,1,sz(v)-1)r=lcm(r,v[i]);return r;}\ntemplate<class T> inline double abs(const vector<T>& v){return sqrt(reduce(all(v),0.0,[](T s,T v){return s+=v*v;}));}\ntemplate<class T> inline T vector_add(const T& u,const T& v){T r(u.size());rep(i,u.size())r[i]=u[i]+v[i];return r;}\ntemplate<class T> inline T vector_subtract(const T& u,const T& v){T r(u.size());rep(i,u.size())r[i]=u[i]-v[i];return r;}\ntemplate<class T> inline T vector_multiply(const T& u,const T& v){T r(u.size());rep(i,u.size())r[i]=u[i]*v[i];return r;}\ntemplate<class S,class T> inline common_type<S,T> dot_product(const vector<S>& u,const vector<T>& v){T r=0;rep(i,u.size())r+=u[i]*v[i];return r;}\ntemplate<class S,class T> inline void sort_by_second(vector<pair<S,T>>& v){sort(all(v),[](auto& L,auto& R){return L.second<R.second;});}\n\n// --- functions which take set/map as argument --- //\ntemplate<class T> inline bool in(const T& k,const set<T>& v){return find(all(v),k)!=v.end();}\ntemplate<class T> inline bool in(const T& k,const unordered_set<T>& v){return find(all(v),k)!=v.end();}\ntemplate<class T> inline T min(const set<T>& v){return *min_element(all(v));}\ntemplate<class T> inline T min(const unordered_set<T>& v){return *min_element(all(v));}\ntemplate<class T> inline T max(const set<T>& v){return *max_element(all(v));}\ntemplate<class T> inline T max(const unordered_set<T>& v){return *max_element(all(v));}\ntemplate<class T> inline T gcd(const set<T>& v){T r=0;for(T x:v)r=(r==0)?x:gcd(r,x);return r;}\ntemplate<class T> inline T gcd(const unordered_set<T>& v){T r=0;for(T x:v)r=(r==0)?x:gcd(r,x);return r;}\ntemplate<class T> inline T lcm(const set<T>& v){T r=0;for(T x:v)r=(r==0)?x:lcm(r,x);return r;}\ntemplate<class T> inline T lcm(const unordered_set<T>& v){T r=0;for(T x:v)r=(r==0)?x:lcm(r,x);return r;}\ntemplate<class T>         inline void print(const set<T>& v){cout<<\"[ \";for(T& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class T>         inline void print(const unordered_set<T>& v){cout<<\"[ \";for(T& x:v)cout<<x<<' ';cout<<\"]\\n\";}\ntemplate<class S,class T> inline void print(const map<S,T>& m){cout<<\"[ \";for(auto& x:m)cout<<\"{ \"<<x.fi<<\", \"<<x.se<<\" } \";cout<<\"]\\n\";}\ntemplate<class S,class T> inline void print(const unordered_map<S,T>& m){cout<<\"[ \";for(auto& x:m)cout<<\"{ \"<<x.fi<<\", \"<<x.se<<\" } \";cout<<\"]\\n\";}\n#pragma endregion template\n\nll W, H, K;\n\ninline ll g(const ll &a, const ll &b) {\n  return ((a-1) * (b-1) + gcd(a, b) - 1) / 2;\n}\n\ninline ll f(ll a, ll b, ll c, ll d) {\n  local(assert(c*d == 0));\n\n  if (d == 0) {\n    local(assert(c > 0));\n    if (a > c) swap(a, c);\n    return (c-1) * (H-1) - g(a, b) - g(H-b, c) - g(c-a, H);\n  }\n\n  if (c == 0) {\n    local(assert(d > 0));\n    if (b > d) swap(b, d);\n    return (d-1) * (W-1) - g(a, b) - g(W-a, d) - g(d-b, W);\n  }\n\n  return 0;\n}\n\nvoid solve() {\n  // naive solution\n  ll ans = 2 * (W-1) * (H-1) * (W+H-2);\n  ll diff = 0;\n\n  brep(a, 1, W-1)\n  brep(b, 1, H-1)\n  brep(c, 1, W-1)\n\n  {\n    ll d = 0LL;\n    ll cnt = f(a, b, c, d);\n    diff += cnt > K;\n    local(printf(\"[ %lld, %lld, %lld, %lld ], %lld, %s\\n\", a, b, c, d, cnt, (cnt > K ? \"Yes\" : \"No\")));\n  }\n\n  brep(a, 1, W-1)\n  brep(b, 1, H-1)\n  brep(d, 1, H-1)\n\n  {\n    ll c = 0LL;\n    ll cnt = f(a, b, c, d);\n    diff += cnt > K;\n    local(printf(\"[ %lld, %lld, %lld, %lld ], %lld, %s\\n\", a, b, c, d, cnt, (cnt > K ? \"Yes\" : \"No\")));\n  }\n\n  co(ans - diff * 2);\n}\n\nint main() {\n  ignore_ret(scanf(\"%lld\",&W));\n  ignore_ret(scanf(\"%lld\",&H));\n  ignore_ret(scanf(\"%lld\",&K));\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint W,H,k;\ninline int _gcd(int a,int b){\n\tif(b==0)return a;\n\treturn _gcd(b,a%b);\n}\nll Solve(int n,int m){\n\tint lim=3*m+2*k;\n\tll ans=0;\n\tfor(int y=1;y<m;++y){\n\t\tfor(int d=0;d<n&&d*y<=lim;++d){\n\t\t\tint t=_gcd(m,d)+2*k-d*y-2;\n\t\t\tint x=t/m+1;\n\t\t\tans+=(max(0,min(t/m,n-d-1))+(x+d<n&&x*m-_gcd(x,y)-_gcd(m-y,x+d)<=t))*(1+(d>0));\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tW=read(),H=read(),k=read();\n\tprintf(\"%lld\\n\",(Solve(W,H)+Solve(H,W))<<1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint r[5009][5009];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\tif (a <= 5000 && b <= 5000) return r[a][b];\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\tfor (int i = 1; i <= 5000; i++) {\n\t\tfor (int j = i; j <= 5000; j += i) {\n\t\t\tfor (int k = i; k <= 5000; k += i) r[j][k] = i;\n\t\t}\n\t}\n}\n\nlong long solve_slow(int W, int H, int K) {\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tint V = W * i / gcd(W - i, W);\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\t\t\t\n\t\t\tfor (int k = 1; k <= min(H - 1, V); k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z += 2;\n\t\t\t\tif (z <= K * 2) {\n\t\t\t\t\tint adds = a * V;\n\t\t\t\t\tint rems = (K * 2) - z; rems /= adds; rems++;\n\t\t\t\t\tint rem2 = (H - 1 - i); rem2 /= V; rem2++;\n\t\t\t\t\tcnt += 1LL * min(rems, rem2) * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nlong long solve(int W, int H, int K) {\n\tif (W <= 400) return solve_slow(W, H, K);\n\n\tlong long cnt = 0;\n\tfor (int i = 1; i <= W / 2; i++) {\n\t\tint a = i, b = W - a, base = 2;\n\t\tif (i * 2 == W) base = 1;\n\n\t\t// 全探索\n\t\tfor (int j = 1; j <= H - 1; j++) {\n\t\t\tint r1 = b * j; if (r1 > 2 * K + 2 * W + 2) break;\n\n\t\t\tfor (int k = 1; k <= H - 1; k++) {\n\t\t\t\tint r2 = a * k; if (r1 + r2 > 2 * K + 2 * W + 2) break;\n\n\t\t\t\t// 求めるパート\n\t\t\t\tint x = j, y = k;\n\t\t\t\tint area = a * y + b * x;\n\t\t\t\tint z1 = gcd(a, x);\n\t\t\t\tint z2 = gcd(b, y);\n\t\t\t\tint z3 = gcd(W, abs(x - y));\n\t\t\t\tint z = (area - (z1 + z2 + z3)); z >>= 1; z += 1;\n\t\t\t\tif (z <= K) {\n\t\t\t\t\tcnt += 1LL * base;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tinit();\n\tlong long W, H, K; init();\n\tcin >> W >> H >> K;\n\n\tlong long V1 = solve(W, H, K);\n\tlong long V2 = solve(H, W, K);\n\tcout << 2LL * (V1 + V2) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n#include <ctime>\n#include<list>\n#include <numeric>\n#include<bitset>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<utility>\n#include<fstream>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include <array>\nusing namespace std;\n\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define CLR(a) memset(a, 0, sizeof(a))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) )\n#define S(X) ( (X) * (X) )\n#define SZ(V) (int )V.size()\n#define FORN(i, n) for(int i = 0; i < n; i++)\n#define FORAB(i, a, b) for(int i = a; i <= b; i++)\n#define ALL(V) V.begin(), V.end()\n#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))\n#define AIN(A, B, C) assert(IN(A, B, C))\n\ntypedef long long int LL;\n//typedef __int128 LLL;\ntypedef long long LLL;\n\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<double, double> PDD;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PLL> VPL;\ntypedef vector<PII> VP;\ntypedef vector<double> VD;\ntypedef vector<vector<int>> VVI;\ntypedef vector<string> VS;\ntypedef long double ld;\n\n#define MAXN 1000006\n//#define MAXN 1006\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\nconst LL INF = 2000000000000000001LL; //2e18 + 1\n\nLL gcd(LL a, LL b) {\n\tif (b == 0 || a == 0) return a + b;\n\tif (a % b == 0) return b;\n\treturn gcd(b, a % b);\n}\n\nLL w, h, k;\nLL Calc(LL w, LL h) {\n\tLL ans = 0;\n\tfor (LL x = 1; x < w; x++) {\n\t\tfor (LL y1 = 1; y1 < h; y1++) {\n\t\t\tLL R = 2 * k - 2 - y1 * (w - x) + gcd(x, y1);\n\t\t\tif (R + w * 2 < 0) break;\n\t\t\t// xy2 - g(w - x, y2) - g(w, y2 - y1) <= R\n\t\t\tLL mn = R / x;\n\t\t\tmn = MAX(mn, 0);\n\t\t\tLL mx = (R + 2 * w) / x;\n\t\t\tmx = MIN(mx, h - 1);\n\t\t\tans += MIN(mn, h - 1);\n\t\t\tfor (LL y2 = mn + 1; y2 <= mx; y2++) {\n\t\t\t\tLL L = x * y2 - gcd(w - x, y2) - gcd(w, ABS(y2 - y1));\n\t\t\t\tans += (L <= R);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int ks) {\n\tscanf(\"%lld %lld %lld\", &w, &h, &k);\n\tLL ans = 2 * (Calc(w, h) + Calc(h, w));\n\tprintf(\"%lld\\n\", ans);\n}\n\nvoid gen() {\n}\n\nint main()\n{\n\tdouble start_time = clock();\n#ifdef LOCAL\n\tfreopen(\"C:\\\\Home\\\\ContestCodes\\\\sample.in\", \"r\", stdin);\n\t// freopen(\"C:\\\\Home\\\\ContestCodes\\\\sample.in\", \"r\", stdin);\n\t//\tfreopen(\"out.out\", \"w\", stdout);\n#endif\n\n\tgen();\n\n\tif (0) {\n\t\tint T;\n\t\tscanf(\"%d\", &T);\n\t\t//AIN(T, 1, 5000);\n\t\tfor (int ks = 1; ks <= T; ks++) {\n\t\t\tsolve(ks);\n\t\t\tif (ks % 1 == 0) fprintf(stderr, \"%d done\\n\", ks);\n\t\t}\n\t}\n\telse {\n\t\tsolve(0);\n\t}\n\n\tdouble end_time = clock();\n\tfprintf(stderr, \"Time = %lf\\n\", (end_time - start_time) / CLOCKS_PER_SEC);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nint solve(int W,int H,int K){\n\tvector<int>gcd_Wv(H);\n\tfor(int i=0;i<H;i++)gcd_Wv[i]=gcd(W,i);\n\tconst int L=2*K+2*W-2;\n\tint ans=0;\n\tfor(int y=1;y<W;y++){\n\t\tfor(int x=1;x*W<=L&&x<H;x++){\n\t\t\tint gcd_xy=gcd(x,y);\n\t\t\tint s;\n\t\t\tint tmp=2*K+gcd_xy-2-(W-y)*x;\n\t\t\tif(tmp<=0)s=1;\n\t\t\telse s=tmp/y+1;\n\t\t\tchmax(s,x);\n\t\t\tchmin(s,H-1);\n\t\t\tans+=s-x;\n\t\t\tfor(int z=s;(W-y)*x+y*z<=2*K+gcd_xy+W-y+W-2&&z<H;z++){\n\t\t\t\tint num=(W-y)*x+y*z+2;\n\t\t\t\tnum-=gcd_xy+gcd_Wv[z-x]+gcd(W-y,z);\n\t\t\t\tnum/=2;\n\t\t\t\tif(num<=K)ans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tans*=2;\n\tfor(int y=1;y<W;y++){\n\t\tfor(int x=1;x*W<=L&&x<H;x++){\n\t\t\tint num=x*W+2;\n\t\t\tnum-=gcd(x,y)+gcd(W-y,x)+W;\n\t\t\tnum/=2;\n\t\t\tif(num<=K)ans--;\n\t\t}\n\t}\n\t\n\tans*=2;\n\treturn ans;\n}\n\nsigned main(){\n\tint W,H,K;\n\tcin>>W>>H>>K;\n\tcout<<solve(W,H,K)+solve(H,W,K)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nint cnt(int H, int W, int x, int y, int a){\n    int S = y * W + a * x;\n    int b = gcd(x, y) + gcd(W - x, y + a) + gcd(W, a);\n    return (S + 2 - b) / 2;\n}\n\nsigned main(){\n\n    int W, H, K; cin >> W >> H >> K;\n    int ans = 0;\n    REP(_, 2){\n        FOR(a, 1, H - 1){\n            int M = min(W - 1, 2 * (K + W) / a);\n            FOR(x, 1, M + 1){\n                int ymin = min((2 * K - a * x) / W, H - 1 - a);\n                if(ymin >= 1) ans += ymin * 2;\n                REP(k, 2) if(ymin + 1 + k <= H - 1 - a && ymin + 1 + k >= 1 && cnt(H, W, x, ymin + 1 + k, a) <= K) ans += 2;\n            }\n        }\n\n        FOR(x, 1, W){\n            int ymin = min(2 * K / W, H - 1);\n            if(ymin >= 1) ans += ymin;\n            REP(k, 2) if(ymin + 1 + k <= H - 1 && ymin + 1 + k >= 1 && cnt(H, W, x, ymin + 1 + k, 0) <= K) ans += 1;\n        }\n\n        swap(W, H);\n    }\n    ans *= 2;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\ninline int calc(int x, int y) {\n    return __gcd(abs(x), abs(y)) - 1;\n};\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 3e5; j++) {\n                int s;\n                for (int k = 1; k < h && (s = abs(j * i + (w - i) * k)) <= 2 * d + 3e5; k++) {\n                    s -= calc(j, w - i);\n                    s -= f[abs(j - k)];\n                    s -= calc(k, i);\n                    s -= 3;\n                    s += 2;\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\n\nlint solve(int H, int W, int K)\n{\n    lint ret = 0;\n    REP(dh, H - 1)\n    {\n        FOR(w, 1, W)\n        {\n\n            lint R = 2 * K - 2 + __gcd(W, dh) - 1LL * w * dh;\n            if (R < 0) break;\n\n            lint lo = min<lint>(R / W, H - 1 - dh); // hs <= lo なら必ず成立\n            lint hi = min<lint>((R + W * 2) / W, H - dh); // hs >= hi なら必ず不成立\n\n            lint ret_tmp = lo;\n            FOR(hs, lo + 1, hi)\n            {\n                lint x = hs * W - __gcd(w, hs) - __gcd<int>(W - w, hs + dh);\n                if (x <= R) ret_tmp++;\n            }\n            ret += ret_tmp * (1 + (dh != 0));\n        }\n    }\n    return ret * 2;\n}\n\nint main()\n{\n    int W, H, K;\n    cin >> W >> H >> K;\n    lint ret = solve(W, H, K) + solve(H, W, K);\n    cout << ret << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\ntemplate<class T> inline void dmin(T& x,T y){ y<x?x=y:0; }\ntemplate<class T> inline void dmax(T& x,T y){ y>x?x=y:0; }\ntemplate<class T> inline void dmin(T& x,vector<T> y){ \n\tfor(auto t:y) t<x?x=t:0;\n}\ntemplate<class T> inline void dmax(T& x,vector<T> y){\n\tfor(auto t:y) t>x?x=t:0;\n}\nld EPS=1e-10,PI=acos(-1);\ntemplate<class T> int sn(T x) { return x<-EPS?-1:(x>EPS); }\ntemplate<class T> struct P{ //represent a point, a vector, or a complex\n\tT x,y;\n\tP(T _x=T(),T _y=T()){ x=_x,y=_y; }\n\tinline P<T> operator!()const { return P<T>(x,-y); }\n\tinline P<T> operator+(const P<T>& b)const { return P<T>(x+b.x,y+b.y); }\n\tinline P<T> operator-(const P<T>& b)const { return P<T>(x-b.x,y-b.y); }\n\tinline P<T> operator*(const P<T>& b)const { return P<T>(x*b.x-y*b.y,x*b.y+y*b.x); }\n\tinline P<T> operator/(const T& t)const { return P<T>(x/t,y/t); }\n\tinline P<T> div2(const P<T>& b) const { return (*this)*(!b); }\n\tinline P<T> operator/(const P<T>& b)const { return div2(b)/b.dis2(); }\n\tinline T dis2()const { return x*x+y*y; }\n\tinline T dis()const { return sqrt(dis2()); }\n\tinline T cp(const P<T>& b)const { return x*b.y-y*b.x; }\n\tinline T dot(const P<T>& b)const { return x*b.x+y*b.y; }\n\tinline P<T> rot90()const { return P<T>(-y,x); }\n\tinline P<T> rot(const T& x)const { return (*this)*P<T>(cos(x),sin(x)); }\n\tinline int qua()const { return sn(y)>=0?(sn(x)>=0?1:2):(sn(x)>=0?4:3); }\n\tinline P<T> splay(const T& d)const{ return (*this)/dis()*d; }\n};\nint get_s(P<int> x,P<int> y,P<int> z){\n\treturn abs((y-x).cp(z-x));\n}\nconst int N=5+1e5;\nint max_fac[N],prime[N],g[505][505],top_prime=0,sp[N][3];\nbool vis[N];\nint gcd1(int x,int y){ return y?gcd1(y,x%y):x; }\ninline void Euler(int n){\n\tfor(int i=2;i<=n;++i) vis[i]=1;\n\tsp[1][0]=sp[1][1]=sp[1][2]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(vis[i]){\n\t\t\tprime[++top_prime]=i;\n\t\t\tmemcpy(sp[i],sp[1],sizeof(sp[i]));\n\t\t\tsp[i][0]=i;\n\t\t}\n\t\tfor(int j=1;j<=top_prime&&i*prime[j]<=n;++j){\n\t\t\tint k=i*prime[j];\n\t\t\tvis[k]=0;\n\t\t\tmemcpy(sp[k],sp[i],sizeof(sp[i]));\n\t\t\tif(sp[k][0]<sp[k][1]&&sp[k][0]<sp[k][2]) sp[k][0]*=prime[j];\n\t\t\telse if(sp[k][1]<sp[k][2]) sp[k][1]*=prime[j];\n\t\t\telse sp[k][2]*=prime[j];\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=0;i<=500;++i)\n\t\tfor(int j=0;j<=500;++j)\n\t\t\tg[i][j]=gcd1(i,j);\n//\tfor(int i=1;i<=10;++i)\n//\t\tprintf(\"|%d %d %d|\",sp[i][0],sp[i][1],sp[i][2]);\n//\texit(0);\n//\tfor(int i=1;i<=10;++i) printf(\"|%d|\",max_fac[i]); puts(\"\");\n}\ninline int gcd(int x,int y){ \n\tif(x<y) swap(x,y);\n\tif(y==0) return x;\n\tif(x<=500) return g[x][y];\n\tint ret=1;\n\tfor(int i=0;i<3;++i){\n\t\tint d=1,k=sp[x][i];\n\t\tif(k<=500) d=g[k][y%k];\n\t\telse if(y%k==0) d=k;\n\t\tret*=d;\n\t\ty/=d;\n\t}\n\treturn ret;\n}\nint count_point(P<int> v){\n\treturn gcd(abs(v.x),abs(v.y));\n}\nbool check(P<int> x,P<int> y,P<int> z,int k){\n\treturn get_s(x,y,z)+2-count_point(y-x)-count_point(z-x)-count_point(z-y)<=k+k;\n}\nll solve(int n,int m,int k){\n\tll ans=0;\n\tfor(int i=1;i<n;++i){\n\t\tfor(int j=1;j<m;++j){\n\t\t\tP<int> x(i,0),y(0,j);\n\t\t\tif(get_s(x,y,P<int>(n,1))+2-count_point(y-x)-2*min(n,m)>k+k) \n\t\t\t\tbreak;\n\t\t\tfor(int d=1;d<m;++d){\n\t\t\t\tP<int> z(n,d);\n\t\t\t\tint key=get_s(x,y,z)+2-count_point(y-x);\n\t\t\t\tif(key-2*min(n,m)>k+k) break;\n\t\t\t\tif(key-count_point(z-x)-count_point(z-y)<=k+k)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"[%d %d %d %lld]\",n,m,k,ans);\n\treturn ans;\n}\nint main(){\n\tint n,m,k; scanf(\"%d%d%d\",&n,&m,&k);\n\tEuler(max(n,m)+1);\n\tll ans=2ll*(solve(n,m,k)+solve(m,n,k));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <chrono>\n#include <random>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <iomanip>\n#define dibs reserve\n#define OVER9000 1234567890\n#define tisic 47\n#define soclose 1e-8\n#define patkan 9\n#define ff first\n#define ss second\nusing uint = unsigned int;\nusing cat = long long;\nusing dbl = long double;\nconstexpr dbl pi = 3.14159265358979323846;\nusing namespace std;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ntemplate <typename T>\nT abs(T x) { return (x < 0) ? (-x) : x; }\n\nint gcd(int x, int y) {\n\tif(x > y) swap(x, y);\n\twhile(x) {\n\t\ty %= x;\n\t\tswap(x, y);\n\t}\n\treturn y;\n}\n\ncat solve_inner(int r, int c2, int W, int H, int K, auto & G) {\n\tint ret = 0;\n\tint C = 2*(K-1)+gcd(c2,r)-c2*(H-r);\n\tint c1 = 1, c1b = min(W-1, C/r);\n\tif(c1 <= c1b) {\n\t\tret += c1b-c1+1;\n\t\tc1 = c1b+1;\n\t}\n\twhile(c1 < W && c1*r <= C+2*H-r) {\n\t\tret += (c1*r <= C+gcd(c1,H-r)+G[abs(c1-c2)]);\n\t\tc1++;\n\t}\n\treturn ret;\n}\n\ncat solve(int W, int H, int K) {\n\tvector<int> G(W+1, 0);\n\tfor(int i = 0; i <= W; i++) G[i] = gcd(H, i);\n\tcat ret = 0;\n\tfor(int r = 1; r <= (H-1)/2; r++)\n\t\tfor(int c2 = 1; c2 < W && c2*(H-r) <= 2*(K-1+H); c2++)\n\t\t\tret += solve_inner(r, c2, W, H, K, G);\n\tret *= 2;\n\tif(H%2 == 0) {\n\t\tint r = H/2;\n\t\tfor(int c2 = 1; c2 < W && c2*(H-r) <= 2*(K-1+H); c2++)\n\t\t\tret += solve_inner(r, c2, W, H, K, G);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcout << fixed << setprecision(10);\n\tint W, H, K;\n\tcin >> W >> H >> K;\n\tcout << 2 * (solve(W, H, K) + solve(H, W, K)) << \"\\n\";\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n//binary gcd\nll gcd(ll _a, ll _b) {\n    ull a = abs(_a), b = abs(_b);\n    if (a == 0) return b;\n    if (b == 0) return a;\n    int shift = bsf(a|b);\n    a >>= bsf(a);\n    do {\n        b >>= bsf(b);\n        if (a > b) swap(a, b);\n        b -= a;\n    } while (b);\n    return (a << shift);\n}\n\n/// g:gcd(a, b), ax+by=g\nstruct EG { ll g, x, y; };\nEG ext_gcd(ll a, ll b) {\n    if (b == 0) {\n        if (a >= 0) return EG{a, 1, 0};\n        else return EG{-a, -1, 0};\n    } else {\n        auto e = ext_gcd(b, a % b);\n        return EG{e.g, e.y, e.x - a / b * e.y};\n    }\n}\n\n\nll inv_mod(ll x, ll md) {\n    auto z = ext_gcd(x, md).x;\n    return (z % md + md) % md;\n}\n\ntemplate<class T, class U>\nT pow_mod(T x, U n, T md) {\n    T r = 1 % md;\n    x %= md;\n    while (n) {\n        if (n & 1) r = (r * x) % md;\n        x = (x * x) % md;\n        n >>= 1;\n    }\n    return r;\n}\n\n// (rem, mod)\npair<ll, ll> crt(const V<ll>& b, const V<ll>& c) {\n    int n = int(b.size());\n    ll r = 0, m = 1;\n    for (int i = 0; i < n; i++) {\n        auto eg = ext_gcd(m, c[i]);\n        ll g = eg.g, im = eg.x;\n        if ((b[i] - r) % g) return {0, -1};\n        ll tmp = (b[i] - r) / g * im % (c[i] / g);\n        r += m * tmp;\n        m *= c[i] / g;\n    }\n    return {(r % m + m) % m, m};\n}\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nll S2(ll a, ll b, ll c, ll d) {\n    return a * d - b * c;\n}\nll check(ll s2, ll a, ll b, ll c, ll d, ll g_cd) {\n    ll i2 = s2 - (gcd(a, b) + g_cd + gcd(a - c, b - d)) + 2;\n    return i2 / 2;\n}\n\nll solve(ll w, ll h, ll n) {\n    ll s_pred = 2 * n + 3 * min(w, h);\n    ll ans = 0;\n    for (ll i = 1; i < w; i++) {\n        for (ll j = 1; j < h; j++) {\n            if (S2(w - i, 1, -i, j) > s_pred) break;\n            ll g_cd = gcd(-i, j);\n            for (ll k = 1; k < h; k++) {\n                // (i, 0), (w, k), (0, j)\n                ll s2 = S2(w - i, k, -i, j);\n                if (s2 > s_pred) break;\n                if (check(s2, w - i, k, -i, j, g_cd) <= n) ans++;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll w, h, k;\n    sc.read(w, h, k);\n\n    ll ans = 2 * solve(w, h, k) + 2 * solve(h, w, k);\n\n    pr.writeln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tll inf = -2 * h - w;\n\tll res1 = 0; ll res2 = 0;\n\tfor (ll x1 = 1; x1 < w; x1++) {\n\t\tif (x1*h < inf)continue;\n\t\tfor (ll x2 = x1; x2 < w; x2++) {\n\t\t\tfor (ll y = 1; y < h; y++) {\n\t\t\t\tll s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\tif (s < inf)break;\n\t\t\t\tif (s >= 0) {\n\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\telse res1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + gcd(x2 - x1, h);\n\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 2 * (res1 + 2 * res2);\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\ntemplate<class T> inline void dmin(T& x,T y){ y<x?x=y:0; }\ntemplate<class T> inline void dmax(T& x,T y){ y>x?x=y:0; }\ntemplate<class T> inline void dmin(T& x,vector<T> y){ \n\tfor(auto t:y) t<x?x=t:0;\n}\ntemplate<class T> inline void dmax(T& x,vector<T> y){\n\tfor(auto t:y) t>x?x=t:0;\n}\nld EPS=1e-10,PI=acos(-1);\ntemplate<class T> int sn(T x) { return x<-EPS?-1:(x>EPS); }\ntemplate<class T> struct P{ //represent a point, a vector, or a complex\n\tT x,y;\n\tP(T _x=T(),T _y=T()){ x=_x,y=_y; }\n\tinline P<T> operator!()const { return P<T>(x,-y); }\n\tinline P<T> operator+(const P<T>& b)const { return P<T>(x+b.x,y+b.y); }\n\tinline P<T> operator-(const P<T>& b)const { return P<T>(x-b.x,y-b.y); }\n\tinline P<T> operator*(const P<T>& b)const { return P<T>(x*b.x-y*b.y,x*b.y+y*b.x); }\n\tinline P<T> operator/(const T& t)const { return P<T>(x/t,y/t); }\n\tinline P<T> div2(const P<T>& b) const { return (*this)*(!b); }\n\tinline P<T> operator/(const P<T>& b)const { return div2(b)/b.dis2(); }\n\tinline T dis2()const { return x*x+y*y; }\n\tinline T dis()const { return sqrt(dis2()); }\n\tinline T cp(const P<T>& b)const { return x*b.y-y*b.x; }\n\tinline T dot(const P<T>& b)const { return x*b.x+y*b.y; }\n\tinline P<T> rot90()const { return P<T>(-y,x); }\n\tinline P<T> rot(const T& x)const { return (*this)*P<T>(cos(x),sin(x)); }\n\tinline int qua()const { return sn(y)>=0?(sn(x)>=0?1:2):(sn(x)>=0?4:3); }\n\tinline P<T> splay(const T& d)const{ return (*this)/dis()*d; }\n};\nll get_s(P<int> x,P<int> y,P<int> z){\n\tP<ll> x1(x.x,x.y),y1(y.x,y.y),z1(z.x,z.y);\n\treturn abs((y1-x1).cp(z1-x1));\n}\nconst int N=5+1e5;\nint max_fac[N],prime[N],g[1005][1005],top_prime=0,sp[N][3];\nbool vis[N];\nint gcd1(int x,int y){ return y?gcd1(y,x%y):x; }\ninline void Euler(int n){\n\tfor(int i=2;i<=n;++i) vis[i]=1;\n\tsp[1][0]=sp[1][1]=sp[1][2]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(vis[i]){\n\t\t\tprime[++top_prime]=i;\n\t\t\tmemcpy(sp[i],sp[1],sizeof(sp[i]));\n\t\t\tsp[i][0]=i;\n\t\t}\n\t\tfor(int j=1;j<=top_prime&&i*prime[j]<=n;++j){\n\t\t\tint k=i*prime[j];\n\t\t\tvis[k]=0;\n\t\t\tmemcpy(sp[k],sp[i],sizeof(sp[i]));\n\t\t\tif(sp[k][0]<sp[k][1]&&sp[k][0]<sp[k][2]) sp[k][0]*=prime[j];\n\t\t\telse if(sp[k][1]<sp[k][2]) sp[k][1]*=prime[j];\n\t\t\telse sp[k][2]*=prime[j];\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=0;i<=1000;++i)\n\t\tfor(int j=0;j<=1000;++j)\n\t\t\tg[i][j]=gcd1(i,j);\n//\tfor(int i=1;i<=10;++i)\n//\t\tprintf(\"|%d %d %d|\",sp[i][0],sp[i][1],sp[i][2]);\n//\texit(0);\n//\tfor(int i=1;i<=10;++i) printf(\"|%d|\",max_fac[i]); puts(\"\");\n}\ninline int gcd(int x,int y){ \n\tif(x<y) swap(x,y);\n\tif(y==0) return x;\n\tif(x<=1000) return g[x][y];\n\tint ret=1;\n\tfor(int i=0;i<3;++i){\n\t\tint d=1,k=sp[x][i];\n\t\tif(k<=1000) d=g[k][y%k];\n\t\telse if(y%k==0) d=k;\n\t\tret*=d;\n\t\ty/=d;\n\t}\n\treturn ret;\n}\nint count_point(P<int> v){\n\treturn gcd(abs(v.x),abs(v.y));\n}\nbool check(P<int> x,P<int> y,P<int> z,int k){\n\treturn get_s(x,y,z)+2-count_point(y-x)-count_point(z-x)-count_point(z-y)<=k+k;\n}\nint solve(int n,int m,int k){\n\tint ans=0;\n\tfor(int i=1;i<n;++i){\n\t\tfor(int j=1;j<m;++j){\n\t\t\tP<int> x(i,0),y(0,j);\n\t\t\tll sq=get_s(x,y,P<int>(n,1));\n\t\t\tif(sq+2-count_point(y-x)-2*min(n,m)>k+k) \n\t\t\t\tbreak;\n\t\t\tfor(int d=1;d<m;++d){\n\t\t\t\tP<int> z(n,d);\n\t\t\t\tll key=sq+2-count_point(y-x)-k-k;\n\t\t\t\tif(key-2*min(n,m)>0) break;\n\t\t\t\tif(key-count_point(z-x)-count_point(z-y)<=0)\n\t\t\t\t\tans++;\n\t\t\t\tsq+=i;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"[%d %d %d %lld]\",n,m,k,ans);\n\treturn ans;\n}\nint main(){\n\tint n,m,k; scanf(\"%d%d%d\",&n,&m,&k);\n\tEuler(max(n,m)+1);\n\tll ans=2ll*(solve(n,m,k)+solve(m,n,k));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll w, h, k;\n\tcin >> w >> h >> k;\n\tk = 2 * k - 2;\n\tll ans = 0;\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tfor (ll b = a; b < h; b++) {\n\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t}\n\t\t}\n\t}\n\tswap(w, h);\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) { \n\t\t\tif (a * i > k + 2 * w) break;\n\t\t\tfor (ll b = a; b < h; b++) {\n\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans += (b > a ? 2 : 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\t/*FOR(y,1,w)\n\t\tFOR(z,1,h)\n\t\t\tFor(x,1,z) if (1ll*y*z+1ll*x*(w-y)-__gcd(x,y)-__gcd(w-y,z)-__gcd(w,z-x)<=2*k-2){\n\t\t\t\tans++;\n\t\t\t\tprintf(\"%d %d %d %d\\n\",w,y,z,x);\n\t\t\t\tif (z!=x) ans++;\n\t\t\t}\n\treturn ans;*/\n\tFOR(y,1,w){\n\t\tFor(z,1,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),L=0,R=0,lim=2*k-2;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-2-tmp<=lim) L=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tl=1,r=z-1;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-y-min(z-mid,w)-tmp<=lim) R=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tint ret=2*L;\n\t\t\tFor(x,L+1,R) if (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\tret+=2;\n\t\t\t}\n\t\t\tans+=ret;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++>\nusing namespace std;\n\nint main()\n{\n  int W,H,K;\n  cin >> W >> H >> K;\n  W--;\n  H--;\n  \n  int count;\n  count = W *( H * (W + H + K) + W *(H + K) + H * K);\n  count += H *( W *(H + K) + H * K);\n  count += H * W * K;\n  \n  cout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint K;\nlong f(int W,int H)\n{\n\tlong ans=0;\n\tconst int LIM=2*K+W*2;\n\tfor(int x=1;x*2<=W;x++)\n\t{\n\t\tlong now=0;\n\t\tfor(int y2=1;y2<H&&(W-x)*y2<=LIM;y2++)\n\t\t{\n\t\t\tconst int LIM2=LIM-(W-x)*y2;\n\t\t\tint preb=gcd(x,y2);\n\t\t\tfor(int y1=1;y1<=y2&&x*y1<=LIM2;y1++)\n\t\t\t{\n\t\t\t\tint b=gcd(W-x,y1)+preb+gcd(W,y2-y1);\n\t\t\t\tint S=x*y1+(W-x)*y2;\n\t\t\t\tif(S-b+2<=2*K)\n\t\t\t\t{\n\t\t\t\t\tnow++;\n\t\t\t\t\tnow+=y1<y2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x*2<W)ans+=now*2;\n\t\telse ans+=now;\n\t}\n\treturn 2*ans;\n}\nmain()\n{\n\tint W,H;\n\tcin>>W>>H>>K;\n\tcout<<f(W,H)+f(H,W)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nll get(int H, int W, int K){\n\tint R = 2 * K - 2;\n\tll ret = 0;\n\tfor(int x = 1; x < H; x++){\n\t\tfor(int p = 1; p * x - 3 * max(H, W) <= R && p < W; p++){\n\t\t\tint b = __gcd(H - x, p);\n\t\t\tint r = R - p * x + b;\n\n\t\t\tint mx = max(0, r) / (H-x);\n\n\t\t\tret += min(mx, W - 1);\n\t\t\t\n\t\t\tfor(int q = mx + 1; q < W; q++){\n\t\t\t\tif(q * (H - x) > r + x + H) break;\n\t\t\t\tret += (q * (H - x) - __gcd(q, x) - __gcd(abs(p - q), H)) <= r;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint W, H, K; cin >> W >> H >> K;\n\tcout <<  2 * (get(H, W, K) + get(W, H, K)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll calc(ll n, ll m, ll a, ll b, ll c)\n{\n\treturn abs(b*(c-a)-m*(n-a))-(__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c));\n}\n\nll solve(ll n, ll m, ll k)\n{\n\tk*=2; ll ans=0; k-=2;\n\t/*\n\tfor(int j=1;j<m;j++)\n\t{\n\t\tcerr<<\"SOLVE \"<<j<<'\\n';\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tassert(calc(n,m,i,j,i)<=calc(n,m,i-1,j,i-1));\n\t\t\t//cerr<<calc(n,m,i,j,i)<<'\\n';\n\t\t}\n\t}\n\t*/\n\t/*\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll a=1;a<n;a++)\n\t\t{\n\t\t\tfor(ll c=a+1;c<n;c++)\n\t\t\t{\n\t\t\t\tif(calc(n,m,a,b,c)<calc(n,m,a,b,c+1))\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"FAIL \"<<a<<' '<<b<<' '<<c<<' '<<calc(n,m,a,b,c)<<' '<<calc(n,m,a,b,c+1)<<'\\n';\n\t\t\t\t}\n\t\t\t\t//assert(calc(n,m,a,b,c)>=calc(n,m,a,b,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tfor(ll b=1;b<m;b++)\n\t{\n\t\tfor(ll z=1;z<=min(n-1,ll(210000)/m);z++)\n\t\t{\n\t\t\tll a=n-z;\n\t\t\tll as=a+1;\n\t\t\tll lo=1; ll hi=a;\n\t\t\twhile(lo<=hi)\n\t\t\t{\n\t\t\t\tll mid=(lo+hi)>>1;\n\t\t\t\tif(calc(n,m,a,b,mid)<=k)\n\t\t\t\t{\n\t\t\t\t\tas=mid;\n\t\t\t\t\thi=mid-1;\n\t\t\t\t}\n\t\t\t\telse lo=mid+1;\n\t\t\t}\n\t\t\tfor(ll y=0;y<=min(a-1,ll(210000)/m);y++)\n\t\t\t{\n\t\t\t\tll c=a-y;\n\t\t\t\tif(c<as-500) break;\n\t\t\t\tif(calc(n,m,a,b,c)<=k) \n\t\t\t\t{\n\t\t\t\t\tif(y>0) ans+=2;\n\t\t\t\t\telse ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\t\t\t\n\t\t\t//a is the maxi\n\t\t\t//c<=a\n\t\t\tll as=a+1;\n\t\t\tll lo=1; ll hi=a;\n\t\t\twhile(lo<=hi)\n\t\t\t{\n\t\t\t\tll mid=(lo+hi)>>1;\n\t\t\t\tif(calc(n,m,a,b,mid)<=k)\n\t\t\t\t{\n\t\t\t\t\tas=mid;\n\t\t\t\t\thi=mid-1;\n\t\t\t\t}\n\t\t\t\telse lo=mid+1;\n\t\t\t}\n\t\t\tif(as==a+1) continue;\n\t\t\tans+=2*(a+1-as)-1;\n\t\t\t*/\n\t\t}\n\t}\n\t//cerr<<\"SOLVE \"<<n<<' '<<m<<'\\n';\n\t/*\n\tfor(ll a=1;a<n;a++)\n\t{\n\t\tfor(ll b=1;b<m;b++)\n\t\t{\n\t\t\tfor(ll c=1;c<n;c++)\n\t\t\t{\n\t\t\t\tll area = abs(b*(c-a)-m*(n-a));\n\t\t\t\tll boundary = 0;\n\t\t\t\tboundary+=__gcd(b,n-a)+__gcd(m,abs(c-a))+__gcd(m-b,n-c);\n\t\t\t\t//cerr<<a<<' '<<b<<' '<<c<<'\\n';\n\t\t\t\t//cerr<<area<<' '<<boundary<<' '<<area+2-boundary<<' '<<k<<'\\n';\n\t\t\t\tif(area-boundary<=k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m,k; cin>>n>>m>>k;\n\tcout<<2LL*(solve(n,m,k)+solve(m,n,k))<<'\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef complex<double> cd;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\n#define bugf(...) fprintf(stderr,__VA_ARGS__);\n#define bugs(x) cerr<<\"    \"<<(x);\n#define bugx(x) cerr<<\"    \"<<(#x)<<\" = \"<<(x);\n#define bugl cerr<<\"\\n\";\n#define bugL cerr<<\"\\n================================================\\n\";\n#define bugt bugx(clock());bugl;\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tint c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\ninline int abs(int a){return (a<0)?(-a):a;}\nint ans;\ninline void sol(int w,int h,int k){\n\t//bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tint a,b,c,A,C,B=k+h-2,D;\n\tREP(b,1,h){\n\t\tA=min(B/(h-b)+2,w);\n\t\tD=B;\n\t\tREP(a,1,A){\n\t\t\tC=min(D/b+2,w);\n\t\t\tREP(c,1,C)if(a*(h-b)+b*c+2<=k+gcd(a,b)+gcd(c,h-b)+gcd(abs(a-c),h))++ans;\n\t\t\tcmax(D-=h-b,0);\n\t\t}\n\t}\n}\ninline void ac(){\n\tint w,h,k,n,i;\n\tscanf(\"%d%d%d\",&w,&h,&k);k<<=1;\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%d\",ans<<1);\n}\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t\n\tac();\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nLL solve(int W, int H, int K) {\n    LL res = 0;\n    for (int y = 1; y < H; y++) {\n        for (int x1 = 1; x1 < W; x1++) {\n            if ((H-y)*x1 > 2*K + 2*H) break;\n            LL U = 2*K+1 - (H-y)*x1;\n            if (y*x1 <= U) {\n                res += 2*(x1-1) + 1;\n                continue;\n            }\n            int low = 1;\n            if (y <= U) {\n                low = U/y;\n                res += 2*(low-1);\n            }\n            for (int x2 = low; x2 <= x1; x2++) {\n                if (y*x2 > 2*K+2*H) break;\n                // if (y*x2 <= U) {\n                    // res += (x1 != x2)?2:1;\n                    // continue;\n                // }\n                LL c = (H-y)*x1 + y*x2 - (__gcd(x1, y) + __gcd(x2, H-y) + __gcd(H, x1-x2)) + 2;\n                // dbg(y, x1, x2, c, (H-y)*x1 + y*x2);\n                // dbg(__gcd(x1, y) + __gcd(x2, H-y) + __gcd(H, x1-x2));\n                if (c <= 2*K) res += (x1 != x2)?2:1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int W, H, K;\n    cin >> W >> H >> K;\n    LL ris1 = solve(W, H, K);\n    LL ris2 = solve(H, W, K);\n    cout << 2*(ris1+ris2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\n\nlint solve(int H, int W, int K)\n{\n    lint ret = 0;\n    REP(dh, H - 1)\n    {\n        FOR(w, 1, W)\n        {\n\n            lint R = 2 * K - 2 + gcd(W, dh) - 1LL * w * dh;\n            if (R < 0) break;\n\n            lint lo = min<lint>(R / W, H - 1 - dh); // hs <= lo なら必ず成立\n            lint hi = min<lint>((R + W * 2) / W, H - dh); // hs >= hi なら必ず不成立\n\n            lint ret_tmp = lo;\n            FOR(hs, lo + 1, hi)\n            {\n                lint x = hs * W - gcd(w, hs) - gcd<int>(W - w, hs + dh);\n                if (x <= R) ret_tmp++;\n            }\n            ret += ret_tmp * (1 + (dh != 0));\n        }\n    }\n    return ret * 2;\n}\n\nint main()\n{\n    int W, H, K;\n    cin >> W >> H >> K;\n    lint ret = solve(W, H, K) + solve(H, W, K);\n    cout << ret << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tvector<int> gcds(h + 1);\n\trep(i, h + 1)gcds[i] = gcd(i, h);\n\tif (w < h) {\n\t\tint inf = -3 * w;\n\t\tint res1 = 0; int res2 = 0;\n\t\tfor (int x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)break;\n\t\t\tfor (int x2 = x1; x2 < w; x2++) {\n\t\t\t\tint g = gcds[x2-x1];\n\t\t\t\tif (2 * k - 2 - x1 * h - (x2 - x1) < -g-2*w)break;\n\t\t\t\tfor (int y = 1; y < h; y++) {\n\t\t\t\t\tint s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + g;\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n\telse {\n\t\tint inf = -3*h;\n\t\tint res1 = 0; int res2 = 0;\n\t\tfor (int x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)break;\n\t\t\tfor (int y = 1; y < h; y++) {\n\t\t\t\tint g = gcd(x1, y);\n\t\t\t\tif (2 * k - 2 - x1 * h < -2 * h - g)break;\n\t\t\t\tfor (int x2 = x1; x2 < w; x2++) {\n\t\t\t\t\tint s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = g + gcd(h - y, x2) + gcds[x2 - x1];\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nstruct point_t {\n    int x, y;\n    point_t() : x(0), y(0) {}\n    point_t(int x, int y) : x(x), y(y) {}\n    point_t(const point_t& rhs) : x(rhs.x), y(rhs.y) {}\n    int operator < (const point_t& rhs) const {return make_pair(y, x) < make_pair(rhs.y, rhs.x);}\n    int operator == (const point_t& rhs) const {return make_pair(y, x) == make_pair(rhs.y, rhs.x);}\n    point_t operator - (const point_t& rhs) const {return point_t(x - rhs.x, y - rhs.y);}\n};\nlong long cross(point_t a, point_t b) {\n    return (long long) a.x * b.y - (long long) a.y * b.x;\n}\nlong long area(point_t a, point_t b, point_t c) {\n    return abs(cross(a, b) + cross(b, c) + cross(c, a));\n}\n\ninline int calc(int x, int y) {\n    return __gcd(abs(x), abs(y)) - 1;\n};\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 3e5; j++) {\n                point_t a(0, i);\n                point_t b(j, w);\n                long long s;\n                for (int k = 1; k < h && (s = area(a, b, point_t(k, 0))) <= 2 * d + 3e5; k++) {\n                    s -= calc(j, w - i);\n                    s -= f[abs(j - k)];\n                    s -= calc(k, i);\n                    s -= 3;\n                    s += 2;\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nmap<pair<int, int>, int> mem;\n\nint get(int x, int y) {\n    x = abs(x);\n    y = abs(y);\n    return gcd(x, y);\n//    typedef typename map<pair<int, int>, int>::mapped_type V;\n//    auto r = mem.insert({{x, y}, V()});\n//    V &v=r.first->second;\n//    if (r.second)\n//        v = gcd(x, y);\n//    return v;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    vector<int> mem(h + 1);\n    vector<int> t2(h + 1);\n    vector<int> mem2(h + 1);\n    for (long b = 1; b < w; b++) {\n        for (int c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            int mm = get(c, b);\n            for (int a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                long g = mm;\n                if (t2[a] != b) {\n                    t2[a] = b;\n                    mem2[a] = get(a, w - b);\n                }\n                g += mem2[a];\n                if (mem[a - c] == 0) {\n                    mem[a - c] = get(a - c, w);\n                }\n                g += mem[a - c];\n                if (s - g + 2 <= k * 2) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    auto start = std::chrono::high_resolution_clock::now();\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration<double> elapsed = finish - start;\n    cerr << elapsed.count() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt gcd(Int x, Int y)\n{\n    if (x == 0)\n        return y;\n    return gcd(y % x, x);\n}\n\nInt inside(Int x1, Int y1, Int x2, Int y2)\n{\n    Int s = abs(x1 * y2 - x2 * y1);\n    s += 2;\n    s -= gcd(abs(x1), abs(y1));\n    s -= gcd(abs(x2), abs(y2));\n    s -= gcd(abs(x2 - x1), abs(y2 - y1));\n    return s / 2;\n}\n\nInt cnt(Int w, Int h, Int k)\n{\n    Int ans = 0;\n    for (Int x = 1; x < w; x++) {\n        for (Int s = 0; s < h - 1; s++) {\n            if (inside(1, x, -s, w) > 2 * k)\n                break;\n            if (inside(1, x, -s, w) > k)\n                continue;\n            Int R = 2 * k - x * s - 2 + gcd(w, s);\n            Int bottom = max(1LL, R / w), top = min(h - s, R / w + 2);\n            bottom = min(bottom, top - 1);\n            while (top - bottom > 1) {\n                Int mid = (top + bottom) / 2;\n                if (inside(mid, x, -s, w) <= k)\n                    bottom = mid;\n                else\n                    top = mid;\n            }\n            if (s == 0)\n                ans += bottom;\n            else\n                ans += bottom * 2;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    Int w, h, k;\n    cin >> w >> h >> k;\n    cout << 2 * cnt(w, h, k) + 2 * cnt(h, w, k) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W,K;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>K;\n\tll ret=0;\n\tFOR(i,2) {\n\t\tfor(int s=0;s<=H-2;s++) {\n\t\t\tint R=2*K+__gcd(s,W)-2;\n\t\t\tll pat=0;\n\t\t\tfor(x=1;x<W;x++) {\n\t\t\t\tint R2=R-s*x;\n\t\t\t\tif(R2<0) break;\n\t\t\t\t\n\t\t\t\tint Ymi=R2/W;\n\t\t\t\t//if(Ymi) pat+=Ymi-1;\n\t\t\t\tfor(y=max(1,Ymi);y<=Ymi+2 && y+s<H;y++) {\n\t\t\t\t//for(y=1;y<=Ymi+2 && y+s<H;y++) {\n\t\t\t\t\tll v=1LL*W*y-__gcd(x,y)-__gcd(W-x,y+s);\n\t\t\t\t\tif(v<=R2) pat++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tret+=((s==0)?1:2)*pat;\n\t\t}\n\t\tswap(H,W);\n\t}\n\tcout<<2*ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=100005;\nint w,h,k;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nint solve(int w,int h)\n{\n\tint res=0;\n\tfor(int d=0;d<h;d++)\n\t\tfor(int a=1;a<w;a++)\n\t\t{\n\t\t\tint R=2*k-a*d+gcd(d,w)-2;\n\t\t\tif(R<0) break;\n\t\t\tint b=min(h-1-d,R/w);\n\t\t\tint tmp=b;\n\t\t\tb++;\n\t\t\tif(b+d<h&&1LL*w*b-gcd(w-a,b+d)-gcd(a,b)<=R) tmp++;\n\t\t\tif(d==0) res+=tmp;\n\t\t\telse res+=tmp*2;\n\t\t}\n\treturn res*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&w,&h,&k);\n\tprintf(\"%lld\",solve(w,h)+solve(h,w));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nlong gcd(long a, long b) {\n    while (b > 0) {\n        long c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nlong get(long x, long y) {\n    x = abs(x);\n    y = abs(y);\n    long d = gcd(x, y);\n    return d;\n}\n\nlong calc(long w, long h, long k) {\n    long res = 0;\n    for (long b = 1; b < w; b++) {\n        for (long c = 1; c < h && c * w <= 2 * (k + w); c++) {\n            for (long a = c; a < h && c * w + (a - c) * b <= 2 * (k + w); a++) {\n                long s = c * w + (a - c) * b;\n                if (s / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                long g = get(c, b);\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                g += get(a, w - b);\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n                g += get(a - c, w);\n                if ((s - g + 2) / 2 <= k) {\n                    res++;\n                    if (a != c) res++;\n                    continue;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int w, h, k;\n    cin >> w >> h >> k;\n    cout << (calc(w, h, k) + calc(h, w, k)) * 2;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nll F(int H,int W,int K){\n\tll ans=0;\n\tint LIM=2*K+1200;\n\tFor(k,1,W-1){\n\t\tint B=min(LIM/(W-k),H-1);\n\t\tFor(i,1,B){\n\t\t\tll key1=1ll*i*(W-k),key2=k;\n\t\t\tint b1=max(0ll,(2*K+1-key1)/key2);\n\t\t\tb1=min(b1,H-1); ans+=b1; key1+=(++b1)*key2;\n\t\t\tfor (;key1<=LIM&&b1<=H-1;key1+=key2,++b1){\n\t\t\t\tint cv=key1-gcd(W,abs(i-b1))-gcd(k,i)-gcd(W-k,b1);\n\t\t\t\tif (cv<=2*K-2) ans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2*ans;\n}\n/*\n300 100000 100000\n*/\nint main(){\n\tint W,H,K;\n\tscanf(\"%d%d%d\",&W,&H,&K);\n\tif (H>W) swap(H,W);\n\tcout<<F(W,H,K)+F(H,W,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll w, h, k;\n\tcin >> w >> h >> k;\n\tk = 2 * k - 2;\n\tll ans = 0;\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tfor (ll b = 1; b < h; b++) {\n\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\tswap(w, h);\n\tfor (ll i = 1; i < w; i++) {\n\t\tfor (ll a = 1; a < h; a++) {\n\t\t\tfor (ll b = 1; b < h; b++) {\n\t\t\t\tif (a * i + b * (w - i) > k + 2 * w) break;\n\t\t\t\tif (a * i + b * (w - i) - gcd(w - i, a) - gcd(i, b) - gcd(w, a - b) <= k) ans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans * 2 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n  int W,H,K;\n  cin >> W >> H >> K;\n  W--;\n  H--;\n  \n  int count;\n  count = W *( H * (W + H + K) + W *(H + K) + H * K);\n  count += H *( W *(H + K) + H * K);\n  count += H * W * K;\n  \n  cout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n  if(a==0 || b==0) return(a+b);\n  else if(a%b == 0) return(b);\n  else return(gcd(b, a%b));\n}\n\nint main(){\n  int W,H,K;\n  cin>>W>>H>>K;\n  long long cnt1=0;\n  long long cnt2=0;\n  \n\tfor(int i=0;i<W;i++){ //横の長さがW\n      for(int j=1;j<H;j++){\n        for(int k=0;k<j;k++){\n          long long X=gcd(W,k)+gcd(i,j)+gcd(W-i,j-k)-(2*W*j-(W*k+i*j+(W-i)*(j-k)));\n            if(X<=2*K+2){\n              cnt1++;\n            }\n        }\n      }\n    }\n\tfor(int i=0;i<H;i++){ //縦の長さがH  \n      for(int j=1;j<W;j++){\n        for(int k=0;k<j;k++){\n          long long X=gcd(k,H)+gcd(j,i)+gcd(j-k,H-i)-(2*j*H-(k*H+j*i+(j-k)*(H-i)));\n            if(X<=2*K+2){\n              cnt2++;\n            }\n        }\n      }\n    }\n//    long long X=gcd(a,b)+gcd(c,d)+gcd(e,f)-(2*max({a,c,e})*H-(a*b+c*d+e*f));\n//  if(X<=2*K+2) count++;\n  \n  cout<<cnt1<<\" \"<<cnt2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint a, b, n;\n\tcin >> a >> b >> n;\n\t\n\tif (a + b < n){cout << \" \";}\n\tif (a >= n && b >= n){cout << n + 1;}\n\tif (a < n && b >= n){cout << a + 1;}\n\tif (a >= n && b < n){cout << b + 1;}\n\tif (a < n && a < b && a + b >= n){cout << a + 1;}\n\tif (b < n && a > b && a + b >= n){cout << b + 1;}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\ninline int calc(int x, int y) {\n    return __gcd(abs(x), abs(y)) - 1;\n};\n\nvoid chemthan() {\n    int w, h, d; cin >> w >> h >> d;\n    int res = 0;\n    FOR(it, 0, 2) {\n        vi f(1e6);\n        FOR(i, 0, sz(f)) f[i] = __gcd(i, w) - 1;\n        FOR(i, 1, w) if (i + i <= w) {\n            for (int j = 1; j < h && i * j <= 2 * d + 3e5; j++) {\n                int tmp = calc(j, w - i);\n                int s;\n                for (int k = 1; k < h && (s = abs(j * i + (w - i) * k)) <= 2 * d + 3e5; k++) {\n                    if (s <= d + d) {\n                        res += 2;\n                        if (i + i == w) {\n                            res--;\n                        }\n                    }\n                    else {\n                        s -= tmp;\n                        s -= f[abs(j - k)];\n                        s -= calc(k, i);\n                        s -= 1;\n                        if (s <= d + d) {\n                            res += 2;\n                            if (i + i == w) {\n                                res--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        swap(w, h);\n    }\n    cout << res * 2 << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//#define GEOF\n\n#ifdef GEOF\nusing ld=long double;\n#else\nusing ld=ll;\n#endif\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-8;\n#ifdef GEOF\nconst ld PI=acos(ld(-1));\n#endif\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nld rabs(cm a){return max(abs(a.x),abs(a.y));}\nld signed_rabs(cm a){\n\tif(abs(a.x)>abs(a.y))return a.x;\n\telse return a.y;\n}\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nld crs(cm a,cm b,cm c){return crs(b-a,c-a);}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\nauto cmless=[](cm a,cm b){\n\tint s=sgn(a.x-b.x);\n\tif(s)return s<0;\n\telse return sgn(a.y-b.y)<0;\n};\nbool cmeq(cm a,cm b){\n\treturn sgn(a.x-b.x)==0&&sgn(a.y-b.y)==0;\n};\n//(-pi,0](0,pi]\nint argtype(cm a){\n\tif(sgn(a.y)==0)return a.x<0?1:0;\n\treturn a.y<0?0:1;\n}\nint argcmp(cm a,cm b){\n\tint at=argtype(a),bt=argtype(b);\n\tif(at!=bt)return at<bt?-1:1;\n\treturn -ccw(a,b);\n};\nbool argless(cm a,cm b){return argcmp(a,b)<0;}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n#ifdef GEOF\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n//AOJ2233\n//a->b->c と進むときに曲がる角度\n//a-b-cが一直線上にあれば0が帰る\nld turn(cm a,cm b,cm c){\n\treturn arg((c-b)/(b-a));\n}\n#endif\ncm rot90(cm a){\n\treturn cm(-a.y,a.x);\n}\n/*\n#ifndef GEOF\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ncm normdir(cm a){\n\tif(a==cm(0,0))return a;\n\tint g=gcd(abs(a.x),abs(a.y));\n\treturn cm(a.x/g,a.y/g);\n}\n#endif*/\nint gcd(int a,int b){\n\tdmp2(a,b);\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tint s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\tdmp((a<<s));\n\treturn a<<s;\n\t\n}\n\nint interior(cm a,cm b,cm c){\n\tint ans=abs(crs(a,b,c));\n\tdmp(ans);\n\tans-=gcd(a.x-b.x,a.y-b.y);\n\tdmp(ans);\n\tans-=gcd(b.x-c.x,b.y-c.y);\n\tdmp(ans);\n\tans-=gcd(c.x-a.x,c.y-a.y);\n\tdmp(ans);\n\tans+=2;\n\tdmp2(a,b,c,ans);\n\treturn ans/2;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint h,w,k;cin>>h>>w>>k;\n\tint ans=0;\n\trep(_,2){\n\t\trng(left,1,h){\n\t\t\tint seq=0;\n\t\t\trep(dif,w-1){\n\t\t\t\tint lw=0,up=w-dif;\n\t\t\t\twhile(up-lw>1){\n\t\t\t\t\tconst int mid=(lw+up)/2;\n\t\t\t\t\tif(interior(cm(0,left),cm(mid+dif,0),cm(mid,h))<=k)\n\t\t\t\t\t\tlw=mid;\n\t\t\t\t\telse\n\t\t\t\t\t\tup=mid;\n\t\t\t\t}\n\t\t\t\tif(lw==0&&left<h-100){\n\t\t\t\t\tseq++;\n\t\t\t\t\tif(seq==100)break;\n\t\t\t\t}\n\t\t\t\tans+=lw;\n\t\t\t\tif(dif>0)ans+=lw;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswap(h,w);\n\t}\n\tprint(ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, k;\nll work(int n, int m) {\n\tll ans = 0;\n\tfor (int i = 0; i <= n - 2; i++)\n\tfor (int j = 1; j <= m - 1 && i * j <= 2 * k + m; j++) {\n\t\tint tmp = 2 * k + __gcd(i, m) - i * j - 2;\n\t\tif (tmp >= 0) {\n\t\t\tint limit = min(n - 1 - i, tmp / m + 1);\n\t\t\tans += (limit - (m * limit - __gcd(limit, j) - __gcd(limit + i, m - j) > tmp)) * (1 + (i != 0));\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n), read(m), read(k);\n\tcout << work(n, m) * 2 + work(m, n) * 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005;\nint f[N],g[N];\nll solve(int w,int h,int k){\n\tll ans=0;\n\tFor(h2,1,h-1){\n\t\tint h1=h-h2,L=w-1,R=w-1,mx=0;\n\t\tFor(de,0,w-2){\n\t\t\tint gg=__gcd(h,de),sum=0;\n\t\t\twhile(L>1){\n\t\t\t\tint b=L,a=L+de;\n\t\t\t\tif(L>w-1-de||(a+b)*h-a*h1-b*h2-gg+2>2*k)L--; else break;\n\t\t\t}\n\t\t\twhile(R){\n\t\t\t\tint b=R,a=R+de;\n\t\t\t\tif(R>w-1-de||(a+b)*h-a*h1-b*h2-(h+gg)+2>2*k)R--; else break;\n\t\t\t}\n\t\t\t//R=min(R+1,w-1-de);\n\t\t\t//L=1; R=w-1-de;'\n\t\t\tif(L>R)break;\n\t\t\tFor(o,mx+1,R+de)f[o]=__gcd(o,h1);\n\t\t\tmx=max(mx,R+de);\n\t\t\tif(!de)For(o,1,R)g[o]=__gcd(o,h2);\n\t\t\tsum+=L-1;\n\t\t\tFor(b,L,R){\n\t\t\t\tint a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(f[a]+g[b]+gg)+2<=2*k){\n\t\t\t\t\t//assert(((a+b)*h-a*h1-b*h2-2*(h+gg)+2<=k));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(de)ans+=sum*2; else ans+=sum;\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint w=read(),h=read(),k=read();\n\tcout<<solve(w,h,k)+solve(h,w,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nint w,h,k;\ninline ll solve(int w,int h,int k){\n\tll ans=0;\n\t/*FOR(y,1,w)\n\t\tFOR(z,1,h)\n\t\t\tFor(x,1,z) if (1ll*y*z+1ll*x*(w-y)-__gcd(x,y)-__gcd(w-y,z)-__gcd(w,z-x)<=2*k-2){\n\t\t\t\tans++;\n\t\t\t\tprintf(\"%d %d %d %d\\n\",w,y,z,x);\n\t\t\t\tif (z!=x) ans++;\n\t\t\t}\n\treturn ans;*/\n\tll sum=0;\n\tFOR(y,1,w){\n\t\t++ans;\n\t\tFor(z,2,h-1){\n\t\t\tif (1ll*y*z+1ll*z*(w-y)-__gcd(z,y)-__gcd(w-y,z)-w<=2*k-2) ++ans;\n\t\t\tint l=1,r=z-1,tmp=__gcd(w-y,z),L=0,R=0,lim=2*k-2;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-2-tmp<=lim) L=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tl=1,r=z-1;\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=l+r>>1;\n\t\t\t\tif (1ll*y*z+1ll*(w-y)*mid-y-min(z-mid,w)-tmp<=lim) R=mid,l=mid+1;\n\t\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tif (R==0) break;\n\t\t\tsum+=R-L;\n\t\t\tint ret=2*L;\n\t\t\tFor(x,L+1,R) if (1ll*y*z+1ll*(w-y)*x-tmp-__gcd(x,y)-__gcd(w,z-x)<=lim){\n\t\t\t\tret+=2;\n\t\t\t}\n\t\t\tans+=ret;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tw=read(),h=read(),k=read();\n\tprintf(\"%lld\\n\",2*(solve(w,h,k)+solve(h,w,k)));\n}\n/*\n100000 100000 100000\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000009;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\n\nll calc(int w, int h,int k) {\n\tvector<int> gcds(w + 1);\n\trep(i, w + 1)gcds[i] = gcd(i, h);\n\tif (w < h) {\n\t\tint inf = -3 * w;\n\t\tint res1 = 0; int res2 = 0;\n\t\tfor (int x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)break;\n\t\t\tfor (int x2 = x1; x2 < w; x2++) {\n\t\t\t\tint g = gcds[x2-x1];\n\t\t\t\tif (2 * k - 2 - x1 * h - (x2 - x1) < -g-2*w)break;\n\t\t\t\tfor (int y = 1; y < h; y++) {\n\t\t\t\t\tint s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = gcd(x1, y) + gcd(h - y, x2) + g;\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n\telse {\n\t\tint inf = -3*h;\n\t\tint res1 = 0; int res2 = 0;\n\t\tfor (int x1 = 1; x1 < w; x1++) {\n\t\t\tif (2 * k - 2 - x1 * h < inf)break;\n\t\t\tfor (int y = 1; y < h; y++) {\n\t\t\t\tint g = gcd(x1, y);\n\t\t\t\tif (2 * k - 2 - x1 * h < -2 * h - g)break;\n\t\t\t\tfor (int x2 = x1; x2 < w; x2++) {\n\t\t\t\t\tint s = 2 * k - 2 - x1 * h - y * (x2 - x1);\n\t\t\t\t\tif (s < inf)break;\n\t\t\t\t\tif (s >= 0) {\n\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\telse res1++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = g + gcd(h - y, x2) + gcds[x2 - x1];\n\t\t\t\t\t\tif (s >= -ri) {\n\t\t\t\t\t\t\tif (x1 != x2)res2++;\n\t\t\t\t\t\t\telse res1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 2 * (res1 + 2 * res2);\n\t}\n}\nvoid solve() {\n\tint w, h, k; cin >> w >> h >> k;\n\tll ans = calc(w, h, k) + calc(h, w, k);\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    //cout << fixed << setprecision(6);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t;rep(i,t)\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define R register\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tint c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\nint ans;\ninline void sol(int w,int h,int k){\n\t//bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tR int a,b,c,A,C,B=k+h-2,D;\n\trep(b,1,h>>1){\n\t\tA=min(B/(h-b)+2,w);\n\t\tD=B;\n\t\tREP(a,1,A){\n\t\t\tC=min(D/b+2,w);\n\t\t\tREP(c,1,C)if(a*(h-b)+b*c+2<=k+gcd(a,b)+gcd(c,h-b)+gcd((a>c)?(a-c):(c-a),h)){\n\t\t\t\tif((b<<1)==h)++ans;\n\t\t\t\telse ans+=2;\n\t\t\t}\n\t\t\tcmax(D-=h-b,0);\n\t\t}\n\t}\n}\ninline void ac(){\n}\nint main(){\n\tint w,h,k,n,i;\n\tscanf(\"%d%d%d\",&w,&h,&k);k<<=1;\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%d\",ans<<1);\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\n \nconst ll INF = 2e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//↓,→,↑,←\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n    #undef endl\n#endif\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\n// const ll mod = 998244353ll;\nconst ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll mod){ll x=1;while(b){while(!(b&1)){(a*=a)%=mod;b>>=1;}(x*=a)%=mod;b--;}return x;}\nvoid YES(bool cond){ if(cond){ p(\"YES\");}else{ p(\"NO\");} return;}\nvoid Yes(bool cond){ if(cond){ p(\"Yes\");}else{ p(\"No\");} return;}\n\n/*\nll fact[fact_table + 5],rfact[fact_table + 5]; \n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table],mod - 2, mod);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n\nvoid init(){\n    struct timeval _time;\n    gettimeofday(&_time, NULL);\n    ll usec = _time.tv_usec * 1000000;\n    srand(usec);\n    return;\n}\n\nll range(ll a,ll b){\n    // generate random number [a, b]\n    // if b >= 10^8, this might not be precise\n    ll num = rand() % (1 + b - a) + a;\n    return num;\n}\n\nbool multicase = false;\nll mygcd(ll a, ll b){\n    if(b > a)swap(a, b);\n    if(b == 0 || a == b)return a;\n    return mygcd(b, a % b);\n}\n\nll calc(ll w, ll h, ll k){\n    ll ans = 0;\n    for(ll i1=1;i1<h;i1++){\n        for(ll i2=1;i2<h;i2++){\n            if(min(i1, i2) * w > 4 * k)break;\n            for(ll j=1;j<w;j++){\n                ll b = mygcd(i1, j) + mygcd(w - j, i2) + mygcd(w, abs(i1 - i2));\n                ll s = max(i1, i2) * w * 2;\n                s -= (i1 * j) + (w - j) * (i2) + (abs(i1 - i2) * w);\n                if(s - b + 2 <= 2 * k)ans ++;\n            }\n        }\n    }\n    return ans;\n}\nll n,m,num,a,b,c,d,e,h,q;\nvoid solve(){\n    ll w, k;\n    cin >> w >> h >> k;\n    ll ans = 0;\n    ans += calc(w, h, k) * 2;\n    ans += calc(h, w, k) * 2;\n    p(ans);\n    return;\n}\n\nint main(){\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll q, testcase = 1;\n    if(multicase){\n        cin >> q;\n    }else{\n        q = 1; \n    }\n    while(q--){\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n    // solve();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=500005,lim=100000;\nint p[N],flag[N],mu[N],A[N],B[N],nA,nB,W,H,K;\nll ans;\nvi d;\n\nvoid init(int n){\n\tint cnt=0;\n\tmu[1]=1;\n\trep(i,2,n){\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tflag[i*p[j]]=1;\n\t\t\tif(i%p[j]==0){\n\t\t\t\tmu[i*p[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i*p[j]]=-mu[i];\n\t\t}\n\t}\n}\n\nll calc(int W,int H,int K,int d){\n\tll ans=0;\n\tint tot=0;\n\trep(r,1,min(d,min(H,K+W))){\n\t\trep(x,1,W-1){\n\t\t\tnA=nB=0;\n\t\t\tfor(int i=r;i<H&&(ll)i*(W-x)<=K+W;i+=d){\n\t\t\t\tA[++nA]=i*(W-x)-__gcd(i,x);\n\t\t\t\tint p=nA;\n\t\t\t\twhile(p>=2&&A[p]<A[p-1]){\n\t\t\t\t\tswap(A[p],A[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=r;i<H&&(ll)i*x<=K+W;i+=d){\n\t\t\t\tB[++nB]=i*x-__gcd(i,W-x);\n\t\t\t\tint p=nB;\n\t\t\t\twhile(p>=2&&B[p]<B[p-1]){\n\t\t\t\t\tswap(B[p],B[p-1]);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p=nA;\n\t\t\trep(i,1,nB){\n\t\t\t\twhile(p&&A[p]+B[i]>K) p--;\n\t\t\t\tans+=p;\n\t\t\t}\n\t\t\ttot+=nA+nB;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int W,int H){\n\td.clear();\n\tfor(int i=1;i*i<=W;i++){\n\t\tif(W%i==0){\n\t\t\td.pb(i);\n\t\t\tif(i*i!=W) d.pb(W/i);\n\t\t}\n\t}\n\tfor(auto x:d){\n\t\tfor(auto y:d){\n\t\t\tif(y%x==0&&mu[y/x]){\n\t\t\t\tans+=mu[y/x]*calc(W,H,K+x,y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tread(W),read(H),read(K);\n\tK=K*2-2;\n\tinit(lim);\n\tsolve(W,H);\n\tsolve(H,W);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005;\nll solve(int w,int h,int k){\n\tll ans=0;\n\tFor(h2,1,h-1){\n\t\tint h1=h-h2;\n\t\tFor(de,0,w-2){\n\t\t\tint l=1,r=w-1-de,gg=__gcd(h,de),sum=0;\n\t\t\twhile(l<r){\n\t\t\t\tll b=((l+r)>>1)+1,a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-gg+2<=2*k)l=b; else r=b-1;\n\t\t\t}\n\t\t\tint L=l;\n\t\t\tl=0,r=w-1-de;\n\t\t\twhile(l<r){\n\t\t\t\tll b=((l+r)>>1)+1,a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(h+gg)+2<=2*k)l=b; else r=b-1;\n\t\t\t}\n\t\t\tint R=l;\n\t\t\t//R=min(R+1,w-1-de);\n\t\t\t//L=1; R=w-1-de;\n\t\t\tif(L>R)break;\n\t\t\tsum+=L-1;\n\t\t\tFor(b,L,R){\n\t\t\t\tint a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(__gcd(a,h1)+__gcd(b,h2)+gg)+2<=2*k){\n\t\t\t\t\t//assert(((a+b)*h-a*h1-b*h2-2*(h+gg)+2<=k));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(de)ans+=sum*2; else ans+=sum;\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint w=read(),h=read(),k=read();\n\tcout<<solve(w,h,k)+solve(h,w,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n// 10535724\nconst int B = 5;\n\nint gcd(int x, int y) {\n\tif (x < y) swap(x, y);\n\twhile(y > 0) {\n\t\tx %= y;\n\t\tswap(x, y);\n\t}\n\treturn x;\n}\nint inside(int y, int x1, int x2, int h) {\n\tint res = x1 * (h - y) + x2 * y + 2;\n\tres -= gcd(x2, h - y);\n\tres -= gcd(x1, y);\n\tres -= gcd(abs(x1 - x2), h);\n\tassert(res % 2 == 0);\n\treturn res / 2;\n}\nll solve(int y, int w, int h, int k) {\n\t//eprintf(\"solve %lld\\n\", y);\n\tll ans = 0;\n\tfor (int x = 1; x < w; x++) {\n\t\tif (x * y + h - y > 2 * k + 2 * h) break;\n\t\tint mx = (2 * k - x * y) / (h - y);\n\t\tmx = max(0, mx);\n\t\tans += mx;\n\t\tfor (int t = mx + 1; t <= mx + B; t++) {\n\t\t\tif (t <= 0 || t >= w) continue;\n\t\t\tans += inside(y, t, x, h) <= k;\n\t\t}\n\t}\n\treturn ans;\n}\nll solve(int w, int h, int k) {\n\tll ans = 0;\n\tfor (ll y = 1; 2 * y <= h; y++) {\n\t\tll cur = solve(y, w, h, k);\n\t\tif (2 * y != h) cur *= 2;\n\t\tans += cur;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tll ans = solve(w, h, k) + solve(h, w, k);\n\tprintf(\"%lld\\n\", ans * 2);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nLL solve(int w, int h, int k)\n{\n\tLL ret = 0;\n\tfor(int a = 1; a <= w - 1 && a * h <= 2 * k + 2 * h - 2; a ++)\n\trep1(x, h - 1) {\n\t\tint ub = 2 * k + __gcd(a, h - x) - 2 - a * x;\n\t\tfor(int b = a; b <= w - 1 && b * (h - x) <= ub + h + x; b ++) {\n\t\t\tif(b * (h - x) - __gcd(h, b - a) - __gcd(b, x) <= ub) ret += b == a ? 1 : 2;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint w, h, k;\n\tscanf(\"%d%d%d\", &w, &h, &k);\n\tprintf(\"%lld\\n\", 2 * solve(w, h, k) + 2 * solve(h, w, k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Triangles\n// Contest : AtCoder - Tokio Marine & Nichido Fire Insurance Programming Contest 2020\n// URL : https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_f\n// Memory Limit : 1024 MB\n// Time Limit : 4000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef complex<double> cd;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\n#define bugf(...) fprintf(stderr,__VA_ARGS__);\n#define bugs(x) cerr<<\"    \"<<(x);\n#define bugx(x) cerr<<\"    \"<<(#x)<<\" = \"<<(x);\n#define bugl cerr<<\"\\n\";\n#define bugL cerr<<\"\\n================================================\\n\";\n#define bugt bugx(clock());bugl;\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmax(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmin(IT &a,IT b){if(a>b){a=b;return true;}else return false;}\ninline int gcd(int a,int b){\n\tint c;\n\twhile(c=b){\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\treturn a;\n}\nll ans;\n\ninline void sol(int w,int h,int k){\n\t//bugL bugs(\"SOL\") bugx(w) bugx(h) bugl\n\tint x,s,y,r,b=((k-1)<<1)+w;\n\tREP(x,1,w)per(s,min(h-2,b/x),0){\n\t\t//bugx(x) bugx(s) bugl\n\t\tr=(k<<1)-(2+x*s)+gcd(w,s);\n\t\ty=r/w+1;\n\t\tif(y*w-gcd(x,y)-gcd(w-x,y+s)>r)--y;\n\t\tcmin(y,h-(s+1));\n\t\tans+=s?(y<<1):y;\n\t}\n}\ninline void ac(){\n\tint w,h,k;\n\tscanf(\"%d%d%d\",&w,&h,&k);\n\tsol(w,h,k);\n\tsol(h,w,k);\n\tprintf(\"%lld\",ans<<1);\n}\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t\n\tac();\n\treturn 0;\n}\n#undef pque\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef bugs\n#undef bugx\n#undef bugl"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=100005;\nll solve(int w,int h,int k){\n\tint ans=0;\n\tFor(h2,1,h-1){\n\t\tint h1=h-h2;\n\t\tFor(de,0,w-2){\n\t\t\tint l=1,r=w-1-de,gg=__gcd(h,de),sum=0;\n\t\t\twhile(l<r){\n\t\t\t\tll b=((l+r)>>1)+1,a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-gg+2<=2*k)l=b; else r=b-1;\n\t\t\t}\n\t\t\tint L=l;\n\t\t\tl=0,r=w-1-de;\n\t\t\twhile(l<r){\n\t\t\t\tll b=((l+r)>>1)+1,a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(h+gg)+2<=2*k)l=b; else r=b-1;\n\t\t\t}\n\t\t\tint R=l;\n\t\t\t//R=min(R+1,w-1-de);\n\t\t\t//L=1; R=w-1-de;\n\t\t\tif(L>R)break;\n\t\t\tsum+=L-1;\n\t\t\tFor(b,L,R){\n\t\t\t\tint a=b+de;\n\t\t\t\tif((a+b)*h-a*h1-b*h2-(__gcd(a,h1)+__gcd(b,h2)+gg)+2<=2*k){\n\t\t\t\t\t//assert(((a+b)*h-a*h1-b*h2-2*(h+gg)+2<=k));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(de)ans+=sum*2; else ans+=sum;\n\t\t}\n\t}\n\treturn ans*2;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint w=read(),h=read(),k=read();\n\tcout<<solve(w,h,k)+solve(h,w,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint n,m,k;\nlong long gcd(int x,int y)\n{\n\tif (y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid swap(long long &x,long long &y)\n{\n\tlong long t=x;x=y;y=t;\n}\nlong long calculate(int r,int c)\n{\n\tlong long total=0;\n\tint pnum=0; \n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>2*k-1+c*3) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t{\n\t\t\tint start=x+1;\n\t\t\tlong long s=2*k-1-(x*c-x*y-gcd(x,y));\n\t\t\tstart=s/y-1;\n\t\t\tif (start<=x) start=x+1;\n\t\t\tif (start>=r) start=r-1;\n\t\t\tif (r<=x+1) continue;\n\t\t\ttotal+=(start-x-1);\n\t\t//\tstart=x+1;\n\t\t\tfor (long long z=start;z<r;z++)\n\t\t\t{\n\t\t\t\tlong long p=z*y-gcd(c-y,z)-gcd(z-x,c);\n\t\t\t\tif (x*c+z*y-x*y>2*k-1+c*3) break;\n\t\t\t\tif (p<=s) total++;\n\t\t\t}\n\t\t\tpnum++;\n\t\t//\tprintf(\"%d\\n\",total);\n\t\t\tif (pnum==9)\n\t\t\t{\n\t\t\t\ttotal++;total--;\n\t\t\t}\n\t\t}\n\t}\n\ttotal*=2;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>2*k-1+c*3) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t{\n\t\t\tlong long z=x;\n\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\tif (p<=2*k-1) total++;\n\t\t}\n\t}\n\treturn total*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t//n++;m++;\n\tlong long ans=0;\n\tans=calculate(n,m);\n\tans=ans+calculate(m,n);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nlong long gcd(long long a, long long b){\n    return b?gcd(b,a%b):a;\n}\nlong long BB(long long a, long long b){\n    if(a<0)a=-a;\n    if(b<0)b=-b;\n    return gcd(a,b);\n}\nlong long Point(long long n, long long m, long long h1, long long h2, long long x){\n    return ((h1+h2)*m - h1*x - h2*(m-x) + 2 - BB(h1,x)-BB(h2,m-x)-BB(h1-h2,m))/2;\n}\nlong long Get(int n, int m, int K){\n    int i, j, kk;\n    long long res=0;\n    for(i=1;i<n;i++){\n        for(j=1;j<m;j++){\n            if(i*j>300000)break;\n            int bb = i, ee = n-1, r = i-1, mid;\n            while(bb<=ee){\n                mid = (bb+ee)>>1;\n                if(Point(n,m,i,mid,j)<=K){\n                    r = mid;\n                    bb=mid+1;\n                }\n                else ee=mid-1;\n            }\n            int s=0;\n            int M = max(10000/(i*j), 20);\n            for(kk=-M;kk<=M;kk++){\n                int yy = kk+r;\n                if(yy<=i || yy >= n)continue;\n                if(Point(n,m,i,yy,j)<=K)s++;\n            }\n            bb = max(r-M-1,i);\n            s += bb-i;\n            s*=2;\n            if(Point(n,m,i,i,j)<=K)s++;\n            res+=s;\n            //printf(\"%d %d %d\\n\",i,j,s);\n        }\n    }\n    return res*2;\n}\nint main(){\n    int n, m, K;\n    int i;\n    scanf(\"%d%d%d\",&n,&m,&K);\n    printf(\"%lld\\n\",Get(n,m,K)+Get(m,n,K));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint n,m,k;\nlong long gcd(int x,int y)\n{\n\tif (y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid swap(long long &x,long long &y)\n{\n\tlong long t=x;x=y;y=t;\n}\nlong long calculate(int r,int c)\n{\n\tlong long total=0;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>6*k) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t\tfor (long long z=x+1;z<r;z++)\n\t\t\t{\n\t\t\t//\tlong long x=x1,z=z1;\n\t\t\t//\tif (x>z) swap(x,z);\n\t\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\t\tif (p<=2*k-1) total++;\n\t\t\t}\n\t}\n\ttotal*=2;\n\tfor (long long x=1;x<r;x++)\n\t{\n\t\tif (x*c>6*k) break;\n\t\tfor (long long y=1;y<c;y++)\n\t\t{\n\t\t\tlong long z=x;\n\t\t\tlong long p=x*c+z*y-x*y-gcd(x,y)-gcd(c-y,z)-gcd(z-x,c);\n\t\t\tif (p<=2*k-1) total++;\n\t\t}\n\t}\n\treturn total*2;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\t//n++;m++;\n\tlong long ans=0;\n\tans=calculate(n,m);\n\tans=ans+calculate(m,n);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint dfrac(int x, int y) {\n  if (x < 0)return (x - y + 1) / y;\n  return x / y;\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n\n  function<int(int, int, int)> solve = [&](int n, int m, int k) {\n\n    vector<int> div(n + 1);\n    for (int i = 1; i <= n; ++i)\n      for (int j = i; j <= n; j += i)\n        ++div[j];\n\n    int ret = 0;\n    for (int i = 1; i < n; ++i) {\n      for (int d = 0; d < m - 1; ++d) {\n        int d1 = gcd(d, n);\n        int S2 = i * d;\n        // G = S - (d1 + d2 + d3)/2\n        int est = d1 + div[i] + div[n - i];\n        if (S2 - n * 2 + 1 > k * 2) break;\n        if (S2 - est + 1 > k * 2) continue;\n        int least = min(max(dfrac(k * 2 - S2 + est - 1, n) - 1, 0), m - 1 - d);\n        //int least = 0;\n        int con = 0;\n        con += least;\n        for (int j = least + 1; j * n + S2 - n * 2 + 1 <= k * 2 && j + d < m; ++j) {\n          int act = S2 + j * n - d1 - gcd(i, j) - gcd(n - i, j + d) + 1;\n          if (act <= k * 2)\n            ++con;\n        }\n        if (d == 0) ret += con;\n        else\n          ret += con * 2;\n      }\n    }\n    return ret;\n  };\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  cout << (solve(n, m, k) + solve(m, n, k)) * 2;\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy waxberry!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 5005 /*rem*/\n#define mod 1000000007\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nint s;\nint u, v;\nint gcd(int a, int b) {\n\treturn __gcd(a, b);\n} \nll ans = 0;\nbool chk(int a, int b, int x, int y, int q) {\n\tll f = a * y + b * x - q - gcd(b, y) - gcd(abs(a - b), u);\n\tif (f <= s) return 1;\n\treturn 0;\n}\nvoid work() {\n\tint rb = s + 3 * u + 1;\n\tfor (int y = u - 1; u - y <= y; y--)\n\t\tfor (int a = 1; a < v; a++) {\n\t\t\tif (y * a > rb) break;\n\t\t\tint rd = 2;\n\t\t\tif (u - y == y) rd = 1;\n\t\t\t\n\t\t\tint x = u - y;\n\t\t\tint eb = (s - y * a) / x;\n\t\t\tint st = 1;\n\t\t\tint ng = gcd(a, x);\n\t\t\tif (eb > 0) {\n\t\t\t\teb = min(eb, v - 1);\n\t\t\t\tst = eb + 1;\n\t\t\t\tans += eb * rd;\n\t\t\t}\n\t\t\twhile (st < v) {\n\t\t\t\tif (x * st + a * y > rb) break;\n\t\t\t\tif (chk(a, st, x, y, ng)) ans += rd;\n\t\t\t\tst++;\n\t\t\t}\n\t\t}\n}\nint main() {\n\tint w, h, k;\n\tcin >> w >> h >> k;\n\ts = 2 * (k - 1);\n\tu = w, v = h, work();\n\tu = h, v = w, work();\n\tans *= 2;\n\tcout << ans << endl;\n\treturn 0;\n}\n/*\n100000 100000 100000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint dfrac(int x, int y) {\n  if (x < 0)return (x - y + 1) / y;\n  return x / y;\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n\n  function<int(int, int, int)> solve = [&](int n, int m, int k) {\n\n    vector<int> div(n + 1);\n    for (int i = 1; i <= n; ++i)\n      for (int j = i; j <= n; j += i)\n        ++div[j];\n\n    int ret = 0;\n    for (int i = 1; i < n; ++i) {\n      for (int d = 0; d < m - 1; ++d) {\n        int d1 = gcd(d, n);\n        ll S2 = i * (ll)d;\n        // G = S - (d1 + d2 + d3)/2\n        int est = d1 + div[i] + div[n - i];\n        if (S2 - n * 2 + 1 > k * 2) break;\n        if (S2 - est + 1 > k * 2) continue;\n        int least = min(max(dfrac(k * 2 - S2 + est - 1, n) - 1, 0), m - 1 - d);\n        int con = 0;\n        con += least;\n        for (int j = least + 1; j * 2 + S2 <= k * 2 && j + d < m; ++j) {\n          int act = S2 + j * n - d1 - gcd(i, j) - gcd(n - i, j + d) + 1;\n          if (act <= k * 2)\n            ++con;\n        }\n        if (d == 0) ret += con;\n        else\n          ret += con * 2;\n      }\n    }\n    return ret;\n  };\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  cout << (solve(n, m, k) + solve(m, n, k)) * 2;\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint gcd(int a, int b)\n{\n\tif (a > b) {\n\t\ta ^= b;\n\t\tb ^= a;\n\t\ta ^= b;\n\t}\n\tif (a == 0) return b;\n\telse return gcd(b % a, a);\n}\n\nlong long solve(int W, int H, int K)\n{\n\tlong long i, j, k, l[2], r[2], ans = 0;\n\tfor (k = 1; k <= (H - 1) / 2; k++) {\n\t\tl[0] = (K * 2 - k * (W + 1)) / (H - k);\n\t\tr[0] = ((K + H) * 2 - k + H - k - 1) / (H - k);\n\t\tif (l[0] < 1) l[0] = 1;\n\t\telse if (l[0] >= W) {\n\t\t\tans += (long long)(W - 1) * (W - 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (r[0] <= 1) break;\n\t\telse if (r[0] > W) r[0] = W;\n\t\tans += (long long)(l[0] - 1) * (W - 1);\n\t\t\n\t\tfor (i = l[0]; i < r[0]; i++) {\n\t\t\tl[1] = (K * 2 - (H - k) * i + k - 1) / k;\n\t\t\tr[1] = ((K + H) * 2 - (H - k) * i + k - 1) / k;\n\t\t\tif (l[1] < 1) l[1] = 1;\n\t\t\telse if (l[1] >= W) {\n\t\t\t\tans += W - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r[1] <= 1) break;\n\t\t\telse if (r[1] > W) r[1] = W;\n\t\t\tans += l[1] - 1;\n\t\t\tfor (j = l[1]; j < r[1]; j++) if (j * k + i * (H - k) - gcd(i, k) - gcd(j, H - k) - gcd(abs(i - j), H) < K * 2) ans++;\n\t\t}\n\t}\n\tfor (k = 1; k <= (W - 1) / 2; k++) {\n\t\tl[0] = (K * 2 - k * (H + 1)) / (W - k);\n\t\tr[0] = ((K + W) * 2 - k + W - k - 1) / (W - k);\n\t\tif (l[0] < 1) l[0] = 1;\n\t\telse if (l[0] >= H) {\n\t\t\tans += (long long)(H - 1) * (H - 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (r[0] <= 1) break;\n\t\telse if (r[0] > H) r[0] = H;\n\t\tans += (long long)(l[0] - 1) * (H - 1);\n\t\t\n\t\tfor (i = l[0]; i < r[0]; i++) {\n\t\t\tl[1] = (K * 2 - (W - k) * i + k - 1) / k;\n\t\t\tr[1] = ((K + W) * 2 - (W - k) * i + k - 1) / k;\n\t\t\tif (l[1] < 1) l[1] = 1;\n\t\t\telse if (l[1] >= H) {\n\t\t\t\tans += H - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r[1] <= 1) break;\n\t\t\telse if (r[1] > H) r[1] = H;\n\t\t\tans += l[1] - 1;\n\t\t\tfor (j = l[1]; j < r[1]; j++) if (j * k + i * (W - k) - gcd(i, k) - gcd(j, W - k) - gcd(abs(i - j), W) < K * 2) ans++;\n\t\t}\n\t}\n\tans *= 2;\n\t\n\tif (H % 2 == 0) {\n\t\tk = H / 2;\n\t\tfor (i = 1; i < W; i++) {\n\t\t\tl[1] = (K * 2 - (H - k) * i + k - 1) / k;\n\t\t\tr[1] = ((K + H) * 2 - (H - k) * i + k - 1) / k;\n\t\t\tif (l[1] < 1) l[1] = 1;\n\t\t\telse if (l[1] >= W) {\n\t\t\t\tans += W - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r[1] <= 1) break;\n\t\t\telse if (r[1] > W) r[1] = W;\n\t\t\tans += l[1] - 1;\n\t\t\tfor (j = l[1]; j < r[1]; j++) if (j * k + i * (H - k) - gcd(i, k) - gcd(j, H - k) - gcd(abs(i - j), H) < K * 2) ans++;\n\t\t}\n\t}\n\tif (W % 2 == 0) {\n\t\tk = W / 2;\n\t\tfor (i = 1; i < H; i++) {\n\t\t\tl[1] = (K * 2 - (W - k) * i + k - 1) / k;\n\t\t\tr[1] = ((K + W) * 2 - (W - k) * i + k - 1) / k;\n\t\t\tif (l[1] < 1) l[1] = 1;\n\t\t\telse if (l[1] >= H) {\n\t\t\t\tans += H - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r[1] <= 1) break;\n\t\t\telse if (r[1] > H) r[1] = H;\n\t\t\tans += l[1] - 1;\n\t\t\tfor (j = l[1]; j < r[1]; j++) if (j * k + i * (W - k) - gcd(i, k) - gcd(j, W - k) - gcd(abs(i - j), W) < K * 2) ans++;\n\t\t}\n\t}\n\t\n\treturn ans * 2;\n}\n\nint main()\n{\n\tint W, H, K;\n\tscanf(\"%d %d %d\", &W, &H, &K);\n\tprintf(\"%lld\\n\", solve(W, H, K));\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//F - Triangles\n//Hiia\n//Tabunn TLE\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n  long long w,h,k,i_b,i_r,i_o,x,y,num0,numnum,numnum1=0,numnum2=0; //b:bottom, r:right, o:other\n  long long /*double*/ y12,y13,y23;\n  scanf(\"%lld%lld%lld\", &w,&h,&k);\n\n  for(i_b=1;i_b<w;i_b++){ //(i_b,0),(w,i_r),(0,i_o)\n    for(i_r=1;i_r<h;i_r++){\n      for(i_o=1;i_o<h;i_o++){\n                        num0=0;\n                        for(x=1;x<w;x++){\n                          for(y=1;y<h;y++){\n                            y12=(i_r-0)*(x-i_b);             //y12=0+(i_r-0)*(x-i_b)/(w-i_b);\n                            y13=(i_o-0)*(x-i_b);             //y13=0+(i_o-0)*(x-i_b)/(0-i_b);\n                            y23=i_r*(0-w)+(i_o-i_r)*(x-w);   //y23=i_r+(i_o-i_r)*(x-w)/(0-w);\n                            if(y*(w-i_b)>y12 && y*(0-i_b)<y13 && y*(0-w)>y23){  //y>y12, y>y13, y<y23\n                              num0++;\n                            }\n                          }\n                        }\n                        if(num0<=k){\n                          numnum1++;\n                        }\n      }\n    }\n  }\n\n\n  for(i_r=1;i_r<h;i_r++){ //(i_b,0),(w,i_r),(0,i_o)->(i_r,0),(h,i_b),(0,i_o)   h<-->w(i_b<-->i_r), i_o<h -> i_o<w\n    for(i_b=1;i_b<w;i_b++){\n      for(i_o=1;i_o<w;i_o++){\n                        num0=0;\n                        for(x=1;x<h;x++){\n                          for(y=1;y<w;y++){\n                            y12=(i_b-0)*(x-i_r);             //y12=0+(i_r-0)*(x-i_b)/(w-i_b); y12=0+(i_b-0)*(x-i_r)/(h-i_r);\n                            y13=(i_o-0)*(x-i_r);             //y13=0+(i_o-0)*(x-i_b)/(0-i_b); y13=0+(i_o-0)*(x-i_r)/(0-i_r);\n                            y23=i_b*(0-h)+(i_o-i_b)*(x-h);   //y23=i_r+(i_o-i_r)*(x-w)/(0-w); y23=i_b+(i_o-i_b)*(x-h)/(0-h);\n                            if(y*(h-i_r)>y12 && y*(0-i_r)<y13 && y*(0-h)>y23){  //y>y12, y>y13, y<y23\n                              num0++;\n                            }\n                          }\n                        }\n                        if(num0<=k){\n                          numnum2++;\n                        }\n      }\n    }\n  }\n/* Nannkachigauyo\n  for(i_b=1;i_b<w;i_b++){ //(i_b,0),(w,i_r),(i_o,h)\n    for(i_r=1;i_r<h;i_r++){\n      for(i_o=1;i_o<w;i_o++){\n                            num0=0;\n                            y12=(i_r-0)*(x-i_b);            //y12=0+(i_r-0)*(x-i_b)/(w-i_b);\n                            y13=(h-0)*(x-i_b);              //y13=0+(h-0)*(x-i_b)/(i_o-i_b);\n                            y23=i_r*(i_o-w)+(h-i_r)*(x-w);  //y23=i_r+(h-i_r)*(x-w)/(i_o-w);\n                            if(i_b==i_o){\n                              for(x=1;x<w;x++){\n                                for(y=1;y<h;y++){\n                                  if(y*(w-i_b)>y12 && x>i_b && y*(i_o-w)>y23){  //y>y12, x>i_b, y<y23\n                                    num0++;\n                                  }\n                                }\n                              }\n                            }\n                            if(i_o<i_b){\n                              for(x=1;x<w;x++){\n                                for(y=1;y<h;y++){\n                                  if(y*(w-i_b)>y12 && y*(i_o-i_b)<y13 && y*(i_o-w)>y23){  //y>y12, y>y13, y<y23\n                                    num0++;\n                                  }\n                                }\n                              }\n                            }\n                            if(i_o>i_b){\n                              for(x=1;x<w;x++){\n                                for(y=1;y<h;y++){\n                                  if(y*(w-i_b)>y12 && y*(i_o-i_b)<y13 && y*(i_o-w)>y23){  //y>y12, y<y13, y<y23\n                                    num0++;\n                                  }\n                                }\n                              }\n                            }\n                            if(num0<=k){\n                              numnum2++;\n                            }\n      }\n    }\n  }\n*/\n  numnum=2*(numnum1+numnum2);\n  printf(\"%lld\\n\", numnum);\n\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Point implements Comparable<Point> {\n  final long x, y;\n\n  Point(long x, long y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public int compareTo(Point point) {\n    if (this.x != point.x) {\n      return Long.compare(this.x, point.x);\n    }\n    return Long.compare(this.y, point.y);\n  }\n\n  public String toString() {\n    return String.format(\"(%d, %d)\", x, y);\n  }\n}\n\nclass NaiveSolver {\n  final int w, h, k;\n\n  NaiveSolver(int w, int h, int k) {\n    this.w = w;\n    this.h = h;\n    this.k = k;\n  }\n\n  private static long gcdRec(long a, long b) {\n    return a % b == 0 ? b : gcd(b, a % b);\n  }\n\n  private static long gcd(long a, long b) {\n    long absA = Math.abs(a);\n    long absB = Math.abs(b);\n    if (absA == 0 || absB == 0) {\n      return absA + absB;\n    }\n    return gcdRec(absA, absB);\n  }\n\n  private boolean accept(long x1, long y1, long x2, long y2, long x3, long y3) {\n    long dx2 = x2 - x1;\n    long dy2 = y2 - y1;\n    long dx3 = x3 - x1;\n    long dy3 = y3 - y1;\n    long sDouble = Math.abs(dx2 * dy3 - dx3 * dy2);\n    long g1 = gcd(x1 - x2, y1 - y2);\n    long g2 = gcd(x2 - x3, y2 - y3);\n    long g3 = gcd(x3 - x1, y3 - y1);\n    long g = g1 + g2 + g3;\n    return sDouble - g + 2 <= 2 * k;\n  }\n\n  public long solve() {\n    long answer = 0;\n    for (long x1 = 1; x1 < w; x1++) {\n      for (long y1 = 1; y1 < h; y1++) {\n        for (long x2 = 1; x2 < w; x2++) {\n          //(x1, 0), (0, y1), (x2, h)\n          //(x1, 0), (w, y1), (x2, h)\n          if (accept(x1, 0, 0, y1, x2, h)) {\n            answer++;\n          }\n          if (accept(x1, 0, w, y1, x2, h)) {\n            answer++;\n          }\n        }\n        for (long y2 = 1; y2 < h; y2++) {\n          //(x1, 0), (0, y1), (w, y2)\n          //(x1, h), (0, y1), (w, y2)\n          if (accept(x1, 0, 0, y1, w, y2)) {\n            answer++;\n          }\n          if (accept(x1, h, 0, y1, w, y2)) {\n            answer++;\n          }\n        }\n      }\n    }\n    return answer;\n  }\n\n  private void addAnswer(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    List<Point> list = List.of(new Point(x1, y1), new Point(x2, y2), new Point(x3, y3));\n    List<Point> sortedList = new ArrayList<>();\n    sortedList.addAll(list);\n    Collections.sort(sortedList);\n    answers.add(sortedList);\n  }\n\n  public List<List<Point>> solveList() {\n    List<List<Point>> answers = new ArrayList<>();\n    for (long x1 = 1; x1 < w; x1++) {\n      for (long y1 = 1; y1 < h; y1++) {\n        for (long x2 = 1; x2 < w; x2++) {\n          //(x1, 0), (0, y1), (x2, h)\n          //(x1, 0), (w, y1), (x2, h)\n          if (accept(x1, 0, 0, y1, x2, h)) {\n            addAnswer(answers, x1, 0L, 0L, y1, x2, (long)h);\n          }\n          if (accept(x1, 0, w, y1, x2, h)) {\n            addAnswer(answers, x1, 0L, (long)w, y1, x2, (long)h);\n          }\n        }\n        for (long y2 = 1; y2 < h; y2++) {\n          //(x1, 0), (0, y1), (w, y2)\n          //(x1, h), (0, y1), (w, y2)\n          if (accept(x1, 0, 0, y1, w, y2)) {\n            addAnswer(answers, x1, 0L, 0L, y1, (long)w, y2);\n          }\n          if (accept(x1, h, 0, y1, w, y2)) {\n            addAnswer(answers, x1, (long)h, 0L, y1, (long)w, y2);\n          }\n        }\n      }\n    }\n    Collections.sort(answers, new Comparator<List<Point>>(){\n      public int compare(List<Point> l1, List<Point> l2) {\n        for (int i = 0; i < l1.size(); i++) {\n          int result = l1.get(i).compareTo(l2.get(i));\n          if (result != 0) {\n            return result;\n          }\n        }\n        return 0;\n      }\n    });\n    return answers;\n  }\n}\n\nclass SubSolver {\n  final int w, h, k;\n  final boolean rotate;\n\n  SubSolver(int w, int h, int k, boolean rotate) {\n    this.w = w;\n    this.h = h;\n    this.k = k;\n    this.rotate = rotate;\n  }\n\n  private static long gcd(long a, long b) {\n    if (a == 0 || b == 0) {\n      return a + b;\n    }\n    return a % b == 0 ? b : gcd(b, a % b);\n  }\n\n  // P1: (x, 0)\n  // P2: (0, y)\n  // P3: (w, y + s)\n  // (0 < x < w),\n  // (0 < y < h)\n  // (0 <= s < h - 1)\n  // TriangleArea = NumLatticeInside + NumLatticeBoundary / 2 - 1\n  // NumLatticeInside = TriangleArea - NumLatticeBoundary / 2 + 1\n  // NumLatticeInside <= k\n  // TriangleArea - NumLatticeBoundary / 2 + 1 <= k\n  // 2 * TriangleArea - NumLatticeBoundary + 2 <= 2k\n  // TriangleArea\n  // = (y + y + s) * w / 2 - x * y / 2 - (w - x) * (y + s) / 2\n  // = yw + sw/2 - xy/2 - wy/2 - ws/2 + xy/2 + xs/2\n  // = yw/2 + xs/2\n  // NumLatticeBoundary\n  // = gcd(s, w) + gcd(x, y) + gcd(w - x, y + s)\n  // 2 * (yw / 2 + xs/2) - gcd(s, w) - gcd(x, y) - gcd(w - x, y + s) + 2 <= 2k\n  // wy - gcd(x, y) - gcd(w - x, y + s) <= 2k + gcd(s, w) - xs - 2\n  // 2k + gcd(s, w) - xs - 2 >= 0\n  // sx <= 2k + gcd(s, w) - 2 <= 2k + w - 2\n  public long solve() {\n    long answer = 0;\n    // s == 0\n    for (long x = 1; x < w; x++) {\n      answer += solve(0, x);\n    }\n\n    for (long s = 1; s < h - 1; s++) {\n      long gcdSw = gcd(s, w);\n      for (long x = 1; x < w && s * x <= 2 * k + gcdSw - 2; x++) {\n        answer += 2 * solve(s, x);\n      }\n    }\n\n    return answer;\n  }\n\n  private long solve(long s, long x) {\n    long r = 2 * k + gcd(s, w) - s * x - 2;\n    // y + s < h\n    // y < h - s\n    // y <= h - s - 1\n    long answer = Math.min(r / w, h - s - 1);\n    boolean a = false;\n    if (accept(s, x, r, r / w + 1)) {\n      a = true;\n      answer++;\n    }\n//    System.err.printf(\"%d %d %s %d\\n\", s, x, a, answer);\n    return answer;\n  }\n\n  private boolean accept(long s, long x, long r, long y) {\n    return y + s < h && w * y - gcd(x, y) - gcd(w - x, y + s) <= r;\n  }\n\n  public List<List<Point>> solveList() {\n    List<List<Point>> answers = new ArrayList<>();\n    // s == 0\n    for (long x = 1; x < w; x++) {\n      answers.addAll(solveList(0, x));\n    }\n\n    for (long s = 1; s < h - 1; s++) {\n      long gcdSw = gcd(s, w);\n      for (long x = 1; x < w && s * x <= 2 * k + gcdSw - 2; x++) {\n        answers.addAll(solveList(s, x));\n      }\n    }\n\n    return answers;\n  }\n\n  private List<List<Point>> solveList(long s, long x) {\n    List<List<Point>> answers = new ArrayList<>();\n\n    long r = 2 * k + gcd(s, w) - s * x - 2;\n    /*\n    long answer = r / w;\n    boolean a = false;\n    if (accept(s, x, r, r / w + 1)) {\n      a = true;\n      answer++;\n    }\n    System.err.printf(\"%d %d %s %d\\n\", s, x, a, answer);\n    */\n    for (int y = 1; y <= r / w && y + s < h; y++) {\n      addAnswer(answers, s, x, y);\n    }\n    if (accept(s, x, r, r / w + 1)) {\n      addAnswer(answers, s, x, r / w + 1);\n    }\n    return answers;\n  }\n\n  private void addAnswer(List<List<Point>> answers, long s, long x, long y) {\n    if (y + s < 0 || y + s > h) {\n      System.err.printf(\"%d %d %d\\n\", s, x, y);\n      throw new RuntimeException();\n    }\n    {\n      addAnswer1(answers, x,     0, 0, y, w, y + s);\n    }\n    if (s != 0) {\n      addAnswer1(answers, w - x, 0, w, y, 0, y + s);\n    }   \n  }\n\n  private void addAnswer1(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    if (y3 < 0 || y3 > h) {\n      System.err.printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n      throw new RuntimeException();\n    }\n    addAnswer2(answers, x1, y1, x2, y2, x3, y3);\n    addAnswer2(answers, x1, h - y1, x2, h - y2, x3, h - y3);\n  }\n\n  private void addAnswer2(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    if (x1 < 0 || x2 < 0 || x3 < 0 || y1 < 0 || y2 < 0 || y3 < 0) {\n      System.err.printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n      throw new RuntimeException();\n    }\n    if (!rotate) {\n      addAnswer3(answers, x1, y1, x2, y2, x3, y3);\n    } else {\n      addAnswer3(answers, y1, x1, y2, x2, y3, x3);\n    }\n  }\n\n  private void addAnswer3(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    if (x1 < 0 || x2 < 0 || x3 < 0 || y1 < 0 || y2 < 0 || y3 < 0) {\n      System.err.printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n      throw new RuntimeException();\n    }\n    List<Point> list = List.of(new Point(x1, y1), new Point(x2, y2), new Point(x3, y3));\n    List<Point> sortedList = new ArrayList<>();\n    sortedList.addAll(list);\n    Collections.sort(sortedList);\n    answers.add(sortedList);\n  }\n}\n\nclass Solver {\n  final int w, h, k;\n\n  Solver(int w, int h, int k) {\n    this.w = w;\n    this.h = h;\n    this.k = k;\n  }\n\n  public long solve() {\n    SubSolver subSolver1 = new SubSolver(w, h, k, false);\n    SubSolver subSolver2 = new SubSolver(h, w, k, true);\n    long answer1 = subSolver1.solve();\n    long answer2 = subSolver2.solve();\n    return 2 * (answer1 + answer2);\n  }\n\n  public List<List<Point>> solveList() {\n    SubSolver subSolver1 = new SubSolver(w, h, k, false);\n    SubSolver subSolver2 = new SubSolver(h, w, k, true);\n    List<List<Point>> answers = new ArrayList<>();\n    answers.addAll(subSolver1.solveList());\n    answers.addAll(subSolver2.solveList());\n    Collections.sort(answers, new Comparator<List<Point>>(){\n      public int compare(List<Point> l1, List<Point> l2) {\n        for (int i = 0; i < l1.size(); i++) {\n          int result = l1.get(i).compareTo(l2.get(i));\n          if (result != 0) {\n            return result;\n          }\n        }\n        return 0;\n      }\n    });\n    return answers;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int w = reader.nextInt();\n    int h = reader.nextInt();\n    int k = reader.nextInt();\n    out.println(new Solver(w, h, k).solve());\n//    out.println(new NaiveSolver(w, h, k).solve());\n//    out.printList(new NaiveSolver(w, h, k).solveList());\n//    out.printList(new Solver(w, h, k).solveList());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Point implements Comparable<Point> {\n  final long x, y;\n\n  Point(long x, long y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public int compareTo(Point point) {\n    if (this.x != point.x) {\n      return Long.compare(this.x, point.x);\n    }\n    return Long.compare(this.y, point.y);\n  }\n\n  public String toString() {\n    return String.format(\"(%d, %d)\", x, y);\n  }\n}\n\nclass NaiveSolver {\n  final int w, h, k;\n\n  NaiveSolver(int w, int h, int k) {\n    this.w = w;\n    this.h = h;\n    this.k = k;\n  }\n\n  private static long gcdRec(long a, long b) {\n    return a % b == 0 ? b : gcd(b, a % b);\n  }\n\n  private static long gcd(long a, long b) {\n    long absA = Math.abs(a);\n    long absB = Math.abs(b);\n    if (absA == 0 || absB == 0) {\n      return absA + absB;\n    }\n    return gcdRec(absA, absB);\n  }\n\n  private boolean accept(long x1, long y1, long x2, long y2, long x3, long y3) {\n    long dx2 = x2 - x1;\n    long dy2 = y2 - y1;\n    long dx3 = x3 - x1;\n    long dy3 = y3 - y1;\n    long sDouble = Math.abs(dx2 * dy3 - dx3 * dy2);\n    long g1 = gcd(x1 - x2, y1 - y2);\n    long g2 = gcd(x2 - x3, y2 - y3);\n    long g3 = gcd(x3 - x1, y3 - y1);\n    long g = g1 + g2 + g3;\n    return sDouble - g + 2 <= 2 * k;\n  }\n\n  public long solve() {\n    long answer = 0;\n    for (long x1 = 1; x1 < w; x1++) {\n      for (long y1 = 1; y1 < h; y1++) {\n        for (long x2 = 1; x2 < w; x2++) {\n          //(x1, 0), (0, y1), (x2, h)\n          //(x1, 0), (w, y1), (x2, h)\n          if (accept(x1, 0, 0, y1, x2, h)) {\n            answer++;\n          }\n          if (accept(x1, 0, w, y1, x2, h)) {\n            answer++;\n          }\n        }\n        for (long y2 = 1; y2 < h; y2++) {\n          //(x1, 0), (0, y1), (w, y2)\n          //(x1, h), (0, y1), (w, y2)\n          if (accept(x1, 0, 0, y1, w, y2)) {\n            answer++;\n          }\n          if (accept(x1, h, 0, y1, w, y2)) {\n            answer++;\n          }\n        }\n      }\n    }\n    return answer;\n  }\n\n  private void addAnswer(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    List<Point> list = List.of(new Point(x1, y1), new Point(x2, y2), new Point(x3, y3));\n    List<Point> sortedList = new ArrayList<>();\n    sortedList.addAll(list);\n    Collections.sort(sortedList);\n    answers.add(sortedList);\n  }\n\n  public List<List<Point>> solveList() {\n    List<List<Point>> answers = new ArrayList<>();\n    for (long x1 = 1; x1 < w; x1++) {\n      for (long y1 = 1; y1 < h; y1++) {\n        for (long x2 = 1; x2 < w; x2++) {\n          //(x1, 0), (0, y1), (x2, h)\n          //(x1, 0), (w, y1), (x2, h)\n          if (accept(x1, 0, 0, y1, x2, h)) {\n            addAnswer(answers, x1, 0L, 0L, y1, x2, (long)h);\n          }\n          if (accept(x1, 0, w, y1, x2, h)) {\n            addAnswer(answers, x1, 0L, (long)w, y1, x2, (long)h);\n          }\n        }\n        for (long y2 = 1; y2 < h; y2++) {\n          //(x1, 0), (0, y1), (w, y2)\n          //(x1, h), (0, y1), (w, y2)\n          if (accept(x1, 0, 0, y1, w, y2)) {\n            addAnswer(answers, x1, 0L, 0L, y1, (long)w, y2);\n          }\n          if (accept(x1, h, 0, y1, w, y2)) {\n            addAnswer(answers, x1, (long)h, 0L, y1, (long)w, y2);\n          }\n        }\n      }\n    }\n    Collections.sort(answers, new Comparator<List<Point>>(){\n      public int compare(List<Point> l1, List<Point> l2) {\n        for (int i = 0; i < l1.size(); i++) {\n          int result = l1.get(i).compareTo(l2.get(i));\n          if (result != 0) {\n            return result;\n          }\n        }\n        return 0;\n      }\n    });\n    return answers;\n  }\n}\n\nclass SubSolver {\n  final int w, h, k;\n  final boolean rotate;\n\n  SubSolver(int w, int h, int k, boolean rotate) {\n    this.w = w;\n    this.h = h;\n    this.k = k;\n    this.rotate = rotate;\n  }\n\n  private static long gcd(long a, long b) {\n    if (a == 0 || b == 0) {\n      return a + b;\n    }\n    return a % b == 0 ? b : gcd(b, a % b);\n  }\n\n  // P1: (x, 0)\n  // P2: (0, y)\n  // P3: (w, y + s)\n  // (0 < x < w),\n  // (0 < y < h)\n  // (0 <= s < h - 1)\n  // TriangleArea = NumLatticeInside + NumLatticeBoundary / 2 - 1\n  // NumLatticeInside = TriangleArea - NumLatticeBoundary / 2 + 1\n  // NumLatticeInside <= k\n  // TriangleArea - NumLatticeBoundary / 2 + 1 <= k\n  // 2 * TriangleArea - NumLatticeBoundary + 2 <= 2k\n  // TriangleArea\n  // = (y + y + s) * w / 2 - x * y / 2 - (w - x) * (y + s) / 2\n  // = yw + sw/2 - xy/2 - wy/2 - ws/2 + xy/2 + xs/2\n  // = yw/2 + xs/2\n  // NumLatticeBoundary\n  // = gcd(s, w) + gcd(x, y) + gcd(w - x, y + s)\n  // 2 * (yw / 2 + xs/2) - gcd(s, w) - gcd(x, y) - gcd(w - x, y + s) + 2 <= 2k\n  // wy - gcd(x, y) - gcd(w - x, y + s) <= 2k + gcd(s, w) - xs - 2\n  // 2k + gcd(s, w) - xs - 2 >= 0\n  // sx <= 2k + gcd(s, w) - 2 <= 2k + w - 2\n  public long solve() {\n    long answer = 0;\n    // s == 0\n    for (long x = 1; x < w; x++) {\n      answer += solve(0, x);\n    }\n\n    for (long s = 1; s < h - 1; s++) {\n      long gcdSw = gcd(s, w);\n      for (long x = 1; x < w && s * x <= 2 * k + gcdSw - 2; x++) {\n        answer += 2 * solve(s, x);\n      }\n    }\n\n    return answer;\n  }\n\n  private long solve(long s, long x) {\n    long r = 2 * k + gcd(s, w) - s * x - 2;\n    // y + s < h\n    // y < h - s\n    // y <= h - s - 1\n    long answer = Math.min(r / w, h - s - 1);\n    if (accept(s, x, r, r / w + 1)) {\n      answer++;\n    }\n    return answer;\n  }\n\n  private boolean accept(long s, long x, long r, long y) {\n    return y + s < h && w * y - gcd(x, y) - gcd(w - x, y + s) <= r;\n  }\n\n  public List<List<Point>> solveList() {\n    List<List<Point>> answers = new ArrayList<>();\n    // s == 0\n    for (long x = 1; x < w; x++) {\n      answers.addAll(solveList(0, x));\n    }\n\n    for (long s = 1; s < h - 1; s++) {\n      long gcdSw = gcd(s, w);\n      for (long x = 1; x < w && s * x <= 2 * k + gcdSw - 2; x++) {\n        answers.addAll(solveList(s, x));\n      }\n    }\n\n    return answers;\n  }\n\n  private List<List<Point>> solveList(long s, long x) {\n    List<List<Point>> answers = new ArrayList<>();\n\n    long r = 2 * k + gcd(s, w) - s * x - 2;\n    for (int y = 1; y <= r / w && y + s < h; y++) {\n      addAnswer(answers, s, x, y);\n    }\n    if (accept(s, x, r, r / w + 1)) {\n      addAnswer(answers, s, x, r / w + 1);\n    }\n    return answers;\n  }\n\n  private void addAnswer(List<List<Point>> answers, long s, long x, long y) {\n    if (y + s < 0 || y + s > h) {\n      System.err.printf(\"%d %d %d\\n\", s, x, y);\n      throw new RuntimeException();\n    }\n    {\n      addAnswer1(answers, x,     0, 0, y, w, y + s);\n    }\n    if (s != 0) {\n      addAnswer1(answers, w - x, 0, w, y, 0, y + s);\n    }   \n  }\n\n  private void addAnswer1(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    if (y3 < 0 || y3 > h) {\n      System.err.printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n      throw new RuntimeException();\n    }\n    addAnswer2(answers, x1, y1, x2, y2, x3, y3);\n    addAnswer2(answers, x1, h - y1, x2, h - y2, x3, h - y3);\n  }\n\n  private void addAnswer2(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    if (x1 < 0 || x2 < 0 || x3 < 0 || y1 < 0 || y2 < 0 || y3 < 0) {\n      System.err.printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n      throw new RuntimeException();\n    }\n    if (!rotate) {\n      addAnswer3(answers, x1, y1, x2, y2, x3, y3);\n    } else {\n      addAnswer3(answers, y1, x1, y2, x2, y3, x3);\n    }\n  }\n\n  private void addAnswer3(List<List<Point>> answers, long x1, long y1, long x2, long y2, long x3, long y3) {\n    if (x1 < 0 || x2 < 0 || x3 < 0 || y1 < 0 || y2 < 0 || y3 < 0) {\n      System.err.printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n      throw new RuntimeException();\n    }\n    List<Point> list = List.of(new Point(x1, y1), new Point(x2, y2), new Point(x3, y3));\n    List<Point> sortedList = new ArrayList<>();\n    sortedList.addAll(list);\n    Collections.sort(sortedList);\n    answers.add(sortedList);\n  }\n}\n\nclass Solver {\n  final int w, h, k;\n\n  Solver(int w, int h, int k) {\n    this.w = w;\n    this.h = h;\n    this.k = k;\n  }\n\n  public long solve() {\n    SubSolver subSolver1 = new SubSolver(w, h, k, false);\n    SubSolver subSolver2 = new SubSolver(h, w, k, true);\n    long answer1 = subSolver1.solve();\n    long answer2 = subSolver2.solve();\n    return 2 * (answer1 + answer2);\n  }\n\n  public List<List<Point>> solveList() {\n    SubSolver subSolver1 = new SubSolver(w, h, k, false);\n    SubSolver subSolver2 = new SubSolver(h, w, k, true);\n    List<List<Point>> answers = new ArrayList<>();\n    answers.addAll(subSolver1.solveList());\n    answers.addAll(subSolver2.solveList());\n    Collections.sort(answers, new Comparator<List<Point>>(){\n      public int compare(List<Point> l1, List<Point> l2) {\n        for (int i = 0; i < l1.size(); i++) {\n          int result = l1.get(i).compareTo(l2.get(i));\n          if (result != 0) {\n            return result;\n          }\n        }\n        return 0;\n      }\n    });\n    return answers;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int w = reader.nextInt();\n    int h = reader.nextInt();\n    int k = reader.nextInt();\n    out.println(new Solver(w, h, k).solve());\n//    out.println(new NaiveSolver(w, h, k).solve());\n//    out.printList(new NaiveSolver(w, h, k).solveList());\n//    out.printList(new Solver(w, h, k).solveList());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO.Pipes;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AtCoder {\n    class Triangles {\n        static int gcd(int a, int b) {\n            while (a>0 && b>0) {\n                if (a>b) {\n                    a %= b;\n                } else {\n                    b %= a;\n                }\n            }\n            return a + b;\n        }\n\n        static long solve(int W, int H, int K) {\n            int[] gcdMemo = new int[H + 1];\n            for (int h = 0; h <= H; h++) {\n                gcdMemo[h] = gcd(W, h);\n            }\n\n            int lim = 2 * K - 2;\n\n            long ans = 0;\n            for (int x = 1; x < W; x++) {\n                for (int y1 = 1; y1 < H; y1++) {\n                    if (W * y1 - 2 * W > lim) {\n                        break;\n                    }\n\n                    // (W - x) * y1 + x * y2 <= lim\n                    // y2 <= (lim - (W - x) * y1) / x\n\n                    int maxTrivial = 0;\n                    if ((long)(W - x) * y1 <= lim) {\n                        maxTrivial = (lim - (W - x) * y1) / x;\n                    }\n\n                    maxTrivial = Math.Min(maxTrivial, H - 1);\n\n                    if (maxTrivial >= y1) {\n                        ans += 2 * (maxTrivial - y1) + 1;\n                    }\n\n                    for (int y2 = Math.Max(maxTrivial + 1, y1); y2 < H; y2++) {\n                        if ((long)(W - x) * y1 + (long)x * y2 - 2 * W > lim) {\n                            break;\n                        }\n\n                        if ((W - x) * y1 + x * y2 - gcd(x, y1) - gcd(W - x, y2) - gcdMemo[Math.Abs(y1 - y2)] <= lim) {\n                            ans += (y2 == y1 ? 1 : 2);\n                        }\n                    }\n                }\n            }\n            return 2 * ans;\n        }\n\n        public static void Main(string[] args) {\n            var parts = Console.ReadLine().Split(' ');\n            int W = int.Parse(parts[0]);\n            int H = int.Parse(parts[1]);\n            int K = int.Parse(parts[2]);\n\n            //Stopwatch tm = new Stopwatch();\n            //tm.Start();\n            long ans = solve(W, H, K) + solve(H, W, K);\n            //tm.Stop();\n\n            //Console.WriteLine(tm.ElapsedMilliseconds + \" ms\");\n            Console.WriteLine(ans);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO.Pipes;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AtCoder {\n    class Triangles {\n        static int gcd(int a, int b) {\n            while (a>0 && b>0) {\n                if (a>b) {\n                    a %= b;\n                } else {\n                    b %= a;\n                }\n            }\n            return a + b;\n        }\n\n        static int solve(int W, int H, int K) {\n            int[] gcdMemo = new int[H + 1];\n            for (int h = 0; h <= H; h++) {\n                gcdMemo[h] = gcd(W, h);\n            }\n\n            int lim = 2 * K - 2;\n\n            int ans = 0;\n            for (int x = 1; x < W; x++) {\n                for (int y1 = 1; y1 < H; y1++) {\n                    if ((long)W * y1 - 2 * W > lim) {\n                        break;\n                    }\n\n                    int g = -1;\n\n                    for (int y2 = y1; y2 < H; y2++) {\n                        if ((long)(W - x) * y1 + (long)x * y2 - 2 * W > lim) {\n                            break;\n                        }\n\n                        if (g == -1) {\n                            g = gcd(x, y1);\n                        }\n\n                        if ((W - x) * y1 + x * y2 - g - gcd(W - x, y2) - gcdMemo[Math.Abs(y1 - y2)] <= lim) {\n                            ans += (y1 == y2 ? 1 : 2);\n                        }\n                    }\n                }\n            }\n            return 2 * ans;\n        }\n\n        public static void Main(string[] args) {\n            var parts = Console.ReadLine().Split(' ');\n            int W = int.Parse(parts[0]);\n            int H = int.Parse(parts[1]);\n            int K = int.Parse(parts[2]);\n\n            //Stopwatch tm = new Stopwatch();\n            //tm.Start();\n            int ans = solve(W, H, K) + solve(H, W, K);\n            //tm.Stop();\n\n            //Console.WriteLine(tm.ElapsedMilliseconds + \" ms\");\n            Console.WriteLine(ans);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "#region いつもの\nusing AtCoderProject;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static AtCoderProject.Global;\nusing BigInteger = System.Numerics.BigInteger;\nusing BitOperations = System.Numerics.BitOperations;\nusing IEnumerable = System.Collections.IEnumerable;\nusing IEnumerator = System.Collections.IEnumerator;\nusing StringBuilder = System.Text.StringBuilder;\nusing Unsafe = System.Runtime.CompilerServices.Unsafe;\n\nnamespace AtCoderProject { using System.IO; using System.Text; using System.Diagnostics; using System.Runtime.CompilerServices; using System.Linq.Expressions; public static class Global { public static T[] NewArray<T>(int len0, T value) => new T[len0].Fill(value); public static T[] NewArray<T>(int len0, Func<T> factory) { var arr = new T[len0]; for (int i = 0; i < arr.Length; i++) arr[i] = factory(); return arr; } public static T[][] NewArray<T>(int len0, int len1, T value) where T : struct { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, value); return arr; } public static T[][] NewArray<T>(int len0, int len1, Func<T> factory) { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, factory); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, T value) where T : struct { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, value); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, Func<T> factory) { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, factory); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, T value) where T : struct { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, value); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, Func<T> factory) { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, factory); return arr; } public static int Pow(int x, int y) { int res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static BigInteger ParseBigInteger(ReadOnlySpan<char> s) { /* 自前実装の方が速い */ BigInteger res; if (s.Length % 9 == 0) res = 0; else { res = new BigInteger(int.Parse(s.Slice(0, s.Length % 9))); s = s.Slice(s.Length % 9); } while (s.Length > 0) { var sp = s.Slice(0, 9); res *= 1000_000_000; res += int.Parse(sp); s = s.Slice(9); } return res; } public static int PopCount(int x) => BitOperations.PopCount((uint)x); public static int PopCount(long x) => BitOperations.PopCount((ulong)x); public static int PopCount(ulong x) => BitOperations.PopCount(x); public static int MSB(int x) => BitOperations.Log2((uint)x); public static int MSB(uint x) => BitOperations.Log2(x); public static int MSB(long x) => BitOperations.Log2((ulong)x); public static int MSB(ulong x) => BitOperations.Log2(x); public static int LSB(int x) => BitOperations.TrailingZeroCount((uint)x); public static int LSB(uint x) => BitOperations.TrailingZeroCount(x); public static int LSB(long x) => BitOperations.TrailingZeroCount((ulong)x); public static int LSB(ulong x) => BitOperations.TrailingZeroCount(x); } public static class Ext { public static bool UpdateMax(this ref int r, int val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMax(this ref long r, long val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMin(this ref int r, int val) { if (r > val) { r = val; return true; } return false; } public static bool UpdateMin(this ref long r, long val) { if (r > val) { r = val; return true; } return false; } public static long ToLong(this int i) => i; public static T[] Fill<T>(this T[] arr, T value) { Array.Fill(arr, value); return arr; } public static T[] Sort<T>(this T[] arr) { Array.Sort(arr); return arr; } public static string[] Sort(this string[] arr) => Sort(arr, StringComparer.OrdinalIgnoreCase); public static T[] Sort<T, U>(this T[] arr, Expression<Func<T, U>> selector) where U : IComparable<U> => Sort(arr, new ExpComparer<T, U>(selector)); public static T[] Sort<T>(this T[] arr, Comparison<T> comparison) { Array.Sort(arr, comparison); return arr; } public static T[] Sort<T>(this T[] arr, IComparer<T> comparer) { Array.Sort(arr, comparer); return arr; } public static T[] Reverse<T>(this T[] arr) { Array.Reverse(arr); return arr; } public static (int index, T max) MaxBy<T>(this T[] arr) where T : IComparable<T> { T max = arr[0]; int maxIndex = 0; for (int i = 0; i < arr.Length; i++) { if (max.CompareTo(arr[i]) < 0) { max = arr[i]; maxIndex = i; } } return (maxIndex, max); } public static (TSource item, TMax max) MaxBy<TSource, TMax>(this IEnumerable<TSource> source, Func<TSource, TMax> maxBySelector) where TMax : IComparable<TMax> { TMax max; TSource maxByItem; var e = source.GetEnumerator(); e.MoveNext(); maxByItem = e.Current; max = maxBySelector(maxByItem); while (e.MoveNext()) { var item = e.Current; var next = maxBySelector(item); if (max.CompareTo(next) < 0) { max = next; maxByItem = item; } } return (maxByItem, max); } public static (int index, T min) MinBy<T>(this T[] arr) where T : IComparable<T> { T min = arr[0]; int minIndex = 0; for (int i = 0; i < arr.Length; i++) { if (min.CompareTo(arr[i]) > 0) { min = arr[i]; minIndex = i; } } return (minIndex, min); } public static (TSource item, TMin min) MinBy<TSource, TMin>(this IEnumerable<TSource> source, Func<TSource, TMin> minBySelector) where TMin : IComparable<TMin> { TMin min; TSource minByItem; var e = source.GetEnumerator(); e.MoveNext(); minByItem = e.Current; min = minBySelector(minByItem); while (e.MoveNext()) { var item = e.Current; var next = minBySelector(item); if (min.CompareTo(next) > 0) { min = next; minByItem = item; } } return (minByItem, min); } public static IComparer<T> Reverse<T>(this IComparer<T> comparer) => Comparer<T>.Create((x, y) => comparer.Compare(y, x)); public static Dictionary<TKey, int> GroupCount<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => source.GroupBy(keySelector).ToDictionary(g => g.Key, g => g.Count()); public static Dictionary<TKey, int> GroupCount<TKey>(this IEnumerable<TKey> source) => source.GroupCount(i => i); public static ref T Get<T>(this T[] arr, int index) { if (index < 0) return ref arr[arr.Length + index]; return ref arr[index]; } public static TValue Get<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key) { dic.TryGetValue(key, out var v); return v; } public static TValue GetOrInit<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key, TValue value) { if (dic.TryGetValue(key, out var v)) return v; return dic[key] = value; } } public class ExpComparer<T, K> : IComparer<T> where K : IComparable<K> { private class ParameterReplaceVisitor : ExpressionVisitor { private readonly ParameterExpression from; private readonly ParameterExpression to; public ParameterReplaceVisitor(ParameterExpression from, ParameterExpression to) { this.from = from; this.to = to; } protected override Expression VisitParameter(ParameterExpression node) => node == from ? to : base.VisitParameter(node); } private readonly Func<T, T, int> func; public ExpComparer(Expression<Func<T, K>> expression) { var paramA = expression.Parameters[0]; var paramB = Expression.Parameter(typeof(T)); var f2 = (Expression<Func<T, K>>)new ParameterReplaceVisitor(expression.Parameters[0], paramB).Visit(expression); var compExp = Expression.Lambda<Func<T, T, int>>(Expression.Call(expression.Body, typeof(K).GetMethod(nameof(IComparable<K>.CompareTo), new[] { typeof(K) }), f2.Body), paramA, paramB); this.func = compExp.Compile(); } public int Compare(T x, T y) => func(x, y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ReverseComparer<T> : IComparer<T> where T : IComparable<T> { private static ReverseComparer<T> defaultComparer; public static IComparer<T> Default => defaultComparer ??= new ReverseComparer<T>(); public int Compare(T y, T x) => x.CompareTo(y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ΔDebugView<T> { private IEnumerable<T> collection; public ΔDebugView(IEnumerable<T> collection) { this.collection = collection ?? throw new ArgumentNullException(nameof(collection)); }[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public T[] Items => collection.ToArray(); }[DebuggerStepThrough] public class ConsoleReader { const int BufSize = 1 << 12; private readonly byte[] buffer = new byte[BufSize]; private readonly Stream input; private readonly Encoding encoding; private int pos = 0; private int len = 0; public ConsoleReader(Stream input, Encoding encoding) { this.input = input; this.encoding = encoding; } public ConsoleReader(Stream input) : this(input, Console.InputEncoding) { } private void MoveNext() { if (++pos >= len) { len = input.Read(buffer, 0, buffer.Length); if (len == 0) { buffer[0] = 10; } pos = 0; } } public int Int { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { int res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = checked(res * 10 + (buffer[pos] ^ 48)); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public int Int0 => this.Int - 1; public long Long { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { long res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = res * 10 + (buffer[pos] ^ 48); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public long Long0 => this.Long - 1; public string String { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return this.encoding.GetString(sb.ToArray()); } } public string Ascii { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new StringBuilder(); while (buffer[pos] <= 32) MoveNext(); do { sb.Append((char)buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return sb.ToString(); } } public string Line { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (buffer[pos] != 10 && buffer[pos] != 13); return this.encoding.GetString(sb.ToArray()); } } public char Char { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { while (buffer[pos] <= 32) MoveNext(); char res = (char)buffer[pos]; MoveNext(); return res; } } public double Double => double.Parse(this.Ascii);[DebuggerStepThrough] public struct RepeatReader { ConsoleReader cr; int count; public RepeatReader(ConsoleReader cr, int count) { this.cr = cr; this.count = count; } public T[] Select<T>(Func<ConsoleReader, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr); return arr; } public T[] Select<T>(Func<ConsoleReader, int, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr, i); return arr; } public string[] Line { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Line; return arr; } } public string[] String { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.String; return arr; } } public string[] Ascii { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Ascii; return arr; } } public int[] Int { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int; return arr; } } public int[] Int0 { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int0; return arr; } } public long[] Long { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long; return arr; } } public long[] Long0 { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long0; return arr; } } public double[] Double { get { var arr = new double[count]; for (var i = 0; i < count; i++) arr[i] = cr.Double; return arr; } } public static implicit operator int[](RepeatReader rr) => rr.Int; public static implicit operator long[](RepeatReader rr) => rr.Long; public static implicit operator double[](RepeatReader rr) => rr.Double; public static implicit operator string[](RepeatReader rr) => rr.Ascii; } public RepeatReader Repeat(int count) => new RepeatReader(this, count);[DebuggerStepThrough] public struct SplitReader { ConsoleReader cr; public SplitReader(ConsoleReader cr) { this.cr = cr; } public string[] String { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.String); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public string[] Ascii { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Ascii); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public double[] Double { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<double>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Double); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public static implicit operator int[](SplitReader sr) => sr.Int; public static implicit operator long[](SplitReader sr) => sr.Long; public static implicit operator double[](SplitReader sr) => sr.Double; public static implicit operator string[](SplitReader sr) => sr.Ascii; } public SplitReader Split => new SplitReader(this); public static implicit operator int(ConsoleReader cr) => cr.Int; public static implicit operator long(ConsoleReader cr) => cr.Long; public static implicit operator double(ConsoleReader cr) => cr.Double; public static implicit operator string(ConsoleReader cr) => cr.Ascii; public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2) => (o1, o2) = (this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3) => (o1, o2, o3) = (this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4) => (o1, o2, o3, o4) = (this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5) => (o1, o2, o3, o4, o5) = (this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6) => (o1, o2, o3, o4, o5, o6) = (this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7) => (o1, o2, o3, o4, o5, o6, o7) = (this, this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7, out ConsoleReader o8) => (o1, o2, o3, o4, o5, o6, o7, o8) = (this, this, this, this, this, this, this, this); }[DebuggerStepThrough] public class ConsoleWriter {[DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly StreamWriter sw; public ConsoleWriter(Stream output) : this(output, Console.OutputEncoding) { } public ConsoleWriter(Stream output, Encoding encoding) { sw = new StreamWriter(output, encoding); } public void Flush() => sw.Flush(); public ConsoleWriter WriteLine(ReadOnlySpan<char> obj) { sw.WriteLine(obj); return this; } public ConsoleWriter WriteLine<T>(T obj) { sw.WriteLine(obj.ToString()); return this; } public ConsoleWriter WriteLineJoin<T>(ReadOnlySpan<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T>(IEnumerable<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLines<T>(ReadOnlySpan<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLines<T>(IEnumerable<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLineGrid<T>(IEnumerable<IEnumerable<T>> cols) { var en = cols.GetEnumerator(); while (en.MoveNext()) WriteLineJoin(en.Current); return this; } private ConsoleWriter WriteMany<T>(char sep, ReadOnlySpan<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } private ConsoleWriter WriteMany<T>(char sep, IEnumerable<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } } }\npublic partial class Program {[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleReader cr;[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleWriter cw; public Program(ConsoleReader reader, ConsoleWriter writer) { this.cr = reader; this.cw = writer; System.Globalization.CultureInfo.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture; } static void Main() => new Program(new ConsoleReader(Console.OpenStandardInput()), new ConsoleWriter(Console.OpenStandardOutput())).Run(); public void Run() { var res = Calc(); if (res is double) cw.WriteLine(Result((double)res)); else if (res is bool) cw.WriteLine(Result((bool)res)); else if (res != null) cw.WriteLine(res.ToString()); cw.Flush(); } }\npublic partial class Program\n{\n    public static string Result(double d) => d.ToString(\"0.####################\", System.Globalization.CultureInfo.InvariantCulture);\n    #endregion\n    public static string Result(bool b) => b ? \"Yes\" : \"No\";\n    private object Calc()\n    {\n        int W = cr;\n        int H = cr;\n        K = cr;\n        return Calc(W, H).Concat(Calc(H, W)).Sum(l => l << 1);\n    }\n    private IEnumerable<long> Calc(int W, int H)\n    {\n        for (int x = 1; x < W; x++)\n            for (long s = Math.Min((2L * K + W - 2) / x, H - 2); s >= 0; s--)\n            {\n                long res = 0;\n                var R = 2L * K + Gcd(s, W) - s * x - 2;\n                if (R < 0) continue;\n                var y1 = R / W;\n                res += Math.Min(y1++, H - s - 1);\n                var l = W * y1 - Gcd(x, y1) - Gcd(W - x, y1 + s);\n                if (y1 < H - s && l <= R) res++;\n                if (s != 0) res <<= 1;\n                yield return res;\n            }\n    }\n    int K;\n    long Gcd(long a, long b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b));\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nlong solve(long X, long Y, long K) {\n  const limArea = K + min(X, Y) - 1;\n  const limY = (2 * limArea) / X;\n  long ans;\n  foreach (x; 1 .. X) {\n    const limY1 = min((2 * limArea) / x, Y - 1);\n    auto g0 = new long[limY1 + 1];\n    auto g1 = new long[limY1 + 1];\n    foreach (y; 1 .. limY1 + 1) {\n      g0[y] = gcd(x, y);\n      g1[y] = gcd(X - x, y);\n    }\n    foreach (y; 1 .. limY1 + 1) {\n      if (((X * y) - (g0[y] + g1[y] + X)) / 2 + 1 <= K) {\n        ans += 1;\n      }\n    }\n    foreach (d; 1 .. Y - 1) {\n      if (x * d > 2 * limArea) {\n        break;\n      }\n      const g2 = gcd(X, d);\n      long lo = 0, hi = limY1 - d + 1;\n      for (; lo + 1 < hi; ) {\n        const mid = (lo + hi) / 2;\n        ((((X * (mid + d) - (X - x) * d) - (g0[mid] + g1[mid + d] + g2)) / 2 + 1 <= K) ? lo : hi) = mid;\n      }\n      ans += 2 * lo;\n    }\n  }\n  \n  debug {\n    if (X <= 100 && Y <= 100) {\n      long brt;\n      foreach (x; 1 .. X) foreach (y0; 1 .. Y) foreach (y1; y0 .. Y) {\n        if (((X * y1 - (X - x) * (y1 - y0)) - (gcd(x, y0) + gcd(X - x, y1) + gcd(X, y1 - y0))) / 2 + 1 <= K) {\n          brt += (y0 == y1) ? 1 : 2;\n        }\n      }\n      writeln(\"brt = \", brt, \", ans = \", ans);\n      assert(brt == ans);\n    }\n  }\n  \n  return ans;\n}\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const W = readInt();\n      const H = readInt();\n      const K = readInt();\n      \n      long ans;\n      ans += solve(W, H, K);\n      ans += solve(H, W, K);\n      ans *= 2;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nlong solve(long X, long Y, long K) {\n  const limArea = K + max(X, Y);\n  long ans;\n  foreach (x; 1 .. X) {\n    const limY1 = min((2 * limArea) / x, Y - 1);\n    auto g0 = new long[limY1 + 1];\n    auto g1 = new long[limY1 + 1];\n    foreach (y; 0 .. limY1 + 1) {\n      g0[y] = gcd(x, y);\n      g1[y] = gcd(X - x, y);\n    }\n    foreach (y; 1 .. limY1 + 1) {\n      if (((X * y) - (g0[y] + g1[y] + X)) / 2 + 1 <= K) {\n        ans += 1;\n      }\n    }\n    foreach (d; 1 .. limY1) {\n      const g2 = gcd(X, d);\n      long lo = 0, hi = limY1 - d + 1;\n      for (; lo + 1 < hi; ) {\n        const mid = (lo + hi) / 2;\n        ((((X * (mid + d) - (X - x) * d) - (g0[mid] + g1[mid + d] + g2)) / 2 + 1 <= K) ? lo : hi) = mid;\n      }\n      ans += 2 * lo;\n    }\n  }\n  \n  debug {\n    if (X <= 100 && Y <= 100) {\n      long brt;\n      foreach (x; 1 .. X) foreach (y0; 1 .. Y) foreach (y1; y0 .. Y) {\n        if (((X * y1 - (X - x) * (y1 - y0)) - (gcd(x, y0) + gcd(X - x, y1) + gcd(X, y1 - y0))) / 2 + 1 <= K) {\n          brt += (y0 == y1) ? 1 : 2;\n        }\n      }\n      writeln(\"brt = \", brt, \", ans = \", ans);\n      assert(brt == ans);\n    }\n  }\n  \n  return ans;\n}\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const W = readInt();\n      const H = readInt();\n      const K = readInt();\n      \n      long ans;\n      ans += solve(W, H, K);\n      ans += solve(H, W, K);\n      ans *= 2;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "w, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(1,h,1):\n\n            pc =0\n            for x in range(1,h,1):\n                for y in range(1,w,1):\n                    if y<a+a/c*x and y>a-a/b*x and x< (c-b)/w*y+b:\n\n                        pc =pc+1\n\n            if pc <=k:\n                count =count +2\n\nw2 = w\nw =h\nh=w2\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(1,h,1):\n\n            pc =0\n            for x in range(1,h,1):\n                for y in range(1,w,1):\n                    if y<a+a/c*x and y>a-a/b*x and x< (c-b)/w*y+b:\n\n                        pc =pc+1\n            if pc <=k:\n                count =count +2\n\n\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "a,v=map(int,input().split())\nb,w=map(int,input().split())\nt=int(input())\nx=a-b\ny=abs(x)\nif v*t>=(y+w*t):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
  },
  {
    "language": "Python",
    "code": "from functions import gcd\n\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+math.gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+math.gcd(w, c-b)-1)/2)\n      \n                if pc <=k:\n                    count =count +4\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef count_h(y1, y2, w):\n    n = y1 * (w + 1)\n    if y2 == y1:\n        n += (w + 1)\n    else:\n        n += int((y2 - y1 + 1) * (w + 1) / 2 + 1)\n    return n - 2\n\n\ndef count_xy(x, y):\n    return int(((x+1) * (y+1) + 1) / 2) + 1 - 2\n\n\ndef test_count():\n    assert count_xy(1, 1) == 1\n    assert count_xy(1, 2) == 2\n    assert count_xy(2, 2) == 4\n    assert count_h(0, 0, 3) == 2\n    assert count_h(0, 1, 3) == 3\n    assert count_h(0, 2, 3) == 5\n    assert (3*4) - count_xy(1, 1) - count_xy(1, 1) - count_h(2, 2, 2) - 3 == 0\n\ndef count_k(w, h, k):\n    result = 0\n    for x1 in range(1, w+1):\n        count = 0\n        for y1 in range(1, h+1):\n            for y2 in range(y1, h+1):\n                dot = (1+w) * (1+h) - count_xy(x1, y1) - count_xy(w-x1, y2) - count_h(h-y1, h-y2, w) - 3\n                if dot == k:\n                    #print([x1, 0], [0, y1], [w, y2], \"match\")\n                    count = count + 1 if y1 == y2 else count + 2\n                else:\n                    #print([x1, 0], [0, y1], [w, y2], \"not\", dot)\n                    assert dot >= 0\n            for x2 in range(x1, w+1):\n                dot = (1+w) * (1+h) - count_xy(x1, y1) - count_xy(x2, h-y2) - count_h(w-x1, w-x2, h) - 3\n                if dot == k:\n                    #print([x1, 0], [0, y1], [w, y2], \"match\")\n                    count = count + 1 if x1 == x2 else count + 2\n                else:\n                    #print([x1, 0], [0, y1], [w, y2], \"not\", dot)\n                    assert dot >= 0\n        if w/2 != x1:\n            count *= 2\n        result += count\n    return result\n\n\nw, h, k = map(int, sys.stdin.readline().split())\nprint(count_k(w, h, k))\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+math.gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+math.gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nprint(count)"
  },
  {
    "language": "Python",
    "code": "fgf"
  },
  {
    "language": "Python",
    "code": "W, H, K = list(map(int,input().split()))\n\ncounter = int(0)\ntriangle_counter = 0\n\nif (W <= 2 or H == 1):\n  print(0)\nelse:\n  for i in range(1, H):\n    for j in range(1, W):\n      for k in range(j, W):\n        counter = 0\n        if (j == k): # 三角形の1辺がy軸と垂直\n          for l in range(1,j):\n            counter += int((H-float(i))/float(k)*l+float(i)/float(j)*l)\n          if(counter <= K):\n            triangle_counter +=2\n        else: # j < k\n          for m in range(1,j):\n            counter += int((H-float(i))/float(k)*m+float(i)/float(j)*m)\n          for n in range (j, W):\n            counter += int((H-float(i))/float(k)*n+i-H*n/(float(k)-float(j)-H*j/(1+j)))\n          if(counter == K):\n            triangle_counter += 4\n  print(triangle_counter)"
  },
  {
    "language": "Python",
    "code": "1"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport sys\nreadline = sys.stdin.buffer.readline\ndef main():\n  r=0\n  w,h,k=map(int,readline().split())\n  for a in range(1,w):\n    for b in range(1,h):\n      for c in range(1,w):\n        s=(h-b)*a+b*a+b*c\n        if s<=2*(k+h):\n          r+=1\n  for a in range(1,h):\n    for b in range(1,w):\n      for c in range(1,h):\n        s=(w-b)*a+b*a+b*c\n        if s<=2*k:\n          r+=1\n  print(r*2)         \nmain()"
  },
  {
    "language": "Python",
    "code": "from math import gcd\n\ninput1 = input().split()\nW = int(input1[0])\nH = int(input1[1])\nK = int(input1[2])\n\ndef NumOfGrid(tup1: list, tup2: list):\n    return gcd((abs(tup1[0]-tup2[0]), abs(tup1[1]-tup2[1]))) -1\n\ndef Sur(p1, p2, p3):\n    p22 = [(p2[0]-p1[0]), (p2[1]-p1[1])]\n    p23 = [(p3[0]-p1[0]), (p3[1]-p1[1])]\n    return abs(p22[0]*p23[1] - p23[0]*p22[1])/2\n\ndef Koshiten(p1:list, p2: list, p3: list):\n    return int(Sur(p1,p2,p3)-(NumOfGrid(p1, p2)+NumOfGrid(p2,p3)+NumOfGrid(p3,p1)-3)-1)\n\ndef Triangles(p1,p2,p3,K):\n    if Koshiten(p1,p2,p3) <= K:\n        return True\n    else:\n        return False\n\nResult = 0\n\nfor a in range(2, H):\n    p1 = [0, a]\n    for b in range(2,W):\n        p2 = [b, H]\n        for c in range(2, W):\n            p3 = [c, 0]\n            if Triangles(p1,p2,p3,K) == True:\n                Result += 1\n        for c in range(2, H):\n            p3 = [W, c]\n            if Triangles(p1,p2,p3,K) == True:\n                Result += 1\nprint(Result)"
  },
  {
    "language": "Python",
    "code": "import math\n\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+math.gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+math.gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+math.gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+math.gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n\n                pc = (w-1)*(c-1) - ((w-a-1)*(c-1)-math.gcd(w-a, c)+1)/2 - ((a-1)*(b-1)-math.gcd(a, b)+1)/2\n                if pc <=k:\n                    count =count +2\n            else:\n                pc = (w-1)*(c-1) - ((w-a-1)*(c-1)-math.gcd(w-a, c)+1)/2 - ((a-1)*(b-1)-math.gcd(a, b)+1)/2 - ((w-1)*(c-b-1)-math.gcd(w, c-b)+1)/2\n\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n\n                pc = (w-1)*(c-1) - ((w-a-1)*(c-1)-math.gcd(w-a, c)+1)/2 - ((a-1)*(b-1)-math.gcd(a, b)+1)/2\n                if pc <=k:\n                    count =count +2\n            else:\n                pc = (w-1)*(c-1) - ((w-a-1)*(c-1)-math.gcd(w-a, c)+1)/2 - ((a-1)*(b-1)-math.gcd(a, b)+1)/2 - ((w-1)*(c-b-1)-math.gcd(w, c-b)+1)/2\n\n\n                if pc <=k:\n                    count =count +4\n\n\n\nprint(count)"
  },
  {
    "language": "Python",
    "code": "w,h,k = (int(x) for x in input().split())\n\nw -= 1\nh -= 1\na = w * h * w \nb = h * w * h\n\nprint((a+b)*2)"
  },
  {
    "language": "Python",
    "code": "from functions import gcd\n\nw, h, k = map(int, input().split())\n\ncount =0\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nw2 = w\nw =h\nh=w2\n\n\n\nfor a in range(1,w,1):\n    for b in range(1,h,1):\n        for c in range(b,h,1):\n\n            if b==c:\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2)\n                if pc <=k:\n                    count =count +2\n            else:\n\n                pc = (w-1)*(c-1) - int(((w-a-1)*(c-1)+gcd(w-a, c)-1)/2) - int(((a-1)*(b-1)+gcd(a, b)-1)/2) - int(((w-1)*(c-b-1)+gcd(w, c-b)-1)/2)\n\n                if pc <=k:\n                    count =count +4\n\nprint(count)\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, [graph1; $len:expr]) => {{\n        let mut g = vec![vec![]; $len];\n        let ab = read_value!($next, [(usize1, usize1)]);\n        for (a, b) in ab {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        g\n    }};\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n    ($next:expr, usize1) => (read_value!($next, usize) - 1);\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        read_value!($next, [$t; len])\n    }};\n    ($next:expr, $t:ty) => ($next().parse::<$t>().expect(\"Parse error\"));\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn gcd(x: i64, y: i64) -> i64 {\n    if y == 0 {\n        x\n    } else {\n        gcd(y, x % y)\n    }\n}\n\nfn calc(w: i64, h: i64, k: i64) -> i64 {\n    let lim = 2 * k - 2 + w + 2 * min(h, w);\n    let mut ans: i64 = 0;\n    for b in 1..h {\n        for c in 1..=min(w - 1, lim / b) {\n            let det = 2 * k - 2 + gcd(w - c, b);\n            let lim = det + c + w;\n            let sup = min(h - 1, (lim - b * c) / (w - c));\n            let inf = min(max(sup, 0), max(0, (det - b * c) / (w - c)));\n            ans += inf;\n            for a in inf + 1..=sup {\n                if a * (w - c) + b * c <= det + gcd(a, c)\n                     + gcd(w, (a - b).abs()) {\n                        ans += 1;\n                    }\n            }\n        }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        w: i64, h: i64, k: i64,\n    }\n    puts!(\"{}\\n\", 2 * (calc(w, h, k) + calc(h, w, k)));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, [graph1; $len:expr]) => {{\n        let mut g = vec![vec![]; $len];\n        let ab = read_value!($next, [(usize1, usize1)]);\n        for (a, b) in ab {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        g\n    }};\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n    ($next:expr, usize1) => (read_value!($next, usize) - 1);\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        read_value!($next, [$t; len])\n    }};\n    ($next:expr, $t:ty) => ($next().parse::<$t>().expect(\"Parse error\"));\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn gcd(x: i64, y: i64) -> i64 {\n    if y == 0 {\n        x\n    } else {\n        gcd(y, x % y)\n    }\n}\n\nfn calc(w: i64, h: i64, k: i64) -> i64 {\n    let mut ans: i64 = 0;\n    for b in 1..h {\n        let lim = 2 * k - 2 + w + b + min(h, w);\n        for c in 1..=min(w - 1, lim / b) {\n            let det = 2 * k - 2 + gcd(w - c, b);\n            let lim = det + c + w;\n            let sup = min(h - 1, (lim - b * c) / (w - c));\n            let inf = min(max(sup, 0), max(0, (det - b * c) / (w - c)));\n            ans += inf;\n            for a in inf + 1..=sup {\n                if a * (w - c) + b * c <= det + gcd(a, c)\n                     + gcd(w, (a - b).abs()) {\n                        ans += 1;\n                    }\n            }\n        }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        w: i64, h: i64, k: i64,\n    }\n    puts!(\"{}\\n\", 2 * (calc(w, h, k) + calc(h, w, k)));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]